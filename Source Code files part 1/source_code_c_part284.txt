wszSurrogatePath);
        if ( SUCCEEDED(hr) )
        {
            /* DLL surrogate */            
            if ( m_pwszSurrogatePath == g_wszEmptyString )
            {
                CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: Found surrogate: dllhost\n"));
                m_eProcessType = ProcessTypeComPlus;
            }
            else
            {
                /* DllSurrogate value is present, use it */                
                CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: Found surrogate: %ws\n", m_pwszSurrogatePath));
                m_eProcessType = ProcessTypeLegacySurrogate;
            }
        }
        else
        {
            /* no DLL surrogate value */            
            CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: No surrogate, No service.\n", m_pwszSurrogatePath));
            m_eProcessType = ProcessTypeNormal;
        }
    }
    
    m_eRunAsType = RunAsLaunchingUser;
    
    hr = ReadRegistryStringValue(hKey, NULL, g_wszRunAs, FALSE, wszValue, sizeof(wszValue)/2);
    if ( SUCCEEDED(hr) && (wszValue[0] != L'\0') )
    {
        if ( lstrcmpiW(wszValue, g_wszInteractive_User) == 0 )
        {
            CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: Found RunAs: Interactive User\n"));
            m_eRunAsType = RunAsInteractiveUser;
        }
        else
        {
            CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: Found RunAs: %ws\n", wszValue));
            m_eRunAsType = RunAsSpecifiedUser;
            
            cchValue = lstrlenW(wszValue);
            
            pwch = wszValue;
            
            while ( *pwch != L'\0' )
            {
                if ( *pwch == L'\\' )
                {
                    break;
                }
                
                pwch++;
            }
            
            if ( *pwch == L'\0' )
            {
                m_pwszRunAsUser = (WCHAR *) new WCHAR[(sizeof(gpwszLocalMachineDomain)/sizeof(WCHAR)) + cchValue + 1];
                if ( m_pwszRunAsUser != NULL )
                {
                    lstrcpyW(m_pwszRunAsUser, gpwszLocalMachineDomain);
                    m_pwszRunAsUser[(sizeof(gpwszLocalMachineDomain)/sizeof(WCHAR))-1] = L'\\';
                    lstrcpyW(m_pwszRunAsUser + (sizeof(gpwszLocalMachineDomain)/sizeof(WCHAR)), wszValue);
                }
            }
            else
            {
                m_pwszRunAsUser = (WCHAR *) new WCHAR[cchValue + 1];
                if ( m_pwszRunAsUser != NULL )
                {
                    lstrcpyW(m_pwszRunAsUser, wszValue);
                }
            }
        }
    }

    m_fActivateAtStorage = FALSE;

    hr = ReadRegistryStringValue(hKey, NULL, g_wszActivateAtStorage, FALSE, wszValue, sizeof(wszValue)/2);
    if ( SUCCEEDED(hr) )
    {
        if ( (wszValue[0] == L'Y') || (wszValue[0] == L'y') )
        {
            m_fActivateAtStorage = TRUE;
        }
    }

    hr = GetRegistrySecurityDescriptor( hKey, g_wszLaunchPermission, &m_pLaunchPermission, NULL, &m_cbLaunchPermission);
    if ( SUCCEEDED(hr) )
    {
        m_dwFlags |= PROCESS_LAUNCHPERMISSION;
    }
    else if ( hr == REGDB_E_KEYMISSING )
    {
        m_dwFlags |= PROCESS_LAUNCHPERMISSION_DEFAULT;
    }

    dwCapabilities=0;
    hr = GetRegistrySecurityDescriptor( hKey, g_wszAccessPermission, &m_pAccessPermission, &dwCapabilities, &m_cbAccessPermission);
    if ( SUCCEEDED(hr) && dwCapabilities==0 )
    {
        m_dwFlags |= PROCESS_ACCESSPERMISSION;
    }
    else if ( hr == REGDB_E_KEYMISSING )
    {
        m_dwFlags |= PROCESS_ACCESSPERMISSION_DEFAULT;
    }

    if ( m_fGotLegacyLevels == FALSE )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( m_fGotLegacyLevels == FALSE )
        {
            res=RegOpenKeyExW(HKEY_LOCAL_MACHINE, g_wszHKLMOle, 0, KEY_READ, &hKeyOle);
            if ( ERROR_SUCCESS==res )
            {
                if ( m_pDefaultLaunchPermission != NULL )
                {
                    delete [] reinterpret_cast<unsigned char*>(m_pDefaultLaunchPermission);
                    m_pDefaultLaunchPermission = NULL;
                }

                if ( m_pDefaultAccessPermission != NULL )
                {
                    delete [] reinterpret_cast<unsigned char*>(m_pDefaultAccessPermission);
                    m_pDefaultAccessPermission=NULL;
                }

                hr = GetRegistrySecurityDescriptor( hKeyOle, g_wszDefaultLaunchPermission, &m_pDefaultLaunchPermission, NULL, &m_cbDefaultLaunchPermission);
                if ( FAILED(hr) )
                {
                    CatalogMakeSecDesc(&m_pDefaultLaunchPermission, NULL);
                }

                dwCapabilities=0;
                hr = GetRegistrySecurityDescriptor( hKeyOle, g_wszDefaultAccessPermission, &m_pDefaultAccessPermission, &dwCapabilities, &m_cbDefaultAccessPermission);
                if ( FAILED(hr) )
                {
                    dwCapabilities=0;
                    CatalogMakeSecDesc(&m_pDefaultAccessPermission, &dwCapabilities);
                }

                cbValue = sizeof(DWORD);

                res = RegQueryValueExW(hKeyOle, g_wszLegacyAuthenticationLevel, NULL, &dwValueType,
                                       (unsigned char *) &dwValue, &cbValue);
                if ( (ERROR_SUCCESS==res) && (dwValueType == REG_DWORD) && (cbValue == sizeof(DWORD)) )
                {
                    m_dwLegacyAuthenticationLevel = dwValue;
                }

                cbValue = sizeof(DWORD);

                res = RegQueryValueExW(hKeyOle, g_wszLegacyImpersonationLevel, NULL, &dwValueType,
                                       (unsigned char *) &dwValue, &cbValue);
                if ( (ERROR_SUCCESS==res) && (dwValueType == REG_DWORD) && (cbValue == sizeof(DWORD)) )
                {
                    m_dwLegacyImpersonationLevel = dwValue;
                }

                RegCloseKey(hKeyOle);
            }
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    cbValue = sizeof(DWORD);

    res=RegQueryValueExW(hKey, g_wszAuthenticationLevel, NULL, &dwValueType, (unsigned char *) &m_dwAuthenticationLevel, &cbValue);
    if ( (ERROR_SUCCESS!=res ) || (dwValueType != REG_DWORD) || (cbValue != sizeof(m_dwAuthenticationLevel)) )
    {
        m_dwAuthenticationLevel = m_dwLegacyAuthenticationLevel;
    }

    GetRegistryStringValue(hKey, NULL, g_wszRemoteServerName, (RQ_MULTISZ | RQ_ALLOWQUOTEQUOTE), &m_pwszRemoteServerName);
    
    // Read SAFER trust level, if it's there
    DWORD dwTrustLevelTemp;
    cbValue = sizeof(DWORD);
    res = RegQueryValueExW(hKey, g_wszSRPTrustLevel, NULL, &dwValueType, (unsigned char *)&dwTrustLevelTemp, &cbValue);
    if ( (ERROR_SUCCESS==res ) && (dwValueType == REG_DWORD) && (cbValue == sizeof(dwTrustLevelTemp)) )
    {
        CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: Found SAFER Level: %x\n", dwTrustLevelTemp));
        m_dwSaferTrustLevel = dwTrustLevelTemp;
        m_dwFlags |= PROCESS_SAFERTRUSTLEVEL;
    }

    CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: Done\n"));
}


CComProcessInfo::~CComProcessInfo()
{
    DELETE_PROCESS_STRING(m_pwszProcessName);
    DELETE_PROCESS_STRING(m_pwszServiceName);
    DELETE_PROCESS_STRING(m_pwszServiceParameters);
    DELETE_PROCESS_STRING(m_pwszRunAsUser);
    DELETE_PROCESS_STRING(m_pwszSurrogatePath);
    DELETE_PROCESS_STRING(m_pwszRemoteServerName);

    if ( m_pLaunchPermission != NULL )
    {
        delete [] reinterpret_cast<unsigned char*>(m_pLaunchPermission);
    }

    if ( m_pAccessPermission != NULL )
    {
        delete [] reinterpret_cast<unsigned char*>(m_pAccessPermission);
    }

    if ( m_pDefaultLaunchPermission != NULL )
    {
        delete [] reinterpret_cast<unsigned char*>(m_pDefaultLaunchPermission);
    }

    if ( m_pDefaultAccessPermission != NULL )
    {
        delete [] reinterpret_cast<unsigned char*>(m_pDefaultAccessPermission);
    }
}


/* IUnknown methods */

STDMETHODIMP CComProcessInfo::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ( riid == IID_IComProcessInfo )
    {
        *ppvObj = (LPVOID) (IComProcessInfo *) this;
    }
    else if ( riid == IID_IComProcessInfo2 )
    {
        *ppvObj = (LPVOID) (IComProcessInfo2 *) this;
    }
    else if ( riid == IID_IProcessServerInfo )
    {
        *ppvObj = (LPVOID) (IProcessServerInfo *) this;
    }
#if DBG
    else if ( riid == IID_ICacheControl )
    {
        *ppvObj = (LPVOID) (ICacheControl *) this;
    }
#endif
    else if ( riid == IID_IUnknown )
    {
        *ppvObj = (LPVOID) (IComProcessInfo *) this;
    }


    if ( *ppvObj != NULL )
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComProcessInfo::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComProcessInfo::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
#if DBG
        //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned ProcessInfo object");
#endif

        delete this;
    }

    return(cRef);
}


/* IComProcessInfo methods */

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetProcessId
(
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidProcessId
)
{
    *ppguidProcessId = &m_guidProcessId;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetProcessName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProcessName
)
{
    *pwszProcessName = m_pwszProcessName;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetProcessType
(
    /* [out] */ ProcessType __RPC_FAR *pType
)
{
    *pType = m_eProcessType;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetSurrogatePath
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogatePath
)
{
    *pwszSurrogatePath = m_pwszSurrogatePath;

    if ( m_pwszSurrogatePath != NULL )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetServiceName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServiceName
)
{
    *pwszServiceName = m_pwszServiceName;

    if ( m_pwszServiceName != NULL )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetServiceParameters
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServiceParameters
)
{
    *pwszServiceParameters = m_pwszServiceParameters;

    if ( m_pwszServiceName != NULL )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetActivateAtStorage
(
    /* [out] */ BOOL __RPC_FAR *pfActivateAtStorage
)
{
    *pfActivateAtStorage = m_fActivateAtStorage;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetRunAsType
(
    /* [out] */ RunAsType __RPC_FAR *pRunAsType
)
{
    *pRunAsType = m_eRunAsType;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetRunAsUser
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszUserName
)
{
    *pwszUserName = m_pwszRunAsUser;

    if ( m_pwszRunAsUser != NULL )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetLaunchPermission
(
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppsdLaunch,
    /* [out] */ DWORD __RPC_FAR *pdwDescriptorLength
)
{
    if ( m_dwFlags & PROCESS_LAUNCHPERMISSION )
    {
        *ppsdLaunch = m_pLaunchPermission;
        *pdwDescriptorLength = m_cbLaunchPermission;
    }
    else if ( m_dwFlags & PROCESS_LAUNCHPERMISSION_DEFAULT )
    {
        *ppsdLaunch = m_pDefaultLaunchPermission;
        *pdwDescriptorLength = m_cbDefaultLaunchPermission;
    }
    else
    {
        *ppsdLaunch = NULL;
        *pdwDescriptorLength = 0;

        return(REGDB_E_INVALIDVALUE);
    }

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetAccessPermission
(
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppsdAccess,
    /* [out] */ DWORD __RPC_FAR *pdwDescriptorLength
)
{
#if 0
    if ( m_dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE )
    {
        *ppsdAccess = NULL;
        *pdwDescriptorLength = 0;
    }
    else if ( m_dwFlags & PROCESS_ACCESSPERMISSION )
    {
        *ppsdAccess = m_pAccessPermission;
        *pdwDescriptorLength = m_cbAccessPermission;
    }
    else if ( m_dwFlags & PROCESS_ACCESSPERMISSION_DEFAULT )
    {
        *ppsdAccess = m_pDefaultAccessPermission;
        *pdwDescriptorLength = m_cbDefaultAccessPermission;
    }
    else
    {
        *ppsdAccess = NULL;
        *pdwDescriptorLength = 0;

        return(REGDB_E_INVALIDVALUE);
    }
#else
    *ppsdAccess = (void **) &m_guidProcessId;
    *pdwDescriptorLength = sizeof(GUID);
#endif

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetAuthenticationLevel
(
    /* [out] */ DWORD __RPC_FAR *pdwAuthnLevel
)
{
    *pdwAuthnLevel = m_dwAuthenticationLevel;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetImpersonationLevel
(
    /* [out] */ DWORD __RPC_FAR *pdwImpLevel
)
{
    *pdwImpLevel = m_dwLegacyImpersonationLevel;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetAuthenticationCapabilities
(
    /* [out] */ DWORD __RPC_FAR *pdwAuthenticationCapabilities
)
{
    *pdwAuthenticationCapabilities = EOAC_APPID;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetEndpoints
(
    /* [out] */ DWORD __RPC_FAR *pdwNumEndpoints,
    /* [size_is][size_is][out] */ DCOM_ENDPOINT __RPC_FAR *__RPC_FAR *ppEndPoints
)
{
    *pdwNumEndpoints = 0;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetRemoteServerName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
)
{
    *pwszServerName = m_pwszRemoteServerName;

    if ( m_pwszRemoteServerName != NULL )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::SendsProcessEvents
(
    /* [out] */ BOOL __RPC_FAR *pbSendsEvents
)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetManifestLocation
(
    /* [out] */ WCHAR** wszManifestLocation
)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetSaferTrustLevel
( 
    /* [out] */ DWORD* pdwSaferTrustLevel
)
{
    HRESULT hr;
    
    if (m_dwFlags & PROCESS_SAFERTRUSTLEVEL)
    {
        *pdwSaferTrustLevel = m_dwSaferTrustLevel;
        hr = S_OK;
    }
    else
    {
        // If registry did not explicitly specify, then we will 
        // use the safer level of the .exe, in other places...
        hr = E_FAIL;
    }

    return hr;
}



/* IProcessServerInfo methods */

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetShutdownIdleTime
(
    /* [out] */ unsigned long __RPC_FAR *pulTime
)
{
    *pulTime = 0;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetCrmLogFileName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszFileName
)
{
    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::EnumApplications
(
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppEnum
)
{
    *ppEnum = new CNoEnum;
    if ( *ppEnum == NULL )
    {
        return(E_OUTOFMEMORY);
    }

    (*ppEnum)->AddRef();

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::EnumRetQueues
(
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppEnum
)
{
    *ppEnum = new CNoEnum;
    if ( *ppEnum == NULL )
    {
        return(E_OUTOFMEMORY);
    }

    (*ppEnum)->AddRef();

    return(S_OK);
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComProcessInfo::CacheAddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComProcessInfo::CacheRelease(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif

BOOL CComProcessInfo::m_fGotLegacyLevels = FALSE;
DWORD CComProcessInfo::m_dwLegacyAuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT;
DWORD CComProcessInfo::m_dwLegacyImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\sxscat.cxx ===
typedef unsigned short USHORT;

#if defined(_NATIVE_WCHAR_T_DEFINED)
typedef wchar_t WCHAR;
#else
typedef unsigned short WCHAR;
#endif

typedef WCHAR *LPWSTR, *PWSTR;
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
typedef long NTSTATUS;
/* sxscat.cxx */

#include <windows.h>
#include <comdef.h>

#include "globals.hxx"

#include "catalog.h"        // from catalog.idl
#include "partitions.h"     // from partitions.idl

#include "sxscat.hxx"       // CComSxSCatalog
#include "sxsclass.hxx"     // CComSxSClassInfo
#include "services.hxx"
#include <sxstypes.h>


/*
 *  globals
 */

CComSxSCatalog *g_pSxSCatalogObject = NULL;

/*
 *  (DLL export) GetSxSCatalogObject()
 */

HRESULT __stdcall GetSxSCatalogObject
(
    /* [in] */ REFIID riid,
    /* [out, iis_is(riid)] */ void ** ppv
)
{
    HRESULT hr;

    *ppv = NULL;

    g_CatalogLock.AcquireWriterLock();

    if ( g_pSxSCatalogObject == NULL )
    {
        g_pSxSCatalogObject = new CComSxSCatalog;
    }

    if ( g_pSxSCatalogObject == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        g_pSxSCatalogObject->AddRef();
        hr = g_pSxSCatalogObject->QueryInterface(riid, ppv);
        if (0 == g_pSxSCatalogObject->Release())
        {
            g_pSxSCatalogObject = NULL;
        }
    }

    g_CatalogLock.ReleaseWriterLock();
    return(hr);
};


/*
 *  class CComSxSCatalog
 */

CComSxSCatalog::CComSxSCatalog(void)
{
    m_cRef = 0;
}


STDMETHODIMP CComSxSCatalog::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IComCatalogInternal) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IComCatalogInternal *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN) *ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComSxSCatalog::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComSxSCatalog::Release(void)
{
    long cRef;

    g_CatalogLock.AcquireWriterLock();

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
    g_pSxSCatalogObject = NULL;

    delete this;
    }

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetClassInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IComClassInfo *pClassInfo;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pComServerRedirection = NULL;
    ACTCTX_SECTION_KEYED_DATA askd;

    askd.cbSize = sizeof(askd);

    if (!::FindActCtxSectionGuid(
                FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX,     // dwFlags
                NULL,                                       // lpExtensionGuid
                ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
                &guidConfiguredClsid,
                &askd))
    {
        const DWORD dwLastError = ::GetLastError();

        if ((dwLastError == ERROR_SXS_KEY_NOT_FOUND) ||
            (dwLastError == ERROR_SXS_SECTION_NOT_FOUND))
            return REGDB_E_CLASSNOTREG;

        return HRESULT_FROM_WIN32(dwLastError);
    }

    // Hey, we have one.  Let's do some validation...
    if ((askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)) ||
        (askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER))
    {
        ::ReleaseActCtx(askd.hActCtx);
        return REGDB_E_INVALIDVALUE;
    }

    pComServerRedirection = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) askd.lpData;

    if ((pComServerRedirection->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)) ||
        (pComServerRedirection->Size > askd.ulLength) ||
        (pComServerRedirection->Flags != 0))
    {
        ::ReleaseActCtx(askd.hActCtx);
        return REGDB_E_INVALIDVALUE;
    }

    pClassInfo = (IComClassInfo *) new CComSxSClassInfo(
                askd.hActCtx,
                guidConfiguredClsid,
                pComServerRedirection,
                askd.ulLength,
                askd.lpSectionBase,
                askd.ulSectionTotalLength);
    if (pClassInfo == NULL)
    {
        ::ReleaseActCtx(askd.hActCtx);
        return E_OUTOFMEMORY;
    }

    ::ReleaseActCtx(askd.hActCtx);

    pClassInfo->AddRef();
    hr = pClassInfo->QueryInterface(riid, ppv);
    pClassInfo->Release();

    return hr;
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetApplicationInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetProcessInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetProcessInfoInternal
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    *ppv = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetServerGroupInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;
    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetRetQueueInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetApplicationInfoForExe
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetTypeLibrary
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  //BUGBUG
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetInterfaceInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  //BUGBUG
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::FlushCache(void)
{
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetClassInfoFromProgId
(
    /* [in] */ IUserToken __RPC_FAR *pUserToken,
    /* [in] */ WCHAR __RPC_FAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION RedirectionData = NULL;
    GUID *ConfiguredClsid = NULL;

    askd.cbSize = sizeof(askd);

    if (ppv != NULL)
        *ppv = NULL;

    if (!::FindActCtxSectionStringW(
                FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX,     // dwFlags
                NULL,                                       // lpExtensionGuid
                ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION,
                pwszProgID,
                &askd))
    {
        const DWORD dwLastError = ::GetLastError();

        if ((dwLastError == ERROR_SXS_KEY_NOT_FOUND) ||
            (dwLastError == ERROR_SXS_SECTION_NOT_FOUND))
            return REGDB_E_CLASSNOTREG;

        return HRESULT_FROM_WIN32(dwLastError);
    }

    // If the blob returned doesn't have the right format/version identifier, or isn't
    // big enough to actually contain an ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION
    // struct, bail.
    if ((askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER) ||
        (askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION)))
    {
        ::ReleaseActCtx(askd.hActCtx);
        return REGDB_E_INVALIDVALUE;
    }

    RedirectionData = (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) askd.lpData;

    // If the blob's recorded header size isn't big enough (or thinks that it's larger than
    // the total blob size), or there are flags set that we don't know how to interpret
    // we have to bail.
    if ((RedirectionData->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION)) ||
        (RedirectionData->Size > askd.ulLength) ||
        (RedirectionData->Flags != 0))
    {
        ::ReleaseActCtx(askd.hActCtx);
        return REGDB_E_INVALIDVALUE;
    }

    ConfiguredClsid = (GUID *) (((ULONG_PTR) askd.lpSectionBase) + RedirectionData->ConfiguredClsidOffset);

    // We now have the clsid; use our existing implementation of clsid->class info mapping.
    hr = this->GetClassInfo(pUserToken, *ConfiguredClsid, riid, ppv, pComCatalog);

    ::ReleaseActCtx(askd.hActCtx);
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\alocdbg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows:
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       alocdbg.cxx
//
//  Contents:   Supports symbolic stack trace dumps for leaked memory
//              allocations
//
//  Classes:    AllocArenaDump
//
//  Functions:  CoGetMalloc
//
//  History:    04-Nov-93 AlexT     Created
//              09-Nov-95 BruceMa   Added this header
//                                  Use imagehlp.dll rather than symhelp.dll
//
//--------------------------------------------------------------------------



/*
 * This file implements an arena that tracks memory allocations and frees.
 *      Isaache
 */

#if !defined(_CHICAGO_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
}
#endif

#include <ole2int.h>

#if DBG == 1

#include <imagehlp.h>
#include <except.hxx>
#include <alocdbg.h>

#pragma optimize( "y", off )

DECLARE_INFOLEVEL( heap );
DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

/*
 * The maximum number of AllocArenaCreate's we expect
 */
static const    MAXARENAS       = 5;

/*
 * When printing leak dumps, the max number we will print out.  Note, we keep
 * track of all of them, we just don't want to take forever to terminate a
 * process
 */
static const    MAXDUMP         = 50;

/*
 * The maximum size we'll let any single debug arena get
 */
static const ULONG ARENASIZE    = 1024*1024;

/*
 * The unit of growth for the arena holding the AllocArena data.
 * Must be a power of 2
 */
static const ALLOCRECINCR       = 128;


// The maximum symbol length we allow
static const ULONG MAXNAMELENGTH = 128;


static AllocArena *AllocArenas[ MAXARENAS + 1 ];


// This is our interface to symhelp for address translation
ULONG RealTranslate ( ULONG_PTR, LPSTR, ULONG );


ULONG MissingTranslate (
    ULONG Address,
    LPSTR Name,
    ULONG MaxNameLength )
{
    return _snprintf( Name, MaxNameLength, "0x%08x [imagehlp.dll missing]", Address );

}





//+---------------------------------------------------------------------------
//
//  Function:   RealTranslate
//
//  Synopsis:   Interfaces to imagehlp!SymGetSymFromAddr
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//
//  Returns:    BOOL
//
//  History:    09-Nov-95   BruceMa     Created
//
//----------------------------------------------------------------------------
ULONG RealTranslate ( ULONG_PTR address, LPSTR name, ULONG maxNameLength )
{
    IMAGEHLP_MODULE  mod;
    char             dump[sizeof(IMAGEHLP_SYMBOL) + MAXNAMELENGTH];
    char             UnDDump[ MAXNAMELENGTH ];
    PIMAGEHLP_SYMBOL pSym = (PIMAGEHLP_SYMBOL) &dump;
    ULONG_PTR         dwDisplacement = 0;

    // Fetch the module name
    mod.SizeOfStruct = sizeof(IMAGEHLP_MODULE);
    if (!SymGetModuleInfo(GetCurrentProcess(), address, &mod))
    {
        sprintf(name, "%08lx !\0", address);
    }
    else
    {
        // Copy the address and module name
        sprintf(name, "%08lx %s!\0", address, mod.ModuleName);
    }


    // Have to do this because size of sym is dynamically determined
    pSym->SizeOfStruct = sizeof(dump);
    pSym->MaxNameLength = MAXNAMELENGTH;

    // Fetch the symbol
    if (SymGetSymFromAddr(GetCurrentProcess(),
                               address,
                               &dwDisplacement,
                               pSym))
    {
        SymUnDName( pSym, UnDDump, sizeof(UnDDump ) );
        // Copy the symbol
        strcat(name, UnDDump );
    }

    // Copy the displacement
    char szDisplacement[16];

    strcat(name, "+");
    sprintf(szDisplacement, "0x%x\0", dwDisplacement);
    strcat(name, szDisplacement);

    return TRUE;
}






//+---------------------------------------------------------------------------
//
//  Function:   RecordStack functions(s) below...per processor type
//
//  Synopsis:   Record a stack backtrace into fTrace
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//                      not record
//              [fTrace] -- The recorded frames are put in here
//
//  Returns:    A checksum of the stack frames for fast initial lookups
//
//  Notes:      If we can do stack backtracing for whatever processor we're
//              compiling for, the #define CANDOSTACK
//
//----------------------------------------------------------------------------

#if defined (_CHICAGO_)

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{
    return 0;
}


#else

#define CANDOSTACK
#define SYM_HANDLE      GetCurrentProcess( )
#if defined(_M_IX86)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_I386
#elif defined(_M_IA64)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_IA64
#elif defined(_M_AMD64)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_AMD64
#else
#error( "unknown target machine" );
#endif

inline int
SaveOffExceptionContext( void * fTrace[ DEPTHTRACE],
                         DWORD & sum,
                         EXCEPTION_POINTERS * pPtrs )
{
    CONTEXT         Context;
    STACKFRAME      StackFrame;

    Context = *(pPtrs->ContextRecord);
    ZeroMemory( &StackFrame, sizeof(StackFrame) );

#if defined(_M_IX86)
    StackFrame.AddrPC.Offset       = Context.Eip;
    StackFrame.AddrPC.Mode         = AddrModeFlat;
    StackFrame.AddrFrame.Offset    = Context.Ebp;
    StackFrame.AddrFrame.Mode      = AddrModeFlat;
    StackFrame.AddrStack.Offset    = Context.Esp;
    StackFrame.AddrStack.Mode      = AddrModeFlat;
#endif

    int i = 3;
    BOOL rVal = TRUE;

    // skip spurious stack frames from RaiseException and ourselves
    while ( (i-- > 0 ) && rVal )
    {
        // skip our own stack frame
        rVal = StackWalk( MACHINE_TYPE,
                          SYM_HANDLE,
                          0,
                          &StackFrame,
                          &Context,
                          (PREAD_PROCESS_MEMORY_ROUTINE) ReadProcessMemory,
                          SymFunctionTableAccess,
                          SymGetModuleBase,
                          NULL );
    }

    // now process the interesting stack frames
    i = 0;
    while ( (i < DEPTHTRACE) && rVal )
    {

        rVal = StackWalk( MACHINE_TYPE,
                          SYM_HANDLE,
                          0,
                          &StackFrame,
                          &Context,
                          (PREAD_PROCESS_MEMORY_ROUTINE) ReadProcessMemory,
                          SymFunctionTableAccess,
                          SymGetModuleBase,
                          NULL );

        if (rVal )
        {
        fTrace[i++] =       (void*) StackFrame.AddrPC.Offset;
        sum +=              (DWORD) StackFrame.AddrPC.Offset;
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}
#endif

#if !defined(_CHICAGO_)

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{

        // we need a context record, and there isn't any clean way to
        // get our own context, so we deliberately cause an exception
        // and catch it, then save off and look at the context record.

        DWORD sum = 0;

        __try
        {
            EXCEPTION_RECORD    Except;
            ZeroMemory( &Except, sizeof(Except) );

            // we raise the exception 0!
            RtlRaiseException( &Except );

        }
        // the exception handler puts everything in the trace block, and
        // fills in the sum
        __except( SaveOffExceptionContext( fTrace,
                                           sum,
                                           GetExceptionInformation() ) )
        {
        }

        return sum;

}
#endif // !defined(_CHICAGO_)

//
// This allows external monitoring of heap activity by caiheap.exe
//
STDAPI_( AllocArena ** )
AllocArenaAddr( void )
{
        return AllocArenas;
}

//
// Create an arena for recording allocation statistics.  Return the arena
// pointer to the caller
//
STDAPI_( AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment )
{
        // the first time through, we set up the symbol handler
        static int FirstTime = TRUE;
        if ( FirstTime )
        {
            SymSetOptions( SYMOPT_DEFERRED_LOADS );
#if !defined(_CHICAGO_)
            SymInitialize( SYM_HANDLE, NULL, TRUE );
#endif // !defined(_CHICAGO_)
            FirstTime = FALSE;
        }

        struct AllocArena *paa = NULL;

        if( memctx == MEMCTX_TASK ) {
#if     defined( CANDOSTACK )
                if( heapInfoLevel & DEB_WARN ) {

                        paa = (struct AllocArena *)VirtualAlloc(
                                NULL, ARENASIZE, MEM_RESERVE, PAGE_NOACCESS );
                        if( paa == NULL )
                                return NULL;

                        paa = (AllocArena *)VirtualAlloc( paa,
                           sizeof(*paa)+(ALLOCRECINCR-1)*sizeof(HeapAllocRec),
                           MEM_COMMIT, PAGE_READWRITE );

                }
                else
#endif
                {
                        paa = (struct AllocArena *)LocalAlloc( LPTR, sizeof(*paa) );
                }
        }

        if( paa == NULL )
                return NULL;

        memcpy( paa->Signature,HEAPSIG,sizeof(HEAPSIG));
        if( comment )
                strncpy(paa->comment, comment, sizeof(paa->comment) );
		
        NTSTATUS status;
        status = RtlInitializeCriticalSection( &paa->csExclusive );
        if (!NT_SUCCESS(status))
        {
            LocalFree(paa);
            return NULL;
        }

        for( int i=0; i < MAXARENAS; i++ )
                if( AllocArenas[i] == 0 ) {
                        AllocArenas[i] = paa;
                        break;
                }

#if     defined( CANDOSTACK )
        if(!(heapInfoLevel & DEB_ITRACE))
#endif
        {
                paa->flags.KeepStackTrace = 0;
                paa->AllocRec[0].paa = paa;
                return paa;
        }

#if     defined( CANDOSTACK )
        paa->cRecords = ALLOCRECINCR;
        paa->cTotalRecords = ALLOCRECINCR;
        paa->flags.KeepStackTrace = 1;

        return paa;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordAlloc
//
//  Synopsis:   Keep a hash table of the stack backtraces of the allocations
//              we've done.
//
//  Arguments:  [paa] -- Return value from AllocArenaCreate() above
//              [bytes] -- the number of bytes being allocated by the caller.
//                      This value is recorded in the stack backtrace entry.
//
//  Algorithm:  The arena for the AllocArena is created with VirtualAlloc.
//                      pAllocArena->cRecords is the index of the next
//                      free record.  The first ALLOCRECINCR records are heads
//                      of separate lists of the records.
//
//  Returns:    A pointer to the AllocRec structure recording the entry.
//              Can return NULL if we can't record the allocation.
//
//----------------------------------------------------------------------------
STDAPI_( HeapAllocRec FAR * )
AllocArenaRecordAlloc( AllocArena *paa, size_t bytes )
{
        if( paa == NULL )
                return NULL;

        EnterCriticalSection( &paa->csExclusive );

        if( bytes ) {
                paa->cAllocs++;
                paa->cBytesNow += bytes;
                paa->cBytesTotal += bytes;
        } else {
                paa->czAllocs++;
        }

        //
        // Record 'size' in the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

        LeaveCriticalSection( &paa->csExclusive );

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace == 0 )
#endif
                return &paa->AllocRec[0];

#if     defined( CANDOSTACK )

        DWORD sum;
        struct HeapAllocRec *phar,*hp;
        void *fTrace[ DEPTHTRACE ];

        //
        // See if we find an existing record of this stack backtrace
        //
        memset( fTrace, '\0', sizeof( fTrace ) );
        sum = RecordStack( 1, fTrace );

        hp = &paa->AllocRec[ sum & (ALLOCRECINCR-1) ];

        EnterCriticalSection( &paa->csExclusive );

        for( phar = hp; phar != NULL; phar = phar->u.next )
                if( phar->sum == sum && !memcmp(phar->fTrace,fTrace,sizeof(fTrace)))
                {
                        phar->count++;
                        phar->bytes += bytes;
                        phar->total.bytes += bytes;
                        phar->total.count++;
                        phar->paa = paa;
                        LeaveCriticalSection( &paa->csExclusive );
                        return phar;
                }
        //
        // We have no record of this allocation.  Make one!
        //
        if( hp->total.count && paa->cRecords == paa->cTotalRecords ) {
                //
                // The arena is currently full.  Grow it by ALLOCRECINCR
                //
                AllocArena *npHeap;

                npHeap = (AllocArena *)VirtualAlloc(
                        paa,
                        sizeof(AllocArena)+
                        ((paa->cTotalRecords + ALLOCRECINCR) *
                                sizeof(HeapAllocRec) ),
                        MEM_COMMIT, PAGE_READWRITE );

                if( npHeap != paa ) {
                        paa->cMissed++;
                        LeaveCriticalSection( &paa->csExclusive );
                        return NULL;
                }

                paa->cTotalRecords += ALLOCRECINCR;
        }

        if( hp->total.count == 0 ) {
                phar = hp;
        } else {
                phar = &paa->AllocRec[ paa->cRecords++ ];
                phar->u.next = hp->u.next;
                hp->u.next = phar;
        }

        paa->cPaths++;

        memcpy( phar->fTrace, fTrace, sizeof( fTrace ) );
        phar->count = phar->total.count = 1;
        phar->bytes = phar->total.bytes = bytes;
        phar->sum = sum;
        phar->paa = paa;
        LeaveCriticalSection( &paa->csExclusive );
        return phar;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordReAlloc
//
//  Synopsis:   Update the record to reflect the fact that we've ReAlloc'd
//              the memory chunk.
//
//  Arguments:  [vp] -- Return value from AllocArenaRecordAlloc() above
//              [oldbytes] -- size of the memory before ReAllocation
//              [newbytes] -- new size of the memory
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordReAlloc( HeapAllocRec FAR *vp, size_t oldbytes, size_t newbytes)
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        paa->cReAllocs++;
        paa->cBytesNow -= oldbytes;
        paa->cBytesNow += newbytes;

        if( newbytes > oldbytes )
                paa->cBytesTotal += newbytes - oldbytes;

        //
        // Take 'oldbytes' out of the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( oldbytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        //
        // Record 'newbytes' in the histogram of requests
        //
        for( i=31; i>=0; i-- )
                if( newbytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->bytes -= oldbytes;
                vp->bytes += newbytes;
                vp->total.count++;
                if( newbytes > oldbytes )
                        vp->total.bytes += newbytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordFree
//
//  Synopsis:   Caller has freed memory -- keep accounting up to date
//
//  Arguments:  [vp] -- Value returned by AllocArenaRecordAlloc() above
//              [bytes] -- The number of bytes being freed
//
//  Algorithm:  AllocRec structures, once allocated, are never actually
//                      freed back to the Hash memory arena.  This helps us
//                      understand historical use of the heap.
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordFree( HeapAllocRec FAR *vp, size_t bytes )
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        //
        // Record this free in the histogram
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        paa->cFrees++;
        paa->cBytesNow -= bytes;

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->count--;
                vp->bytes -= bytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

STDAPI_( void )
AllocArenaDumpRecord( HeapAllocRec FAR *bp, BOOL fDumpSymbols )
{

        char achBuffer[ MAX_PATH ], *p;
        static int FirstTime = TRUE;

        // make sure we print the nice undecorated names
        if ( FirstTime && fDumpSymbols)
        {
            SymSetOptions( SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS );
            FirstTime = FALSE;
        }


        heapDebugOut((DEB_WARN, "*** %d allocs, %u bytes:\n",
                         bp->count, bp->bytes ));

        for( int j=0; j<DEPTHTRACE && bp->fTrace[j]; j++ )
        {
            if(fDumpSymbols)
            {
                RealTranslate((ULONG_PTR)bp->fTrace[j],
                             achBuffer,
                             sizeof(achBuffer));

                if( p = strchr( achBuffer, '\n' ) )
                        *p = '\0';
                heapDebugOut((DEB_WARN, "       %s\n", achBuffer));
            }
            else
                heapDebugOut((DEB_WARN, "       0x%08x\n", bp->fTrace[j]));
        }

}

extern "C" ULONG DbgPrint( PCH Format, ... );

STDAPI_( void )
AllocArenaDump( AllocArena *paa, BOOL fDumpSymbols )
{
        if( paa == NULL ) {
                for( int i = 0; i < MAXARENAS && AllocArenas[i]; i++ )
                        AllocArenaDump( AllocArenas[i], fDumpSymbols );
                return;
        }

        char *cmdline = GetCommandLineA();

        if( cmdline == NULL )
                cmdline = "???";

        HeapAllocRec *bp = paa->AllocRec;
        HeapAllocRec *ep = bp + paa->cRecords;

        if( paa->cBytesNow )
                heapDebugOut((DEB_WARN, "***** %u bytes leaked mem for %s in '%s'\n", paa->cBytesNow, paa->comment, cmdline ));

#if     defined( CANDOSTACK )
        if( paa->cBytesNow && paa->flags.KeepStackTrace )
        {
                int cleaks = 0;

                for( ; bp < ep; bp++) {
                        if( bp->count )
                                ++cleaks;
                }

                if( cleaks ) {
                        heapDebugOut((DEB_WARN, "***** %s %u MEM LEAKS\n",
                                paa->comment, cleaks ));

                        if( heapInfoLevel & DEB_TRACE ) {
                                HeapAllocRec *bp;
                                UINT maxdump = MAXDUMP;
                                for( bp = paa->AllocRec; maxdump && bp<ep; bp++)
                                        if( bp->count ) {
                                                heapDebugOut((DEB_TRACE, "\n"));
                                                AllocArenaDumpRecord( bp, fDumpSymbols );
                                                maxdump--;
                                        }
                        } else if( cleaks )
                                heapDebugOut((DEB_WARN, "** Set ole32!heapInfoLevel to x707 for leak backtrace\n"));

                }
        }
#endif

        if( (heapInfoLevel & DEB_TRACE) && paa->cBytesTotal )
        {
                heapDebugOut((DEB_TRACE,"\n"));
                heapDebugOut((DEB_TRACE,
                        "'%s' Memory Stats: %u allocations, %u frees\n",
                        cmdline, paa->cAllocs, paa->cFrees ));

                if( paa->czAllocs )
                        heapDebugOut((DEB_TRACE,
                                "\t%u zero allocs\n", paa->czAllocs ));

                heapDebugOut((DEB_TRACE,
                                "\t%u bytes allocated\n", paa->cBytesTotal ));

                heapDebugOut((DEB_TRACE,
                                "*** Histogram of Allocated Mem Sizes ***\n"));

                heapDebugOut((DEB_TRACE, "  Min    Max\t  Tot\t Simul\n" ));
                for( int i=0; i < 32; i++ )
                        if( paa->Histogram.total[i] )
                        {
                                heapDebugOut((DEB_TRACE,
                                        "%6u -> %6u\t%6u\t%6u\n",
                                        1<<i, (1<<(i+1))-1,
                                        paa->Histogram.total[i],
                                        paa->Histogram.simul[i]
                                ));
                        }
        }
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\cerror.cxx ===
//+-------------------------------------------------------------------
//
//  File:       cerror.cxx
//
//  Contents:   Implements COM extended error information.
//
//  Classes:    CErrorObject - Implements the COM error object.
//
//  Functions:  CoCreateErrorInfo = CreateErrorInfo
//              CoGetErrorInfo    = GetErrorInfo
//              CoSetErrorInfo    = SetErrorInfo
//
//  History:    20-Jun-96   MikeHill    Added more OleAut32 wrappers.
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <oleauto.h>
#include <chock.hxx>
#include <privoa.h>     // PrivSys* routines

HRESULT NdrStringRead(IStream *pStream, LPWSTR *psz);
SIZE_T  NdrStringSize(LPCWSTR psz);
HRESULT NdrStringWrite(IStream *pStream, LPCWSTR psz);

struct ErrorObjectData
{
    DWORD  dwVersion;
    DWORD  dwHelpContext;
    IID    iid;
};

class CErrorObject : public IErrorInfo, public ICreateErrorInfo, public IMarshal
{
private:
    long   _refCount;
    ErrorObjectData _data;
    LPWSTR _pszSource;
    LPWSTR _pszDescription;
    LPWSTR _pszHelpFile;

    ~CErrorObject();

public:
    CErrorObject();

    /*** IUnknown methods ***/
    HRESULT STDMETHODCALLTYPE QueryInterface(
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);

    ULONG STDMETHODCALLTYPE AddRef( void);

    ULONG STDMETHODCALLTYPE Release( void);

    /*** IMarshal methods ***/
    HRESULT STDMETHODCALLTYPE GetUnmarshalClass(
        /* [in] */ REFIID riid,
        /* [unique][in] */ void __RPC_FAR *pv,
        /* [in] */ DWORD dwDestContext,
        /* [unique][in] */ void __RPC_FAR *pvDestContext,
        /* [in] */ DWORD mshlflags,
        /* [out] */ CLSID __RPC_FAR *pCid);

    HRESULT STDMETHODCALLTYPE GetMarshalSizeMax(
        /* [in] */ REFIID riid,
        /* [unique][in] */ void __RPC_FAR *pv,
        /* [in] */ DWORD dwDestContext,
        /* [unique][in] */ void __RPC_FAR *pvDestContext,
        /* [in] */ DWORD mshlflags,
        /* [out] */ DWORD __RPC_FAR *pSize);

    HRESULT STDMETHODCALLTYPE MarshalInterface(
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ REFIID riid,
        /* [unique][in] */ void __RPC_FAR *pv,
        /* [in] */ DWORD dwDestContext,
        /* [unique][in] */ void __RPC_FAR *pvDestContext,
        /* [in] */ DWORD mshlflags);

    HRESULT STDMETHODCALLTYPE UnmarshalInterface(
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ REFIID riid,
        /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);

    HRESULT STDMETHODCALLTYPE ReleaseMarshalData(
        /* [unique][in] */ IStream __RPC_FAR *pStm);

    HRESULT STDMETHODCALLTYPE DisconnectObject(
        /* [in] */ DWORD dwReserved);

    /*** IErrorInfo methods ***/
    HRESULT STDMETHODCALLTYPE GetGUID(
        /* [out] */ GUID __RPC_FAR *pGUID);

    HRESULT STDMETHODCALLTYPE GetSource(
        /* [out] */ BSTR __RPC_FAR *pBstrSource);

    HRESULT STDMETHODCALLTYPE GetDescription(
        /* [out] */ BSTR __RPC_FAR *pBstrDescription);

    HRESULT STDMETHODCALLTYPE GetHelpFile(
        /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);

    HRESULT STDMETHODCALLTYPE GetHelpContext(
        /* [out] */ DWORD __RPC_FAR *pdwHelpContext);

    /*** ICreateErrorInfo methods ***/
    HRESULT STDMETHODCALLTYPE SetGUID(
        /* [in] */ REFGUID rguid);

    HRESULT STDMETHODCALLTYPE SetSource(
        /* [in] */ LPOLESTR szSource);

    HRESULT STDMETHODCALLTYPE SetDescription(
        /* [in] */ LPOLESTR szDescription);

    HRESULT STDMETHODCALLTYPE SetHelpFile(
        /* [in] */ LPOLESTR szHelpFile);

    HRESULT STDMETHODCALLTYPE SetHelpContext(
        /* [in] */ DWORD dwHelpContext);

};

//+-------------------------------------------------------------------
//
//  Function:   CoCreateErrorInfo
//
//  Synopsis:   Creates a COM error object.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//--------------------------------------------------------------------
WINOLEAPI
CoCreateErrorInfo(ICreateErrorInfo **ppCreateErrorInfo)
{
    HRESULT hr = S_OK;
    CErrorObject *pTemp;

    __try
    {
        *ppCreateErrorInfo = NULL;

        pTemp = new CErrorObject;

        if(pTemp != NULL)
        {
            *ppCreateErrorInfo = (ICreateErrorInfo *) pTemp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CErrorObjectCF_CreateInstance
//
//  Synopsis:   Creates a COM error object.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//--------------------------------------------------------------------
HRESULT CErrorObjectCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(pUnkOuter == NULL);
    return CoCreateErrorInfo((ICreateErrorInfo **)ppv);
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetErrorInfo
//
//  Synopsis:   Gets the error object for the current thread.
//
//  Returns:    S_OK, S_FALSE, E_INVALIDARG, E_NOINTERFACE.
//
//  Notes:      If sucessful, this function clears the error object
//              for the current thread.
//
//--------------------------------------------------------------------
WINOLEAPI
CoGetErrorInfo(DWORD dwReserved, IErrorInfo ** ppErrorInfo)
{
    HRESULT hr = S_OK;
    COleTls tls(hr);
    IUnknown *punkError = NULL;
    if(FAILED(hr))
    {
        //Could not access TLS.
        return hr;
    }

    if(dwReserved != 0)
    {
        return E_INVALIDARG;
    }

    __try
    {
        *ppErrorInfo = NULL;

        if(tls->punkError != NULL)
        {
            punkError = tls->punkError;
	    tls->punkError = NULL;
	    hr = punkError->QueryInterface(IID_IErrorInfo, (void **) ppErrorInfo);
            if(SUCCEEDED(hr))
            {
                //Clear the error object.
                punkError->Release();
                hr = S_OK;
            }
	    else
	    {
	       ComDebOut((DEB_WARN, "Error object does not implement IID_IErrorInfo"));
	       tls->punkError = punkError;
	    }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoSetErrorInfo
//
//  Synopsis:   Sets the COM extended error information for the
//              current thread.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//--------------------------------------------------------------------
WINOLEAPI
CoSetErrorInfo(unsigned long dwReserved, IErrorInfo * pErrorInfo)
{
    HRESULT hr = S_OK;
    COleTls tls(hr);

    if(FAILED(hr))
    {
        //Could not access TLS.
        return hr;
    }

    if(dwReserved != 0)
    {
        return E_INVALIDARG;
    }

    __try
    {
        // Do this first, so that if the Release() reenters,
        // we're not pointing at them.
        // Some ADO destructor code will, indeed, do just that.
        //
        IUnknown * punkErrorOld = tls->punkError;
	tls->punkError = NULL;        

        //Release the old error object.
        if(punkErrorOld != NULL)
        {
            punkErrorOld->Release();
        }
	
        //AddRef the new error object.
        if(pErrorInfo != NULL)
        {
            pErrorInfo->AddRef();
        }
        
        // Set the error object for the current thread.
	tls->punkError = pErrorInfo;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::CErrorObject
//
//  Synopsis:   Constructor for COM error object.
//
//----------------------------------------------------------------------------
CErrorObject::CErrorObject()
  : _refCount(1),
    _pszSource(NULL),
    _pszDescription(NULL),
    _pszHelpFile(NULL)
{
    _data.dwVersion = 0;
    _data.dwHelpContext = 0;
    _data.iid = GUID_NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::~CErrorObject
//
//  Synopsis:   Destructor for COM error object.
//
//----------------------------------------------------------------------------
CErrorObject::~CErrorObject()
{
    if(_pszSource != NULL)
        PrivMemFree(_pszSource);

    if(_pszDescription != NULL)
        PrivMemFree(_pszDescription);

    if(_pszHelpFile != NULL)
        PrivMemFree(_pszHelpFile);
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.  The error object
//              supports the IErrorInfo, ICreateErrorInfo, IMarshal, and
//              IUnknown interfaces.
//
//  Returns:    S_OK, E_NOINTERFACE, E_INVALIDARG.
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::QueryInterface(
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv)
{
    HRESULT hr = S_OK;

    _try
    {
        *ppv = NULL;

        if (IsEqualIID(riid, IID_IMarshal))
        {
            AddRef();
            *ppv = (IMarshal *) this;
        }
        else if (IsEqualIID(riid, IID_IUnknown) ||
                 IsEqualIID(riid, IID_ICreateErrorInfo))
        {
            AddRef();
            *ppv = (ICreateErrorInfo *) this;
        }
        else if(IsEqualIID(riid, IID_IErrorInfo))
        {
            AddRef();
            *ppv = (IErrorInfo *) this;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::AddRef
//
//  Synopsis:   Increments the reference count.
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CErrorObject::AddRef()
{
    Win4Assert(_refCount > 0);

    InterlockedIncrement(&_refCount);
    return _refCount;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::Release
//
//  Synopsis:   Decrements the reference count.
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CErrorObject::Release()
{
    ULONG count = _refCount - 1;

    Win4Assert(_refCount > 0);

    if(0 == InterlockedDecrement(&_refCount))
    {
        delete this;
        count = 0;
    }
    return count;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetUnmarshalClass
//
//  Synopsis:   Get the CLSID of the COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetUnmarshalClass(
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = CLSID_ErrorObject;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetMarshalSizeMax
//
//  Synopsis:   Get the size of the marshalled COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetMarshalSizeMax(
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD __RPC_FAR *pSize)
{
    SIZE_T cb;

    cb = sizeof(_data);
    cb += NdrStringSize(_pszSource);
    cb += NdrStringSize(_pszDescription);
    cb += NdrStringSize(_pszHelpFile);

    *pSize = (DWORD) cb;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::MarshalInterface
//
//  Synopsis:   Marshal the COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::MarshalInterface(
    /* [unique][in] */ IStream __RPC_FAR *pStream,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags)
{
    HRESULT hr;

    hr = pStream->Write(&_data, sizeof(_data), NULL);

    if(SUCCEEDED(hr))
        hr = NdrStringWrite(pStream, _pszSource);

    if(SUCCEEDED(hr))
        hr = NdrStringWrite(pStream, _pszDescription);

    if(SUCCEEDED(hr))
        hr = NdrStringWrite(pStream, _pszHelpFile);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::UnmarshalInterface
//
//  Synopsis:   Unmarshal the COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::UnmarshalInterface(
    /* [unique][in] */ IStream __RPC_FAR *pStream,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv)
{
    HRESULT hr;

    *ppv = NULL;

    //Clear the error object.
    if(_pszSource != NULL)
    {
        PrivMemFree(_pszSource);
        _pszSource = NULL;
    }

    if(_pszDescription != NULL)
    {
        PrivMemFree(_pszDescription);
        _pszDescription = NULL;
    }

    if(_pszHelpFile != NULL)
    {
        PrivMemFree(_pszHelpFile);
        _pszHelpFile = NULL;
    }

    hr = pStream->Read(&_data, sizeof(_data), NULL);

    if(SUCCEEDED(hr))
        hr = NdrStringRead(pStream, &_pszSource);

    if(SUCCEEDED(hr))
        hr = NdrStringRead(pStream, &_pszDescription);

    if(SUCCEEDED(hr))
        hr = NdrStringRead(pStream, &_pszHelpFile);

    //Check the version.
    if(_data.dwVersion > 0)
    {
        _data.dwVersion = 0;
    }

    if(SUCCEEDED(hr))
    {
        hr = QueryInterface(riid, ppv);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::ReleaseMarshalData
//
//  Synopsis:   Release a marshalled COM error object.
//
//  Notes:      Just seek to the end of the marshalled error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::ReleaseMarshalData(
    /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::DisconnectObject
//
//  Synopsis:   Disconnect the object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::DisconnectObject(
    /* [in] */ DWORD dwReserved)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetDescription
//
//  Synopsis:   Gets a textual description of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetDescription(
    /* [out] */ BSTR __RPC_FAR *pBstrDescription)
{
    HRESULT hr = S_OK;
    BSTR pTemp;

    __try
    {
        *pBstrDescription = NULL;

        if(_pszDescription != NULL)
        {
            pTemp = PrivSysAllocString(_pszDescription);
            if(pTemp != NULL)
            {
                *pBstrDescription = pTemp;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetGUID
//
//  Synopsis:   Gets the IID of the interface that defined the error.
//
//  Returns:    S_OK, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetGUID(
    /* [out] */ GUID __RPC_FAR *pGUID)
{
    HRESULT hr = S_OK;

    __try
    {
        *pGUID = _data.iid;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetHelpContext
//
//  Synopsis:   Gets the Help context ID for the error.
//
//  Returns:    S_OK, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetHelpContext(
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext)
{
    HRESULT hr = S_OK;

    __try
    {
        *pdwHelpContext = _data.dwHelpContext;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetHelpFile
//
//  Synopsis:   Gets the path of the help file that describes the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetHelpFile(
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile)
{
    HRESULT hr = S_OK;
    BSTR pTemp;

    __try
    {
        *pBstrHelpFile = NULL;

        if(_pszHelpFile != NULL)
        {
            pTemp = PrivSysAllocString(_pszHelpFile);
            if(pTemp != NULL)
            {
                *pBstrHelpFile = pTemp;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetSource
//
//  Synopsis:   Gets the ProgID of the class that is the source of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetSource(
    /* [out] */ BSTR __RPC_FAR *pBstrSource)
{
    HRESULT hr = S_OK;
    BSTR pTemp;

    __try
    {
        *pBstrSource = NULL;

        if(_pszSource != NULL)
        {
            pTemp = PrivSysAllocString(_pszSource);
            if(pTemp != NULL)
            {
                *pBstrSource = pTemp;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetDescription
//
//  Synopsis:   Sets the textual description of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetDescription(
    /* [in] */ LPOLESTR pszDescription)
{
    HRESULT hr = S_OK;
    LPOLESTR pTemp = NULL;
    SIZE_T cb;

    __try
    {
        if(pszDescription != NULL)
        {
            cb = (wcslen(pszDescription) + 1) * sizeof(OLECHAR);
            pTemp = (LPOLESTR) PrivMemAlloc(cb);
            if(pTemp != NULL)
            {
                memcpy(pTemp, pszDescription, cb);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            pTemp = (LPOLESTR) InterlockedExchangePointer((PVOID *)&_pszDescription,
                                                          (PVOID) pTemp);
            if(pTemp != NULL)
            {
                PrivMemFree(pTemp);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetGUID
//
//  Synopsis:   Sets the IID of the interface that defined the error.
//
//  Returns:    S_OK, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetGUID(
    /* [in] */ REFGUID rguid)
{
    HRESULT hr = S_OK;

    __try
    {
        _data.iid = rguid;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetHelpContext
//
//  Synopsis:   Sets the Help context ID for the error.
//
//  Returns:    S_OK.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetHelpContext(
    /* [in] */ DWORD dwHelpContext)
{
    _data.dwHelpContext = dwHelpContext;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetHelpFile
//
//  Synopsis:   Sets the path of the Help file that describes the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetHelpFile(
    /* [in] */ LPOLESTR pszHelpFile)
{
    HRESULT hr = S_OK;
    LPOLESTR pTemp = NULL;
    SIZE_T cb;

    __try
    {
        if(pszHelpFile != NULL)
        {
            cb = (wcslen(pszHelpFile) + 1) * sizeof(OLECHAR);
            pTemp = (LPOLESTR) PrivMemAlloc(cb);
            if(pTemp != NULL)
            {
                memcpy(pTemp, pszHelpFile, cb);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            pTemp = (LPOLESTR) InterlockedExchangePointer((PVOID *)&_pszHelpFile,
                                                          (PVOID) pTemp);
            if(pTemp != NULL)
            {
                PrivMemFree(pTemp);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetSource
//
//  Synopsis:   Sets the source of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetSource(
    /* [in] */ LPOLESTR pszSource)
{
    HRESULT hr = S_OK;
    LPOLESTR pTemp = NULL;
    SIZE_T cb;

    __try
    {
        if(pszSource != NULL)
        {
            cb = (wcslen(pszSource) + 1) * sizeof(OLECHAR);
            pTemp = (LPOLESTR) PrivMemAlloc(cb);
            if(pTemp != NULL)
            {
                memcpy(pTemp, pszSource, cb);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            pTemp = (LPOLESTR) InterlockedExchangePointer((PVOID *)&_pszSource,
                                                          (PVOID) pTemp);
            if(pTemp != NULL)
            {
                PrivMemFree(pTemp);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


struct NdrStringHeader
{
    DWORD dwMax;
    DWORD dwOffset;
    DWORD dwActual;
};

struct NdrStringPtrHeader
{
    DWORD dwUnique;
    DWORD dwMax;
    DWORD dwOffset;
    DWORD dwActual;
};

// This is the maximum size of a read string.  To prevent DOS attacks
// that get us to allocate a whole lot of memory.
#define MAX_STRING_BUFFER_LEN (64 * 1024)

//+---------------------------------------------------------------------------
//
//  Function:   NdrStringRead
//
//  Synopsis:   Reads a string from a stream in NDR format.
//
//  Notes:      The NDR format of a string is the following.
//              DWORD - Represents the unique pointer.
//              DWORD - Maximum number of elements.
//              DWORD - offset.
//              DWORD - Actual number of elements.
//              NULL terminated UNICODE string.
//
//----------------------------------------------------------------------------
HRESULT NdrStringRead(IStream *pStream, LPWSTR *ppsz)
{
    DWORD dwUnique = 0;
    ULONG cbRead = 0;

    *ppsz = NULL;

    //Check for a NULL pointer.
    HRESULT hr = pStream->Read(&dwUnique, sizeof(dwUnique), &cbRead);
    if (FAILED(hr) || (cbRead != sizeof(dwUnique)))
        return RPC_E_INVALID_OBJREF;
    
    if(dwUnique != 0)
    {
        LPWSTR pTemp = NULL;
        NdrStringHeader hdr;

        hr = pStream->Read(&hdr, sizeof(hdr), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(hdr)))
            return RPC_E_INVALID_OBJREF;

        // hdr.dwMax is supposed to be the size of the buffer.
        //
        // I'm not sure what hdr.dwOffset is supposed to mean.  But
        // we always write 0, and this unmarshaller doesn't know what
        // to do with it, so make sure it's 0.
        //
        // hdr.dwActual is supposed to be the length we copy.  One
        // might think that hdr.dwActual might not be the same as 
        // hdr.dwMax, because of dwOffset, but since dwOffset is always
        // 0...
        if ((hdr.dwMax != hdr.dwActual) || (hdr.dwOffset != 0))
            return RPC_E_INVALID_OBJREF;

        // Do not honor requests for very large strings here.
        if (hdr.dwMax > MAX_STRING_BUFFER_LEN)
            return E_OUTOFMEMORY;
                
        pTemp = (LPWSTR) PrivMemAlloc(hdr.dwMax * sizeof(WCHAR));
        if(pTemp != NULL)
        {
            hr = pStream->Read(pTemp,
                               hdr.dwMax * sizeof(WCHAR),
                               &cbRead);
            if ((FAILED(hr))                          || 
                (cbRead != hdr.dwMax * sizeof(WCHAR)) ||
                (pTemp[hdr.dwMax-1] != L'\0'))
            {
                PrivMemFree(pTemp);
                return RPC_E_INVALID_OBJREF;
            }
            else
            {
                *ppsz = pTemp;                
            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrStringSize
//
//  Synopsis:   Computes the size of a marshalled string.
//
//----------------------------------------------------------------------------
SIZE_T NdrStringSize(LPCWSTR psz)
{
    SIZE_T cb;

    if(psz != NULL)
    {
        cb = sizeof(NdrStringPtrHeader);
        cb += (wcslen(psz) + 1) * sizeof(WCHAR);
    }
    else
    {
        cb = sizeof(DWORD);
    }

    return cb;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrStringWrite
//
//  Synopsis:   Writes a string to a stream in NDR format.
//
//  Notes:      The NDR format of a string is shown below.
//              DWORD - Represents the unique pointer.
//              DWORD - Maximum number of elements.
//              DWORD - offset.
//              DWORD - Number of elements.
//              NULL terminated UNICODE string.
//
//----------------------------------------------------------------------------
HRESULT NdrStringWrite(IStream *pStream, LPCWSTR psz)
{
    HRESULT hr = S_OK;
    ULONG cbWritten;

    //Check for a NULL pointer.
    if(psz != NULL)
    {
        NdrStringPtrHeader hdr;

        //Write the header.
        hdr.dwUnique = 0xFFFFFFFF;
        hdr.dwMax = (DWORD) wcslen(psz) + 1;
        hdr.dwOffset = 0;
        hdr.dwActual = hdr.dwMax;
        hr = pStream->Write(&hdr, sizeof(hdr), &cbWritten);

        if(SUCCEEDED(hr))
        {
            hr = pStream->Write(psz, hdr.dwActual * sizeof(WCHAR), &cbWritten);
        }
    }
    else
    {
        DWORD dwUnique = 0;

        //Write a NULL unique pointer.
        hr = pStream->Write(&dwUnique, sizeof(dwUnique), &cbWritten);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\sxsclass.cxx ===
typedef unsigned short USHORT;

#if defined(_NATIVE_WCHAR_T_DEFINED)
typedef wchar_t WCHAR;
#else
typedef unsigned short WCHAR;
#endif
typedef WCHAR *LPWSTR, *PWSTR;
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
typedef long NTSTATUS;
/* sxsclass.cxx */

#include <windows.h>
#include <appmgmt.h>
#include <comdef.h>
#include <string.h>
#include <stdio.h>

#include "globals.hxx"
#include "services.hxx"

#include "catalog.h"
#include "partitions.h"
#include "sxsclass.hxx"
#include "catalog.hxx"

#define STRLEN_WCHAR(s) ((sizeof((s)) / sizeof((s)[0])) -1)
#define STRLEN_OLE32DLL (STRLEN_WCHAR(g_wszOle32Dll))


/*
 *  class CComSxSClassInfo
 */

CComSxSClassInfo::CComSxSClassInfo
    (
    HANDLE hActCtx,
    REFGUID rguidConfiguredClsid,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pData,
    ULONG ulDataLength,
    PVOID pBase,
    ULONG ulSectionLength
    )
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_cLocks = 0;
    m_cLocksExternal = 0;

    m_hActCtx = hActCtx;
    ::AddRefActCtx(m_hActCtx);
    m_pData = pData;
    m_ulDataLength = ulDataLength;
    m_pSectionBase = pBase;
    m_ulSectionLength = ulSectionLength;
    m_bufModulePath[0]= L'\0';
}


CComSxSClassInfo::~CComSxSClassInfo()
{
    ::ReleaseActCtx(m_hActCtx);
}


/* IUnknown methods */

STDMETHODIMP CComSxSClassInfo::QueryInterface(
                                          REFIID riid,
                                          LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ( riid == IID_IComClassInfo )
    {
        *ppvObj = (LPVOID) static_cast<IComClassInfo *>(this);
    }
    else if ( riid == IID_IClassClassicInfo )
    {
        *ppvObj = (LPVOID) static_cast<IClassClassicInfo *>(this);
    }
#if DBG
    else if ( riid == IID_ICacheControl )
    {
        *ppvObj = (LPVOID) static_cast<ICacheControl *>(this);
    }
#endif
    else if ( riid == IID_IUnknown )
    {
        *ppvObj = (LPVOID) static_cast<IComClassInfo *>(this);
    }

    if ( *ppvObj != NULL )
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComSxSClassInfo::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComSxSClassInfo::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
#if DBG
        //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned ClassInfo object");
#endif
        delete this;
    }

    return(cRef);
}

/* IComClassInfo methods */

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetConfiguredClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    *ppguidClsid = const_cast<GUID *>(&m_pData->ConfiguredClsid);
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetProgId
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProgid
    )
{
    // The existing COM implementation seems to just return a pointer to their own copy,
    // so we'll do the same...

    if (m_pData->ProgIdOffset != 0)
    {
        *pwszProgid = (PWSTR) (((ULONG_PTR) m_pData) + m_pData->ProgIdOffset);
        return S_OK;
    }

    *pwszProgid = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetClassName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszClassName
    )
{
    *pwszClassName = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetApplication
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    *ppv = NULL;
    return(E_FAIL);
}

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetClassContext
    (
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX __RPC_FAR *pclsctx
    )
{
    *pclsctx = CLSCTX_INPROC_SERVER;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetCustomActivatorCount
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long __RPC_FAR *pulCount
    )
{
    *pulCount = 0;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetCustomActivatorClsids
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *prgguidClsid
    )
{
    *prgguidClsid = NULL;
    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetCustomActivators
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator __RPC_FAR *__RPC_FAR *__RPC_FAR *prgpActivator
    )
{
    *prgpActivator = NULL;
    return(S_FALSE);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetTypeInfo
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    *ppv = NULL;
    return(E_NOTIMPL);        //BUGBUG
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::IsComPlusConfiguredClass
    (
    /* [out] */ BOOL __RPC_FAR *pfComPlusConfiguredClass
    )
{
    *pfComPlusConfiguredClass = FALSE;

    return(S_OK);
}


/* IClassClassicInfo methods */

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetThreadingModel
    (
    /* [out] */ ThreadingModel __RPC_FAR *pthreadmodel
    )
{
    switch (m_pData->ThreadingModel)
    {
    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT:
        *pthreadmodel = ApartmentThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE:
        *pthreadmodel = FreeThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE:
        *pthreadmodel = SingleThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH:
        *pthreadmodel = BothThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL:
        *pthreadmodel = NeutralThreaded;
        break;

    default:
        return REGDB_E_INVALIDVALUE;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetModulePath
    (
    /* [in] */ CLSCTX clsctx,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszDllName
    )
{
    *pwszDllName = NULL;

    /* make sure exactly one context is requested */

    if ( (clsctx & (clsctx - 1)) != 0 )
    {
        return(E_FAIL);
    }

    if (clsctx != CLSCTX_INPROC_SERVER)
        return E_FAIL;

    if (m_pData->ModuleOffset == 0)
        return E_FAIL;

    if (m_bufModulePath[0] == L'\0') 
    {
        //
        // find a full qualified filepath for the sxs redirected dll
        //
        WCHAR *pwsz = (PWSTR) (((ULONG_PTR) m_pSectionBase) + m_pData->ModuleOffset); // bare filename
        DWORD dwLen = SearchPathW(NULL, pwsz, NULL, STRLEN_WCHAR(m_bufModulePath), m_bufModulePath, NULL);
        if ((dwLen== 0) || (dwLen > STRLEN_WCHAR(m_bufModulePath)))
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }
    }

    *pwszDllName = m_bufModulePath;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetImplementedClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    *ppguidClsid = const_cast<GUID *>(&m_pData->ImplementedClsid);
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetProcess
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    *ppv = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetRemoteServerName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
    )
{
    *pwszServerName = NULL;
    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetLocalServerType
    (
    /* [out] */ LocalServerType __RPC_FAR *pType
    )
{
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetSurrogateCommandLine
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogateCommandLine
    )
{
    *pwszSurrogateCommandLine = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::MustRunInClientContext
    (
    /* [out] */ BOOL __RPC_FAR *pbMustRunInClientContext
    )
{
    *pbMustRunInClientContext = FALSE;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetVersionNumber
    (
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS
    )
{
    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::Lock(void)
{
    /* Like GetClassesRoot, but defer actually opening the */
    /* key, in case this object is already fully rendered. */

    g_CatalogLock.AcquireWriterLock();

    m_cLocks++;
    m_cLocksExternal++;

    g_CatalogLock.ReleaseWriterLock();

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::Unlock(void)
{
    g_CatalogLock.AcquireWriterLock();

    if ( m_cLocksExternal != 0 )
    {
        m_cLocksExternal--;
    }

    g_CatalogLock.ReleaseWriterLock();

    return(S_OK);
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComSxSClassInfo::CacheAddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComSxSClassInfo::CacheRelease(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\cocrguid.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       CoCreateGuid.cpp
//
//  Contents:   Guid creation
//
//  Classes:
//
//  Functions:  CoCreateGuid
//
//  History:    12-Apr-94   BruceMa    Created
//              19-Apr-94   BruceMa    Fixes chicago build
//              20-Apr-94   BruceMa    Uniqueness algorithm improved
//              28-Apr-94   Rickhi     Added UuidCreate
//              27-Jun-94   BruceMa    Use RPC system API instead of
//                                      original code
//              26-Sep-94   BruceMa    Fix incorect error code
//
//----------------------------------------------------------------------

#include <ole2int.h>
#include <rpcdce.h>

// forward reference
INTERNAL wCoCreateGuid(GUID *pGuid);

//+---------------------------------------------------------------------
//
//  Function:   CoCreateGuid
//
//  Synopsis:   Calls UuidCreate() to create a new guid.
//
//  Arguments:  [pGuid] -- Pointer to guid structure to create
//
//  Returns:    S_OK             Success
//              RPC_S_xxxx       Failure creating GUID
//
//
//----------------------------------------------------------------------
STDAPI CoCreateGuid(GUID *pGuid)
{
    OLETRACEIN((API_CoCreateGuid, PARAMFMT("pGuid= %p"), pGuid));

    HRESULT hr;

    if (!IsValidPtrOut(pGuid, sizeof(*pGuid)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = wCoCreateGuid(pGuid);
    }

    OLETRACEOUT((API_CoCreateGuid, hr));
    return hr;
}



//+---------------------------------------------------------------------
//
//  Function:   wCoCreateGuid               (internal)
//
//  Synopsis:   Calls UuidCreate() to create a new guid.
//
//  Arguments:  [pGuid] -- Pointer to guid structure to create
//
//  Returns:    S_OK             Success
//              RPC_S_xxxx       Failure creating GUID
//
//
//----------------------------------------------------------------------
INTERNAL wCoCreateGuid(GUID *pGuid)
{
    int err;

    // We simply use the RPC system supplied API
    if ((err = UuidCreate(pGuid)) != RPC_S_UUID_LOCAL_ONLY)
    {
        return err ? HRESULT_FROM_WIN32(err) : S_OK;
    }

    return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\compobj.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       d:\nt\private\cairole\com\class\compobj.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:  GetInfoLevel
//              DllMain
//              CheckAndStartSCM
//              CoGetCurrentProcess
//              CoBuildVersion
//              SetOleThunkWowPtr
//              CoInitializeWOW
//              CoInitialize
//              CoInitializeEx
//              CoUninitialize
//
//  History:    09-Jun-94   BruceMa    Added this file header
//              09-Jun-94   BruceMa    Distinguish CoInitialize errors
//              14-Jun-94   BruceMa    Ensure single threading
//              17-Jun-94   Bradlo     Add SetState/GetState
//              06-Jul-94   BruceMa    Support for CoGetCurrentProcess
//              28-Jul-94   BruceMa    Allow CoGetCurrentProcess to do a
//                                     partial CoInitialize (because Publisher
//                                     didn't call CoInitialize (!))
//              29-Aug-94   AndyH      set the locale for the CRT
//              29-Sep-94   AndyH      remove setlocale call
//              06-Oct-94   BruceMa    Allow CoGetCurrentProcess to work even
//                                     if that thread didn't call CoInitialize
//              09-Nov-94   BruceMa    Initialize/Delete IMallocSpy
//                                      critical section
//              12-Dec-94   BruceMa    Delete Chicago pattern table at
//                                      CoUninitialize
//              09-Jan-95   BruceMa    Initialize/Delete ROT
//                                      critical section
//              10-May-95   KentCe     Defer Heap Destruction to the last
//                                      process detach.
//              28-Aug-95   BruceMa    Close g_hRegPatTblEvent at
//                                      ProcessUninitialize
//              25-Sep-95   BruceMa    Check that scm is started during
//                                      CoInitialize
//              25-Oct-95   Rickhi     Improve CoInit Time.
//              20-Jan-96   RichN      Add Rental model
//              04-Dec-97   ronan      Com Internet Services - self registration for objrefs
//              10-Feb-99   TarunA     Allow async sends to finish
//
//----------------------------------------------------------------------
// compobj.cpp - main file for the compobj dll

#include <ole2int.h>
#include <verole.h>     // for CoBuildVersion
#include <thunkapi.hxx> // For interacting with the VDM
#include <hkole32.h>    // For InitHookOle

#include <olespy.hxx>

#include "pattbl.hxx"
#include "pexttbl.hxx"

#include <olepfn.hxx>
#include "..\dcomrem\channelb.hxx"
#include "..\dcomrem\call.hxx"
#include "..\dcomrem\context.hxx"
#include "..\dcomrem\crossctx.hxx"
#include "..\dcomrem\aprtmnt.hxx"
#include "..\objact\actvator.hxx"
#include "..\objact\dllcache.hxx"
#include <excepn.hxx>       // Exception filter routines

#include "rwlock.hxx"

#define SAFEALLOCA_ASSERT Win4Assert
#include <alloca.h>

#if DBG==1
#include <outfuncs.h>
#endif

#if LOCK_PERF==1
void OutputHashPerfData();
#endif

NAME_SEG(CompObj)
ASSERTDATA

HRESULT Storage32DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
HRESULT MonikerDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
HRESULT Ole232DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
EXTERN_C HINSTANCE hProxyDll;
EXTERN_C HRESULT PrxDllRegisterServer(void);
EXTERN_C HRESULT ComcatDllRegisterServer(void);
EXTERN_C HRESULT ObjrefDllRegisterServer(void);
EXTERN_C HRESULT TxfDllRegisterServer(void);
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);

extern BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
);

extern "C"
BOOL WINAPI TxfDllMain (
	HINSTANCE hInstance, 
	DWORD dwReason, 
	LPVOID /*lpReserved*/
);

HRESULT FixUpPipeRegistry(void);

HRESULT MallocInitialize(void);
BOOL    MallocUninitialize(void);

STDAPI  OleReleaseEnumVerbCache();
extern void ClipboardProcessUninitialize();
extern void CleanROTForApartment();
extern HRESULT DllHostProcessInitialize();
extern void DllHostThreadUninitialize();
extern void DllHostProcessUninitialize();
extern BOOL IsMTAHostInitialized();
extern ULONG gcHostProcessInits;
extern ULONG gcNAHosts;
extern void GIPTableProcessUninitialize();
extern void GIPTableApartmentUninitialize();
extern void CleanupTlsMap(BOOL fDynamic);
extern void ProcessUninitTlsCleanup(void);
extern void AssertDebugInit();

extern CProcessPatternTbl *g_pPatTbl;
extern CProcessExtensionTbl *g_pExtTbl;

extern void ScmGetThreadId( DWORD * pThreadID );

static long g_cCoSetState = 0;          // # of outstanding CoSetState calls
static HINSTANCE g_hOleAut32 = NULL;    // module handle of oleaut32
static COleStaticMutexSem g_mxsCoSetState;

STDAPI CoSetState(IUnknown *punkStateNew);
WINOLEAPI CoSetErrorInfo(DWORD dwReserved, IErrorInfo * pErrorInfo);

void ProcessUninitialize( void );
void DoThreadSpecificCleanup();
void WaitForPendingAsyncSends();

COleStaticMutexSem  g_mxsSingleThreadOle; // CS to prevent both STA/MTA init races
COleStaticMutexSem  gMTAInitLock;         // CS to protect MTA init races
DWORD               gcInitingMTA;         // Number of threads trying to init MTA

// The following pointer is used to hold an interface to the
// WOW thunk interface.

LPOLETHUNKWOW     g_pOleThunkWOW = NULL;

// The following is the count of per-process CoInitializes that have been done.
DWORD             g_cProcessInits  = 0;     // total per process inits
DWORD             g_cMTAInits      = 0;     // # of multi-threaded inits
DWORD             g_cSTAInits      = 0;     // # of apartment-threaded inits
BOOL              g_fShutdownHosts = FALSE; // Shutdown hosts
CObjectContext   *g_pMTAEmptyCtx   = NULL;  // MTA empty context
CObjectContext   *g_pNTAEmptyCtx   = NULL;  // NTA empty context

// Holds the process id of SCM.  DCOM uses this to unmarshal an object
// interface on the SCM.  See MakeSCMProxy in dcomrem\ipidtbl.cxx.
DWORD gdwScmProcessID = 0;

extern CComApartment* gpMTAApartment;     // global MTA Apartment
extern CComApartment* gpNTAApartment;     // global NTA Apartment

// Process secret
GUID gProcessGuid = GUID_NULL;

INTERNAL CleanupLeakedDomainStack (COleTls& Tls, CObjectContext* pCorrectCtx);


#if DBG==1
//---------------------------------------------------------------------------
//
//  function:   GetInfoLevel
//
//  purpose:    This routine is called when a process attaches. It extracts
//              the debug info levels values from win.ini.
//
//---------------------------------------------------------------------------

//  externals used below in calls to this function
extern "C" unsigned long olInfoLevel;       //  lower layer storage
extern "C" unsigned long msfInfoLevel;      //  upper layer storage
extern "C" unsigned long filestInfoLevel;   //  Storage file ILockBytes
extern "C" unsigned long simpInfoLevel;     //  Simple mode storage
extern "C" unsigned long astgInfoLevel;     //  Async storage
extern "C" unsigned long LEInfoLevel;       //  linking and embedding
extern "C" unsigned long RefInfoLevel;      //  CSafeRef class
extern "C" unsigned long DDInfoLevel;       //  Drag'n'drop
extern "C" unsigned long mnkInfoLevel;      //  Monikers
extern "C" unsigned long propInfoLevel;     //  properties

// Silences checked build excepn popups when true
extern BOOL gfSuppressDebugExceptionPopup;

extern DWORD g_dwInfoLevel;

DECLARE_INFOLEVEL(intr);                  // For 1.0/2.0 interop
DECLARE_INFOLEVEL(UserNdr);               // For Oleprxy32 and NDR
DECLARE_INFOLEVEL(Stack);                 // For stack switching
DECLARE_INFOLEVEL(ClsCache);              // Class Cache
DECLARE_INFOLEVEL(RefCache);              // Reference Cache
DECLARE_INFOLEVEL(Call);                  // Call tracing
DECLARE_INFOLEVEL(Context);               // Context


ULONG GetInfoLevel(CHAR *pszKey, ULONG *pulValue, CHAR *pszdefval)
{
    CHAR    szValue[20];
    DWORD   cbValue = sizeof(szValue);

    // if the default value has not been overridden in the debugger,
    // then get it from win.ini.

    if (*pulValue == (DEB_ERROR | DEB_WARN))
    {
        if (GetProfileStringA("CairOLE InfoLevels", // section
                          pszKey,               // key
                          pszdefval,             // default value
                          szValue,              // return buffer
                          cbValue))
        {
            *pulValue = strtoul (szValue, NULL, 16);
        }
    }

    return  *pulValue;
}

extern ULONG g_dwInterceptLevel;

VOID GetInterceptorLevel()
{
    CHAR    szValue[20];
    DWORD   cbValue = sizeof(szValue);
    CHAR   *pszdefval = "0x10000001";               // ON | NOINOUT    

    if (GetProfileStringA("CairOLE",                // section
                          "Interceptors",           // key
                          pszdefval,                // default value
                          szValue,                  // return buffer
                          cbValue))
    {
        g_dwInterceptLevel = strtoul (szValue, NULL, 16);
    }
}

// Maps "Y" and "N" to BOOL's
VOID GetBoolFlag(CHAR* pszKey, BOOL* pfFlag, BOOL fDefaultFlag)
{
    CHAR    szValue[20];
    DWORD   cbValue = sizeof(szValue);
    CHAR   *pszdefval = fDefaultFlag ? "Y" : "N";

    if (GetProfileStringA("CairOLE",                // section
                          pszKey,                   // key
                          pszdefval,                // default value
                          szValue,                  // return buffer
                          cbValue))
    {
        if (!lstrcmpiA(szValue, "Y"))
            *pfFlag = TRUE;
        else if (!lstrcmpiA(szValue, "N"))
            *pfFlag = FALSE;
        else
            *pfFlag = fDefaultFlag;
    }
    else
        *pfFlag = fDefaultFlag;
}

BOOL fSSOn = TRUE;

#endif // DBG


//+-------------------------------------------------------------------------
//
//  Function:   ObjRefDllRegisterServer
//
//  Synopsis:   add OBJREF moniker to the registry
//
//  History:    21-Jan-98 RonanS    Created
//
//--------------------------------------------------------------------------
STDAPI ObjrefDllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32,  hkObjref, hkProgId = NULL;
    DWORD dwDisposition;
    HRESULT hr;

    // create clsid key
    hr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    _T("CLSID\\{00000327-0000-0000-C000-000000000046}"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyCLSID, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        // set short name
        hr = RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) _T("objref"), sizeof(TCHAR)*(lstrlen(_T("objref"))+1));
        if (SUCCEEDED(hr))
        {
            // set up inproc server
            hr = RegCreateKeyEx(hKeyCLSID,
                          _T("InprocServer32"),
                          NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyInproc32, &dwDisposition);

            if (SUCCEEDED(hr))
            {
                TCHAR szName[] = _T("OLE32.DLL");
                hr = RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1));

                if (SUCCEEDED(hr))
                    hr = RegSetValueEx(hKeyInproc32, _T("ThreadingModel"), NULL, REG_SZ, (BYTE*) _T("Both"), sizeof(_T("Both")));

                RegCloseKey(hKeyInproc32);
            }

            // set up progid
            if (SUCCEEDED(hr))
                hr = RegCreateKeyEx(hKeyCLSID,
                       _T("ProgID"),
                       NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                       &hkProgId, &dwDisposition);

            if (SUCCEEDED(hr))
            {
                TCHAR szProgId[] = _T("objref");
                hr = RegSetValueEx(hkProgId, _T(""), NULL, REG_SZ, (BYTE*) szProgId, sizeof(TCHAR)*(lstrlen(szProgId)+1));
                RegCloseKey(hkProgId);
            }
        }

        RegCloseKey(hKeyCLSID);
    }

    if (FAILED(hr))
        return E_UNEXPECTED;

    // RegCreateKeyEx will open the key if it exists
    hr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    _T("objref"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hkObjref, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        // set short name
        hr = RegSetValueEx(hkObjref, _T(""), NULL, REG_SZ, (BYTE*) _T("objref"), sizeof(TCHAR)*(lstrlen(_T("objref"))+1));


        if (SUCCEEDED(hr))
            hr = RegCreateKeyEx(hkObjref,
                     _T("CLSID"),
                     NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                     &hKeyCLSID, &dwDisposition);

        if (SUCCEEDED(hr))
        {
             TCHAR szClsid[] = _T("{00000327-0000-0000-C000-000000000046}");
             hr = RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) szClsid, sizeof(TCHAR)*(lstrlen(szClsid)+1));
             RegCloseKey(hKeyCLSID);
        }

        RegCloseKey(hkObjref);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ObjRefDllUnRegisterServer
//
//  Synopsis:   remove OBJREF moniker from the registry
//
//  History:    21-Jan-98 RonanS    Created
//
//--------------------------------------------------------------------------
STDAPI ObjrefDllUnregisterServer(void)
{
    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("CLSID\\{00000327-0000-0000-C000-000000000046}\\InprocServer32"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("CLSID\\{00000327-0000-0000-C000-000000000046}\\ProgID"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("CLSID\\{00000327-0000-0000-C000-000000000046}"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }

    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("objref\\CLSID"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }

    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
               _T("objref"))!=ERROR_SUCCESS)
    {
       return E_UNEXPECTED;
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Dll entry point
//
//  Arguments:  none
//
//  Returns:    S_OK - class register successfully.
//
//  History:    10-Mar-97 YongQu    Created
//
//  Note:       merge component category
//--------------------------------------------------------------------------
STDAPI  DllRegisterServer(void)
{
    HRESULT hr;

    hr = PrxDllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = ObjrefDllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = ComcatDllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = Storage32DllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = FixUpPipeRegistry();
	if (FAILED(hr))
		return hr;

	hr = TxfDllRegisterServer();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//  History:    21-Jan-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    OLETRACEIN((API_DllGetClassObject, PARAMFMT("rclsid= %I,iid= %I,ppv= %p"),
               &clsid, &iid, ppv));

    // try proxy dll first, since it is the most common case.
    HRESULT hr = ProxyDllGetClassObject(clsid, iid, ppv);
    if (FAILED(hr))
    {
        // second most common case
        hr = ComDllGetClassObject( clsid, iid, ppv );
        if (FAILED(hr))
        {
            hr = Storage32DllGetClassObject(clsid, iid, ppv);
            if (FAILED(hr))
            {
                hr = MonikerDllGetClassObject(clsid, iid, ppv);
                if (FAILED(hr))
                {
                    // Ole232 will succeed for any class id so it MUST
                    // be the last one in the list.
                    if (IsEqualCLSID(clsid, CLSID_ATHostActivator))
                    {
                        hr = REGDB_E_CLASSNOTREG;
                    }
                    else
                    {
                        hr = Ole232DllGetClassObject(clsid, iid, ppv);
                    }
                }
            }
        }
    }

    OLETRACEOUT((API_DllGetClassObject, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Dll entry point for OLE/COM
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//              If we are called because of FreeLibrary, then we should do as
//              much cleanup as we can. If we are called because of process
//              termination, we should not do any cleanup, as other threads in
//              this process will have already been killed, potentially while
//              holding locks around resources.
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//  History:    06-Dec-93 Rickhi    dont do cleanup on process exit
//              09-Nov-94 BruceMa   Initialize/Delete IMallocSpy
//                                   critical section
//              16-Jan-95 KevinRo   Changed to DllMain to remove a bunch
//                                  of unneeded code and calls
//
//--------------------------------------------------------------------------

#if DBG==1
extern COleStaticMutexSem g_mxsVdprintf;
extern BOOL g_mxsVdprintfInitialized;
#endif

extern "C" BOOL WINAPI DllMain(
    HANDLE hInstance,
    DWORD dwReason,
    LPVOID lpvReserved)
{
    HRESULT hr;

    //Initialize hInstance for PrxDllRegisterServer.
    hProxyDll = (HINSTANCE) hInstance;

    if (dwReason == DLL_PROCESS_DETACH)
    {
#if DBG==1
        // Don't use g_mxsVdprintf anymore
        g_mxsVdprintfInitialized = FALSE;
#endif

        CairoleDebugOut((DEB_DLL,
                         "DLL_PROCESS_DETACH: %s\n",
                         lpvReserved?"Process Exit":"Dll Unload"));

        // Process is exiting so lets clean up if we have to
#if LOCK_PERF==1
        OutputHashPerfData();
#endif

#if DBG==1
        // Update state to indicate process detach
        CairoleAssert (g_fDllState == DLL_STATE_NORMAL);
        g_fDllState = DLL_STATE_PROCESS_DETACH;
#endif

        // Do Thread specific cleanup
        ThreadNotification((HINSTANCE)hInstance, dwReason, lpvReserved);

        //
        // When there is a FreeLibrary, and we still have initialized OLE
        // com threads, then try to get rid of all of the global process
        // stuff we are maintaining.
        //
        if (g_cProcessInits != 0 && lpvReserved == NULL )
        {
            // Cleanup process
            ProcessUninitialize();

            // UnInitialize HookOle.
            // This unloads the Hookole dll.
            UninitHookOle();
        }

        //  Clean up catalog
        (void) CatalogDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved);

        //  Clean up txfaux
        (void) TxfDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved);

        // Cleanup TLS map
        CleanupTlsMap(lpvReserved ? FALSE : TRUE);

        // Uninitialize memory allocator
        MallocUninitialize();

#if DBG==1
        CloseDebugSinks();
#endif

        //
        //  Only bother to rundown the static mutex pool if we're being
        //  unloaded w/o exiting the process
        //

#if LOCK_PERF!=1
        // When monitoring the locks, we do need individual lock cleanup.
        if (lpvReserved == NULL)
        {
#endif
            // Cleanup Reader-Writer locks
            gPSRWLock.Cleanup();
            CClassCache::_mxs.Cleanup();

            //
            //      Destruct the static mutex pool
            //

            while (g_pInitializedStaticMutexList != NULL)
            {
                COleStaticMutexSem * pMutex;

                pMutex = g_pInitializedStaticMutexList;
                g_pInitializedStaticMutexList = pMutex->pNextMutex;
                pMutex->Destroy();
            }

#if LOCK_PERF!=1
        }
#endif
	
        if (gfOleMutexCreationSemOkay)
        {
            DeleteCriticalSection (&g_OleMutexCreationSem);
            gfOleMutexCreationSemOkay = FALSE;
        }
        if (gfOleGlobalLockOkay)
        {
            DeleteCriticalSection (&g_OleGlobalLock);
            gfOleGlobalLockOkay = FALSE;
        }

#if LOCK_PERF==1
        // This must be done after the cleanup block for locks above
        // The destroy routines of locks report contention counts etc.
        gLockTracker.OutputPerfData();
#endif


#if DBG==1
        // Update state to indicate that static objects are
        // being destroyed
        g_fDllState = DLL_STATE_STATIC_DESTRUCTING;

        // Clean up g_mxsVdprintf critsec so the verifier doesn't complain about a leaked 
        // critsec on checked builds when ole32 is unloaded
        //
        // By the time we get here, we're protected by the loader lock,
        // so we don't really need the critical section anyway
        g_mxsVdprintf.Destroy();
#endif

        return TRUE;
    }


    else if (dwReason == DLL_PROCESS_ATTACH)
    {
        //
        // Initialize SafeAlloca
        //
        SafeAllocaInitialize (
            (MAX_PATH + 3) * sizeof (WCHAR),    // alloca at most a MAX_PATH WCHAR buffer
            SAFEALLOCA_USE_DEFAULT,             // use default additional probe size
            NULL, NULL);                        // use default heap allocators

        // Create a secret guid for the process
        RPC_STATUS sc = UuidCreate (&gProcessGuid);
        if (sc != RPC_S_OK)
            return FALSE;
            
        // Initialize the mutex package. Do this BEFORE doing anything
        // else, as even a DebugOut will fault if the critical section
        // is not initialized.        
        NTSTATUS status;
        status = RtlInitializeCriticalSection(&g_OleMutexCreationSem);
        if (!NT_SUCCESS(status))
            return FALSE;

        gfOleMutexCreationSemOkay = TRUE;

        status = RtlInitializeCriticalSection(&g_OleGlobalLock);
        if (!NT_SUCCESS(status))
            return FALSE;

        gfOleGlobalLockOkay = TRUE;

#if LOCK_PERF==1
        hr = gLockTracker.Init(); //static initialization function
        CairoleAssert(SUCCEEDED(hr));
#endif
        // Initialize Reader-Writer locks
        CStaticRWLock::InitDefaults();
        gPSRWLock.Initialize();
        CClassCache::_mxs.Initialize();


        ComDebOut((DEB_DLL,"DLL_PROCESS_ATTACH:\n"));

        //
        //  Initialize catalog
        //

        (void) CatalogDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved);


#if DBG==1

        // Can't use Win4Assert (NULL == GetModuleHandle(_T("csrsrv.dll")));
        // because a window will attempt to be created by MessageBox which crashes
        // CSRSS.

        if (GetModuleHandle(_T("csrsrv.dll")) != NULL)
        {
            // Loaded into CSRSS, so debug output and breakpoint
            CairoleDebugOut((DEB_ERROR, "OLE32 can't be loaded into CSRSS. File a bug against code loading OLE32, not OLE32 itself!\n"));
            DebugBreak();
        }

        // Note that we've completed running the static constructors

        CairoleAssert (g_fDllState == DLL_STATE_STATIC_CONSTRUCTING);

        g_fDllState = DLL_STATE_NORMAL;

#endif


#if DBG==1
        AssertDebugInit();
        OpenDebugSinks(); // Set up for logging

        //  set the various info levels
        GetInfoLevel("cairole", &CairoleInfoLevel, "0x0003");
        GetInfoLevel("ol", &olInfoLevel, "0x0003");
        GetInfoLevel("msf", &msfInfoLevel, "0x0003");
        GetInfoLevel("filest", &filestInfoLevel, "0x0003");
        GetInfoLevel("simp", &simpInfoLevel, "0x0003");
        GetInfoLevel("astg", &astgInfoLevel, "0x0003");
        GetInfoLevel("LE", &LEInfoLevel, "0x0003");
        GetInfoLevel("Ref", &RefInfoLevel, "0x0003");
        GetInfoLevel("DD", &DDInfoLevel, "0x0003");
        GetInfoLevel("mnk", &mnkInfoLevel, "0x0003");
        GetInfoLevel("intr", &intrInfoLevel, "0x0003");
        GetInfoLevel("UserNdr", &UserNdrInfoLevel, "0x0003");
        GetInfoLevel("Stack", &StackInfoLevel, "0x0003");
        GetInfoLevel("ClsCache", &ClsCacheInfoLevel, "0x0003");
        GetInfoLevel("RefCache", &RefCacheInfoLevel, "0x0003");
        GetInfoLevel("Call", &CallInfoLevel, "0x0003");
        GetInfoLevel("Context", &ContextInfoLevel, "0x0003");
        GetInfoLevel("prop", &propInfoLevel, "0x0003");
        GetBoolFlag("SuppressDebugExceptionPopup", &gfSuppressDebugExceptionPopup, FALSE);
        StgDebugInit();

        // Set whether interception is on/off/conditional
        GetInterceptorLevel();

        ULONG dummy;

        // Get API trace level
        dummy = DEB_WARN|DEB_ERROR;
        GetInfoLevel("api", &dummy, "0x0000");
        g_dwInfoLevel = (DWORD) dummy;

        fSSOn = (BOOL)GetInfoLevel("StackOn", &dummy, "0x0003");

#endif //DBG==1

        //Initialize the OLE retail memory allocator.
        hr = MallocInitialize();

        if(FAILED(hr))
        {
            ComDebOut((DEB_ERROR, "Failed to init memory allocator hr:%x",hr));
            return FALSE;
        }
        
        //  Fire up TxfAux
        if (!TxfDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved))
        {
            ComDebOut((DEB_ERROR, "Failed to init txfdllmain; gle:%d", GetLastError()));
            return FALSE;
        }

        //
        // this will be needed for the J version
        //        setlocale(LC_CTYPE, "");
        //
        g_hmodOLE2 = (HMODULE)hInstance;
        g_hinst    = (HINSTANCE)hInstance;

        InitializeOleSpy(OLESPY_TRACE);

#ifdef  TRACELOG
        if (!sg_pTraceLog)
        {
            sg_pTraceLog = (CTraceLog *) new CTraceLog();
            if (sg_pTraceLog)
            {
            	if (sg_pTraceLog->FInit() == FALSE)
            	{
            	    delete sg_pTraceLog;
            	    sg_pTraceLog = NULL;
            	}
            }
            CairoleAssert(sg_pTraceLog && "Create Trace Log Failed");
        }
#endif  // TRACELOG

        //
        // Initialize HookOle.
        // This checks the state of the global hook switch
        // and initializes hookole if it is on.
        //
        InitHookOle();
    }

    return ThreadNotification((HINSTANCE)hInstance, dwReason, lpvReserved);
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessInitialize, private
//
//  Synopsis:   Performs all of the process initialization.  Happens when
//              the first com thread calls CoInitialize.
//
//  Arguments:  None.
//
//  Returns:    S_OK, CO_E_INIT_RPC_CHANNEL, E_FAIL
//
//  History:    29-Aug-95   RickHi  Created
//
//----------------------------------------------------------------------------
HRESULT ProcessInitialize()
{
    HRESULT hr = S_OK;

    // Initialize the OleSpy
    InitializeOleSpy(OLESPY_CLIENT);

    // Initialize Access Control.
    if (SUCCEEDED(hr))
    {
        hr = InitializeAccessControl();

        if (SUCCEEDED(hr))
        {
            // Initialize wrapper objects. This is needed
            // for the creation of the context objects in CoInit.
            CStdWrapper::Initialize();

            // init the dll host objects
            hr = DllHostProcessInitialize();
            if (SUCCEEDED(hr))
            {
                // Initialize activation
                hr = ActivationProcessInit();
            }
        }
    }

    ComDebErr(FAILED(hr), "ProcessInitialize failed\n");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessUninitialize, private
//
//  Synopsis:   Performs all of the process de-initialization.  Happens when
//              the last com thread calls CoUninitialize, or when the
//              DLL_PROCESS_DETACH notification comes through.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    29-Aug-94   RickHi  Created
//
//----------------------------------------------------------------------------
void ProcessUninitialize()
{
    // clean up clipboard window class registration
    ClipboardProcessUninitialize();

    // Free Enum verb cache
    OleReleaseEnumVerbCache();

    // cleanup activation entries
    ActivationProcessCleanup();

    // cleanup GIP Table entries
    GIPTableProcessUninitialize();

    // clean up the rot
    DestroyRunningObjectTable();

    // Cleanup wrapper objects
    CStdWrapper::Cleanup();

    // Turn off RPC
    ChannelProcessUninitialize();

    // Cleanup Access Control.
    UninitializeAccessControl();

    // Release references on catalog objects held in
    // the Dll Cache.
    CCReleaseCatalogObjects();

    // Clean up catalog
    UninitializeCatalog();

    // Free loaded Dlls class cache
    CCCleanUpDllsForProcess();

    // Delete the per process pattern lookup table
    if (g_pPatTbl != NULL)
    {
        delete g_pPatTbl;
        g_pPatTbl = NULL;
    }

    // Delete the per process extension lookup table
    if (g_pExtTbl != NULL)
    {
        delete g_pExtTbl;
        g_pExtTbl = NULL;
    }

#ifdef  TRACELOG
    if (sg_pTraceLog)
    {
        CTraceLog *pTraceLog = sg_pTraceLog;
        sg_pTraceLog = NULL;         //  prevent more entries into the log
        delete pTraceLog;            //  delete the log, also dumps it.
    }
#endif  // TRACELOG

    UninitializeOleSpy(OLESPY_TRACE);

    // If WOW is going down, disable it.
    // WARNING: IsWOWThread & IsWOWProcess will no longer return valid results!!!!
    g_pOleThunkWOW = NULL;

    // Cleanup relavant TLS entries at process uninit time
    ProcessUninitTlsCleanup();
}


//+---------------------------------------------------------------------------
//
//  Function:   FinishShutdown     Private
//
//  Synopsis:   This routine cleans up all the apartment bound structures
//              that could potentially make outgoing calls
//
//  History:    07-Jul-98  GopalK   Created
//              17-May-01  Jsimmons Added exception handlers around calls into
//                                  user code to make us more robust during shutdown.
//                                  (this also hides user bugs, unfortunately).
//
//----------------------------------------------------------------------------
void FinishShutdown()
{
    __try
    {
        // cleanup per apartment registered LocalServer class table
        CCCleanUpLocalServersForApartment();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), NULL, IID_IUnknown, 0))
    {
    }

    // cleanup per apartment object activation server objects
    ActivationAptCleanup();

    // clean up the Dll Host Apartments
    DllHostThreadUninitialize();

    __try
    {
        // cleanup the gip table for the current apartment
        GIPTableApartmentUninitialize();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), NULL, IID_IUnknown, 0))
    {
    }

    __try
    {
        // cleanup per apartment identity objects
        gOIDTable.ThreadCleanup();
        gPIDTable.ThreadCleanup();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), NULL, IID_IUnknown, 0))
    {
    }

    __try
    {
        // cleanup per apartment ROT.
        CleanROTForApartment();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), NULL, IID_IUnknown, 0))
    {
    }

    __try
    {
        // cleanup per apartment Dll class table.
        CCCleanUpDllsForApartment();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), NULL, IID_IUnknown, 0))
    {
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ThreadStop
//
//  Synopsis:   Per thread uninitialization
//
//  History:    ??-???-??  ?         Created
//              05-Jul-94  AlexT     Separated thread and process uninit
//              11-Feb-98  JohnStra  Made NTA aware
//              02-Jul-98  GopalK    Simplified
//
//  Notes:      We are holding the single thread mutex during this call
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) ThreadStop(BOOL fHostThread)
{
    ComDebOut((DEB_CALLCONT, "ThreadStop entered. fHostThread:%x\n", fHostThread));

    BOOL fStopped = TRUE;

    // Get the local apartment object
    CComApartment *pComApt = NULL;
    GetCurrentComApartment(&pComApt);

    if (pComApt != NULL)
    {
        // Mark the apartment as stopped
        pComApt->StopServer();

        // Check if dispatched calls have rehydrated the apartment
        if(!fHostThread)
        {
            COleTls Tls;

            // Check apartment type
            if(Tls->dwFlags & OLETLS_APARTMENTTHREADED)
            {
                if(Tls->cComInits > 1)
                {
                    ComDebOut((DEB_CALLCONT, "STA reinited in ThreadStop\n"));
                    fStopped = FALSE;
                }
            }
            else
            {
                if((IsMTAHostInitialized() ? (g_cMTAInits-1) : g_cMTAInits) > 1)
                {
                    ComDebOut((DEB_CALLCONT, "MTA reinited in ThreadStop\n"));
                    fStopped = FALSE;
                }
            }

            // Check for rehydrated apartments
            if(!fStopped)
            {
                pComApt->RestartServer();
            }
        }

        pComApt->Release();
    }

    WaitForPendingAsyncSends();

    ComDebOut((DEB_CALLCONT,
               "ThreadStop returning %s\n", fStopped ? "TRUE" : "FALSE"));    
    return(fStopped);
}

//+-------------------------------------------------------------------------
//
//  Function:   WaitForPendingAsyncSends
//
//  Synopsis:   Wait for async sends to complete
//
//  History:    10-Feb-99   TarunA      Created
//
//  Notes:      
//
//--------------------------------------------------------------------------
void WaitForPendingAsyncSends()
{
    ComDebOut((DEB_CALLCONT, "WaitForPendingAsyncSends entered\n"));
    COleTls Tls;
    // Wait for a random period of time to allow
    // async sends to complete
    DWORD i = 0;
    while((0 < Tls->cAsyncSends) && i < 10)
    {
        // Wait in an alertable state to receive callback 
        // notifications from RPC
        SleepEx(5,TRUE);
        i++;
    }
    if(0 < Tls->cAsyncSends)
    {
        // Sanity check
        Win4Assert(NULL != Tls->pAsyncCallList);
        // Cleanup the list
        Tls->cAsyncSends = 0;    
        while(NULL != Tls->pAsyncCallList)
        {
            CAsyncCall* pCall = Tls->pAsyncCallList;
            Tls->pAsyncCallList = Tls->pAsyncCallList->_pNext;
            // Decrement the extra addref taken before calling RPC
            pCall->Release();
        }
    }
    ComDebOut((DEB_CALLCONT, "WaitForPendingAsyncSends returning\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   NAUninitialzie, private
//
//  Synopsis:   Uninitialize the neutral apartment.
//
//  History:    15-May-98   Johnstra  Created
//
//----------------------------------------------------------------------------
void NAUninitialize()
{
    // Switch thread into the NA.
    CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);

    // Stop the apartment
    ThreadStop(TRUE);

    // Cleanup NTA
    FinishShutdown();
    ChannelThreadUninitialize();

    // Free global neutral apartment object
    if (gpNTAApartment)
    {
        gpNTAApartment->Release();
        gpNTAApartment = NULL;
    }

    // Release the global NA empty context
    if (g_pNTAEmptyCtx)
    {
        g_pNTAEmptyCtx->InternalRelease();
        COleTls Tls;
        Tls->pCurrentCtx = NULL;
        Tls->ContextId = (ULONGLONG)-1;
        g_pNTAEmptyCtx = NULL;
    }

    // Switch thread back to the original apartment
    LeaveNTA(pSavedCtx);
}

//+---------------------------------------------------------------------------
//
//  Function:   ApartmentUninitialize, private
//
//  Synopsis:   Performs all of the process uninitialization needed when a
//              Single-Threaded Apartment uninitializes, and when the
//              Multi-Threaded apartment uninitializes.
//
//  returns:    TRUE - uninit complete
//              FALSE - uninit aborted
//
//  History:    11-Mar-96   RickHi  Created
//              02-Jul-98   GopalK  Modified for NA shutdown
//
//----------------------------------------------------------------------------
BOOL ApartmentUninitialize(BOOL fHostThread)
{
    // Sanity check
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);

    // NOTE: The following sequence of uninitializes is critical:
    //
    // 1) Prevent incoming calls
    // 2) LocalServer class cache
    // 3) object activation (objact) server object
    // 4) Dll host server object
    // 5) standard identity table
    // 6) running object table
    // 7) Dll class cache
    // 8) Channel cleanup - should not touch proxies/stubs
    COleTls tls;
    BOOL fSTA = tls->dwFlags & OLETLS_APARTMENTTHREADED;
    BOOL fUnlock = FALSE;

    // Shutdown the apartment
    BOOL fStopped = ThreadStop(fHostThread);

    if(fSTA)
    {
        if(!fStopped)
        {
            return(FALSE);
        }
            
    }
    else
    {
        if(fStopped)
        {
            // Acquire MTA init lock to prevent MTA from getting reinited
            // while we are shutting down the apartment
            LOCK(gMTAInitLock);
            fUnlock = TRUE;                        
            if(g_cMTAInits > (DWORD)(IsMTAHostInitialized() ? 2 : 1))
            {
                fStopped = FALSE;
            }
                
        }
    }

    // Finish all outgoing calls from the apartment
    if(fStopped)
    {
        // This should always succeed
        HRESULT hr = CleanupLeakedDomainStack (tls, tls->pNativeCtx);
        Win4Assert (SUCCEEDED (hr));

        FinishShutdown();
    }

    // Unlock MTA init lock if neccessary
    if(fUnlock)
    {
        UNLOCK(gMTAInitLock);
    }

    // Acquire lock
    LOCK(g_mxsSingleThreadOle);
    if(!fStopped)
    {
        if(!fSTA)
        {
            ComDebOut((DEB_WARN, "MTA reinited during last shutdown\n"));
            if(gpMTAApartment) gpMTAApartment->RestartServer();
        }

        return(FALSE);
    }
        

    // Check for the need to cleanup Dll host threads
    if(!fHostThread && !g_fShutdownHosts &&
       (g_cProcessInits-1 == gcHostProcessInits-gcNAHosts))
    {
        // Update state to indicate that host aparments
        // are being shutdown
        g_fShutdownHosts = TRUE;

        // Note that the following function yields the lock
        // and the init counts can change. ThreadStop ignores
        // app code reinits host apartments. We need to honors
        // reinits for MTA host apartment only
        DllHostProcessUninitialize();

        // Restore state to indicate that host apartment shutdown
        // is complete
        g_fShutdownHosts = FALSE;
    }

    // NOTE: g_mxsSingleThreadOle should not be released
    //       from this point onwards. GopalK
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);

    // Check if we have to re-start the MTA
    if(!fSTA)
    {
        if(g_cMTAInits > 1)
        {
            ComDebOut((DEB_WARN, "MTA reinited during last shutdown\n"));
            if(gpMTAApartment)
                gpMTAApartment->RestartServer();
            return(FALSE);
        }
    }

    // Uninit NA if needed
    if(1 == g_cProcessInits)
        NAUninitialize();

    // Cleanup apartment channel
    ChannelThreadUninitialize();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetOleThunkWowPtr
//
//  Synopsis:   Sets the value of g_pOleThunkWOW, as part of CoInitializeWow
//              and OleInitializeWow. This function is called by these
//              routines.
//
//  Effects:
//
//  Arguments:  [pOleThunk] --  VTable pointer to OleThunkWow interface
//
//  Returns:    none
//
//  History:    4-05-94   kevinro   Created
//----------------------------------------------------------------------------
void SetOleThunkWowPtr(LPOLETHUNKWOW lpthk)
{
    //
    // The theory here is that the lpthk parameter is the address into the
    // olethk32.dll and once loaded will never change. Therefore it only
    // needs to be set on the first call. After that, we can ignore the
    // subsequent calls, since they should be passing in the same value.
    //
    // If g_pOleThunkWOW is set to INVALID_HANDLE_VALUE, then OLETHK32 had
    // been previously unloaded, but is reloading
    //
    // I don't belive there is a multi-threaded issue here, since the pointer
    // value will always set as the same. Therefore, if two threads set it,
    // no problem.
    //

    if(!IsWOWThreadCallable())
    {
        g_pOleThunkWOW = lpthk;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInitializeWOW, private
//
//  Synopsis:   Entry point to initialize the 16-bit WOW thunk layer.
//
//  Effects:    This routine is called when OLE32 is loaded by a VDM.
//              It serves two functions: It lets OLE know that it is
//              running in a VDM, and it passes in the address to a set
//              of functions that are called by the thunk layer. This
//              allows normal 32-bit processes to avoid loading the WOW
//              DLL since the thunk layer references it.
//
//  Arguments:  [vlpmalloc] -- 16:16 pointer to the 16 bit allocator.
//              [lpthk] -- Flat pointer to the OleThunkWOW virtual
//                         interface. This is NOT an OLE/IUnknown style
//                         interface.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-15-94   kevinro   Created
//
//  Notes:
//
//      Note that vlpmalloc is a 16:16 pointer, and cannot be called directly
//----------------------------------------------------------------------------
STDAPI CoInitializeWOW( LPMALLOC vlpmalloc, LPOLETHUNKWOW lpthk )
{
    //
    // At the moment, there was no need to hang onto the 16bit vlpmalloc
    // routine for this thread. That may change once we get to the threaded
    // model
    //

    vlpmalloc;

    HRESULT hr;

    OLETRACEIN((API_CoInitializeWOW, PARAMFMT("vlpmalloc= %x, lpthk= %p"), vlpmalloc, lpthk));

    // Get (or allocate) the per-thread data structure
    COleTls Tls(hr);

    if (FAILED(hr))
    {
        ComDebOut((DEB_ERROR, "CoInitializeWOW Tls OutOfMemory"));
        return CO_E_INIT_TLS;
    }
    Tls->dwFlags |= OLETLS_WOWTHREAD;

    SetOleThunkWowPtr(lpthk);

    // WOW may be calling CoInitialize on multiple threads
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    OLETRACEOUT((API_CoInitializeWOW, hr));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoUnloadingWow
//
//  Synopsis:   Entry point to notify OLE32 that OLETHK32 is unloading
//
//  Effects:    This routine is called by OLETHK32 when it is being unloaded.
//              The key trick is to make sure that we uninitialize the current
//              thread before OLETHK32 goes away, and set the global thunk
//              vtbl pointer to INVALID_HANDLE_VALUE before it does go away.
//
//              Otherwise, we run a risk that OLE32 will attempt to call
//              back to OLETHK32
//
//  Arguments:  fProcessDetach - whether this is a process detach
//
//  Requires:   IsWOWProcess must be TRUE
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-18-95   kevinro   Created
//
//  Notes:
//
//      This routine is only called by PROCESS_DETACH in OLETHK32.DLL.
//      Because of this, there shouldn't be any threading protection needed,
//      since the loader will protect us.
//
//----------------------------------------------------------------------------
STDAPI CoUnloadingWOW(BOOL fProcessDetach)
{
    //
    // First, cleanup this thread
    //
    DoThreadSpecificCleanup();

    //
    // Now, set the global WOW thunk pointer to an invalid value. This
    // will prevent it from being called in the future.
    //
    if (fProcessDetach)
    {
        g_pOleThunkWOW = (OleThunkWOW *) INVALID_HANDLE_VALUE;
    }

    return(NOERROR);

}

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterInitializeSpy
//
//  Synopsis:   Register an IInitializeSpy interface for this thread.
//
//  Arguments:  pSpy       IInitializeSpy to register
//              pdwCookie  Out parameter containing the cookie which should
//                         be used to unregister the spy later.
//
//  Returns:    HRESULT
//
//  History:    12-Dec-01 JohnDoty   Created
//
//--------------------------------------------------------------------------
STDAPI CoRegisterInitializeSpy(IInitializeSpy *pSpy, ULARGE_INTEGER *puliCookie)
{
    IInitializeSpy *pRealSpy = NULL;
    HRESULT hr = S_OK;

    if (pSpy == NULL)
        return E_INVALIDARG;
    if (puliCookie == NULL)
        return E_INVALIDARG;

    puliCookie->QuadPart = (ULONGLONG)(-1);

    COleTls Tls(hr);    
    if (FAILED(hr))
        return CO_E_INIT_TLS;

    hr = pSpy->QueryInterface(IID_IInitializeSpy, (void **)&pRealSpy);
    if (SUCCEEDED(hr))
    {        
        InitializeSpyNode *pNode = Tls->pFirstFreeSpyReg;
        if (pNode == NULL)
        {
            pNode = (InitializeSpyNode *)CoTaskMemAlloc(sizeof(InitializeSpyNode));            
            if (pNode != NULL)
            {
                // New node, new cookie.
                pNode->dwCookie = Tls->dwMaxSpy;
                Tls->dwMaxSpy++;
                if (Tls->dwMaxSpy == 0)
                {
                    Tls->dwMaxSpy--;
                    CoTaskMemFree(pNode);
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            Tls->pFirstFreeSpyReg = pNode->pNext;
            pNode->pNext = NULL;
        }

        if (SUCCEEDED(hr))
        {
            // Fill out the node (cookie already set)
            pNode->pNext    = Tls->pFirstSpyReg;
            pNode->pPrev    = NULL;
            pNode->dwRefs   = 1;
            pNode->pInitSpy = pRealSpy;

            // Link into the list
            if (Tls->pFirstSpyReg)
                Tls->pFirstSpyReg->pPrev = pNode;
            Tls->pFirstSpyReg = pNode;

            // Return the cookie
            puliCookie->LowPart  = pNode->dwCookie;
            puliCookie->HighPart = GetCurrentThreadId();
            
            hr = S_OK;
        }
        else
        {
            pRealSpy->Release();
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnlinkSpyNode
//
//  Synopsis:   Unlinks an InitializeSpyNode from the list in TLS.
//
//  Arguments:  pNode      Node to un-link.
//
//  Returns:    void
//
//  History:    12-Dec-01 JohnDoty   Created
//
//--------------------------------------------------------------------------
void UnlinkSpyNode(InitializeSpyNode *pNode)
{
    COleTls Tls;

    if (pNode->pNext) pNode->pNext->pPrev = pNode->pPrev;
    if (pNode->pPrev) pNode->pPrev->pNext = pNode->pNext;
    
    if (pNode == Tls->pFirstSpyReg)
        Tls->pFirstSpyReg = pNode->pNext;
    
    // Link the node into the free list.
    pNode->pPrev = NULL;
    pNode->pNext = Tls->pFirstFreeSpyReg;
    Tls->pFirstFreeSpyReg = pNode;    
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRevokeInitializeSpy
//
//  Synopsis:   Revoke an IInitializeSpy registration for this thread.
//
//  Arguments:  dwCookie   Cookie received from previous call to 
//                         CoRegisterInitializeSpy
//
//  Returns:    HRESULT
//
//  History:    12-Dec-01 JohnDoty   Created
//
//--------------------------------------------------------------------------
STDAPI CoRevokeInitializeSpy(ULARGE_INTEGER uliCookie)
{
    HRESULT hr;
    COleTls Tls(hr);    
    if (FAILED(hr))
        return CO_E_INIT_TLS;

    // Check the high part-- it's the thread ID.
    // If it doesn't match, then this is the wrong thread to do the revoke.
    if (GetCurrentThreadId() != uliCookie.HighPart)
        return E_INVALIDARG;

    DWORD dwCookie = uliCookie.LowPart;
    InitializeSpyNode *pNode  = Tls->pFirstSpyReg;
    while (pNode != NULL)
    {
        if (pNode->dwCookie == dwCookie)
        {
            if (pNode->pInitSpy == NULL)
                return E_INVALIDARG;  // Already been revoked

            pNode->pInitSpy->Release();
            pNode->pInitSpy = NULL;

            pNode->dwRefs--;
            if (pNode->dwRefs == 0)
            {
                // Nobody else is holding on to this.  Unlink the node.
                UnlinkSpyNode(pNode);
            }

            return S_OK;
        }

        pNode = pNode->pNext;
    }

    return E_INVALIDARG;
}

//+-------------------------------------------------------------------------
//
//  Function:   NotifyInitializeSpies
//
//  Synopsis:   Notify all registered Initialize Spies about an event.
//
//  Arguments:  fInitialize   TRUE if CoInitialize, FALSE if CoUninitialize
//              fPreNotify    TRUE if this is a Pre* notification, FALSE if
//                            this is a Post* notification.
//              dwFlags       Flags parameter for Initialize notifications.
//              hrInit        HRESULT for PostInitialize notification.
//
//  Returns:    HRESULT
//
//  History:    12-Dec-01 JohnDoty  Created
//
//--------------------------------------------------------------------------
HRESULT NotifyInitializeSpies(BOOL fInitialize, 
                              BOOL fPreNotify, 
                              DWORD dwFlags = 0,
                              HRESULT hrInit = S_OK)
{
    HRESULT hr = hrInit;
    
    COleTls Tls;
    InitializeSpyNode *pSpyNode = Tls->pFirstSpyReg;
    while (pSpyNode)
    {
        // Take a reference on this node-- this node will not be deleted until
        // we get finished sending this notification.
        pSpyNode->dwRefs++;

        // Take a reference on the spy, since the spy might unregister itself
        // during this notification.
        IInitializeSpy *pSpy = pSpyNode->pInitSpy;
        if (pSpy)
        {
            pSpy->AddRef();

            // Notify the spy appropriately.
            if (fInitialize)
            {
                if (fPreNotify)
                {
                    // hr ignored on purpose (by design)
                    pSpy->PreInitialize(dwFlags, Tls->cComInits);
                }
                else
                {
                    hr = pSpy->PostInitialize(hr, dwFlags, Tls->cComInits);
                }
            }
            else
            {
                if (fPreNotify)
                {
                    // hr ignored on purpose (by design)
                    pSpy->PreUninitialize(Tls->cComInits);
                }
                else
                {
                    // hr ignored on purpose (by design)
                    pSpy->PostUninitialize(Tls->cComInits);
                }
            }

            pSpy->Release();
        }

        // Remember what the next node is, since we might unlink the current
        // node now.
        InitializeSpyNode *pNext = pSpyNode->pNext;
        
        // Release our reference on this node, and unlink it if necessary.
        pSpyNode->dwRefs--;
        if (pSpyNode->dwRefs == 0)
        {
            // Nobody's holding onto this node anymore.  Unlink it.
            UnlinkSpyNode(pSpyNode);
        }

        pSpyNode = pNext;
    }

    return hr;
}                              

//+-------------------------------------------------------------------------
//
//  Function:   CoInitialize
//
//  Synopsis:   COM Initializer
//
//  Arguments:  [pvReserved]
//
//  Returns:    HRESULT
//
//  History:    09-Nov-94 Ricksa    Added this function comment & modified
//                                  to get rid of single threaded init flag.
//
//--------------------------------------------------------------------------
STDAPI CoInitialize(LPVOID pvReserved)
{
    HRESULT hr;

    OLETRACEIN((API_CoInitialize, PARAMFMT("pvReserved= %p"), pvReserved));

    hr = CoInitializeEx( pvReserved, COINIT_APARTMENTTHREADED);

    OLETRACEOUT((API_CoInitialize, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsRunningInSCM
//
//  Synopsis:   Figure out if we're running in the RPCSS process.  This is
//              used by CoInitialize to disallow COM in the SCM.
//
//  History:    16-Jan-01 JohnDoty  Created
//
//--------------------------------------------------------------------------
BOOL IsRunningInSCM()
{
    static BOOL s_fRunningInSCM = FALSE;
    static BOOL s_fCheckedIfInSCM = FALSE;
    
    // 
    // Okay for multiple threads to race through here, they all 
    // better get the same answer anyway.
    //
    if (s_fCheckedIfInSCM)
        return s_fRunningInSCM;

    const WCHAR  wszRPCSS[] = L"\\system32\\rpcss.dll";
    const size_t cchRPCSS   = (sizeof(wszRPCSS) / sizeof(WCHAR)); 

    // GetSystemWindowsDirectory returns enough space for the NULL.
    unsigned cchBufferSize = (GetSystemWindowsDirectory(NULL, 0) - 1) + cchRPCSS;

    WCHAR *wszFullPath = (WCHAR *)alloca(cchBufferSize * sizeof(WCHAR));
    
    if (GetSystemWindowsDirectory(wszFullPath, cchBufferSize))
    {
        lstrcat(wszFullPath, wszRPCSS);

        s_fRunningInSCM = GetModuleHandle(wszFullPath) ? TRUE : FALSE;
        s_fCheckedIfInSCM = TRUE;
    }

    return s_fRunningInSCM;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoInitializeEx
//
//  Synopsis:   COM Initializer
//
//  Arguments:  [pMalloc]
//              [flags]
//
//  Returns:    HRESULT
//
//  History:    06-Apr-94 AlexT     Added this function comment,
//                                  Cleaned up pMalloc usage
//              25-May-94 AlexT     Make success return code more closely
//                                  match 16-bit OLE
//              28-Aug-94 AndyH     pMalloc must be NULL except for Excel
//              16-Jan-01 JohnDoty  Don't allow CoInitializeEx in rpcss!
//
//  Notes:      If we're going to return successfully, we return one of the
//              following two values:
//
//              S_OK if caller passed in a NULL pMalloc and we accepted it
//              S_OK if caller passed in NULL pMalloc and this was the first
//                  successful call on this thread
//              S_FALSE if caller passed in NULL pMalloc and this was not the
//                  first successful call on this thread
//
//              This is slightly different from 16-bit OLE, because 16-bit OLE
//              didn't allow task allocations before CoInitialize was called
//              (we do), and 16-bit OLE allowed the app to change the allocator.
//
//              For chicago: SSAPI(x) expands to SSx; the x api is in
//              stkswtch.cxx which switches to the 16 bit stack first and
//              calls then SSx.
//
//--------------------------------------------------------------------------
STDAPI SSAPI(CoInitializeEx)(LPVOID pMalloc, ULONG flags)
{
    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    ComDebOut((DEB_TRACE, "CoInitializeEx pMalloc:%x flags:%x\n", pMalloc, flags));

    if ((flags &
        (COINIT_DISABLE_OLE1DDE|COINIT_APARTMENTTHREADED|COINIT_SPEED_OVER_MEMORY))
        != flags)
    {
        ComDebOut((DEB_ERROR, "CoInitializeEx(%x,%x) illegal flag", pMalloc, flags));
        return E_INVALIDARG;
    }

    if (NULL != pMalloc)
    {
        // Allocator NOT replaceable!  When called from 16-bits, the Thunk
        // layer always pases a NULL pMalloc.

        // EXCEL50 for NT supplies an allocator. We dont use it, but we
        // dont return error either, or we would break them.
        if (!IsTaskName(L"EXCEL.EXE"))
        {
            ComDebOut((DEB_ERROR, "CoInitializeEx(%x,%x) illegal pMalloc", pMalloc, flags));
            return E_INVALIDARG;
        }
    }

    // CoInitializeEx cannot be called from within rpcss.
    // This effectively stops all remoting inside the SCM.
    if (IsRunningInSCM())
    {
        ComDebOut((DEB_ERROR, "Cannot CoInitializeEx in RPCSS\n"));
        return E_UNEXPECTED;
    }

    // Get (or allocate) the per-thread data structure
    HRESULT hr;
    COleTls Tls(hr);

    if (FAILED(hr))
    {
        ComDebOut((DEB_ERROR, "CoInitializeEx Tls OutOfMemory"));
        return CO_E_INIT_TLS;
    }

    // Notify Initialize spies we are beginning initialization of this thread
    NotifyInitializeSpies(TRUE /* CoInit */, TRUE /* Pre */, flags);

    // Disallow CoInitialize from the neutral apartement.
    if (IsThreadInNTA())
    {
        ComDebOut((DEB_ERROR, "Attempt to CoInitialize from neutral apt.\n"));
        hr = RPC_E_CHANGED_MODE;
        goto ExitCoInit;
    }

    // Check for dispatch thread
    if (Tls->dwFlags & OLETLS_DISPATCHTHREAD)
    {
        // Don't allow a creation of STA on dispatch threads
        if(flags & COINIT_APARTMENTTHREADED)
        {
            ComDebOut((DEB_TRACE,"Attempt to create STA on a dispatch thread.\n" ));
            hr = RPC_E_CHANGED_MODE;
            goto ExitCoInit;
        }
        // Simply return for creation of MTA on dispatch threads
        else
        {
            ComDebOut((DEB_TRACE,"Attempt to create MTA on a dispatch thread.\n" ));
            hr = S_FALSE;
            goto ExitCoInit;
        }
    }

    // Don't allow chaning mode
    if (( (flags & COINIT_APARTMENTTHREADED) && (Tls->dwFlags & OLETLS_MULTITHREADED)) ||
        (!(flags & COINIT_APARTMENTTHREADED) && (Tls->dwFlags & OLETLS_APARTMENTTHREADED)))
    {
        ComDebOut((DEB_ERROR,"CoInitializeEx Attempt to change threadmodel\n"));

        hr = RPC_E_CHANGED_MODE;
        goto ExitCoInit;
    }

    // This flag can be set at any time.  It cannot be disabled.
    if (flags & COINIT_SPEED_OVER_MEMORY)
    {
        gSpeedOverMem = TRUE;
    }

    // increment the per-thread init count
    if (1 == ++(Tls->cComInits))
    {
        // first time for thread, might also be first time for process
        // so go check that now.

        // Prevent races initing/uniniting MTA
        if(!(flags & COINIT_APARTMENTTHREADED))
        {
            LOCK(gMTAInitLock);
            ++gcInitingMTA;
        }

        // Single thread CoInitialize/CoUninitialize to guarantee
        // that no race conditions occur where two threads are
        // simultaneously initializing and uninitializing the library.
        LOCK(g_mxsSingleThreadOle);
        hr = wCoInitializeEx(Tls, flags);
        UNLOCK(g_mxsSingleThreadOle);

        if(FAILED(hr))
            Tls->cComInits--;

        // Release MTA lock
        if(!(flags & COINIT_APARTMENTTHREADED))
        {
            --gcInitingMTA;
            UNLOCK(gMTAInitLock);
        }

        goto ExitCoInit;
    }
    else if(Tls->dwFlags & OLETLS_PENDINGUNINIT)
    {
        // Sanity check
        Win4Assert(Tls->cCalls && Tls->cComInits==2);

        // Update state
        Tls->cComInits = 1;
        Tls->dwFlags &= ~OLETLS_PENDINGUNINIT;

        hr = S_OK;
        goto ExitCoInit;
    }

    // this is the 2nd or greater successful call on this thread
    ComDebOut((DEB_TRACE, "CoInitializeEx returned S_FALSE\n"));
    hr = S_FALSE;
    goto ExitCoInit;

ExitCoInit:

    // Notify spies that we are finishing initialization of this thread.
    hr = NotifyInitializeSpies(TRUE /* CoInit */, FALSE /* Post */, flags, hr);

    if (SUCCEEDED(hr) && !(Tls->dwFlags & OLETLS_DISPATCHTHREAD))
    {
        // Log for the verifier.  Only if succeeded on non-dispatch, threads,
        // to cut down on the noise that can be generated by bad CoInits.
        // (On dispatch threads, we return S_FALSE, but do not increment the
        // init count.)
        CoVrfNotifyCoInit();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeNTA
//
//  Synopsis:   Initialization function for the NTA.
//
//  History:    20-Feb-98   Johnstra  Created
//
//+-------------------------------------------------------------------------
INTERNAL InitializeNTA()
{
    // Sanity checks
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
    Win4Assert(gpNTAApartment == NULL);

    // Enter NTA
    CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);

    // Create the NA apartment object.
    HRESULT hr = E_OUTOFMEMORY;
    gpNTAApartment = new CComApartment(APTKIND_NEUTRALTHREADED);
    if (gpNTAApartment != NULL)
    {
        // Create the NTA Empty context
        g_pNTAEmptyCtx = CObjectContext::CreateObjectContext(NULL, CONTEXTFLAGS_DEFAULTCONTEXT);
        if (g_pNTAEmptyCtx != NULL)
        {
            // Freeze the NA empty context.
            g_pNTAEmptyCtx->Freeze();

            // Indicate that the NTA has been initialized.
            hr = S_OK;
        }
        else
        {
            // Clean up the apartment object.
            gpNTAApartment->Release();
            gpNTAApartment = NULL;
        }
    }

    // Leave NTA
    LeaveNTA(pSavedCtx);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitAptCtx
//
//  Synopsis:   Worker routine for wCoInitializeEx.  Sets up a new COM threads
//              object context and apartment info in TLS, allocating new
//              objects if specified.
//
//  Arguments:  pEmptyCtx   - ref to threads empty object context ptr
//              pNativeApt  - ref to threads native apt object ptr
//              tls         - ref to threads tls structure
//              fAlloc      - specifies whether empty object context and
//                            native apt need to be allocated
//
//  History:    28-Mar-98   Johnstra  Created
//
//+-------------------------------------------------------------------------
INTERNAL InitThreadCtx(
    CObjectContext*& pEmptyCtx,
    CComApartment*&  pNativeApt,
    COleTls&         tls,
    BOOL             fAlloc,
    APTKIND          AptKind
    )
{
    HRESULT hr = S_OK;
    if (fAlloc)
    {
        hr = E_OUTOFMEMORY;

        // Create an apartment object.  Note: the apartment object
        // must be created and placed into TLS before we create the
        // object context because the context's constructor expects
        // to find an apartment object in TLS.

        // Make sure that we do not overwrite an existing apartment.
        Win4Assert((NULL == tls->pNativeApt) && (NULL == pNativeApt));

        pNativeApt = new CComApartment(AptKind);
        if (pNativeApt != NULL)
        {
            // Initialize thread's native and current apartment.
            tls->pNativeApt = pNativeApt;

            // Make sure that we do not overwrite an existing context.
            Win4Assert((NULL == tls->pNativeCtx) && (NULL == pEmptyCtx));

            // Now create an object context.
            pEmptyCtx = CObjectContext::CreateObjectContext(NULL, CONTEXTFLAGS_DEFAULTCONTEXT);
            if (pEmptyCtx != NULL)
            {
                // Freeze the new empty context.
                pEmptyCtx->Freeze();

                // Init thread's native and current object context.
                tls->pNativeCtx = pEmptyCtx;
                tls->pNativeCtx->InternalAddRef();
                tls->pCurrentCtx = tls->pNativeCtx;
                tls->ContextId = tls->pCurrentCtx->GetId();

                hr = S_OK;
            }
            else
            {
                pNativeApt->Release();
                pNativeApt = NULL;
                tls->pNativeApt = NULL;
            }
        }
    }
    else
    {
        // Init threads native and current apartment.
        tls->pNativeApt = pNativeApt;
        tls->pNativeApt->AddRef();

        // Init threads native and current object context.
        tls->pNativeCtx = pEmptyCtx;
        tls->pNativeCtx->InternalAddRef();
        tls->pCurrentCtx = tls->pNativeCtx;
        tls->ContextId = tls->pCurrentCtx->GetId();
    }

    tls->pContextStack = NULL;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CleanupLeakedDomainStack
//
//  Synopsis:   Worker routine for wCoInitializeEx.  Cleans up leaked service domain
//              contexts and notifies them of their abandonment
//
//  Arguments:  tls         - ref to threads tls structure
//              pCorrectCtx - the context we should be in
//
//  History:    14-Mar-01   mfeingol  Created
//
//+-------------------------------------------------------------------------
INTERNAL CleanupLeakedDomainStack (COleTls& Tls, CObjectContext* pCorrectCtx)
{
    HRESULT hr = S_OK;

    if (Tls->pContextStack)
    {
        CoVrfNotifyLeakedServiceDomain();

        Win4Assert (pCorrectCtx);

        // Restore correct context if necessary
        if (Tls->pCurrentCtx != pCorrectCtx)
        {
            Tls->pCurrentCtx->NotifyContextAbandonment();
            Tls->pCurrentCtx->InternalRelease();    // Balance internaladdref in EnterForCallback
            Tls->pCurrentCtx = pCorrectCtx;
            Tls->ContextId = pCorrectCtx->GetId();
        }

        // Handle leaked service domain stack
        while (Tls->pContextStack)
        {
            ContextStackNode csnCtxNode = {0};
            hr = PopServiceDomainContext (&csnCtxNode);
            if (FAILED (hr))
            {
                // Should never fail unless we're out of stack nodes
                Win4Assert (!"Out of stack nodes  - should never happen");
                return hr;
            }

            // Release ps, delete call objects
            csnCtxNode.pPS->Release();

            delete csnCtxNode.pClientCall;
            delete csnCtxNode.pServerCall;

            // Stop if we find the correct context
            if (csnCtxNode.pSavedContext == pCorrectCtx) break;

            // Tell the leaked context about its predicament
            csnCtxNode.pSavedContext->NotifyContextAbandonment();
            csnCtxNode.pSavedContext->InternalRelease();  // Balance internaladdref in EnterForCallback
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoInitializeEx
//
//  Synopsis:   worker routine for CoInitialize.
//
//  Arguments:  [tls]   - tls ptr for this thread
//              [flags] - initialization flags
//
//  History:    10-Apr-96   Rickhi  Created
//              29-Jun-98   GopalK  Modified cleanup logic
//
//  Notes:      When called by the DLLHost threads that are initializing,
//              the g_mxsSingleThreadOle mutex is being held by the requesting
//              thread, so it is still safe to muck with global state.
//
//+-------------------------------------------------------------------------
INTERNAL wCoInitializeEx(COleTls &Tls, ULONG flags)
{
    HRESULT hr = S_OK;

    if(1 == InterlockedIncrement((LONG *) &g_cProcessInits))
    {
        // first time for process, do per-process initialization
        hr = ProcessInitialize();
        if(FAILED(hr))
        {
            // ProcessInitialize failed, we must call ProcessUninitialize
            // to cleanup *before* we release the lock.
            goto ErrorReturn;
        }
    }

    if(flags & COINIT_APARTMENTTHREADED)
    {
        // apartment threaded, count 1 more STA init, mark the thread
        // as being apartment threaded, and conditionally disable
        // OLE1.

        Tls->dwFlags |= OLETLS_APARTMENTTHREADED;
        if(flags & COINIT_DISABLE_OLE1DDE)
            Tls->dwFlags |= OLETLS_DISABLE_OLE1DDE;

        // Initialize the threads context and apartment objects.
        hr = InitThreadCtx(Tls->pEmptyCtx, Tls->pNativeApt, Tls, TRUE,
                           APTKIND_APARTMENTTHREADED);
        if(FAILED(hr))
            goto ErrorReturn;

        if(1 == InterlockedIncrement((LONG *)&g_cSTAInits))
        {
            // If this is the first STA init, then the previous main
            // thread, if there was one, should have been cleaned up.
            Win4Assert(gdwMainThreadId == 0);
            
            // Register a window class for this and all future STA's
            hr = RegisterOleWndClass();
            if(FAILED(hr))
            {
                InterlockedDecrement((LONG *) &g_cSTAInits);
                goto ErrorReturn;
            }
        }

        // If we do not currently have a thread considered to be the
        // main STA, make this one be it.  This is a relaxation of 
        // the code from NT4\W2K -- in those days, we said that the
        // main STA had better be the last STA to go away, and things
        // sometimes didn't work if that rule was not honored.  Now
        // we just go with the flow.
        if (gdwMainThreadId == 0)
        {
            hr = InitMainThreadWnd();
            if (FAILED(hr))
            {
                if (0 == InterlockedDecrement((LONG *) &g_cSTAInits))
                {
                    // Don't need the window class now
                    UnRegisterOleWndClass();
                }
                goto ErrorReturn;
            }
            else if (hr == S_OK)
            {
                Win4Assert(gdwMainThreadId == GetCurrentThreadId());
                Win4Assert(ghwndOleMainThread != NULL);
            }
            // else returns S_FALSE in the WOW thread case
        }
    }
    else
    {
        // multi threaded, count 1 more MTA init, mark the thread
        // as being multi-threaded, and always disable OLE1
        Tls->dwFlags |= (OLETLS_DISABLE_OLE1DDE | OLETLS_MULTITHREADED);

        Win4Assert((g_cMTAInits != 0) ||
                   ((NULL == gpMTAApartment) && (NULL == g_pMTAEmptyCtx)));
        // Initialze the threads context and apartment objects.
        hr = InitThreadCtx(g_pMTAEmptyCtx, gpMTAApartment, Tls,
                           (g_cMTAInits == 0) ? TRUE : FALSE,
                           APTKIND_MULTITHREADED);
        if(FAILED(hr))
            goto ErrorReturn;

        InterlockedIncrement((LONG *) &g_cMTAInits);
    }

    // Initialize the neutral apartment if it has not yet been initialized.
    if(NULL == gpNTAApartment)
    {
        hr = InitializeNTA();
        if (FAILED(hr))
            goto ErrorReturn;
    }

    // this is the first successful call on this thread. make
    // sure to return S_OK and not some other random success code.
    ComDebOut((DEB_TRACE, "CoInitializeEx returned S_OK\n"));
    return S_OK;


ErrorReturn:
    // An error occurred. Fixup our tls init counter and
    // undo the TLS state change

    // cleanup our counter if the intialization failed so
    // that other threads waiting on the lock wont assume
    // that ProcessInitialize has been done.
    Tls->dwFlags = OLETLS_LOCALTID | (Tls->dwFlags & OLETLS_UUIDINITIALIZED);

    if(Tls->pNativeCtx)
    {
        Tls->pNativeCtx->InternalRelease();
        Tls->pNativeCtx = NULL;
        Tls->pCurrentCtx = NULL;
        Tls->ContextId = (ULONGLONG)-1;
    }

    if (Tls->pNativeApt)
    {
        Tls->pNativeApt->Release();
        Tls->pNativeApt = NULL;
    }

    if(flags & COINIT_APARTMENTTHREADED)
    {
        if(Tls->pEmptyCtx)
        {
            Tls->pEmptyCtx->InternalRelease();
            Tls->pEmptyCtx = NULL;
        }
    }
    else if(g_cMTAInits == 0)
    {
        if(g_pMTAEmptyCtx)
        {
            g_pMTAEmptyCtx->InternalRelease();
            g_pMTAEmptyCtx = NULL;
        }
        if(gpMTAApartment)
        {
            gpMTAApartment->Release();
            gpMTAApartment = NULL;
        }
    }

    if(0 == InterlockedDecrement((LONG *) &g_cProcessInits))
    {
        ProcessUninitialize();      
    }

    ComDebOut((DEB_ERROR,"CoInitializeEx Failed %x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   SSAPI(CoUnInitialize)
//
//  Synopsis:   COM UnInitializer, normally called from OleUninitialize
//              when the app is going away.
//
//  Effects:    Cleans up per apartment state, and if this is the last
//              apartment, cleans up global state.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    24-Jun-94 Rickhi    Added this function comment,
//                                  Cleaned up pMalloc usage
//              29-Jun-94 AlexT     Rework so that we don't own the mutex
//                                  while we might yield.
//
//  Notes:      It is critical that we not own any mutexes when we might
//              make a call that would allow a different WOW thread to run
//              (which could otherwise lead to deadlock).  Examples of such
//              calls are Object RPC, SendMessage, and Yield.
//
//--------------------------------------------------------------------------
STDAPI_(void) SSAPI(CoUninitialize)(void)
{
    COleTls Tls(TRUE);

    // Make sure not being called from DllMain
    // The one case where it's OK to call this from DllMain is if it's our DLL_THREAD_DETATCH.
    //
    // So if our TLS is NULL, it's not us.  Or if the OLETLS_INTHREADDETACH flag is not set,
    // it's not us.
    if ((Tls.IsNULL()) || !(Tls->dwFlags & OLETLS_INTHREADDETACH))
        CoVrfDllMainCheck();

    OLETRACEIN((API_CoUninitialize, NOPARAM));

    // Get the thread init count.
    if (!Tls.IsNULL())
    {
        // Notify spies that we are beginning to uninit this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, TRUE /* Pre */);

        if (Tls->cComInits > 0)
        {           
            // Sanity check
            Win4Assert(!(Tls->dwFlags & OLETLS_DISPATCHTHREAD) ||
                       !(Tls->dwFlags & OLETLS_APARTMENTTHREADED));
            
            // Disallow CoUnitialize from the neutral apartement.
            if (IsThreadInNTA())
            {
                ComDebOut((DEB_ERROR, "Attempt to uninitialize neutral apt.\n"));
            }            
            else 
            {
                if (1 == Tls->cComInits)
                {
                    // Check for outstanding calls on the thread
                    if(Tls->cCalls && !(Tls->dwFlags & OLETLS_INTHREADDETACH))
                    {
                        Tls->dwFlags |= OLETLS_PENDINGUNINIT;
                    }
                    else
                    {
                        wCoUninitialize(Tls, FALSE);
                    }
                }
                else
                {
                    // Sanity check
                    Win4Assert(!(Tls->dwFlags & OLETLS_PENDINGUNINIT));
                    Tls->cComInits--;
                }

                // Log for the verifier.
                CoVrfNotifyCoUninit();
            }
        }
        else
        {
            if (!(Tls->dwFlags & OLETLS_DISPATCHTHREAD))
            {
                // cComInits is always 0 on a dispatch thread, but if you call
                // CoInitializeEx(COINIT_MULTITHREADED) then you get back S_FALSE.
                // Thus, don't do a verifier stop when somebody does an extra
                // CoUninitialize-- they just don't know any better.
                CoVrfNotifyExtraUninit();
            }

            ComDebOut((DEB_ERROR,
                       "(0 == thread inits) Unbalanced call to CoUninitialize\n"));
        }

        // Notify spies that we are finished uninitializing this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, FALSE /* Post */);
    }

    OLETRACEOUTEX((API_CoUninitialize, NORETURN));
    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoUnInitialize
//
//  Synopsis:   worker routine for CoUninitialize, and special entry point
//              for DLLHost threads when cleaning up.
//
//  Effects:    Cleans up apartment state.
//
//  History:    10-Apr-96   Rickhi  Created
//
//  Notes:      When called with fHostThread == TRUE, the g_mxsSingleThreadOle
//              critical section is already held by the main thread that is
//              uninitializing, currently waiting in DllHostProcessUninitialize
//              for the host threads to exit. The host threads use this
//              uninitializer to avoid taking the CS and deadlocking with the
//              main thread.
//
//--------------------------------------------------------------------------
INTERNAL_(void) wCoUninitialize(COleTls &Tls, BOOL fHostThread)
{
    ComDebOut((DEB_COMPOBJ, "CoUninitialize Thread\n"));

    if (fHostThread)
    {
        // If this is a host thread, we haven't notified initialize spies yet.
        // Notify spies that we are beginning to uninit this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, TRUE /* Pre */);
    }

    if(Tls->dwFlags & OLETLS_THREADUNINITIALIZING)
    {
        // somebody called CoUninitialize while inside CoUninitialize. Since
        // we dont subtract the thread init count until after init is done.
        // we can end up here. Just warn the user about the problem and
        // return without doing any more work.
        ComDebOut((DEB_WARN, "Unbalanced Nested call to CoUninitialize\n"));
        goto exit;
    }

    // mark the thread as uninitializing
    Tls->dwFlags |= OLETLS_THREADUNINITIALIZING;

    //Release the per-thread error object.
    CoSetErrorInfo(0, NULL);

    if(Tls->dwFlags & OLETLS_APARTMENTTHREADED)
    {
        // do per-apartment cleanup
        if(!ApartmentUninitialize(fHostThread))
        {
            // uninit was aborted while waiting for pending calls to complete.
            Tls->dwFlags &= ~OLETLS_THREADUNINITIALIZING;
            ComDebOut((DEB_WARN, "CoUninitialize Aborted\n"));
            goto exit;
        }

        // Release empty context
        Tls->pEmptyCtx->InternalRelease();
        Tls->pEmptyCtx = NULL;
        Win4Assert((Tls->pNativeCtx == NULL) && (Tls->pCurrentCtx == NULL));

        // Release apartment object.
        Tls->pNativeApt->Release();
        Tls->pNativeApt = NULL;

        // Ensure that the lock is held
        ASSERT_LOCK_HELD(g_mxsSingleThreadOle);

        // Check for the main STA going away (this call is a no-op
        // if this thread is not the main STA).  We need to call this 
        // here because the main thread wnd will not always be cleaned
        // up by the time we get here.
        UninitMainThreadWnd();

        // Check for the last STA
        if(1 == g_cSTAInits)
        {
            // If so, don't need the window class anymore
            UnRegisterOleWndClass();
        }
        InterlockedDecrement((LONG *) &g_cSTAInits);
    }
    else
    {
        // MTA. Prevent races
        ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
        LOCK(g_mxsSingleThreadOle);

        while(TRUE)
        {
            // Check for the last MTA
            BOOL fUninitMTA = (g_cMTAInits == 1)
                              ? TRUE
                              : (g_cProcessInits == 2)
                                ? (!fHostThread && IsMTAHostInitialized())
                                : FALSE;
            if(fUninitMTA)
            {
                // Release the lock
                UNLOCK(g_mxsSingleThreadOle);
                ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    
                // Unint MTA apartment
                if(ApartmentUninitialize(fHostThread))
                {
                    // Release MTA empty context
                    g_pMTAEmptyCtx->InternalRelease();
                    g_pMTAEmptyCtx = NULL;
    
                    // Release MTA apartment object
                    gpMTAApartment->Release();
                    gpMTAApartment = NULL;

                    // Update tls state
                    Win4Assert((Tls->pNativeCtx == NULL) && (Tls->pCurrentCtx == NULL));
                    Tls->pNativeApt = NULL;
                    break;
                }
    
                // Ensure that the lock is held
                ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
            }
            else
            {
                gPSTable.ThreadCleanup(FALSE);
                Tls->pNativeApt->Release();
                Tls->pNativeApt = NULL;
                break;
            }
        }

        // Decrement MTA count
        InterlockedDecrement((LONG *) &g_cMTAInits);
    }

    // Ensure that the lock is held
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);

    // Check for the last apartment
    if (!fHostThread)
    {
        if (1 == g_cProcessInits)
        {
            CairoleDebugOut((DEB_COMPOBJ, "CoUninitialize Process\n"));
            Win4Assert(Tls->cComInits == 1);
            ProcessUninitialize();                                
        }
    }

    // Decrement process count
    InterlockedDecrement((LONG *) &g_cProcessInits);
    Win4Assert(!fHostThread || g_cProcessInits>0);

    // Allow future Coinits/CoUninits
    UNLOCK(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);

    // Release the per-thread "state" object (regardless of whether we
    // are Apartment or Free threaded. This must be done now since the
    // OLE Automation Dll tries to free this in DLL detach, which may
    // try to call back into the OLE32 dll which may already be detached!

    CoSetState(NULL);

    // mark the thread as finished uninitializing and turn off all flags
    // and reset the count of initializations.
    Tls->dwFlags = OLETLS_LOCALTID | (Tls->dwFlags & OLETLS_UUIDINITIALIZED);
    Tls->cComInits = 0;

exit:

    if (fHostThread)
    {
        // If this is a host thread, we haven't notified initialize spies yet.
        // Notify spies that we are finished uninitializing this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, FALSE /* Post */);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IsApartmentInitialized
//
//  Synopsis:   Check if the current apartment is initialized
//
//  Returns:    TRUE  - apartment initialized, TLS data guaranteed to exist
//                      for this thread.
//              FALSE - apartment not initialized
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
BOOL IsApartmentInitialized()
{
    HRESULT hr;
    COleTls Tls(hr);

    // initialized if any MTA apartment exists, or if the current thread has
    // been initialized, or if the current thread is in the NA.

    return (SUCCEEDED(hr) &&
            (g_cMTAInits > 0 || Tls->cComInits != 0 || IsThreadInNTA()))
           ? TRUE : FALSE;
}
//+---------------------------------------------------------------------
//
//  Function:   CoGetCurrentProcess
//
//  Synopsis:   Returns a unique value for the current thread. This routine is
//              necessary because hTask values from Windows get reused
//              periodically.
//
//  Arguments:  -
//
//  Returns:    DWORD
//
//  History:    28-Jul-94   BruceMa    Created.
//
//  Notes:
//
//----------------------------------------------------------------------
STDAPI_(DWORD) CoGetCurrentProcess(void)
{
    HRESULT hr;

    OLETRACEIN((API_CoGetCurrentProcess, NOPARAM));

    COleTls Tls(hr);

    if ( FAILED(hr) )
    {
        OLETRACEOUTEX((API_CoGetCurrentProcess, RETURNFMT("%ud"), 0));
        return 0;
    }

    // Get our OLE-specific thread id
    if ( Tls->dwApartmentID == 0 )
    {
        // This sets our dwApartmentID.
        ScmGetThreadId( &Tls->dwApartmentID );
        // On Win95 Tls->dwApartmentID can be 0 if the resolver fails initialization
        if ( Tls->dwApartmentID == 0 )
        {
            Tls->dwApartmentID = GetTickCount();
        }
    }

    Win4Assert(Tls->dwApartmentID);
    OLETRACEOUTEX((API_CoGetCurrentProcess, RETURNFMT("%ud"), Tls->dwApartmentID));

    return Tls->dwApartmentID;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoBuildVersion
//
//  Synopsis:   Return build version DWORD
//
//  Returns:    DWORD hiword = 23
//              DWORD loword = build number
//
//  History:    16-Feb-94 AlexT     Use verole.h rmm for loword
//
//  Notes:      The high word must always be constant for a given platform.
//              For Win16 it must be exactly 23 (because that's what 16-bit
//              OLE 2.01 shipped with).  We can choose a different high word
//              for other platforms.  The low word must be greater than 639
//              (also because that's what 16-bit OLE 2.01 shipped with).
//
//--------------------------------------------------------------------------
STDAPI_(DWORD)  CoBuildVersion( VOID )
{
    WORD wLowWord;
    WORD wHighWord;

    OLETRACEIN((API_CoBuildVersion, NOPARAM));

    wHighWord = 23;
    wLowWord  = rmm;    //  from ih\verole.h

    Win4Assert(wHighWord == 23 && "CoBuildVersion high word magic number");
    Win4Assert(wLowWord > 639 && "CoBuildVersion low word not large enough");

    DWORD dwVersion;

    dwVersion = MAKELONG(wLowWord, wHighWord);

    OLETRACEOUTEX((API_CoBuildVersion, RETURNFMT("%x"), dwVersion));

    return dwVersion;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoSetState
//              CoGetState
//
//  Synopsis:   These are private APIs, exported for use by the
//              OLE Automation DLLs, which allow them to get and
//              set a single per thread "state" object that is
//              released at CoUninitialize time.
//
//  Arguments:  [punk/ppunk] the object to set/get
//
//  History:    15-Jun-94 Bradlo    Created
//
//--------------------------------------------------------------------------
STDAPI CoSetState(IUnknown *punkStateNew)
{
    OLETRACEIN((API_CoSetState, PARAMFMT("punk= %p"), punkStateNew));

    HRESULT hr;
    COleTls Tls(hr);

    if (SUCCEEDED(hr))
    {
        IUnknown *punkStateOld;

        //  Note that either the AddRef or the Release below could (in
        //  theory) cause a reentrant call to us.  By keeping
        //  punkStateOld in a stack variable, we handle this case.

        if (NULL != punkStateNew)
        {
            //  We're going to replace the existing state with punkStateNew;
            //  take a reference right away

            //  Note thate even if this AddRef reenters TLSSetState we're
            //  okay because we haven't touched pData->punkState yet.
            punkStateNew->AddRef();

            // Single thread CoSetState/CoGetState
            COleStaticLock lck(g_mxsCoSetState);
            if (++g_cCoSetState == 1)
            {
                // The first time CoSetState is called by OA.
                // We do a load lib here so OA won't go away while we hold
                // the per state pointer.
                //
                Win4Assert(g_hOleAut32 == NULL);
                g_hOleAut32 = LoadLibraryA("oleaut32.dll");
#if DBG==1
                if (g_hOleAut32 == NULL)
                {
                    CairoleDebugOut((DEB_DLL,
                        "CoSetState: LoadLibrary oleaut32.dll failed\n"));
                }
#endif
            }
        }

        punkStateOld = Tls->punkState;
        Tls->punkState = punkStateNew;

        if (NULL != punkStateOld)
        {
            //  Once again, even if this Release reenters TLSSetState we're
            //  okay because we're not going to touch pData->punkState again
            punkStateOld->Release();

            HINSTANCE hOleAut32 = NULL;     //

            {
                // Single thread CoSetState/CoGetState
                COleStaticLock lck(g_mxsCoSetState);
                if (--g_cCoSetState == 0)
                {
                    // Release the last ref to OA per thread state.
                    // We do a free lib here so OA may go away if it wants to.
                    //
                    Win4Assert(g_hOleAut32 != NULL);
                    hOleAut32 = g_hOleAut32;
                    g_hOleAut32 = NULL;
                }
                // release the lock implicitly
            }                               // in case dll detatch calls back
            if (hOleAut32)
                FreeLibrary(hOleAut32);
        }

        OLETRACEOUT((API_CoSetState, S_OK));
        return S_OK;
    }

    OLETRACEOUT((API_CoSetState, S_FALSE));
    return S_FALSE;
}

STDAPI CoGetState(IUnknown **ppunk)
{
    OLETRACEIN((API_CoGetState, PARAMFMT("ppunk= %p"), ppunk));

    HRESULT hr;
    COleTls Tls(hr);
    IUnknown *punk;

    if (SUCCEEDED(hr))
    {
        punk = Tls->punkState;
        if (punk)
        {
            punk->AddRef();
            *ppunk = punk;
            
            OLETRACEOUT((API_CoGetState, S_OK));
            return S_OK;
        }
    }

    *ppunk = NULL;

    OLETRACEOUT((API_CoGetState, S_FALSE));
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoQueryReleaseObject, private
//
//  Synopsis:   Determine if this object is one that should be released during
//              shutdown.
//
//  Effects:    Turns out that some WOW applications don't cleanup properly.
//              Specifically, sometimes they don't release objects that they
//              really should have. Among the problems caused by this are that
//              some objects don't get properly cleaned up. Storages, for
//              example, don't get closed. This leaves the files open.
//              Monikers are being released, which eat memory.
//
//              This function is called by the thunk manager to determine
//              if an object pointer is one that is known to be leaked, and
//              if the object should be released anyway. There are several
//              classes of object that are safe to release, and some that
//              really must be released.
//
//  Arguments:  [punk] -- Unknown pointer to check
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-15-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG_PTR adwQueryInterfaceTable[QI_TABLE_END] = { 0 , 0 };
STDAPI CoQueryReleaseObject(IUnknown *punk)
{
    OLETRACEIN((API_CoQueryReleaseObject, PARAMFMT("punk= %p"), punk));
    CairoleDebugOut((DEB_ITRACE,
                     "CoQueryReleaseObject(%x)\n",
                     punk));
    //
    // A punk is a pointer to a pointer to a vtbl. We are going to check the
    // vtbl to see if we can release it.
    //

    ULONG_PTR pQueryInterface;
    HRESULT hr;

    if (!IsValidReadPtrIn(punk,sizeof(DWORD)))
    {
        hr = S_FALSE;
        goto ErrorReturn;
    }

    if (!IsValidReadPtrIn(*(DWORD**)punk,sizeof(DWORD)))
    {
        hr = S_FALSE;
        goto ErrorReturn;
    }

    // Pick up the QI function pointer
    pQueryInterface = **(ULONG_PTR **)(punk);

    CairoleDebugOut((DEB_ITRACE,
                     "CoQueryReleaseObject pQueryInterface = %x\n",
                     pQueryInterface));

    //
    // adwQueryInterfaceTable is an array of known QueryInterface pointers.
    // Either the value in the table is zero, or it is the address of the
    // classes QueryInterface method. As each object of interest is created,
    // it will fill in its reserved entry in the array. Check olepfn.hxx for
    // details
    //

    if( pQueryInterface != 0)
    {
        for (int i = 0 ; i < QI_TABLE_END ; i++)
        {
            if (adwQueryInterfaceTable[i] == pQueryInterface)
            {
                CairoleDebugOut((DEB_ITRACE,
                                 "CoQueryReleaseObject punk matched %x\n",i));
                hr = NOERROR;
                goto ErrorReturn;
            }
        }
    }
    CairoleDebugOut((DEB_ITRACE,
                     "CoQueryReleaseObject No match on punk\n"));
    hr = S_FALSE;

ErrorReturn:
    OLETRACEOUT((API_CoQueryReleaseObject, hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\hkole32.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hkole.cpp

Abstract:

    This file contains all functions used for hookole support.
        InitHookOle         (called from ProcessAttach routine)
        UninitHookOle       (called from ProcessDetach routine)
        EnableHookObject    (exported function)
        GetHookInterface    (exported function)
        HkOleRegisterObject (exported function)

    This code was originally added to compobj.cxx in the form of macros that
    existed in hkole32.h

Author:

    Dan Lafferty (danl) 04-Jun-1996

Environment:

    User Mode - Win32

Revision History:

    04-Jun-1996 danl
    Created

--*/
//
// INCLUDES
//
#include <ole2int.h>
#include <windows.h>
#include <hkole32.h>
#include <reghelp.hxx>

//#include <tchar.h>


//
// Registry Key Strings
//
#define szCLSIDKey      "CLSID"
#define HookBase        HKEY_LOCAL_MACHINE
#define szHookKey       "Software\\Microsoft\\HookOleObject"
#define KEY_SEP         "\\"

//
// Event Name used for Global Hook Switch.
//
#define szHookEventName    "HookSwitchHookEnabledEvent"

//
// Length of CLSID string including NUL terminator.
//
#define MAX_CLSID  39

//
//  IHookOleObject used to satisfy usage in GetHookInterface
//  (This is copied from the oletools\hookole\inc\hookole.h file).
//    NOTE:  This is just a dummy used to pass the pointer through.
//
interface IHookOleObject : IUnknown{};

//
// Function Types.
//
typedef HRESULT (STDAPICALLTYPE * LPFNINITHOOKOLE)(VOID);
typedef HRESULT (STDAPICALLTYPE * LPFNUNINITHOOKOLE)(VOID);

typedef HRESULT (STDAPICALLTYPE * LPFNENABLEHOOKOBJECT)(
            BOOL    bEnabled,
            PBOOL    pbPrevious);

typedef HRESULT (STDAPICALLTYPE * LPFNGETHOOKINTERFACE)(
            IHookOleObject **ppNewHook);

typedef HRESULT (STDAPICALLTYPE * LPFNHKOLEREGISTEROBJECT)(
            REFCLSID    rclsid,
            REFIID      riid,
            LPVOID      pvObj,
            BOOL    fNewInstance);

//
// GLOBALS
//
    HINSTANCE               glhHookDll = NULL;

    LPFNINITHOOKOLE         pfnInitHookOle         =NULL;
    LPFNUNINITHOOKOLE       pfnUninitHookOle       =NULL;
    LPFNENABLEHOOKOBJECT    pfnEnableHookObject    =NULL;
    LPFNGETHOOKINTERFACE    pfnGetHookInterface    =NULL;
    LPFNHKOLEREGISTEROBJECT pfnHkOleRegisterObject = NULL;

//
// Local Function Prototypes and Inline Functions
//
VOID
HkFindAndLoadDll(
    VOID
    );

HINSTANCE
HkLoadInProcServer(
    REFCLSID rclsid
    );

inline HRESULT CLSIDFromStringA(LPSTR lpsz, LPCLSID lpclsid)
{
    LPWSTR lpwsz = new WCHAR[strlen(lpsz)+1];

    if (NULL == lpwsz)
        return E_OUTOFMEMORY;

    MultiByteToWideChar (
        CP_ACP,
        MB_PRECOMPOSED,
        lpsz,
        -1,
        lpwsz,
        lstrlenA(lpsz)+1);

    HRESULT hr = CLSIDFromString(lpwsz, lpclsid);
    delete lpwsz;
    return hr;
}

VOID
InitHookOle(
    VOID
    )

/*++

Routine Description:

    This routine is called from the OLE32 PROCESS_ATTACH routine.
    It checks the state of the global hook switch.  If in the ON state,
    the HookOle DLL is loaded and the global procedure addresses are
    obtained.  If the HookOle pfcnInitHookOle pointer was obtained,
    then that function is called so that HookOle.DLL is properly initialized.

Arguments:

    none.

Return Value:
    none.  Success or failure is determined by the state of the globals.

--*/
{
    HANDLE  hHookEvent  = NULL;
    HKEY    hRegKey     = NULL;
    DWORD   status;

    LPFNGETCLASSOBJECT pfnGCO;

    //
    // See if the hook switch exists.  If not, hooking can't be on.
    //
    hHookEvent  = OpenEventA(EVENT_ALL_ACCESS,FALSE, szHookEventName);
    if (hHookEvent == NULL) {
        //
        // Hooking is OFF.
        //
        return;
    }

    //
    // See if the hook switch is on.
    //
    status = WaitForSingleObject(hHookEvent,0);
    if (status != WAIT_OBJECT_0) {
        //
        // The event is not-signaled.  Hooking is OFF.
        //
        goto CleanExit;
    }

    //
    // Hooking is ON.  Now find the hookole dll name and load it.
    //
    HkFindAndLoadDll();

    //
    // Call the InitHookOle function in HookOle.DLL
    // NOTE:  This InitHookOle has a return value.
    //
    if (pfnInitHookOle != NULL) {
        if (pfnInitHookOle() != S_OK) {

            //
            // If HookOLE failed and is unusable, then release the DLL.
            // and function pointers
            //
            UninitHookOle();
        }
    }

CleanExit:
    if (hHookEvent != NULL) {
        CloseHandle(hHookEvent);
        hHookEvent = NULL;
    }
}

VOID
UninitHookOle(
    VOID
    )

/*++

Routine Description:

    This routine is called from the OLE32 PROCESS_DETACH routine.
    It unloads the HookOLE DLL and sets the global pointers to a safe (NULL)
    state.

Arguments:
    none.

Return Value:
    none.

--*/
{
    //
    // Tell HookOLE DLL to uninitialize.
    //
    if (pfnUninitHookOle != NULL) {
        pfnUninitHookOle();
    }

    //
    // Remove all the procedure function pointers
    //
    pfnInitHookOle          =NULL;
    pfnUninitHookOle        =NULL;
    pfnEnableHookObject     =NULL;
    pfnGetHookInterface     =NULL;
    pfnHkOleRegisterObject  =NULL;

    //
    // Free the DLL
    //
    if (glhHookDll != NULL) {
        FreeLibrary(glhHookDll);
    }

    return;
}

STDAPI_(HRESULT)
EnableHookObject(
    IN  BOOL    bEnabled,
    OUT BOOL*   pbPrevious
    )

/*++

Routine Description:

    This function is used by components to turn off hooking for the
    current process.  This is required by components such as OleLogger
    where not doing so would cause new log entries to be generated
    whenever a log entry was being removed from the HookOleLog circular
    queue.

Arguments:

    bEnabled - TRUE if hooking is to be enabled.  FALSE if it is to be
    disabled.

    pbPrevious - TRUE if hooking was previously enabled.  FALSE if hooking
    was previously disabled.

Return Value:
    S_OK - if the operation was successful.
    otherwise an appropriate error is returned.

--*/
{
    //
    // If the caller wants to enable hookole, but the hookole dll isn't
    // loaded, then load the dll.
    //
    if ((bEnabled == TRUE) && (glhHookDll == NULL)) {
        HkFindAndLoadDll();
    }

    //
    // Call the EnableHookObject function in HookOle.DLL
    //
    if (pfnEnableHookObject != NULL) {
        return(pfnEnableHookObject(bEnabled,pbPrevious));
    }
    else {
        return(E_UNEXPECTED);
    }
}

STDAPI_(HRESULT)
GetHookInterface(
    OUT IHookOleObject** ppNewHook
    )

/*++

Routine Description:

    This function is used by components to obtain the pointer to the
    IHookOle interface created to hook interfaces in this process.
    The interface pointer is AddRef'd by GetHookInterface so the
    caller is required to Release the pointer when finished with it.

    This is currently called from the QueryContainedInterface calls in
    CIHookOleClass and CIHookOleInstance.  It is also called during
    wrapper DLL process attach.


Arguments:

    ppNewHook - Location where the pointer to the IHookOle interface is
    to be returned.

Return Value:

    S_OK - if the operation was successful.
    E_NOINTERFACE - The interface pointer doesn't exist.
    E_INVALIDARG - ppNewHook is an invalid pointer.

--*/
{
    if (pfnGetHookInterface != NULL) {
        return(pfnGetHookInterface(ppNewHook));
    }
    return(E_NOINTERFACE);
}

STDAPI_(HRESULT)
HkOleRegisterObject(
    IN  REFCLSID    rclsid,
    IN  REFIID      riid,
    IN  LPVOID      pvObj,
    IN  BOOL    fNewInstance
    )

/*++

Routine Description:

    This routine can be called from application programs that desire to
    register a newly created object with hookole.

Arguments:

    rclsid - pointer to the clsid for the object being registered.

    riid - pointer to the iid for the object being registered.

    pvObj - pointer to the object that is being registered.

Return Value:

    S_OK - if the operation was successful.
    E_NOINTERFACE - HookOle isn't loaded.

--*/
{
    if (pfnHkOleRegisterObject != NULL) {
        return(pfnHkOleRegisterObject(rclsid,riid,pvObj,fNewInstance));
    }
    return(E_NOINTERFACE);
}

VOID
HkFindAndLoadDll(
    VOID
    )

/*++

Routine Description:

    Obtains the DLL path name from the registry and loads the dll and obtains
    all the relevant procedure addresses.

Arguments:

    none

Return Value:

    none - success is determined by examining the global handle to the dll
        and the procedure function pointers.  If they were successfully
        obtained, they will be non-NULL.

--*/
{
    DWORD    status;
    CLSID   HookClsid;
    CHAR    szClsidText[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize;
    HKEY    hRegKey;

    //
    // Open key to "\\Software\\Microsoft\\HookOleObject"
    //
    status = RegOpenKeyExA (HookBase, szHookKey, 0, KEY_READ, &hRegKey);
    if (status != ERROR_SUCCESS) {
        goto CleanExit;
    }

    //
    // Read the CLSID string from the registry
    //
    dwSize = sizeof(szClsidText);
    status = RegQueryValueExA(
                    hRegKey,
                    szCLSIDKey,
                    NULL,
                    &dwType,
                    (LPBYTE)&szClsidText,
                    &dwSize);

    if (status != ERROR_SUCCESS) {
        //
        // Failed to obtain the CLSID for HookOleObject
        //
        goto CleanExit;
    }

    //
    // Make CLSID out of the text string.
    //
    if (!SUCCEEDED(CLSIDFromStringA(szClsidText,&HookClsid))) {
        //
        // could not find clsid for HookOleObject in registry
        //
        goto CleanExit;
    }

    //
    // Load the HookOle Dll identifed by the CLSID.
    // Store the handle in a global location.
    //
    glhHookDll = HkLoadInProcServer(HookClsid);
    if (!glhHookDll) {
        //
        // dll would not load or could not be found
        //
        goto CleanExit;
    }

    //
    // Get the entry point for DllGetClassObject.
    //
    pfnInitHookOle        = (LPFNINITHOOKOLE)
                            GetProcAddress(glhHookDll,"InitHookOle");

    pfnUninitHookOle      = (LPFNUNINITHOOKOLE)
                            GetProcAddress(glhHookDll,"UninitHookOle");

    pfnEnableHookObject   = (LPFNENABLEHOOKOBJECT)
                            GetProcAddress(glhHookDll,"EnableHookObject");

    pfnGetHookInterface   = (LPFNGETHOOKINTERFACE)
                            GetProcAddress(glhHookDll,"GetHookInterface");

    pfnHkOleRegisterObject= (LPFNHKOLEREGISTEROBJECT)
                            GetProcAddress(glhHookDll,"HkOleRegisterObject");

CleanExit:
    if (hRegKey != NULL) {
        RegCloseKey(hRegKey);
        hRegKey = NULL;
    }
}

HINSTANCE
HkLoadInProcServer(
    REFCLSID rclsid
    )
/*++

Routine Description:

    This routine loads the DLL for the InProc server identified by the
    rclsid.

Arguments:

    rclsid - CLSID for the inproc server dll that is to be loaded.

Return Value:

    hDLL - the handle for the DLL is returned.  If this function failed,
        a NULL is returned.

--*/
{
    CHAR        szInProc32[] = "InprocServer32";
    CHAR        szClsidKey[MAX_PATH];
    CHAR        szDllName[MAX_PATH];
    WCHAR       szClsidW[MAX_CLSID];
    CHAR        szClsid[MAX_CLSID];
    LONG        lSize = sizeof(szDllName);
    DWORD       status;
    HRESULT     hr;
    HINSTANCE   hDll = NULL;

    hr = StringFromGUID2(rclsid, szClsidW, MAX_CLSID);
    if (SUCCEEDED(hr)) {

        WideCharToMultiByte (
            CP_ACP,
            WC_COMPOSITECHECK,
            szClsidW,
            -1,
            szClsid,
            sizeof(szClsid),
            NULL,
            NULL);

        //
        // "CLSID\\classid-string\\InprocServer32"
        //
        strcpy(szClsidKey, szCLSIDKey);
        strcat(szClsidKey, KEY_SEP);
        strcat(szClsidKey,szClsid);
        strcat(szClsidKey,KEY_SEP);
        strcat(szClsidKey,szInProc32);

        status = QueryClassesRootValueA(
                    szClsidKey,
                    szDllName,
                    &lSize);

        if (status == ERROR_SUCCESS) {
            hDll = LoadLibraryA(szDllName);
        }
    }
    return(hDll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\compapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       compapi.cxx
//
//  Contents:   API for the compobj dll
//
//  Classes:
//
//  Functions:
//
//  History:    31-Dec-93   ErikGav     Chicago port
//              28-Mar-94   BruceMa     CLSID_NULL undoes TreatAs emulation
//              20-Apr-94   Rickhi      CClassExtMap, commenting, cleanup
//              03-May-94   BruceMa     Corrected IsOle1Class w/ OLE 2.01
//              04-May-94   BruceMa     Conformed CoTreatAsClass to 16-bit OLE
//              12-Dec-94   BruceMa     Support CoGetClassPattern on Chicago
//              03-Jan-95   BruceMa     Support Chicago style pattern matching
//                                       on NT if CoInitialize has not been
//                                       called
//              28-Aug-95   MurthyS     StringFromGUID2 and StringFromGUID2A
//                                       no longer use sprintf or wsprintf
//              07-Sep-95   MurthyS     Only do validation in API rtns with
//                                       work done by worker routines.  Commonly
//                                       used (internally) worker routines moved
//                                       to common\ccompapi.cxx
//              04-Feb-96   BruceMa      Add per-user registry support
//              12-Nov-98   SteveSw     CLSIDFromProgID, CLSIDFromProgIDEx, and
//                                       ProgIDFromClSID implemented on top of
//                                       Catalog
//                                      CoGetClassVersion implemented
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "ole1guid.h"
#include "pattbl.hxx"           // CProcessPatternTable
#include "pexttbl.hxx"          // CProcessExtensionTable
#include "objact.hxx"           // CheckDownloadRegistrySettings
#include <appmgmt.h>
#include <reghelp.hxx>

// forward references

INTERNAL wCoMarshalHresult(IStream FAR* pstm, HRESULT hresult);
INTERNAL wCoUnmarshalHresult(IStream FAR* pstm, HRESULT FAR * phresult);

//+-------------------------------------------------------------------------
//
//  Function:   wCoMarshalHresult    (internal)
//
//  Synopsis:   writes an hresult into the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
inline INTERNAL wCoMarshalHresult(IStream FAR* pstm, HRESULT hresult)
{
	return pstm->Write(&hresult,sizeof(hresult),NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoUnMarshalHresult    (internal)
//
//  Synopsis:   reads an hresult from the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
inline INTERNAL wCoUnmarshalHresult(IStream FAR* pstm, HRESULT FAR * phresult)
{
	SCODE sc;

	HRESULT hresult = pstm->Read(&sc,sizeof(sc),NULL);
	CairoleAssert((hresult == NOERROR)
				  && "CoUnmarshalHresult: Stream read error");
	if (hresult == NOERROR)
	{
		*phresult = sc;
	}

	return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoGetCallerTID (internal)
//
//  Synopsis:   gets the TID of the ORPC client that called us.
//
//  Arguments:  [pTIDCaller] - where to put the result.
//
//--------------------------------------------------------------------------
inline HRESULT wCoGetCallerTID(DWORD *pTIDCaller)
{
	HRESULT hr;
	COleTls tls(hr);

	if (SUCCEEDED(hr))
	{
		*pTIDCaller = tls->dwTIDCaller;
		return(tls->dwFlags & OLETLS_LOCALTID) ? S_OK : S_FALSE;
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoGetCurrentLogicalThreadId (internal)
//
//  Synopsis:   Gets the current logical thread id that this physical
//              thread is operating under. The current physical thread
//              takes on the logical tid of any client application that
//              makes an Rpc call into this app.  The function is exported
//              so that the tools infrastructure (conformance suite, logger,
//              etc) can use it.
//
//  Arguments:  [pguid] - where to return the logical thread id
//
//  Returns:    [S_OK]  - got the logical thread id
//              [E_OUTOFMEMORY] - cant allocate resources
//
//--------------------------------------------------------------------------
inline INTERNAL wCoGetCurrentLogicalThreadId(GUID *pguid)
{
	GUID *pguidTmp = TLSGetLogicalThread();
	if (pguidTmp != NULL)
	{
		*pguid = *pguidTmp;
		return S_OK;
	}

	return E_OUTOFMEMORY;
}

NAME_SEG(CompApi)
ASSERTDATA


CProcessPatternTbl      *g_pPatTbl = NULL;
CProcessExtensionTbl    *g_pExtTbl = NULL;

//
//  string constants used throughout this file
//

WCHAR wszInterfaceKey[]   = L"Interface\\";
ULONG ulInterfaceKeyLen   = ((sizeof(wszInterfaceKey)/sizeof(WCHAR))-1);

WCHAR wszClasses[]  = L"Software\\Classes\\";

WCHAR wszTreatAs[]        = L"TreatAs";
WCHAR wszAutoTreatAs[]    = L"AutoTreatAs";

WCHAR wszProxyStubClsid[] = L"\\ProxyStubClsid32";
WCHAR wszProxyStubClsid16[] = L"\\ProxyStubClsid";

extern WCHAR wszOle1Class[];	// defined in common\ccompapi.cxx

// Constant for inprocess marshaling - this s/b big enough to cover most
// cases since reallocations just waste time.
#define EST_INPROC_MARSHAL_SIZE 256

//+-------------------------------------------------------------------------
//
//  Function:   CoMarshalHresult    (public)
//
//  Synopsis:   writes an hresult into the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
STDAPI CoMarshalHresult(IStream FAR* pstm, HRESULT hresult)
{
	OLETRACEIN((API_CoMarshalHresult, PARAMFMT("pstm= %p, hresult= %x"), pstm, hresult));
	CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pstm);

	HRESULT hr;

	if (IsValidInterface(pstm))
	{
		hr = wCoMarshalHresult(pstm, hresult);

	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoMarshalHresult, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoUnMarshalHresult    (public)
//
//  Synopsis:   reads an hresult from the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
STDAPI CoUnmarshalHresult(IStream FAR* pstm, HRESULT FAR * phresult)
{
	HRESULT hr;
	OLETRACEIN((API_CoUnmarshalHresult, PARAMFMT("pstm= %p, phresult= %p"), pstm, phresult));
	CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pstm);

	if (IsValidInterface(pstm) &&
		IsValidPtrOut(phresult, sizeof(*phresult)))
	{
		hr = wCoUnmarshalHresult(pstm, phresult);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoUnmarshalHresult, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoGetCallerTID  (exported, but not in header files)
//
//  Synopsis:   gets the TID of the current calling application
//
//  Arguments:  [pTIDCaller] - where to return the caller TID
//
//  Returns:    [S_TRUE] - caller TID set, caller in SAME process
//              [S_FALSE] = caller TID set, caller in different process
//              [E_OUTOFMEMORY] - caller TID not set
//
//--------------------------------------------------------------------------
STDAPI CoGetCallerTID(DWORD *pTIDCaller)
{
	OLETRACEIN((API_CoGetCallerTID, PARAMFMT("pTIDCaller= %p"), pTIDCaller));
	HRESULT hr;

	if (IsValidPtrOut(pTIDCaller, sizeof(*pTIDCaller)))
	{
		hr = wCoGetCallerTID(pTIDCaller);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoGetCallerTID, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoGetCurrentLogicalThreadId (exported, but not in header files)
//
//  Synopsis:   Gets the current logical thread id that this physical
//              thread is operating under. The current physical thread
//              takes on the logical tid of any client application that
//              makes an Rpc call into this app.  The function is exported
//              so that the tools infrastructure (conformance suite, logger,
//              etc) can use it.
//
//  Arguments:  [pguid] - where to return the logica thread id
//
//  Returns:    [S_OK]  - got the logical thread id
//              [E_OUTOFMEMORY] - cant allocate resources
//
//--------------------------------------------------------------------------
STDAPI CoGetCurrentLogicalThreadId(GUID *pguid)
{
	OLETRACEIN((API_CoGetCurrentLogicalThreadId, PARAMFMT("pguid= %p"), pguid));
	HRESULT hr;

	if (IsValidPtrOut(pguid, sizeof(*pguid)))
	{
		hr = wCoGetCurrentLogicalThreadId(pguid);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoGetCurrentLogicalThreadId, hr));
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   StringFromGUID2     (public)
//
//  Synopsis:   converts GUID into {...} form without leading identifier;
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------
STDAPI_(int)  StringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax)
{
	OLETRACECMNIN((API_StringFromGUID2, PARAMFMT("rguid= %I, lpsz= %p, cbMax= %d"),
				   &rguid, lpsz, cbMax));
	int iRet = 0;
	if ((&rguid != NULL) &&
		IsValidPtrIn(&rguid, sizeof(rguid)) &&
		IsValidPtrOut(lpsz, cbMax))
	{
		if (cbMax >= GUIDSTR_MAX)
		{
			iRet = wStringFromGUID2(rguid, lpsz, cbMax);
		}
	}


	OLETRACECMNOUTEX((API_StringFromGUID2, RETURNFMT("%d"), iRet));
	return iRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   GUIDFromString    (private)
//
//  Synopsis:   parse above format;  always writes over *pguid.
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) GUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{

	if ((lpsz != NULL) &&
		IsValidPtrIn(lpsz, GUIDSTR_MAX) &&
		IsValidPtrOut(pguid, sizeof(*pguid)))
	{
		if (lstrlenW(lpsz) < (GUIDSTR_MAX - 1))
			return(FALSE);

		return(wGUIDFromString(lpsz, pguid));
	}
	return(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   StringFromCLSID (public)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDAPI  StringFromCLSID(REFCLSID rclsid, LPWSTR FAR* lplpsz)
{
	OLETRACEIN((API_StringFromCLSID, PARAMFMT("rclsid= %I, lplpsz= %p"), &rclsid, lplpsz));
	HRESULT hr;

	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(lplpsz, sizeof(*lplpsz)))
	{
		hr = wStringFromCLSID(rclsid, lplpsz);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_StringFromCLSID, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromString (public)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
STDAPI CLSIDFromString(LPWSTR lpsz, LPCLSID lpclsid)
{
	HRESULT hr;

	OLETRACEIN((API_CLSIDFromString, PARAMFMT("lpsz= %ws, lpclsid= %p"),
				lpsz, lpclsid));

//  Note:  Should be doing IsValidPtrIn(lpsz, CLSIDSTR_MAX) but can't because
//  what comes in might be a ProgId.

	if (IsValidPtrIn(lpsz, 1) &&
		IsValidPtrOut(lpclsid, sizeof(*lpclsid)))
	{
		hr = wCLSIDFromString(lpsz, lpclsid);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CLSIDFromString, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromOle1Class      (public)
//
//  Synopsis:   translate Ole1Class into clsid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              CO_E_CLASSSTRING    (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CLSIDFromOle1Class(LPCWSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign)
{
	if ((lpsz != NULL) &&
		IsValidPtrIn(lpsz,1) &&
		IsValidPtrOut(lpclsid, sizeof(*lpclsid)))
	{
		if (lpsz[0] == 0)
		{
			// NOTE - This check wasn't in shipped versions of this
			// code.  In prior versions the empty string would be passed
			// down into the guts of the 1.0 CLSID support and would
			// fail there with CO_E_CLASSSTRING.  That code path depended
			// on an assert being broken to function properly.  With that
			// assert fixed, this new check is required.

			*lpclsid = CLSID_NULL;
			return CO_E_CLASSSTRING;
		}


		return(wCLSIDFromOle1Class(lpsz, lpclsid, fForceAssign));
	}
	return(E_INVALIDARG);

}

//+---------------------------------------------------------------------------
//
//  Function:   Ole1ClassFromCLSID2
//
//  Synopsis:   translate CLSID into Ole1Class
//              REVIEW: might want to have CLSIDFromOle1Class instead of having
//              CLSIDFromString do the work.
//
//  Arguments:  [rclsid] --
//              [lpsz] --
//              [cbMax] --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(int) Ole1ClassFromCLSID2(REFCLSID rclsid, LPWSTR lpsz, int cbMax)
{
	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(lpsz, cbMax))
	{
		return(wOle1ClassFromCLSID2(rclsid, lpsz, cbMax));
	}
	return(E_INVALIDARG);
}

//+-------------------------------------------------------------------------
//
//  Function:   StringFromIID   (public)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDAPI StringFromIID(REFIID rclsid, LPWSTR FAR* lplpsz)
{
	OLETRACEIN((API_StringFromIID, PARAMFMT("rclsid= %I, lplpsz= %p"), &rclsid, lplpsz));
	HRESULT hr = NOERROR;

	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(lplpsz, sizeof(*lplpsz)))
	{
		hr = wStringFromIID(rclsid, lplpsz);
	}
	else
	{
		hr = E_INVALIDARG;

	}

	OLETRACEOUT((API_StringFromIID, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IIDFromString   (public)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz]  - ptr to buffer for results
//              [lpiid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
STDAPI IIDFromString(LPWSTR lpsz, LPIID lpiid)
{
	OLETRACEIN((API_IIDFromString, PARAMFMT("lpsz= %ws, lpiid= %p"), lpsz, lpiid));

	HRESULT hr = E_INVALIDARG;
	if (IsValidPtrIn(lpsz, IIDSTR_MAX) &&
		IsValidPtrOut(lpiid, sizeof(*lpiid)))
	{
		if ((lpsz == NULL) ||
			(lstrlenW(lpsz) == (IIDSTR_MAX - 1)))
		{
			hr = wIIDFromString(lpsz, lpiid);
		}

	}
	OLETRACEOUT((API_IIDFromString, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoIsOle1Class   (public)
//
//  Synopsis:   reads the Ole1Class entry in the registry for the given clsid
//
//  Arguments:  [rclsid]    - the classid to look up
//
//  Returns:    TRUE if Ole1Class
//              FALSE otherwise
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid)
{
	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)))
	{
		return(wCoIsOle1Class(rclsid));
	}
	return(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   ProgIDFromCLSID     (public)
//
//  Synopsis:   convert clsid into progid
//
//  Arguments:  [rclsid]    - the classid to look up
//              [pszProgID] - returned progid
//
//  Returns:    E_INVALIDARG, E_OUTOFMEMORY,
//              REGDB_E_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
STDAPI ProgIDFromCLSID(REFCLSID rclsid, LPWSTR FAR* ppszProgID)
{
	HRESULT hr = E_INVALIDARG;
	IComClassInfo* pICCI = NULL;

	if ((&rclsid != NULL) && ppszProgID != NULL &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(ppszProgID, sizeof(*ppszProgID)))
	{
		*ppszProgID = NULL;

		// Do not use Catalog for Ole1 clsids since it returns the Progid for
		// clsid of the TreatAs class instead of the queried clsid.
		if (!wCoIsOle1Class(rclsid))
		{
			hr = InitializeCatalogIfNecessary();

			if (SUCCEEDED(hr))
			{
				hr = gpCatalog->GetClassInfo (rclsid, IID_IComClassInfo, (void**) &pICCI);
			}

			if (SUCCEEDED(hr) && pICCI != NULL)
			{
				WCHAR* pszProgID = NULL;
 
				hr = pICCI->GetProgId( &pszProgID );

				if (SUCCEEDED(hr) && pszProgID != NULL)
				{
					*ppszProgID = UtDupString (pszProgID);
					hr = (*ppszProgID != NULL) ? S_OK : E_OUTOFMEMORY;
				}

				pICCI->Release();
			}
		}

		if (*ppszProgID == NULL && hr != E_OUTOFMEMORY)
		{
			hr = wkProgIDFromCLSID(rclsid, ppszProgID);
		}
	}

	return(hr);
}


//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromProgID     (public)
//
//  Synopsis:   convert progid into clsid
//
//  Arguments:  [pszProgID]  - the progid to convert
//              [pclsid]     - the returned classid
//
//  Returns:    E_INVALIDARG, CO_E_CLASSSTRING (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CLSIDFromProgID(LPCWSTR pszProgID, LPCLSID pclsid)
{
	HRESULT hr = E_INVALIDARG;

	if ((pszProgID != NULL) && (pclsid != NULL) &&
		IsValidPtrIn(pszProgID,1) &&
		IsValidPtrOut(pclsid, sizeof(*pclsid)))
	{
		*pclsid = CLSID_NULL;

		if (pszProgID[0] == 0)
		{
			hr = CO_E_CLASSSTRING;
		}
		else
		{
			IComClassInfo* pICCI = NULL;

			hr = InitializeCatalogIfNecessary();

			if ( SUCCEEDED(hr) )
			{
				hr = gpCatalog->GetClassInfoFromProgId ( (WCHAR *) pszProgID, IID_IComClassInfo, (void**) &pICCI);
			}

			if ( (hr == S_OK) && (pICCI != NULL) )
			{
				LPCLSID pTempClsid = NULL;
				hr = pICCI->GetConfiguredClsid( (GUID**) &pTempClsid );
				if ( pTempClsid == NULL )
				{
					hr = E_UNEXPECTED;
				}
				else
				{
					*pclsid = *pTempClsid;
				}
			}
            else
            {
                hr = CO_E_CLASSSTRING;
            }

            if (pICCI)
                pICCI->Release();

            //
            // REVIEW: Should not hit this path anymore, since RegCat knows
            // how to answer this question (and does so with CLSIDFromOle1Class)
            //
			// if ( FAILED(hr) )
			// {
            //     hr = CLSIDFromOle1Class(pszProgID, pclsid);
			// }            
		}
	}

	return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetClassVersion     (public)
//
//  Synopsis:   fetch versions for a class
//
//  Arguments:  [pClassSpec]   - [in] identifies the class (must be a CLSID)
//              [pdwVersionMS] - [out] version info
//              [pdwVersoinLS] - [out] version info
//
//  Returns:    E_INVALIDARG   - if pClassSpec is not a CLSID
//              errors from InitializeCatalogIfNecessary
//              errors from GetClassInfo
//              errors from GetVersionNumber
//
//--------------------------------------------------------------------------
STDAPI  CoGetClassVersion(/* [in] */ uCLSSPEC *pClassSpec,
						  /* [out] */ DWORD* pdwVersionMS,
						  /* [out] */ DWORD* pdwVersionLS)
{
	HRESULT hr = S_OK;
	IComClassInfo* pICCI = NULL;

	if (pClassSpec == NULL || pClassSpec->tyspec != TYSPEC_CLSID ||
		pdwVersionMS == NULL || pdwVersionLS == NULL )
	{
		hr = E_INVALIDARG;
	}

	if ( SUCCEEDED(hr) )
	{
		*pdwVersionMS = *pdwVersionLS = 0;
		hr = InitializeCatalogIfNecessary();
	}

	if ( SUCCEEDED(hr) )
	{
		hr = gpCatalog->GetClassInfo ( pClassSpec->tagged_union.clsid, IID_IComClassInfo, (void**) &pICCI );
	}

	if ( SUCCEEDED(hr) && pICCI != NULL )
	{
		hr = pICCI->GetVersionNumber ( pdwVersionMS, pdwVersionLS );
		pICCI->Release();
	}

	return hr;
}

#ifdef DIRECTORY_SERVICE

//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromProgIDEx     (public)
//
//  Synopsis:   convert progid into clsid, trigger ClassStore download if necessary
//
//  Arguments:  [pszProgID]  - the progid to convert
//              [pclsid]     - the returned classid
//
//  Returns:    E_INVALIDARG, CO_E_CLASSSTRING (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CLSIDFromProgIDEx(LPCWSTR pszProgID, LPCLSID pclsid)
{
	HRESULT hr=CLSIDFromProgID(pszProgID, pclsid);

    // If the call failed, check our code download policy
    // and attempt to install the application if the latter allows downloads
	if (FAILED(hr) && CheckDownloadRegistrySettings())
	{
		INSTALLDATA InstallData;

		InstallData.Type = PROGID;
		InstallData.Spec.ProgId = (PWCHAR) pszProgID;

		InstallApplication( &InstallData );
		hr=CLSIDFromProgID(pszProgID, pclsid);
	}

	return hr;
}

#endif

//+-------------------------------------------------------------------------
//
//  Function:   CoOpenClassKey      (public)
//
//  Synopsis:   opens a registry key for specified class
//
//  Arguments:  [rclsid]    - the classid to look up
//              [pszProgID] - returned progid
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
STDAPI CoOpenClassKey(REFCLSID clsid, BOOL bOpenForWrite, HKEY *lphkeyClsid)
{
	if ((&clsid != NULL) &&
		IsValidPtrIn(&clsid, sizeof(clsid)) &&
		IsValidPtrOut(lphkeyClsid, sizeof(*lphkeyClsid)))
	{
		return(wRegOpenClassKey(clsid,KEY_READ | (bOpenForWrite ? KEY_WRITE : 0), lphkeyClsid));
	}
	return(E_INVALIDARG);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetTreatAsClass   (public)
//
//  Synopsis:   get current treat as class if any
//
//  Arguments:  [clsidOld]  - the classid to look up
//              [pclsidNew] - returned classid
//
//  Returns:    S_OK when there is a TreatAs entry.
//              S_FALSE when there is no TreatAs entry.
//              REGDB_E_READREGDB or same as CLSIDFromString
//
//--------------------------------------------------------------------------
STDAPI  CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID lpClsidNew)
{
	if ((&clsidOld != NULL) &&
		IsValidPtrIn(&clsidOld, sizeof(clsidOld)) &&
		IsValidPtrOut(lpClsidNew, sizeof(*lpClsidNew)))
	{
		return(wCoGetTreatAsClass(clsidOld, lpClsidNew));
	}
	return(E_INVALIDARG);
}


//+-------------------------------------------------------------------------
//
//  Function:   CoTreatAsClass      (public)
//
//  Synopsis:   set current treat as class if any
//
//  Arguments:  [clsidOld]  - the old classid to look up
//              [clsidNew]  - the new classid
//
//  Returns:    S_OK if successful
//              REGDB_E_CLASSNOTREG, REGDB_E_READREGDB, REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew)
{
	if ((&clsidOld != NULL) &&
		(&clsidNew != NULL) &&
		IsValidPtrIn(&clsidOld, sizeof(clsidOld)) &&
		IsValidPtrIn(&clsidNew, sizeof(clsidNew)))
	{
		return(wCoTreatAsClass(clsidOld, clsidNew));
	}
	return(E_INVALIDARG);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoMarshalInterThreadInterfaceInStream, public
//
//  Synopsis:   helper function to a marshaled buffer to be passed
//              between threads.
//
//  Arguments:  [riid]      - interface id
//              [pUnk]      - ptr to interface we want to marshal
//              [ppStm]     - stream we want to give back to caller
//
//  Returns:    NOERROR     - Stream returned
//              E_INVALIDARG - Input parameters are invalid
//              E_OUTOFMEMORY - memory stream could not be created.
//
//  Algorithm:  Validate pointers. Create a stream and finally marshal
//              the input interface into the stream.
//
//  History:    03-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------------
HRESULT CoMarshalInterThreadInterfaceInStream(
											 REFIID riid,
											 LPUNKNOWN pUnk,
											 LPSTREAM *ppStm)
{
	HRESULT hr = E_INVALIDARG;
	LPSTREAM pStm = NULL;

    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

	// Validate parameters
	if ((&riid != NULL)
		&& IsValidPtrIn(&riid, sizeof(riid))
		&& IsValidInterface(pUnk)
		&& IsValidPtrOut(ppStm, sizeof(*ppStm)))
	{
		return(wCoMarshalInterThreadInterfaceInStream(riid, pUnk, ppStm));
	}
	return(E_INVALIDARG);
}





//+-------------------------------------------------------------------------
//
//  Function:   CoGetInterfaceAndReleaseStream, public
//
//  Synopsis:   Helper to unmarshal object from stream for inter-thread pass
//
//  Arguments:  [riid]      - interface id
//              [pStm]      - stream we want to give back to caller
//              [ppv]       - pointer for returned object
//
//  Returns:    NOERROR     - Unmarshaled object returned
//              E_OUTOFMEMORY - out of memory
//
//  Algorithm:  Validate the input parameters. Unmarshal the stream and
//              finally release the stream pointer.
//
//  History:    03-Nov-94   Ricksa       Created
//
//  Notes:      This always releases the input stream if stream is valid.
//
//--------------------------------------------------------------------------
HRESULT CoGetInterfaceAndReleaseStream(
									  LPSTREAM pstm,
									  REFIID riid,
									  LPVOID *ppv)
{
    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

	// Validate parameters.
	if (IsValidInterface(pstm) &&
		(&riid != NULL) &&
		IsValidPtrIn(&riid, sizeof(riid)) &&
		IsValidPtrOut(ppv, sizeof(*ppv)))
	{
		return(wCoGetInterfaceAndReleaseStream(pstm, riid, ppv));
	}
	return(E_INVALIDARG);
}

// The real working section...worker routines.  Assume parameter
// validation has already been done and therefore can be used
// internally by COM, STG, SCM etc

WCHAR wszOle1Class[]      = L"Ole1Class";
WCHAR wszProgID[]         = L"ProgID";
WCHAR wszClassKey[]       = L"CLSID\\";
#define ulClassKeyLen     ((sizeof(wszClassKey)/sizeof(WCHAR))-1)


//+-------------------------------------------------------------------------
//
//  Function:   wCoTreatAsClass      (internal)
//
//  Synopsis:   set current treat as class if any
//
//  Arguments:  [clsidOld]  - the old classid to look up
//              [clsidNew]  - the new classid
//
//  Returns:    S_OK if successful
//              REGDB_E_CLASSNOTREG, REGDB_E_READREGDB, REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
INTERNAL  wCoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew)
{
	HRESULT   hresult = S_OK;
	HKEY      hkeyClsid = NULL;
	WCHAR     szClsid[VALUE_LEN];
	LONG      cb = sizeof(szClsid);
	CLSID     clsidNewTmp;

	// The class had better be registered
	hresult = wRegOpenClassKey (clsidOld, KEY_READ | KEY_WRITE, &hkeyClsid);
	if (hresult != S_OK)
	{
		return hresult;
	}

	// Save the new clsid because it's a const and we may write into it
	clsidNewTmp = clsidNew;

	// Convert the new CLSID to a string
	Verify(StringFromCLSID2(clsidNew, szClsid, sizeof(szClsid)) != 0);

	// If the new CLSID equals the old CLSID, then convert AutoTreatAs, if
	// any, to TreatAs.
	if (IsEqualCLSID(clsidOld, clsidNew))
	{
		if (RegQueryValue(hkeyClsid, wszAutoTreatAs, szClsid, &cb) ==
			ERROR_SUCCESS)
		{
			if (wCLSIDFromString(szClsid, &clsidNewTmp) != S_OK)
			{
				return REGDB_E_INVALIDVALUE;
			}
		}

		// If no AutoTreatAs, remove any TreatAs
		else
		{
			clsidNewTmp = CLSID_NULL;
		}
	}

	// Make sure the new CLSID is not an OLE 1 class
	if (CoIsOle1Class(clsidNew))
	{
		return E_INVALIDARG;
	}

	// If the new CLSID is CLSID_NULL, then undo the emulation
	if (IsEqualCLSID(clsidNewTmp, CLSID_NULL))
	{
		LONG err = RegDeleteKey(hkeyClsid, wszTreatAs);
		if (err != ERROR_SUCCESS)
		{
			hresult = REGDB_E_WRITEREGDB;
		}
		else
		{
			hresult = S_OK;
		}
		Verify (ERROR_SUCCESS == RegCloseKey(hkeyClsid));
		return hresult;
	}

	if (RegSetValue(hkeyClsid, wszTreatAs, REG_SZ, (LPWSTR) szClsid,
					lstrlenW(szClsid)) != ERROR_SUCCESS)
	{
		hresult = REGDB_E_WRITEREGDB;
	}

	Verify (ERROR_SUCCESS == RegCloseKey(hkeyClsid));
	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCLSIDFromString (internal)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
INTERNAL wCLSIDFromString(LPWSTR lpsz, LPCLSID lpclsid)
{

	if (lpsz == NULL)
	{
		*lpclsid = CLSID_NULL;
		return NOERROR;
	}
	if (*lpsz == 0)
	{
		return(CO_E_CLASSSTRING);
	}

	if (lpsz[0] != '{')
	{
		return wCLSIDFromOle1Class(lpsz, lpclsid);
	}

	return wGUIDFromString(lpsz,lpclsid)
	? NOERROR : CO_E_CLASSSTRING;

}

// translate CLSID into Ole1Class
// REVIEW: might want to have CLSIDFromOle1Class instead of having
// CLSIDFromString do the work.
INTERNAL_(int) wOle1ClassFromCLSID2(REFCLSID rclsid, LPWSTR lpsz, int cbMax)
{
	if (wRegQueryClassValue(rclsid, wszOle1Class, lpsz, cbMax) != ERROR_SUCCESS)
	{
		// Use lookup table
		return Ole10_StringFromCLSID (rclsid, lpsz, cbMax) == NOERROR
		? lstrlenW (lpsz) : 0;
	}
	return lstrlenW(lpsz);
}

//+-------------------------------------------------------------------------
//
//  Function:   wCLSIDFromOle1Class      (internal)
//
//  Synopsis:   translate Ole1Class into clsid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              CO_E_CLASSSTRING    (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
INTERNAL  wCLSIDFromOle1Class(LPCWSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign)
{
	// lookup lpsz\\clsid and call CLSIDFromString on the result;
	// in a pathological case, this could infinitely recurse.
	HRESULT hr;
	WCHAR  sz[256];
	LONG cbValue = sizeof(sz);
	HKEY hkProgID;
	DWORD dwType;

	if (lpsz == NULL)
	{
		return(E_INVALIDARG);
	}

	if (*lpsz == 0)
	{
		return(CO_E_CLASSSTRING);
	}

	hr = wRegOpenProgIDKey(lpsz, &hkProgID);
	if (SUCCEEDED(hr))
	{
		if (RegQueryValue(hkProgID, L"CLSID", sz, &cbValue) != ERROR_SUCCESS)
		{
            // Attempt to go to the current version...
            WCHAR *szCurVer = NULL;
            if (RegQueryValue(hkProgID, L"CurVer", NULL, &cbValue) == ERROR_SUCCESS)
            {
                szCurVer = (WCHAR *)alloca(cbValue);
                if (RegQueryValue(hkProgID, L"CurVer", szCurVer, &cbValue) == ERROR_SUCCESS)
                {
                    // Recurse on the current version.
                    if (lstrcmpiW(szCurVer, lpsz) != 0)
                    {
                        RegCloseKey(hkProgID);
                        
                        return wCLSIDFromOle1Class(szCurVer, lpclsid, fForceAssign);
                    }
                }
            }

            // Just a failure code so we don't return immediately.
            hr = E_FAIL; 
		}
		RegCloseKey(hkProgID);
	}

	if (SUCCEEDED(hr))
	{
		hr = wCLSIDFromString(sz, lpclsid);
	}
	else
	{
		// Use lookup table or hash string to create CLSID for OLE 1 class.
		hr = Ole10_CLSIDFromString (lpsz, lpclsid, fForceAssign);
	}

	return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   wCoGetTreatAsClass   (internal)
//
//  Synopsis:   get current treat as class if any
//
//  Arguments:  [clsidOld]  - the classid to look up
//              [pclsidNew] - returned classid
//
//  Returns:    S_OK when there is a TreatAs entry.
//              S_FALSE when there is no TreatAs entry.
//              REGDB_E_READREGDB or same as CLSIDFromString
//
//--------------------------------------------------------------------------
INTERNAL  wCoGetTreatAsClass(REFCLSID clsidOld, LPCLSID lpClsidNew)
{
	// lookup HKEY_CLASSES_ROOT\CLSID\{rclsid}\TreatAs

	HRESULT hresult;
	HKEY    hkeyClsid = NULL;
	WCHAR   szClsid[VALUE_LEN];
	LONG    cb = sizeof(szClsid);

	VDATEPTROUT (lpClsidNew, CLSID);

	hresult = wRegOpenClassKey (clsidOld, KEY_READ, &hkeyClsid);
	if (hresult != NOERROR)
	{
		// same as no TreatAs case below
		*lpClsidNew = clsidOld;
		return S_FALSE;
	}

	CairoleDebugOut((DEB_REG, "RegQueryValue(%ws)\n", wszTreatAs));

	// Fetch the TreatAs class from the registry
	if (RegQueryValue(hkeyClsid, wszTreatAs, szClsid, &cb) == ERROR_SUCCESS)
	{
		hresult = wCLSIDFromString(szClsid, lpClsidNew);
	}

	// There is no TreatAs
	else
	{
		*lpClsidNew = clsidOld;
		hresult = S_FALSE;
	}

	Verify (ERROR_SUCCESS==RegCloseKey(hkeyClsid));
	return hresult;
}
//+-------------------------------------------------------------------------
//
//  Function:   wRegQueryPSClsid     (private)
//
//  Synopsis:   reads the proxystub clsid entry out of the registry.
//
//  Arguments:  [riid]      - the interface iid to lookup
//              [lpclsid]   - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  Notes:      this is an internal function used only if the requested IID
//              entry is not in the shared memory table and the table is full.
//
//  History:    07-Apr-94   Rickhi      extracted from original source
//              04-Feb-96   BruceMa     Per-user registry support
//
//--------------------------------------------------------------------------
INTERNAL wRegQueryPSClsid(REFIID riid, LPCLSID lpclsid)
{
	// lookup HKEY_CLASSES_ROOT\Interface\{iid}\ProxyStubClsid

	HRESULT hr = REGDB_E_IIDNOTREG;
	WCHAR szValue[VALUE_LEN];
	ULONG cbValue = sizeof(szValue);
	HKEY hkInterface;
	HKEY  hIf;
	DWORD dwType;
	int err;

	hr = wRegOpenInterfaceKey(riid, &hkInterface);
	if (SUCCEEDED(hr))
	{
		err = RegOpenKeyEx(hkInterface, L"ProxyStubClsid32", NULL, KEY_READ, &hIf);
		if (ERROR_SUCCESS == err)
		{
			// The unnamed value is the clsid for this iid
			err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
			if (ERROR_SUCCESS == err)
			{
				hr = wCLSIDFromString(szValue, lpclsid);
			}
			RegCloseKey(hIf);
		}
		else
		{
			// If the key is missing, check to see if it is IDispatch
			//
			// There wasn't a ProxyStubClsid32 for this interface.
			// Because many applications install with interfaces
			// that are variations on IDispatch, we are going to check
			// to see if there is a ProxyStubClsid. If there is, and its
			// class is that of IDispatch, then the OLE Automation DLL is
			// the correct one to use. In that particular case, we will
			// pretend that ProxyStubClsid32 existed, and that it is
			// for IDispatch.

			err = RegOpenKeyEx(hkInterface, L"ProxyStubClsid", NULL, KEY_READ, &hIf);
			if (ERROR_SUCCESS == err)
			{
				// The unnamed value is the clsid for this iid
				err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
				if (ERROR_SUCCESS == err)
				{
					CLSID clsid;

					hr = wCLSIDFromString(szValue, &clsid);
					if (SUCCEEDED(hr) &&
						IsEqualCLSID(CLSID_PSDispatch, clsid))
					{
						CairoleDebugOut((DEB_WARN,
										 "Substituting IDispatch based on ProxyStubClsid\n"));
						*lpclsid = CLSID_PSDispatch;
						hr = S_OK;
					}
				}
				RegCloseKey(hIf);
			}
		}
		RegCloseKey(hkInterface);
	}

	return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   wRegQuerySyncIIDFromAsyncIID     (private)
//
//  Synopsis:   maps an async IID to a sync IID using the registry
//
//  Arguments:  [riidAsync]   - async IID in
//              [lpiidSync]   - corresponding sync IID out
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  History:    MattSmit 26-Sep-97  Created - loosely copied from wRegQueryPSClsid
//
//--------------------------------------------------------------------------
INTERNAL wRegQuerySyncIIDFromAsyncIID(REFIID riid, LPCLSID lpiidSync)
{
	// lookup HKEY_CLASSES_ROOT\Interface\{iid}\ProxyStubClsid

	HRESULT hr = REGDB_E_IIDNOTREG;
	WCHAR szValue[VALUE_LEN];
	ULONG cbValue = sizeof(szValue);
	HKEY hkInterface;
	HKEY  hIf;
	DWORD dwType;
	int err;

	hr = wRegOpenInterfaceKey(riid, &hkInterface);
	if (SUCCEEDED(hr))
	{
		err = RegOpenKeyEx(hkInterface, L"SynchronousInterface", NULL, KEY_READ, &hIf);
		hr =  REGDB_E_READREGDB;
		if (ERROR_SUCCESS == err)
		{
			// The unnamed value is the sync iid for this iid
			err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
			if (ERROR_SUCCESS == err)
			{
				hr = wCLSIDFromString(szValue, lpiidSync);
			}
			RegCloseKey(hIf);
		}
		RegCloseKey(hkInterface);
	}

	return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   wRegQueryAsyncIIDFromSyncIID     (private)
//
//  Synopsis:   maps a sync iid to an async iid using the registry
//
//  Arguments:  [riid]        - the interface iid to lookup
//              [lpiidAsync]   - corresponding async iid
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  History:    MattSmit 26-Sep-97  Created - loosely copied from wRegQueryPSClsid
//
//--------------------------------------------------------------------------
INTERNAL wRegQueryAsyncIIDFromSyncIID(REFIID riid, LPCLSID lpiidAsync)
{
	// lookup HKEY_CLASSES_ROOT\Interface\{iid}\ProxyStubClsid

	HRESULT hr = REGDB_E_IIDNOTREG;
	WCHAR szValue[VALUE_LEN];
	ULONG cbValue = sizeof(szValue);
	HKEY hkInterface;
	HKEY  hIf;
	DWORD dwType;
	int err;

	hr = wRegOpenInterfaceKey(riid, &hkInterface);
	if (SUCCEEDED(hr))
	{
		err = RegOpenKeyEx(hkInterface, L"AsynchronousInterface", NULL, KEY_READ, &hIf);
		hr =  REGDB_E_READREGDB;
		if (ERROR_SUCCESS == err)
		{
			// The unnamed value is the sync iid for this iid
			err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
			if (ERROR_SUCCESS == err)
			{
				hr = wCLSIDFromString(szValue, lpiidAsync);
			}
			RegCloseKey(hIf);
		}
		RegCloseKey(hkInterface);
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoGetClassExt   (internal)
//
//  Synopsis:   returns the clsid for files with the specified file extension
//
//  Arguments:  [pszExt] - the file extension to look up
//              [pclsid] - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_CLASSNOTREG if extension is not registered.
//              REGDB_E_READREGDB   if any other error
//
//  History:    07-Apr-94   Rickhi      added caching
//              26-Sep-96   t-KevinH    New caching scheme
//
//--------------------------------------------------------------------------
INTERNAL wCoGetClassExt(LPCWSTR pwszExt, LPCLSID pclsid)
{
	if (!g_pExtTbl)
	{
		ASSERT_LOCK_NOT_HELD(gTblLck);
		LOCK(gTblLck);

		if (!g_pExtTbl)
		{
			g_pExtTbl = new CProcessExtensionTbl;
		}

		UNLOCK(gTblLck);
		ASSERT_LOCK_NOT_HELD(gTblLck);

		if (!g_pExtTbl)
		{
			return E_OUTOFMEMORY;
		}
	}

	return g_pExtTbl->GetClsid(pwszExt, pclsid);
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegGetClassExt  (private)
//
//  Synopsis:   returns the clsid for files with the specified file extension
//
//  Arguments:  [pszExt] - the file extension to look up
//              [pclsid] - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_CLASSNOTREG if extension is not registered.
//              REGDB_E_READREGDB   if any other error
//
//  Notes:
//
//  History:    07-Apr-94   Rickhi      added caching
//              04-Feb-96   BruceMa     Per-user registry support
//
//--------------------------------------------------------------------------
INTERNAL wRegGetClassExt(LPCWSTR lpszExt, LPCLSID pclsid)
{
	HRESULT hr;
	HKEY  hExt;
	int   err;
	WCHAR szKey[KEY_LEN];
	WCHAR szValue[VALUE_LEN];
	LONG  cbValue = sizeof(szValue);
	DWORD dwType;

	// Open the key
	hr = wRegOpenFileExtensionKey(lpszExt, &hExt);
	if (SUCCEEDED(hr))
	{
		// The ProgId is this key's unnamed value
		err = RegQueryValueEx(hExt, NULL, NULL, &dwType, (BYTE *) szValue,
							  (ULONG *) &cbValue);

		if (ERROR_SUCCESS == err)
		{
			hr = wCLSIDFromProgID(szValue, pclsid);
		}
		else
		{
			hr = REGDB_E_CLASSNOTREG;
		}
		RegCloseKey(hExt);
	}
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoGetClassPattern   (internal)
//
//  Synopsis:   attempts to determine the class of a file by looking
//              at byte patterns in the file.
//
//  Arguments:  [hfile] - handle of file to look at
//              [pclsid] - the class of object to create
//
//  Returns:    S_OK - a pattern match was found, pclisd contains the clsid
//              MK_E_CANTOPENFILE - cant open the file.
//              REGDB_E_CLASSNOTREG - no pattern match was made
//
//--------------------------------------------------------------------------
INTERNAL wCoGetClassPattern(HANDLE hfile, CLSID *pclsid)
{
	HRESULT hr = S_OK;

	// Check whether our pattern table has been initialized
	if (g_pPatTbl == NULL)
	{
		ASSERT_LOCK_NOT_HELD(gTblLck);
		LOCK(gTblLck);

		if (g_pPatTbl == NULL)
		{
			hr = E_OUTOFMEMORY;

			// load the cache
			g_pPatTbl = new CProcessPatternTbl(hr);

			if (FAILED(hr))
			{
				delete g_pPatTbl;
				g_pPatTbl = NULL;
			}
		}

		UNLOCK(gTblLck);
	}

	if (SUCCEEDED(hr))
	{
		// Check the file for registered patterns
		hr = g_pPatTbl->FindPattern(hfile, pclsid);
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoMarshalInterThreadInterfaceInStream, (internal)
//
//  Synopsis:   helper function to a marshaled buffer to be passed
//              between threads.
//
//  Arguments:  [riid]      - interface id
//              [pUnk]      - ptr to interface we want to marshal
//              [ppStm]     - stream we want to give back to caller
//
//  Returns:    NOERROR     - Stream returned
//              E_INVALIDARG - Input parameters are invalid
//              E_OUTOFMEMORY - memory stream could not be created.
//
//  Algorithm:  Create a stream and finally marshal
//              the input interface into the stream.
//
//  History:    03-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------------
INTERNAL_(HRESULT) wCoMarshalInterThreadInterfaceInStream(
														 REFIID riid,
														 LPUNKNOWN pUnk,
														 LPSTREAM *ppStm)
{
	HRESULT hr;
	LPSTREAM pStm = NULL;

	// Assume error
	hr = E_OUTOFMEMORY;

	// Create a stream
	pStm = CreateMemStm(EST_INPROC_MARSHAL_SIZE, NULL);

	if (pStm != NULL)
	{
		// Marshal the interface into the stream
		hr = CoMarshalInterface(pStm, riid, pUnk, MSHCTX_INPROC, NULL,
								MSHLFLAGS_NORMAL);
	}

	if (SUCCEEDED(hr))
	{
		// Reset the stream to the begining
		LARGE_INTEGER li;
		LISet32(li, 0);
		pStm->Seek(li, STREAM_SEEK_SET, NULL);

		// Set the return value
		*ppStm = pStm;
	}
	else
	{
		// Cleanup if failure
		if (pStm != NULL)
		{
			pStm->Release();
		}

		*ppStm = NULL;
	}

	// Assert

	// Return the result
	return hr;
}





//+-------------------------------------------------------------------------
//
//  Function:   wCoGetInterfaceAndReleaseStream, (internal)
//
//  Synopsis:   Helper to unmarshal object from stream for inter-thread pass
//
//  Arguments:  [riid]      - interface id
//              [pStm]      - stream we want to give back to caller
//              [ppv]       - pointer for returned object
//
//  Returns:    NOERROR     - Unmarshaled object returned
//              E_OUTOFMEMORY - out of memory
//
//  Algorithm:  Unmarshal the stream and
//              finally release the stream pointer.
//
//  History:    03-Nov-94   Ricksa       Created
//
//  Notes:      This always releases the input stream if stream is valid.
//
//--------------------------------------------------------------------------
INTERNAL_(HRESULT) wCoGetInterfaceAndReleaseStream(
												  LPSTREAM pstm,
												  REFIID riid,
												  LPVOID *ppv)
{
	HRESULT hr;

	// Unmarshal the interface
	hr = CoUnmarshalInterface(pstm, riid, ppv);

	// Release the stream since that is the way the function is defined.
	pstm->Release();

	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromCLSID (internal)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
INTERNAL  wStringFromCLSID(REFCLSID rclsid, LPWSTR FAR* lplpsz)
{
	WCHAR sz[CLSIDSTR_MAX];

	Verify(StringFromCLSID2(rclsid, sz, CLSIDSTR_MAX) != 0);

	*lplpsz = UtDupString(sz);

	return *lplpsz != NULL ? NOERROR : E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromIID   (internal)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
INTERNAL wStringFromIID(REFIID rclsid, LPWSTR FAR* lplpsz)
{
	WCHAR sz[IIDSTR_MAX];
	*lplpsz = NULL;

	if (StringFromIID2(rclsid, sz, IIDSTR_MAX) != 0)
	{
		*lplpsz = UtDupString(sz);
	}

	return *lplpsz != NULL ? NOERROR : E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------------
//
//  Function:   wIIDFromString   (internal)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz]  - ptr to buffer for results
//              [lpiid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
INTERNAL wIIDFromString(LPWSTR lpsz, LPIID lpiid)
{
	if (lpsz == NULL)
	{
		*lpiid = IID_NULL;
		return NOERROR;
	}

	return wGUIDFromString(lpsz, lpiid)
	? NOERROR : CO_E_IIDSTRING;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoIsOle1Class   (internal)
//
//  Synopsis:   reads the Ole1Class entry in the registry for the given clsid
//
//  Arguments:  [rclsid]    - the classid to look up
//
//  Returns:    TRUE if Ole1Class
//              FALSE otherwise
//
//  History:    Gopalk  Oct 30,96  Changed to check HIWORD before hitting
//                                 registry
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) wCoIsOle1Class(REFCLSID rclsid)
{
	CairoleDebugOut((DEB_REG, "wCoIsOle1Class called.\n"));

	//  since we now have guid, Ole1Class = would indicate OLE 1.0 nature.
	//  lookup HKEY_CLASSES_ROOT\{rclsid}\Ole1Class
	WCHAR szValue[VALUE_LEN];
	WORD hiWord;

	hiWord = HIWORD(rclsid.Data1);
	if (hiWord==3 || hiWord==4)
		if (wRegQueryClassValue(rclsid, wszOle1Class, szValue, sizeof(szValue))==ERROR_SUCCESS)
			return TRUE;

	return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   wkProgIDFromCLSID     (internal)
//              (wProgIDFromCLSID name is already in use)
//
//  Synopsis:   convert clsid into progid
//
//  Arguments:  [rclsid]    - the classid to look up
//              [pszProgID] - returned progid
//
//  Returns:    E_INVALIDARG, E_OUTOFMEMORY,
//              REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wkProgIDFromCLSID(REFCLSID rclsid, LPWSTR FAR* ppszProgID)
{
	HRESULT hr;
	WCHAR szProgID[KEY_LEN];

	*ppszProgID = NULL;

	hr = wRegQueryClassValue (rclsid, wszProgID, szProgID, sizeof(szProgID));

	if (SUCCEEDED(hr))
	{
		*ppszProgID = UtDupString (szProgID);
		hr = (*ppszProgID != NULL) ? NOERROR : E_OUTOFMEMORY;
	}

	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenKeyEx      (internal)
//
//  Synopsis:   Opens a registry key.  HKEY_CLASSES_ROOT is a special case.
//              First, we try to open the per-user key under
//              HKEY_CURRENT_USER\Software\Classes.  Second, we try to
//              open the key under HKEY_LOCAL_MACHINE\Software\Classes.
//
//  Returns:    ERROR_SUCCESS
//
//--------------------------------------------------------------------------
INTERNAL_(LONG) wRegOpenKeyEx(
							 HKEY hKey,	 // handle of open key
							 LPCWSTR lpSubKey,	 // address of name of subkey to open
							 DWORD ulOptions,	 // reserved
							 REGSAM samDesired,	 // security access mask
							 PHKEY phkResult	 // address of handle of open key
							 )
{
	LONG status;

	status = RegOpenKeyEx(hKey,
						  lpSubKey,
						  ulOptions,
						  samDesired,
						  phkResult);

	return status;
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegQueryClassValue  (Internal)
//
//  Synopsis:   reads the specified subkey of the specified clsid
//
//  Arguments:  [rclsid]     - the classid to look up
//              [lpszSubKey] - subkey to read
//              [lpszValue]  - buffer to hold returned value
//              [cbMax]      - sizeof the buffer
//
//  Returns:    REGDB_E_CLASSNOTREG, REGDB_E_READREGDB
//
//  Notes:      We search both the per-user and per-machine registry.
//
//--------------------------------------------------------------------------
INTERNAL wRegQueryClassValue(REFCLSID rclsid, LPCWSTR lpszSubKey,
							 LPWSTR lpszValue, int cbMax)
{
	HRESULT hr;
	HKEY hkeyClsid;
	LONG cbValue = cbMax;

	hr = wRegOpenClassKey (rclsid, KEY_READ, &hkeyClsid);
	if (SUCCEEDED(hr))
	{
		long status;

		status = RegQueryValue(hkeyClsid, lpszSubKey, lpszValue, &cbValue);

		switch (status)
		{
		case ERROR_SUCCESS:
			hr = S_OK;
			break;

			// win32 will return file not found instead of bad key
		case ERROR_FILE_NOT_FOUND:
		case ERROR_BADKEY:
			hr = REGDB_E_CLASSNOTREG;
			break;

		default:
			hr = REGDB_E_READREGDB;
			break;
		}

		//Close the key.
		Verify (ERROR_SUCCESS == RegCloseKey(hkeyClsid));
	}

	CairoleDebugOut((DEB_REG, "ReqQueryValue(%ws)\n", lpszSubKey));
	return hr;
}


//+-------------------------------------------------------------------------
/*
	Function:   HandlerInRegistry           (internal)

	Synopsis:   given a CLSTX value and a classid, determines
					   if a handler for that context exists in the
					   registry for that class

	Parameters: [in] clsid          -  ClassID
						[in] dwClsCtx  -   Context

	Returns:      REGDB_E_CLASSNOTREG, S_OK

	History:       Dec. 10, 1997   RahulTh         created
*/
//+--------------------------------------------------------------------------
HRESULT HandlerInRegistry (
						  REFCLSID    clsid,
						  DWORD       dwClsCtx)
{
	HKEY hkClsid = NULL;
	DWORD dwReserved = 0;
	HKEY hkSubkey = NULL;
	HRESULT hr = REGDB_E_CLASSNOTREG;

	//first see if the clsid exists in the registry
	if (FAILED(wRegOpenClassKey(clsid, KEY_READ, &hkClsid)))
	{
		return REGDB_E_CLASSNOTREG;
	}

	//if clsid exists in the registry, check if the required server is registered
	if (dwClsCtx & CLSCTX_LOCAL_SERVER)
	{
		hr = RegOpenKeyEx(hkClsid, L"LocalServer32", dwReserved,
						  KEY_READ, &hkSubkey);
		goto exit_HandlerInRegistry;
	}

	if (dwClsCtx & CLSCTX_INPROC_SERVER)
	{
		hr = RegOpenKeyEx(hkClsid, L"InprocServer32", dwReserved,
						  KEY_READ, &hkSubkey);
		goto exit_HandlerInRegistry;
	}

	if (dwClsCtx & CLSCTX_INPROC_HANDLER)
	{
		hr = RegOpenKeyEx(hkClsid, L"InprocHandler32", dwReserved,
						  KEY_READ, &hkSubkey);
		goto exit_HandlerInRegistry;
	}

	exit_HandlerInRegistry:

	Verify (hkSubkey?(ERROR_SUCCESS == RegCloseKey(hkSubkey)):TRUE);
	Verify (hkClsid?(ERROR_SUCCESS == RegCloseKey(hkClsid)):TRUE);

	if (SUCCEEDED(hr))
		return S_OK;
	else
		return REGDB_E_CLASSNOTREG;
}


//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenClassKey      (internal)
//
//  Synopsis:   opens a registry key for specified class
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenClassKey(
						 REFCLSID clsid,
						 REGSAM samDesired,
						 HKEY FAR* lphkeyClsid)
{
	long status;
	WCHAR szKey[KEY_LEN];

	if (IsEqualCLSID(clsid, CLSID_NULL))
		return REGDB_E_CLASSNOTREG;

	*lphkeyClsid = NULL;

	lstrcpyW (szKey, wszClassKey);
	Verify (StringFromCLSID2 (clsid, szKey+ulClassKeyLen,
							  sizeof(szKey)-ulClassKeyLen) != 0);

	status = OpenClassesRootKeyEx(szKey, samDesired, lphkeyClsid);

	switch (status)
	{
	case ERROR_SUCCESS:
		return NOERROR;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_CLASSNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenClassSubkey  (Internal)
//
//  Synopsis:   Opens the specified subkey of the specified clsid
//
//  Arguments:  [rclsid]      - the classid to look up
//              [lpszSubKey]  - subkey to read
//              [phkeySubkey] - returned value HKEY
//
//  Returns:    Return value of RegOpenKeyEx
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenClassSubkey(
							REFCLSID rclsid,
							LPCWSTR lpszSubkey,
							HKEY *phkeySubkey)
{
	WCHAR szKey[KEY_LEN];
	int ccClsid, ccLen;

	lstrcpyW(szKey, wszClassKey);

	ccLen = ulClassKeyLen;

	// translate rclsid into string
	ccClsid = StringFromCLSID2(rclsid,
							   &szKey[ccLen],
							   KEY_LEN-ccLen);

	CairoleAssert((ccClsid != 0) && "wReqOpenClassSubkey");

	ccLen += ccClsid-1;

	szKey[ccLen++] = L'\\';
	lstrcpyW(&szKey[ccLen], lpszSubkey);

	CairoleDebugOut((DEB_REG, "wReqOpenClassSubkey(%ws)\n", szKey));
	if (ERROR_SUCCESS != OpenClassesRootKeyEx(
									  szKey,
									  KEY_READ,
									  phkeySubkey))
	{
		return REGDB_E_READREGDB;
	}
	return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenInterfaceKey      (internal)
//
//  Synopsis:   opens a registry key for specified interface
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenInterfaceKey(REFIID riid, HKEY * lphkeyIID)
{
	long status;
	WCHAR szKey[KEY_LEN];
	lstrcpyW(szKey, wszInterfaceKey);
	int cbIid = StringFromIID2(riid, &szKey[ulInterfaceKeyLen],
							   sizeof(szKey)-ulInterfaceKeyLen);

	status = OpenClassesRootKeyEx(
						   szKey,
						   KEY_READ,
						   lphkeyIID);

	switch (status)
	{
	case ERROR_SUCCESS:
		return NOERROR;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_IIDNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenProgIDKey      (internal)
//
//  Synopsis:   opens a registry key for specified ProgID.
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenProgIDKey(LPCWSTR pszProgID, HKEY FAR* lphkeyClsid)
{
	long status;

	status = OpenClassesRootKeyEx(
						   pszProgID,
						   KEY_READ,
						   lphkeyClsid);

	switch (status)
	{
	case ERROR_SUCCESS:
		return NOERROR;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_CLASSNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}



//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenFileExtensionKey      (internal)
//
//  Synopsis:   opens a registry key for specified file extension.
//
//  Arguments:  [pszFileExt]- the file extension to look up
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenFileExtensionKey(LPCWSTR pszFileExt, HKEY FAR* lphkeyClsid)
{
	long status;

	status = OpenClassesRootKeyEx(
						   pszFileExt,
						   KEY_READ,
						   lphkeyClsid);

	switch (status)
	{
	case ERROR_SUCCESS:
		return S_OK;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_CLASSNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\cspytbl.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       cspytbl.cxx
//
//  Contents:   Used by CTaskMemory::* (memapi.cxx) to support IMallocSpy
//
//  Synopsis:   The requirements are to efficiently store, locate and remove
//              entries in a table that may have to be expanded.  Therefore
//              the choice is a dynamically expandable hash table.  It is
//              fast and removals do not require compaction.  Expansion is
//              always to twice the current number of entries, so excessive
//              expansions will not be done.
//
//  Classes:    CSpyTable
//
//  Functions:  
//
//  History:    27-Oct-94  BruceMa      Created
//
//----------------------------------------------------------------------


#include <ole2int.h>
#include "cspytbl.hxx"





//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::CSpyTable, public
//
//  Synopsis:	Constructor
//
//  Arguments:	BOOl *  -       Indicates construction success
//
//  Algorithm:	
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
CSpyTable::CSpyTable(BOOL *pfOk)
{
    // Allocate and initialize the hash table
    m_cAllocations = 0;
    m_cEntries = INITIALENTRIES;
    m_table = (LPAENTRY) LocalAlloc(LMEM_FIXED, m_cEntries * sizeof(AENTRY));
    if (m_table == NULL)
    {
        *pfOk = FALSE;
        return;
    }

    // Initialize the table
    // m_table[*].dwCollision = FALSE;
    // m_table[*].allocation = NULL;
    memset(m_table, 0, m_cEntries * sizeof(AENTRY));

    // Return success
    *pfOk = TRUE;

}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::~CSpyTable, public
//
//  Synopsis:	Destructor
//
//  Arguments:	-
//
//  Algorithm:	
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
CSpyTable::~CSpyTable()
{
    // Delete the table
    LocalFree(m_table);
}
    




//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Add, public
//
//  Synopsis:	Add an entry to the hash table
//
//  Arguments:	void *  -       The allocation to add
//
//  Algorithm:	
//
//  Returns:    TRUE     -       Entry added
//              FALSE    -       Memory failure expanding table
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	(1) This can only fail on a memory allocation failure
//
//              (2) The j == j0 test guarantees the table is full since
//                  the algorithm is wrapping at a collision using a prime
//                  number which is relatively prime to m_cEntries
//
//--------------------------------------------------------------------------
BOOL CSpyTable::Add(void *allocation)
{
    ULONG j0, j;

    // Don't add null entries
    if (allocation == NULL)
    {
        return FALSE;
    }
    
    // Search for an available entry

    // Do until success or the table is full
    j = j0 = PtrToUlong(allocation) % m_cEntries;
    do
    {
        j = (j + PRIME) % m_cEntries;
        if (m_table[j].pAllocation != NULL)
        {
            m_table[j].dwCollision = TRUE;
        }
    } until_(m_table[j].pAllocation == NULL  ||  j == j0);

    // Found an available entry
    if (j != j0)
    {
        m_table[j].pAllocation = allocation;
        m_cAllocations++;
        return TRUE;
    }

    // The table is full
    else
    {
        // Expand the hash table
        if (!Expand())
        {
            return FALSE;
        }

        // Call ourself recusively to add
        return Add(allocation);
    }
}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Remove, public
//
//  Synopsis:	Remove an entry from the table
//
//  Arguments:	void *  -       The allocation to remove
//
//  Algorithm:	
//
//  Returns:    TRUE     -       Entry removed
//              FALSE    -       Entry not found
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
BOOL CSpyTable::Remove(void *allocation)
{
    ULONG j0, j;
    
    // Search for the entry
    if (Find(allocation, &j))
    {
        // Remove the entry
        m_table[j].pAllocation = NULL;

        // Remove collison markers from here backward until
        // a non-empty entry (if next forward entry is not empty)
        if (m_table[j].dwCollision)
        {
            j0 = (j + PRIME) % m_cEntries;
            if (m_table[j].pAllocation == NULL  &&  !m_table[j].dwCollision)
            {
                j0 = j;
                do
                {
                    m_table[j].dwCollision = FALSE;
                    j = (j - PRIME + m_cEntries) % m_cEntries;
                } until_(m_table[j].pAllocation != NULL  ||  j == j0);
            }
        }
        m_cAllocations--;
        return TRUE;
    }

    // Otherwise the entry was not found
    else
    {
        return FALSE;
    }
}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Find, public
//
//  Synopsis:	Find an entry in the table
//
//  Arguments:	void *  -       The allocation to find
//              ULONG * -       Out parameter to store the index of
//                              the found entry
//
//  Algorithm:	
//
//  Returns:    TRUE     -       Entry found
//              FALSE    -       Entry not found
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
BOOL  CSpyTable::Find(void *allocation, ULONG *pulIndex)
{
    ULONG j0, j;

    // Don't search for null entries
    if (allocation == NULL)
    {
        return FALSE;
    }
    
    // Search for the entry

    // Do until success or end of the table is reached
    j = j0 = PtrToUlong(allocation) % m_cEntries;
    do
    {
        j = (j + PRIME) % m_cEntries;
    } until_(m_table[j].pAllocation == allocation  ||
             (m_table[j].pAllocation == NULL  &&
              m_table[j].dwCollision == FALSE)    ||
             j == j0);

    // Return result
    if (m_table[j].pAllocation == allocation)
    {
        *pulIndex = j;
        return TRUE;
    }

    // Else not found
    else
    {
        return FALSE;
    }
}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Expand, private
//
//  Synopsis:	Expand the hash table
//
//  Arguments:	-
//
//  Algorithm:	
//
//  Returns:    TRUE    -       Expansion successful
//              FALSE   -       Memory allocation failure during expansion
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	To allow starting with a small table but not to do too many
//              expansions in a large application, we expand by twice the
//              current number of entries.
//
//--------------------------------------------------------------------------
BOOL CSpyTable::Expand(void)
{
    LPAENTRY pOldTable;

    // Save the current table
    pOldTable = m_table;

    // Allocate a new table
    m_cEntries *= 2;
    m_table = (LPAENTRY) LocalAlloc(LMEM_FIXED, m_cEntries * sizeof(AENTRY));
    if (m_table == NULL)
    {
        m_table = pOldTable;
        return FALSE;
    }

    // Initialize it
    for (ULONG j = 0; j < m_cEntries; j++)
    {
        m_table[j].dwCollision = FALSE;
        m_table[j].pAllocation = NULL;
    }

    // Restore the entries in the old table
    m_cAllocations = 0;
    for (j = 0; j < m_cEntries / 2; j++)
    {
        if (pOldTable[j].pAllocation != NULL)
        {
            Add(pOldTable[j].pAllocation);
        }
    }

    // Clean up
    LocalFree(pOldTable);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\ole1guid.h ===
/* ole1guid.h

	Contains prototypes for OLE10 class string <--> CLSID conversion
	functions in ole1guid.cpp

	These functions are to be called only if the information
	is not available in the reg db.

	Copyright (c) 1992  Microsoft Corporation
*/


INTERNAL Ole10_StringFromCLSID
	(REFCLSID clsid,
	LPWSTR szOut,
	int cbMax);

INTERNAL Ole10_CLSIDFromString
	(LPCWSTR szOle1,
	CLSID FAR* pclsid,
	BOOL fForceAssign);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\pexttbl.cxx ===
//+------------------------------------------------------------------------
//
//  File:       pexttbl.cxx
//
//  Contents:   Table to support (per process) file extension to CLSID
//              registry caching
//
//  Classes:    CProcessExtensionTbl
//
//  History:	26-Sep-96   t-KevinH	Created
//
//-------------------------------------------------------------------------

#include <ole2int.h>
#include <olesem.hxx>

#include <pexttbl.hxx>       // class definition


#define EXT_ENTRIES_PER_PAGE		32

COleStaticMutexSem gTblLck;	// Table Lock

//+------------------------------------------------------------------------
//
//  Hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain ExtBuckets[23] =
{
    {&ExtBuckets[0],  &ExtBuckets[0]},
    {&ExtBuckets[1],  &ExtBuckets[1]},
    {&ExtBuckets[2],  &ExtBuckets[2]},
    {&ExtBuckets[3],  &ExtBuckets[3]},
    {&ExtBuckets[4],  &ExtBuckets[4]},
    {&ExtBuckets[5],  &ExtBuckets[5]},
    {&ExtBuckets[6],  &ExtBuckets[6]},
    {&ExtBuckets[7],  &ExtBuckets[7]},
    {&ExtBuckets[8],  &ExtBuckets[8]},
    {&ExtBuckets[9],  &ExtBuckets[9]},
    {&ExtBuckets[10], &ExtBuckets[10]},
    {&ExtBuckets[11], &ExtBuckets[11]},
    {&ExtBuckets[12], &ExtBuckets[12]},
    {&ExtBuckets[13], &ExtBuckets[13]},
    {&ExtBuckets[14], &ExtBuckets[14]},
    {&ExtBuckets[15], &ExtBuckets[15]},
    {&ExtBuckets[16], &ExtBuckets[16]},
    {&ExtBuckets[17], &ExtBuckets[17]},
    {&ExtBuckets[18], &ExtBuckets[18]},
    {&ExtBuckets[19], &ExtBuckets[19]},
    {&ExtBuckets[20], &ExtBuckets[20]},
    {&ExtBuckets[21], &ExtBuckets[21]},
    {&ExtBuckets[22], &ExtBuckets[22]}
};


//+-------------------------------------------------------------------
//
//  Function:   CleanupExtEntry
//
//  Synopsis:   Call the ExtensionTbl to cleanup an entry. This is called
//              by the hash table cleanup code.
//
//  History:    26-Sep-96   t-KevinH  Created
//
//--------------------------------------------------------------------
void CleanupExtEntry(SHashChain *pNode)
{
    if (((SExtEntry *)pNode)->m_wszExt != ((SExtEntry *)pNode)->m_wszBuf)
    {
	PrivMemFree(((SExtEntry *)pNode)->m_wszExt);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::CProcessExtensionTbl, public
//
//  Synopsis:   Initialize the table
//
//  History:    26-Sep-96   t-KevinH      Created
//
//-------------------------------------------------------------------------
CProcessExtensionTbl::CProcessExtensionTbl()
{
    LOCK(gTblLck);
    _HashTbl.Initialize(ExtBuckets, &gTblLck );
    _palloc.Initialize(sizeof(SExtEntry), EXT_ENTRIES_PER_PAGE, &gTblLck );
    UNLOCK(gTblLck);
}

//+------------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::~CProcessExtensionTbl, public
//
//  Synopsis:   Cleanup the Registered Interface Table.
//
//  History:    26-Sep-96   t-KevinH      Created
//
//-------------------------------------------------------------------------
CProcessExtensionTbl::~CProcessExtensionTbl()
{
    LOCK(gTblLck);
    _HashTbl.Cleanup(CleanupExtEntry);
    _palloc.Cleanup();
    UNLOCK(gTblLck);
}

//+-------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::GetClsid, public
//
//  Synopsis:   Finds the ExtEntry in the table for the given extension,
//              adds an entry if one is not found.
//
//  History:    26-Sep-96   t-KevinH      Created
//
//--------------------------------------------------------------------
HRESULT CProcessExtensionTbl::GetClsid(LPCWSTR pwszExt, CLSID *pclsid)
{
    HRESULT hr = S_OK;
    WCHAR wszExtLower[MAX_PATH];	// The extension in lower case

    // ensure string fits in path buffer
    if (lstrlenW(pwszExt) >= MAX_PATH-1)
        return E_INVALIDARG;
    
    lstrcpyW(wszExtLower, pwszExt);
    CharLowerW(wszExtLower);

    // look for the classid in the table.
    DWORD iHash = _HashTbl.Hash(wszExtLower);

    LOCK(gTblLck);

    SExtEntry *pExtEntry = (SExtEntry *) _HashTbl.Lookup(iHash, wszExtLower);

    if (pExtEntry == NULL)
    {
	// no entry exists for this extension, add one.

	hr = wRegGetClassExt(wszExtLower, pclsid);

	if (SUCCEEDED(hr))
	{
	    hr = AddEntry(*pclsid, wszExtLower, iHash);
	}
    }
    else
    {
        // found an entry, return the clsid
        *pclsid = pExtEntry->m_clsid;
    }

    UNLOCK(gTblLck);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::AddEntry, private
//
//  Synopsis:   allocates and entry, fills in the values, and adds it
//              to the hash table.
//
//  History:    26-Sep-96   t-KevinH      Created
//
//--------------------------------------------------------------------
HRESULT CProcessExtensionTbl::AddEntry(REFCLSID rclsid,
				       LPCWSTR pwszExt,
				       DWORD iHash)
{
    SExtEntry *pExtEntry = (SExtEntry *) _palloc.AllocEntry();

    if (pExtEntry)
    {
        pExtEntry->m_clsid = rclsid;
        
        ULONG ulExtLength = lstrlenW(pwszExt);
        if (EXT_BUFSIZE <= ulExtLength)
        {
            pExtEntry->m_wszExt = (WCHAR *)PrivMemAlloc((ulExtLength + 1) * sizeof(WCHAR));
            if (pExtEntry->m_wszExt == NULL)
                return E_OUTOFMEMORY;
        }
        else
        {
            pExtEntry->m_wszExt = pExtEntry->m_wszBuf;
        }
        lstrcpyW(pExtEntry->m_wszExt, pwszExt);
        
        // add to the hash table
        _HashTbl.Add(iHash, pExtEntry->m_wszExt, &pExtEntry->m_node);
        
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\ole1guid.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    Ole1Guid.cpp

Abstract:

    This module converts 1.0 class names to GUIDs (CLSIDs).
    See the ole2issues database (bug 318) for a description of this
    whole mechanism.

Author:

    Jason Fuller    (jasonful)  19-October-1992
*/

// ErikGav 31-Dec-93  Chicago port

#include <ole2int.h>

// CLSID_* declarations
#include <ole1cls.h>

#define STR_MAX 80
ASSERTDATA

typedef unsigned short HASH;

typedef struct ENTRY
{
    LPCWSTR  sz;        // class name
    const CLSID FAR* pclsid;    // corresponding CLSID
} ENTRY;


// This is the map.
// The +6 removes "CLSID_"
// It does unnatural things with the pre-processor, but it ensures that
// the map and ole1cls.h will always be in sync.

// REVIEW OPTIMIZATION
// If it is a problem that the strings in this map are in the data segment,
// we can use yet more pre-processor tricks to define a code-segment LPCSTR
// variable for each string, then put these variables in the map.

static ENTRY rgentMap[] =
{
    #define DEFINE_OLE1GUID(clsid,x,xx,xxx,sz) sz, &clsid, /##/
    #include "ole1cls.h"
    #undef DEFINE_OLE1GUID

    NULL, NULL

};



#pragma SEG(VerifyIs10Class)
// verify name is ole1class; errors: CO_E_CLASSSTRING
static INTERNAL VerifyIs10Class(LPCWSTR szOle1)
{
    HKEY hkey = NULL;   
    HKEY hkey2 = NULL;  
    HRESULT hresult = NOERROR;

    if (ERROR_SUCCESS != OpenClassesRootKey ((LPWSTR) szOle1, &hkey) ||
        ERROR_SUCCESS != RegOpenKeyEx (hkey, L"protocol\\StdFileEditing", 0, KEY_READ, &hkey2))
    {
        // This string is not an OLE 1 server, so we do not know
        // what it is.
        hresult = ReportResult (0, CO_E_CLASSSTRING, 0, 0);
    }
    if (hkey)
        RegCloseKey (hkey);
    if (hkey2)
        RegCloseKey (hkey2);
    return hresult;
}



#pragma SEG(Hash)
// hash ole1 class name; errors: none
static INTERNAL_(HASH) Hash(LPCWSTR sz)
{
    HASH hash = 0;
    Assert (sizeof (HASH) == 2);  // This is vital

    while (*sz)
        hash = 257 * hash + *sz++;

    return hash;
}



#define RegCall(f)                                              \
    if ((f) != ERROR_SUCCESS)                                   \
    {                                                           \
        CairoleDebugOut((DEB_WARN,                              \
                         "WriteToRegDb: 2.0 registration failed\n")); \
        if (hkey) RegCloseKey (hkey);                           \
        return ResultFromScode (REGDB_E_WRITEREGDB);            \
    }

#pragma SEG(WriteToRegDb)
// errors: REGDB_E_WRITEREGDB
static INTERNAL WriteToRegDb
    (LPCWSTR szOle1,      // OLE1 class name e.g. "ExcelWorksheet"
    LPCWSTR szClsid)      // "{...0046}"
{
    WCHAR szKey [256];
    WCHAR szUserName [256];
    LONG cbUserName = 256;
    HKEY hkey=NULL;

    Assert (szClsid[0] == '{');
    Assert (szOle1 [0] != '{');

    // szOle1 = User type Name
    //      clsid = {...0046}        <- write this
    RegCall (OpenClassesRootKey ((LPWSTR) szOle1, &hkey))
    RegCall (RegQueryValue (hkey, NULL, szUserName, &cbUserName))
    RegCall (RegSetValue (hkey, L"Clsid", REG_SZ, (LPWSTR) szClsid, lstrlenW(szClsid)))

    if (0==lstrcmpW(szClsid, L"{00030003-0000-0000-C000-000000000046}"))
    {
        // Word
        RegSetValue (hkey, L"PackageOnFileDrop", REG_SZ, (LPWSTR)NULL, 0);
    }

    RegCall (RegCloseKey (hkey))
    hkey=NULL;

    // write this:
    // CLSID
    //      {...00046} = User Type Name
    //              Ole1Class = szOle1
    //              ProgID    = szOle1
    wsprintf (szKey, L"CLSID\\%ws", szClsid);
    RegCall (SetClassesRootValue ((LPWSTR) szKey, REG_SZ, szUserName,
                        (cbUserName/sizeof(WCHAR))-1))
    RegCall (OpenClassesRootKey ((LPWSTR) szKey, &hkey))
    RegCall (RegSetValue (hkey, L"Ole1Class", REG_SZ, (LPWSTR) szOle1, lstrlenW(szOle1)))
    RegCall (RegSetValue (hkey, L"ProgID", REG_SZ, (LPWSTR) szOle1, lstrlenW(szOle1)))
    RegCall (RegCloseKey (hkey))
    return NOERROR;
}

#undef RegCall

#pragma SEG(Ole10_CLSIDFromString)

// Ole10_CLSIDFromString
//
// This function must only be called when the CLSID is NOT in the reg db
// (under key "Clsid")
//
// errors: CO_E_CLASSSTRING (not ole1 class); REGDB_E_WRITEREGDB (errors with reg.dat)
//
INTERNAL    Ole10_CLSIDFromString
    (LPCWSTR szOle1,
    CLSID FAR* pclsid,
    BOOL    fForceAssign) // always assign a CLSID, even if not in reg db
{
    WCHAR szClsid[STR_MAX];
    ENTRY FAR* pent;

    *pclsid = CLSID_NULL;

    #ifdef _DEBUG
    {
        // This function should not be called if the CLSID is in the reg db
        HKEY hkey, hkey2;
        if (ERROR_SUCCESS==OpenClassesRootKey (szOle1, &hkey))
        {
            if (ERROR_SUCCESS == RegOpenKeyEx (hkey, L"Clsid", 0, KEY_READ, &hkey2))
            {
                Assert (0);
                RegCloseKey (hkey2);
            }
            RegCloseKey (hkey);
        }
    }
    #endif

    // Look for class name in Map
    for (pent = (ENTRY FAR*) rgentMap; pent->sz != NULL; pent++)
    {
        // Because atoms and reg db keys are case-insensitive, OLE 1.0
        // was case insensitive.  So let's be case-insensitive also.
        if (0==lstrcmpiW(szOle1, pent->sz))
        {
            *pclsid = *pent->pclsid;
            Verify(StringFromCLSID2 (*pent->pclsid, szClsid, STR_MAX) != 0);
            break;
        }
    }
            
    if (IsEqualGUID(*pclsid, CLSID_NULL))
    {
        HRESULT hresult;

        if (!fForceAssign &&
            (NOERROR != (hresult = VerifyIs10Class (szOle1))))
        {
            // This happens when trying to get a CLSID for a packaged
            // object, e.g., trying to get a CLSID for "txtfile"
            // because someone called GetClassFile("foo.txt").
            // So do not assert
            return hresult;
        }

        
        // Class name is not in our table, so make up a GUID by hashing
        HASH hash = Hash (szOle1);
        wsprintf (szClsid, L"{0004%02X%02X-0000-0000-C000-000000000046}",
                  LOBYTE(hash), HIBYTE(hash));
        Verify(CLSIDFromString (szClsid, pclsid) == NOERROR);
    }

        Assert((!IsEqualGUID(*pclsid, CLSID_NULL)) &&
               "About to write NULL GUID into registry");

    HRESULT hresult = WriteToRegDb (szOle1, szClsid);
    // If forcing the assignment of a CLSID even if the string
    // is not in the reg db, then WriteToRegDb is allowed to fail.
    return fForceAssign ? NOERROR : hresult;
}

#pragma SEG(Ole10_StringFromCLSID)

// Ole10_StringFromCLSID
//
// Only call this function if the "Ole1Class" key is NOT yet in the reg db
//
// errors: E_UNEXPECTED (clsid not a known ole1 class)
//
INTERNAL Ole10_StringFromCLSID(
    REFCLSID clsid,
    LPWSTR szOut,
    int cbMax)
{
    ENTRY FAR* pent;
    LPWSTR szClsid = NULL;

    // Look it up in Map
    for (pent = (ENTRY FAR*) rgentMap; pent->sz != NULL; pent++)
    {
        if (IsEqualGUID(clsid, *pent->pclsid))
        {
            if (lstrlenW (pent->sz) +1 > cbMax)
            {
                // unlikely
                return E_OUTOFMEMORY;
            }
            lstrcpyW (szOut, pent->sz);
            
            if (NOERROR==StringFromCLSID (clsid, &szClsid))
            {
                // If the info had already been in the reg db, then
                // this function wouldn't have been called.  So write
                // the info now.  This happens when we a 1.0 object (and CLSID)
                // in a 2.0 file comes from a machine where the server is
                // registered to one where it is not.
                WriteToRegDb (pent->sz, szClsid);
                PubMemFree(szClsid);
            }
            return NOERROR;
        }
    }

    // We could not find the CLSID.
    // We could iterate through the reg db and assign CLSIDs to all 1.0
    // servers that do not yet have a CLSID, until we find one that matches.
    // We decided it is not worth doing this because if the server
    // was in the reg db, it probably would have been assigned a CLSID
    // already.
    // If not found, it is a hashed CLSID for a server that
    // is not in our map and has not been assigned a CLSID (perhaps
    // because it does not exist on this machine).
    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\memapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows:
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       MemAPI.CXX
//
//  Contents:   Memory allocation routines and IMallocSpy support
//
//  Classes:    CRetailMalloc
//              CSpyMalloc
//
//  Functions:  CoGetMalloc
//              CoRegisterMallocSpy
//              CoRevokeMallocSpy
//              CoTaskMemAlloc
//              CoTaskMemFree
//              MIDL_user_allocate
//              MIDL_user_free
//
//  History:
//      04-Nov-93 AlexT     Created
//      25-Jan-94 AlexT     Add CTaskMemory
//      25-Jan-94 alexgo    added PubMemRealloc
//      08-Feb-94 AlexT     Fix MIPS alignment
//      24-Oct-94 BruceMa   Add API's CoRegisterMallocSpy and
//                          CoRevokeMallocSpy, and support for
//                          IMallocSpy
//      01-Nov-94 BruceMa   Improve performance of retail IMalloc
//      27-Sep-95 ShannonC  Rewrote in C to improve performance.
//
//  Notes:
//    OLE implements IMalloc using a single, static instance of CMalloc.
//    CoGetMalloc always returns the same IMalloc pointer.  When necessary,
//    OLE can change the behavior of CMalloc by changing the lpVtbl.
//
//    The CMalloc object has two interchangeable vtables.  Normally,
//    the CMalloc object uses the CRetailMallocVtbl.  If an IMallocSpy is 
//    registered, OLE will switch to the CSpyMallocVtbl in order to add 
//    IMallocSpy support. Note that we will not change vtables when the 
//    IMallocSpy is revoked.  Once OLE switches to the CSpyMallocVtbl, it 
//    can never change back.
//
//--------------------------------------------------------------------------
#include <ole2int.h>
#include <memapi.hxx>
#include "cspytbl.hxx"

//+-------------------------------------------------------------------------
//
//  Class:          CMalloc
//
//  Purpose:    Base class for OLE memory allocators.
//
//  Interface:  IMalloc
//
//  See Also:   CRetailMalloc, CSpyMalloc
//
//--------------------------------------------------------------------------
HRESULT __stdcall CMalloc_QueryInterface(IMalloc * pThis,
                                         REFIID riid,
                                         void **ppvObject);

ULONG   __stdcall CMalloc_AddRef(IMalloc * pThis);

ULONG   __stdcall CMalloc_Release(IMalloc * pThis);

typedef struct IMallocVtbl
{
    HRESULT ( __stdcall *QueryInterface )(IMalloc * pThis,
                                          REFIID riid,
                                          void ** ppvObject);

    ULONG ( __stdcall *AddRef )(IMalloc * pThis);

    ULONG ( __stdcall *Release )(IMalloc * pThis);

    void *( __stdcall *Alloc )(IMalloc * pThis, SIZE_T cb);

    void *( __stdcall *Realloc )(IMalloc * pThis, void *pv, SIZE_T cb);

    void ( __stdcall *Free )(IMalloc * pThis, void *pv);

    SIZE_T ( __stdcall *GetSize )(IMalloc * pThis, void *pv);

    int ( __stdcall *DidAlloc )(IMalloc * pThis, void *pv);

    void ( __stdcall *HeapMinimize )(IMalloc * pThis);

} IMallocVtbl;

typedef struct CMalloc
{
    IMallocVtbl *lpVtbl;
} CMalloc;

//Global variables

//g_lpVtblMalloc points to CDebugMallocVtbl or CRetailMallocVtbl.
IMallocVtbl *   g_lpVtblMalloc = 0;

//WARNING: g_CMalloc.lpVtbl may change at runtime.
//Initially, g_CMalloc.lpVtbl points to either
//CDebugMallocVtbl or CRetailMallocVtbl.  When an IMallocSpy is
//registered, g_CMalloc.lpVtbl changes so it points to CSpyMallocVtbl.
CMalloc         g_CMalloc;
IMalloc *       g_pMalloc = (IMalloc *) &g_CMalloc;

//+-------------------------------------------------------------------------
//
//  Class:      CRetailMalloc
//
//  Purpose:    OLE retail memory allocator.  This memory allocator uses
//              the NT heap.
//
//  Interface:  IMalloc
//
//--------------------------------------------------------------------------

//Function prototypes.
void *  __stdcall CRetailMalloc_Alloc(IMalloc *pThis, SIZE_T cb);

void *  __stdcall CRetailMalloc_Realloc(IMalloc *pThis, void *pv, SIZE_T cb);

void    __stdcall CRetailMalloc_Free(IMalloc *pThis, void *pv);

SIZE_T   __stdcall CRetailMalloc_GetSize(IMalloc *pThis, void *pv);

int     __stdcall CRetailMalloc_DidAlloc(IMalloc *pThis, void *pv);

void    __stdcall CRetailMalloc_HeapMinimize(IMalloc *pThis);

// Makes serialized heap access obvious
const DWORD HEAP_SERIALIZE = 0;

//CRetailMalloc vtbl.
IMallocVtbl CRetailMallocVtbl =
{
    CMalloc_QueryInterface,
    CMalloc_AddRef,
    CMalloc_Release,
    CRetailMalloc_Alloc,
    CRetailMalloc_Realloc,
    CRetailMalloc_Free,
    CRetailMalloc_GetSize,
    CRetailMalloc_DidAlloc,
    CRetailMalloc_HeapMinimize
};

//+-------------------------------------------------------------------------
//
//  Class:      CSpyMalloc
//
//  Purpose:    OLE spy memory allocator.
//
//  Interface:  IMalloc
//
//--------------------------------------------------------------------------

//function prototypes.
void *  __stdcall CSpyMalloc_Alloc(IMalloc *pThis, SIZE_T cb);

void *  __stdcall CSpyMalloc_Realloc(IMalloc *pThis, void *pv, SIZE_T cb);

void    __stdcall CSpyMalloc_Free(IMalloc *pThis, void *pv);

SIZE_T __stdcall CSpyMalloc_GetSize(IMalloc *pThis, void *pv);

int     __stdcall CSpyMalloc_DidAlloc(IMalloc *pThis, void *pv);

void    __stdcall CSpyMalloc_HeapMinimize(IMalloc *pThis);

//CSpyMalloc vtbl.
IMallocVtbl CSpyMallocVtbl =
{
    CMalloc_QueryInterface,
    CMalloc_AddRef,
    CMalloc_Release,
    CSpyMalloc_Alloc,
    CSpyMalloc_Realloc,
    CSpyMalloc_Free,
    CSpyMalloc_GetSize,
    CSpyMalloc_DidAlloc,
    CSpyMalloc_HeapMinimize
};

// Globals for the IMallocSpy code
//
// IMallocSpy instance supplied by the user
LPMALLOCSPY      g_pMallocSpy = NULL;

// The thread id (via CoGetCurrentProcess) which registered the IMallocSpy
DWORD            g_dwMallocSpyRegistrationTID = 0;

// Semaphore used while spying
COleStaticMutexSem g_SpySem;

// Indicates whether a revoke was attempted with allocation count > 0
BOOL             g_fRevokePending = FALSE;

// Table of IMallocSpy allocations not yet freed
LPSPYTABLE       g_pAllocTbl = NULL;





//+-------------------------------------------------------------------------
//
//  Function:   MallocInitialize
//
//  Synopsis:   Initializes the memory allocator.
//
//--------------------------------------------------------------------------
HRESULT MallocInitialize(void)
{
    HRESULT hr = S_OK;

    g_hHeap = GetProcessHeap();

    if(0 == g_hHeap)
    {
        return E_OUTOFMEMORY;
    }

    //Use the OLE retail memory allocator.
    g_lpVtblMalloc = &CRetailMallocVtbl;

    g_CMalloc.lpVtbl = g_lpVtblMalloc;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   MallocUninitialize
//
//  Synopsis:   Clean up and check for local memory leaks
//
//  Effects:    Prints out messages on debug terminal if there are leaks
//
//  Returns:    If no leaks, TRUE
//              Otherwise, FALSE
//
//--------------------------------------------------------------------------
BOOL MallocUninitialize(void)
{
    VDATEHEAP();

    return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Function:   CoGetMalloc
//
//  Synopsis:   returns system provided IMalloc
//
//  Arguments:  [dwContext] - type of allocator to return
//              [ppMalloc] - where to return the allocator
//
//--------------------------------------------------------------------------
STDAPI CoGetMalloc(DWORD dwContext, IMalloc **ppMalloc)
{
    HRESULT hr;

    switch (dwContext)
    {
    case MEMCTX_TASK:
        //We use a static IMalloc object so
        //we don't need to AddRef it here.
        *ppMalloc = g_pMalloc;
        hr = S_OK;
        break;

    case MEMCTX_SHARED:
        CairoleDebugOut((DEB_WARN, "CoGetMalloc(MEMCTX_SHARED, ...) not "
                         "supported for 32-bit OLE\n"));

        //  fall through to E_INVALIDARG
    default:
        *ppMalloc = NULL;
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------
//
//  Function:   CoRegisterMallocSpy
//
//  Synopsis:   Registers the supplied implementation instance of
//              IMallocSpy
//
//  Arguments:  [pMallocSpy]
//
//  Returns:    CO_E_OBJISREG   -       A spy is already registered
//              E_INVALIDARG    -       The QueryInterface for
//                                      IID_IMallocSpy failed
//              S_OK            -       Spy registered ok
//
//----------------------------------------------------------------------
STDAPI CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy)
{
    HRESULT     hr = S_OK;

    OLETRACEIN((API_CoRegisterMallocSpy, PARAMFMT("pMallocSpy = %p"), pMallocSpy));

    if(pMallocSpy != 0)
    {
        LPMALLOCSPY pMSpy;

        hr = pMallocSpy->QueryInterface(IID_IMallocSpy, (void **) &pMSpy);

        if(SUCCEEDED(hr))
        {
            LOCK (g_SpySem);

            if (0 == g_pMallocSpy)
            {
                BOOL fOk = FALSE;

                // Initialize
                g_fRevokePending = FALSE;
                if (g_pAllocTbl)
                {
                    delete g_pAllocTbl;
                }

                g_pAllocTbl = new CSpyTable(&fOk);

                if (g_pAllocTbl && fOk)
                {
                    // Register the new one
                    CairoleDebugOut((DEB_TRACE, "IMallocSpy registered: %x\n", pMSpy));
                    g_pMallocSpy = pMSpy;
                    g_dwMallocSpyRegistrationTID = CoGetCurrentProcess();

                    //Switch the IMalloc lpVtbl to CSpyMallocVtbl.
                    g_CMalloc.lpVtbl = &CSpyMallocVtbl;

                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // An IMallocSpy is already registered. Deny this registration.
                CairoleDebugOut((DEB_ERROR, "Registering IMallocSpy %x over %x\n",
                                 pMallocSpy, g_pMallocSpy));

                hr = CO_E_OBJISREG;
            }

            if(FAILED(hr))
            {
                pMSpy->Release();
            }

            UNLOCK (g_SpySem);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    OLETRACEOUT((API_CoRegisterMallocSpy, hr));

    return hr;
}


//+---------------------------------------------------------------------
//
//  Function:   CoRevokeMallocSpy
//
//  Synopsis:   Revokes any registered IMallocSpy instance
//
//  Returns:    CO_E_OBJNOTREG  -       No spy is currently registered
//              E_ACCESSDENIED  -       A spy is registered but there are
//                                      outstanding allocations done while
//                                      the spy was active which have not
//                                      yet been freed
//              S_OK            -       Spy revoked successfully
//
//----------------------------------------------------------------------
STDAPI CoRevokeMallocSpy(void)
{
    HRESULT hr = S_OK;

    OLETRACEIN((API_CoRevokeMallocSpy, NOPARAM));

    // Make revoking thread safe
    LOCK (g_SpySem);

    // Check that an IMallocSpy instance is registered
    if (g_pMallocSpy != 0)
    {
        if (0 == g_pAllocTbl->m_cAllocations)
        {
            // Attempt to release it
            CairoleDebugOut((DEB_TRACE, "IMallocSpy revoked: %x\n", g_pMallocSpy));
            g_pMallocSpy->Release();
            g_pMallocSpy = NULL;
            g_fRevokePending = FALSE;
            delete g_pAllocTbl;
            g_pAllocTbl = NULL;
            g_dwMallocSpyRegistrationTID = 0;
            hr = S_OK;
        }
        else
        {
            // If there are still outstanding Alloc/Realloc's which have not yet
            // been Free'd, then deny the revoke
            g_fRevokePending = TRUE;
            hr = E_ACCESSDENIED;
        }
    }
    else
    {
        CairoleDebugOut((DEB_WARN, "Attempt to revoke NULL IMallocSpy\n"));
        hr = CO_E_OBJNOTREG;
    }

    UNLOCK (g_SpySem);

    OLETRACEOUT((API_CoRevokeMallocSpy, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoTaskMemAlloc
//
//  Synopsis:   Allocate public memory (using task IMalloc)
//
//  Arguments:  [ulcb] -- memory block size
//
//  Returns:    Pointer to allocated memory or NULL
//
//--------------------------------------------------------------------------
STDAPI_(LPVOID) CoTaskMemAlloc(SIZE_T stcb)
{
    return g_pMalloc->Alloc(stcb);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoTaskMemFree
//
//  Synopsis:   Free public memory
//
//  Arguments:  [pv] -- pointer to memory block
//
//  Requires:   pv must have been allocated with the task allocator
//
//--------------------------------------------------------------------------
STDAPI_(void) CoTaskMemFree(void *pv)
{
        g_pMalloc->Free(pv);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoTaskMemRealloc
//
//  Synopsis:   Re-Allocate public memory (using task IMalloc)
//
//  Arguments:  [pv]   -- pointer to the memory to be resized
//              [ulcb] -- memory block size
//
//  Returns:    Pointer to allocated memory or NULL
//
//--------------------------------------------------------------------------
STDAPI_(LPVOID) CoTaskMemRealloc(LPVOID pv, SIZE_T stcb)
{
    return g_pMalloc->Realloc(pv, stcb);
}

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Purpose:    allocates memory on behalf of midl-generated stubs
//
//--------------------------------------------------------------------------
extern "C" void * __RPC_API MIDL_user_allocate(size_t cb)
{
    return PrivMemAlloc8(cb);
}

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Purpose:    frees memory allocated by MIDL_user_allocate
//
//--------------------------------------------------------------------------
extern "C" void __RPC_API MIDL_user_free(void *pv)
{
    PrivMemFree8(pv);
}


//-------------------------------------------------------------------------
//
// On Chicago, heap allocations don't happen on 8 byte boundaries.  This
// causes a problem for RPC marshalling/unmarshalling.  If OLE code were
// consistent and used complementary routines for allocating and freeeing
// we would only have to change PrivMemAlloc8 and PrivMemFree8.  But since
// this is not the case, we have to change PrivMemAlloc and PrivMemFree.
//
// These Inline functions guarantee allocations are 8-byte aligned on all
// platforms.
//
//-------------------------------------------------------------------------

// compute number of extra bytes to allocate
inline SIZE_T PreAlign8(SIZE_T stcb)
{
    return stcb;
}

// modify the pointer so it is 8byte aligned
inline LPVOID PostAlign8(LPVOID pv)
{
    return pv;
}

// return the original allocated pointer
inline LPVOID Unalign8(LPVOID pv)
{
    return pv;
}

// return the number of padding bytes
inline SIZE_T Align8Pad(LPVOID pv)
{
    return 0;
}

// Called in place of PostAlign8 when doing a ReAlloc. ReAligns the data
// if necessary.
inline LPVOID Realign8(LPVOID pv, SIZE_T stOriginalPad, SIZE_T cbData)
{
    return pv;
}


//+-------------------------------------------------------------------------
//
//  Function:   CMalloc_QueryInterface
//
//  Synopsis:   QueryInterface on the memory allocator.
//
//  Arguments:  riid - Supplies the IID.
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT __stdcall CMalloc_QueryInterface(IMalloc * pThis,
                                         REFIID riid,
                                         void **ppvObject)
{
    HRESULT hr;

    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,IID_IMalloc))
    {
        //We use a static IMalloc object so
        //we don't need to AddRef it here.
        *ppvObject = pThis;
        hr = S_OK;
    }
    else
    {
        *ppvObject = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CMalloc_AddRef
//
//  Synopsis:   AddRef the memory allocator.
//
//--------------------------------------------------------------------------
ULONG   __stdcall CMalloc_AddRef(IMalloc * pThis)
{
    //We use a static IMalloc object so
    //we don't need to AddRef it here.
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Function:   CMalloc_Release
//
//  Synopsis:   Release the memory allocator.
//
//--------------------------------------------------------------------------
ULONG   __stdcall CMalloc_Release(IMalloc * pThis)
{
    //We use a static IMalloc object so
    //we don't need to Release it here.
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Alloc
//
//  Synopsis:   Allocate a block of memory.
//
//  Arguments:  [cb] -- Specifies the size of the memory block to allocate.
//
//  Returns:    Pointer to allocated memory or NULL
//
//--------------------------------------------------------------------------
void * __stdcall CRetailMalloc_Alloc(IMalloc *pThis, SIZE_T cb)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    return PostAlign8((LPVOID) HeapAlloc(g_hHeap, HEAP_SERIALIZE, PreAlign8(cb)));
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_DidAlloc
//
//  Synopsis:   Determine if the memory block was allocated by this
//              memory allocator.
//
//  Arguments:  [pv] -- pointer to the memory block
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
int __stdcall CRetailMalloc_DidAlloc(IMalloc *pThis, void * pv)
{
    int fDidAlloc = -1;

    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (pv != 0)
    {
        fDidAlloc = HeapValidate(g_hHeap, HEAP_SERIALIZE, Unalign8(pv));
    }

    return fDidAlloc;
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Free
//
//  Synopsis:   Free a memory block previously allocated via CRetailMalloc_Alloc.
//
//  Arguments:  [pv] -- pointer to the memory block to be freed.
//
//--------------------------------------------------------------------------
void __stdcall CRetailMalloc_Free(IMalloc *pThis, void * pv)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (pv != 0)
    {
        HeapFree(g_hHeap, HEAP_SERIALIZE, Unalign8(pv));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_GetSize
//
//  Synopsis:   Gets the size of a memory block.
//
//  Arguments:  [pv] -- pointer to the memory block
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
SIZE_T __stdcall CRetailMalloc_GetSize(IMalloc * pThis, void * pv)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (0 == pv)
    {
        return((SIZE_T) -1);
    }
    return ((SIZE_T)(HeapSize(g_hHeap, HEAP_SERIALIZE, Unalign8(pv)) - Align8Pad(pv)));
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Minimize
//
//  Synopsis:   Compact the heap.
//
//--------------------------------------------------------------------------
void __stdcall CRetailMalloc_HeapMinimize(IMalloc * pThis)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    // Compact the heap
    HeapCompact(g_hHeap, HEAP_SERIALIZE);
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Realloc
//
//  Synopsis:   Changes the size of a memory block previously allocated
//              via CRetailMalloc_Alloc.
//
//  Arguments:  [pv] -- Points to the memory block to be reallocated.
//              [cb] -- Specifies the new size of the memory block.
//
//  Returns:    Pointer to allocated memory or NULL.
//
//--------------------------------------------------------------------------
void * __stdcall CRetailMalloc_Realloc(IMalloc *pThis, void * pv, SIZE_T cb)
{
    LPVOID pvNew = 0;

    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (pv != 0)
    {
        if (cb != 0)
        {
            int cbPad = (int) Align8Pad(pv);
            pvNew = (LPVOID) HeapReAlloc(g_hHeap, HEAP_SERIALIZE,
                                         Unalign8(pv), PreAlign8(cb));
            pvNew = Realign8(pvNew, cbPad, cb);
        }
        else
        {
            //Treat this as a free.
            HeapFree(g_hHeap, HEAP_SERIALIZE, pv);
            pvNew = 0;
        }
    }
    else
    {
        //Treat this as an alloc.
        pvNew = PostAlign8((LPVOID) HeapAlloc(g_hHeap, HEAP_SERIALIZE, PreAlign8(cb)));
    }

    return pvNew;
}

//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc::Alloc
//
//  Synopsis:   Local memory allocator
//
//  Arguments:  [cb] -- memory block size
//
//  Returns:    Pointer to new memory block.
//
//--------------------------------------------------------------------------
void * __stdcall CSpyMalloc_Alloc(IMalloc *pThis, SIZE_T cb)
{
    void *pvRet = NULL;

    LOCK (g_SpySem);

    // If an IMallocSpy is active, call the pre method
    if (g_pMallocSpy)
    {
        SIZE_T cbAlloc = g_pMallocSpy->PreAlloc(cb);

        // The pre method forces failure by returning 0
        if ((cbAlloc != 0) || (0 == cb))
        {
            // Allocate the memory
            pvRet = g_lpVtblMalloc->Alloc(pThis, cbAlloc);

            // Call the post method
            pvRet = g_pMallocSpy->PostAlloc(pvRet);

            // Update the spy table.
            if (pvRet != NULL)
            {
                g_pAllocTbl->Add(pvRet);
            }
        }
    }
    else
    {
        // Allocate the memory
        pvRet = g_lpVtblMalloc->Alloc(pThis, cb);
    }

    UNLOCK (g_SpySem);

    return pvRet;
}

//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_Realloc
//
//  Synopsis:   Reallocated local memory
//
//  Arguments:  [pv] -- original memory block
//              [cb] -- new size
//
//  Returns:    Pointer to new memory block
//
//--------------------------------------------------------------------------
void *CSpyMalloc_Realloc(IMalloc *pThis, void * pv, SIZE_T cb)
{
    void *pvNew = 0;

    if(pv != 0)
    {
        if(cb != 0)
        {
            LOCK (g_SpySem);

            // If an IMallocSpy is active, call the pre method
            if (g_pMallocSpy != 0)
            {
                void *pvTemp = 0;
                ULONG j = 0;
                BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
                SIZE_T cbAlloc = g_pMallocSpy->PreRealloc(pv, cb, &pvTemp, fSpyed);

                // The pre method forces failure by returning 0
                if (cbAlloc != 0)
                {
                    //Reallocate the memory
                    pvTemp = g_lpVtblMalloc->Realloc(pThis, pvTemp, cbAlloc);

                    // Call the post method
                    pvNew = g_pMallocSpy->PostRealloc(pvTemp, fSpyed);

                    // Update the spy table.
                    if (pvNew != 0)
                    {
                        if (fSpyed)
                        {
                            g_pAllocTbl->Remove(pv);
                        }

                        g_pAllocTbl->Add(pvNew);
                    }
                }
            }
            else
            {
                //Reallocate the memory.
                pvNew = g_lpVtblMalloc->Realloc(pThis, pv, cb);
            }

            UNLOCK (g_SpySem);
        }
        else
        {
            //Treat this as a Free.
            pThis->Free(pv);
        }
    }
    else
    {
        //Treat this as an Alloc.
        pvNew = pThis->Alloc(cb);
    }

    return pvNew;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSpyMalloc_Free
//
//  Synopsis:   release local memory
//
//  Arguments:  [pv] -- memory address
//
//--------------------------------------------------------------------------
void __stdcall CSpyMalloc_Free(IMalloc *pThis, void * pv)
{
    if(pv != 0)
    {
        LOCK (g_SpySem);

        // If an IMallocSpy is active, call the pre method
        if (g_pMallocSpy)
        {
            ULONG j;
            BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
            void *pvNew = g_pMallocSpy->PreFree(pv, fSpyed);

            // Free the buffer
            g_lpVtblMalloc->Free(pThis, pvNew);

            // If an IMallocSpy is active, call the post method
            g_pMallocSpy->PostFree(fSpyed);

            // Update the spy table.
            if (fSpyed)
            {
                g_pAllocTbl->Remove(pv);
            }

            if (g_pAllocTbl->m_cAllocations == 0  &&  g_fRevokePending)
            {
                CoRevokeMallocSpy();
            }
        }
        else
        {
            // Free the buffer
            g_lpVtblMalloc->Free(pThis, pv);
        }

        UNLOCK (g_SpySem);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_GetSize
//
//  Synopsis:   Return size of memory block
//
//  Arguments:  [pv] -- memory address
//
//  Returns:    If valid memory, the size of the block
//              Otherwise, 0
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
SIZE_T __stdcall CSpyMalloc_GetSize(IMalloc *pThis, void * pv)
{
    SIZE_T ulSize = (ULONG) -1;

    if (pv != 0)
    {
        LOCK (g_SpySem);

        // If an IMallocSpy is active, call the pre method
        if (g_pMallocSpy)
        {
            ULONG j;
            BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
            void *pvNew = g_pMallocSpy->PreGetSize(pv, fSpyed);

            // Fetch the size of the allocation
            ulSize = g_lpVtblMalloc->GetSize(pThis, pvNew);

            // Call the post method
            ulSize = g_pMallocSpy->PostGetSize(ulSize, fSpyed);
        }
        else
        {
            // Fetch the size of the allocation
            ulSize = g_lpVtblMalloc->GetSize(pThis, pv);
        }

        UNLOCK (g_SpySem);
    }

    return ulSize;
}


//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_DidAlloc
//
//  Synopsis:   Return whether this allocator allocated the block
//
//  Arguments:  [pv] -- memory address
//
//  Returns:    If allocated by this allocator, TRUE
//              Otherwise, FALSE
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
int __stdcall CSpyMalloc_DidAlloc(IMalloc *pThis, void * pv)
{
    int   fDidAlloc = (ULONG) -1;

    if (pv != 0)
    {
        LOCK (g_SpySem);

        // If an IMallocSpy is active, call the pre method
        if (g_pMallocSpy)
        {
            ULONG j;
            BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
            void *pvNew = g_pMallocSpy->PreDidAlloc(pv, fSpyed);

            // Check the allocation
            fDidAlloc = g_lpVtblMalloc->DidAlloc(pThis, pvNew);

            // Call the post method
            fDidAlloc = g_pMallocSpy->PostDidAlloc(pv, fSpyed, fDidAlloc);
        }
        else
        {
            // Check the allocation
            fDidAlloc = g_lpVtblMalloc->DidAlloc(pThis, pv);
        }

        UNLOCK (g_SpySem);
    }

    return fDidAlloc;
}



//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_HeapMinimize
//
//  Synopsis:   Minimize heap
//
//--------------------------------------------------------------------------
void __stdcall CSpyMalloc_HeapMinimize(IMalloc *pThis)
{
    LOCK (g_SpySem);

    // If an IMallocSpy is active, call the pre method
    if (g_pMallocSpy)
    {
        g_pMallocSpy->PreHeapMinimize();

        // Compact the heap
        g_lpVtblMalloc->HeapMinimize(pThis);

        // Call the post method
        g_pMallocSpy->PostHeapMinimize();
    }
    else
    {
        // Compact the heap
        g_lpVtblMalloc->HeapMinimize(pThis);
    }

    UNLOCK (g_SpySem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\privoa.cxx ===
//+============================================================================
//
//  File:   PrivOA.cxx
//
//  This file provides private wrapper routines for the OleAut32.dll
//  exports which are called from ole32.dll.  We don't want to link 
//  ole32 directly to oleaut32 for performance reasons.  So, for
//  each export, there is a corresponding function pointer and
//  "Load" routine.
//
//  For example, pfnSysAllocString initially points to LoadSysAllocString.
//  The first time it is called, the Load routine loads oleaut32 (if
//  necessary), does a GetProcAddr on "SysAllocString", puts
//  pointer into pfnSysAllocString, then makes the call.  All subsequent
//  calls to pfnSysAllocString thus go straight to oleaut32.
//
//+============================================================================



#include <ole2int.h>
#include <oleauto.h>
#include <privoa.h>     // PrivSys* routines

SYS_ALLOC_STRING       *pfnSysAllocString      = LoadSysAllocString;
SYS_FREE_STRING        *pfnSysFreeString       = LoadSysFreeString;
SYS_REALLOC_STRING_LEN *pfnSysReAllocStringLen = LoadSysReAllocStringLen;
SYS_STRING_BYTE_LEN    *pfnSysStringByteLen    = LoadSysStringByteLen;

SAFE_ARRAY_ACCESS_DATA      *pfnSafeArrayAccessData     = LoadSafeArrayAccessData;
SAFE_ARRAY_GET_L_BOUND      *pfnSafeArrayGetLBound      = LoadSafeArrayGetLBound;
SAFE_ARRAY_GET_DIM          *pfnSafeArrayGetDim         = LoadSafeArrayGetDim;
SAFE_ARRAY_GET_ELEM_SIZE    *pfnSafeArrayGetElemsize    = LoadSafeArrayGetElemsize;
SAFE_ARRAY_GET_U_BOUND      *pfnSafeArrayGetUBound      = LoadSafeArrayGetUBound;
SAFE_ARRAY_GET_VARTYPE      *pfnSafeArrayGetVartype     = LoadSafeArrayGetVartype;
SAFE_ARRAY_UNACCESS_DATA    *pfnSafeArrayUnaccessData   = LoadSafeArrayUnaccessData;
SAFE_ARRAY_CREATE_EX        *pfnSafeArrayCreateEx       = LoadSafeArrayCreateEx;

BSTR_USER_SIZE              *pfnBSTR_UserSize           = LoadBSTR_UserSize;
BSTR_USER_MARSHAL           *pfnBSTR_UserMarshal        = LoadBSTR_UserMarshal;
BSTR_USER_UNMARSHAL         *pfnBSTR_UserUnmarshal      = LoadBSTR_UserUnmarshal;
BSTR_USER_FREE              *pfnBSTR_UserFree           = LoadBSTR_UserFree;

LPSAFEARRAY_USER_SIZE       *pfnLPSAFEARRAY_UserSize        = LoadLPSAFEARRAY_UserSize;
LPSAFEARRAY_USER_MARSHAL    *pfnLPSAFEARRAY_UserMarshal     = LoadLPSAFEARRAY_UserMarshal;
LPSAFEARRAY_USER_UNMARSHAL  *pfnLPSAFEARRAY_UserUnmarshal   = LoadLPSAFEARRAY_UserUnmarshal;
LPSAFEARRAY_USER_FREE       *pfnLPSAFEARRAY_UserFree        = LoadLPSAFEARRAY_UserFree;




#define OLEAUT_FNPTR( fname )   FNTYPE_##fname  *pfn##fname=Load##fname;

#define LoadAut1( fname, type1 )            \
OLEAUT_FNPTR( fname );                      \
HRESULT STDAPICALLTYPE                      \
Load##fname( type1 farg1 )                  \
{                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                   \
        hr = pfn##fname( farg1 );           \
    return ( hr );                          \
}

#define LoadAut1r( retType, fname, type1 )  \
OLEAUT_FNPTR( fname );                      \
retType STDAPICALLTYPE                      \
Load##fname( type1 farg1 )                  \
{                                           \
    retType tmp=0;                          \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                   \
        tmp = pfn##fname( farg1 );          \
    return ( tmp );                         \
}

#define LoadAut1v( fname, type1 )           \
OLEAUT_FNPTR( fname );                      \
void STDAPICALLTYPE                         \
Load##fname( type1 farg1 )                  \
{                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                   \
        pfn##fname( farg1 );                \
}

#define LoadAut2( fname, type1, type2 )                     \
OLEAUT_FNPTR( fname );                                      \
HRESULT STDAPICALLTYPE                                      \
Load##fname( type1 farg1, type2 farg2 )                     \
{                                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        hr = pfn##fname( farg1, farg2 );                    \
    return ( hr );                                          \
}

#define LoadAut3( fname, type1, type2, type3 )              \
OLEAUT_FNPTR( fname );                                      \
HRESULT STDAPICALLTYPE                                      \
Load##fname( type1 farg1, type2 farg2, type3 farg3 )        \
{                                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        hr = pfn##fname( farg1, farg2, farg3 );             \
    return ( hr );                                          \
}

#define LoadAut3r( retType, fname, type1, type2, type3 )    \
OLEAUT_FNPTR( fname );                                      \
retType STDAPICALLTYPE                                      \
Load##fname( type1 farg1, type2 farg2, type3 farg3 )        \
{                                                           \
    retType tmp=0;                                          \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        tmp = pfn##fname( farg1, farg2, farg3 );            \
    return ( tmp );                                         \
}


#define LoadAut5( fname, type1, type2, type3, type4, type5 ) \
OLEAUT_FNPTR( fname );                                       \
HRESULT STDAPICALLTYPE                                       \
Load##fname( type1 farg1, type2 farg2, type3 farg3, type4 farg4, type5 farg5 )        \
{                                                            \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        hr = pfn##fname( farg1, farg2, farg3, farg4, farg5 );  \
    return ( hr );                                          \
}



//+----------------------------------------------------------------------------
//
//  Load oleaut32.dll routines
//
//  These routines are represent all the oleaut32 exports that are called
//  by ole32.dll.  Each corresponds to an oleaut32 export, and each is 
//  initially pointed to by a global pfn function ptr.  The load routine
//  loads the export into the pfn, then calls it.  Thus all future
//  calls on the pfn function pointer go directly to oleaut32.
//
//
//+----------------------------------------------------------------------------

HRESULT
LoadOleAut32Export( CHAR *szExport, void **ppfn )
{
    static HINSTANCE  hOleAut32 = NULL;
    void *pfn = NULL;

    HRESULT hr = S_OK;
    if( NULL == hOleAut32)
    {
        hOleAut32 = LoadLibraryA("oleaut32.dll");
        if( NULL == hOleAut32 )
            return( HRESULT_FROM_WIN32( GetLastError() ));
    }

    pfn = GetProcAddress(hOleAut32, szExport );
    if( NULL == pfn )
        return( HRESULT_FROM_WIN32( GetLastError() ));
    
    *ppfn = pfn;
    return( S_OK );
}

BSTR STDAPICALLTYPE
LoadSysAllocString(LPCOLESTR pwsz)
{
    BSTR bstr = NULL;

    if( SUCCEEDED(LoadOleAut32Export( "SysAllocString", reinterpret_cast<void**>(&pfnSysAllocString) )))
       bstr = pfnSysAllocString(pwsz);

    return bstr;
}

VOID STDAPICALLTYPE
LoadSysFreeString(BSTR bstr)
{
    if( SUCCEEDED(LoadOleAut32Export( "SysFreeString", reinterpret_cast<void**>(&pfnSysFreeString) )))
       pfnSysFreeString(bstr);

    return;
}

BOOL STDAPICALLTYPE
LoadSysReAllocStringLen(BSTR FAR *pbstr, OLECHAR FAR *pwsz, UINT cch)
{
    BOOL fRet = FALSE;

    if( SUCCEEDED(LoadOleAut32Export( "SysReAllocStringLen", reinterpret_cast<void**>(&pfnSysReAllocStringLen) )))
        fRet = (*pfnSysReAllocStringLen)(pbstr, pwsz, cch);

    return( fRet );
}

UINT STDAPICALLTYPE
LoadSysStringByteLen(BSTR bstr)
{
    UINT uiLen = 0;

    if( SUCCEEDED(LoadOleAut32Export( "SysStringByteLen", reinterpret_cast<void**>(&pfnSysStringByteLen) )))
       uiLen = (*pfnSysStringByteLen)(bstr);

    return( uiLen );
}

LoadAut1r( UINT, SysStringLen, BSTR );


HRESULT STDAPICALLTYPE
LoadSafeArrayAccessData( SAFEARRAY * psa, void HUGEP** ppvData )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayAccessData", reinterpret_cast<void**>(&pfnSafeArrayAccessData) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayAccessData( psa, ppvData );

    return( hr );

}

HRESULT STDAPICALLTYPE
LoadSafeArrayGetLBound( SAFEARRAY *psa, UINT nDim, LONG * plLbound )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetLBound", reinterpret_cast<void**>(&pfnSafeArrayGetLBound) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayGetLBound( psa, nDim, plLbound );

    return( hr );
}

HRESULT STDAPICALLTYPE
LoadSafeArrayGetUBound( SAFEARRAY *psa, UINT nDim, LONG * plUbound )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetUBound", reinterpret_cast<void**>(&pfnSafeArrayGetUBound) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayGetUBound( psa, nDim, plUbound );

    return( hr );
}

UINT STDAPICALLTYPE
LoadSafeArrayGetDim( SAFEARRAY *psa )
{
    UINT ui = 0;
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetDim", reinterpret_cast<void**>(&pfnSafeArrayGetDim) );
    if( SUCCEEDED(hr) )
        ui = pfnSafeArrayGetDim( psa );

    return( ui );
}


UINT STDAPICALLTYPE
LoadSafeArrayGetElemsize( SAFEARRAY * psa )
{
    HRESULT hr;
    UINT ui = 0;

    hr = LoadOleAut32Export( "SafeArrayGetElemsize", reinterpret_cast<void**>(&pfnSafeArrayGetElemsize) );
    if( SUCCEEDED(hr) )
        ui = pfnSafeArrayGetElemsize( psa );

    return( ui );
}


HRESULT STDAPICALLTYPE
LoadSafeArrayGetVartype( SAFEARRAY *psa, VARTYPE *pvt )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetVartype", reinterpret_cast<void**>(&pfnSafeArrayGetVartype) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayGetVartype( psa, pvt );

    return( hr );
}



HRESULT STDAPICALLTYPE
LoadSafeArrayUnaccessData( SAFEARRAY *psa )
{
    HRESULT hr;

    hr = LoadOleAut32Export( "SafeArrayUnaccessData", reinterpret_cast<void**>(&pfnSafeArrayUnaccessData) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayUnaccessData( psa );

    return( hr );
}


SAFEARRAY * STDAPICALLTYPE
LoadSafeArrayCreateEx( VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound, PVOID pvExtra)
{
    HRESULT hr;
    SAFEARRAY *psa = NULL;

    hr = LoadOleAut32Export( "SafeArrayCreateEx", reinterpret_cast<void**>(&pfnSafeArrayCreateEx) );
    if( SUCCEEDED(hr) )
        psa = pfnSafeArrayCreateEx( vt, cDims, rgsabound, pvExtra );

    return( psa );
}

LoadAut3r( SAFEARRAY*, SafeArrayCreate, VARTYPE, UINT, SAFEARRAYBOUND* );
LoadAut3( SafeArrayPutElement, SAFEARRAY*, long*, void* );
LoadAut1( SafeArrayDestroy, SAFEARRAY* );

LoadAut1v( VariantInit, VARIANT* );
LoadAut1( VariantClear, VARIANTARG* );
LoadAut2( VariantCopy, VARIANTARG*, VARIANTARG* );
LoadAut5( VariantChangeTypeEx, VARIANTARG *, VARIANTARG *, LCID, USHORT, VARTYPE );



// The following routines are optimized so that if they are called twice,
// they don't re-getprocaddr the pfn.  This is because oleprx32\proxy\prop_p.c
// must have a constant function pointer for its function tables.

EXTERN_C unsigned long 
LoadBSTR_UserSize( unsigned long __RPC_FAR *pul, unsigned long ul, BSTR __RPC_FAR * pbstr )
{
    HRESULT hr = S_OK;
    unsigned long ulRet = 0;

    if( LoadBSTR_UserSize == pfnBSTR_UserSize )
        hr = LoadOleAut32Export( "BSTR_UserSize", reinterpret_cast<void**>(&pfnBSTR_UserSize) );
    if( SUCCEEDED(hr) )
        ulRet = pfnBSTR_UserSize( pul, ul, pbstr );
    return( ulRet );
}


EXTERN_C unsigned char __RPC_FAR * 
LoadBSTR_UserMarshal(  unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, BSTR __RPC_FAR *pbstr )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadBSTR_UserMarshal == pfnBSTR_UserMarshal )
        hr = LoadOleAut32Export( "BSTR_UserMarshal", reinterpret_cast<void**>(&pfnBSTR_UserMarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnBSTR_UserMarshal( pul, puc, pbstr );
    return( pucRet );
}

EXTERN_C unsigned char __RPC_FAR * 
LoadBSTR_UserUnmarshal(unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, BSTR __RPC_FAR *pbstr )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadBSTR_UserUnmarshal == pfnBSTR_UserUnmarshal )
        hr = LoadOleAut32Export( "BSTR_UserUnmarshal", reinterpret_cast<void**>(&pfnBSTR_UserUnmarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnBSTR_UserUnmarshal( pul, puc, pbstr );
    return( pucRet );
}

EXTERN_C void 
LoadBSTR_UserFree( unsigned long __RPC_FAR *pul, BSTR __RPC_FAR *pbstr )
{
    HRESULT hr = S_OK;

    if( LoadBSTR_UserFree == pfnBSTR_UserFree )
        hr = LoadOleAut32Export( "BSTR_UserFree", reinterpret_cast<void**>(&pfnBSTR_UserFree) );
    if( SUCCEEDED(hr) )
        pfnBSTR_UserFree( pul, pbstr );
}

EXTERN_C unsigned long 
LoadLPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *pul, unsigned long            ul, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;
    unsigned long ulRet = 0;

    if( LoadLPSAFEARRAY_UserSize == pfnLPSAFEARRAY_UserSize )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserSize", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserSize) );
    if( SUCCEEDED(hr) )
        ulRet = pfnLPSAFEARRAY_UserSize( pul, ul, ppsa );
    return( ulRet );
}

EXTERN_C unsigned char __RPC_FAR * 
LoadLPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadLPSAFEARRAY_UserMarshal == pfnLPSAFEARRAY_UserMarshal )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserMarshal", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserMarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnLPSAFEARRAY_UserMarshal( pul, puc, ppsa );
    return( pucRet );
}

EXTERN_C unsigned char __RPC_FAR * 
LoadLPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadLPSAFEARRAY_UserUnmarshal == pfnLPSAFEARRAY_UserUnmarshal )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserUnmarshal", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserUnmarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnLPSAFEARRAY_UserUnmarshal( pul, puc, ppsa );

    return( pucRet );
}

EXTERN_C void          
LoadLPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *pul, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;

    if( LoadLPSAFEARRAY_UserFree == pfnLPSAFEARRAY_UserFree )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserFree", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserFree) );
    if( SUCCEEDED(hr) )
        pfnLPSAFEARRAY_UserFree( pul, ppsa );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   class
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\ih;..;..\..\..\common;..\..\..\actprops
INCLUDES=     $(INCLUDES);..\..\objact
INCLUDES=     $(INCLUDES);..\..\inc;..\..\moniker2;..\..\dcomrem
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O);$(DS_INC_PATH)

SOURCES=      \
            ..\cerror.cxx   \
            ..\cocrguid.cxx \
            ..\compapi.cxx  \
            ..\compobj.cxx  \
            ..\cspytbl.cxx  \
            ..\memapi.cxx   \
            ..\ole1guid.cxx \
            ..\tls.cxx      \
            ..\hkole32.cxx  \
            ..\pexttbl.cxx  \
            ..\privoa.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\coll\plex.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include <ole2int.h>
//#include <compobj.seg>
#pragma SEG(plex)

#include "plex.h"
ASSERTDATA

// Collection support
#ifdef OLE_COLL_SEG
#pragma code_seg(OLE_COLL_SEG)
#endif


#pragma SEG(CPlex_Create)  
CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, DWORD mp, UINT nMax, UINT cbElement)
{
	CairoleAssert(nMax > 0 && cbElement > 0);
	CPlex FAR* p = (CPlex FAR*)CoMemAlloc(sizeof(CPlex) + nMax * cbElement, mp, NULL);
	if (p == NULL)
		return NULL;

	p->nMax = nMax;
	p->nCur = 0;
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

#pragma SEG(CPlex_FreeDataChain)  
void CPlex::FreeDataChain(DWORD mp)     // free this one and links
{
    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
		CoMemFree(pThis, mp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\coll\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   coll
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O);
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O);
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O);
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES=    \
              $(C_DEFINES)          \


SOURCES=      \
              ..\array_fv.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\coll\array_fv.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       d:\nt\private\cairole\com\coll\array_fv.cxx
//
//  Contents:   Implementation of Array of values
//
//  Classes:    CArrayFValue
//
//  Functions:  CArrayFValue::CArrayFValue
//              CArrayFValue::~CArrayFValue
//              CArrayFValue::SetSize
//              CArrayFValue::FreeExtra
//              CArrayFValue::_GetAt
//              CArrayFValue::SetAt
//              CArrayFValue::SetAtGrow
//              CArrayFValue::InsertAt
//              CArrayFValue::RemoveAt
//              CArrayFValue::IndexOf
//              CArrayFValue::AssertValid
//
//  History:    26-Jul-94   BruceMa    Created this file header
//              26-Jul-94   BruceMa    Memory sift fix
//
//----------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly initialized elements

#include <ole2int.h>
//#include <compobj.seg>
#pragma SEG(array_fv)
ASSERTDATA

#include "valid.h"
#include "array_fv.h"

#include <limits.h>
#define SIZE_T_MAX  UINT_MAX            /* max size for a size_t */


/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CArrayFValue_ctor)
CArrayFValue::CArrayFValue(UINT cbValue)
{
	m_pData = NULL;
	m_cbValue = cbValue;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

#pragma SEG(CArrayFValue_dtor)
CArrayFValue::~CArrayFValue()
{
	ASSERT_VALID(this);

	PrivMemFree(m_pData);
}

// set new size; return FALSE if OOM

#pragma SEG(CArrayFValue_SetSize)
BOOL CArrayFValue::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
	ASSERT_VALID(this);
	Assert(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;    // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		PrivMemFree(m_pData);
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
		Assert((long)nNewSize * m_cbValue <= SIZE_T_MAX);    // no overflow

		m_pData = (BYTE FAR*)PrivMemAlloc(nNewSize * m_cbValue);
		if (m_pData == NULL)
                {
                    m_nSize = m_nMaxSize = 0;
                    return FALSE;
                }

		memset(m_pData, 0, nNewSize * m_cbValue);        // zero fill
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			memset(&m_pData[m_nSize * m_cbValue], 0, (nNewSize-m_nSize) * m_cbValue);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// Otherwise grow array
		int nNewMax;
		if (nNewSize < m_nMaxSize + m_nGrowBy)
			nNewMax = m_nMaxSize + m_nGrowBy;   // granularity
		else
			nNewMax = nNewSize; // no slush

		Assert((long)nNewMax * m_cbValue <= SIZE_T_MAX); // no overflow

		BYTE FAR* pNewData = (BYTE FAR*)PrivMemAlloc(nNewMax * m_cbValue);
		if (pNewData == NULL)
			return FALSE;

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * m_cbValue);

		// construct remaining elements
		Assert(nNewSize > m_nSize);
		memset(&pNewData[m_nSize * m_cbValue], 0, (nNewSize-m_nSize) * m_cbValue);

		// get rid of old stuff (note: no destructors called)
		PrivMemFree(m_pData);
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
	ASSERT_VALID(this);

	return TRUE;
}

#pragma SEG(CArrayFValue_FreeExtra)
void CArrayFValue::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
		Assert((long)m_nSize * m_cbValue <= SIZE_T_MAX); // no overflow

		BYTE FAR* pNewData = (BYTE FAR*)PrivMemAlloc(m_nSize * m_cbValue);
		if (pNewData == NULL)
			return;					// can't shrink; don't to anything

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * m_cbValue);

		// get rid of old stuff (note: no destructors called)
		PrivMemFree(m_pData);
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CArrayFValue__GetAt)
LPVOID CArrayFValue::_GetAt(int nIndex) const
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0 && nIndex < m_nSize);
	return &m_pData[nIndex * m_cbValue];
}

#pragma SEG(CArrayFValue_SetAt)
void CArrayFValue::SetAt(int nIndex, LPVOID pValue)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0 && nIndex < m_nSize);

	memcpy(&m_pData[nIndex * m_cbValue], pValue, m_cbValue);
}

#pragma SEG(CArrayFValue_SetAtGrow)
BOOL CArrayFValue::SetAtGrow(int nIndex, LPVOID pValue)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);
	if (nIndex >= m_nSize && !SetSize(nIndex+1))
		return FALSE;

	SetAt(nIndex, pValue);

	return TRUE;
}

#pragma SEG(CArrayFValue_InsertAt)
BOOL CArrayFValue::InsertAt(int nIndex, LPVOID pValue, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);        // will expand to meet need
	Assert(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		if (!SetSize(nIndex + nCount))       // grow so nIndex is valid
			return FALSE;
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		if (!SetSize(m_nSize + nCount)) // grow it to new size
			return FALSE;

		// shift old data up to fill gap
		memmove(&m_pData[(nIndex+nCount) * m_cbValue],
			&m_pData[nIndex * m_cbValue],
			(nOldSize-nIndex) * m_cbValue);

		// re-init slots we copied from
		memset(&m_pData[nIndex * m_cbValue], 0, nCount * m_cbValue);
	}

	// insert new value in the gap
	Assert(nIndex + nCount <= m_nSize);
	while (nCount--)
		memcpy(&m_pData[nIndex++ * m_cbValue], pValue, m_cbValue);

	ASSERT_VALID(this);

	return TRUE;
}

#pragma SEG(CArrayFValue_RemoveAt)
void CArrayFValue::RemoveAt(int nIndex, int nCount /* = 1 */)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);
	Assert(nIndex < m_nSize);
	Assert(nCount >= 0);
	Assert(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex * m_cbValue],
			&m_pData[(nIndex + nCount) * m_cbValue],
			nMoveCount * m_cbValue);
	m_nSize -= nCount;
}


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CArrayFValue_IndexOf)
// find element given part of one; offset is offset into value; returns
// -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
// will be optimized for appropriate value size and param combinations
int CArrayFValue::IndexOf(LPVOID pData, UINT cbData, UINT offset)
{
	Assert(offset <= m_cbValue);
	Assert(cbData <= m_cbValue);
	Assert((long)offset + cbData <= m_cbValue);
	Assert(IsValidReadPtrIn(pData, cbData));

#ifdef LATER
	if (cbData == sizeof(WORD) && m_cbValue == sizeof(WORD))
	{
		int iwRet;
		_asm
		{
			push di
			les di,pData			;* get value
			mov ax,es:[di]			;*    from *(WORD FAR*)pData
			les di,this
			mov cx,[di].m_nSize		;* get size (in WORDs) of array
			les di,[di].m_pData		;* get ptr to WORD array
			repne scasw				;* look for *(WORD FAR*)pData
			jeq retcx				;* brif found
			xor cx,cx				;* return -1
		retcx:
			dec cx
			mov iwRet,cx
			pop di
		}

		return iwRet;
	}
#endif
	BYTE FAR* pCompare = m_pData + offset;	// points to the value to compare
	int nIndex = 0;

	if (cbData == sizeof(WORD)) {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (*(WORD FAR*)pCompare == *(WORD FAR*)pData)
				return nIndex;
		}
	} else if (cbData == sizeof(LONG)) {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (*(LONG FAR*)pCompare == *(LONG FAR*)pData)
				return nIndex;
		}
	} else {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (memcmp(pCompare, pData, cbData) == 0)
				return nIndex;
		}
	}

	return -1;
}


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CArrayFValue_AssertValid)
void CArrayFValue::AssertValid() const
{
#ifdef _DEBUG
	if (m_pData == NULL)
	{
		Assert(m_nSize == 0);
		Assert(m_nMaxSize == 0);
	}
	else
	{
		Assert(m_nSize <= m_nMaxSize);
		Assert((long)m_nMaxSize * m_cbValue <= SIZE_T_MAX);    // no overflow
		Assert(IsValidReadPtrIn(m_pData, m_nMaxSize * m_cbValue));
	}

	// some collections live as global variables in the libraries, but
	// have their existance in some context.  Also, we can't check shared
	// collections since we might be checking the etask collection
	// which would cause an infinite recursion.
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\class\tls.cxx ===
//+---------------------------------------------------------------
//
//  File:       tls.cxx
//
//  Contents:   Thread Local Storage initialization and cleanup.
//
//  History:    18-Apr-94   CraigWi     Split off of channelb.cxx
//              06-Jul-94   BruceMa     Support for CoGetCurrentProcess
//              30-Jan-95   BruceMa     DLL_PROCESS_DETACH can interrupt
//                                       DLL_THREAD_DETACH so delete pData
//                                       carefully
//
//----------------------------------------------------------------
#include <ole2int.h>
#include <..\dcomrem\locks.hxx>

// Heap Handle
extern  HANDLE    g_hHeap;

//+-------------------------------------------------------------------------
//
// per-thread tls entry
//
//+-------------------------------------------------------------------------
typedef struct tagTLSMapEntry
{
    DWORD        dwThreadId;    // tid of thread that owns this entry
    SOleTlsData *ptls;          // ptr to TLS structure for this thread
} TLSMapEntry;

COleStaticMutexSem  gTlsLock;   // CS to protect the global map
TLSMapEntry        *gpTlsMap            = NULL;
ULONG               gcTlsTotalEntries   = 0;
ULONG               gcTlsUsedEntries    = 0;
LONG                giTlsNextFreeEntry  = -1;

//+-------------------------------------------------------------------------
//
//  Function:   TLSLookupThreadId
//
//  Synopsis:   Finds the Tls structure associated with a given threadid
//
//  Returns:    ptr to structure if found in the map, NULL otherwise
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
SOleTlsData *TLSLookupThreadId(DWORD dwThreadId)
{
    ASSERT_LOCK_DONTCARE(gTlsLock); // Allow this to be recursively locked.
    LOCK(gTlsLock);

    if (gpTlsMap != NULL)
    {
        // walk the map looking for a match on the threadid
        TLSMapEntry *pMapEntry  = gpTlsMap;
        TLSMapEntry *pTlsMapEnd = &gpTlsMap[gcTlsTotalEntries];
        while (pMapEntry < pTlsMapEnd)
        {
            if (pMapEntry->dwThreadId == dwThreadId &&
                pMapEntry->ptls != NULL)
            {
                UNLOCK(gTlsLock);
                return pMapEntry->ptls;
            }
            
            pMapEntry++;
        }
    }

    UNLOCK(gTlsLock);
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSGrowMap
//
//  Synopsis:   Grows the global tls map.
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
BOOL TLSGrowMap()
{
    ASSERT_LOCK_HELD(gTlsLock);

    // need to grow the map
    ULONG cNew = (gcTlsTotalEntries) ? gcTlsTotalEntries*2 : 40;
    TLSMapEntry *pNewMap = (TLSMapEntry *)HeapAlloc(g_hHeap, 0,
                                                    cNew * sizeof(TLSMapEntry));
    if (pNewMap == NULL)
    {
        // could not grow the map
        return FALSE;
    }

    // copy the old map into the new one, free the old one
    memcpy(pNewMap, gpTlsMap, gcTlsTotalEntries * sizeof(TLSMapEntry));
    if (gpTlsMap)
        HeapFree(g_hHeap, 0, gpTlsMap);
    gpTlsMap           = pNewMap;
    giTlsNextFreeEntry = gcTlsTotalEntries;

    // initialize the remaining entries
    for (LONG i=giTlsNextFreeEntry; i<(LONG)cNew; i++)
    {
        gpTlsMap[i].dwThreadId = i+1;
        gpTlsMap[i].ptls       = NULL;
    }

    // mark the last entry
    gpTlsMap[cNew-1].dwThreadId = -1;
    gcTlsTotalEntries             = cNew;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSAddToMap
//
//  Synopsis:   Adds the Tls structure associated with a given threadid to
//              the global map.
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
BOOL TLSAddToMap(SOleTlsData *ptls)
{
    ASSERT_LOCK_NOT_HELD(gTlsLock);
    LOCK(gTlsLock);

    if (giTlsNextFreeEntry == -1)
    {
        // need to grow the map
        if (!TLSGrowMap())
        {
            ptls->TlsMapIndex = -1;
            UNLOCK(gTlsLock);
            return FALSE;
        }
    }

    // get the entry pointer, update the next free slot, and
    // fill in the entry
    ptls->TlsMapIndex   = giTlsNextFreeEntry;
    TLSMapEntry *pEntry = &gpTlsMap[giTlsNextFreeEntry];
    giTlsNextFreeEntry  = pEntry->dwThreadId;
    pEntry->dwThreadId  = GetCurrentThreadId();
    pEntry->ptls        = ptls;

    // Increment number of initialized threads
    ++gcTlsUsedEntries;

    UNLOCK(gTlsLock);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   ProcessUninitTlsCleanup
//
//  Synopsis:   Cleansup relavant TLS entries at process uninit time
//
//  History:    18-oct-99   Gopalk
//
//--------------------------------------------------------------------------
void ProcessUninitTlsCleanup()
{
    if(gpTlsMap)
    {
        // Sanity check
        ASSERT_LOCK_NOT_HELD(gTlsLock);
        
        // Acquire TLS lock
        LOCK(gTlsLock);

        // Check for the need to cleanup any remaining tls entries
        if(gcTlsUsedEntries)
        {
            for(ULONG i=0;i<gcTlsTotalEntries;i++)
            {
                if(gpTlsMap[i].ptls)
                {
                    gpTlsMap[i].ptls->pCurrentCtx = NULL;
                    gpTlsMap[i].ptls->ContextId = (ULONGLONG)-1;
                }
            }
        }
        
        // Release TLS lock
        UNLOCK(gTlsLock);
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   CleanupTlsMap
//
//  Synopsis:   Cleansup remaining TLS entries in the map
//
//  History:    03-June-98   Gopalk
//
//--------------------------------------------------------------------------
void CleanupTlsMap(BOOL fSafe)
{
    // No need to hold the lock as the routine is called from inside
    // DllMain which is single threaded by the OS
    if(gpTlsMap)
    {
        // Check for the need to cleanup any remaining tls entries
        if(gcTlsUsedEntries)
        {
            for(ULONG i=0;i<gcTlsTotalEntries;i++)
            {
                if(gpTlsMap[i].ptls)
                    CleanupTlsState(gpTlsMap[i].ptls, fSafe);
            }
        }

        // Sanity check
        Win4Assert(gcTlsUsedEntries == 0);

        // Free TLS map
        HeapFree(g_hHeap, 0, gpTlsMap);
        gpTlsMap = NULL;
    }

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSRemoveFromMap
//
//  Synopsis:   Removes a Tls structure associated with a given threadid
//              from the global map.
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
void TLSRemoveFromMap(SOleTlsData *ptls)
{
    ASSERT_LOCK_NOT_HELD(gTlsLock);
    LOCK(gTlsLock);

    LONG index          = ptls->TlsMapIndex;
    Win4Assert(index != -1);
    TLSMapEntry *pEntry = &gpTlsMap[index];
    Win4Assert(pEntry->ptls == ptls);
    pEntry->ptls        = NULL;
    pEntry->dwThreadId  = giTlsNextFreeEntry;
    giTlsNextFreeEntry  = index;
    --gcTlsUsedEntries;

    UNLOCK(gTlsLock);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSAllocData
//
//  Synopsis:   Allocates the thread local storage block
//
//  Returns:    S_OK - allocated the data
//              E_OUTOFMEMORY - could not allocate the data
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
HRESULT COleTls::TLSAllocData(void)
{
    Win4Assert(g_hHeap != NULL);

    _pData = (SOleTlsData *) HeapAlloc(g_hHeap, 0,
                                       sizeof(SOleTlsData));

    if (_pData)
    {
        // This avoids having to set most fields to NULL, 0, etc and
        // is needed cause on debug builds memory is not guaranteed to
        // be zeroed.
        memset(_pData, 0, sizeof(SOleTlsData));

        // fill in the non-zero values
        _pData->dwFlags = OLETLS_LOCALTID;

        if (ComVerifierSettings::ComVerifierEnabled())
        {
            // Allocate space for the verifier data.
            _pData->pVerifierData = (VerifierTlsData *)HeapAlloc(g_hHeap, 
                                                                 HEAP_ZERO_MEMORY,
                                                                 sizeof(VerifierTlsData));
            // If it fails, oh well... this is just debugging data anyway.
        }

        // add it to the global map
        if (TLSAddToMap(_pData))
        {
            NtCurrentTeb()->ReservedForOle = _pData;
            _pData->ppTlsSlot = &(NtCurrentTeb()->ReservedForOle);
            return S_OK;
        }

        // error, cleanup and fallthru to error exit
        HeapFree(g_hHeap, 0, _pData);
        _pData = NULL;
    }

    ComDebOut((DEB_ERROR, "TLSAllocData failed.\n"));
    return E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------------
//
//  Function:   TLSGetLogicalThread
//
//  Synopsis:   gets the logical threadid of the current thread,
//              allocating one if necessary
//
//  Returns:    ptr to GUID
//              NULL if error
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
IID *TLSGetLogicalThread()
{
    HRESULT hr;
    RPC_STATUS sc;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        if (!(tls->dwFlags & OLETLS_UUIDINITIALIZED))
        {
            sc = UuidCreate(&(tls->LogicalThreadId));
            Win4Assert(sc == RPC_S_OK);

            tls->dwFlags |= OLETLS_UUIDINITIALIZED;
        }

        return &(tls->LogicalThreadId);
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupTlsState
//
//  Synopsis:   Cleans up state maintained inside tls
//
//  History:    June-04-98   Gopalk   Created
//
//----------------------------------------------------------------------------
void CleanupTlsState(SOleTlsData *pTls, BOOL fSafe)
{
    IUnknown* pUnkRelease = NULL;
    void* pMem = NULL;
    HWND hwndClose = NULL;
    HANDLE hClose = NULL;

    // Sanity check
    Win4Assert(pTls);

    // Cleanup verifier information
    if (pTls->pVerifierData)
    {
        VerifierTlsData* pVerifierData = pTls->pVerifierData;
        pTls->pVerifierData = NULL;
        HeapFree(g_hHeap, 0, pVerifierData);
    }

    // Cleanup initialization spies
    //   Revoke outstanding registrations
    InitializeSpyNode *pSpyNode = pTls->pFirstSpyReg;
    pTls->pFirstSpyReg = NULL; 
    while (pSpyNode)
    {
        InitializeSpyNode *pNext = pSpyNode->pNext;
        if (pSpyNode->pInitSpy)
            pSpyNode->pInitSpy->Release();
        CoTaskMemFree(pSpyNode);
        
        pSpyNode = pNext;
    }
    //   Free the free list
    pSpyNode = pTls->pFirstFreeSpyReg;
    pTls->pFirstFreeSpyReg = NULL;
    while (pSpyNode)
    {
        InitializeSpyNode *pNext = pSpyNode->pNext;
        CoTaskMemFree(pSpyNode);        
        pSpyNode = pNext;
    }

    // Cleanup call objects cached in the tls
    CleanupThreadCallObjects(pTls);

    // Release the docfile shared memory allocator
    if (pTls->pSmAllocator != NULL)
    {
        pUnkRelease = (IUnknown*)pTls->pSmAllocator;
        pTls->pSmAllocator = NULL;
        pUnkRelease->Release();
    }

    // Cleanup cancel state
    if(pTls->hThread)
    {
        hClose = pTls->hThread;
        pTls->hThread = NULL;
        CloseHandle(hClose);
    }

    // Cleanup DDE state
    if (pTls->hwndDdeServer != NULL)
    {
        hwndClose = pTls->hwndDdeServer;
        pTls->hwndDdeServer = NULL;
        SSDestroyWindow(hwndClose);
    }
    if (pTls->hwndDdeClient != NULL)
    {
        hwndClose = pTls->hwndDdeClient;
        pTls->hwndDdeClient = NULL;
        SSDestroyWindow(hwndClose);
    }

    // Cleanup OLE state
    if(pTls->pDragCursors)
    {
        pMem = pTls->pDragCursors;
        pTls->pDragCursors = NULL;
        PrivMemFree(pMem);
    }

    if (pTls->hwndClip != NULL)
    {
        hwndClose = pTls->hwndClip;
        pTls->hwndClip = NULL;
        SSDestroyWindow(hwndClose);
    }

    if (pTls->hRevert != NULL)
    {
        hClose = pTls->hRevert;
        pTls->hRevert = NULL;
        CloseHandle(hClose);
    }

    // Ensure there are no outstanding call objects
    Win4Assert(pTls->pFreeClientCall == NULL);
    Win4Assert(pTls->pFreeAsyncCall  == NULL);

    // Free up lock state
    LockEntry *pNextEntry = pTls->lockEntry.pNext;
    LockEntry *pFreeEntry;

    pTls->lockEntry.pNext = NULL;

    while(pNextEntry)
    {
        pFreeEntry = pNextEntry;
        pNextEntry = pFreeEntry->pNext;
        HeapFree(g_hHeap, 0, pFreeEntry);
    }

    if(fSafe)
        *(pTls->ppTlsSlot) = NULL;

    // Remove the entry from the global map
    TLSRemoveFromMap(pTls);

    // Free up tls memory
    HeapFree(g_hHeap, 0, pTls);
}

//+---------------------------------------------------------------------------
//
//  Function:   DoThreadSpecificCleanup
//
//  Synopsis:   Called to perform cleanup on all this threads data
//              structures, and to call CoUninitialize() if needed.
//
//              Could be called by DLL_THREAD_DETACH or DLL_PROCESS_DETACH
//
//  History:    3-18-95   kevinro   Created
//
//----------------------------------------------------------------------------
void DoThreadSpecificCleanup()
{
    CairoleDebugOut((DEB_DLL | DEB_ITRACE,"_IN DoThreadSpecificCleanup\n"));

    SOleTlsData *pTls = (SOleTlsData *) (NtCurrentTeb()->ReservedForOle);

    if (pTls == NULL)
    {
        // there is no TLS for this thread, so there can't be anything
        // to cleanup.
        return;
    }

    if (pTls->dwFlags & OLETLS_THREADUNINITIALIZING)
    {
        // this thread is already uninitializing.
        return;
    }

    if (IsWOWThread() && IsWOWThreadCallable() && pTls->cComInits != 0)
    {
        // OLETHK32 needs a chance to prepare, here is where we tell it
        // to fail any future callbacks.
        g_pOleThunkWOW->PrepareForCleanup();
    }

    // Because of the DLL unload rules in NT we need to be careful
    // what we do in clean up. We notify the routines with special
    // behavior here.

    pTls->dwFlags |= OLETLS_INTHREADDETACH;

    if (pTls->cOleInits != 0)
    {
        CoVrfNotifyLeakedOleInits();
    }

    if (pTls->cComInits != 0)
    {
        CoVrfNotifyLeakedInits();
    }

    while (pTls->cComInits != 0)
    {
        // cleanup per-thread initializations;
        ComDebOut((DEB_WARN, "Unbalanced call to CoInitialize for thread %ld\n",
                   GetCurrentThreadId()));        

        CoUninitialize();
    }

    // Cleanup TLS state
    CleanupTlsState(pTls, TRUE);

    // reset the index so we dont find this data again.
    Win4Assert(NtCurrentTeb()->ReservedForOle == NULL);

#if LOCK_PERF==1
    FreeLockPerfPvtTlsData();
#endif //LOCK_PERF==1

    ComDebOut((DEB_DLL | DEB_ITRACE,"OUT DoThreadSpecificCleanup\n"));
}


//+-------------------------------------------------------------------------
//
//  Function:   ThreadNotification
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [hDll]          -- a handle to the dll instance
//              [dwReason]      -- the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:      other one time initialization occurs in ctors for
//              global objects
//
//  WARNING:    if we are called because of FreeLibrary, then we should do as
//              much cleanup as we can. If we are called because of process
//              termination, we should not do any cleanup, as other threads in
//              this process will have already been killed, potentially while
//              holding locks around resources.
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) ThreadNotification(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        // new thread is starting
        ComDebOut((DEB_DLL,"DLL_THREAD_ATTACH:\n"));
#if LOCK_PERF==1
        HRESULT hr;
        hr = AllocLockPerfPvtTlsData();
        if (FAILED(hr)) 
        {
            ComDebOut((DEB_ERROR, "AllocLockPerfPvtTlsData failed.\n"));
            return FALSE;
        }
#endif
        break;

    case DLL_THREAD_DETACH:
        // Thread is exiting, clean up resources associated with threads.
        ComDebOut((DEB_DLL,"DLL_THREAD_DETACH:\n"));

        DoThreadSpecificCleanup();

        ASSERT_LOCK_NOT_HELD(gComLock);
        break;

    case DLL_PROCESS_ATTACH:
        // Get and cache the module name and the module name size.
        gcImagePath = GetModuleFileName(NULL, gawszImagePath, MAX_PATH);

#if LOCK_PERF==1
        gTlsLockPerfIndex = TlsAlloc();
        Win4Assert( gTlsLockPerfIndex!=0xffffffff );
        hr = AllocLockPerfPvtTlsData();
        if ((gTlsLockPerfIndex==0xFFFFFFFF) || FAILED(hr)) 
        {
            ComDebOut((DEB_ERROR, "TlsAlloc OR AllocLockPerfPvtTlsData failed.\n"));
            return FALSE;
        }
#endif  //LOCK_PERF==1
        break;

    case DLL_PROCESS_DETACH:
        if (NULL == lpvReserved)
        {
            // exiting because of FreeLibrary, so try to cleanup

            //
            // According the to the rules, OLETHK32 should have called over to
            // remove the global pointer (used for testing the IsWOWxxx situations)
            // before going away. It should have done this BEFORE this
            // DLL_PROCESS_DETACH was dispatched.
            //
            Win4Assert(!(IsWOWProcess() && IsWOWThreadCallable()));

            //
            // DLL_PROCESS_DETACH is called when we unload. The thread that is
            // currently calling has not done thread specific cleanup yet.
            //
            DoThreadSpecificCleanup();

#if LOCK_PERF==1
            TlsFree(gTlsLockPerfIndex);
            gTlsLockPerfIndex = 0xffffffff;
#endif  //LOCK_PERF==1
        }
        break;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSIsWOWThread
//
//  Synopsis:   indicates definitively if current thread is 16-bit WOW thread
//
//  Returns:    TRUE/FALSE
//
//  History:    15-Nov-94   MurthyS     Created
//
//--------------------------------------------------------------------------
BOOLEAN TLSIsWOWThread()
{
    COleTls tls;

    return((BOOLEAN) (tls->dwFlags & OLETLS_WOWTHREAD));
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSIsThreadDetaching
//
//  Synopsis:   indicates if thread cleanup is in progress
//
//  Returns:    TRUE/FALSE
//
//  History:    29-Jan-95   MurthyS     Created
//
//--------------------------------------------------------------------------
BOOLEAN TLSIsThreadDetaching()
{
    COleTls tls;

    return((BOOLEAN) (tls->dwFlags & OLETLS_INTHREADDETACH));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\commap\lib\iface.cxx ===
//+-------------------------------------------------------------------
//
//  File:       iface.cxx
//
//  Contents:   Implementation of CComInterfaceInfo
//
//  Classes:    CComInterfaceInfo
//
//  History:    27-Mar-2002  JohnDoty  Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <commap.h>
#include "iface.hxx"

CComInterfaceInfo::CComInterfaceInfo(
    IN GUID iid, 
    IN GUID ipid, 
    IN OXID oxid)
{
    m_IID   = iid;
    m_IPID  = ipid;
    m_OXID  = oxid;
    m_cRefs = 0;
}

// IUnknown
HRESULT 
__stdcall 
CComInterfaceInfo::QueryInterface(
    IN REFIID riid, 
    OUT void **ppv)
{
    if ((riid == IID_IUnknown) || 
        (riid == IID_IComInterfaceInfo))
    {
        *ppv = this;
        AddRef();
        
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

ULONG 
__stdcall 
CComInterfaceInfo::AddRef() 
{ 
    return InterlockedIncrement((LONG *)&m_cRefs); 
}

ULONG 
__stdcall 
CComInterfaceInfo::Release()
{
    ULONG cRefs = InterlockedDecrement((LONG *)&m_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }
    return cRefs;
}

// IComInterfaceInfo
HRESULT 
__stdcall 
CComInterfaceInfo::GetIID(OUT IID *pIID)
{
    if (pIID == NULL)
        return E_POINTER;
    
    *pIID = m_IID;
    return S_OK;
}

HRESULT 
__stdcall 
CComInterfaceInfo::GetIPID(OUT IPID *pIPID)
{
    if (pIPID == NULL)
        return E_POINTER;
    
    *pIPID = m_IPID;
    return S_OK;
}

HRESULT 
__stdcall 
CComInterfaceInfo::GetOXID(OUT OXID *pOXID)
{
    if (pOXID == NULL)
        return E_POINTER;
    
    *pOXID = m_OXID;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\coll\map_kv.cxx ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

#include <ole2int.h>
//#include <compobj.seg>
#pragma SEG(map_kv)

#include "map_kv.h"

#include "plex.h"
ASSERTDATA


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CMapKeyToValue_ctor)  
CMapKeyToValue::CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey,
	int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
	Assert(nBlockSize > 0);

	m_cbValue = cbValue;
	m_cbKey = cbKey;
	m_cbKeyInAssoc = cbKey == 0 ? sizeof(CKeyWrap) : cbKey;

	m_pHashTable = NULL;
	m_nHashTableSize = nHashSize;
	m_lpfnHashKey = lpfnHashKey;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
	if (memctx == MEMCTX_SAME)
		memctx = CoMemctxOf(this);
	m_memctx = memctx;
	Assert(m_memctx != MEMCTX_UNKNOWN);
}

#pragma SEG(CMapKeyToValue_dtor)  
CMapKeyToValue::~CMapKeyToValue()
{
	ASSERT_VALID(this);
	RemoveAll();
	Assert(m_nCount == 0);
}


#pragma SEG(MKVDefaultHashKey)  
// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
	UINT hash = 0;
	BYTE FAR* lpb = (BYTE FAR*)pKey;

	while (cbKey-- != 0)
		hash = 257 * hash + *lpb++;

	return hash;
}


#pragma SEG(CMapKeyToValue_InitHashTable)  
BOOL CMapKeyToValue::InitHashTable()
{
	ASSERT_VALID(this);
	Assert(m_nHashTableSize  > 0);
	
	if (m_pHashTable != NULL)
		return TRUE;

	Assert(m_nCount == 0);

	if ((m_pHashTable = (CAssoc FAR* FAR*)CoMemAlloc(m_nHashTableSize * sizeof(CAssoc FAR*), m_memctx, NULL)) == NULL)
		return FALSE;

	memset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

	ASSERT_VALID(this);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_RemoveAll)  
void CMapKeyToValue::RemoveAll()
{
	ASSERT_VALID(this);

	// free all key values and then hash table
	if (m_pHashTable != NULL)
	{
		// destroy assocs
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			register CAssoc FAR* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
				// assoc itself is freed by FreeDataChain below
				FreeAssocKey(pAssoc);
		}

		// free hash table
		CoMemFree(m_pHashTable, m_memctx);
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain(m_memctx);
	m_pBlocks = NULL;

	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

#pragma SEG(CMapKeyToValue_NewAssoc)  
CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_memctx, m_nBlockSize, SizeAssoc());

		if (newBlock == NULL)
			return NULL;

		// chain them into free list
		register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
		// free in reverse order to make it easier to debug
		pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
		for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
		{
			((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
			m_pFreeList = (CAssoc FAR*)pbAssoc;
		}
	}
	Assert(m_pFreeList != NULL); // we must have something

	CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

	// init all fields except pNext while still on free list
	pAssoc->nHashValue = hash;
	if (!SetAssocKey(pAssoc, pKey, cbKey))
		return NULL;

	SetAssocValue(pAssoc, pValue);

	// remove from free list after successfully initializing it (except pNext)
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	Assert(m_nCount > 0);       // make sure we don't overflow

	return pAssoc;
}


#pragma SEG(CMapKeyToValue_FreeAssoc)  
// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	Assert(m_nCount >= 0);      // make sure we don't underflow

	FreeAssocKey(pAssoc);
}


#pragma SEG(CMapKeyToValue_GetAssocAt)  
// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
	if (m_lpfnHashKey)
	    nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    nHash = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	register CAssoc  FAR* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
			return pAssoc;
	}
	return NULL;
}


#pragma SEG(CMapKeyToValue_CompareAssocKey)  
BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
	LPVOID pKey1;
	UINT cbKey1;

	GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
	return cbKey1 == cbKey2 && memcmp(pKey1, pKey2, cbKey1) == 0;
}


#pragma SEG(CMapKeyToValue_SetAssocKey)  
BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
	Assert(cbKey == m_cbKey || m_cbKey == 0);

	if (m_cbKey == 0)
	{
		Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

		// alloc, set size and pointer
		if ((pAssoc->key.pKey = CoMemAlloc(cbKey, m_memctx, NULL)) == NULL)
			return FALSE;

		pAssoc->key.cbKey = cbKey;
	}

	LPVOID pKeyTo;

	GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

	memcpy(pKeyTo, pKey, cbKey);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_GetAssocKeyPtr)  
// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
	if (m_cbKey == 0)
	{
		// variable length key; go indirect
		*ppKey = pAssoc->key.pKey;
		*pcbKey = pAssoc->key.cbKey;
	}
	else
	{
		// fixed length key; key in assoc
		*ppKey = (LPVOID)&pAssoc->key;
		*pcbKey = m_cbKey;
	}
}


#pragma SEG(CMapKeyToValue_FreeAssocKey)  
void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
	if (m_cbKey == 0)
		CoMemFree(pAssoc->key.pKey, m_memctx);
}


#pragma SEG(CMapKeyToValue_GetAssocValuePtr)  
void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
	*ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


#pragma SEG(CMapKeyToValue_GetAssocValue)  
void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueFrom;
	GetAssocValuePtr(pAssoc, &pValueFrom);
	Assert(pValue != NULL);
	memcpy(pValue, pValueFrom, m_cbValue);
}


#pragma SEG(CMapKeyToValue_SetAssocValue)  
void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueTo;
	GetAssocValuePtr(pAssoc, &pValueTo);
	if (pValue == NULL)
		memset(pValueTo, 0, m_cbValue);
	else
		memcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_Lookup)  
// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	UINT nHash;
	return LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
}


#pragma SEG(CMapKeyToValue_LookupHKey)  
// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
	{
		memset(pValue, 0, m_cbValue);
		return FALSE;       // not in map
	}

	ASSERT_VALID(this);

	GetAssocValue(pAssoc, pValue);
	return TRUE;
}


#pragma SEG(CMapKeyToValue_LookupAdd)  
// lookup and if not found add; returns FALSE only if OOM; if added, 
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	if (Lookup(pKey, cbKey, pValue))
		return TRUE;

	// value set to zeros since lookup failed

	return ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);
}


#pragma SEG(CMapKeyToValue_SetAt)  
// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	UINT nHash;
	register CAssoc  FAR* pAssoc;

	ASSERT_VALID(this);

	if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
	{
		if (!InitHashTable())
			// out of memory
			return FALSE;

		// it doesn't exist, add a new Association
		if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
			return FALSE;

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;

		ASSERT_VALID(this);
	}
	else
	{
		SetAssocValue(pAssoc, pValue);
	}

	return TRUE;
}


#pragma SEG(CMapKeyToValue_SetAtHKey)  
// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
		return FALSE;       // not in map

	ASSERT_VALID(this);

	SetAssocValue(pAssoc, pValue);
	return TRUE;
}


#pragma SEG(CMapKeyToValue_RemoveKey)  
// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	register CAssoc  FAR* FAR* ppAssocPrev;
	UINT i;
	if (m_lpfnHashKey)
	    i = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    i = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	ppAssocPrev = &m_pHashTable[i];

	CAssoc  FAR* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;   // not found
}


#pragma SEG(CMapKeyToValue_RemoveHKey)  
// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	// REVIEW: would like some way to verify that hKey is valid
	CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
		// null hkey or bad hash value
		return FALSE;

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

	while (*ppAssocPrev != NULL)
	{
		if (*ppAssocPrev == pAssoc)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &(*ppAssocPrev)->pNext;
	}

	return FALSE;   // not found (must have a messed up list or passed 
					// a key from another list)
}


#pragma SEG(CMapKeyToValue_GetHKey)  
HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
	UINT nHash;

	ASSERT_VALID(this);

	return (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

#pragma SEG(CMapKeyToValue_GetNextAssoc)  
void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition, 
		LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
	ASSERT_VALID(this);

	Assert(m_pHashTable != NULL);       // never call on empty map

	register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
	Assert(pAssocRet != NULL);

	if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		Assert(pAssocRet != NULL);  // must find something
	}

	// find next association
	CAssoc  FAR* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// fill in return data
	*pNextPosition = (POSITION) pAssocNext;

	// fill in key/pointer to key
	LPVOID pKeyFrom;
	UINT cbKey;
	GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
	if (m_cbKey == 0)
		// variable length key; just return pointer to key itself
		*(void FAR* FAR*)pKey = pKeyFrom;
	else
		memcpy(pKey, pKeyFrom, cbKey);

	if (pcbKey != NULL)
		*pcbKey = cbKey;

	// get value
	GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_AssertValid)  
void CMapKeyToValue::AssertValid() const
{
#ifdef _DEBUG
	Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

	Assert(m_nHashTableSize > 0);
	Assert(m_nCount == 0 || m_pHashTable != NULL);

	if (m_pHashTable != NULL)
		Assert(IsValidReadPtrIn(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

	if (m_lpfnHashKey)
	    Assert(IsValidCodePtr((FARPROC)m_lpfnHashKey));

	if (m_pFreeList != NULL)
		Assert(IsValidReadPtrIn(m_pFreeList, SizeAssoc()));

	if (m_pBlocks != NULL)
		Assert(IsValidReadPtrIn(m_pBlocks, SizeAssoc() * m_nBlockSize));

	// some collections live as global variables in the libraries, but 
	// have their existance in some context.  Also, we can't check shared
	// collections since we might be checking the etask collection
	// which would cause an infinite recursion.
	// REVIEW: Assert(m_memctx == MEMCTX_SHARED || 
	// CoMemctxOf(this) == MEMCTX_UNKNOWN || CoMemctxOf(this) == m_memctx);
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\commap\lib\commap.cxx ===
//+-------------------------------------------------------------------
//
//  File:       commap.cxx
//
//  Contents:   Basic commap functionality.
//
//  Functions:  GetComProcessState
//              BuildOIDListFromIPIDArray
//              BuildObjectInfoFromOIDList
//
//  History:    27-Mar-2002  JohnDoty  Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <commap.h>
#include "iface.hxx"
#include "objinfo.hxx"
#include "process.hxx"
#include "reader.hxx"
#include <dbghelp.h>

struct OIDList
{
    OID              oid;
    DWORD            cIPIDs;
    const IPIDEntry *pFirstIPID;
    OIDList         *pNextOID;
};

HRESULT
BuildOIDListFromIPIDArray(
    IN const CProcessReader &reader,
    IN const DWORD cEntries,
    IN IPIDEntry rgEntries[],
    OUT DWORD *pcOIDs,
    OUT OIDList **ppOIDList)
{
    HRESULT hr            = S_OK;
    OIDList *pOIDListHead = NULL;
    DWORD    cOIDs        = 0;

    *pcOIDs = 0;
    *ppOIDList = NULL;
    
    for (DWORD i = 0; i < cEntries; i++)
    {
        OID oid;
        hr = reader.GetOIDFromIPIDEntry(&(rgEntries[i]), &oid);
        if (FAILED(hr))
            break;
        
        // Search for the OIDList entry.
        OIDList *pCurrentOID = pOIDListHead;
        while (pCurrentOID)
        {
            if (pCurrentOID->oid == oid)
                break;
            pCurrentOID = pCurrentOID->pNextOID;
        }
        
        if (pCurrentOID == NULL)
        {
            // OID not found!
            // Create new OID list entry.
            pCurrentOID = new OIDList;
            if (pCurrentOID == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            cOIDs++;
            
            pCurrentOID->oid = oid;
            pCurrentOID->cIPIDs = 1;
            pCurrentOID->pFirstIPID = &(rgEntries[i]);
            
            pCurrentOID->pNextOID = pOIDListHead;
            pOIDListHead = pCurrentOID;
        }
        else
        {
            // OID found!
            // Chain IPIDEntry to this list.
            rgEntries[i].pNextIPID  = (IPIDEntry *)pCurrentOID->pFirstIPID;
            pCurrentOID->pFirstIPID = &(rgEntries[i]);
            pCurrentOID->cIPIDs++;
        }
    }

    if (SUCCEEDED(hr))
    {
        *pcOIDs = cOIDs;
        *ppOIDList = pOIDListHead;
    }
    else
    {
        while (pOIDListHead)
        {
            OIDList *pTemp = pOIDListHead->pNextOID;
            delete pOIDListHead;
            pOIDListHead = pTemp;
        }
    }

    return hr;
}

HRESULT
BuildObjectInfoFromOIDList(
    IN const CProcessReader &reader,
    IN OIDList* pOIDList,
    OUT IComObjectInfo **ppObjInfo)
{
    HRESULT hr = S_OK;

    // First create the array of interface info for this object.
    IComInterfaceInfo **rgInterfaceInfo = new IComInterfaceInfo *[pOIDList->cIPIDs];
    if (rgInterfaceInfo == NULL)
    {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(rgInterfaceInfo, sizeof(IComInterfaceInfo *) * pOIDList->cIPIDs);

    DWORD iInterface = 0;
    const IPIDEntry *pCurrentIPID = pOIDList->pFirstIPID;
    while(pCurrentIPID)
    {
        OXID oxid;
        hr = reader.GetOXIDFromIPIDEntry(pCurrentIPID, &oxid);
        if (FAILED(hr))
            break;
        
        CComInterfaceInfo *pItfInfo = new CComInterfaceInfo(pCurrentIPID->iid,
                                                            pCurrentIPID->ipid,
                                                            oxid);
        if (pItfInfo == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
        pItfInfo->QueryInterface(IID_IComInterfaceInfo, 
                                 (void **)&(rgInterfaceInfo[iInterface]));
        iInterface++;
        
        pCurrentIPID = pCurrentIPID->pNextIPID;
    }
    
    if (SUCCEEDED(hr))
    {
        CComObjectInfo *pObj = new CComObjectInfo(pOIDList->oid,
                                                  pOIDList->cIPIDs,
                                                  rgInterfaceInfo);
        if (pObj != NULL)
        {
            // At this point pObj owns the interface array.  Do not clean
            // it up-- it will be cleaned up by pObj's destructor.
            pObj->QueryInterface(IID_IComObjectInfo, (void **)ppObjInfo);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }                        
    }
    
    if (FAILED(hr))
    {
        // Out of memory or something died along the way.
        // Clean up the interface array.
        for (DWORD i = 0; i < pOIDList->cIPIDs; i++)
        {
            if (rgInterfaceInfo[i])
                rgInterfaceInfo[i]->Release();
        }
        delete [] rgInterfaceInfo;
    }
    
    return hr;
}

STDAPI
GetComProcessState(
    IN HANDLE hProcess,
    IN DWORD  dwFlags,
    OUT IComProcessState **ppProcess)
{
    HRESULT          hr           = S_OK;
    DWORD            cEntries     = 0;
    IPIDEntry       *rgEntries    = NULL;
    DWORD            cOIDs        = 0;
    OIDList         *pOIDListHead = NULL;
    LPWSTR           wszLRPCEndpoint = NULL;

    if (ppProcess == NULL)
    {
        return E_POINTER;
    }
    *ppProcess = NULL;

    if (hProcess == NULL)
    {
        return E_INVALIDARG;
    }

    if (!(dwFlags & CM_SYMBOLS_LOADED))
    {
        // Assume symbols not loaded for hProcess-- must do SymInitialize()
        if (!SymInitialize(hProcess, NULL, TRUE))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    CProcessReader reader(hProcess);
    hr = reader.ReadLRPCEndpoint(&wszLRPCEndpoint);
    if (SUCCEEDED(hr))
    {
        hr = reader.ReadIPIDEntries(&cEntries, &rgEntries);
        if (SUCCEEDED(hr))
        {
            // Now, each IPID needs to be traced back to it's OID.  Joy of joys!
            hr = BuildOIDListFromIPIDArray(reader,
                                           cEntries,
                                           rgEntries,
                                           &cOIDs,
                                           &pOIDListHead);
        }
    }


    if (SUCCEEDED(hr))
    {
        // Good, got the OID list.  
        // First allocate the array that will hold the pointers to object infos.
        IComObjectInfo **rgObjectInfo = new IComObjectInfo *[cOIDs];
        if (rgObjectInfo != NULL)
        {
            // Now go through the OID list and construct:
            //  1. CComInterfaceInfos,
            //  2. CComObjectInfos
            //
            ZeroMemory(rgObjectInfo, sizeof(IComObjectInfo *) * cOIDs);
            
            DWORD iObject = 0;
            OIDList *pCurrentOID = pOIDListHead;
            while (pCurrentOID)
            {
                hr = BuildObjectInfoFromOIDList(reader, pCurrentOID, &(rgObjectInfo[iObject]));
                if (FAILED(hr))
                    break;
                
                iObject++;
                pCurrentOID = pCurrentOID->pNextOID;
            } // End of OID Loop        
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            // Great, time to create the object to return.
            CComProcessState *pProcState = new CComProcessState(cOIDs,
                                                                rgObjectInfo,
                                                                wszLRPCEndpoint);
            if (pProcState != NULL)
            {
                pProcState->QueryInterface(IID_IComProcessState, (void **)ppProcess);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        if (FAILED(hr))
        {
            // Something screwed up.  Clean up the object array.
            if (rgObjectInfo)
            {
                for (DWORD i = 0; i < cOIDs; i++)
                {
                    if (rgObjectInfo[i])
                        rgObjectInfo[i]->Release();
                }
                delete [] rgObjectInfo;
            }
        }
    }

    // Clean up!
    //
    // Clean up OID list.
    while (pOIDListHead)
    {
        OIDList *pTemp = pOIDListHead->pNextOID;
        delete pOIDListHead;
        pOIDListHead = pTemp;
    }
    // Clean up IPIDEntries.
    delete [] rgEntries;

    if (!(dwFlags & CM_SYMBOLS_LOADED))
    {
        // We called SymInitialize, must clean up now.
        SymCleanup(hProcess);
    }
    
    if (FAILED(hr) && wszLRPCEndpoint)
    {
        // Clean up LRPC endpoint string, since nobody is holding it.
        CoTaskMemFree(wszLRPCEndpoint);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\commap\lib\objinfo.cxx ===
//+-------------------------------------------------------------------
//
//  File:       objinfo.cxx
//
//  Contents:   Implementation of CComObjectInfo
//
//  Classes:    CComObjectInfo
//
//  History:    27-Mar-2002  JohnDoty  Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <commap.h>
#include "objinfo.hxx"

CComObjectInfo::~CComObjectInfo()
{
    for (DWORD i = 0; i < m_cInterfaces; i++)
    {
        (m_rgInterfaces[i])->Release();
    }
    delete [] m_rgInterfaces;
}
    
// IUnknown
HRESULT 
__stdcall 
CComObjectInfo::QueryInterface(
    IN REFIID riid, 
    OUT void **ppv)
{
    if ((riid == IID_IUnknown) || 
        (riid == IID_IComObjectInfo))
    {
        *ppv = this;
        AddRef();
        
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

ULONG
__stdcall
CComObjectInfo::AddRef() 
{ 
    return InterlockedIncrement((LONG *)&m_cRefs); 
}

ULONG
__stdcall
CComObjectInfo::Release()
{
    ULONG cRefs = InterlockedDecrement((LONG *)&m_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }
    
    return cRefs;
}

// IComObjectInfo
HRESULT
__stdcall
CComObjectInfo::GetOID(OUT OID *pOID)
{
    if (pOID == NULL)
        return E_POINTER;
    
    *pOID = m_oid;
    return S_OK;
}

HRESULT
__stdcall
CComObjectInfo::GetInterfaceCount(OUT DWORD *pcInterfaces)
{
    if (pcInterfaces == NULL)
        return E_POINTER;
    
    *pcInterfaces = m_cInterfaces;
    return S_OK;
}

HRESULT
__stdcall
CComObjectInfo::GetInterface(
    IN DWORD iInterface, 
    IN REFIID riid,
    OUT void **ppvInterfaceInfo)
{
    if (ppvInterfaceInfo == NULL)
        return E_POINTER;
    if (iInterface >= m_cInterfaces)
        return E_INVALIDARG;
    
    return m_rgInterfaces[iInterface]->QueryInterface(riid, ppvInterfaceInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\commap\lib\process.cxx ===
//+-------------------------------------------------------------------
//
//  File:       process.cxx
//
//  Contents:   Implementation of CComProcessState
//
//  Classes:    CComProcessState
//
//  History:    27-Mar-2002  JohnDoty  Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <commap.h>
#include "process.hxx"
#include <strsafe.h>

CComProcessState::~CComProcessState()
{
    for (DWORD i = 0; i < m_cObjects; i++)
    {
        m_rgObjects[i]->Release();
    }
    delete[] m_rgObjects;
}

// IUnknown
HRESULT
__stdcall
CComProcessState::QueryInterface(
    IN REFIID riid, 
    OUT void **ppv
)
{
    if ((riid == IID_IUnknown) || (riid == IID_IComProcessState))
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
__stdcall 
CComProcessState::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cRefs);
}

ULONG
__stdcall 
CComProcessState::Release()
{
    ULONG cRefs = InterlockedDecrement((LONG *)&m_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }

    return cRefs;
}

// IComProcessState
HRESULT
__stdcall
CComProcessState::GetObjectCount(OUT DWORD *pcInterfaces)
{
    if (NULL == pcInterfaces)
        return E_POINTER;

    *pcInterfaces = m_cObjects;
    return S_OK;
}

HRESULT
__stdcall
CComProcessState::GetObject(
    IN DWORD iObject,
    IN REFIID riid,
    OUT void **ppvObjInfo)
{
    if (ppvObjInfo == NULL)
        return E_POINTER;
    *ppvObjInfo = NULL;
    
    if (iObject >= m_cObjects)
        return E_INVALIDARG;
    
    return m_rgObjects[iObject]->QueryInterface(riid, ppvObjInfo);
}

HRESULT
__stdcall
CComProcessState::GetLRPCEndpoint(
    OUT LPWSTR *ppvEndpoint)
{
    if (ppvEndpoint == NULL)
        return E_POINTER;
    
    *ppvEndpoint = NULL;
    if (m_wszEndpointName)
    {
        size_t cch = lstrlenW(m_wszEndpointName) + 1;
        *ppvEndpoint = (LPWSTR)CoTaskMemAlloc((cch + 1) * 2);
        if (*ppvEndpoint == NULL)
            return E_OUTOFMEMORY;

        HRESULT hr = StringCchCopyW(*ppvEndpoint, cch, m_wszEndpointName);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\commap\lib\util.h ===
//+-------------------------------------------------------------------
//
//  File:       util.h
//
//  Contents:   Misc. Utility functions and macros
//
//  History:    27-Mar-2002  JohnDoty  Created
//
//--------------------------------------------------------------------
#pragma once

#define STACK_INSTANCE(type, name)                  \
   unsigned char __##name##_buffer[sizeof(type)];   \
   type * name = ( type * ) __##name##_buffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\aprtmnt.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       aprtmnt.cxx
//
//  Contents:   Maintains per-apartment state.
//
//  Classes:    CComApartment
//
//  History:    25-Feb-98   Johnstra      Created
//
//-----------------------------------------------------------------------------
#include <ole2int.h>
#include "locks.hxx"    // LOCK macros
#include "aprtmnt.hxx"  // class definition
#include "resolver.hxx" // gLocalMID
#include "remoteu.hxx"  // CRemoteUnknown


// STA apartments are chained off of TLS.
CComApartment* gpMTAApartment = NULL;   // global MTA Apartment
CComApartment* gpNTAApartment = NULL;   // global NTA Apartment

// count of multi-threaded apartment inits (see CoInitializeEx)
extern DWORD g_cMTAInits;

// Lock for TLS data (see tls.cxx)
extern COleStaticMutexSem gTlsLock;

//+-------------------------------------------------------------------
//
//  Function:   GetCurrentComApartment, public
//
//  Synopsis:   Gets the CComApartment object of the current apartment
//
//  History:    26-Oct-98   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT GetCurrentComApartment(CComApartment **ppComApt)
{
    ComDebOut((DEB_OXID,"GetCurrentComApartment ppComApt:%x\n", ppComApt));
    *ppComApt = NULL;

    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        APTKIND AptKind = GetCurrentApartmentKind(tls);
        switch (AptKind)
        {
        case APTKIND_MULTITHREADED :
            *ppComApt = gpMTAApartment;
            break;

        case APTKIND_NEUTRALTHREADED :
            *ppComApt = gpNTAApartment;
            break;

        case APTKIND_APARTMENTTHREADED :
            *ppComApt = tls->pNativeApt;
            break;

        default:
            Win4Assert(*ppComApt == NULL);
            break;
        }

        if (*ppComApt)
        {
            (*ppComApt)->AddRef();
            (*ppComApt)->AssertValid();
            hr = S_OK;
        }
        else
        {
            hr = CO_E_NOTINITIALIZED;
        }
    }

    ComDebOut((DEB_OXID,"GetCurrentComApartment hr:%x pComApt:%x\n", hr, *ppComApt));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   GetApartmentByID, public
//
//  Synopsis:   Gets the CComApartment object of the specified thread
//
//  History:    27-Feb-02   JohnDoty    Created.
//
//--------------------------------------------------------------------
HRESULT GetApartmentByID(DWORD dwAptID, CComApartment **ppComApt)
{
    ComDebOut((DEB_APT,"GetApartmentByID: dwAptID 0x%08x\n", dwAptID));

    // Take g_mxsSingleThreadOle so people can't CoUninit the target
    // apartment out from under us completely.  (The apartment cannot
    // be destroyed, see ApartmentUninitialize and 
    // ChannelThreadUninitialize.)
    //
    ASSERT_LOCK_DONTCARE(g_mxsSingleThreadOle);
    LOCK(g_mxsSingleThreadOle);

    HRESULT hr = E_INVALIDARG;
    if (dwAptID == NTATID)
    {
        *ppComApt = gpNTAApartment;
        if (gpNTAApartment)
        {
            gpNTAApartment->AddRef();
            hr = S_OK;
        }
        ComDebOut((DEB_APT,"GetApartmentByID: Found NA 0x%p\n", gpNTAApartment));
    }
    else if (dwAptID == MTATID)
    {
        *ppComApt = gpMTAApartment;
        if (gpMTAApartment)
        {
            gpMTAApartment->AddRef();
            hr = S_OK;
        }
        ComDebOut((DEB_APT,"GetApartmentByID: Found MTA 0x%p\n", gpMTAApartment));
    }
    else
    {
        // Assume you don't know what you're asking for.
        hr = E_INVALIDARG;

        // Take the lock for the TLS.  This means the target
        // thread can't die out from under us.
        //
        ASSERT_LOCK_NOT_HELD(gTlsLock);
        LOCK(gTlsLock);

        // Go get the TLS data for this apartment.
        SOleTlsData *pTls = TLSLookupThreadId(dwAptID);
        if (pTls)
        {
            *ppComApt = pTls->pNativeApt;
            if (pTls->pNativeApt)
            {
                ComDebOut((DEB_APT,"GetApartmentByID: Found STA 0x%p\n", pTls->pNativeApt));
                pTls->pNativeApt->AddRef();
                hr = S_OK;
            }
        }

        UNLOCK(gTlsLock);
        ASSERT_LOCK_NOT_HELD(gTlsLock);
    }

    UNLOCK(g_mxsSingleThreadOle);
    ASSERT_LOCK_DONTCARE(g_mxsSingleThreadOle);

    if (*ppComApt)
    {
        Win4Assert((*ppComApt)->GetAptId() == dwAptID);
    }

    ComDebOut((DEB_APT,"GetApartmentByID: returning 0x%08x\n", hr));

    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     IUnknown methods
//
//  Synopsis:   Clean up the native apartment object for the thread.
//
//  History:    20-Feb-98   Johnstra      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CComApartment::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown)
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CComApartment::AddRef()
{
    return InterlockedIncrement((LONG *) &_cRefs);
}

STDMETHODIMP_(ULONG) CComApartment::Release()
{
    ULONG refs = InterlockedDecrement((LONG *) &_cRefs);
    if (refs == 0)
    {
        delete this;
    }
    return refs;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::GetRemUnk, Public
//
//  Synopsis:   Obtains the RemUnk proxy for the apartment
//
//  History:    30-Jun-98   GopalK       Created
//
//+-------------------------------------------------------------------
HRESULT CComApartment::GetRemUnk(IRemUnknownN **ppRemUnk)
{
    ComDebOut((DEB_OXID,"CComApartment::GetRemUnk this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    HRESULT hr;

    *ppRemUnk = NULL;

    // Check if the apartment is still valid
    if (IsInited() && !IsStopPending())
    {
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);
        ASSERT_LOCK_HELD(gOXIDLock);

        OXIDEntry* pOXID = _pOXIDEntry;
        if(NULL == pOXID)
        {
            UNLOCK(gOXIDLock);
            hr = RPC_E_DISCONNECTED;
            goto Cleanup;
        }

        AssertValid();
        
        // Stabilize OXID entry
        pOXID->IncRefCnt();

        ASSERT_LOCK_HELD(gOXIDLock);
        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);

        // Get the RemUnk proxy from OXID entry
        hr = pOXID->GetRemUnk((IRemUnknown **) ppRemUnk);
        if(SUCCEEDED(hr))
            (*ppRemUnk)->AddRef();
        else
            *ppRemUnk = NULL;

        // Fixup the refcount on OXID entry
        pOXID->DecRefCnt();
    }
    else
    {
        hr = RPC_E_DISCONNECTED;
    }

Cleanup:
    
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"CComApartment::GetRemUnk hr:%x pRemUnk:%x\n", hr, *ppRemUnk));
    return(hr);
}

//+--------------------------------------------------------------------------
//
//  Member:     CComApartment::GetPreRegMOID, public
//
//  Synopsis:   Get an OID that has been pre-registered with the Ping
//              Server for this apartment.
//
//  Parameters: [pmoid] - where to return the OID
//
//  History:    06-Nov-95   Rickhi      Created.
//              02-Nov-98   Rickhi      Moved from resolver code.
//
//  Notes: careful. The oids are dispensed in reverse order [n]-->[0], so the
//         unused ones are from [0]-->[cPreRegOidsAvail-1]. CanRundownOID
//         depends on this behavior.
//
//----------------------------------------------------------------------------
HRESULT CComApartment::GetPreRegMOID(MOID *pmoid)
{
    ComDebOut((DEB_OXID,"CComApartment::GetPreRegMOID this:%x\n", this));
    AssertValid();

    // CODEWORK:
    // sometimes the NTA is not initialized because we call InitChannel while
    // in the STA/MTA, then switch to the NTA to do some work. For example,
    // CoGetStandardMarshal does this. This should be fixed and the NTA init
    // done in InitChannelIfNecessary.

    HRESULT hr = InitRemoting();
    if (FAILED(hr))
        return hr;

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (_cPreRegOidsAvail == 0)
    {
        // wait until no other threads are calling ServerAllocOIDs
        hr = WaitForAccess();

        if (SUCCEEDED(hr))
        {
            // have exclusive access now, check the count again.
            if (_cPreRegOidsAvail == 0)
            {
                // still none, need to really go get more.
                hr = CallTheResolver();
            }

            // wakeup any threads waiting for access to this code
            CheckForWaiters();
        }
    }    

    // Careful here.  CallTheResolver can return success even
    // when rpcss failed to allocate even one new oid.   
    if (SUCCEEDED(hr) && (_cPreRegOidsAvail > 0))
    {
        // take the next available OID
        Win4Assert(_cPreRegOidsAvail <= MAX_PREREGISTERED_OIDS);
        _cPreRegOidsAvail--;
        MOIDFromOIDAndMID(_arPreRegOids[_cPreRegOidsAvail], gLocalMid, pmoid);

        // mark it so we know it is taken (helps debugging) by turning on high bit.
        _arPreRegOids[_cPreRegOidsAvail] |= 0xf000000000000000;
    }
    else if (SUCCEEDED(hr))
    {
        // Don't have an oid to give back, even after all that work.  Bummer.
        Win4Assert(_cPreRegOidsAvail == 0);
        hr = E_OUTOFMEMORY;
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"CComApartment::GetPreRegMOID hr:%x moid:%I\n", hr, pmoid));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComApartment::FreePreRegMOID, public
//
//  Synopsis:   Free an OID that has been pre-registered with the Ping
//              Server for this apartment. The Free'd OID will be returned
//              to the ping server so it can cleanup it's state.
//
//  Parameters: [rmoid] - MOID to return the OID
//
//  History:    10-Feb-99   Rickhi      Created.
//
//  Notes:      The list maintained by this code is used to tell the resolver
//              about OIDs that are no longer used. This list is also checked
//              by the Rundown thread. If the OID is in this list, it is OK
//              to rundown, and it will be removed from the list at that time.
//              By returning OIDs to the resolver in a timely fashion, we can
//              reduce memory consumption in the resolver, and reduce and almost
//              eliminate calls to RundownOID.
//
//----------------------------------------------------------------------------
HRESULT CComApartment::FreePreRegMOID(REFMOID rmoid)
{
    ComDebOut((DEB_OXID,"CComApartment::FreePreRegMOID this:%x moid:%I\n",
              this, &rmoid));
    AssertValid();

    HRESULT hr = S_OK;
    OID oid;
    OIDFromMOID(rmoid, &oid);

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    while (!(_cOidsReturn < MAX_PREREGISTERED_OIDS_RETURN))
    {
        // no space in the list, go call the resolver to free
        // up space in the list. Note that we release the lock
        // over this call, so it is possible some other thread
        // adds more entries to the list and fills it up before
        // we return, hence the loop.

        // wait until no other threads are calling the resolver
        // for this apartment.
        hr = WaitForAccess();

        if (SUCCEEDED(hr))
        {
            // have exclusive access now, check the count again.
            if (!(_cOidsReturn < MAX_PREREGISTERED_OIDS_RETURN))
            {
                // still no room, need to really go free some more.
                hr = CallTheResolver();
            }

            // wakeup any threads waiting for access to this code
            CheckForWaiters();
        }

        if (FAILED(hr))
            break;
    }

    if (_cOidsReturn < MAX_PREREGISTERED_OIDS_RETURN)
    {
#if DBG==1
        // make sure there are no duplicates
        for (ULONG i=0; i<_cOidsReturn; i++)
            Win4Assert(_arOidsReturn[i] != oid);
#endif

        // add the OID to the list
        _arOidsReturn[_cOidsReturn++] = oid;

		// OID is freed.
        hr = S_OK;
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"CComApartment::FreePreRegMOID hr:%x _cOidsReturn:%x\n",
              hr, _cOidsReturn));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::CanRundownOID, public
//
//  Synopsis:   Determine if OK to rundown the specified OID.
//
//  History:    06-Nov-95   Rickhi      Created.
//              02-Nov-98   Rickhi      Moved from resolver code.
//
//--------------------------------------------------------------------
void CComApartment::CanRundownOIDs(ULONG cOids, OID arOid[],
                                   RUNDOWN_RESULT arResult[])
{
    ComDebOut((DEB_OXID,
        "CComApartment::CanRundownOIDs this:%x cOids:%x arOid:%x arRes:%x\n",
        this, cOids, arOid, arResult));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);
    AssertValid();

    for (ULONG i=0; i<cOids; i++)
    {
        if (IsOidInPreRegList(arOid[i]))
        {
            // found the OID still in the pre-reg list.
            // although we could keep it incase we have to hand another
            // one out in the future, we'll actually return it in order
            // to quiet down the system and prevent future calls to Rundown.
            arResult[i] = RUNDWN_RUNDOWN;
        }
        else if (IsOidInReturnList(arOid[i]))
        {
            // found the OID in the return list. We're done with
            // this oid so OK to rundown.
            arResult[i] = RUNDWN_RUNDOWN;
        }
        else
        {
            // OID is not in any of our lists. We don't know that state
            // of it.
            arResult[i] = RUNDWN_UNKNOWN;
        }
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::WaitForAccess, private
//
//  Synopsis:   waits until there are no threads allocting OIDs in this
//              apartment.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CComApartment::WaitForAccess()
{
    ASSERT_LOCK_HELD(gOXIDLock);

    if (_dwState & APTFLAG_REGISTERINGOIDS)
    {
        // some other thread is busy registering OIDs for this OXID
        // so lets wait for it to finish. This should only happen in
        // the MTA apartment.
        Win4Assert(IsMTAThread() || IsThreadInNTA());

        if (_hEventOID == NULL)
        {
            _hEventOID = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (_hEventOID == NULL)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }

        // count one more waiter
        _cWaiters++;

        do
        {
            // release the lock before we block so the other thread can wake
            // us up when it returns.
            UNLOCK(gOXIDLock);
            ASSERT_LOCK_NOT_HELD(gOXIDLock);

            ComDebOut((DEB_OXID,"WaitForOXIDEntry wait on hEvent:%x\n", _hEventOID));
            DWORD rc = WaitForSingleObject(_hEventOID, INFINITE);
            Win4Assert(rc == WAIT_OBJECT_0);

            ASSERT_LOCK_NOT_HELD(gOXIDLock);
            LOCK(gOXIDLock);

        } while (_dwState & APTFLAG_REGISTERINGOIDS);

        // one less waiter
        _cWaiters--;
    }

    // mark the entry as busy by us
    _dwState |= APTFLAG_REGISTERINGOIDS;

    ASSERT_LOCK_HELD(gOXIDLock);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::CheckForWaiters, private
//
//  Synopsis:   wakes up any threads waiting to get an OID for this
//              apartment.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CComApartment::CheckForWaiters()
{
    ASSERT_LOCK_HELD(gOXIDLock);

    if (_cWaiters > 0)
    {
        // some other thread is busy waiting for the current thread to
        // finish registering so signal him that we are done.

        Win4Assert(_hEventOID != NULL);
        ComDebOut((DEB_TRACE,"CheckForWaiters signalling hEvent:%x\n", _hEventOID));
        SetEvent(_hEventOID);
    }

    // mark the entry as no longer busy by us
    _dwState &= ~APTFLAG_REGISTERINGOIDS;

    ASSERT_LOCK_HELD(gOXIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::CallTheResolver, private
//
//  Synopsis:   calls the resolver to return the OIDs in the Return list,
//              and allocate more OIDs for the PreReg list.
//
//  History:    10-Feb-99   Rickhi      Created from other pieces.
//
//--------------------------------------------------------------------
HRESULT CComApartment::CallTheResolver()
{
    ComDebOut((DEB_OXID,
        "CComApartment::CallTheResolver this:%x cToFree:%x cToAlloc:%x\n",
        this, _cOidsReturn, MAX_PREREGISTERED_OIDS - _cPreRegOidsAvail));
    AssertValid();
    Win4Assert(_pOXIDEntry != NULL);
    Win4Assert(_cOidsReturn <= MAX_PREREGISTERED_OIDS_RETURN);
    ASSERT_LOCK_HELD(gOXIDLock);

    // Tell the resolver about the ones we are done with.
    ULONG cOidsReturn = _cOidsReturn;
    OID arOidsReturn[MAX_PREREGISTERED_OIDS_RETURN];
    memcpy(arOidsReturn, _arOidsReturn, _cOidsReturn * sizeof(OID));
    _cOidsReturn = 0;

    // make up a list of pre-registered OIDs on our stack. Allocate only
    // enough to fill up the available space in the list.
    ULONG cOidsAlloc = MAX_PREREGISTERED_OIDS - _cPreRegOidsAvail;
    OID   arOidsAlloc[MAX_PREREGISTERED_OIDS];


    // we can safely release the lock now.
    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // ask the OXIDEntry to go get more OIDs and release the ones
    // we are done with.
    HRESULT hr = CO_E_NOTINITIALIZED;
    if (_pOXIDEntry)
    {
        hr = _pOXIDEntry->AllocOIDs(&cOidsAlloc, arOidsAlloc,
                                    cOidsReturn, arOidsReturn);
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (SUCCEEDED(hr))
    {
        // copy the newly created OIDs into the list.
        ULONG cOidsCopy = min(cOidsAlloc, MAX_PREREGISTERED_OIDS - _cPreRegOidsAvail);
        Win4Assert(cOidsCopy == cOidsAlloc);
        memcpy(_arPreRegOids + _cPreRegOidsAvail, arOidsAlloc, cOidsCopy * sizeof(OID));
        _cPreRegOidsAvail += cOidsAlloc;
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::CallTheResolver hr%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::GetOXIDEntry, public
//
//  Synopsis:   Creates and/or returns the OXIDEntry for this apartment
//
//  History:    06-Nov-98   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CComApartment::GetOXIDEntry(OXIDEntry **ppOXIDEntry)
{
    AssertValid();

    HRESULT hr = S_OK;
    if (_pOXIDEntry == NULL)
    {
        hr = InitRemoting();
        if (hr == S_FALSE)
        {
            hr = S_OK;
        }
    }

    *ppOXIDEntry = _pOXIDEntry;
    ComDebOut((DEB_OXID,"CComApartment::GetOXIDEntry this:%x hr:%x pOXIDEntry:%x\n",
              this, hr, *ppOXIDEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::InitCSIfNecessary, private
//
//  Synopsis:   Initializes this apartment's critical section, if
//              necessary.
//
//  History:    28-Feb-02   JohnDoty     Created.
//
//--------------------------------------------------------------------
HRESULT CComApartment::InitCSIfNecessary()
{
    if (_fInitializedCS)
        return S_OK;

    DWORD dwSpinCount = CalculateSpinCount();
    HRESULT hr = S_OK;    
    
    Win4Assert(gfOleMutexCreationSemOkay);
    if (!gfOleMutexCreationSemOkay)
        return E_UNEXPECTED;

    // We use g_OleMutexCreationSem because it probably won't 
    // have much contention at all.
    EnterCriticalSection(&g_OleMutexCreationSem);

    if (!_fInitializedCS)
    {
        if (!InitializeCriticalSectionAndSpinCount(&_csMessageParams, dwSpinCount))
            hr = E_OUTOFMEMORY;
        else
            _fInitializedCS = TRUE;
    }

    LeaveCriticalSection(&g_OleMutexCreationSem);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::QueueMessage, public
//
//  Synopsis:   Queues a message to this apartment, in anticipation of
//              processing it later.  This only applies to apartment-
//              threaded apartments.
//
//  History:    27-Feb-02   JohnDoty     Created.
//
//--------------------------------------------------------------------
HRESULT CComApartment::QueueMessage(UINT msg, IMessageParam *param)
{
    AssertValid();
    Win4Assert(_AptKind == APTKIND_APARTMENTTHREADED);

    ComDebOut((DEB_APT,"QueueMessage: this: 0x%p msg: %x param: 0x%p\n", this, msg, param));

    // Figure out which bucket we're adding to.
    UINT iMsg = (msg - WM_USER);
    if (iMsg >= OLE_MESSAGE_COUNT)
    {
        Win4Assert(!"QueueMessage: Unknown message!\n");
        return E_INVALIDARG; // Don't know what you're talking about, kid.
    }

    // Make sure the lock is initialized.
    HRESULT hr = InitCSIfNecessary();
    if (FAILED(hr))
        return hr;
    Win4Assert(_fInitializedCS); // Just to be paranoid...

    EnterCriticalSection(&_csMessageParams);

    param->pNextMessage = NULL;

    // Link up the list... insert at the end.
    if (_arMessageParams[iMsg].pLast != NULL)
        _arMessageParams[iMsg].pLast->pNextMessage = param;
    
    _arMessageParams[iMsg].pLast = param;
    
    if (_arMessageParams[iMsg].pFirst == NULL)
        _arMessageParams[iMsg].pFirst = param;
    
    // The list holds a reference on the object.
    param->AddRef();

    LeaveCriticalSection(&_csMessageParams);

    ComDebOut((DEB_APT,"QueueMessage: Returning 0x%08x\n", S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::RemoveMessage, public
//
//  Synopsis:   Remove a message that was sent to this apartment, so we
//              can process it.  The idea is that the IMessageParam 
//              parameter to this function comes from an LPARAM recieved
//              in a window proc.  As such, the caller of this function 
//              now owns the reference placed on the object.  (If the
//              function fails, the caller does NOT own the reference.)
//
//              This only applies to apartment-threaded apartments.
//
//  History:    27-Feb-02   JohnDoty     Created.
//
//--------------------------------------------------------------------
HRESULT CComApartment::RemoveMessage(UINT msg, IMessageParam *param)
{
    AssertValid();
    Win4Assert(_AptKind == APTKIND_APARTMENTTHREADED);

    ComDebOut((DEB_APT,"RemoveMessage: this: 0x%p msg: %x param: 0x%p\n", this, msg, param));

    // Figure out which bucket we're removing from.
    UINT iMsg = (msg - WM_USER);
    if (iMsg >= OLE_MESSAGE_COUNT)
    {
        ComDebOut((DEB_ERROR,"RemoveMessage: Unknown Message!\n", msg, param));
        return E_INVALIDARG; // Don't know what you're talking about, kid.
    }

    // Make sure the lock is initialized.
    HRESULT hr = InitCSIfNecessary();
    if (FAILED(hr))
        return hr;
    Win4Assert(_fInitializedCS); // Just to be paranoid...
    
    hr = E_INVALIDARG;
    EnterCriticalSection(&_csMessageParams);

    IMessageParam *pChase   = NULL;
    IMessageParam *pCurrent = _arMessageParams[iMsg].pFirst;
    while (pCurrent != NULL)
    {
        if (pCurrent == param)
        {
            ComDebOut((DEB_APT,"RemoveMessage: Found message...\n", msg, param));

            // Found it.  De-queue it.
            if (pChase)
                pChase->pNextMessage = pCurrent->pNextMessage;
            else
                _arMessageParams[iMsg].pFirst = pCurrent->pNextMessage;

            if (pCurrent == _arMessageParams[iMsg].pLast)
                _arMessageParams[iMsg].pLast = pChase;
            
            // For completeness sake...
            pCurrent->pNextMessage = NULL;

            // Don't Release() it, the caller now owns this ref.
            // (Return success so that they know about it.)
            hr = S_OK;
            break;
        }

        pChase = pCurrent;
        pCurrent = pCurrent->pNextMessage;
    }

    LeaveCriticalSection(&_csMessageParams);
    
    ComDebOut((DEB_APT,"RemoveMessage: Returning 0x%08x\n", hr)); 
    return hr;
}

//--------------------------------------------------------------------
//
//  Member:     CComApartment::InitRemoting, private
//
//  Synopsis:   Initialized the apartment for serving remote objects.
//
//  History:    02-Nov-98   Rickhi      Moved from channel init code.
//
//  Notes:      Marshalling the remote unknown causes recursion back to
//              this function.  The recursion is terminated because
//              GetLocalOXIDEntry is not NULL on the second call.
//
//              If there is a failure, whatever work-in-progress has
//              been completed is left alone and cleaned up later when
//              the apartment is uninitialized.
//
//--------------------------------------------------------------------
HRESULT CComApartment::InitRemoting()
{
    ComDebOut((DEB_OXID,"CComApartment::InitRemoting: this:%x [IN]\n", this));
    AssertValid();

    if (IsInited())
        // it is initialized already
        return S_OK;

    // handle re-entrancy on the same thread. Note that when we create the
    // CRemUnknown below, it calls back to InitRemoting, so we want to
    // pretend like InitRemoting has already completed.
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    if ((tls->dwFlags & OLETLS_APTINITIALIZING))
        // it is already being initialized by the current thread.
        return S_FALSE;
    else
        // re-entrancy protection
        tls->dwFlags |= OLETLS_APTINITIALIZING;


    // Make sure the apartment's CoInit counts are OK.
    if (_AptKind == APTKIND_MULTITHREADED && g_cMTAInits == 0)
    {
        // CoInitializeEx(MULTITHREADED) has not been called
        hr = CO_E_NOTINITIALIZED;
    }
    else if (_AptKind == APTKIND_APARTMENTTHREADED)
    {
        if (tls->cComInits == 0 ||
           (tls->dwFlags & OLETLS_THREADUNINITIALIZING))
            // CoInitialize has not been called for this apartment
            hr = CO_E_NOTINITIALIZED;
    }


    if (SUCCEEDED(hr))
    {
        // ensure channel process initialization has been done.
        hr = ChannelProcessInitialize();

        if (SUCCEEDED(hr))
        {
            ComDebOut((DEB_OXID,"CComApartment::InitRemoting: this:%x\n", this));
            
            // Always switch to deafult context for initializing remoting
            COleTls Tls;
            CObjectContext *pSavedCtx = Tls->pCurrentCtx;
            CObjectContext *pDefaultCtx;
            if (_AptKind == APTKIND_NEUTRALTHREADED)
            {
                Win4Assert(IsThreadInNTA());
                pDefaultCtx = g_pNTAEmptyCtx;
            }
            else
            {
                Win4Assert(!IsThreadInNTA());
                pDefaultCtx = IsSTAThread() ? Tls->pNativeCtx : g_pMTAEmptyCtx;
            }
            Tls->pCurrentCtx = pDefaultCtx;
            Win4Assert(pDefaultCtx);
            Tls->ContextId = pDefaultCtx->GetId();

            ASSERT_LOCK_NOT_HELD(gOXIDLock);
            LOCK(gOXIDLock);
            
            // only allow one thread to come through this initialization
            hr = WaitForAccess();

            if (SUCCEEDED(hr))
            {
                if (_pOXIDEntry == NULL)
                {
                    // create the OXIDEntry for this apartment. Note that it is
                    // only partially initialized at this point.
                    hr = gOXIDTbl.MakeServerEntry(&_pOXIDEntry);

                    if (SUCCEEDED(hr))
                    {
                        // initialize the OXIDEntry remoting
                        hr = _pOXIDEntry->InitRemoting(this);
                    }
                }

                if (SUCCEEDED(hr) && _pRemUnk == NULL)
                {
                    // Marshal the remote unknown. Note this causes recursion back to
                    // CComApartment::GetOXIDEntry, but the recursion is terminated
                    // because GetOXIDEntry returns the partially initialized OXIDEntry
                    // on the second call. Don't hold the critical section over this,
                    // single-threaded is guaranteed by WaitForAccess above.

                    UNLOCK(gOXIDLock);
                    ASSERT_LOCK_NOT_HELD(gOXIDLock);

                    IPID  ipidRundown;
                    hr = E_OUTOFMEMORY;
                    CRemoteUnknown *pRemUnk = new CRemoteUnknown(hr, &ipidRundown);

                    ASSERT_LOCK_NOT_HELD(gOXIDLock);
                    LOCK(gOXIDLock);

                    if (SUCCEEDED(hr))
                    {
                        // need to complete the initialization of the OXIDEntry
                        Win4Assert(_pRemUnk == NULL);
                        _pRemUnk = pRemUnk;
                        _pOXIDEntry->InitRundown(ipidRundown);
                    }
                }

                if (SUCCEEDED(hr) && !(_dwState & APTFLAG_REMOTEINITIALIZED))
                {
                    // Register the OXID and pre-registered OIDs for this
                    // apartment. Do this after creating the IRemUnknown, since
                    // the registration requires the IRemUnknown IPID.
                    hr = CallTheResolver();
                    if (SUCCEEDED(hr))
                    {
                        // remoting is really initialized now.
                        _dwState |= APTFLAG_REMOTEINITIALIZED;
                    }
                }

                // OK to let other threads through now
                CheckForWaiters();
            }

            UNLOCK(gOXIDLock);
            ASSERT_LOCK_NOT_HELD(gOXIDLock);

            // restore the original context, if there was one
            Win4Assert(Tls->pCurrentCtx == pDefaultCtx);
            Tls->pCurrentCtx = pSavedCtx;
            Tls->ContextId = pSavedCtx ? pSavedCtx->GetId() : (ULONGLONG)-1;
        }
    }

    // thread is no longer initing the apartment object
    tls->dwFlags &= ~OLETLS_APTINITIALIZING;

    ComDebOut((DEB_OXID,"CComApartment::InitRemoting: this:%x hr:%x [OUT]\n",
              this, hr));
    return hr;
}

//--------------------------------------------------------------------
//
//  Member:     CComApartment::CleanupRemoting, public
//
//  Synopsis:   Cleans up the state created by InitRemoting
//
//  History:    02-Nov-98   Rickhi      Moved from channel init code.
//
//--------------------------------------------------------------------
HRESULT CComApartment::CleanupRemoting()
{
    ComDebOut((DEB_OXID,"CComApartment::CleanupRemoting: this:%x\n", this));
    AssertValid();

    HRESULT hr = S_OK;
    OXIDEntry *pOXIDEntry = NULL;
    CRemoteUnknown *pRemUnk = NULL;

    // Stop the server again incase the apartment got reinit'd
    StopServer();

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (_pOXIDEntry != NULL)
    {
        // cleanup the OXIDEntry and RemoteUnknown for this apartment
        Win4Assert(!(_dwState & APTFLAG_SERVERSTARTED));
        Win4Assert(_pOXIDEntry->IsStopped());

        // store remote unknown for cleanup after the lock is released
        pRemUnk = _pRemUnk;
        _pRemUnk = NULL;

        // save the OXIDEntry to release after we release the lock
        pOXIDEntry = _pOXIDEntry;
        _pOXIDEntry = NULL;

        // cleanup the transport stuff. this might release the lock.
        pOXIDEntry->CleanupRemoting();

        // Free any pre-registered OIDs since these are registered for the
        // current apartment. We get a new OXID if the thread is re-initialized.
        pOXIDEntry->FreeOXIDAndOIDs(_cPreRegOidsAvail, _arPreRegOids);
        _cPreRegOidsAvail = 0;

        // mark state as uninitialized and not stopped
        _dwState &= ~(APTFLAG_REMOTEINITIALIZED | APTFLAG_STOPPENDING);
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // delete the remote unknown (if any) now that we have released the lock.
    if (pRemUnk)
        delete pRemUnk;

    // release the OXIDEntry (if any) now that we have released the lock.
    if (pOXIDEntry)
        pOXIDEntry->DecRefCnt();


    ComDebOut((DEB_OXID,"CComApartment::CleanupRemoting: this:%x hr:%x\n",
              this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::StartServerExternal
//
//  Synopsis:   Starts the apartment servicing incoming remote calls.
//              This method can be called from outside the apartment
//              (but it only works on the NA.  ^_^)
//
//  History:    28-Mar-01   JohnDoty    Created
//
//--------------------------------------------------------------------
HRESULT CComApartment::StartServerExternal()
{
    ComDebOut((DEB_OXID, "CComApartment::StartServerExternal this:%x [IN]\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    AssertValid();

    // Only the NA can be started from outside the NA.
    if (GetAptId() != NTATID)
        return S_FALSE;
    
    HRESULT hr = S_OK;
    if (!IsInited())
    {
        CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx); 

        hr = StartServer();

        LeaveNTA(pSavedCtx);
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::StartServerExternal this:%x [OUT] hr:%x\n",
              this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::RestartServer
//
//  Synopsis:   Restarts the apartment servicing incoming remote calls.  This is
//              generally meant to be called iff an apartment init count goes up
//              during the middle of an attempt to unitialize.  COM+ 31479.
//
//  History:    24-May-02   JohnFran
//
//--------------------------------------------------------------------
HRESULT CComApartment::RestartServer()
{
    ComDebOut((DEB_OXID, "CComApartment::RestartServer this:%x [IN]\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    AssertValid();
    //This should only be called on the MTA
    Win4Assert(_AptKind == APTKIND_MULTITHREADED);

    HRESULT hr = S_OK;

    //Clear the stop pending flag.
    _dwState &= ~APTFLAG_STOPPENDING;

    //Now make the call to restart the server.
    hr = StartServer();

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::RestartServer this:%x [OUT] hr:%x\n",
              this, hr));

    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CComApartment::StartServer
//
//  Synopsis:   Starts the apartment servicing incoming remote calls.
//
//  History:    02-Nov-98   Rickhi      Moved from ChannelThreadUninitialize
//
//--------------------------------------------------------------------
HRESULT CComApartment::StartServer()
{
    ComDebOut((DEB_OXID, "CComApartment::StartServer this:%x [IN]\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    AssertValid();

    HRESULT hr = S_OK;

    // if server started or is stopping don't do anything
    if (!(_dwState & (APTFLAG_SERVERSTARTED | APTFLAG_STOPPENDING)))
    {
        // initialize remoting for this apartment. Note that this returns
        // S_FALSE if the current thread is recursing during the
        // initialization, in which case we skip the rest of this function.
        hr = InitRemoting();
        if (SUCCEEDED(hr))
        {
            if (hr != S_FALSE)
            {
                ASSERT_LOCK_NOT_HELD(gOXIDLock);
                LOCK(gOXIDLock);

                if (!(_dwState & APTFLAG_SERVERSTARTED))
                {
                    // Turn off the STOPPED bit so we can accept incoming calls again.
                    hr = _pOXIDEntry->StartServer();
                    if (SUCCEEDED(hr))
                    {
                        _dwState |= APTFLAG_SERVERSTARTED;
                    }
                }

                UNLOCK(gOXIDLock);
                ASSERT_LOCK_NOT_HELD(gOXIDLock);
            }
            else
            {
                hr = S_OK;
            }            
        }
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::StartServer this:%x [OUT] hr:%x\n",
              this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::StopServer
//
//  Synopsis:   Stops the apartment servicing incoming remote calls.
//
//  History:    02-Nov-98   Rickhi  Moved from ChannelThreadUninitialize
//
//--------------------------------------------------------------------
HRESULT CComApartment::StopServer()
{
    ComDebOut((DEB_OXID, "CComApartment::StopServer this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    AssertValid();

    if (_dwState & APTFLAG_SERVERSTARTED)
    {
        if (_pOXIDEntry)
        {
            _pOXIDEntry->StopServer();
        }

        // mark the server as pending stop and not started
        _dwState |= APTFLAG_STOPPENDING;
        _dwState &= ~APTFLAG_SERVERSTARTED;
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::StopServer this:%x\n", this));
    return S_OK;
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Method:     CComApartment::AssertValid
//
//  Synopsis:   Verifies the integrity of the internal state
//
//  History:    02-Nov-98   Rickhi      Created
//
//--------------------------------------------------------------------
void CComApartment::AssertValid()
{
    if (_dwState & APTFLAG_REMOTEINITIALIZED)
    {
        Win4Assert(_pOXIDEntry);
    }

    if (_pOXIDEntry)
    {
        // make sure the apartment types match
        switch (_AptKind)
        {
        case APTKIND_MULTITHREADED :
            Win4Assert(_pOXIDEntry->IsMTAServer());
            break;

        case APTKIND_NEUTRALTHREADED :
            Win4Assert(_pOXIDEntry->IsNTAServer());
            break;

        case APTKIND_APARTMENTTHREADED :
            Win4Assert(_pOXIDEntry->IsSTAServer());
            break;

        default:
            break;
        }

        // make sure the OXIDEntry is valid
        _pOXIDEntry->AssertValid();
    }
}
#endif // DBG==1


//+-------------------------------------------------------------------
//
//  Function:   GetPreRegMOID, public
//
//  Synopsis:   Gets a pre-registered MOID from the current apartment
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT GetPreRegMOID(MOID *pmoid)
{
    // find the current apartment
    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);
    if (SUCCEEDED(hr))
    {
        // ask it for a reserved MOID
        hr = pComApt->GetPreRegMOID(pmoid);
        pComApt->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FreePreRegMOID, public
//
//  Synopsis:   Gets a pre-registered MOID from the current apartment
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT FreePreRegMOID(REFMOID rmoid)
{
    // find the current apartment
    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);
    if (SUCCEEDED(hr))
    {
        // ask it for a reserved MOID
        pComApt->FreePreRegMOID(rmoid);
        pComApt->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\commap\test\test.cxx ===
#include <windows.h>
#include <stdio.h>
#include <commap_i.c>
#include <commap.h>
#include <sddl.h>
#include <aclapi.h>

inline void PrintGuid(REFGUID guid)
{
    printf("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
           guid.Data1, 
           guid.Data2, 
           guid.Data3,
           guid.Data4[0],
           guid.Data4[1],
           guid.Data4[2],
           guid.Data4[3],
           guid.Data4[4],
           guid.Data4[5],            
           guid.Data4[6],
           guid.Data4[7]);                                                 
}

struct DbgIPID
{
    WORD  offset;     // These are reversed because of little-endian
    WORD  page;       // These are reversed because of little-endian
    DWORD pid;
    DWORD tid;
    DWORD seq;
};

inline void PrintIPID(IPID ipid)
{
    DbgIPID dbgipid = *(DbgIPID *)&ipid;
    printf("{pid: %08x tid: %08x pg: %04x off: %04x seq: %08x}\n", 
           dbgipid.pid, dbgipid.tid, dbgipid.page, dbgipid.offset, dbgipid.seq);    
}

WCHAR *
GetInterfaceName(IN GUID iid)
{
    HKEY hkCLSID;
    if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"Interface", 0, KEY_READ, &hkCLSID) != ERROR_SUCCESS)
        return NULL;

    HKEY hkClass;
    WCHAR guidBuff[40];
    StringFromGUID2(iid, guidBuff, 40);
    if (RegOpenKeyExW(hkCLSID, guidBuff, 0, KEY_READ, &hkClass) != ERROR_SUCCESS)
    {
        RegCloseKey(hkCLSID);
        return NULL;
    }

    DWORD cbData;
    RegQueryValueEx(hkClass, NULL, 0, NULL, NULL, &cbData);
    WCHAR *wszItfName = (WCHAR *)CoTaskMemAlloc(cbData);    
    if (RegQueryValueEx(hkClass, NULL, 0, NULL, (LPBYTE)wszItfName, &cbData) != ERROR_SUCCESS)
    {
        CoTaskMemFree(wszItfName);
        wszItfName = NULL;
    }
    
    RegCloseKey(hkClass);
    RegCloseKey(hkCLSID);
    return wszItfName;
}

bool 
EnablePrivilege(
    IN const wchar_t *pszPriv, 
    IN bool bEnable
)
{
    TOKEN_PRIVILEGES tp;
    HANDLE hToken;

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES,
                          &hToken))
        return false;

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;
    if (!LookupPrivilegeValue(0, pszPriv, &tp.Privileges[0].Luid))
    {
        CloseHandle(hToken);
        return false;
    }

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, 0))
    {
        CloseHandle(hToken);
        return false;
    }

    return (ERROR_NOT_ALL_ASSIGNED != GetLastError());
}

#define ORSTD(objref)    objref.u_objref.u_standard

HRESULT BuildMarshaledObjref(OID oid, OXID oxid, IPID ipid, REFIID riid, IStream **ppStream)
{
    // Fill out parameter.
    *ppStream = NULL;

    // Fill in the objref.
    OBJREF objref;
    objref.signature       = OBJREF_SIGNATURE;
    objref.flags           = OBJREF_STANDARD;
    objref.iid             = riid;
    ORSTD(objref).std.flags       = SORF_NULL;
    ORSTD(objref).std.cPublicRefs = 0;
    ORSTD(objref).std.oxid        = oxid;
    ORSTD(objref).std.oid         = oid;
    ORSTD(objref).std.ipid        = ipid;
    ORSTD(objref).saResAddr.wNumEntries     = 0;
    ORSTD(objref).saResAddr.wSecurityOffset = 0;

    // Write objref to stream.
    IStream *pStream = NULL;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (SUCCEEDED(hr))
    {
        hr = pStream->Write(&objref, sizeof(objref), NULL);
        if (SUCCEEDED(hr))
        {
            // Reset the stream.
            LARGE_INTEGER li; li.QuadPart = 0;
            pStream->Seek(li, STREAM_SEEK_SET, NULL);

            *ppStream = pStream;
        }
        else
        {
            pStream->Release();
        }
    }

    return hr;
}


int __cdecl main(int argc, char* argv[])
{
    printf("Hello world!\n");

    if (!EnablePrivilege(SE_DEBUG_NAME, true))
    {
        printf("Unable to enable debug privilege.\n");
        return -1;
    }    

    CoInitialize(NULL);

    DWORD dwPID = GetCurrentProcessId();
    if (argc > 1)
    {
        dwPID = atoi(argv[1]);
    }
    HANDLE hProcess = OpenProcess(GENERIC_READ | PROCESS_VM_OPERATION,
                                  FALSE,
                                  dwPID);
    if (hProcess == NULL)
    {
        printf("Unable to open process %d (gle %d)\n", dwPID, GetLastError());
        return GetLastError();
    }

    IComProcessState *pState = NULL;
    HRESULT hr = GetComProcessState(hProcess, 0, &pState);
    printf("GetComProcessState returned 0x%08x\n", hr);
    if (pState)
    {
        LPWSTR wszEndpoint = NULL;
        DWORD cOIDs = 0;
        
        pState->GetLRPCEndpoint(&wszEndpoint);
        if (wszEndpoint)
        {
            printf("LRPC Endpoint is : %S\n", wszEndpoint);
            CoTaskMemFree(wszEndpoint);
        }
        else
        {
            printf("LRPC is not initialized.\n");
        }

        pState->GetObjectCount(&cOIDs);
        printf("%d OIDs:\n", cOIDs);
        for (DWORD i = 0; i < cOIDs; i++)
        {
            IComObjectInfo *pObjectInfo = NULL;
            hr = pState->GetObject(i, IID_IComObjectInfo, (void **)&pObjectInfo);
            if (SUCCEEDED(hr))
            {
                OID oid;
                pObjectInfo->GetOID(&oid);
                printf("    %d: OID=%I64x\n", i, oid);

                DWORD cInterfaces = 0;
                pObjectInfo->GetInterfaceCount(&cInterfaces);
                for (DWORD j = 0; j < cInterfaces; j++)
                {
                    IComInterfaceInfo *pInterface = NULL;
                    hr = pObjectInfo->GetInterface(j, IID_IComInterfaceInfo, (void **)&pInterface);
                    if (SUCCEEDED(hr))
                    {
                        IID    iid;
                        IPID   ipid;
                        OXID   oxid;
                        WCHAR *wszInterfaceName = NULL;

                        pInterface->GetIID(&iid);
                        pInterface->GetIPID(&ipid);
                        pInterface->GetOXID(&oxid);
                        wszInterfaceName = GetInterfaceName(iid);

                        printf("        IID:  "); 
                        if (wszInterfaceName != NULL)
                        {
                            printf("%S\n", wszInterfaceName);
                            CoTaskMemFree(wszInterfaceName);
                        }
                        else
                        {
                            PrintGuid(iid); 
                            printf("\n");
                        }
                        printf("        IPID: "); PrintIPID(ipid);
                        printf("        OXID: %I64x\n", oxid); 
                        printf("\n");


                        IStream *pStm = NULL;
                        hr = BuildMarshaledObjref(oid, oxid, ipid, iid, &pStm);
                        if (SUCCEEDED(hr))
                        {
                            IUnknown *punk = NULL;
                            hr = CoUnmarshalInterface(pStm, iid, (void **)&punk);
                            if (SUCCEEDED(hr))
                            {
                                printf("        Unmarshal succeeded!\n");
                                punk->Release();
                            }
                            else
                            {
                                printf("        Unmarshal failed! (0x%08x)\n", hr);
                            }
                            pStm->Release();
                        }
                        else
                        {
                            printf("        BuildMarshaledObjref failed? (0x%08x)\n", hr);
                        }
                        printf("\n");

                        pInterface->Release();
                    }
                    else
                    {
                        printf("        GetInterfaceInfo %d failed with 0x%08x\n", j, hr);
                    }
                }
                printf("        (%d Interface%s)\n\n", cInterfaces, (cInterfaces != 1) ? "s" : "");

                
                pObjectInfo->Release();
            }
            else
            {
                printf("  GetObjectInfo %d failed with 0x%08x\n", i, hr);
            }
        }

        pState->Release();    
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\aggid.cxx ===
//+-------------------------------------------------------------------
//
//  File:       aggid.cxx
//
//  Contents:   aggregated identity object and creation function
//
//  History:    30-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <aggid.hxx>        // CAggStdId


//+-------------------------------------------------------------------
//
//  Member:     CAggId::CAggId, public
//
//  Synopsis:   ctor for aggregated identity object
//
//  Arguments:  [ppunkInternal] - returned IUnknown of CStdIdentity
//
//  History:    30-Oct-96   Rickhi      Created
//              10-Jan-97   Gopalk      Added the clsid argument
//              12-Mar-98   Gopalk      Modified for new ID Tables
//
//--------------------------------------------------------------------
CAggId::CAggId(REFCLSID clsid, HRESULT &hr)
    : _cRefs(1),
      _punkInner(NULL)
{
    // Create StdID as an inner object
    hr = CreateIdentityHandler((IUnknown *) this,
                               STDID_CLIENT | STDID_AGGID,
                               NULL, GetCurrentApartmentId(),
                               IID_IStdIdentity,
                               (void **) &_pStdId);

    if (FAILED(hr))
		return;

    _pStdId->SetHandlerClsid(clsid);

    ComDebOut((DEB_MARSHAL, "CAggId::CAggId created %x\n", this));
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::~CAggId, private
//
//  Synopsis:   dtor for aggregated identity object
//
//  History:    30-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
CAggId::~CAggId()
{
    ComDebOut((DEB_MARSHAL, "CAggId::~CAggId called. this:%x\n", this));

    IUnknown *punkInner = _punkInner;
    _punkInner = NULL;

    if (punkInner)
    {
        punkInner->Release();
    }

    // release the last reference on the internal unk that was added
    // when the internal unk was initially created.
	if(_pStdId)
	{
	    ULONG RefsOnStdId = (_pStdId->GetInternalUnk())->Release();
        Win4Assert(RefsOnStdId==0);
	}

    ComDebOut((DEB_MARSHAL, "CAggId::~CAggId destroyed %x\n", this));
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::QueryInterface, public
//
//  Synopsis:   Queries for the requested interface
//
//  Arguments:  [riid]   - interface iid to return to caller
//              [ppv]    - where to put that interface
//
//  History:    31-Oct-96   Rickhi  Created.
//              13-Jan-97   Gopalk  Create handler as the inner object
//                                  (if needed due to race conditions
//                                  during unmarshaling)
//
//--------------------------------------------------------------------
STDMETHODIMP CAggId::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = IsImplementedInterface(riid, ppv);
    if (FAILED(hr))
    {
        // Create handler as the inner object if needed. This case can
        // arise if interfaces on the server object are being
        // unmarshaled simulataneously
        if(!_punkInner)
            hr = CreateHandler(_pStdId->GetHandlerClsid());

        // Delegate the QI to the handler
        if(_punkInner)
            hr = _punkInner->QueryInterface(riid, ppv);
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::QueryMultipleInterfaces, public
//
//  Synopsis:   return interfaces asked for.
//
//  Arguements: [cMQIs] - count of MULTI_QI structs
//              [pMQIs] - array of MULTI_QI structs
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CAggId::QueryMultipleInterfaces(ULONG cMQIs, MULTI_QI *pMQIs)
{
    HRESULT hr = S_OK;

    // fill in the interfaces this object supports
    ULONG     cMissing = 0;
    MULTI_QI *pMQINext = pMQIs;

    for (ULONG i=0; i<cMQIs; i++, pMQINext++)
    {
        if (pMQINext->pItf == NULL)
        {
            // higher level guy did not yet fill in the interface. Check
            // if we support it.

            pMQINext->hr = IsImplementedInterface(*(pMQINext->pIID),
                                                  (void **)&pMQINext->pItf);
            if (FAILED(pMQINext->hr))
            {
                cMissing++; // count one more missing interface
            }
        }
    }

    if (cMissing > 0)
    {
        // there are more interfaces left, QI the handler to get the
        // rest of the interfaces.
        IMultiQI *pMQI = NULL;
        hr = _punkInner->QueryInterface(IID_IMultiQI, (void **)&pMQI);
        if (SUCCEEDED(hr))
        {
            // handler implements MultiQI, use it.
            hr = pMQI->QueryMultipleInterfaces(cMQIs, pMQIs);
            pMQI->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::IsImplementedInterface, private
//
//  Synopsis:   Internal routine common to QueryInterface and
//              QueryMultipleInterfaces. Returns interfaces supported
//              by this object.
//
//  Arguments:  [riid]   - interface iid to return to caller
//              [ppv]    - where to put that interface
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
HRESULT CAggId::IsImplementedInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IMultiQI))
    {
        *ppv = (IMultiQI *)this;
    }
    else if (IsEqualIID(riid, IID_IStdIdentity))
    {
        *ppv = (void *)_pStdId;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)(*ppv))->AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::AddRef, public
//
//  Synopsis:   increments the reference count on the object
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAggId::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::Release, public
//
//  Synopsis:   decrements the reference count on the object
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAggId::Release(void)
{
    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL  fTryToDelete = InterlockedDecRefCnt(&_cRefs, &cNewRefs);

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry
        if ((_pStdId == NULL) || IsOKToDeleteClientObject(_pStdId, &_cRefs))
        {
            // the refcnt did not change while we acquired the lock
            // (i.e. the idtable did not just hand out a reference).
            // OK to delete the identity object.
            delete this;
            break;  // all done. the entry has been deleted.
        }

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&_cRefs, &cNewRefs);
    }

    return (cNewRefs & ~CINDESTRUCTOR);
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::SetHandler, public
//
//  Synopsis:   Sets the handler
//
//  Arguments:  [punkInner] [in]  - IUnknown pointer to inner object
//
//  History:    13-Jan-97   Gopalk  Created. This method is also used
//                                  during Default handler creation
//--------------------------------------------------------------------
STDMETHODIMP CAggId::SetHandler(IUnknown *punkInner)
{
    ComDebOut((DEB_MARSHAL,
               "CAggId::SetHandler this:%x punkInner:%x _punkInner:%x\n",
               this, punkInner, _punkInner));
    Win4Assert(punkInner);

    // Initialize hr to return E_FAIL
    HRESULT hr = E_FAIL;

    // Set the _punkInner after aquiring the lock
    if (InterlockedCompareExchangePointer((void **)&_punkInner,
                                          punkInner, NULL) == NULL)
    {
        // AddRef the new handler as it is an IN parameter and
        // we are caching a pointer to it
        _punkInner->AddRef();
        hr = S_OK;
    }

    ComDebOut((DEB_MARSHAL, "CAggId::SetHandler this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::CreateHandler, private
//
//  Synopsis:   creates the client handler
//
//  Arguments:  [rclsid] - class of client handler to create
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
HRESULT CAggId::CreateHandler(REFCLSID rclsid)
{
    ComDebOut((DEB_MARSHAL,
        "CAggId::CreateHandler this:%x clsid:%I\n", this, &rclsid));

    // create the handler, 'this' acts as the controlling unknown.
    IUnknown *punkOuter = (IUnknown *)this;
    IUnknown *punkInner = NULL;

    DWORD dwFlags = CLSCTX_INPROC_HANDLER | CLSCTX_NO_CODE_DOWNLOAD;
    dwFlags |= (gCapabilities & EOAC_NO_CUSTOM_MARSHAL) ? CLSCTX_NO_CUSTOM_MARSHAL : 0;

    HRESULT hr = CoCreateInstance(rclsid, punkOuter, dwFlags,
                                  IID_IUnknown, (void **)&punkInner);

    if (SUCCEEDED(hr))
    {
        // set the handler
        SetHandler(punkInner);

        // it is possible for two or more threads to simultaneously
        // unmarshal the interface. Consequently the following will
        // release the handler instances that have not been utilized
        // as the inner object
        punkInner->Release();
    }

    ComDebOut((DEB_MARSHAL,
        "CAggId::CreateHandler this:%x hr:%x _punkInner:%x\n",
        this, hr, _punkInner));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CreateClientHandler, private
//
//  Synopsis:   Creates a client side identity object that aggregates
//              an application supplied handler object.
//
//  Arguments:  [rclsid] - class of handler to create
//              [rmoid]  - Identity of object
//              [ppStdId]- place to return identity
//
//  History:    30-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL CreateClientHandler(REFCLSID rclsid, REFMOID rmoid,DWORD dwAptId,
                             CStdIdentity **ppStdId)
{
    ComDebOut((DEB_MARSHAL, "CreateClientHandler rclsid:%I rmoid:%I ppStdId:%x\n",
        &rclsid, &rmoid, ppStdId));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // First thing we do is create an instance of the CAggId, which
    // will serve as the system-supplied controlling unknown for the
    // client object, as well as the OID for the OID table and the
    // marshaling piece.

    HRESULT hr = E_OUTOFMEMORY;

	// CAggId::CAggId ends up calling CreateIdentityHandler which must be called WITHOUT
	// the gComLock
    CAggId *pAID = new CAggId(rclsid, hr);
    if(SUCCEEDED(hr))
    {
		// We have now created a new CAggId which aggregates a CStdIdentity.
		// Check to see whether another thread beat us to registering it.  If not, 
		// then we will set this one.
	    LOCK(gComLock);
	    CStdIdentity *pTempId = NULL;
		HRESULT hrTemp = ObtainStdIDFromOID(rmoid, dwAptId, TRUE, &pTempId);
		if(FAILED(hrTemp))
		{
			// There still wasn't an entry, so set our entry and continue
			// Once we've registered the ID, it's OK to release the lock.
			hr = pAID->SetOID(rmoid);
			UNLOCK(gComLock);
		}
		else
		{
			// Another thread beat us, use their entry, and we're done (no need to continue on 
			// with creating the handler, so we Exit).
			UNLOCK(gComLock);
			*ppStdId = pTempId;
			goto Exit;
		}
    }
		
    // Make sure we don't hold the lock while creating the
    // handler since this involves running app code.
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (SUCCEEDED(hr))
    {
        // now create an instance of the handler. the handler will
        // create an aggregated instance of the remoting piece via
        // a nested call to the CoGetStdMarshalEx API. The
        // end result is the client handler sandwiched between the
        // CAggId controling unknown and the
        // CStdIdentity::CInternalUnk. That way, the system
        // controlls the inner and outer pieces of the object.

        hr = pAID->CreateHandler(rclsid);

        if (SUCCEEDED(hr))
        {
            hr = pAID->QueryInterface(IID_IStdIdentity, (void **)ppStdId);
        }
    }

Exit:

    ASSERT_LOCK_NOT_HELD(gComLock);

	if(pAID)
        pAID->Release();

    ComDebOut((DEB_MARSHAL, "CreateClientHandler hr:%x *ppStdId:%x\n",
            hr, *ppStdId));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\callctrl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       callctrl.cxx
//
//  Contents:   Contains the ORPC CallControl code
//
//  History:    21-Dec-93 Johannp   Original Version
//              04-Nov-94 Rickhi    ReWrite as layer over channel
//
//--------------------------------------------------------------------------
#include <ole2int.h>
#include <thkreg.h>             // OLETHK_ defines
#include <dde.h>
#include <callctrl.hxx>
#include <objsrv.h>             // IID_ILocalSystemActivator
#include <callmgr.hxx>
#include <ctxchnl.hxx>          // gCtxHook
#include <excepn.hxx>
#include <reghelp.hxx>

// private defines used only in this file
#define WM_SYSTIMER             0x0118
#define SYS_ALTDOWN             0x2000
#define WM_NCMOUSEFIRST         WM_NCMOUSEMOVE
#define WM_NCMOUSELAST          WM_NCMBUTTONDBLCLK


// empty slot in window registration
#define WD_EMPTY    (HWND)-1

BOOL gAutoInputSync = FALSE;

// the following table is used to quickly determine what windows
// message queue inputflag to specify for the various categories of
// outgoing calls in progress. The table is indexed by CALLCATEGORY.

DWORD gMsgQInputFlagTbl[4] = {
    QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,  // NOCALL
    QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,  // SYNCHRONOUS
    QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,  // ASYNC
    QS_SENDMESSAGE};                                // INPUTSYNC


// the following table is used to map bit flags in the Rpc Message to
// the equivalent OLE CALLCATEGORY.

DWORD gRpcFlagToCallCatMap[3] = {
    CALLCAT_SYNCHRONOUS,                // no flags set
    CALLCAT_INPUTSYNC,                  // RPCFLG_INPUT_SYNCHRONOUS
    CALLCAT_ASYNC};                     // RPCFLG_ASYNCHRONOUS


// prototypes
HRESULT CopyMsgForRetry(RPCOLEMESSAGE *pMsg,
                        IInternalChannelBuffer *pChnl,
                        HRESULT hrIn);

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterMessageFilter, public
//
//  Synopsis:   registers an applications message filter with the call control
//
//  Arguments:  [pMsgFilter] - message filter to register
//              [ppMsgFilter] - optional, where to return previous IMF
//
//  Returns:    S_OK - registered successfully
//
//  History:    21-Dec-93 JohannP  Created
//
//--------------------------------------------------------------------------
STDAPI CoRegisterMessageFilter(LPMESSAGEFILTER  pMsgFilter,
                               LPMESSAGEFILTER *ppMsgFilter)
{
    ComDebOut((DEB_MFILTER, "CoRegisterMessageFilter pMF:%x ppMFOld:%x\n",
               pMsgFilter, ppMsgFilter));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMessageFilter,(IUnknown **)&pMsgFilter);

    // validate the parameters. NULL acceptable for either or both parameters.
    if (pMsgFilter != NULL && !IsValidInterface(pMsgFilter))
    {
        return E_INVALIDARG;
    }

    if(ppMsgFilter != NULL && !IsValidPtrOut(ppMsgFilter, sizeof(ppMsgFilter)))
    {
        return E_INVALIDARG;
    }

    // this operation is not allowed on MTA Threads
    if (IsMTAThread())
        return CO_E_NOT_SUPPORTED;

    // find the callcontrol for this apartment and replace the existing
    // message filter. if no callctrl has been created yet, just stick
    // the pMsgFilter in tls.

    COleTls tls;
    CAptCallCtrl *pACC = tls->pCallCtrl;

    IMessageFilter *pOldMF;

    if (pACC)
    {
        pOldMF = pACC->InstallMsgFilter(pMsgFilter);
    }
    else
    {
        pOldMF = tls->pMsgFilter;

        if (pMsgFilter)
        {
            pMsgFilter->AddRef();
        }
        tls->pMsgFilter = pMsgFilter;
    }
    if (ppMsgFilter)
    {
        // return old MF to the caller
        *ppMsgFilter = pOldMF;
    }
    else if (pOldMF)
    {
        // release the old MF
        pOldMF->Release();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::InstallMsgFilter
//
//  Synopsis:   called to install a new application provided message filter
//
//  Arguments:  [pMF] - new message filter to install (or NULL)
//
//  Returns:    previous message filter if there was one
//
//  History:    20-Dec-93   JohannP Created
//
//--------------------------------------------------------------------------
INTERNAL_(IMessageFilter *) CAptCallCtrl::InstallMsgFilter(IMessageFilter *pMF)
{
    IMessageFilter *pMFOld = _pMF;      //  save the old one to return

    _pMF = pMF;                         //  install the new one
    if (_pMF)
    {
        _pMF->AddRef();
    }

    return pMFOld;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::CAptCallCtrl
//
//  Synopsis:   constructor for per apartment call control state
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
CAptCallCtrl::CAptCallCtrl() :
    _fInMsgFilter(FALSE),
    _pTopCML(NULL)
{
    // The first one is reserved for ORPC. An hWnd value of WD_EMPTY
    // means the slot is available.
    _WD[0].hWnd = WD_EMPTY;

    // The second slot has fixed values for DDE
    _WD[1].hWnd      = NULL;
    _WD[1].wFirstMsg = WM_DDE_FIRST;
    _WD[1].wLastMsg  = WM_DDE_LAST;

    // put our pointer into thread local storage, and retrieve any previously
    // registered message filter.

    COleTls tls;
    tls->pCallCtrl = this;

    _pMF = tls->pMsgFilter;
    tls->pMsgFilter = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::~CAptCallCtrl
//
//  Synopsis:   destructor for per apartment call control state
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
CAptCallCtrl::~CAptCallCtrl()
{
    Win4Assert(_pTopCML == NULL);   // no outgoing calls.

    if (_pMF)
    {
        _pMF->Release();
    }

    // remove our pointer from thread local storage
    COleTls tls;
    tls->pCallCtrl = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::Register/Revoke
//
//  Synopsis:   register or revoke RPC window data
//
//  Arguments:  [hWnd]      - window handle to look for calls on
//              [wFirstMsg] - msgid of first message in range to look for
//              [wLastMsg]  - msgid of last message in range to look for
//
//  Returns:    nothing
//
//  Notes:      This code is only ever called by the RpcChannel and by
//              the DDE layer, and so error checking is kept to a minimum.
//
//  History:    30-Apr-95 Rickhi    Created
//
//--------------------------------------------------------------------------
void CAptCallCtrl::Register(HWND hWnd, UINT wFirstMsg, UINT wLastMsg)
{
    Win4Assert(_WD[0].hWnd == WD_EMPTY && "Register Out of Space");

    _WD[0].hWnd      = hWnd;
    _WD[0].wFirstMsg = wFirstMsg;
    _WD[0].wLastMsg  = wLastMsg;
}

void CAptCallCtrl::Revoke(HWND hWnd)
{
    Win4Assert(_WD[0].hWnd == hWnd && "Revoke not found");
    _WD[0].hWnd = WD_EMPTY;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetSlowTimeFactor
//
//  Synopsis:   Get the time slowing factor for Wow apps
//
//  Returns:    The factor by which we need to slow time down.
//
//  Algorithm:  If there is a factor in the registry, we open and read the
//              registry. Otherwise we just set it to the default.
//
//  History:    22-Jul-94 Ricksa    Created
//              09-Jun-95 Susia     ANSI Chicago optimization
//
//--------------------------------------------------------------------------
DWORD GetSlowTimeFactor(void)
{
    // Default slowing time so we can just exit if there is no key which
    // is assumed to be the common case.
    DWORD dwSlowTimeFactor = OLETHK_DEFAULT_SLOWRPCTIME;

    // Key for reading the value from the registry
    HKEY hkeyOleThk;

    // Get the Ole Thunk special value key
    LONG lStatus = OpenClassesRootKeyEx(OLETHK_KEY, KEY_READ,&hkeyOleThk);

    if (lStatus == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSizeData = sizeof(dwSlowTimeFactor);

        lStatus = RegQueryValueEx(hkeyOleThk, OLETHK_SLOWRPCTIME_VALUE, NULL,
            &dwType, (LPBYTE) &dwSlowTimeFactor, &dwSizeData);

        if ((lStatus != ERROR_SUCCESS) || dwType != REG_DWORD)
        {
            // Guarantee that value is reasonable if something went wrong.
            dwSlowTimeFactor = OLETHK_DEFAULT_SLOWRPCTIME;
        }

        // Close the key since we are done with it.
        RegCloseKey(hkeyOleThk);
    }

    return dwSlowTimeFactor;
}

//+-------------------------------------------------------------------------
//
//  Function:   CanMakeOutCall
//
//  Synopsis:   called when the client app wants to make an outgoing call to
//              determine if it is OK to do it now or not. Common subroutine
//              to CAptRpcChnl::GetBuffer and RemoteReleaseRifRef
//
//  Arguments:  [dwCallCatOut] - call category of call the app wants to make
//              [pChnl] - ptr to channel call is being made on
//              [riid] - interface call is being made on
//
//  Returns:    S_OK - ok to make the call
//              RPC_E_CANTCALLOUT_INEXTERNALCALL - inside IMessageFilter
//              RPC_E_CANTCALLOUT_INASYNCCALL - inside async call
//              RPC_E_CANTCALLOUT_ININPUTSYNCCALL - inside input sync or SendMsg
//
//  History:    21-Dec-93 Johannp   Original Version
//              04-Nov-94 Rickhi    ReWrite
//              03-Oct-95 Rickhi    Made into common subroutine
//
//--------------------------------------------------------------------------
INTERNAL CanMakeOutCall(DWORD dwCallCatOut, REFIID riid, RPCOLEMESSAGE *pMsg)
{
    // get the topmost incoming call state from Tls.

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    CSrvCallState *pSCS = tls->pTopSCS;

    DWORD dwCallCatIn = (pSCS) ? pSCS->GetCallCatIn() : CALLCAT_NOCALL;

    // if handling an incoming ASYNC call, only allow ASYNC outgoing calls,
    // and local calls on IRemUnknown (which locally is actually IRundown).

    if (dwCallCatIn  == CALLCAT_ASYNC &&
        dwCallCatOut != CALLCAT_ASYNC &&
        !IsEqualGUID(riid, IID_IRundown) )
    {
        return RPC_E_CANTCALLOUT_INASYNCCALL;
    }

    // if handling an incoming INPUTSYNC call, or if we are handling a
    // SendMessage, dont allow SYNCHRONOUS calls out or we could deadlock
    // since SYNC uses PostMessage and INPUTSYNC uses SendMessage.

    if (dwCallCatOut == CALLCAT_SYNCHRONOUS &&
        (dwCallCatIn == CALLCAT_INPUTSYNC ||
            (SSInSendMessageEx(NULL) & ISMEX_SEND) ))
    {
        if(pMsg != NULL && TRUE == gAutoInputSync)
        {
            //Convert the synchronous call to an input_sync call
            //so that we can make an outgoing call while
            //processing a SendMessage.  Some ActiveX controls and DocObjects
            //require this behavior in order to run cross-thread or cross-process.

            pMsg->rpcFlags |= RPCFLG_INPUT_SYNCHRONOUS;
        }
        else
        {
            return RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::CAptRpcChnl/~CAptRpcChnl
//
//  Synopsis:   constructor/destructor
//
//  Parameters: [pStdId] - std identity for the object
//              [pOXIDEntry] - OXIDEntry for the object server
//              [eState] - state flags passed thru to CRpcChannelBuffer
//                         (ignored by CAptRpcCnl).
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
CAptRpcChnl::CAptRpcChnl(CStdIdentity *pStdId,
                         OXIDEntry *pOXIDEntry,
                         DWORD eState) :
    CRpcChannelBuffer(pStdId, pOXIDEntry, eState),
    _dwTIDCallee(pOXIDEntry->GetTid()),
    _dwAptId(GetCurrentApartmentId())
{
    ComDebOut((DEB_CALLCONT,"CAptRpcChnl::CAptRpcChnl this:%x\n", this));
}

CAptRpcChnl::~CAptRpcChnl()
{
    ComDebOut((DEB_CALLCONT,"CAptRpcChnl::~CAptRpcChnl this:%x\n", this));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::GetBuffer
//
//  Synopsis:   Ensure it is legal to call out now, then get a buffer.
//
//  Parameters: [pMsg] - ptr to message structure
//              [riid] - interface call is being made on
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::GetBuffer(RPCOLEMESSAGE *pMsg, REFIID riid)
{
    HRESULT hr = S_OK;

    // Make sure we are allowed to make this outgoing call. We do that here
    // so that we dont marshal all the parameters only to discover that we
    // cant call out and then have to free all the marshalled parameters
    // (especially the ones where marshalling has side effects).

    if (!(_dwAptId == GetCurrentApartmentId() || CallableOnAnyApt()))
    {
        // we are not being called in the correct apartment
        CoVrfNotifySmuggledProxy(riid, pMsg->iMethod, _dwAptId);
        return RPC_E_WRONG_THREAD;
    }

    // If we are on the server side, everything is ok.
    if (IsClientSide())
    {
        if (IsMTAThread())
        {
            if (pMsg->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
            {
                // dont allow INPUTSYNC calls from an MTA apartment to anybody.
                return RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
            }

            // All ASYNC calls from an MTA apartment are treated as SYNCHRONOUS,
            // so convert the call category here before proceeding.

            pMsg->rpcFlags &= ~RPCFLG_ASYNCHRONOUS;
        }
        else
        {
            // dont allow the application to call out while handling an
            // IMessageFilter call because it screws up the call sequencing.

            COleTls tls;
            CAptCallCtrl *pACC = tls->pCallCtrl;
            if (pACC && pACC->InMsgFilter())
            {
                ComDebOut((DEB_ERROR, "Illegal callout from within IMessageFilter\n"));
                return RPC_E_CANTCALLOUT_INEXTERNALCALL;
            }

            // Only set the old style async bit for the two old style interfaces.
            if ((pMsg->rpcFlags & RPC_BUFFER_ASYNC) &&
                (riid == IID_AsyncIAdviseSink || riid == IID_AsyncIAdviseSink2))
                pMsg->rpcFlags |= RPCFLG_ASYNCHRONOUS;

            // if the call is async and remote, or async and to an MTA apartment,
            // then change the category to sync, since we dont support async remotely
            // or to MTA apartments locally. This must be done before calling
            // CanMakeOutCall in order to avoid deadlocks. If the call is input sync
            // and remote or to an MTA apartment, dissallow the call.

            if (pMsg->rpcFlags & (RPCFLG_ASYNCHRONOUS | RPCFLG_INPUT_SYNCHRONOUS))
            {
                DWORD dwCtx;
                CRpcChannelBuffer::GetDestCtx(&dwCtx, NULL);

                if (dwCtx == MSHCTX_DIFFERENTMACHINE ||
                    (GetOXIDEntry()->IsMTAServer()))
                {
                    if (pMsg->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
                        return RPC_E_CANTCALLOUT_ININPUTSYNCCALL;

                    // turn off the async flag so that the call looks (and acts)
                    // like it is synchronous.
                    pMsg->rpcFlags &= ~RPCFLG_ASYNCHRONOUS;
                }
            }

            // Make sure we are allowed to make this outgoing call. We do that here
            // so that we dont marshal all the parameters only to discover that we
            // cant call out and then have to free all the marshalled parameters
            // (especially the ones where marshalling has side effects).

            // figure out the call category of this call by looking at bit
            // values in the rpc message flags.

            DWORD dwCallCatOut = RpcFlagToCallCat(pMsg->rpcFlags);

            // check other outgoing call restrictions common to multi and single
            // threaded apartments

            hr = CanMakeOutCall(dwCallCatOut, riid, pMsg);
        }
    }

    if (hr == S_OK)
    {
        // ask the real channel for a buffer.
        hr =  CRpcChannelBuffer::GetBuffer(pMsg, riid);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::SendReceive
//
//  Synopsis:   in MTA, just call the channel directly.
//              in STA, instantiate a modal loop object and then transmit the call
//
//  Parameters: [pMsg] - ptr to message structure
//              [pulStatus] - place to return a status code
//
//  History:    11-Nov-94   Rickhi      Created
//              11-Feb-98   JohnStra    Added NTA support.
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::SendReceive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    // Get the local OXID Entry
    OXIDEntry* pOXIDEntry = GetOXIDEntry();

    if (IsMTAThread() ||
        (pOXIDEntry->IsNTAServer() &&
         pOXIDEntry->IsInLocalProcess()))
    {
        // We are in the MTA, or, the server we are calling is in the NTA.
        // Just call the channel directly.
        return CRpcChannelBuffer::SendReceive( pMsg, pulStatus );
    }

    // STA. Construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.
    CCliModalLoop CML(_dwTIDCallee, GetMsgQInputFlag(pMsg), 0);

    HRESULT hr;

    do
    {
        hr = CML.SendReceive(pMsg, pulStatus, this);

        if (hr == RPC_E_SERVERCALL_RETRYLATER)
        {
            // the call was rejected by the server and the client Msg Filter
            // decided to retry the call. We have to make a copy of the
            // message and re-send it.
            hr = CopyMsgForRetry(pMsg);
        }
        else if (hr == RPC_E_CALL_REJECTED)
        {
            // the call was rejected by the server and the client Msg Filter
            // decided NOT to retry the call. We have to free the buffer
            // that was returned since the proxy is not expecting it.
            CAptRpcChnl::FreeBuffer(pMsg);
        }

    }  while (hr == RPC_E_SERVERCALL_RETRYLATER);

    return hr;
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Send
//
//  Description:Used during pipe calls to send data.
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//  Notes:      This is also used on the server side since we need
//              a modal loop there also.
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Send(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    if (IsMTAThread())
    {
        // MTA, just call the channel directly
        return CRpcChannelBuffer::Send(pMsg, pulStatus);
    }

    // STA. Construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(_dwTIDCallee, GetMsgQInputFlag(pMsg), 0);
    return CML.Send(pMsg, pulStatus, this);
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Send (IAsyncRpcChannelBuffer)
//
//  Description:Used for async calls
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Send(RPCOLEMESSAGE *pMsg, ISynchronize *pISync)
{
    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Send [in] pMsg:0x%x, pISync:0x%x\n",
                 pMsg, pISync));

    HRESULT hr = S_OK;
    if (pISync)
    {
        hr = RegisterAsync(pMsg, (IAsyncManager *) pISync);
    }

    if (SUCCEEDED(hr))
    {
        ULONG status;
        hr = Send(pMsg, &status);
        if (FAILED(hr))
        {
            pISync->Signal();
            pISync->Release();
        }
    }

    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Send [out] hr:0x%x\n", hr));
    return hr;
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Receive
//
// Description: Used to receive data during pipe calls.
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Receive(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
{
    if (IsMTAThread())
    {
        // MTA, just call the channel directly
        return CRpcChannelBuffer::Receive(pMsg, uSize, pulStatus);
    }

    // STA. Construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(_dwTIDCallee, GetMsgQInputFlag(pMsg), 0);
    return CML.Receive(pMsg, uSize, pulStatus, this);
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Receive (IAsyncRpcChannelBuffer)
//
// Description: Used to receive data during async calls.
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Receive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Receive [in] pMsg:0x%x, pulStatus:0x%x\n",
                 pMsg, pulStatus));
    HRESULT hr = Receive(pMsg, 0, pulStatus);
    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Receive [out] hr:0x%x\n", hr));
    return hr;
}

//--------------------------------------------------------------------------
//
//  Function:   GetMsgQInputFlag
//
// Description: Determines the callcat of the call
//
//--------------------------------------------------------------------------
DWORD GetMsgQInputFlag(RPCOLEMESSAGE *pMsg)
{
    // Figure out the call category of this call by looking at the bit
    // values in the rpc message flags.

    DWORD dwCallCatOut    = RpcFlagToCallCat(pMsg->rpcFlags);
    DWORD dwMsgQInputFlag = gMsgQInputFlagTbl[dwCallCatOut];

    // Now for a spectacular hack. IRemUnknown::Release had slightly
    // different dwMsgQInputFlag semantic in the old code base, so we
    // check for that one case here and set the flag accordingly. Not
    // doing this would allow SYSCOMMAND calls in during Release which
    // we throw away, thus preventing an app from shutting down correctly.
    // SimpSvr.exe is a good example of this.

    if ((pMsg->iMethod & ~RPC_FLAGS_VALID_BIT) == 5 &&
        (IsEqualIID(IID_IRundown, *MSG_TO_IIDPTR(pMsg)) ||
         IsEqualIID(IID_IRemUnknown, *MSG_TO_IIDPTR(pMsg))))
    {
        dwMsgQInputFlag = (QS_POSTMESSAGE | QS_SENDMESSAGE | QS_TRANSFER |
                           QS_ALLPOSTMESSAGE);
    }

    return dwMsgQInputFlag;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::CopyMsgForRetry
//
//  Synopsis:   Makes a copy of the message we sent. We have to ask Rpc
//              for another buffer and then copy the original buffer into
//              the new one so we can make another call.
//
//  Parameters: [pMsg] - ptr to message structure to copy
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CAptRpcChnl::CopyMsgForRetry(RPCOLEMESSAGE *pMsg)
{
    ComDebOut((DEB_CALLCONT,"CAptRpcChnl::CopyMsgForRetry pMsg:%x\n", pMsg));

    // CODEWORK: this is dumb, but the channel blows chunks in FreeBuffer
    // if i dont do this double copy.

    void *pTmpBuf = PrivMemAlloc(pMsg->cbBuffer);
    if (pTmpBuf)
    {
        memcpy(pTmpBuf, pMsg->Buffer, pMsg->cbBuffer);
    }

    // save copy of the contents of the old message so we can free it later

    HRESULT hr = E_OUTOFMEMORY;
    CCtxCall *pCtxCall = ((CMessageCall *) pMsg->reserved1)->GetClientCtxCall();

    // Free current message
    CAptRpcChnl::FreeBuffer(pMsg);

    if (pTmpBuf)
    {
        // Inform context hook that the call is being retried
        gCtxHook.PrepareForRetry(pCtxCall);

        // Store context call object in TLS
        COleTls Tls;
        CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

        // allocate a new message, dont have to worry about checking the
        // CanMakeOutCall again, so we just ask the Rpc channel directly.
        pMsg->reserved1 = NULL;

#ifdef _WIN64
        // On a message retry we need to redo what the proxy did during transfer
        // protocol negotiation.
        hr = S_OK;

        if (IsNDRSyntaxNegotiated())
        {
            ClearNDRSyntaxNegotiated();     //Set "Not Negotiated" so errors cases in NegotiateSyntax work
            hr = NegotiateSyntax(pMsg);
        }
        if (SUCCEEDED(hr))
        {
            hr = CRpcChannelBuffer::GetBuffer(pMsg, *MSG_TO_IIDPTR(pMsg));
        }
#else
        hr = CRpcChannelBuffer::GetBuffer(pMsg, *MSG_TO_IIDPTR(pMsg));
#endif

        // Revoke context call object from TLS
        pCtxCall->RevokeFromTLS(Tls, pCurCall);

        if (SUCCEEDED(hr))
        {
            // Save the context call object inside message call
            ((CMessageCall *) pMsg->reserved1)->SetClientCtxCall(pCtxCall);

            // copy the temp buffer into the new buffer
            memcpy(pMsg->Buffer, pTmpBuf, pMsg->cbBuffer);
            hr = RPC_E_SERVERCALL_RETRYLATER;
        }

        PrivMemFree(pTmpBuf);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::SendReceive
//
//  Synopsis:   called to transmit a call to the server and enter a modal
//              loop.
//
//  Arguments:  [pMsg] - message to send
//              [pulStatus] - place to return status code
//              [pChnl] - IRpcChannelBuffer pointer
//
//  Returns:    result of the call. May return RETRYLATER if the call should
//              be retransmitted.vv
//
//  History:    11-Nov-94       Rickhi      Created
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::SendReceive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus,
                                    IInternalChannelBuffer *pChnl)
{
    // SendReceive is a blocking call. The channel will transmit the call
    // asynchronously then call us back in BlockFn where we wait for an
    // event such as the call completing, or a windows message arriving,
    // or the user cancelling the call. Because of the callback, we need
    // to set _hr before calling SR.

    _hr = RPC_S_CALLPENDING;
    _hr = pChnl->SendReceive2(pMsg, pulStatus);

    // By this point the call has completed. Now check if it was rejected
    // and if so, whether we need to retry immediately, later, or never.
    // Handling of Rejected calls must occur here, not in the BlockFn, due
    // to the fact that some calls and some protocols are synchronous, and
    // other calls and protocols are asynchronous.

    if (_hr == RPC_E_CALL_REJECTED || _hr == RPC_E_SERVERCALL_RETRYLATER)
    {
        // this function decides on 1 of 3 different courses of action
        // 1. fail the call     - sets the state to Call_Rejected
        // 2. retry immediately - sets _hr to RETRYLATER, fall out
        // 3. retry later       - starts the timer, we block below

        _hr = HandleRejectedCall(pChnl);

        // if a timer was installed to retry the call later, then we have
        // to go into modal loop until the timer expires. if the call is
        // cancelled while in this loop, the loop will be exited.

        while (!IsTimerAtZero())
        {
            BlockFn(NULL, 0, NULL);
        }

        // Either it is time to retransmit the call, or the call was
        // cancelled or rejected.
    }

    return _hr;
}

//--------------------------------------------------------------------------
//
// Member:      CCliModalLoop::Send
//
// Description: Used for pipe calls.
//
//  History:    15-Feb-97       RichN      Created
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::Send(RPCOLEMESSAGE *pMsg, ULONG *pulStatus,
                             IInternalChannelBuffer *pChnl)
{
    _hr = RPC_S_CALLPENDING;
    _hr = pChnl->Send2(pMsg, pulStatus);
    return _hr;
}

//--------------------------------------------------------------------------
//
// Member:      CCliModalLoop::Receive
//
// Description: Used for pipe calls.
//
//  History:    15-Feb-97       RichN      Created
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::Receive(RPCOLEMESSAGE *pMsg,
                                ULONG uSize,
                                ULONG *pulStatus,
                                IInternalChannelBuffer *pChnl)
{
    _hr = RPC_S_CALLPENDING;
    _hr = pChnl->Receive2(pMsg, uSize, pulStatus);
    return _hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::HandleRejectedCall
//
//  Synopsis:   called when the response to a remote call is rejected or
//              retry later.
//
//  Arguments:  [pChnl] - channel we are calling on.
//
//  Returns:    RPC_E_CALL_REJECTED - call is rejected
//              RPC_E_SERVERCALL_RETRYLATER - the call should be retried
//                      (Timer is set if retry is to be delayed)
//
//  Algorithm:  Calls the app's message filter (if there is one) to
//              determine whether the call should be failed, retried
//              immediately, or retried at some later time. If there is
//              no message filter, or the client is on a different machine,
//              then the call is always rejected.
//
//  History:    21-Dec-93 Johannp   Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::HandleRejectedCall(IInternalChannelBuffer *pChnl)
{
    // default return value - rejected
    DWORD dwRet = 0xffffffff;

    DWORD dwDestCtx;
    HRESULT hr = ((IRpcChannelBuffer3 *)pChnl)->GetDestCtx(&dwDestCtx, NULL);

    if (SUCCEEDED(hr) && dwDestCtx != MSHCTX_DIFFERENTMACHINE)
    {
        // the call is local to this machine, ask the message filter
        // what to do.  For remote calls we never allow retry, since
        // the parameters were not sent back to us in the packet.

        IMessageFilter *pMF = _pACC->GetMsgFilter();
        if (pMF)
        {
            ComDebOut((DEB_MFILTER,
                "pMF->RetryRejectedCall(dwTIDCallee:%x ElapsedTime:%x Type:%x)\n",
                    _dwTIDCallee, GetElapsedTime(),
                    (_hr == RPC_E_CALL_REJECTED) ? SERVERCALL_REJECTED
                                                 : SERVERCALL_RETRYLATER));

            dwRet = pMF->RetryRejectedCall((MF_HTASK)LongToPtr(_dwTIDCallee), GetElapsedTime(),
                         (_hr == RPC_E_CALL_REJECTED) ? SERVERCALL_REJECTED
                                                      : SERVERCALL_RETRYLATER);

            ComDebOut((DEB_MFILTER,"pMF->RetryRejected() dwRet:%x\n", dwRet));

            _pACC->ReleaseMsgFilter();
        }
    }

    if (dwRet == 0xffffffff)
    {
        // Really rejected. Mark it as such incase it was actually
        // Call_RetryLater, also ensures that IsWaiting returns FALSE
        return RPC_E_CALL_REJECTED;
    }
    else if (dwRet >= 100)
    {
        // Retry Later. Start the timer. This ensures that IsTimerAtZero
        // returns FALSE and IsWaiting returns TRUE
        return StartTimer(dwRet);
    }
    else
    {
        // Retry Immediately. The state is set so that IsTimerAtZero
        // returns TRUE.

        Win4Assert(IsTimerAtZero());
        return RPC_E_SERVERCALL_RETRYLATER;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   OleModalLoopBlockFn
//
//  Synopsis:   Called by the RpcChannel during an outgoing call while
//              waiting for the reply message.
//
//  Arguments:  [pvWnd] - Window handle to expect the reply on
//              [pvCtx] - Call Context (the CCliModalLoop)
//              [hCallWaitEvent] - optional event to have CallControl wait on
//
//  Returns:    result of the call
//
//  Algorithm:  pvCtx is the topmost modal loop for the current apartment.
//              Just call it's block function.
//
//  History:    Dec-93   JohannP    Created
//
//--------------------------------------------------------------------------
RPC_STATUS SSAPI(OleModalLoopBlockFn(void *pvWnd, void *pvCtx, HANDLE hCallWaitEvent))
{
    Win4Assert( pvCtx != NULL );
    if (hCallWaitEvent == NULL)
        return ((CCliModalLoop *) pvCtx)->BlockFn(&hCallWaitEvent, 0, NULL);
    else
        return ((CCliModalLoop *) pvCtx)->BlockFn(&hCallWaitEvent, 1, NULL);
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::BlockFn (private)
//
//  Synopsis:   Implements the blocking part of the modal loop. This function
//              blocks until an event of interest occurs, then it goes and
//              processes that event and returns.
//
//  Arguments:  [hCallWaitEvent] - event to wait on (optional)
//
//  Returns:    RPC_S_CALLPENDING - the call is still pending a reply
//              RPC_E_CALL_CANCELLED - the call was cancelled.
//              RPC_E_SERVERCALL_RETRYLATER - the call should be retried later
//
//  History:    Dec-93   JohannP    Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
HRESULT CCliModalLoop::BlockFn(HANDLE *ahEvent, DWORD cEvents,
                               LPDWORD lpdwSignaled)
{
    ComDebOut((DEB_CALLCONT,
        "CCliModalLoop::BlockFn this:%x dwMsgQInputFlag:%x ahEvent:%x\n",
        this, _dwMsgQInputFlag, ahEvent));
    Win4Assert( cEvents != 0 || IsWaiting() && "ModalLoop::BlockFn - not waiting on call");

    // First, we wait for an event of interest to occur, either for the call
    // to complete, or a new windows message to arrive on the queue.

    DWORD   dwWakeReason  = WAIT_TIMEOUT;

    if (cEvents != 0)
    {
        // Check if an event is already signalled. This ensures that
        // when we return from nested calls and the upper calls have already
        // been acknowledged, that no windows messages can come in.

        ComDebOut((DEB_CALLCONT, "WaitForMultipleObject cEvent:%x\n", cEvents));

        dwWakeReason = WaitForMultipleObjectsEx(cEvents,
                                                ahEvent,
                                                _dwWaitFlags&COWAIT_WAITALL,
                                                0,
                                                _dwWaitFlags&COWAIT_ALERTABLE);
    }

    if (dwWakeReason == WAIT_TIMEOUT)
    {
        DWORD dwWaitTime = TicksToWait();

        // If we want to wake up for a posted message, we need to make
        // sure that we haven't missed any because of the queue status
        // being affected by prior PeekMessages. We don't worry about
        // QS_SENDMESSAGE because if PeekMessage got called, the pending
        // send got dispatched. Further, if we are in an input sync call,
        // we don't want to start dispatching regular RPC calls here by
        // accident.

        if (_dwMsgQInputFlag & QS_POSTMESSAGE)
        {
            DWORD dwStatus = GetQueueStatus(_dwMsgQInputFlag);

            // We care about any message on the queue not just new messages
            // because PeekMessage affects the queue state. It resets the
            // state so even if a message is not processed, the queue state
            // represents this as an old message even though no one has
            // ever looked at it. So even though the message queue tells us
            // there are no new messages in the queue. A new message we are
            // interested in could be in the queue.

            WORD wNew = (WORD) dwStatus | HIWORD(dwStatus);

            // Note that we look for send as well as post because our
            // queue status could have reset the state of the send message
            // bit and therefore, MsgWaitForMultipleObject below will not
            // wake up to dispatch the send message.

            if (wNew & (QS_POSTMESSAGE | QS_SENDMESSAGE))
            {
                // the acknowledge message might be already in the queue
                if (PeekRPCAndDDEMessage())
                {
                    // we know that *some* RPC message came in and was
                    // processed. It could have been the Reply we were waiting
                    // for OR some other incoming call. Since we cant tell
                    // which, we return to RPC land. If it was not our Reply
                    // then RPC will call our modal loop again.
                    return _hr;
                }
            }
        }

        ComDebOut((DEB_CALLCONT,
            "Call MsgWaitForMultiple time:%ld, cEvents:%x pEvent:%x,\n",
            dwWaitTime, cEvents, ahEvent ));

        DWORD dwFlags = (_dwWaitFlags & COWAIT_WAITALL) ? MWMO_WAITALL : 0;
        dwFlags |= (_dwWaitFlags & COWAIT_ALERTABLE) ? MWMO_ALERTABLE : 0;
        dwFlags |= (_dwWaitFlags & COWAIT_INPUTAVAILABLE) ? MWMO_INPUTAVAILABLE : 0;

        dwWakeReason = MsgWaitForMultipleObjectsEx(cEvents,
                                                 ahEvent,
                                                 dwWaitTime,
                                                 _dwMsgQInputFlag,
                                                 dwFlags);

        ComDebOut((DEB_CALLCONT,
            "MsgWaitForMultipleObjects hr:%ld\n", dwWakeReason));
    }
    else if (dwWakeReason == WAIT_FAILED)
    {
        // Wait occasionally fails on Win95. Not much we can do here except
        // just exit and retransmit the call
        ComDebOut((DEB_ERROR, "WaitForSingleObject error:%ld\n", GetLastError()));
        Win4Assert((FALSE) && "CCliModalLoop::BlockFn WaitForSingleObject error");
        return(_hr = RPC_E_SERVERCALL_RETRYLATER);
    }


    // OK, we've done whatever blocking we were going to do and now we have
    // been woken up, so figure out what event of interest occured to wake
    // us up and go handle it.

    if (dwWakeReason == (WAIT_OBJECT_0 + cEvents))
    {
        // Windows message came in - go process it
        ComDebOut((DEB_CALLCONT, "BlockFn: Windows Message Arrived\n"));
        HandleWakeForMsg();
    }
    else if (dwWakeReason == WAIT_TIMEOUT)
    {
        if (_hr == RPC_S_WAITONTIMER && IsTimerAtZero())
        {
            // The Retrytimer timed out - just exit and retransmit the call
            ComDebOut((DEB_CALLCONT, "BlockFn: Timer at zero\n"));
            _hr = RPC_E_SERVERCALL_RETRYLATER;
        }
        else
        {
            // we may have missed a message before we called MsgWaitForMult...
            // so we go check now for any incoming messages.
            ComDebOut((DEB_CALLCONT, "BlockFn: Timeout-Look for msgs\n"));
            HandleWakeForMsg();
        }
    }
    else  if (dwWakeReason == 0xffffffff)
    {
        // Wait occasionally fails on Win95. Not much we can do except
        // just exit and retransmit the call.
        ComDebOut((DEB_ERROR, "MsgWaitForMultipleObjects error:%ld\n", GetLastError()));
        Win4Assert((FALSE) && "CCliModalLoop::BlockFn MsgWaitForMultipleObjects error");
        return(_hr = RPC_E_SERVERCALL_RETRYLATER);
    }
    else
    {
        // CallComplete signalled - the call is done.
        ComDebOut((DEB_CALLCONT, "BlockFn: CallComplete Event Signaled\n"));
        if (lpdwSignaled != NULL)
            *lpdwSignaled = dwWakeReason - WAIT_OBJECT_0;
        _hr = S_OK;
    }

    ComDebOut((DEB_CALLCONT, "CCliModalLoop::BlockFn this:%x returns:%x\n",
        this, _hr));
    return _hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::HandleWakeForMsg (private)
//
//  Synopsis:   Handle wake for the arrival of some kind of message
//
//  Returns:    nothing
//              fClearedQueue flag set if appropriate
//
//  Algorithm:  If this is called to wake up for a posted message, we
//              check the queue status. If the message queue status indicates
//              that there is some kind of a modal loop going on, then we
//              clear all the keyboard and mouse messages in our queue. Then
//              if we wake up for all input, we check the message queue to
//              see whether we need to notify the application that a message
//              has arrived. Then, we dispatch any messages that have to do
//              with the ORPC system. Finally we yield just in case we need
//              to dispatch a send message in the VDM. For an input sync
//              RPC, all we do is a call that will yield to get the pending
//              send message dispatched.
//
//  History:    Dec-93   JohannP    Created
//              13-Aug-94 Ricksa    Created
//
//--------------------------------------------------------------------------
INTERNAL_(void) CCliModalLoop::HandleWakeForMsg()
{
    MSG msg;    // Used for various peeks.

    // Is this an input sync call?
    if (_dwMsgQInputFlag != QS_SENDMESSAGE)
    {
        // No, so we have to worry about the state of the message queue.
        // We have to be careful that we aren't holding the input focus
        // on an input synchronized queue.

        // So what is the state of the queue? - note we or QS_TRANSFER because
        // this an undocumented flag which tells us the the input focus has
        // changed to us.

        DWORD dwQueueFlags = GetQueueStatus(QS_ALLINPUT | QS_TRANSFER);
        ComDebOut((DEB_CALLCONT, "Queue Status %lx\n", dwQueueFlags));

        // Call through to the application if we are going to. We do this here
        // so that the application gets a chance to process any
        // messages that it wants to and also allows the call control to
        // dispatch certain messages that it knows how to, thus making the
        // queue more empty.

        if (((_dwMsgQInputFlag & QS_ALLINPUT) == QS_ALLINPUT) &&
              FindMessage(dwQueueFlags))
        {
            // pending message in the queue
            HandlePendingMessage();
        }

        // Did the input focus change to us?
        if ((LOWORD(dwQueueFlags) & QS_TRANSFER) || _dwFlags & CMLF_CLEAREDQUEUE)
        {
            ComDebOut((DEB_CALLCONT, "Message Queue is being cleared\n"));
            _dwFlags |= CMLF_CLEAREDQUEUE;

            // Try to clear the queue as best we can of any messages that
            // might be holding off some other modal loop from executing.
            // So we eat all mouse and key events.
            if (HIWORD(dwQueueFlags) & QS_KEY)
            {
                while (MyPeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,
                    PM_REMOVE | PM_NOYIELD))
                {
                    ;
                }
            }

            // Clear mouse releated messages if there are any
            if (HIWORD(dwQueueFlags) & QS_MOUSE)
            {
                while (MyPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
                    PM_REMOVE | PM_NOYIELD))
                {
                    ;
                }

                while (MyPeekMessage(&msg, NULL, WM_NCMOUSEFIRST,
                    WM_NCMOUSELAST, PM_REMOVE | PM_NOYIELD))
                {
                    ;
                }

                while (MyPeekMessage(&msg, NULL, WM_QUEUESYNC, WM_QUEUESYNC,
                    PM_REMOVE  | PM_NOYIELD))
                {
                    ;
                }
            }

            // Get rid of paint message if we can as well -- this makes
            // the screen look so much better.
            if (HIWORD(dwQueueFlags) & QS_PAINT)
            {
                if (MyPeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_REMOVE | PM_NOYIELD))
                {
                    ComDebOut((DEB_CALLCONT, "Dispatch paint\n"));
                    MyDispatchMessage(&msg);
                }
            }
        }
    }
    else if (!IsWOWThread() || !IsWOWThreadCallable())
    {
        // We need to give user control so that the send message
        // can get dispatched. Thus the following is simply a no-op
        // which gets into user to let it dispatch the message.
        __try
        {
            PeekMessage(&msg, 0, WM_NULL, WM_NULL, PM_NOREMOVE);
        }
        __except (PeekMessageExceptionFilter (GetExceptionInformation()))
        {
        }
    }

    if (IsWOWThread() && IsWOWThreadCallable())
    {
        // In WOW, a genuine yield is the only thing to guarantee
        // that SendMessage will get through
        ComDebOut((DEB_CALLCONT, "YieldTask16\n"));
        g_pOleThunkWOW->YieldTask16();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::PeekRPCAndDDEMessage
//
//  Synopsis:   Called when a windows message arrives to look for incoming
//              Rpc messages which might be the reply to an outstanding call
//              or may be new incoming request messages. Also looks for
//              DDE messages.
//
//  Returns:    TRUE  - found and processed an RPC message
//              FALSE - did not find an RPC message
//
//  History:    21-Dec-93 JohannP   Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
BOOL CCliModalLoop::PeekRPCAndDDEMessage()
{
    // loop over all windows looking for incoming Rpc messages. Note that
    // it is possible for a dispatch here to cause one of the windows to
    // be deregistered or another to be registered, so our loop has to account
    // for that, hence the check for NULL hWnd.

    BOOL fRet = FALSE;
    MSG  Msg;

    for (UINT i = 0; i < 2; i++)
    {
        // get window info and peek on it if the hWnd is still OK
        SWindowData *pWD = _pACC->GetWindowData(i);

        if (pWD->hWnd != WD_EMPTY)
        {
            if (MyPeekMessage(&Msg, pWD->hWnd, pWD->wFirstMsg, pWD->wLastMsg,
                           PM_REMOVE | PM_NOYIELD))
            {
                Win4Assert(IsWaiting());
                MyDispatchMessage(&Msg);

                // exit on the first dispatched message. If the message was
                // not the reply we were waiting for, then the channel will
                // call us back again.
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::FindMessage
//
//  Synopsis:   Called by HandleWakeForMsg when a message arrives on the
//              windows msg queue.  Determines if there is something of
//              interest to us, and pulls timer msgs. Dispatches RPC, DDE,
//              and RPC timer messages.
//
//  Arguments:  [dwStatus] - current Queue status (from GetQueueStatus)
//
//  Returns:    TRUE  - there is a message to process
//              FALSE - no messages to process
//
//  Algorithm:  Find the next message in the queue by using the following
//              priority list:
//
//              1. RPC and DDE messages
//              2. mouse and keyboard messages
//              3. other messages
//
//  History:    21-Dec-93 Johannp   Created
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) CCliModalLoop::FindMessage(DWORD dwStatus)
{
    WORD wOld = HIWORD(dwStatus);
    WORD wNew = (WORD) dwStatus;

    if (!wNew)
    {
        if (!(wOld & QS_POSTMESSAGE))
            return FALSE;   // no messages to take care of
        else
            wNew |= QS_POSTMESSAGE;
    }

    MSG Msg;

    // Priority 1: look for RPC and DDE messages
    if (wNew & (QS_POSTMESSAGE | QS_SENDMESSAGE | QS_TIMER))
    {
        if (PeekRPCAndDDEMessage())
        {
            // we know that *some* RPC message came in, might be our
            // reply or may be some incoming call. In any case, return to
            // the modal loop to guy so we can figure out if we need to
            // keep going.
            return FALSE;
        }
    }

    if (wNew & QS_TIMER)
    {
        // throw the system timer messages away
        while (MyPeekMessage(&Msg, 0, WM_SYSTIMER, WM_SYSTIMER, PM_REMOVE | PM_NOYIELD))
            ;
    }

    // Priority 2: messages from the hardware queue
    if (wNew & (QS_KEY | QS_MOUSEMOVE | QS_MOUSEBUTTON))
    {
        return TRUE;        // these messages are always removed
    }
    else if (wNew & QS_TIMER)
    {
        if (MyPeekMessage(&Msg, 0, WM_TIMER, WM_TIMER, PM_NOREMOVE | PM_NOYIELD) )
            return TRUE;
    }
    else if (wNew & QS_PAINT)
    {
        return TRUE;        // this  message might not get removed
    }
    else if (wNew & (QS_POSTMESSAGE | QS_SENDMESSAGE))
    {
        if (MyPeekMessage(&Msg, 0, 0, 0, PM_NOREMOVE))
            return TRUE;    // Priority 3: all other messages
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::HandlePendingMessage
//
//  Synopsis:   this function is called for system messages and other
//              pending messages
//
//  Arguments:  none
//
//  Returns:    nothing, _hr may be updated if call is cancelled.
//
//  Algorithm:
//
//  History:    21-Dec-93 Johannp   Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
INTERNAL_(void) CCliModalLoop::HandlePendingMessage()
{
    // get and call the message filter if there is one
    IMessageFilter *pMF = _pACC->GetMsgFilter();

    if (pMF)
    {
        ComDebOut((DEB_MFILTER,
            "pMF->MessagePending(dwTIDCallee:%x ElapsedTime:%x Type:%x)\n",
            _dwTIDCallee, GetElapsedTime(),
            (_pPrev) ? PENDINGTYPE_NESTED : PENDINGTYPE_TOPLEVEL));

        DWORD dwRet = pMF->MessagePending((MF_HTASK)LongToPtr(_dwTIDCallee),
                                          GetElapsedTime(),
                                          (_pPrev) ? PENDINGTYPE_NESTED
                                                   : PENDINGTYPE_TOPLEVEL);

        ComDebOut((DEB_MFILTER,"pMF->MessagePending() dwRet:%x\n", dwRet));


        _pACC->ReleaseMsgFilter();

        if (dwRet == PENDINGMSG_CANCELCALL)
        {
            _hr = RPC_E_CALL_CANCELED;
            return;
        }

        Win4Assert((dwRet == PENDINGMSG_WAITDEFPROCESS ||
                    dwRet == PENDINGMSG_WAITNOPROCESS) &&
                    "Invalid return value from pMF->MessagePending");
    }

    // if we get here we are going to do the default message processing.
    // Default Processing: Continue to wait for the call return and
    // don't dispatch the new message. Perform default processing on
    // special system messages.

    MSG  msg;

    // we have to take out all syscommand messages
    if (MyPeekMessage(&msg, 0, WM_SYSCOMMAND, WM_SYSCOMMAND, PM_REMOVE | PM_NOYIELD))
    {
        // only dispatch some syscommands
        if (msg.wParam == SC_HOTKEY || msg.wParam == SC_TASKLIST)
        {
            ComDebOut((DEB_CALLCONT,">>>> Dispatching SYSCOMMAND message: %x; wParm: %x \r\n",msg.message, msg.wParam));
            MyDispatchMessage(&msg);
        }
        else
        {
            ComDebOut((DEB_CALLCONT,">>>> Received/discarded SYSCOMMAND message: %x; wParm: %x \r\n",msg.message, msg.wParam));
            MessageBeep(0);
        }
    }
    else if (MyPeekMessage(&msg, 0, WM_SYSKEYDOWN, WM_SYSKEYDOWN, PM_NOREMOVE | PM_NOYIELD))
    {
        if (msg.message == WM_KEYDOWN)
        {
            if (msg.wParam != VK_CONTROL && msg.wParam != VK_SHIFT)
                MessageBeep(0);
        }
        else if (msg.message == WM_SYSKEYDOWN && msg.lParam & SYS_ALTDOWN &&
                 (msg.wParam == VK_TAB || msg.wParam == VK_ESCAPE))
        {
            MyPeekMessage(&msg, 0, WM_SYSKEYDOWN, WM_SYSKEYDOWN, PM_REMOVE | PM_NOYIELD);
            TranslateMessage(&msg);
            MyDispatchMessage(&msg);
        }
    }
    else if (MyPeekMessage(&msg, 0, WM_ACTIVATE, WM_ACTIVATE, PM_REMOVE | PM_NOYIELD)
          || MyPeekMessage(&msg, 0, WM_ACTIVATEAPP, WM_ACTIVATEAPP, PM_REMOVE | PM_NOYIELD)
          || MyPeekMessage(&msg, 0, WM_NCACTIVATE, WM_NCACTIVATE, PM_REMOVE | PM_NOYIELD) )
    {
        MyDispatchMessage(&msg);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::MyPeekMessage
//
//  Synopsis:   This function is called whenever we want to do a PeekMessage.
//              It intercepts WM_QUIT messages and remembers them so that
//              they can be reposted when the modal loop is exited.
//
//  Arguments:  [pMsg] - message structure
//              [hWnd] - window to peek on
//              [min/max] - min and max message numbers
//              [wFlag] - peek flags
//
//  Returns:    TRUE  - a message is available
//              FALSE - no messages available
//
//  History:    21-Dec-93 Johannp       Created
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) CCliModalLoop::MyPeekMessage(MSG *pMsg, HWND hwnd,
                                             UINT min, UINT max, WORD wFlag)
{
    BOOL fRet = FALSE;

    __try
    {
        fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);
    }
    __except (PeekMessageExceptionFilter (GetExceptionInformation()))
    {
    }

    while (fRet)
    {
        ComDebOut((DEB_CALLCONT, "MyPeekMessage: hwnd:%x msg:%d time:%ld\n",
            pMsg->hwnd, pMsg->message, pMsg->time));

        if (pMsg->message != WM_QUIT)
        {
            // it is not a QUIT message so exit the loop and return TRUE
            break;
        }

        // just remember that we saw a QUIT message. we will ignore it for
        // now and repost it after our call has completed.

        ComDebOut((DEB_CALLCONT, "WM_QUIT received.\n"));
        _wQuitCode = (ULONG) pMsg->wParam;
        _dwFlags  |= CMLF_QUITRECEIVED;

        __try
        {
            if (!(wFlag & PM_REMOVE))   // NOTE: dont use PM_NOREMOVE
            {
                // quit message is still on queue so pull it off
                PeekMessage(pMsg, hwnd, WM_QUIT, WM_QUIT, PM_REMOVE | PM_NOYIELD);
            }

            // peek again to see if there is another message
            fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);
        }
        __except (PeekMessageExceptionFilter (GetExceptionInformation()))
        {
        }
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::MyDispatchMessage
//
//  Synopsis:   This function is called whenever we want to dispatch a
//              message we have peeked.
//
//  Arguments:  [pMsg] - message structure
//
//--------------------------------------------------------------------------
inline INTERNAL_(void) CCliModalLoop::MyDispatchMessage(MSG *pMsg)
{
    ComDebOut((DEB_CALLCONT, "Dispatching Message hWnd:%x msg:%d wParam:%x\n",
        pMsg->hwnd, pMsg->message, pMsg->wParam));

    DispatchMessage(pMsg);
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::GetElapsedTime
//
//  Synopsis:   Get the elapsed time for an RPC call
//
//  Returns:    Elapsed time of current call
//
//  Algorithm:  This checks whether we have the slow time factor. If not,
//              and we are in WOW we read it from the registry. Otherwise,
//              it is just set to one. Then we calculate the time of the
//              RPC call and divide it by the slow time factor.
//
//  History:    22-Jul-94 Ricksa    Created
//
//--------------------------------------------------------------------------
INTERNAL_(DWORD) CCliModalLoop::GetElapsedTime()
{
    // Define slow time factor to something invalid
    static dwSlowTimeFactor = 0;

    if (dwSlowTimeFactor == 0)
    {
        if (IsWOWProcess())
        {
            // Get time factor from registry otherwise set to the default
            dwSlowTimeFactor = GetSlowTimeFactor();
        }
        else
        {
            // Time is unmodified for 32 bit apps
            dwSlowTimeFactor = 1;
        }
    }

    DWORD dwTickCount = GetTickCount();
    DWORD dwElapsedTime = dwTickCount - _dwTimeOfCall;
    if (dwTickCount < _dwTimeOfCall)
    {
        // the timer wrapped
        dwElapsedTime = 0xffffffff - _dwTimeOfCall + dwTickCount;
    }

    return  (dwElapsedTime / dwSlowTimeFactor);
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::FindPrevCallOnLID        [server side]
//
//  Synopsis:   When an incoming call arrives this is used to find any
//              previous call for the same logical thread, ignoring
//              INTERNAL calls.  The result is used to determine if this
//              is a nested call or not.
//
//  Arguments:  [lid] - logical threadid of incoming call
//
//  Returns:    pCML - if a previous CliModalLoop found for this lid
//              NULL - otherwise
//
//  Algorithm:  just walk backwards on the _pPrev chain
//
//  History:    17-Dec-93 JohannP    Created
//              30-Apr-95 Rickhi     ReWrite
//
//--------------------------------------------------------------------------
CCliModalLoop *CCliModalLoop::FindPrevCallOnLID(REFLID lid)
{
    CCliModalLoop *pCML = this;

    do
    {
        if (pCML->_lid == lid)
        {
            break;      // found a match, return it
        }

    } while ((pCML = pCML->_pPrev) != NULL);

    return pCML;
}

//+-------------------------------------------------------------------------
//
//  Function:   STAInvoke
//
//  Synopsis:   Called whenever an incoming call arrives in a single-threaded
//              apartment. It asks the apps message filter (if there is one)
//              whether it wants to handle the call or not, and dispatches
//              the call if OK.
//
//  Arguments:  [pMsg] - Incoming Rpc message
//              [CallCatIn] - callcat of incoming call
//              [pStub] - stub to call if MF says it is OK
//              [pChnl] - channel ptr to give to stub
//              [pv] - real interface being called
//              [pdwFault] - where to store fault code if there is a fault
//
//  Returns:    result for MF or from call to stub
//
//  History:    21-Dec-93 Johannp   Original Version
//              22-Jul-94 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
INTERNAL STAInvoke(RPCOLEMESSAGE *pMsg, DWORD CallCatIn, IRpcStubBuffer *pStub,
                   IInternalChannelBuffer *pChnl, void *pv,
                   IPIDEntry *pIPIDEntry, DWORD *pdwFault)
{
    ComDebOut((DEB_CALLCONT,
        "STAInvoke pMsg:%x CallCatIn:%x pStub:%x pChnl:%x\n",
         pMsg, CallCatIn, pStub, pChnl));

    HRESULT hr = HandleIncomingCall(*MSG_TO_IIDPTR(pMsg),
                                    (WORD)pMsg->iMethod,
                                    CallCatIn, pv);
    if (hr == S_OK)
    {
        // the message filter says its OK to invoke the call.

        // construct a server call state. This puts the current incoming
        // call's CallCat in Tls so we can check it if the server tries to
        // make an outgoing call while handling this call. See CanMakeOutCall.
        CSrvCallState SCS(CallCatIn);

        // invoke the call
        hr = MTAInvoke(pMsg, CallCatIn, pStub, pChnl, pIPIDEntry, pdwFault);
    }
    else if (hr == RPC_E_CALL_REJECTED || hr == RPC_E_SERVERCALL_RETRYLATER)
    {
        // server is rejecting the call, try to copy the incomming buffer so
        // that the client has the option of retrying the call.
        hr = CopyMsgForRetry(pMsg, pChnl, hr);
    }

    ComDebOut((DEB_CALLCONT,"STAInvoke returns:%x\n",hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   HandleIncomingCall, internal
//
//  Synopsis:   Called whenever an incoming call arrives in a single-threaded
//              apartment. It asks the app's message filter (if there is one)
//              whether it wants to handle the call or not
//
//  Arguments:  [piid] - ptr to interface the call is being made on
//              [iMethod] - method number being called
//              [CallCatIn] - category of incoming call
//              [pv] - real interface being called
//
//  Returns:    result from MF
//
//  History:    11-Oct-96 Rickhi   Separated from STAInvoke
//              12-Feb-98 Johnstra Made NTA aware
//
//--------------------------------------------------------------------------
INTERNAL HandleIncomingCall(REFIID riid, WORD iMethod, DWORD CallCatIn, void *pv)
{
    ComDebOut((DEB_CALLCONT,
        "HandleIncomingCall iid:%I iMethod:%x CallCatIn:%x pv:%x:%x\n",
         &riid, iMethod, CallCatIn, pv));

    COleTls tls;
    if (IsThreadInNTA() || !(tls->dwFlags & OLETLS_APARTMENTTHREADED))
    {
        // free-threaded apartments don't have a message filter
        return S_OK;
    }

    HRESULT hr = S_OK;
    CAptCallCtrl *pACC = tls->pCallCtrl;


    // We dont call the message filter for IUnknown since older versions
    // of OLE did not, and doing so (unfortunately) breaks compatibility.
    // Also check for IRundown since local clients call on it instead of
    // IRemUnknown.

    IMessageFilter *pMF = (riid == IID_IRundown ||
                           riid == IID_IRemUnknown ||
                           riid == IID_IRemUnknown2)
                          ? NULL : pACC->GetMsgFilter();

    if (pMF)
    {
        //  the app has installed a message filter, call it.

        INTERFACEINFO IfInfo;
        IfInfo.pUnk = (IUnknown *)pv;
        IfInfo.iid = riid;
        IfInfo.wMethod = iMethod;

        ComDebOut((DEB_CALLCONT, "Calling iMethod:%x riid:%I\n",
            IfInfo.wMethod, &IfInfo.iid));

        CCliModalLoop *pCML = NULL;
        REFLID lid          = tls->LogicalThreadId;
        DWORD  TIDCaller    = tls->dwTIDCaller;

        DWORD dwCallType    = pACC->GetCallTypeForInCall(&pCML, lid, CallCatIn);
        DWORD dwElapsedTime = (pCML) ? pCML->GetElapsedTime() : 0;

        // The DDE layer doesn't provide any interface information. This
        // was true on the 16-bit implementation, and has also been
        // brought forward into this implementation to insure
        // compatibility. However, the CallCat of the IfInfo is still
        // provided.
        //
        // Therefore, if pIfInfo has its pUnk member set to NULL, then
        // we are going to send a NULL pIfInfo to the message filter.

        ComDebOut((DEB_MFILTER,
         "pMF->HandleIncomingCall(dwCallType:%x TIDCaller:%x dwElapsedTime:%x IfInfo:%x)\n",
         dwCallType, TIDCaller, dwElapsedTime, (IfInfo.pUnk) ? &IfInfo : NULL));

        DWORD dwRet = pMF->HandleInComingCall(dwCallType,
                                              (MF_HTASK)LongToPtr(TIDCaller),
                                              dwElapsedTime,
                                              IfInfo.pUnk ? &IfInfo : NULL);

        ComDebOut((DEB_MFILTER,"pMF->HandleIncomingCall() dwRet:%x\n", dwRet));

        pACC->ReleaseMsgFilter();

        // strict checking of app return code for win32
        Win4Assert(dwRet == SERVERCALL_ISHANDLED  ||
                   dwRet == SERVERCALL_REJECTED   ||
                   dwRet == SERVERCALL_RETRYLATER ||
                   IsWOWThread() && "Invalid Return code from App IMessageFilter");


        if (dwRet != SERVERCALL_ISHANDLED)
        {
            if (CallCatIn == CALLCAT_ASYNC || CallCatIn == CALLCAT_INPUTSYNC)
            {
                // Note: input-sync and async calls can not be rejected
                // Even though they can not be rejected, we still have to
                // call the MF above to maintain 16bit compatability.
                hr = S_OK;
            }
            else if (dwRet == SERVERCALL_REJECTED)
            {
                hr = RPC_E_CALL_REJECTED;
            }
            else if (dwRet == SERVERCALL_RETRYLATER)
            {
                hr = RPC_E_SERVERCALL_RETRYLATER;
            }
            else
            {
                // 16bit OLE let bogus return codes go through and of course
                // apps rely on that behaviour so we let them through too, but
                // we are more strict on 32bit.
                hr = (IsWOWThread()) ? S_OK : RPC_E_UNEXPECTED;
            }
        }
    }

    ComDebOut((DEB_CALLCONT, "HandleIncomingCall hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   MTAInvoke
//
//  Synopsis:   Multi-Threaded Apartment Invoke. Called whenever an incoming
//              call arrives in the MTA apartment (or as a subroutine to
//              STAInvoke). It just dispatches to a common sub-routine.
//
//  Arguments:  [pMsg] - Incoming Rpc message
//              [pStub] - stub to call if MF says it is OK
//              [pChnl] - channel ptr to give to stub
//              [pdwFault] - where to store fault code if there is a fault
//
//  Returns:    result from calling the stub
//
//  History:    03-Oct-95   Rickhi  Made into subroutine from STAInvoke
//
//--------------------------------------------------------------------------
INTERNAL MTAInvoke(RPCOLEMESSAGE *pMsg, DWORD CallCatIn, IRpcStubBuffer *pStub,
                   IInternalChannelBuffer *pChnl, IPIDEntry *pIPIDEntry,
                   DWORD *pdwFault)
{
#if DBG==1
    ComDebOut((DEB_CALLCONT,
        "MTAInvoke pMsg:%x CallCatIn:%x pStub:%x pChnl:%x\n",
         pMsg, CallCatIn, pStub, pChnl));
    IID iid       = *MSG_TO_IIDPTR(pMsg);
    DWORD iMethod = pMsg->iMethod;
    DebugPrintORPCCall(ORPC_INVOKE_BEGIN, iid, iMethod, CallCatIn);
    RpcSpy((CALLIN_BEGIN, NULL, iid, iMethod, 0));
#endif

    // call a common subroutine to do the dispatch. The subroutine also
    // catches exceptions and provides some debug help.

    HRESULT hr = pChnl->ContextInvoke(pMsg, pStub, pIPIDEntry, pdwFault);

#if DBG==1
    RpcSpy((CALLIN_END, NULL, iid, iMethod, hr));
    DebugPrintORPCCall(ORPC_INVOKE_END, iid, iMethod, CallCatIn);
    ComDebOut((DEB_CALLCONT,"MTAInvoke returns:%x\n",hr));
#endif

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CopyMsgForRetry
//
//  Synopsis:   Makes a copy of the server-side message buffer to return to
//              the client so that the client can retry the call later.
//              Returns an error if the client is on a different machine.
//
//  Parameters: [pMsg] - ptr to message to copy
//              [pChnl] - ptr to channel call is being made on
//              [hr] - result code
//
//  History:    30-05-95    Rickhi  Created
//
//+-------------------------------------------------------------------------
HRESULT CopyMsgForRetry(RPCOLEMESSAGE *pMsg, IInternalChannelBuffer *pChnl,
                        HRESULT hrIn)
{
    ComDebOut((DEB_CALLCONT,"CopyMsgForRetry pMsg:%x pChnl:%x pBuffer:%x\n",
        pMsg, pChnl, pMsg->Buffer));

    DWORD dwDestCtx;
    HRESULT hr = ((IRpcChannelBuffer3 *) pChnl)->GetDestCtx(&dwDestCtx, NULL);

    if (SUCCEEDED(hr) && dwDestCtx != MSHCTX_DIFFERENTMACHINE &&
        !IsEqualGUID(IID_ILocalSystemActivator, *MSG_TO_IIDPTR(pMsg)))
    {
        // client on same machine as server.
        void *pSavedBuffer = pMsg->Buffer;

        // Store context call object in TLS
        COleTls Tls;
        CCtxCall *pCtxCall = NULL;
        CCtxCall *pCurCall = NULL;

        if(pMsg->reserved1)
        {
            pCtxCall = ((CMessageCall *) pMsg->reserved1)->GetServerCtxCall();
            pCurCall = pCtxCall->StoreInTLS(Tls);
        }

        // Obtain a new buffer from the apartment channel
        hr = pChnl->GetBuffer2(pMsg, *MSG_TO_IIDPTR(pMsg));

        if(pCtxCall)
        {
            // Revoke context call object from TLS
            pCtxCall->RevokeFromTLS(Tls, pCurCall);
        }

        // Check for success
        if (SUCCEEDED(hr))
        {
            // copy original buffer to the new buffer
            memcpy(pMsg->Buffer, pSavedBuffer, pMsg->cbBuffer);
            hr = hrIn;
        }
    }
    else
    {
        // client on different machine than server, or the call was on
        // the activation interface, fail the call and dont send back
        // a copy of the parameter packet.
        hr = RPC_E_CALL_REJECTED;
    }

    ComDebOut((DEB_CALLCONT,"CopyMsgForRetry pBuffer:%x hr:%x\n",
        pMsg->Buffer, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::GetCallTypeForInCall
//
//  Synopsis:   called when an incoming call arrives in order to determine
//              what CALLTYPE to pass to the applications message filter.
//
//  Arguments:  [ppCML] - Client Modal Loop of prev call on same lid (if any)
//              [lid]   - logical thread id of this call
//              [dwCallCat] - call category of incoming call
//
//  Returns:    the CALLTYPE to give to the message filter
//
//  History:    21-Dec-93 Johannp       Created
//              30-Apr-95 Rickhi        ReWrite
//
//  Notes:
//
//  1 = CALLTYPE_TOPLEVEL  // sync or inputsync call - no outgoing call
//  2 = CALLTYPE_NESTED    // callback on behalf of previous outgoing call
//  3 = CALLTYPE_ASYNC     // asynchronous call - no outstanding call
//  4 = CALLTYPE_TOPLEVEL_CALLPENDING // call with new LID - outstand call
//  5 = CALLTYPE_ASYNC_CALLPENDING    // async call - outstanding call
//
//--------------------------------------------------------------------------
DWORD CAptCallCtrl::GetCallTypeForInCall(CCliModalLoop **ppCML,
                                         REFLID lid, DWORD dwCallCatIn)
{
    DWORD CallType;
    CCliModalLoop *pCML = GetTopCML();

    if (dwCallCatIn == CALLCAT_ASYNC)       // asynchronous call has arrived
    {
        if (pCML == NULL)
            CallType = CALLTYPE_ASYNC;      // no outstanding calls
        else
            CallType = CALLTYPE_ASYNC_CALLPENDING;  // outstanding call
    }
    else                                    // non-async call has arrived
    {
        if (pCML == NULL)
            CallType = CALLTYPE_TOPLEVEL;  // no outstanding call
        else if ((*ppCML = pCML->FindPrevCallOnLID(lid)) != NULL)
            CallType = CALLTYPE_NESTED;    // outstanding call on same lid
        else
            CallType = CALLTYPE_TOPLEVEL_CALLPENDING; // different lid
    }

    ComDebOut((DEB_CALLCONT,"GetCallTypeForInCall return:%x\n", CallType));
    return CallType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\commap\lib\reader.cxx ===
//+-------------------------------------------------------------------
//
//  File:       reader.cxx
//
//  Contents:   Implementation of CProcessReader, which knows how to
//              read various structures out of process memory.
//
//  Classes:    CProcessReader
//
//  History:    27-Mar-2002  JohnDoty  Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include "reader.hxx"
#include <dbghelp.h>
#include "util.h"
#include <strsafe.h>

#define private   public
#define protected public
#include <ctxchnl.hxx>

HRESULT 
CProcessReader::GetStdIDFromIPIDEntry(
    IN const IPIDEntry *pIPIDEntry,
    OUT ULONG_PTR *pStdID)
const
{
    STACK_INSTANCE(CCtxComChnl, pChnl);
    
    *pStdID = 0;
    
    if (pIPIDEntry->pChnl == NULL)
    {
        // No channel?  Just return NULL then.
        return S_FALSE;
    }
    
    if (!ReadProcessMemory(m_hProcess, 
                           pIPIDEntry->pChnl,
                           pChnl, 
                           sizeof(CCtxComChnl), 
                           NULL))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    *pStdID = (ULONG_PTR)(pChnl->_pStdId);
    return S_OK;
}

HRESULT
CProcessReader::GetOXIDFromIPIDEntry(
    IN const IPIDEntry *pIPIDEntry,
    OUT OXID *pOXID)
const
{
    STACK_INSTANCE(OXIDEntry, pOXIDEntry);

    *pOXID = 0;
    if (!pIPIDEntry->pOXIDEntry)
    {
        return S_FALSE;
    }

    if (!ReadProcessMemory(m_hProcess, pIPIDEntry->pOXIDEntry, pOXIDEntry, sizeof(OXIDEntry), NULL))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    OXIDFromMOXID(pOXIDEntry->GetMoxid(), pOXID);
    return S_OK;
}

HRESULT 
CProcessReader::GetOIDFromIPIDEntry(
    IN const IPIDEntry *pIPIDEntry,
    OUT OID *pOID)
const
{
    ULONG_PTR ulStdIDAddr = 0;
    
    *pOID = 0;
    
    HRESULT hr = GetStdIDFromIPIDEntry(pIPIDEntry, &ulStdIDAddr);
    if (hr == S_OK)
    {
        STACK_INSTANCE(CStdIdentity, pStdID);
        
        if (ReadProcessMemory(m_hProcess, 
                              (LPCVOID)ulStdIDAddr, 
                              pStdID, 
                              sizeof(CStdIdentity), 
                              NULL))
        {
            STACK_INSTANCE(CIDObject, pIDObject);
            
            if (pStdID->GetIDObject() == NULL)
                return S_FALSE;
            
            if (ReadProcessMemory(m_hProcess,
                                  pStdID->GetIDObject(),
                                  pIDObject,
                                  sizeof(CIDObject),
                                  NULL))
            {                    
                OIDFromMOID(pIDObject->GetOID(), pOID);
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    
    return hr;
}

HRESULT 
CProcessReader::ReadIPIDEntries(
    OUT DWORD *pcIPIDEntries,
    OUT IPIDEntry **prgIPIDEntries)
const
{        
    HRESULT   hr           = S_OK;
    IPIDEntry ipidHead     = { NULL };
    DWORD     cIPIDEntries = 0;
    
    char buffer[sizeof(IMAGEHLP_SYMBOL64) + 256];
    PIMAGEHLP_SYMBOL64 sym = (PIMAGEHLP_SYMBOL64)buffer;
    sym->SizeOfStruct      = sizeof(IMAGEHLP_SYMBOL64);
    sym->MaxNameLength     = 256;
    
    *pcIPIDEntries = 0;
    *prgIPIDEntries = NULL;
    
    
    if (!SymGetSymFromName64(m_hProcess, "ole32!CIPIDTable::_oidListHead", sym))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }
    
    if (ReadProcessMemory(m_hProcess, (LPCVOID)(sym->Address), &ipidHead, sizeof(ipidHead), NULL))
    {        
        IPIDEntry *pPrev = &ipidHead;
        void *pCurrent = pPrev->pOIDFLink;
        pPrev->pOIDFLink = pPrev->pOIDBLink = NULL; // Clear these for ease of cleanup.
        
        while ((pCurrent != NULL) && (pCurrent != (void *)sym->Address))
        {
            pPrev->pOIDFLink = (IPIDEntry *)CoTaskMemAlloc(sizeof(IPIDEntry));
            if (pPrev->pOIDFLink == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
            ZeroMemory(pPrev->pOIDFLink, sizeof(IPIDEntry));
            
            if (!ReadProcessMemory(m_hProcess, pCurrent, pPrev->pOIDFLink, sizeof(IPIDEntry), NULL))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto cleanup;
            }
            
            cIPIDEntries++;
            pPrev    = pPrev->pOIDFLink;
            pCurrent = pPrev->pOIDFLink;
            pPrev->pOIDFLink = pPrev->pOIDBLink = NULL;
            pPrev->pNextIPID = NULL;
        }      
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }
    
    if (cIPIDEntries > 0)
    {
        DWORD i;
        IPIDEntry *pCurrent = ipidHead.pOIDFLink;
        IPIDEntry *ret = new IPIDEntry[cIPIDEntries];
        if (ret == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        i = 0;
        while (pCurrent != NULL)
        {
            ret[i] = (*pCurrent); i++;
            pCurrent = pCurrent->pOIDFLink;
        }
        
        *prgIPIDEntries = ret;
    }
    
    *pcIPIDEntries = cIPIDEntries;
    
cleanup:
    
    IPIDEntry *pCleanup = ipidHead.pOIDFLink;
    while (pCleanup != NULL)
    {
        IPIDEntry *pTemp = pCleanup->pOIDFLink;
        CoTaskMemFree(pCleanup);
        pCleanup = pTemp;
    }
    
    return hr;
}    

HRESULT 
CProcessReader::ReadLRPCEndpoint(
    OUT LPWSTR *pwszEndpoint)
const
{   
    HRESULT hr = S_OK;

    BOOL  fLrpc = FALSE;
    WCHAR lrpcEndpoint[GUIDSTR_MAX+3] = L"OLE";
     
    char buffer[sizeof(IMAGEHLP_SYMBOL64) + 256];
    PIMAGEHLP_SYMBOL64 sym = (PIMAGEHLP_SYMBOL64)buffer;
    sym->SizeOfStruct      = sizeof(IMAGEHLP_SYMBOL64);
    sym->MaxNameLength     = 256;

    if (!SymGetSymFromName64(m_hProcess, "ole32!gfLrpc", sym))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    if (!ReadProcessMemory(m_hProcess, (LPCVOID)(sym->Address), 
                           &fLrpc, sizeof(fLrpc), NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;        
    }

    if (!fLrpc)
    {
        *pwszEndpoint = NULL;
        hr = S_OK;
        goto cleanup;
    }

    if (!SymGetSymFromName64(m_hProcess, "ole32!gwszLRPCEndPoint", sym))
    {
        // This might be < .NET Server.  Different path!
        DWORD dwEndPoint = 0;

        if (!SymGetSymFromName64(m_hProcess, "ole32!gdwEndPoint", sym))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }

        if (!ReadProcessMemory(m_hProcess, (LPCVOID)(sym->Address), &dwEndPoint,
                               sizeof(dwEndPoint), NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;            
        }

        hr = StringCbPrintfW(lrpcEndpoint, 
                             sizeof(lrpcEndpoint),
                             L"OLE%x",
                             dwEndPoint);
        if (FAILED(hr))
        {
            goto cleanup;
        }
    }
    else
    {
        // .NET Server (or better?).  Read the entire endpoint.
        if (!ReadProcessMemory(m_hProcess, (LPCVOID)(sym->Address), lrpcEndpoint+3, 
                               sizeof(lrpcEndpoint)-(3*sizeof(WCHAR)), NULL))
        {        
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }
    }

    *pwszEndpoint = (LPWSTR)CoTaskMemAlloc(sizeof(lrpcEndpoint));
    if (*pwszEndpoint == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    memcpy(*pwszEndpoint, lrpcEndpoint, sizeof(lrpcEndpoint));
    hr = S_OK;

cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\call.cxx ===
//+-------------------------------------------------------------------
//
//  File:       call.cxx
//
//  Contents:   code to support COM calls
//
//  Functions:  CCallTable methods
//              CallObject methods
//
//  History:    14-May-97   Gopalk      Created
//              10-Feb-99   TarunA      Receive SendComplete notifications
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <channelb.hxx>
#include <call.hxx>
#include <threads.hxx>
#include <callctrl.hxx>
#include <callmgr.hxx>

/***************************************************************************/
/* Class globals. */

// critical section guarding call objects
COleStaticMutexSem  gCallLock;

CAsyncCall    *CAsyncCall::_aList[CALLCACHE_SIZE] =
        { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
DWORD          CAsyncCall::_iNext          = 0;
void          *CClientCall::_aList[CALLCACHE_SIZE] =
        { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
DWORD          CClientCall::_iNext        = 0;


CCallTable     gCallTbl;                            // Global call table
BOOL           CCallTable::m_fInitialized  = FALSE; // Is call table initialized?
CPageAllocator CCallTable::m_Allocator;             // Allocator for call entries


//+-------------------------------------------------------------------
//
//  Method:     CCallTable::SetEntry     public
//
//  Synopsis:   Sets the given call object as the top call object on
//              the call object stack.
//
//+-------------------------------------------------------------------
HRESULT CCallTable::SetEntry(ICancelMethodCalls *pObject)
{
    CallDebugOut((DEB_CALL, "CThreadTable::SetEntry pObject:%x\n",pObject));

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    // hold a reference to the call object
    pObject->AddRef();

    if (tls->CallEntry.pvObject == NULL)
    {
        // we can take the fast path since the CallEntry in
        // tls is currently unused.
        tls->CallEntry.pvObject = pObject;
        return S_OK;
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    Initialize();     // Make sure this table is initialized.

    // Create a new stack entry
    CallEntry *pStackEntry = (CallEntry *) m_Allocator.AllocEntry();
    if(pStackEntry)
    {
        // link it in
        pStackEntry->pNext      = tls->CallEntry.pNext;
        pStackEntry->pvObject   = tls->CallEntry.pvObject;
        tls->CallEntry.pNext    = pStackEntry;
        tls->CallEntry.pvObject = pObject;
        pObject = NULL;

        // One more call is using the table
        ++m_cCalls;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (pObject)
    {
        pObject->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::ClearEntry     public
//
//  Synopsis:   Removes the top call object from the call object stack.
//
//+-------------------------------------------------------------------
ICancelMethodCalls *CCallTable::ClearEntry(ICancelMethodCalls *pCall)
{
    CallDebugOut((DEB_CALL, "CThreadTable::ClearEntry pCall:%x\n",pCall));
    ASSERT_LOCK_HELD(gCallLock);

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return NULL;

    if (tls->CallEntry.pvObject == NULL)
        return NULL;

    // tls has a pointer to the call object
    ICancelMethodCalls *pvObject = (ICancelMethodCalls *) tls->CallEntry.pvObject;
    tls->CallEntry.pvObject = NULL;

    // ensure we are poping the call we think we are
    Win4Assert(pCall == NULL || pCall == pvObject);

    if (tls->CallEntry.pNext)
    {
        // there is a nested call, make tls point to the previous call
        // and release the previous call.
        CallEntry *pTmp          = (CallEntry *)tls->CallEntry.pNext;
        tls->CallEntry.pvObject  = pTmp->pvObject;
        tls->CallEntry.pNext     = pTmp->pNext;
        m_Allocator.ReleaseEntry((PageEntry *) pTmp);

        // One less thread is using the table
        --m_cCalls;
        if(m_fInitialized == FALSE)
            PrivateCleanup();
    }

    ASSERT_LOCK_HELD(gCallLock);
    return pvObject;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::GetEntry     public
//
//  Synopsis:   Finds thread entry corresponding to the ThreadId
//              passed in and returns its stack top call object
//
//+-------------------------------------------------------------------
ICancelMethodCalls *CCallTable::GetEntry(DWORD dwThreadId)
{
    CallDebugOut((DEB_CALL, "CThreadTable::GetEntry dwThreadId:%x\n",dwThreadId));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    ICancelMethodCalls *pObject = NULL;

    // Find the tls pointer
    SOleTlsData *tls = TLSLookupThreadId(dwThreadId);
    if (tls != NULL)
    {
        // obtain its call object
        pObject = (ICancelMethodCalls *)tls->CallEntry.pvObject;
        if(pObject)
            pObject->AddRef();
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL, "CThreadTable::GetEntry returned pObject:%x\n", pObject));
    return pObject;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::CancelPendingCalls     public
//
//  Synopsis:   Walks the call object stack of the specified thread
//              and cancels calls that are pending
//
//+-------------------------------------------------------------------
void CCallTable::CancelPendingCalls()
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CCallTable::CancelPendingCalls\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Find the tls pointer
    SOleTlsData *tls = TLSLookupThreadId(GetCurrentThreadId());
    if (tls != NULL)
    {
        // obtain its call object
        CallEntry *pCallEntry = &tls->CallEntry;
        while (pCallEntry->pvObject)
        {
            // cancel the calls in the call object stack
            ((ICancelMethodCalls *) pCallEntry->pvObject)->Cancel(0);
            pCallEntry = (CallEntry *) pCallEntry->pNext;
        }
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::Initialize     public
//
//  Synopsis:   Initializes the call table
//
//+-------------------------------------------------------------------
void CCallTable::Initialize()
{
    CallDebugOut((DEB_CALL, "CCallTable::Initialize\n"));

    ASSERT_LOCK_DONTCARE(gCallLock);
    LOCK(gCallLock);

    if(!m_fInitialized)
    {
        // Really initialze only if needed
        if(m_cCalls == 0)
            m_Allocator.Initialize(sizeof(CallEntry), CALLS_PER_PAGE, &gCallLock);

        // Mark the state as initialized
        m_fInitialized = TRUE;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_DONTCARE(gCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::Cleanup     public
//
//  Synopsis:   Cleanup call table
//
//+-------------------------------------------------------------------
void CCallTable::Cleanup()
{
    CallDebugOut((DEB_CALL, "CCallTable::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    m_fInitialized = FALSE;
    if(m_cCalls == 0)
        PrivateCleanup();

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::PrivateCleanup     public
//
//  Synopsis:   Really Cleanup call table
//
//+-------------------------------------------------------------------
void CCallTable::PrivateCleanup()
{
    CallDebugOut((DEB_CALL, "CCallTable::PrivateCleanup\n"));
    ASSERT_LOCK_HELD(gCallLock);
    Win4Assert(m_cCalls == 0);

    // Cleanup allocator
    m_Allocator.Cleanup();

    ASSERT_LOCK_HELD(gCallLock);
    return;
}



//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::CMessageCall
//
//  Synopsis:   CMessageCall ctor.
//
//---------------------------------------------------------------------------
CMessageCall::CMessageCall()
{
    CallDebugOut((DEB_CALL, "CMessageCall::CMessageCall this:%x\n",this));
    _pHeader  = NULL;
    _pHandle  = NULL;
    _hEvent   = NULL;
    _pContext = NULL;
    _hSxsActCtx = INVALID_HANDLE_VALUE;
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::~CMessageCall
//
//  Synopsis:   CMessageCall destructor.
//
//---------------------------------------------------------------------------
CMessageCall::~CMessageCall()
{
    CallDebugOut((DEB_CALL, "CMessageCall::~CMessageCall this:%x\n",this));
    Win4Assert(_pHeader == NULL);
    Win4Assert(_pHandle == NULL);

    if (_hEvent != NULL)
    {
        // Release the event.
        gEventCache.Free(_hEvent);
    }

    SetSxsActCtx(INVALID_HANDLE_VALUE);
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::InitCallobject
//
//  Synopsis:   Initializes the call object before a call starts
//
//---------------------------------------------------------------------------
HRESULT CMessageCall::InitCallObject(CALLCATEGORY       callcat,
                                     RPCOLEMESSAGE     *original_msg,
                                     DWORD              flags,
                                     REFIPID            ipidServer,
                                     DWORD              destctx,
                                     COMVERSION         version,
                                     CChannelHandle    *handle)
{
    CallDebugOut((DEB_CALL, "CMessageCall::InitCallObject this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock); // no need to hold lock over this init code
    Win4Assert(_pHeader == NULL);
    Win4Assert(_pHandle == NULL);

    _iFlags = flags;     // set flags first

    if (_hEvent == NULL && (_iFlags & (client_cs | proxy_cs)))
    {
        // don't have an event yet, go get one
        // only needed for process-local calls
        HRESULT hr = gEventCache.Get(&_hEvent);
        if (FAILED(hr))
            return hr;
    }

    // the event should never be in the signalled state at this point
    Win4Assert(((_hEvent == NULL) || (WaitForSingleObject(_hEvent, 0) == WAIT_TIMEOUT)) &&
                       "InitCallObject: _hEvent Signalled in call object!\n");

    // set the destination context & version
    _destObj.SetDestCtx(destctx);
    _destObj.SetComVersion(version);

    _callcat               = callcat;
    _hResult               = S_OK;
    _ipid                  = ipidServer;
    _dwErrorBufSize 	   = 0;
    message                = *original_msg;
    hook.iid               = *MSG_TO_IIDPTR( original_msg );
    hook.cbSize            = sizeof(hook);

    _pHandle               = handle;
    if(_pHandle != NULL)
    {
        message.reserved1  = _pHandle->_hRpc;
        _pHandle->AddRef();  // AddRef interface pointers kept by the call.
    }

    m_ulCancelTimeout      = INFINITE;
    m_dwStartCount         = 0;
    m_pClientCtxCall       = NULL;
    m_pServerCtxCall       = NULL;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::UninitCallobject
//
//  Synopsis:   Uninitializes the call object after a call completes
//
//---------------------------------------------------------------------------
void CMessageCall::UninitCallObject()
{
    CallDebugOut((DEB_CALL, "CMessageCall::UninitCallObject this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock); // no need to hold lock over this uninit code

    if(IsClientSide() && _pHeader != NULL)
    {
        // On the client side, Release the buffer
        if (ProcessLocal())
            PrivMemFree8(_pHeader);
        else if (message.Buffer)
            I_RpcFreeBuffer( (RPC_MESSAGE *) &message );
    }
    _pHeader = NULL;

    if (_pHandle != NULL)
    {
        // Release the handle.
        _pHandle->Release();
        _pHandle = NULL;
    }

    if (_pContext != NULL)
    {
        _pContext->Release();
        _pContext = NULL;
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::SetCallerHwnd
//
//  Synopsis:   Set the calling thread's hWnd for the reply and free the
//              reply event (if any).
//
//---------------------------------------------------------------------------
HRESULT CMessageCall::SetCallerhWnd()
{
    // In 32bit, replies are done via Events, but for 16bit, replies
    // are done with PostMessage, so we dont need an event.  Not having
    // an event makes the callctrl modal loop a little faster.

    OXIDEntry *pLocalOXIDEntry;
    HRESULT hr = GetLocalOXIDEntry(&pLocalOXIDEntry);
    if (SUCCEEDED(hr))
    {
        _hWndCaller = pLocalOXIDEntry->GetServerHwnd();

        if(_hEvent != NULL)
        {
            gEventCache.Free(_hEvent);
            _hEvent = NULL;
        }
    }

    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::CAsyncCall
//
//  Synopsis:   Initialize the async state and call the CMessageCall
//              constructor
//
//---------------------------------------------------------------------------
CAsyncCall::CAsyncCall()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CAsyncCall this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    _iRefCount          = 1;
    _lFlags             = 0;
    _pChnlObj           = NULL;
    _pRequestBuffer     = NULL;
    _pNext              = NULL;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::~CAsyncCall
//
//  Synopsis:   Cleanup the async state and call the CMessageCall
//              dtor
//
//---------------------------------------------------------------------------
CAsyncCall::~CAsyncCall()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::~CAsyncCall this:%x\n",this));
    Win4Assert(_pChnlObj == NULL);
    Win4Assert(_pContext == NULL);
    Win4Assert(_iRefCount == 0);

#if DBG == 1
    _dwSignature = 0;
#endif
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::InitCallObject
//
//  Synopsis:   Initialize the async state and the CMessageCall before
//              a call starts.
//
//---------------------------------------------------------------------------
HRESULT CAsyncCall::InitCallObject(CALLCATEGORY       callcat,
                                   RPCOLEMESSAGE     *pMsg,
                                   DWORD              flags,
                                   REFIPID            ipidServer,
                                   DWORD              destctx,
                                   COMVERSION         version,
                                   CChannelHandle    *handle)
{
    CallDebugOut((DEB_CALL, "CAsyncCall::InitCallObject this:%x\n",this));

    _lApt = GetCurrentApartmentId();

    // initialize the message call object
    HRESULT hr = CMessageCall::InitCallObject(callcat, pMsg, flags, ipidServer,
                                              destctx, version, handle);
    if (SUCCEEDED(hr))
    {
        // init async state structure to give to RPC
        RPC_STATUS sc = RpcAsyncInitializeHandle(&_AsyncState, sizeof(_AsyncState));
        if (RPC_S_OK == sc) 
        {
            _AsyncState.Flags                 = 0;
            _AsyncState.Event                 = RpcCallComplete;
            _AsyncState.NotificationType      = RpcNotificationTypeCallback;
            _AsyncState.u.NotificationRoutine = ThreadSignal;
            _eSignalState                     = none_ss;
            
            if ((message.rpcFlags & RPC_BUFFER_ASYNC) == 0)
                _iFlags |= fake_async_cs;
            
            message.rpcFlags |= RPC_BUFFER_ASYNC;
            
            if (pMsg->rpcFlags & RPC_BUFFER_ASYNC)
                SetClientAsync();
            
            if (flags & (client_cs | proxy_cs))
            {
                // on the client side
                if (FakeAsync())
                {
                    // Push this call object onto call stack which holds a reference.
                    hr = gCallTbl.PushCallObject(this);
                    Win4Assert(SUCCEEDED(hr) ? (_iRefCount == 2) : (_iRefCount == 1));
                    if(SUCCEEDED(hr))
                        _lFlags |= CALLFLAG_ONCALLSTACK;
                }
                else
                {
                    hr = S_OK;
                }
            }
        }
        else
        {
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc ); 
            Win4Assert(SUCCEEDED(hr));
        }
        // Make sure the DCOM_CALL_STATE does not overlap the CALLFLAG.
        Win4Assert( CALLFLAG_USERMODEBITS < 0x10000 );
    }

#if DBG==1
    _dwSignature = 0xAAAACA11;
    if(IsSTAThread())
        _lFlags |= CALLFLAG_STATHREAD;
    if(IsWOWThread())
        _lFlags |= CALLFLAG_WOWTHREAD;
#endif

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::UninitCallObject
//
//  Synopsis:   Clean up the async call state after a call completes
//
//---------------------------------------------------------------------------
void CAsyncCall::UninitCallObject()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::UninitCallObject this:%x\n",this));

    // reset state
    _pChnlObj = NULL;
    _lFlags = 0;

    // uninitialize the base class call object
    CMessageCall::UninitCallObject();
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::InitClientHwnd, public
//
//  Synopsis:   Initializes the hwnd of the call object
//
//+-------------------------------------------------------------------
void CAsyncCall::InitClientHwnd()
{
    ASSERT_LOCK_NOT_HELD(gCallLock);
    if (IsSTAThread())
    {
        // Save the OXID we can post a message
        // when this thread needs to be Signaled.
        OXIDEntry *pOXIDEntry;
        GetLocalOXIDEntry(&pOXIDEntry);
        Win4Assert(pOXIDEntry);     // this can't fail at this time
        _hwndSTA = pOXIDEntry->GetServerHwnd();
    }
    else
    {
        _hwndSTA = 0;
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::InitForSendComplete
//
//  Synopsis:   Initialize the async state to receive send complete 
//              notifications
//
//---------------------------------------------------------------------------
HRESULT CAsyncCall::InitForSendComplete()
{                                   
    CallDebugOut((DEB_CALL, "CAsyncCall::InitForSendComplete this:%x\n",this));
    HRESULT hr = S_OK;
    // init async state structure to give to RPC
    RPC_STATUS sc = RpcAsyncInitializeHandle(&_AsyncState, sizeof(_AsyncState));
    if (RPC_S_OK == sc) {
       _AsyncState.Flags                       = 0;
       _AsyncState.Event                       = RpcSendComplete;
       _AsyncState.NotificationType            = RpcNotificationTypeApc;
       _AsyncState.u.APC.NotificationRoutine   = ThreadSignal;
       _AsyncState.u.APC.hThread               = 0;
       return hr;
    }
    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc ); 
    Win4Assert(SUCCEEDED(hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CClientCall     public
//
//  Synopsis:   Constructor for the client call object
//
//+-------------------------------------------------------------------
CClientCall::CClientCall()
{
    CallDebugOut((DEB_CALL, "CClientCall::CClientCall this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    m_cRefs   = 1;
    m_dwFlags = 0;

    m_dwThreadId = GetCurrentThreadId();

#if DBG == 1
    m_dwSignature      = 0xCCCCCA11;
    m_dwWorkerThreadId = 0;
#endif
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::~CClientCall     public
//
//  Synopsis:   destructor for the client call object
//
//+-------------------------------------------------------------------
CClientCall::~CClientCall()
{
    CallDebugOut((DEB_CALL, "CClientCall::~CClientCall this:%x\n", this));
    Win4Assert(m_cRefs == 0);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::InitCallObject,  public
//
//  Synopsis:   Initialize the call object state before a call starts
//
//+-------------------------------------------------------------------
HRESULT CClientCall::InitCallObject(CALLCATEGORY       callcat,
                                    RPCOLEMESSAGE     *message,
                                    DWORD              flags,
                                    REFIPID            ipidServer,
                                    DWORD              destctx,
                                    COMVERSION         version,
                                    CChannelHandle    *handle)
{
    CallDebugOut((DEB_CALL, "CClientCall::InitCallObject this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // initialize the message call object
    HRESULT hr = CMessageCall::InitCallObject(callcat, message, flags, ipidServer,
                                              destctx, version, handle);
    if (SUCCEEDED(hr))
    {
        // Intialize the member variables
        m_hThread = 0;

        // Push this call object onto call stack
        if (flags & (client_cs | proxy_cs))
        {
            hr = gCallTbl.PushCallObject(this);
            Win4Assert(SUCCEEDED(hr) ? (m_cRefs == 2) : (m_cRefs == 1));
            if(SUCCEEDED(hr))
                m_dwFlags |= CALLFLAG_ONCALLSTACK;
        }
    }

#if DBG==1
    if(IsSTAThread())
            m_dwFlags |= CALLFLAG_STATHREAD;
    if(IsWOWThread())
            m_dwFlags |= CALLFLAG_WOWTHREAD;
#endif

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::UninitCallObject,     public
//
//  Synopsis:   Cleanup call state after a call has completed.
//
//+-------------------------------------------------------------------
void CClientCall::UninitCallObject()
{
    CallDebugOut((DEB_CALL, "CClientCall::UninitCallObject this:%x\n",this));

#if DBG==1
    if (IsClientSide())
    {
        // Assert that the call finished
        Win4Assert(!(m_dwFlags & CALLFLAG_ONCALLSTACK) ||
                           (m_dwFlags & CALLFLAG_CALLFINISHED));;
        Win4Assert(!IsCallDispatched() || IsCallCompleted());
    }
#endif

    // turn off all except the STA & WOW thread markings
    m_dwFlags = 0;

    if (_pContext != NULL)
    {
        _pContext->Release();
        _pContext = NULL;
    }

    // uninitialize the message call object
    CMessageCall::UninitCallObject();
}

//---------------------------------------------------------------------------
//
//  Function:   GetCallObject, public
//
//  Synopsis:   Accquires either an async call object or client call object
//
//---------------------------------------------------------------------------
INTERNAL GetCallObject(BOOL fAsync, CMessageCall **ppCall)
{
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        if (fAsync)
        {
            // find/create an async call object
            if (tls->pFreeAsyncCall)
            {
                // found an entry in TLS, take it
                *ppCall = (CMessageCall *) tls->pFreeAsyncCall;
                (*ppCall)->AddRef();
                tls->pFreeAsyncCall = NULL;
            }
            else
            {
                // not found, try the cache
                *ppCall = CAsyncCall::AllocCallFromList();
                if (*ppCall != NULL)
                {
                    (*ppCall)->AddRef();
                }
                else
                {
                    // still don't have one, go make a new one in the heap
                    *ppCall = (CMessageCall *) new CAsyncCall();
                }
            }
        }
        else
        {
            // find/create an client call object
            if (tls->pFreeClientCall)
            {
                // found an entry in TLS, take it
                *ppCall = (CMessageCall *) tls->pFreeClientCall;
                (*ppCall)->AddRef();
                tls->pFreeClientCall = NULL;
            }
            else
            {
                // not found, create one, either from the cache, or from the heap
                *ppCall = (CMessageCall *) new CClientCall();
            }
        }

        hr = (*ppCall == NULL) ? E_OUTOFMEMORY : S_OK;
    }
    else
        *ppCall = NULL;

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::QueryInterface
//
//  Synopsis:   Queries an interface.
//
//---------------------------------------------------------------------------
STDMETHODIMP CAsyncCall::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_ICancelMethodCalls) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (ICancelMethodCalls *) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::AddRef
//
//  Synopsis:   Add a reference.
//
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncCall::AddRef( )
{
    return InterlockedIncrement((long *)&_iRefCount);
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::Release
//
//  Synopsis:   Release a reference.
//
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncCall::Release( )
{
    ULONG lRef = InterlockedDecrement((long*)&_iRefCount);
    if (lRef == 0)
    {
        // uninitialize the call object
        UninitCallObject();

        // if there is room in tls, and this call belongs to the
        // current apartment, place the call object into TLS,
        // otherwise, delete it (which returns it to a cache)
        COleTls tls(TRUE);
        if ( !tls.IsNULL() &&
             tls->pFreeAsyncCall == NULL &&
             !(tls->dwFlags & OLETLS_THREADUNINITIALIZING) &&
             _lApt == GetCurrentApartmentId())
        {
            tls->pFreeAsyncCall = this;
        }
        else
        {
            // Add the structure to the list if the list is not full and
            // if the process is still initialized (since latent threads may try
            // to return stuff).
            if (!ReturnCallToList(this))
            {
                // no room in the cache, delete it
                delete this;
            }
        }
    }
    return lRef;
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::GetState     public
//
//  Synopsis:   Returns the current status of call object
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::GetState(DWORD *pdwState)
{
    CallDebugOut((DEB_CALL, "CAsyncCall::GetState\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (ProcessLocal())
    {
        // For process local calls, check the call state.
        *pdwState = _lFlags & CALLFLAG_USERMODEBITS;
    }
    else
    {
        // Otherwise ask RPC
        RPC_STATUS status;

        if (IsClientSide())
        {
            // On the client, check for complete.
            status = RpcAsyncGetCallStatus( &_AsyncState );
            if (status == RPC_S_ASYNC_CALL_PENDING)
                *pdwState = DCOM_NONE;
            else
                *pdwState = DCOM_CALL_COMPLETE;
        }
        else
        {
            // On the server, check for cancel.
            status = RpcServerTestCancel( _hRpc );
            if (status == RPC_S_OK)
                *pdwState = DCOM_CALL_CANCELED;
            else
                *pdwState = DCOM_NONE;
        }
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallCompleted     private
//
//  Synopsis:   This method is called when the reply for a call is
//              received.  If the call is canceled after this method
//              is invoked the reply must be freed.
//
//+-------------------------------------------------------------------
void CAsyncCall::CallCompleted(HRESULT hrRet)
{
#if DBG==1
    ULONG debFlags = DEB_CALL;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
            debFlags |= DEB_CANCEL;
    CallDebugOut((debFlags, "CAsyncCall::HRESULTCallComplete(0x%x, 0x%x)\n",
                              this, hrRet));
#endif
    Win4Assert(!(_lFlags & CALLFLAG_CALLCOMPLETED));

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having completed
    _lFlags |= CALLFLAG_CALLCOMPLETED;

    // Remove any pending cancel requests as the call has
    // completed before the client thread could detect
    // cancel
    if(_lFlags & CALLFLAG_CANCELISSUED)
    {
        Win4Assert(_lFlags & CALLFLAG_CALLCANCELED);
        _lFlags &= ~CALLFLAG_CANCELISSUED;
        _lFlags |= CALLFLAG_CLIENTNOTWAITING;
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallCompleted     private
//
//  Synopsis:   This method is called for process local calls when
//              the server sends the reply.  It changes the state
//              and returns the previous state atomicly.
//
//+-------------------------------------------------------------------
void CAsyncCall::CallCompleted( BOOL *pCanceled )
{
#if DBG==1
    ULONG debFlags = DEB_CALL;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
        debFlags |= DEB_CANCEL;
    CallDebugOut((debFlags, "CAsyncCall::BOOLCallComplete(0x%x, 0x%x)\n",
                  this, pCanceled));
#endif
    Win4Assert(!(_lFlags & CALLFLAG_CALLCOMPLETED));

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having completed
    _lFlags   |= CALLFLAG_CALLCOMPLETED;
    *pCanceled = _lFlags & CALLFLAG_CALLCANCELED;

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallFinished     private
//
//  Synopsis:   This function is called when all normal activity on a call
//              is complete (ie, when SendReceive gets a transmission error
//              or FreeBuffer completes).  The only way a call can continue
//              to exist after this method is called is if someone has a
//              pointer to the cancel interface on the call.
//
//+-------------------------------------------------------------------
void CAsyncCall::CallFinished()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CallFinished this:%x\n",this));

    // Sanity check
    Win4Assert(!FakeAsync() || (_lFlags & CALLFLAG_ONCALLSTACK));

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having finished
    _lFlags |= CALLFLAG_CALLFINISHED;

    // Pop the call from the call stack for fake async calls
    if(FakeAsync())
    {
        gCallTbl.PopCallObject((ICancelMethodCalls *)this);
        _lFlags &= ~CALLFLAG_ONCALLSTACK;
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if(FakeAsync())
    {
        // Fix up the refcount
        Release();
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallSent     private
//
//  Synopsis:   This method is called when the request has been sent.
//              Cancels that arrive before this method is invoked are
//              flagged.  Cancels that arrive after this method is
//              invoked can use the RPC cancel APIs.
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::CallSent()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CallSent this:%x\n",this));
    Win4Assert(!(_lFlags & CALLFLAG_CALLSENT));

    HRESULT hr = S_OK;

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having been sent.
    _lFlags |= CALLFLAG_CALLSENT;

    // Check if the call was canceled before it was sent
    if((_lFlags & CALLFLAG_CALLCANCELED) && !FakeAsync())
        hr = RPC_E_CALL_CANCELED;

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::WOWMsgArrived     private
//
//  Synopsis:   For WOW threads, there is a time lag between server
//              thread posting the OLE call completion message and
//              the client thread receiving the message. This method
//              is invoked by the client WOW thread that made the COM
//              call after it receives the OLE call completion message
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::WOWMsgArrived()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::WOWMsgArrived this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having finished
    _lFlags |= CALLFLAG_WOWMSGARRIVED;

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CanDispatch     public
//
//  Synopsis:   Returns S_OK if the call has not already been canceled
//              This calls handles the case when the call is canceled
//              between the GetBuffer and SendReceive
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::CanDispatch()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CanDispatch this:%x\n",this));

    HRESULT hr;
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Check if the call has been canceled
    if (_lFlags & CALLFLAG_CALLCANCELED && (m_ulCancelTimeout == 0))
    {
        hr = RPC_E_CALL_CANCELED;
    }
    else
    {
        // Update state
        hr = S_OK;
        m_dwStartCount = GetTickCount();
        _lFlags |= CALLFLAG_CALLDISPATCHED;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::Cancel     public
//
//  Synopsis:   Updates current status of call object
//
//  Descrption: This method is valid only on the client side for
//              canceling call
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::Cancel(ULONG ulTimeout)
{
    return Cancel(FALSE, ulTimeout);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::Cancel     public
//
//  Synopsis:   Updates current status of call object
//
//  Descrption: Since the async call object is not copied, the _iFlags
//              field always has the proxy bit set.
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::Cancel(BOOL fModalLoop, ULONG ulTimeout)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CAsyncCall::Cancel(0x%x, 0x%x, 0x%x)\n",
                              this, fModalLoop, ulTimeout));

    HRESULT hr;
    BOOL    fCancel = FALSE, fSignal = FALSE;

    // Assert that the call object is on the client side
    Win4Assert(IsClientSide());

    // check if cancel is enabled
    if (!(CancelEnabled() || fModalLoop))
    {
        HRESULT hr = CO_E_CANCEL_DISABLED;
        CallDebugOut((DEB_CALL|DEB_CANCEL,
                      "CAsyncCall::Cancel this:0x%x returning 0x%x - cancel disabled\n",
                       this, hr));
        return(hr);
    }

    // Assert that modal loop cancels have 0 timeout value
    Win4Assert(!fModalLoop || ulTimeout==0);

    // Validate arguments
    if(!fModalLoop && (_lFlags & CALLFLAG_WOWTHREAD))
    {
        // Support cancel for calls made by WOW threads
        // only from modal loop
        return(E_NOTIMPL);
    }
    else if(_callcat == CALLCAT_INPUTSYNC)
    {
        // Do not provide cancel support for Input Sync calls
        return(E_FAIL);
    }

    // Aquire COM lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Check state
    do
    {
        // Initialize
        hr = S_OK;

        if(_lFlags & (CALLFLAG_CALLCOMPLETED | CALLFLAG_CALLFINISHED))
        {
            // Call has completed
            hr = RPC_E_CALL_COMPLETE;
        }
        else if(_lFlags & CALLFLAG_CALLCANCELED)
        {
            // Do not support increasing cancel timeout
            if(m_ulCancelTimeout < ulTimeout)
                    hr = RPC_E_CALL_CANCELED;
        }
        else if(!FakeAsync() && (ulTimeout>0 && ulTimeout!=(ULONG)INFINITE))
        {
            // RPC does not support cancel timeout for async calls

            // Release lock
            UNLOCK(gCallLock);
            ASSERT_LOCK_NOT_HELD(gCallLock);

            // Check if TLS is initialized
            COleTls Tls(FALSE);

            // Call RPC to perform advisory cancel
            // We don't really care about the return code here....
            // but PREfix complains when we don't check it.  
            RPC_STATUS ignore = RpcAsyncCancelCall(&_AsyncState, FALSE);

            // Block this thread for the requested time
            if(Tls.IsNULL() || IsMTAThread())
            {
                Sleep(ulTimeout*1000);
            }
            else
            {
                // Create modal loop object
                // Since this is an async call, the callcat must
                // be CALLCAT_ASYNC. INPUTSYNC is explicitly
                // prevented above
                CCliModalLoop CML(0, gMsgQInputFlagTbl[CALLCAT_ASYNC], 0);

                // Start timer
                CML.StartTimer(ulTimeout*1000);

                // Loop till timer expires
                while (!CML.IsTimerAtZero())
                {
                    CML.BlockFn(NULL, 0, NULL);
                }
            }

            // Reset timeout
            ulTimeout = 0;

            // Reaquire COM lock
            ASSERT_LOCK_NOT_HELD(gCallLock);
            LOCK(gCallLock);

            // Loop back to check state
            hr = S_FALSE;
        }
    } while(hr == S_FALSE);

    if(hr == S_OK)
    {
        // Check if the thread that made the call is aware of
        // an earlier cancel request with timeout
        if(_lFlags & CALLFLAG_CANCELISSUED)
        {
            // Assert that this is a fake async call
            Win4Assert(FakeAsync());
            // Assert that we do not land here for calls made
            // by WOW threads
            Win4Assert(!(_lFlags & CALLFLAG_WOWTHREAD));

            // Just change the timeout to the new value as
            // the thread that made the call is still not aware
            // of the earlier cancel reuest
            Win4Assert(_lFlags & CALLFLAG_CALLCANCELED);
            m_ulCancelTimeout = ulTimeout;

            // If cancel is happening from inside the modal loop
            // wait on the event to revert its state
            if(fModalLoop)
            {
                Win4Assert(!ProcessLocal() && FakeAsync());
                Win4Assert(_hEvent);
                WaitForSingleObject(_hEvent, INFINITE);

                // Update state for modal loop cancels before
                // issuing RPC cancel
                _lFlags &= ~CALLFLAG_CANCELISSUED;

                // Cancel the call using RPC
                fCancel = TRUE;
            }
            // Else there is no more work to do as the thread that
            // made the call will wake up and process the
            // earlier cancel request
        }
        else
        {
            // Update the state
            if(!(_lFlags & CALLFLAG_CALLCANCELED))
                m_dwStartCount = GetTickCount();
            _lFlags |= CALLFLAG_CALLCANCELED;
            m_ulCancelTimeout = ulTimeout;

            // Assert that cancel from modal loop happens only after the
            // call has been dispatched
            Win4Assert(!fModalLoop || (FakeAsync() && IsCallDispatched()));

            // Assert that calls made by WOW threads can only be canceled
            // from inside modal loop
            Win4Assert(!(_lFlags & CALLFLAG_WOWTHREAD) || fModalLoop);

            // For pure async calls, there is no need to issue
            // cancel if the call has not yet been sent.
            // For FakeAsync calls, wake up the client thread
            // for positive cancel timeout values only if the call
            // has not been dispatched yet
            if(FakeAsync() ? (IsCallDispatched() || m_ulCancelTimeout>0) :
               IsCallSent())
            {
                if(ProcessLocal())
                {
                    // Assert that the call object does not represent
                    // a fake async call
                    Win4Assert(!FakeAsync());
                    Win4Assert(!fModalLoop);

                    // WOW threads cannot make async calls because there
                    // is no support for them in the thunking code
                    Win4Assert(!(_lFlags & CALLFLAG_WOWTHREAD));

                    // Inform the client that the call was canceled
                    if(ulTimeout == 0)
                    {
                        _lFlags |= CALLFLAG_CLIENTNOTWAITING;
                        fSignal = TRUE;
                    }
                }
                else
                {
                    // Check for fake async calls
                    if(FakeAsync())
                    {
                        Win4Assert(_hEvent);

                        // Do not call RPC async cancel function holding
                        // our lock
                        if(fModalLoop)
                        {
                            // Cancel the call using RPC
                            fCancel = TRUE;
                        }
                        else
                        {
                            // Wake up the actual client thread from the modal
                            // loop after updating state so that it knows
                            // there is timeout value
                            _lFlags |= CALLFLAG_CANCELISSUED;
                            SetEvent(_hEvent);
                        }
                    }
                    else
                    {
                        // For true async calls, cancel the call using RPC
                        // directly
                        fCancel = TRUE;
                    }
                }
            }
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Check for the need to cancel
    if(fSignal)
    {
        SignalTheClient(this);
    }
    else
    {
        // REVIEW: For normal async calls, the call could have completed
        //         after we released the lock above. The call completion
        //         might have called I_RpcFreeBuffer making the RPC state
        //         associated for the cancel stale
        if(fCancel)
        {
	   // Narrow the window for the race mentioned above
	   if(_lFlags & (CALLFLAG_CALLCOMPLETED | CALLFLAG_CALLFINISHED))
	   {
	       // Call has completed
	       hr = RPC_E_CALL_COMPLETE;
	   }
	   else
	   {
	      CallDebugOut((DEB_CALL|DEB_CANCEL,
			   "0x%x --> RpcAsyncCancelCall(0x%x, 0x%x)\n",
			    this, &_AsyncState, TRUE));
	      RPC_STATUS rpcStatus = RpcAsyncCancelCall(&_AsyncState, TRUE);
	      CallDebugOut((DEB_CALL|DEB_CANCEL,
			    "0x%x <-- RpcAsyncCancelCall returns 0x%x\n",
			     this, rpcStatus));
	      if(rpcStatus==RPC_S_OK)
	      {
		  if(fModalLoop)
		  {
		      Win4Assert(_hEvent);
		      WaitForSingleObject(_hEvent, INFINITE);
		  }
	      }
	      else
		  CallDebugOut((DEB_WARN,
			       "This: 0x%x RpcAsyncCancelCall failed returning 0x%x\n",
				this, rpcStatus));
	   }
        }
    }

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                "CAsyncCall::Cancel this:0x%x returning 0x%x\n", this, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::TestCancel     public
//
//  Synopsis:   Answers whether the current call has been canceled
//
//+-------------------------------------------------------------------
STDMETHODIMP CAsyncCall::TestCancel()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::TestCancel this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = RPC_S_CALLPENDING;
    if(IsClientSide() || ProcessLocal())
    {
        if(_lFlags & CALLFLAG_CALLCANCELED)
            hr = RPC_E_CALL_CANCELED;
        else if(_lFlags & CALLFLAG_CALLCOMPLETED)
            hr = RPC_E_CALL_COMPLETE;
    }
    else
    {
        if(RpcServerTestCancel(_hRpc) == RPC_S_OK)
            hr = RPC_E_CALL_CANCELED;
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::AdvCancel     public
//
//  Synopsis:   Implements advisory cancel for async calls
//              Called from inside modal loop
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::AdvCancel()
{
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gCallLock);
    Win4Assert(FakeAsync());

    // Call RPC to perform advisory cancel
    CallDebugOut((DEB_CALL|DEB_CANCEL,
                  "0x%x --> RpcAsyncCancelCall(0x%x, 0x%x)\n",
                   this, &_AsyncState, FALSE));
    RPC_STATUS rpcStatus = RpcAsyncCancelCall(&_AsyncState, FALSE);
    CallDebugOut((DEB_CALL|DEB_CANCEL,
                  "0x%x <-- RpcAsyncCancelCall returns 0x%x\n",
                   this, rpcStatus));

    if (rpcStatus == RPC_S_OK)
        return S_OK;

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThreadSignal
//
//  Synopsis:   Called by RPC to notify state changes of async calls.
//              Invokes the call's ISynchronize::Signal.
//
//----------------------------------------------------------------------------
void ThreadSignal(struct _RPC_ASYNC_STATE *hAsync, void *Context,
                  RPC_ASYNC_EVENT event )
{
    CAsyncCall *pCall = (CAsyncCall *)
                       (((char *) hAsync) - offsetof(CAsyncCall, _AsyncState));

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                 "ThreadSignal(Call:0x%x, Context:0x%x, Event:0x%x)\n",
                  pCall, Context, event));
        
    // If TLS can't be initialized, give up.
    HRESULT hr;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    // Client side
    if(RpcCallComplete == event)
    {
        Win4Assert( pCall->_eSignalState == pending_ss );
        pCall->_eSignalState = signaled_ss;
        
        if (pCall->_pChnlObj != NULL)
        {
            // Signal the Client.
    
            // Assert this is normal async call
            Win4Assert(!pCall->FakeAsync());
    
            // Inform call object about call completion
            pCall->CallCompleted(S_OK);
    
            SignalTheClient(pCall);
        }
        else
        {
            // Set the call event.
#if DBG==1
            pCall->Signaled();
#endif
    
            // Assert that this is fake async call
            Win4Assert(pCall->FakeAsync());
    
            // Inform call object about call completion
            pCall->CallCompleted(S_OK);
    
            // Wake up client thread after ensuring that
            // it is waiting
            if(pCall->IsClientWaiting())
                SetEvent(pCall->GetEvent());
    
            // Async call objects are addrefed before calling RPC
            pCall->Release();
        }
    }
    // Server side
    else if(RpcSendComplete == event) 
    {
        Win4Assert(0 < Tls->cAsyncSends);
        // Unchain it from the list
        Win4Assert(Tls->pAsyncCallList);
        CAsyncCall* pThis = Tls->pAsyncCallList;
        CAsyncCall* pPrev = NULL;
        while((NULL != pThis) && (pThis != pCall))
        {
            pPrev = pThis;
            pThis = pThis->_pNext; 
        }
        // Found a match
        if(pThis == pCall)
        {
            // Decrement the number of async sends outstanding
            Tls->cAsyncSends--;
            if(NULL == pPrev)
            {
                // First element in the list matched
                Tls->pAsyncCallList = Tls->pAsyncCallList->_pNext; 
            }
            else
            {
                // Element is in the middle of the list
                pPrev->_pNext = pThis->_pNext;
            }
            // Async call objects are addrefed before calling RPC
            pCall->Release();
        }
        else
        {
            Win4Assert(FALSE && 
                       "Callback from RPC for non-existent call object");
        }
    }
    else
    {
        Win4Assert("Unexpected callback from RPC to ThreadSignal");
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::Cleanup
//
//  Synopsis:   Free all elements in the cache.
//
//---------------------------------------------------------------------------
/* static */
void CAsyncCall::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    if (_iNext <= CALLCACHE_SIZE)
    {
        // Release all calls.
        for (DWORD i = 0; i < _iNext; i++)
        {
            if (_aList[i] != NULL)
            {
                delete _aList[i];
                _aList[i] = NULL;
            }
        }
        _iNext = 0;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+---------------------------------------------------------------------------
//
//  Function:   SignalTheClient
//
//  Synopsis:   Propgates the signal for a finished async cal to the correct
//              client.
//
//----------------------------------------------------------------------------
void  SignalTheClient(CAsyncCall *pCall)
{
    ComDebOut((DEB_CHANNEL, "SignalTheClient[in] pCall:0x%x\n", pCall));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    Win4Assert(GetCurrentApartmentKind() != APTKIND_NEUTRALTHREADED);

#if DBG==1
    pCall->Signaled();
#endif
    CChannelObject *pChnlObj = pCall->_pChnlObj;
    pCall->_pChnlObj = NULL;

    if (pCall->_lApt == NTATID)
    {
        COleTls tls;
        if (tls.IsNULL() == FALSE) //com1.x bug 25441. If we can't allocate tls, can't enter NTA. This hangs client, though.
        {
            CObjectContext *pSaveContext = EnterNTA(g_pNTAEmptyCtx);
            ComSignal(pChnlObj);
            pSaveContext = LeaveNTA(pSaveContext);
            Win4Assert(pSaveContext == g_pNTAEmptyCtx);
        }
    }
    else if (pCall->_lApt == MTATID)
    {
        // caller is in the MTA
        if (IsSTAThread())
        {
            // send to a cached MTA thread
            CacheCreateThread(ComSignal, pChnlObj);
        }
        else
        {
            // We are already on an MTA thread, probably on an RPC
            // thread.  Just signal the call directly from this
            // thread.
            Win4Assert(!IsThreadInNTA());
            ComSignal(pChnlObj);
        }
    }
    else
    {
        Win4Assert(pCall->_hwndSTA);

        // there is a window for us to call back
        // on.  this means we need to switch threads so
        // the signal will happen in the callers apartment
        //
        // First thing, we need the apartment.
        CComApartment *pTargetApt = NULL;
        HRESULT hr = GetApartmentByID(pCall->_lApt, &pTargetApt);
        if (SUCCEEDED(hr))
        {
            // Takes a reference on the call object if successful.
            hr = pTargetApt->QueueMessage(WM_OLE_SIGNAL, (IMessageParam *)pChnlObj);
            Win4Assert(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                if (!PostMessage(pCall->_hwndSTA, WM_OLE_SIGNAL,
                                 WMSG_MAGIC_VALUE, (LPARAM)((IMessageParam *)pChnlObj)))
                {
                    ComDebOut((DEB_ERROR, "SignalTheClient: PostMessage to switch threads failed!\n"));

                    // Remove the message from the target apartment queue and release
                    // the reference the queue took.
                    hr = pTargetApt->RemoveMessage(WM_OLE_SIGNAL, (IMessageParam *)pChnlObj);
                    if (SUCCEEDED(hr))
                        pChnlObj->Release();
                }
            }

            pTargetApt->Release();
        }
    }

    ComDebOut((DEB_CHANNEL, "SignalTheClient[out] \n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   ComSignal
//
//  Synopsis:   Called after switching to the correct apartment.  Signals
//              the caller and then releases the reference we hold during
//              the call.
//
//----------------------------------------------------------------------------
DWORD _stdcall ComSignal(void *pParam)
{
    ASSERT_LOCK_NOT_HELD(gCallLock);
    CChannelObject *pChnlObj = (CChannelObject *) pParam;
    ComDebOut((DEB_CHANNEL, "ComSignal [in] pChnlObj:0x%x\n", pChnlObj));

    pChnlObj->Signal();

    ComDebOut((DEB_CHANNEL, "ComSignal [out]\n"));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::QueryInterface     public
//
//  Synopsis:   QI behavior of client call object
//
//+-------------------------------------------------------------------
STDMETHODIMP CClientCall::QueryInterface(REFIID riid, LPVOID *ppv)
{
    CallDebugOut((DEB_CALL, "CClientCall::QueryInterface this:%x riid:%I\n",
                              this, &riid));

    if(IsEqualIID(riid, IID_ICancelMethodCalls) ||
       IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (ICancelMethodCalls *) this;
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    // AddRef the interface before return
    ((IUnknown *) (*ppv))->AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::AddRef     public
//
//  Synopsis:   AddRefs client call object
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCall::AddRef()
{
    CallDebugOut((DEB_CALL, "CClientCall::AddRef this:%x\n",this));

    ULONG cRefs = InterlockedIncrement((LONG *)& m_cRefs);
    if(m_dwFlags & CALLFLAG_INDESTRUCTOR)
    {
        // Always return 0 when inside the destructor
        cRefs = 0;
    }

    return(cRefs);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Release     public
//
//  Synopsis:   Release client call object. Gaurds against
//              double destruction that can happen if it aggregates
//              another object and gets nested AddRef and Release on
//              the thread invoking the destructor
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCall::Release()
{
    CallDebugOut((DEB_CALL, "CClientCall::Release this:%x\n",this));

    ULONG cRefs = InterlockedDecrement((LONG *) &m_cRefs);
    if(cRefs == 0)
    {
        // uninitialize the call object
        UninitCallObject();

        // if there is room, place this call object into TLS,
        // otherwise, delete it.
        COleTls tls(TRUE);
        if ( !tls.IsNULL() &&
             tls->pFreeClientCall == NULL &&
             !(tls->dwFlags & OLETLS_THREADUNINITIALIZING) &&
             m_dwThreadId == GetCurrentThreadId())
        {
            tls->pFreeClientCall = this;
        }
        else
        {
            // Mark as in destructor & delete the call
             m_dwFlags |= CALLFLAG_INDESTRUCTOR;
             delete this;
        }
    }

    return(cRefs);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::operator new     public
//
//  Synopsis:   new operator for client call object
//
//+-------------------------------------------------------------------
void *CClientCall::operator new(size_t size)
{
    Win4Assert(size == sizeof(CClientCall) &&
               "Client Call object should not be inherited");

    void *pCall = NULL;

    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);
    if (_iNext > 0 && _iNext < CALLCACHE_SIZE+1)
    {
        // Get the last entry from the cache.
        _iNext--;
        pCall = _aList[_iNext];
        _aList[_iNext] = NULL;
    }
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (pCall == NULL)
    {
        // None available in the cache, allocate a new one. Don't
        // hold the lock over heap allocations
        pCall = PrivMemAlloc(size);
    }

    return pCall;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::operator delete     public
//
//  Synopsis:   delete operator for Client call object
//
//+-------------------------------------------------------------------
void CClientCall::operator delete(void *pCall)
{
    // Add the structure to the list if the list is not full and
    // if the process is still initialized (since latent threads may try
    // to return stuff).

    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);
    if (_iNext < CALLCACHE_SIZE && gfChannelProcessInitialized)
    {
        _aList[_iNext] = pCall;
        _iNext++;
        pCall = NULL;  // don't need to memfree
    }
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (pCall)
    {
        // no room in cache, return to heap.
        // don't hold lock over heap free
        PrivMemFree(pCall);
    }
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Cleanup     public
//
//  Synopsis:   Either performs cleanup or updates the state such that
//              cleanup is performed when the last object is destroyed
//
//+-------------------------------------------------------------------
/* static */
void CClientCall::Cleanup()
{
    CallDebugOut((DEB_CALL, "CClientCall::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    if (_iNext <= CALLCACHE_SIZE)
    {
        // Release all calls.
        for (DWORD i = 0; i < _iNext; i++)
        {
            if (_aList[i] != NULL)
            {
                delete _aList[i];
                _aList[i] = NULL;
            }
        }
        _iNext = 0;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::GetState     public
//
//  Synopsis:   Returns the current status of call object
//
//+-------------------------------------------------------------------
HRESULT CClientCall::GetState(DWORD *pdwState)
{
    CallDebugOut((DEB_CALL, "CClientCall::GetState this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    *pdwState = (m_dwFlags & CALLFLAG_USERMODEBITS);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CallCompleted     private
//
//  Synopsis:   Completes the specified call. To avoid race condtions
//              between cancel and complete, both Complete and Cancel
//              methods should use the same synchronization event for
//              waking up the thread that made the call.
//
//              This method is invoked by the server thread for process local
//              calls and by the thread that made the RPC call for
//              process remote calls
//
//              To prevent the race in canceling RPC calls, the thread
//              waits alertably if the call completes successfully
//              after it was canceled, so that any pending user mode
///             cancel APC enqueued by RPC would be removed
//
//+-------------------------------------------------------------------
void CClientCall::CallCompleted(HRESULT hrRet)
{
#if DBG==1
    ULONG debFlags = DEB_CALL;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
            debFlags |= DEB_CANCEL;
#endif
    CallDebugOut((debFlags, "CClientCall::CallComplete(0x%x, 0x%x)\n",
                              this, hrRet));

    // Assert that this method is invoked only once
    Win4Assert(!(m_dwFlags & CALLFLAG_CALLCOMPLETED));

    // Assert that the method is invoked by the thread that
    // made the actual call
    Win4Assert(m_dwWorkerThreadId == GetCurrentThreadId());

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having completed
    m_dwFlags |= CALLFLAG_CALLCOMPLETED;

    // Update state
    if(m_dwFlags & CALLFLAG_CALLCANCELED)
    {
        // Check if the call is process local
        if(ProcessLocal())
        {
            // Remove any pending cancel requests as the call has
            // completed before the client thread could detect
            // cancel
            if(m_dwFlags & CALLFLAG_CANCELISSUED)
            {
                m_dwFlags &= ~CALLFLAG_CANCELISSUED;
                m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
            }
        }
        else
        {
            // Assert that STA threads do not make cross process
            // SYNC calls
            Win4Assert(!(m_dwFlags & CALLFLAG_STATHREAD) &&
                               "STA thread is making a SYNC call");

            // Prevent the race in canceling RPC calls
            if(hrRet != RPC_E_CALL_CANCELED)
            {
                if(_hEvent)
                {
                    // Wait on the call event alertably to remove
                    // pending Cancel APC enqueued by RPC runtime
                    WaitForSingleObjectEx(_hEvent, 0, TRUE);
                }
                else
                {
                    // Sleep alertably for zero seconds. Note that
                    // this makes the thread forgo the rest of the
                    // CPU time slice
                    SleepEx(0, TRUE);
                }
            }
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CallFinished     private
//
//  Synopsis:   The specified call is marked as finished. This method
//              is invoked by the thread that made the COM call when
//              it is unblocked.
//
//              NOTE: The call object might be destroyed in this method
//                    call. The caller should be careful not to touch
//                    any member variables of the call object after
//                    this method call
//+-------------------------------------------------------------------
void CClientCall::CallFinished()
{
    CallDebugOut((DEB_CALL, "CClientCall::CallFinished this:%x\n",this));

    // Ensure that the method is invoked by the thread that
    // made the COM call
    Win4Assert(m_dwThreadId == GetCurrentThreadId());
    Win4Assert(m_dwFlags & CALLFLAG_ONCALLSTACK);

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having finished
    m_dwFlags |= CALLFLAG_CALLFINISHED;

    // Pop this call object from the call stack
    gCallTbl.PopCallObject((ICancelMethodCalls *)this);
    m_dwFlags &= ~CALLFLAG_ONCALLSTACK;

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Fixup the refcount
    Release();
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::WOWMsgArrived     private
//
//  Synopsis:   For WOW threads, there is a time lag between server
//              thread posting the OLE call completion message and
//              the client thread receiving the message. This method
//              is invoked by the client WOW thread that made the COM
//              call after it receives the OLE call completion message
//
//+-------------------------------------------------------------------
HRESULT CClientCall::WOWMsgArrived()
{
    CallDebugOut((DEB_CALL, "CClientCall::WOWMsgArrived this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Ensure that the method is invoked by the thread that
    // made the COM call
    Win4Assert(m_dwThreadId == GetCurrentThreadId());

    // Aquire lock
    LOCK(gCallLock);

    // Mark the call as having finished
    m_dwFlags |= CALLFLAG_WOWMSGARRIVED;

    // Release lock
    UNLOCK(gCallLock);

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CanDispatch     public
//
//  Synopsis:   Returns S_OK if the call has not already been canceled
//              This calls handles the case when the call is canceled
//              between the GetBuffer and SendReceive
//
//              IMPORTANT NOTE: This method should be invoked on the
//                              thread that is going to make RPC call
//
//+-------------------------------------------------------------------
HRESULT CClientCall::CanDispatch()
{
    CallDebugOut((DEB_CALL, "CClientCall::CanDispatch this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;
    BOOL fRet;
    HANDLE hThread = NULL;
    DWORD dwThreadId = GetCurrentThreadId();

#if DBG == 1
    
    // Ensure that for process local calls, the thread making the call
    // is different from thread that made the COM call
    
    if(ProcessLocal() && !Neutral() && !IsNAToMTAFlagSet() && !IsNAToSTAFlagSet())
        Win4Assert(m_dwThreadId != dwThreadId);
    
    // NOTE:The original test is not valid for calls from the NA on a proxy
    // because before the call is dispatched we leave the NA
    // Hence added the new flag. Also the original test was
    // checking if the current thread is in the NA. This is
    // wrong, the correct test is to check if the server is in the NA -Sajia.
	
    if (!ProcessLocal())
    {
       // Ensure that MTA threads make direct RPC calls
       if(!(m_dwFlags & CALLFLAG_STATHREAD))
	   Win4Assert(m_dwThreadId == dwThreadId);
       // Ensure that STA threads do not make direct RPC calls
       else
	   Win4Assert(IsThreadInNTA() || m_dwThreadId != dwThreadId);
       // NOTE: the STA check above is useless because remote calls 
       // from the STA are always async, so we don't get here -Sajia.
    }
    // Save the worker thread id
    m_dwWorkerThreadId = dwThreadId;
#endif

    // Aquire lock
    LOCK(gCallLock);

    // Check if the call has been canceled
    if((m_dwFlags & CALLFLAG_CALLCANCELED) && (m_ulCancelTimeout == 0))
    {
        hr = RPC_E_CALL_CANCELED;
    }
    else
    {
        // Initialize the return value
        hr = S_OK;
        m_dwStartCount = GetTickCount();

        // Obtain non psuedo handle to the thread for calls
        // other than process local calls
        if(!ProcessLocal())
        {
            COleTls Tls(hr);

            // Initialize
            if(SUCCEEDED(hr))
                    hThread = Tls->hThread;

            // Assert that STA threads do not make cross process
            // SYNC calls
            Win4Assert(!(m_dwFlags & CALLFLAG_STATHREAD) &&
                               "STA thread is making a SYNC call");

            // MTA threads make direct RPC calls
            if(SUCCEEDED(hr) && !hThread)
            {
                // The system call below should not fail
                fRet = DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
                                       GetCurrentProcess(), &Tls->hThread,
                                       0, FALSE, DUPLICATE_SAME_ACCESS);

                // Set the default cancel time out to 0 seconds
                if(fRet)
                {
                    hThread = Tls->hThread;
                    RPC_STATUS st = RpcMgmtSetCancelTimeout(0);
                    Win4Assert(st == RPC_S_OK);
                }
                else
                {
                    CallDebugOut((DEB_WARN,
                                  "This: 0x%x Duplicate handle failed\n", this));
                    hr = RPC_E_SYS_CALL_FAILED;
                }
            }
        }

        // Update state
        if(SUCCEEDED(hr))
        {
            m_dwFlags |= CALLFLAG_CALLDISPATCHED;
            m_hThread = hThread;
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Cancel     public
//
//  Synopsis:   Attempts to cancel this call
//
//+-------------------------------------------------------------------
STDMETHODIMP CClientCall::Cancel(ULONG ulTimeout)
{
    return Cancel(FALSE, ulTimeout);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Cancel     public
//
//  Synopsis:   Worker routine that implements functionality to
//              cancel this call
//
//+-------------------------------------------------------------------
HRESULT CClientCall::Cancel(BOOL fModalLoop, ULONG ulTimeout)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CClientCall::Cancel(0x%x, 0x%x, 0x%x)\n",
                              this, fModalLoop, ulTimeout));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Assert that the call object is on the
    // client side
    Win4Assert(IsClientSide());

    // check if cancel is enabled
    if (!(CancelEnabled() || fModalLoop))
    {
        HRESULT hr = CO_E_CANCEL_DISABLED;
        CallDebugOut((DEB_CALL|DEB_CANCEL,
                     "CClientCall::Cancel this:0x%x returning 0x%x - cancel disabled\n",
                      this, hr));
        return(hr);
    }


    HRESULT hr = S_OK;
    DWORD dwThreadId;
    CallEntry *pEntry;


    // Assert that modal loop cancels have 0 timeout value
    Win4Assert(!fModalLoop || ulTimeout==0);

    // Validate arguments
    if(!fModalLoop && (m_dwFlags & CALLFLAG_WOWTHREAD))
    {
        // Support cancel for calls made by WOW threads
        // only from modal loop
        return(E_NOTIMPL);
    }
    else if(_callcat == CALLCAT_INPUTSYNC)
    {
        // Do not provide cancel support for Input Sync calls
        return(E_FAIL);
    }

    // Aquire COM lock
    LOCK(gCallLock);

    // Check if the state has changed while we waited to aquire the lock
    if(m_dwFlags & (CALLFLAG_CALLCOMPLETED | CALLFLAG_CALLFINISHED))
    {
        // Call has completed
        hr = RPC_E_CALL_COMPLETE;
    }
    else if(m_dwFlags & CALLFLAG_CALLCANCELED)
    {
        // Do not support increasing cancel timeout
        if(m_ulCancelTimeout < ulTimeout)
            hr = RPC_E_CALL_CANCELED;
    }

    if(hr == S_OK)
    {
        // Check if the thread that made the call is aware of
        // an earlier cancel request
        if(m_dwFlags & CALLFLAG_CANCELISSUED)
        {
            // Assert that we do not end up here for calls made
            // by WOW threads
            Win4Assert(!(m_dwFlags & CALLFLAG_WOWTHREAD));

            // Just change the timeout to the new value as
            // the thread that made the call is still not aware
            // of the earlier cancel reuest
            Win4Assert(m_dwFlags & CALLFLAG_CALLCANCELED);
            m_ulCancelTimeout = ulTimeout;

            // If cancel is happening from inside the modal loop
            // wait on the event to revert its state
            if(fModalLoop)
            {
                Win4Assert(_hEvent);
                WaitForSingleObject(_hEvent, INFINITE);

                m_dwFlags &= ~CALLFLAG_CANCELISSUED;
                m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
            }
            // Else there is no more work to do as the thread that
            // made the call will wake up and process the
            // earlier cancel request
        }
        else
        {
            // Update the state
            if(!(m_dwFlags & CALLFLAG_CALLCANCELED))
                m_dwStartCount = GetTickCount();
            m_dwFlags |= CALLFLAG_CALLCANCELED;
            m_ulCancelTimeout = ulTimeout;

            // Assert that calls made by WOW threads can only be canceled
            // from inside modal loop
            Win4Assert(!(m_dwFlags & CALLFLAG_WOWTHREAD) || fModalLoop);

            // Wake up the client thread for positive cancel timeout
            // values only if the call has not yet been dispatched
            if(IsCallDispatched() || m_ulCancelTimeout>0)
            {
                // Unblock the thread that made the call
                if(ProcessLocal())
                {
                    // For STA threads, the call can be canceled by the
                    // same thread that made the call. This can happen
                    // either inside modal loop or when a new call is
                    // dispatched to the STA thread

                    // NOTE: Irrespective of the threading model of the
                    // caller thread, calls to RTA are executed directly
                    // on the thread making the call. As calling thread
                    // is not blocked waiting for call completion, cancels
                    // on such are inherently advisory in nature. Gopalk

                    // Check for the modal loop case
                    if(fModalLoop)
                    {
                        // The thread has already unblocked
                        // Nothing more to do

                        // Mark the client thread as not waiting
                        m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
                    }
                    else if(m_ulCancelTimeout != (ULONG) INFINITE)
                    {
                        // Wake up the thread that made the call
                        m_dwFlags |= CALLFLAG_CANCELISSUED;
                        Win4Assert(_hEvent);
                        SetEvent(_hEvent);
                    }
                }
                else
                {
                    // STA threads do not make cross process sync calls
                    Win4Assert(!fModalLoop && !(m_dwFlags & CALLFLAG_STATHREAD));

                    // Cancel the RPC call
                    if (_destObj.GetDestCtx() != MSHCTX_DIFFERENTMACHINE)
                    {
                        // RPC has not yet implemented cancel facility for
                        // LRPC calls.
                        hr = E_NOTIMPL;
                    }
                    else
                    {
                        // Must be a remote call
                        RPC_STATUS rpcStatus;

                        Win4Assert(m_hThread);
                        CallDebugOut((DEB_CALL|DEB_CANCEL,
                                     "0x%x --> RpcCancelThreadEx(0x%x, 0x%x)\n",
                                      this, m_hThread, m_ulCancelTimeout));
                        rpcStatus = RpcCancelThreadEx(m_hThread, m_ulCancelTimeout);
                        CallDebugOut((DEB_CALL|DEB_CANCEL,
                                      "0x%x <-- RpcCancelThreadEx returns 0x%x\n",
                                       this, rpcStatus));
                    }
                }
            }
	    else if (!IsCallDispatched() && ProcessLocal() && fModalLoop) 
	    {
	       //Process local call, cancelled before dispatch
	       // mark the client as not waiting, if we are called
	       // from the modal loop
	       m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
	    }
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                 "CClientCall::Cancel this:0x%x returning 0x%x\n", this, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CClientCall::TestCancel     public
//
//  Synopsis:   Answers whether the current call has been canceled
//
//+-------------------------------------------------------------------
STDMETHODIMP CClientCall::TestCancel()
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CClientCall::TestCancel this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = RPC_S_CALLPENDING;

    if(m_dwFlags & CALLFLAG_CALLCANCELED)
        hr = RPC_E_CALL_CANCELED;
    else if(m_dwFlags & CALLFLAG_CALLCOMPLETED)
        hr = RPC_E_CALL_COMPLETE;

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                  "CClientCall::TestCancel this:0x%x hr 0x%x\n", this, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::AdvCancel     public
//
//  Synopsis:   Implements advisory cancel for sync calls
//              It is a No Op for sync calls
//
//+-------------------------------------------------------------------
HRESULT CClientCall::AdvCancel()
{
    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CMessageCall::GetTimeout     private
//
//  Synopsis:   Retuns the timeout value in milliseconds
//
//+-------------------------------------------------------------------
DWORD CMessageCall::GetTimeout()
{
    DWORD dwTimeout = 0;
    long lRemTime, lElapsedTime;

    if(m_ulCancelTimeout == (ULONG) INFINITE)
        dwTimeout = (DWORD) INFINITE;
    else if(m_ulCancelTimeout > 0)
    {
        lElapsedTime = GetTickCount() - m_dwStartCount;
        lRemTime = m_ulCancelTimeout*1000 - lElapsedTime;
        if(lRemTime > 0)
            dwTimeout = lRemTime;
    }

    return(dwTimeout);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::ResolveCancel     private
//
//  Synopsis:   Called by STA threads from inside modal loop and MTA
//              threads immediatly after unblocking
//
//+-------------------------------------------------------------------
HRESULT CMessageCall::RslvCancel(DWORD &dwSignal, HRESULT hrIn,
                                 BOOL fPostMsg, CCliModalLoop *pCML)
{
#if DBG==1
    ULONG debFlags = DEB_LOOP;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
        debFlags |= DEB_CANCEL;
#endif
    CallDebugOut((debFlags,
                  "CMessageCall::RslvCancel(0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n",
                   this, dwSignal, hrIn, fPostMsg, pCML));


    HRESULT hrOut = RPC_S_CALLPENDING;
    BOOL fCancel = FALSE, fAdvCancel = FALSE, fReset = FALSE;
    DWORD dwTimeout;

    // Sanity checks
    Win4Assert((hrIn==S_OK) == (dwSignal==WAIT_OBJECT_0));
    Win4Assert(hrIn==RPC_S_CALLPENDING || hrIn==S_OK || hrIn==RPC_E_CALL_CANCELED);

    // X-Process calls made by WOW threads use event
    // Process local calls made WOW threads use messages
    // for call completion notification
    Win4Assert(fPostMsg == (IsWOWThread() && ProcessLocal()));

    // Check the status of call
    if((dwSignal - WAIT_OBJECT_0) == 0)
    {
        if(!IsCancelIssued())
        {
            // Call was completed normally, take the fast path exit
            CallDebugOut((debFlags,
                         "CMessageCall::RslvCancel this:0x%x returning hr:0x%x\n",
                          this, S_OK));
           return S_OK;
        }

        // Acquire lock
        LOCK(gCallLock);

        // Check for event getting signaled due to the
        // call being canceled
        if (IsCancelIssued())
        {
            // Obtain timeout
            dwTimeout = GetTimeout();
            if(dwTimeout)
                fAdvCancel = TRUE;
            else
                fCancel = TRUE;

            // Acknowledge cancel request
            AckCancel();

            CallDebugOut((debFlags, "CMessageCall::RslvCancel CancelIssued "
                         "this:0x%x Timeout:0x%x\n", this, dwTimeout));
        }
        else
        {
            // Assert that the call has completed
            Win4Assert(!IsCallDispatched() || IsCallCompleted());
            Win4Assert(hrIn == S_OK);
            hrOut = S_OK;

            CallDebugOut((debFlags, "CMessageCall::RslvCancel CallCompleted "
                         "this:0x%x hrOut:0x%x\n", this, hrOut));
        }

        // Release lock
        UNLOCK(gCallLock);
    }
    else if(hrIn == RPC_S_CALLPENDING)
    {
        // Calls made by WOW threads can only be canceled
        // from inside modal loop
        if(fPostMsg)
        {
            // Check for call completion
            if(HasWOWMsgArrived())
                hrOut = S_OK;

            CallDebugOut((debFlags, "CMessageCall::RslvCancel WOWCall "
                         "this:0x%x hrOut:0x%x\n", this, hrOut));
        }
        else if(IsCallCanceled())
        {
            // Obtain timeout
            dwTimeout = GetTimeout();
            if(dwTimeout == 0)
                fCancel = TRUE;

            CallDebugOut((debFlags, "CMessageCall::RslvCancel CancelPending "
                         "this:0x%x Timeout:0x%x\n", this, dwTimeout));
        }
    }

    // Check for the need to cancel call
    if(fCancel || hrIn==RPC_E_CALL_CANCELED)
    {
        // The call was canceled from inside modal loop
        // or due to cancel timeout
        // Inform call object about cancel
        hrIn = Cancel(TRUE, 0);

        CallDebugOut((debFlags, "CMessageCall::RslvCancel this:0x%x "
                     "ModalLoop Cancel returned hr:0x%x\n", this, hrIn));

        if(hrIn == RPC_E_CALL_COMPLETE)
        {
            // Wait for the call to finish
            if(fPostMsg)
            {
                // The thread needs to pump messages till the completion
                // message is received
                if(HasWOWMsgArrived())
                    hrOut = S_OK;
                else
                    fReset = TRUE;
            }
            else
            {
                WaitForSingleObject(_hEvent, INFINITE);
                hrOut = S_OK;
            }
        }
        else if(hrIn == RPC_E_CALL_CANCELED)
        {
            // Assert that we never end up here
            Win4Assert(!"Modal Loop cancel returning RPC_E_CALL_CANCELED");
        }
        else
        {
            Win4Assert(hrIn == S_OK);
            hrOut = RPC_E_CALL_CANCELED;
        }
    }
    else if(fAdvCancel)
    {
        // Inform the server that the client is no longer interested
        // in results of this call
        hrIn = AdvCancel();
        fReset = TRUE;

        CallDebugOut((debFlags, "CMessageCall::RslvCancel this:0x%x "
                     "ModalLoop AdvCancel returned hr:0x%x\n", this, hrIn));
    }

    // Reset state if returning back to modal loop
    if(fReset && pCML)
    {
        pCML->ResetState();
        dwSignal = 0xFFFFFFFF;
    }

    CallDebugOut((debFlags, "CMessageCall::RslvCancel this:0x%x returning hr:0x%x\n",
                  this, hrOut));
    return(hrOut);
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetCancelObject
//
//  Synopsis:   Obtains the cancel object of the topmost call
//
//+-------------------------------------------------------------------
WINOLEAPI CoGetCancelObject(DWORD dwThreadId, REFIID iid, void **ppUnk)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoGetCancelObject(0x%x, 0x%x)\n",
                              dwThreadId, ppUnk));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = S_OK;
    ICancelMethodCalls *pCancel;

    // Validate argument
    if(!IsValidPtrOut(ppUnk, sizeof(void *)))
        hr = E_INVALIDARG;

    if(SUCCEEDED(hr))
    {
        // Check for the need to get current thread id
        if(dwThreadId == 0)
            dwThreadId = GetCurrentThreadId();

        // Get the entry for the given thread
        pCancel = gCallTbl.GetEntry(dwThreadId);

        if(pCancel)
        {
            // Check if the desired interface is IID_ICancelMethodCalls
            if(IsEqualIID(iid, IID_ICancelMethodCalls))
            {
                *ppUnk = pCancel;
            }
            else
            {
                // QI for the desired interface
                hr = pCancel->QueryInterface(iid, ppUnk);

                // Fix up the ref count
                pCancel->Release();
            }
        }
        else
            hr = RPC_E_NO_CONTEXT;
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoGetCancelObject returning 0x%x\n",
                              hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoSetCancelObject
//
//  Synopsis:   Sets the cancel object for the topmost call
//
//+-------------------------------------------------------------------
WINOLEAPI CoSetCancelObject(IUnknown *pUnk)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoSetCancelObject(0x%x)\n", pUnk));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = S_OK;

    // Validate argument
    if(pUnk && !IsValidInterface(pUnk))
        hr = E_INVALIDARG;

    if(SUCCEEDED(hr))
    {
        ICancelMethodCalls *pCancel = NULL;

        if(pUnk)
        {
            // QI for ICancelMethodCalls interface
            hr = pUnk->QueryInterface(IID_ICancelMethodCalls, (void **) &pCancel);
        }

        if(SUCCEEDED(hr))
        {
            // Set or clear the entry for the current thread
            if (pCancel)
            {
                hr = gCallTbl.PushCallObject(pCancel);
                pCancel->Release();
            }
            else
            {
                LOCK(gCallLock);
                IUnknown *pUnkCall = gCallTbl.PopCallObject(NULL);
                UNLOCK(gCallLock);
                if (pUnkCall)
                {
                    pUnkCall->Release();
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoSetCancelObject returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoCancelCall
//
//  Synopsis:   Cancels the topmost call of the given thread
//
//+-------------------------------------------------------------------
WINOLEAPI CoCancelCall(DWORD dwThreadId, ULONG ulTimeout)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoCancelCall(0x%x)\n", dwThreadId));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Obtain the cancel object for the given thread
    ICancelMethodCalls *pCancel;
    HRESULT hr = CoGetCancelObject(dwThreadId, IID_ICancelMethodCalls, (void **)&pCancel);
    if(SUCCEEDED(hr))
    {
        // Cancel the call
        hr = pCancel->Cancel(ulTimeout);
        pCancel->Release();
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoCancelCall returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoTestCancel
//
//  Synopsis:   Called by the server to check if the cuurent call has
//              been canceled by the client
//
//+-------------------------------------------------------------------
WINOLEAPI CoTestCancel()
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoTestCancel()\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Obtain the cancel object for the given thread
    ICancelMethodCalls *pCancel;
    HRESULT hr = CoGetCallContext(IID_ICancelMethodCalls, (void **) &pCancel);
    if(SUCCEEDED(hr))
    {
        // Test for cancel
        hr = pCancel->TestCancel();
        pCancel->Release();
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoTestCancel returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoEnableCallCancellation
//
//  Synopsis:   Called by the client to enable cancellation of calls
//
//+-------------------------------------------------------------------
WINOLEAPI CoEnableCallCancellation(void *pReserved)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoEnableCallCancellation()\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;

    if (pReserved != NULL)
        return E_INVALIDARG;

    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    // Increment thread callCancellation count
    tls->cCallCancellation++;

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoDisableCallCancellation
//
//  Synopsis:   Called by the client to disable call cancellation (default)
//
//+-------------------------------------------------------------------
WINOLEAPI CoDisableCallCancellation(void *pReserved)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoDisableCallCancellation()\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;

    if (pReserved != NULL)
        return E_INVALIDARG;

    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    if (tls->cCallCancellation < 1)
        return CO_E_CANCEL_DISABLED;

    // decrement thread callCancellation count
    tls->cCallCancellation--;

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   ReleaseMarshalBuffer
//
//  Synopsis:   Called by channel when call is aborted to release
//              interface pointers in the marshal buffer.
//
//+-------------------------------------------------------------------
INTERNAL ReleaseMarshalBuffer(
   RPCOLEMESSAGE *pMessage,
   IUnknown      *punk,
   BOOL           fOutParams
   )
{
#if 0
    if (CairoleInfoLevel == 0)
    {
        CallDebugOut((DEB_WARN, "ReleaseMarshalBuffer() doing nothing\n"));
        return S_OK;
    }
#endif

    // If fOutParams is TRUE, then we're supposed to be freeing out parameters.
    // Otherwise, we're supposed to be freeing in parameters.
    //
    // These are the magic numbers that tell RPC what to do.
#define RELEASE_IN   (0)
#define RELEASE_OUT  (1)
    DWORD dwFlags = (fOutParams) ? RELEASE_OUT : RELEASE_IN;

    HRESULT hr;
    IReleaseMarshalBuffers *pRMB = NULL;
    hr = punk->QueryInterface(IID_IReleaseMarshalBuffers, (void**)&pRMB);
    if (SUCCEEDED(hr))
    {
        hr = pRMB->ReleaseMarshalBuffer(pMessage, dwFlags, NULL);
        pRMB->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\chancont.cxx ===
//----------------------------------------------------------------------------
//
//  copyright (c) 1992  Microsoft Corporation
//
//  File:       chancont.cxx
//
//  Abstract:   This module contains thread switching code for the single
//              threaded mode.
//
//  History:    29 Dec 1993 Alex Mitchell   Creation.
//              Mar 1994    JohannP         Added call category support.
//              19 Jul 1994 CraigWi         Added support for ASYNC calls
//              27-Jan-95   BruceMa         Don't get on CChannelControl list unless
//                                          constructor is successsful
//              01-Nov-96   RichN           Add pipe support.
//              17-Oct-97   RichN           Remove pipes.
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include <chancont.hxx>
#include <channelb.hxx>
#include <threads.hxx>
#include <objerror.h>
#include <callctrl.hxx>
#include <service.hxx>
#include <ipidtbl.hxx>
#include <giptbl.hxx>
#include <callmgr.hxx>
#include <ole2int.h>      // CacheCreateThread

//----------------------------------------------------------------------------
// Prototypes.

HRESULT DispatchOnNewThread         (CMessageCall *);
HRESULT TransmitCall                ( OXIDEntry *, CMessageCall * );
void    WakeUpWowClient             (CMessageCall *pcall);

//----------------------------------------------------------------------------
// Globals.

// Event cache.
CEventCache         gEventCache;

HANDLE CEventCache::_list[] = {0,0,0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,0,0};
DWORD  CEventCache::_ifree  = 0;
COleStaticMutexSem CEventCache::_mxsEventCache;

extern LPTSTR       gOleWindowClass;
extern BOOL         gfDestroyingMainWindow;

//----------------------------------------------------------------------------
//
//  Function:   GetToSTA
//
//  Synopsis:   Sends or Posts a message to an STA and waits for the reply.
//
//  Notes:      For W95 WOW we switch back to the 16bit stack on entry to
//              this routine, since this may Post/Send windows messages and
//              Peek/Dispatch them in the modal loop.
//
//----------------------------------------------------------------------------
HRESULT SSAPI(GetToSTA)(OXIDEntry *pOXIDEntry, CMessageCall *pCall)
{
    ComDebOut((DEB_CHANNEL, "GetToSTA pCall:%x\n", pCall));
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT result = S_OK;

    Win4Assert(pCall->IsClientSide());
    Win4Assert(pCall->ProcessLocal());

    // keep the OXIDEntry around for the call
    pOXIDEntry->IncRefCnt();

    // Addref the call object before dispatch
    pCall->AddRef();

    CALLCATEGORY category = pCall->GetCallCategory();

    if (category == CALLCAT_INPUTSYNC)
    {
        // send the call
        result = pOXIDEntry->SendCallToSTA(pCall);

        if (SUCCEEDED(result))
            result = pCall->GetResult();

        if (!pCall->IsCallCompleted())
        {
           // fixup reference count
           pCall->Release();
        }
    }
    else      // sync call
    {
        Win4Assert(category == CALLCAT_SYNCHRONOUS);
        Win4Assert(pCall->GetEvent());

        // Dispatch the call
        result = pOXIDEntry->PostCallToSTA(pCall);

        // If the above post failed, release call object object
        if(FAILED(result))
            pCall->Release();

        if (result == S_OK)
        {
            // Wait for the either the call to complete
            // or get canceled or timeout to occur
            result = RPC_S_CALLPENDING;
            while(result == RPC_S_CALLPENDING)
            {
                DWORD dwTimeout = pCall->GetTimeout();
                DWORD dwReason  = WaitForSingleObject(pCall->GetEvent(), dwTimeout);

                if(dwReason==WAIT_OBJECT_0)
                {
                    result = S_OK;
                }
                else if(dwReason==WAIT_TIMEOUT)
                {
                    result = RPC_E_CALL_CANCELED;
                    Win4Assert(pCall->GetTimeout() == 0);
                }
                else
                {
                    result = RPC_E_SYS_CALL_FAILED;
                    break;
                }

                result = pCall->RslvCancel(dwReason, result, FALSE, NULL);
            }

            if(result == S_OK)
                result = pCall->GetResult();

            // CallCompleted is invoked on the server
            // thread. Assert that it has been called
            Win4Assert(pCall->IsCallCanceled() || pCall->IsCallCompleted() ||
                       !pCall->IsCallDispatched());
        }
    } // sync call

    pOXIDEntry->DecRefCnt();

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    return result;
}

//----------------------------------------------------------------------------
//
//  Function:   ModalLoop
//
//  Synopsis:   Calls the Modal Loop BlockFn to wait for an outgoing call to
//              complete.
//
//----------------------------------------------------------------------------
HRESULT ModalLoop( CMessageCall *pcall )
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    DWORD result;

    // we should only enter the modal loop for synchronous calls or input
    // synchronous calls to another process or to an MTA apartment within
    // the current process.

    Win4Assert(pcall->GetCallCategory() == CALLCAT_SYNCHRONOUS ||
               pcall->GetCallCategory() == CALLCAT_INPUTSYNC);


    // detemine if we are using an event or a postmessage for the call
    // completion signal.  We use PostMessage only for process local
    // calls in WOW, otherwise we use events and the OleModalLoop determines
    // if the call completed or not.

    BOOL           fMsg  = (pcall->ProcessLocal() && IsWOWThread());
    BOOL           fWait = TRUE;
    DWORD       dwSignal = 0xFFFFFFFF;
    CAptCallCtrl  *pACC  = GetAptCallCtrl();
    CCliModalLoop *pCML  = pACC->GetTopCML();

    ComDebOut((DEB_CALLCONT,"ModalLoop: wait on %s\n",(fMsg) ? "Msg" : "Event"));

    // Wait at least once so the event is returned to the cache in the
    // unsignalled state.
    Win4Assert(fMsg || pcall->GetEvent());
    do
    {
        // Enter modal loop
        HANDLE hEvent = pcall->GetEvent();
        result = pCML->BlockFn(&hEvent, hEvent ? 1 : 0, &dwSignal);
        result = pcall->RslvCancel(dwSignal, result, fMsg, pCML);

        // Unblock if the call is still not pending
        if(result != RPC_S_CALLPENDING)
            fWait = FALSE;
    } while (fWait);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return result;
}

//----------------------------------------------------------------------------
//
//  Function:   SwitchSTA
//
//  Synopsis:   Sends or Posts a message to an STA and waits for the reply
//              in a modal loop.
//
//  Notes:      For W95 WOW we switch back to the 16bit stack on entry to
//              this routine, since this may Post/Send windows messages and
//              Peek/Dispatch them in the modal loop.
//
//----------------------------------------------------------------------------
HRESULT SSAPI(SwitchSTA)( OXIDEntry *pOXIDEntry, CMessageCall **ppCall )
{
    ComDebOut((DEB_CHANNEL, "SwitchSTA hWnd:%x pCall:%x hEvent:%x\n",
    (*ppCall)->GetCallerhWnd(), (*ppCall), (*ppCall)->GetEvent()));
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Transmit the call.
    HRESULT result = TransmitCall( pOXIDEntry, *ppCall );

    // the transmit was successful and the reply isn't already here so wait.
    if (result == RPC_S_CALLPENDING)
    {
        // This is a single-threaded apartment so enter the modal loop.
        result = ModalLoop( *ppCall );
    }

    if (result == S_OK)
        result = (*ppCall)->GetResult();

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "SwitchSTA hr:%x\n", result));
    return result;
}

//----------------------------------------------------------------------------
//
//  Function:   ThreadDispatch
//
//  Synopsis:   This routine is called by the OLE Worker thread on the client
//              side, and by ThreadWndProc on the server side.
//
//  Notes:      For the client case, it calls ThreadSendReceive which will send
//              the data over to the server side.
//              This routine notifies the COM thread when the call is complete.
//              If the call is canceled before completion, the routine cleans up.
//
//----------------------------------------------------------------------------
DWORD _stdcall ThreadDispatch( void *param )
{
    HRESULT       result   = S_OK;
    CMessageCall *pcall    = (CMessageCall *) param;

    gOXIDTbl.ValidateOXID();
    Win4Assert( !pcall->IsClientSide() || pcall->ProcessLocal());


    // NOTE: there is an implied reference on *ppcall which is taken
    //       for us by whoever sent/posted the message.  It is our
    //       responsibility to release it.

    // This code path is also executed by the worker thread
    // for process local STA to MTA calls

    // For process local calls, ask call object whether it is OK to
    // dispatch
    if  (pcall->ProcessLocal())
        result = pcall->CanDispatch();

    if (SUCCEEDED(result))
    {
        // Dispatch the call
        result = ComInvoke(pcall);
    }
    else
    {
        // Cleanup resources
        PrivMemFree(pcall->message.Buffer);
        pcall->_pHeader = NULL;
    }

    // If the call became async, the app will complete it later.  Don't
    // do anything now.
    if (pcall->ServerAsync())
    {
        // Release the the implied reference.  See note above.
        pcall->Release();
        return 0;
    }

    // Update the return code in the call
    pcall->SetResult(result);

    // Complete sync process local calls
    if (pcall->ProcessLocal())
        pcall->CallCompleted( result );

    // Check call type
    if (pcall->ProcessLocal())
    {
        // Don't do anything if the call was canceled
        if(pcall->IsClientWaiting())
        {
            // Check the call category
            if (pcall->GetCallCategory() == CALLCAT_SYNCHRONOUS)
            {
                // Check for calls into NTA
                if (!pcall->ThreadLocal())
                {
                    if (IsWOWThread())
                    {
                        WakeUpWowClient(pcall);
                    }
                    else
                    {
                        ComDebOut((DEB_CHANNEL, "SetEvent pInfo:%x hEvent:%x\n",
                              pcall, pcall->GetEvent()));
                        SetEvent( pcall->GetEvent() );
                    }
                }
            }
            else if((pcall->GetCallCategory() == CALLCAT_ASYNC))
            {
                SignalTheClient((CAsyncCall *)pcall);
            }
        }
    }
    else
    {
        // On the server side of a machine remote or process remote call. We
        // lied and told RPC it was async.  Send the reply using the async APIs.
        ((CAsyncCall *) pcall)->ServerReply();
    }

    // Release the the implied reference.  See note above.
    pcall->Release();

    gOXIDTbl.ValidateOXID();
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   WakeUpWowClient
//
//  Synopsis:   Wakes up the waiting client.
//
//----------------------------------------------------------------------------
void WakeUpWowClient(CMessageCall *pcall)
{
    ComDebOut((DEB_CHANNEL,"WakeUpWowClient"));

    //  NOTE NOTE NOTE NOTE NOTE NOTE NOTE
    //  16bit OLE used to do PostMessage for the Reply; we
    //  tried using SetEvent (which is faster) but this caused
    //  compatibility problems for applications which had bugs that
    //  were hidden by the 16bit OLE DLLs because messages happened
    //  to be dispatched in a particular order (see NtBug 21616 for
    //  an example).  To retain the old behavior, we do a
    //  PostMessage here.

    ComDebOut((DEB_CHANNEL,
      "PostMessage Reply hWnd:%x pCall:%x hEvent:%x\n",
       pcall->GetCallerhWnd(), pcall, pcall->GetEvent()));

    DWORD dwTargetApt = GetWindowThreadProcessId(pcall->GetCallerhWnd(), NULL);
    if (dwTargetApt == 0)
    {
        ComDebOut((DEB_ERROR, "WakeUpWowClient: GetWindowThreadProcessId failed! %d\n", 
                   GetLastError()));
        return;
    }

    CComApartment *pApt = NULL;
    HRESULT hr = GetApartmentByID(dwTargetApt, &pApt);
    if (SUCCEEDED(hr))
    {
        hr = pApt->QueueMessage(WM_OLE_ORPC_DONE, (IMessageParam *)pcall);
        Win4Assert(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            Verify(PostMessage(pcall->GetCallerhWnd(),
                               WM_OLE_ORPC_DONE,
                               WMSG_MAGIC_VALUE, 
                               (LPARAM)((IMessageParam *)pcall)));
        }

        pApt->Release();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     GetOrCreateSTAWindow
//
//  Synopsis:   Apartment model only.  Setup the window used for
//              local thread switches and the call control.  Helper func
//              for ThreadStart.  Also, on Win95 helper function for
//              GetOleNotificationWnd() in com\dcomrem\notify.cxx so that
//              we can lazily finish registering classes
//
//  History:    09-26-96    MurthyS  Created
//
//--------------------------------------------------------------------------
HWND GetOrCreateSTAWindow()
{
    HWND hwnd;

    Win4Assert(IsSTAThread());

    // We have already created one on Win95
    if (!(hwnd = TLSGethwndSTA()))
    {
        if (GetCurrentThreadId() == gdwMainThreadId && ghwndOleMainThread != NULL)
        {
            // this is the main thread, we can just re-use the already
            // existing gMainThreadWnd.

            hwnd = ghwndOleMainThread;
        }
        else
        {
            // Create a new window for use by the current thread for the
            // apartment model. The window is destroyed in ThreadStop.
            //
            // On NT, we have to inherit from a new window class.
            HWND hwndParent = HWND_MESSAGE;

            Win4Assert(gOleWindowClass != NULL);

            hwnd = CreateWindowExW(0,
                              gOleWindowClass,
                              TEXT("OLEChannelWnd"),
                              // must use WS_POPUP so the window does not get
                              // assigned a hot key by user.
                              (WS_DISABLED | WS_POPUP),
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              hwndParent,
                              NULL,
                              g_hinst,
                              NULL);

        }

        TLSSethwndSTA(hwnd);
    }

    return(hwnd);
}

//--------------------------------------------------------------------------
//
//  Function:   PeekTillDone
//
//  Synopsis:   Pulls all remaining messages off the windows message queue.
//
//--------------------------------------------------------------------------
void PeekTillDone(HWND hWnd)
{
    MSG    msg;
    BOOL   got_quit = FALSE;
    WPARAM quit_val = 0;

    while(PeekMessage(&msg, hWnd, WM_USER,
                      0x7fff, PM_REMOVE | PM_NOYIELD))
    {
        if (msg.message == WM_QUIT)
        {
            got_quit = TRUE;
            quit_val = msg.wParam;
        }
        else
        {
            DispatchMessage(&msg);
        }
    }

    if (got_quit)
    {
        PostQuitMessage( (int) quit_val );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ThreadWndProc, Internal
//
//  Synopsis:   Dispatch COM windows messages.  This routine is only called
//              for Single-Threaded Apartments. It dispatches calls and call
//              complete messages.  If it does not recognize the message, it
//              calls DefWindowProc to dispatch it.
//
//--------------------------------------------------------------------------
LRESULT ThreadWndProc(HWND window, UINT message, WPARAM wparam, LPARAM params)
{
    Win4Assert(IsSTAThread());

    // First, check to see if we have got a message that doesn't belong
    //  to us. In that case, do the default processing from the final
    //  "else" statement below

    if ( (LOWORD(wparam) != WMSG_MAGIC_VALUE ) || params == NULL)
    {
        // when the window is first created we are holding the lock, and the
        // creation of the window causes some messages to be dispatched.
        ASSERT_LOCK_DONTCARE(gComLock);

        // check if the window is being destroyed because of UninitMainWindow
        // or because of system shut down. Only destroy it in the former case.
        if ((message == WM_DESTROY || message == WM_CLOSE) &&
            window == ghwndOleMainThread &&
            gfDestroyingMainWindow == FALSE)
        {
            ComDebOut((DEB_WARN, "Attempted to destroy window outside of UninitMainThreadWnd"));
            return 0;
        }

        // Otherwise let the default window procedure have the message.
        ComDebOut((DEB_CHANNEL,"->DefWindowProc(window=0x%x, msg=0x%x, wparam=0x%x, lparams=0x%x)\n",
                    window, message, wparam, params));
        LRESULT result = DefWindowProc(window, message, wparam, params);
        ComDebOut((DEB_CHANNEL,"<-DefWindowProx(status=0x%x)\n", result));
        return result;
    }
    else if (message == WM_OLE_GETCLASS)
    {
        // CoGetClassObject (single-threaded).  This is special, hand it down to the
        // base message proc.
        return OleMainThreadWndProc(window, message, wparam, params);
    }
    else
    {
        //
        // If this is a message we care about, validate the input and
        // handle.
        //
        if ((message >= WM_USER) && (message < WM_OLE_LAST))
        {
            IMessageParam *pMsgParam = (IMessageParam *)(params);
            CComApartment *pCurrApt  = NULL;

            HRESULT hr;
            COleTls tls(hr);
            if (FAILED(hr))
                return 0;

            pCurrApt = tls->pNativeApt;  
            if (pCurrApt == NULL) // Ummm...
                return 0;
            pCurrApt->AddRef();

            // wparam is a magic cookie used by USER to ensure correct focus mgmt
            Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
            ASSERT_LOCK_NOT_HELD(gComLock);

            hr = pCurrApt->RemoveMessage(message, pMsgParam);
            if (SUCCEEDED(hr))
            {
                if (message == WM_OLE_ORPC_POST || message == WM_OLE_ORPC_SEND)
                {
                    CMessageCall *call = (CMessageCall *)(pMsgParam);
                    ComDebOut((DEB_CHANNEL, "ThreadWndProc: Incoming Call pCall:%x\n", call));

                    // Dispatch all calls through ThreadDispatch.  Local calls may be
                    // canceled.  Server-side, non-local calls cannot be canceled.  Send
                    // message calls (event == NULL) are handled as well.
                    ThreadDispatch( call );                    
                }
                else if (message == WM_OLE_ORPC_DONE)
                {
                    CMessageCall *call = (CMessageCall *)(pMsgParam);
                    ComDebOut((DEB_CHANNEL, "ThreadWndProc: Call Completed hWnd:%x pCall:%x\n", window, call));

                    // Inform call object that the call completion message
                    // has arrived
                    call->WOWMsgArrived();
                }
                else if (message == WM_OLE_ORPC_RELRIFREF)
                {
                    // delayed call to Release due to being in an async or inputsync call.
                    HandlePostReleaseRifRef(params);
                }
                else if (message == WM_OLE_GIP_REVOKE)
                {
                    CGIPMessageParam *pGIPMsg = (CGIPMessageParam *)(pMsgParam);
                    
                    // revoke the globally registered interface.
                    gGIPTbl.RevokeInterfaceFromGlobal(pGIPMsg->Cookie());
                }
                else if (message == WM_OLE_SIGNAL)
                {
                    ComSignal((CChannelObject *)pMsgParam);
                }
                else
                {
                    Win4Assert(!"Unknown OLE window message posted to thread proc!");
                }

                // Now release the reference that RemoveMessage() 'gave' us.
                pMsgParam->Release();
            }
            else
            {
                ComDebOut((DEB_ERROR, "ThreadWndProc: Invalid parameter passed! 0x%p\n", params));
            }

            pCurrApt->Release();

            ASSERT_LOCK_NOT_HELD(gComLock);
            return 1;
        }
        else
        {
            // This default message processing is also at the top of the routine,
            //  when we can tell that we've got a message we don't care about
            
            // when the window is first created we are holding the lock, and the
            // creation of the window causes some messages to be dispatched.
            ASSERT_LOCK_DONTCARE(gComLock);
            
            // check if the window is being destroyed because of UninitMainWindow
            // or because of system shut down. Only destroy it in the former case.
            if ((message == WM_DESTROY || message == WM_CLOSE) &&
                window == ghwndOleMainThread &&
                gfDestroyingMainWindow == FALSE)
            {
                ComDebOut((DEB_WARN, "Attempted to destroy window outside of UninitMainThreadWnd"));
                return 0;
            }
            // Otherwise let the default window procedure have the message.
            ComDebOut((DEB_CHANNEL,"->DefWindowProc(window=0x%x, msg=0x%x, wparam=0x%x, lparams=0x%x)\n",
                       window, message, wparam, params));
            LRESULT result = DefWindowProc(window, message, wparam, params);
            ComDebOut((DEB_CHANNEL,"<-DefWindowProx(status=0x%x)\n", result));
            return result;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   TransmitCall
//
//  Synopsis:   Return S_OK if the call completed successfully.
//              Return RPC_S_CALL_PENDING if the caller should block.
//              Return an error if the call failed.
//
//+-------------------------------------------------------------------------
HRESULT TransmitCall( OXIDEntry *pOXIDEntry, CMessageCall *pCall )
{
    ComDebOut((DEB_CHANNEL, "TransmitCall pCall:%x\n", pCall));
    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert( pCall->GetCallCategory() != CALLCAT_ASYNC );
    Win4Assert( pCall->ProcessLocal() );
    // Assert that this code path is only taken on the
    // client side
    Win4Assert(pCall->IsClientSide());


    BOOL    fDispCall = FALSE;
    BOOLEAN wait = FALSE;
    HRESULT result = S_OK;
    HANDLE  hSxsActCtx = INVALID_HANDLE_VALUE;

    // Don't touch the call hresult after the other thread starts,
    // otherwise we might erase the results of the other thread.
    // Since we never want signalled events returned to the cache, always
    // wait on the event at least once.  For example, the post message
    // succeeds and the call completes immediately.  Return RPC_S_CALLPENDING
    // even though the call already has a S_OK in it.

    // Mark the call as pending
    pCall->SetResult(RPC_S_CALLPENDING);

    // Addref the call object before dispatch
    pCall->AddRef();

    // Get the sxs context before sending
    if (GetCurrentActCtx(&hSxsActCtx))
        pCall->SetSxsActCtx(hSxsActCtx);
    else
    {
        pCall->Release();
        result = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(result))
            result = E_FAIL;
        Win4Assert(result != S_OK);
        goto Exit;
    }

    if (!(pOXIDEntry->IsMTAServer()))
    {
        // server is in STA
        if (pCall->GetCallCategory() == CALLCAT_INPUTSYNC)
        {
            result = pOXIDEntry->SendCallToSTA(pCall);

            // Check CompleteStatus instead of result since the call
            // could have been partially processed by the server when
            // when the window handle went bad.
            if (!pCall->IsCallCompleted())
            {
                // fix up reference count
                pCall->Release();
            }
        }
        else
        {
            Win4Assert(pCall->GetCallCategory() == CALLCAT_SYNCHRONOUS);

            // Local Sync call and STA server. Post the message and wait
            // for a reply.

            if (IsWOWThread())
            {
                // In 32bit, replies are done via Events, but for 16bit, replies
                // are done with PostMessage, so get the hWnd for the reply.
                pCall->SetCallerhWnd();
            }

            // Post to the server window
            result = pOXIDEntry->PostCallToSTA(pCall);

            // If the above post failed, release call object
            if (FAILED(result))
            {
                pCall->Release();
            }
            else
            {
                wait = TRUE;
            }
        }
    }
    else
    {
        ComDebOut(( DEB_CHANNEL, "DispatchOnNewThread, pCall: %x \n", pCall));

        // Process local STA to MTA. Transmit the call by having
        // a worker thread invoke the server directly.
        wait = TRUE;

        // On the server side, the call event should have already
        // been created
        Win4Assert(pCall->GetEvent());

        // Dispatch the call
        result = CacheCreateThread( ThreadDispatch, pCall );

        if(FAILED(result))
        {
            // Fix up the reference count
            pCall->Release();
        }
    }
Exit:
    if (result != S_OK)
    {
        pCall->SetResult(result);
        wait = FALSE;
    }

    ComDebOut((DEB_CHANNEL, "TransmitCall pCall->hResult:%x fWait:%x\n",
               pCall->GetResult(), wait));

    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert(wait || pCall->GetResult() != RPC_S_CALLPENDING);
    return (wait) ? RPC_S_CALLPENDING : pCall->GetResult();
}

//+-------------------------------------------------------------------------
//
//  Member:     CEventCache::Cleanup
//
//  Synopsis:   Empty the event cache
//
//  Notes:      This function must be thread safe because Canceled calls
//              can complete at any time.
//
//--------------------------------------------------------------------------
void CEventCache::Cleanup(void)
{
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
    LOCK(_mxsEventCache);

    while (_ifree > 0)
    {
        _ifree--;               // decrement the index first!
        Verify(CloseHandle(_list[_ifree]));
        _list[_ifree] = NULL;   // NULL slot so we dont need to re-init
    }

    // reset the index to 0 so reinitialization is not needed
    _ifree = 0;

    UNLOCK(_mxsEventCache);
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEventCache::Free
//
//  Synopsis:   returns an event to the cache if there are any available
//              slots, frees the event if not.
//
//  Notes:      This function must be thread safe because Canceled calls
//              can complete at any time.
//
//--------------------------------------------------------------------------
void CEventCache::Free( HANDLE hEvent )
{
    // there better be an event
    Win4Assert(hEvent != NULL);

    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
    LOCK(_mxsEventCache);

    // dont return anything to the cache if the process is no longer init'd.
    if (_ifree < CEVENTCACHE_MAX_EVENT && gfChannelProcessInitialized)
    {
        // there is space, save this event.

#if DBG==1
        // in debug, ensure slot is NULL
        Win4Assert(_list[_ifree] == NULL && "Free: _list[_ifree] != NULL");

        //  ensure not already in the list
        for (ULONG j=0; j<_ifree; j++)
        {
            Win4Assert(_list[j] != hEvent && "Free: event already in cache!");
        }

        // ensure that the event is in the non-signalled state
        Win4Assert(WaitForSingleObject(hEvent, 0) == WAIT_TIMEOUT &&
                "Free: Signalled event returned to cache!\n");
#endif

        _list[_ifree] = hEvent;
        _ifree++;
        hEvent = NULL;
    }

    UNLOCK(_mxsEventCache);
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);

    if (hEvent)
    {
        // still have it, really free it.
        Verify(CloseHandle(hEvent));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEventCache::Get
//
//  Synopsis:   gets an event from the cache if there are any available,
//              allocates one if not.
//
//  Notes:      This function must be thread safe because Canceled calls
//              can complete at any time.
//
//--------------------------------------------------------------------------
HRESULT CEventCache::Get( HANDLE *hEvent )
{
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
    LOCK(_mxsEventCache);

    Win4Assert(_ifree <= CEVENTCACHE_MAX_EVENT);

    if (_ifree > 0)
    {
        // there is an event in the cache, use it.
        _ifree--;
        *hEvent = _list[_ifree];

#if DBG==1
        //  in debug, NULL the slot.
        _list[_ifree] = NULL;
#endif

        UNLOCK(_mxsEventCache);
        ASSERT_LOCK_NOT_HELD(_mxsEventCache);
        return S_OK;
    }

    UNLOCK(_mxsEventCache);
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);

    // no free event in the cache, allocate a new one.
    *hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    return (*hEvent) ? S_OK : RPC_E_OUT_OF_RESOURCES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\callmgr.cxx ===
//+-------------------------------------------------------------------
//
//  File:       callmgr.cxx
//
//  Contents:   class managing asynchronous calls
//
//  Classes:    CClientCallMgr
//              CServerCallMgr
//              CChannelObject
//
//  History:    22-Sep-97  MattSmit    Created
//              22-Jul-98  GopalK      Shutdown and Architectural changes
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include "callmgr.hxx"
#include "locks.hxx"
#include "ctxchnl.hxx"
#include "sync.hxx"
#include "riftbl.hxx"

// Head Node for the MTA pending call list.
struct
{
    PVOID pv1;
    PVOID pv2;
} MTAPendingCallList = {NULL, NULL};


// critical section protecting channel call object state
COleStaticMutexSem  gChnlCallLock;

//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::CChannelObject
//
//  Synopsis:   CChannelObject represents channel part of the Call object
//              It implements functionality to track the state of the call
//              and features needed for auto completion, currently pending
//              async calls, etc.
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
CChannelObject::CChannelObject(CClientCallMgr *pCallMgr, CCtxComChnl *pChnl)
:
_cRefs(1),
#ifdef _WIN64
_dwState(STATE_READYFORNEGOTIATE),
#else
_dwState(STATE_READYFORGETBUFFER),
#endif
_pChnl(pChnl),
_pCall(NULL),
_pCallMgr(pCallMgr),
_hr(S_OK),
_pSync(NULL)
{
    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::CChannelObject this:0x%x\n",
                      this));
    // Sanity check
    Win4Assert(_pChnl);
    Win4Assert(_pCallMgr);

    // Initialize
    _dwAptID = GetCurrentApartmentId();
    _pendingCall.pNext = NULL;
    _pendingCall.pPrev = NULL;
    _pendingCall.pChnlObj = this;

    _pChnl->AddRef();
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::~CChannelObject
//
//  Synopsis:   Destructor for the channel call object. It completes auto
//              complete calls as it is guaranteed to be called when the response
//              to such a call has arrived
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
CChannelObject::~CChannelObject()
{
    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::~CChannelObject [in] this:0x%x\n", this));

    if (_dwState == STATE_READYFORRECEIVE)
    {
        HRESULT hr;
        COleTls Tls(hr);
        ULONG status;
        Win4Assert(SUCCEEDED(hr));
	if (SUCCEEDED(hr))
        {
            hr = Receive(&_msg, &status);
            if (SUCCEEDED(hr))
            {
                // Release any marshaled interface pointers in the marshal
                // buffer before freeing the buffer.
                if (status == RPC_S_CALL_CANCELLED)
                {
                    Win4Assert(_pChnl);
                    ReleaseMarshalBuffer(&_msg, 
                                         (IRpcStubBuffer *)_pChnl->GetIPIDEntry()->pStub,
                                         FALSE);
                }
                
                FreeBuffer(&_msg);            
            }
        }
    }

    _pChnl->Release();

    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::~CChannelObject [out] this:0x%x\n", this));
}


//+-------------------------------------------------------------------
//
//  Method:     CChannelObject::QueryInterface     public
//
//  Synopsis:   QI behavior of CChannelObject
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//+-------------------------------------------------------------------
STDMETHODIMP CChannelObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown * pUnk = 0;
    if ((riid == IID_IUnknown) ||
        (riid == IID_IAsyncRpcChannelBuffer) ||
        (riid == IID_IRpcChannelBuffer) ||
        (riid == IID_IRpcChannelBuffer2))
    {
        pUnk = (IAsyncRpcChannelBuffer *) this;
    }
#ifdef _WIN64
    else if (riid == IID_IRpcSyntaxNegotiate)
    {
        pUnk = (IRpcSyntaxNegotiate *)this;
    }
#endif    
    else if (riid == IID_ICancelMethodCalls)
    {
        pUnk = (ICancelMethodCalls *)this;
    }
    else if (riid == IID_IClientSecurity)
    {
        pUnk = (IClientSecurity *) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Method:     CChannelObject::QueryInterface     public
//
//  Synopsis:   AddRefs CChannelObject
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CChannelObject::AddRef( void )
{
    return(ULONG) InterlockedIncrement((PLONG) &_cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CChannelObject::QueryInterface     public
//
//  Synopsis:   Releases CChannelObject. For auto complete calls
//              it defers destruction till the call to completes
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CChannelObject::Release( void )
{
    ULONG cRefs = (ULONG) InterlockedDecrement((PLONG) &_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }

    return cRefs;
}

void CChannelObject::MakeAutoComplete(void)
{
     ASSERT_LOCK_HELD(gChnlCallLock);
     _pSync = NULL;
     _pCallMgr = NULL;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Signal
//
//  Synopsis:   Marks the call as complete
//
//  History:    23-Jun-98   GopalK    Created
//
//--------------------------------------------------------------------------------
void CChannelObject::Signal()
{
    if (_dwState != STATE_ERROR) 
    {
       // Update state to indicate arrival of response
       DWORD dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORRECEIVE);
       Win4Assert((dwState == STATE_SENDING) ||
		  (dwState == STATE_RECEIVING) ||
		  (dwState == STATE_READYFORSIGNAL));
    }

    // Check for auto complete calls
    LOCK(gChnlCallLock);
    Win4Assert((_pSync==NULL) == (_pCallMgr==NULL));
    ISynchronize *pSync = _pSync;
    if (pSync)
        pSync->AddRef();
    UNLOCK(gChnlCallLock);

    // Check for the need to signal client
    if (pSync)
    {
        pSync->Signal();
        pSync->Release();
    }

    // Release the reference taken in Send()

    Release();

    return;
}
#ifdef _WIN64
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::NegotiateSyntax
//
//  Synopsis:   Called by the proxy to negotiate NDR Transfer
//              Syntax
//              
//  History:    10-Jan-2000   Sajia  Created
//              
//-------------------------------------------------------------------------
STDMETHODIMP CChannelObject::NegotiateSyntax( RPCOLEMESSAGE *pMessage)
{
   AsyncDebOutTrace((DEB_CHANNEL,
		     "CChannelObject::NegotiateSyntax [IN] pMessage:0x%x\n",
		     pMessage));
   HRESULT hr = E_UNEXPECTED;
   
   // Prevent concurrent async calls on the same call object
   
   // Note: The assumption here is that in a client process, there
   // will be only one type of proxy for a given interface. ie; 
   // the proxy will either be legacy or new. Thus, it is impossible
   // for two different types of proxies to hold onto the same
   // channel object. If this were possible, we will need to 
   // protect against concurrency better. As such, we just need to
   // protect against concurrent calls on the same proxy.
   
   
   DWORD dwState = _dwState;
   if (dwState <= STATE_READYFORNEGOTIATE)
   {
       dwState = InterlockedCompareExchange((LONG *) &_dwState,
					    STATE_AMBIGUOUS,
					    dwState);
       if (dwState <= STATE_READYFORNEGOTIATE)
	   hr = S_OK;
   }

   if (SUCCEEDED(hr))
   {
      // Delegate to base channel
      hr = _pChnl->NegotiateSyntax(pMessage);
   
      if (SUCCEEDED(hr))
      {
	  dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORGETBUFFER);
      }
      else
      {
	  dwState = InterlockedExchange((LONG *) &_dwState, STATE_ERROR);
      }
      // Sanity check
      Win4Assert(dwState == STATE_AMBIGUOUS);
   }
   AsyncDebOutTrace((DEB_CHANNEL,
		     "CChannelObject::NegotiateSyntax [OUT] hr:0x%x\n",
		     hr));
   return hr;
}
#endif
//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetBuffer
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::GetBuffer
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetBuffer(RPCOLEMESSAGE *pMessage, REFIID riid)
{
    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::GetBuffer [IN] pMessage:0x%x,  riid:%I\n",
                      pMessage, &riid));

    HRESULT hr = E_UNEXPECTED;

    // Prevent concurrent async calls on the same call object
    DWORD dwState = _dwState;
    if (dwState <= STATE_READYFORGETBUFFER)
    {
        dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                             STATE_AMBIGUOUS,
                                             dwState);
        if (dwState <= STATE_READYFORGETBUFFER)
            hr = S_OK;
    }

    // Delegate to base channel
    if (SUCCEEDED(hr))
    {
        // Sanity check
        Win4Assert(_pCall == NULL);

        hr = _pChnl->GetBuffer(pMessage, riid);
        if (SUCCEEDED(hr))
        {
            _pCall = (CAsyncCall *) pMessage->reserved1;
            _pCall->AddRef();
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORSEND);
        }
        else
        {
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_ERROR);
        }

        // Sanity check
        Win4Assert(dwState == STATE_AMBIGUOUS);
    }

    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::GetBuffer [OUT] hr:0x%x\n",
                      hr));
    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Send
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::Send. It adds the call to the
//              pending call list of the current apartment
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::Send(RPCOLEMESSAGE *pMsg, ISynchronize *pSync,
                                  ULONG *pulStatus)
{
    HRESULT hr;

#if DBG==1
    // Ensure that proxy passed the correct call object
    CClientCallMgr *pCallMgr = NULL;
    hr = pSync->QueryInterface(IID_IStdCallObject, (void **) &pCallMgr);
    Win4Assert(SUCCEEDED(hr));
    Win4Assert(pCallMgr == _pCallMgr);
    pCallMgr->Release();
#endif

    // Ensure that GetBuffer was called before
    DWORD dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                               STATE_SENDING,
                                               STATE_READYFORSEND);
    if (dwState == STATE_READYFORSEND)
        hr = S_OK;
    else
        hr = E_UNEXPECTED;

    // Delegate to base channel
    if (SUCCEEDED(hr))
    {
        // Add the call to the pending call list so that all pending calls
        // can be canceled during uninit
        LOCK(gChnlCallLock);
        CallPending();
        UNLOCK(gChnlCallLock);

        // Hold reference to ChannelObject across the call, this
        // is released in the Signal method. This must be done before
        // Send is called below.
        AddRef();

        // Send request
        hr = pSync->Reset();
        if (SUCCEEDED(hr))
        {
            _pSync = pSync;
            hr = _pChnl->Send(pMsg, (ISynchronize *)this, pulStatus);
        }
        
        // Update state
        if (SUCCEEDED(hr))
        {
            _msg = *pMsg;
            dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                                 STATE_READYFORSIGNAL,
                                                 STATE_SENDING);
            Win4Assert((dwState == STATE_SENDING) ||
                       (dwState == STATE_READYFORRECEIVE));
        }
        else
        {
            LOCK(gChnlCallLock);
            CallFinished();
            IUnknown *pCall = (IAsyncRpcChannelBuffer *)(_pCall);
            _pCall = NULL;
            UNLOCK(gChnlCallLock);

            pCall->Release();
            _hr = hr;
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_ERROR);
            Win4Assert(dwState == STATE_SENDING);
            // Signal the call is complete
            Signal();
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Receive
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::Receive. It deletes the call from
//              the pending call list of the current apartment for error returns
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::Receive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    HRESULT hr = E_UNEXPECTED;

    // Ensure that Send succeeded before
    DWORD dwState = _dwState;
    if ((dwState == STATE_READYFORRECEIVE) ||
        (dwState == STATE_READYFORSIGNAL))
    {
        dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                             STATE_RECEIVING,
                                             dwState);
        if ((dwState == STATE_READYFORRECEIVE) ||
            (dwState == STATE_READYFORSIGNAL))
            hr = S_OK;
    }
    else
    {
        if (dwState == STATE_ERROR)
        {
            dwState = InterlockedCompareExchange((LONG *) &_dwState,
#ifdef _WIN64
						 STATE_READYFORNEGOTIATE,
#else
                                                 STATE_READYFORGETBUFFER,
#endif						 
                                                 STATE_ERROR);
            if (dwState == STATE_ERROR)
            {
                hr = _hr;
                _hr = S_OK;
            }
        }
        Win4Assert(FAILED(hr));
    }

    // Delegate to base channel
    if (SUCCEEDED(hr))
    {
        // Ensure that the signal has been called before
        // calling receive
        if (dwState == STATE_READYFORSIGNAL)
            _pCallMgr->Wait(0, INFINITE);

        // Receive response
        hr = _pChnl->Receive(pMsg, pulStatus);
        if (SUCCEEDED(hr))
        {
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORFREEBUFFER);
        }
        else
        {
            LOCK(gChnlCallLock);
            CallFinished();
            IUnknown *pCall = (IAsyncRpcChannelBuffer *)_pCall;
            _pCall = NULL;
            UNLOCK(gChnlCallLock);
            pCall->Release();
#ifdef _WIN64
	    dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORNEGOTIATE);
#else            
	    dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORGETBUFFER);
#endif	    
        }

        // Sanity check
        Win4Assert((dwState == STATE_RECEIVING) ||
                   (dwState == STATE_READYFORRECEIVE));
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::FreeBuffer
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::FreeBuffer. It deletes the call
//              from the pending call list of the current apartment
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::FreeBuffer(RPCOLEMESSAGE *pMessage)
{
    HRESULT hr = E_UNEXPECTED;
    IUnknown *pCall;

    // Ensure that it is legal to call freebuffer
    DWORD dwState = _dwState;
    if ((dwState == STATE_READYFORFREEBUFFER) ||
        (dwState == STATE_READYFORSEND))
    {
        dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                             STATE_AMBIGUOUS,
                                             dwState);
        if ((dwState == STATE_READYFORFREEBUFFER) ||
            (dwState == STATE_READYFORSEND))
            hr = S_OK;
    }

    // Deleate to base channel
    if (SUCCEEDED(hr))
    {
        LOCK(gChnlCallLock);
        if (dwState == STATE_READYFORFREEBUFFER)
            CallFinished();
        IUnknown *pCall = (IAsyncRpcChannelBuffer *)_pCall;
        _pCall = NULL;
        UNLOCK(gChnlCallLock);
        hr = _pChnl->FreeBuffer(pMessage);
        pCall->Release();
#ifdef _WIN64
        dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORNEGOTIATE);
#else        
	dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORGETBUFFER);
#endif	
        Win4Assert(dwState == STATE_AMBIGUOUS);
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::SendReceive
//
//  Synopsis:   not implemented
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::SendReceive(RPCOLEMESSAGE *pMessage, ULONG *pulStatus)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetDestCtx
//
//  Synopsis:   delegate to channel
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetDestCtx (DWORD FAR* lpdwDestCtx,
                                         LPVOID FAR* lplpvDestCtx )
{
    return _pChnl->GetDestCtx(lpdwDestCtx, lplpvDestCtx);
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Isconnected
//
//  Synopsis:   delegate to channel
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::IsConnected ( void )
{
    return _pChnl->IsConnected();
}

//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetProtocolVersion
//
//  Synopsis:   delegate to channel
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetProtocolVersion(DWORD *pdwVersion)
{
    return _pChnl->GetProtocolVersion(pdwVersion);
}

//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetDestCtxEx
//
//  Synopsis:   delegate to channel
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetDestCtxEx(RPCOLEMESSAGE *pMsg, DWORD *pdwDestContext,
                                          void **ppvDestContext )
{
    return _pChnl->GetDestCtxEx(pMsg, pdwDestContext, ppvDestContext);
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::Cancel
//
//  Synopsis:   Cancels the current call.  Delegates to call object
//
//  History:    27-Jan-98  MattSmit  Created
//              13-Jun-98   GopalK    Architectural changes
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::Cancel(ULONG ulSeconds)
{
    ComDebOut((DEB_CHANNEL|DEB_CANCEL,
               "CChannelObject::Cancel IN ulSeconds:%d\n",
               ulSeconds));

    HRESULT hr = S_OK;
    CMessageCall *pCall = NULL;

    // Check if a call is in progress
    LOCK(gChnlCallLock);
    if (_pCall)
    {
        pCall = _pCall;
        pCall->AddRef();
    }
    else
        hr = E_UNEXPECTED;
    UNLOCK (gChnlCallLock);

    // Delgate to base cancel code
    if (pCall)
    {
        hr = pCall->Cancel(ulSeconds);
        pCall->Release();
    }

    ComDebOut((DEB_CHANNEL|DEB_CANCEL, "CChannelObject::Cancel OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::TestCancel
//
//  Synopsis:   Test to see if the current call is cancelled. Delegates to
//              call object
//
//  History:    27-Jan-98  MattSmit  Created
//              13-Jun-98   GopalK    Architectural changes
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::TestCancel()
{
    ComDebOut((DEB_CHANNEL|DEB_CANCEL,
               "CClientCallMbr::TestCancel IN \n"));

    HRESULT hr = S_OK;
    CMessageCall *pCall = NULL;

    // Check if a call is in progress
    LOCK(gChnlCallLock);
    if (_pCall)
    {
        pCall = _pCall;
        pCall->AddRef();
    }
    else
        hr = RPC_E_CALL_COMPLETE;
    UNLOCK (gChnlCallLock);

    // Delgate to base cancel code
    if (pCall)
    {
        hr = pCall->TestCancel();
        pCall->Release();
    }

    ComDebOut((DEB_CHANNEL|DEB_CANCEL,
               "CClientCallMbr::TestCancel OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     QueryBlanket
//
//  Synopsis:   dispatched to the call object's query
//
//  History:    6-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::QueryBlanket(
                                         IUnknown                *pProxy,
                                         DWORD                   *pAuthnSvc,
                                         DWORD                   *pAuthzSvc,
                                         OLECHAR                **pServerPrincName,
                                         DWORD                   *pAuthnLevel,
                                         DWORD                   *pImpLevel,
                                         void                   **pAuthInfo,
                                         DWORD                   *pCapabilities
                                         )
{
    HRESULT hr;
    ComDebOut((DEB_CHANNEL, "CChannelObject::QueryBlanket IN"
               " pProxy:0x%x, pAuthnSvc:0x%x, pAuthzSvc:0x%x, "
               "pServerPrincName:0x%x, pAuthnLevel:0x%x, pImpLevel:0x%x, "
               "pAuthInfo:0x%x, pCapabilities:0x%x\n", pProxy, pAuthnSvc,
               pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel,
               pAuthInfo, pCapabilities));

    hr = _pCallMgr->VerifyInterface(pProxy);
    if (FAILED(hr))
    {
        return hr;
    }
    LOCK(gComLock);

    hr = QueryBlanketFromChannel(_pChnl, pAuthnSvc, pAuthzSvc, pServerPrincName,
                                 pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities);
    UNLOCK(gComLock);

    ComDebOut((DEB_CHANNEL, "CChannelObject::QueryBlanket OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::SetBlanket
//
//  Synopsis:   a copy is performed, and the call dispatched to the call
//              object's setblanket
//
//  History:    23-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::SetBlanket(
                                       IUnknown                 *pProxy,
                                       DWORD                     AuthnSvc,
                                       DWORD                     AuthzSvc,
                                       OLECHAR                  *pServerPrincName,
                                       DWORD                     AuthnLevel,
                                       DWORD                     ImpLevel,
                                       void                     *pAuthInfo,
                                       DWORD                     Capabilities
                                       )
{
    CCtxComChnl *pNewChnl;
    HRESULT hr;

    ComDebOut((DEB_CHANNEL, "CChannelObject::SetBlanket IN "
               "pProxy:0x%x, AuthnSvc:0x%x, AuthzSvc:0x%x, pServerPrincName:0x%x,"
               " AuthnLevel:0x%x, ImpLevel:0x%x, pAuthInfo:0x%x, Capabilities:0x%x\n",
               pProxy, AuthnSvc, AuthzSvc, pServerPrincName, AuthnLevel, ImpLevel,
               pAuthInfo, Capabilities));

    hr = _pCallMgr->VerifyInterface(pProxy);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // copy the channel so the state change is localized to
    // this object only.
    //

    hr = E_OUTOFMEMORY;
    pNewChnl = _pChnl->Copy(_pChnl->GetOXIDEntry(), GUID_NULL, GUID_NULL);


    
    if (pNewChnl)
    {
        Win4Assert(_pChnl->GetIPIDEntry());
        pNewChnl->SetIPIDEntry(_pChnl->GetIPIDEntry());
        
        LOCK(gComLock);
        hr = SetBlanketOnChannel(pNewChnl, AuthnSvc, AuthzSvc, pServerPrincName,
                                 AuthnLevel, ImpLevel, pAuthInfo, Capabilities);
        if (SUCCEEDED(hr))
        {
            _pChnl->Release();
            _pChnl = pNewChnl;
            _pChnl->AddRef();
        }
        UNLOCK(gComLock);
        
        pNewChnl->Release();
    }



    ComDebOut((DEB_CHANNEL, "CChannelObject::SetBlanket OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::CopyProxy
//
//  Synopsis:   not implemented
//
//  History:    23-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::CopyProxy(IUnknown  *pProxy, IUnknown **ppCopy)
{
    return E_NOTIMPL;
}

//+--------------------------------------------------------------------------------
//
//  Function:      CChannelObject::CallPending
//
//  Synopsis:      Add the call to the list of pending calls
//
//  History:       15-Jul-98    GopalK    Created
//
//---------------------------------------------------------------------------------
void CChannelObject::CallPending()
{
    ASSERT_LOCK_HELD(gChnlCallLock);

    // Obtain pending call list for the current apartment
    SPendingCall *pHeadNode = GetPendingCallList();

    // Add the new item to it
    _pendingCall.pPrev = pHeadNode;
    _pendingCall.pNext = pHeadNode->pNext;
    pHeadNode->pNext->pPrev = &_pendingCall;
    pHeadNode->pNext = &_pendingCall;

    return;
}


//+--------------------------------------------------------------------------------
//
//  Function:      CChannelObject::CallFinished
//
//  Synopsis:      Removes the call to the list of pending calls
//
//  History:       15-Jul-98    GopalK    Created
//
//---------------------------------------------------------------------------------
void CChannelObject::CallFinished()
{
    ASSERT_LOCK_HELD(gChnlCallLock);

    // Update pending call list
    _pendingCall.pNext->pPrev = _pendingCall.pPrev;
    _pendingCall.pPrev->pNext = _pendingCall.pNext;
    _pendingCall.pNext = NULL;
    _pendingCall.pPrev = NULL;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   CancelPendingCalls, Internal
//
//  Synopsis:   Cancel outstanding async calls
//
//--------------------------------------------------------------------------
void CancelPendingCalls(HWND hwnd)
{
    LOCK(gChnlCallLock);
    SPendingCall *pHead = GetPendingCallList();
    while (pHead->pNext != pHead)
    {
        // Obtain the last pending async call
        SPendingCall *pPendingCall = pHead->pNext;
        ComDebOut((DEB_ERROR, "Async call(0x%x) still pending\n",
                   pPendingCall->pChnlObj));

        // Stablize pending async call
        pPendingCall->pChnlObj->AddRef();

        UNLOCK(gChnlCallLock);

        // Cancel the call
        HRESULT hr = pPendingCall->pChnlObj->Cancel(0);
        ComDebOut((DEB_ERROR, "Canceling it returned 0x%x\n", hr));
        pPendingCall->pChnlObj->Release();

        // Wait for it to return
        while (pHead->pNext == pPendingCall)
        {
            // REVIEW: Change to a wait on event.
            //         Should we care for broken apps.
            //         GopalK
	    // The broken app comment above alludes
	    // to apps that autocomplete, but leak the 
	    // call object. It is better to hang here, 
	    // rather than exit normally-so that such apps 
	    // can be debugged and fixed.
	    // Sajia
	    
            ComDebOut((DEB_ERROR, "Sleeping for a second for pCall:%x\n",
                       pPendingCall));
            Sleep(100);

            // STA needs to pump message for the call to complete
            if (hwnd)
            {
                PeekTillDone(hwnd);
            }
        }

        // Reacquire lock
        LOCK(gChnlCallLock);
    }

    UNLOCK(gChnlCallLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CClientCallMgr::CPrivUnknown::AddRef    public
//
//  Synopsis:   Implements inner unknown for CClientCallMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCallMgr::CPrivUnknown::AddRef()
{
    CClientCallMgr *pCallMgr = GETPPARENT(this, CClientCallMgr, _privUnk);
    ULONG cRefs = InterlockedIncrement((long *) &(pCallMgr->_cRefs));
    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CClientCallMgr::CPrivUnknown::Release    public
//
//  Synopsis:   Implements inner unknown for CClientCallMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCallMgr::CPrivUnknown::Release()
{
    CClientCallMgr *pCallMgr = GETPPARENT(this, CClientCallMgr, _privUnk);

    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL fTryToDelete = InterlockedDecRefCnt(&pCallMgr->_cRefs, &cNewRefs);

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry
        BOOL fActuallyDeleted = FALSE;

        ASSERT_LOCK_NOT_HELD(gChnlCallLock);
        LOCK(gChnlCallLock);

        if (pCallMgr->_cRefs == CINDESTRUCTOR)
        {
            // the refcnt did not change while we acquired the lock.
            // OK to delete.
            if (pCallMgr->_pChnlObj != NULL)
            {
                pCallMgr->_pChnlObj->MakeAutoComplete();
            }
            fActuallyDeleted = TRUE;
        }

        UNLOCK(gChnlCallLock);
        ASSERT_LOCK_NOT_HELD(gChnlCallLock);

        if (fActuallyDeleted == TRUE)
        {
            delete pCallMgr;
            break;  // all done. the entry has been deleted.
        }

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&pCallMgr->_cRefs, &cNewRefs);
    }

    return(cNewRefs & ~CINDESTRUCTOR);
}


//+-------------------------------------------------------------------
//
//  Member:     CClientCallMgr::CPrivUnknown::QueryInterface    public
//
//  Synopsis:   Implements inner unknown for CClientCallMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::CPrivUnknown::QueryInterface(REFIID riid, void **ppv)
{
    CClientCallMgr *pCallMgr = GETPPARENT(this, CClientCallMgr, _privUnk);
    return pCallMgr->QueryInterfaceImpl(riid, ppv);
}


//+----------------------------------------------------------------------------
//
//  Member:        CClientCallMgr::CClientCallMgr
//
//  Synopsis:      Constructs client side call object
//
//  History:       22-Sep-97    MattSmit       Created
//                 15-Jul-98    GopalK         Aggregation support and
//                                             Shutdown changes
//
//-----------------------------------------------------------------------------
CClientCallMgr::CClientCallMgr(IUnknown *pUnkOuter, REFIID syncIID, REFIID asyncIID,
                               CStdIdentity *pStdId, CClientCallMgr *pNextMgr,
                               HRESULT &hr, IUnknown **ppInnerUnk)
:
_cRefs(1),
_dwFlags(0),
_pUnkOuter(pUnkOuter ? pUnkOuter : &_privUnk),
_asyncIID(asyncIID),
_cStdEvent(NULL),
_pChnlObj(NULL),
_pProxyObj(NULL),
_pICMC(NULL),
_pICS(NULL),
_pNextMgr(pNextMgr)
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CClientCallMgr IN -- this:0x%x",
                      this));
    ASSERT_LOCK_NOT_HELD(gChnlCallLock);

    // Initialize state
    _pStdId = pStdId;
    Win4Assert(_pStdId);
    _pStdId->AddRef();


    // Init the out parameters
    hr = S_OK;
    *ppInnerUnk = &_privUnk;

    Win4Assert((syncIID != IID_IUnknown) && (syncIID != IID_IMultiQI));

    // Create a synchronization object.
    HANDLE hEvent;
    CChannelObject *pChnlObj = NULL;
    IRpcProxyBuffer *pProxyObj = NULL;

    // Create a manual reset event
    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent)
        hr = _cStdEvent.SetEventHandle(&hEvent);
    else
        hr = MAKE_WIN32(GetLastError());
    if (SUCCEEDED(hr))
    {
        
        // Find the IPID entry for this interface

        // Acquire lock
        LOCK(gIPIDLock);
        IPIDEntry *pIPID;

        if (syncIID == IID_IRemUnknown)
        {
            // Special case IRemUnknown, since it might be IRemUnknown
            // or IRundown.
            hr = _pStdId->FindIPIDEntryByIID(IID_IRundown, &pIPID);
            if (SUCCEEDED(hr))
            {
                // We're going to change the asyncIID here.  We do it                
                // because:
                //
                //    1. The MIDL generated call factory guy doesn't understand when
                //       we ask a derived interface for a call object for a base interface,
                //    and
                //    2. It's safe.  (IRundown derives from IRemUnknown, so all the VTBL 
                //       stuff just works out.)
                //
                // This is a special case for IRemUnknown, because for new remunks we might
                // only have an IPID entry for IRundown.
                _asyncIID = IID_AsyncIRundown;
            }
            else
            {
                hr = _pStdId->FindIPIDEntryByIID(IID_IRemUnknown, &pIPID);
            }
        }
        else
        {
            hr = _pStdId->FindIPIDEntryByIID(syncIID, &pIPID);           
        }

        // Release the lock
        UNLOCK(gIPIDLock);
        
        // Create proxy call object
        if (SUCCEEDED(hr))
        {
            IUnknown *pProxy;

            // QIing on the interface implemented by the proxy
            // for ICallFactory. GopalK
            hr = GetAsyncCallObject(pIPID->pStub, GetControllingUnknown(), _asyncIID,
                                    IID_IRpcProxyBuffer, &pProxy,
                                    (void **) &pProxyObj);
            if (SUCCEEDED(hr))
            {
                // Fixup the refcount on the proxy call object
                pProxy->Release();

                // Assume OOF
                hr = E_OUTOFMEMORY;

                // Create channel call object
                Win4Assert(pIPID->pChnl);
                pChnlObj = new CChannelObject(this, pIPID->pChnl);
                if (pChnlObj)
                {
                    // Connect the channel call object to proxy call object
                    hr = pProxyObj->Connect(pChnlObj);
                    if (SUCCEEDED(hr))
                    {
                        // Update state
                        _pProxyObj = pProxyObj;
                        pProxyObj = NULL;

                        _pChnlObj = pChnlObj;
                        pChnlObj = NULL;
                    }
                }
            }

        }
    }
    // Cleanup
    if (pChnlObj)
        pChnlObj->Release();
    if (pProxyObj)
        pProxyObj->Release();


    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CClientCallMgr OUT -- hr:0x%x\n",
                      hr));
}


//+----------------------------------------------------------------------------
//
//  Member:        CClientCallMgr::~CClientCallMgr
//
//  Synopsis:      Destroys client side call object. As a potential side effect
//                 of destruction, the current pending call will get marked
//                 for auto completion.
//
//  History:       22-Sep-97    MattSmit       Created
//                 15-Jul-98    GopalK         Aggregation support and
//                                             Shutdown changes
//
//-----------------------------------------------------------------------------
CClientCallMgr::~CClientCallMgr()
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::~CClientCallMgr IN -- this:0x%x\n",
                      this));
    if (_pStdId)
        _pStdId->Release();
    // Sanity checks
    Win4Assert(_pICMC == NULL);
    Win4Assert(_pICS == NULL);


    // Release proxy call object
    if (_pProxyObj)
    {
        _pProxyObj->Disconnect();
        _pProxyObj->Release();
    }

    // Release channel call object at the end to prevent shutdown races
    if (_pChnlObj)
        _pChnlObj->Release();


    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::~CClientCallMgr OUT -- this:0x%x\n",
                      this));
}


//+--------------------------------------------------------------------------------
//
//  Interface:     IUnknown
//
//  Synopsis:      Basic reference counting implementation, QI handed off to
//                 QueryInterfaceImpl, so code can be reused by objects enapsulating
//                 this one w/o causing loops
//
//  History:       22-Sep-97    MattSmit       Created
//                 15-Jul-98    GopalK         Aggregation support and
//                                             Shutdown changes
//
//---------------------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return _pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CClientCallMgr::AddRef()
{
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CClientCallMgr::Release()
{
    return _pUnkOuter->Release();
}

HRESULT CClientCallMgr::QueryInterfaceImpl(REFIID riid, LPVOID *ppv)
{
    ComDebOut((DEB_CHANNEL,
               "CClientCallMgr::QueryInterfaceImpl riid:%I, ppv:0x%x\n",
               &riid, ppv));

    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;
    if (riid == IID_IUnknown)
    {
        *ppv = (ISynchronize *) this;
    }
    else if (riid == IID_ISynchronize)
    {
        *ppv = (ISynchronize *) this;
    }
    else if (riid == IID_IClientSecurity)
    {
        *ppv = (IClientSecurity *) this;
    }
    else if (riid == IID_ICancelMethodCalls)
    {
        *ppv = (ICancelMethodCalls *) this;
    }
    else if (riid == IID_ISynchronizeHandle)
    {
        *ppv = (ISynchronizeHandle *) this;
    }
    else if (riid == IID_IStdCallObject)
    {
        *ppv = this;
    }
    else if (riid == _asyncIID)
    {
        // hand off to the proxy call manager
        return _pProxyObj->QueryInterface(riid, ppv);
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}


//+--------------------------------------------------------------------------------
//
//  Interface:     IClientSecurity
//
//  Synopsis:      IClientSecurity methods are delegated to the channel call object
//
//  History:       22-Sep-97    MattSmit       Created
//
//---------------------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::QueryBlanket(
                                         IUnknown                *pProxy,
                                         DWORD                   *pAuthnSvc,
                                         DWORD                   *pAuthzSvc,
                                         OLECHAR                **pServerPrincName,
                                         DWORD                   *pAuthnLevel,
                                         DWORD                   *pImpLevel,
                                         void                   **pAuthInfo,
                                         DWORD                   *pCapabilites
                                         )
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::QueryBlanket IN pProxy:0x%x, pAuthnSvc:0x%x, "
                      "pAuthzSvc:0x%x, pServerPrincName:0x%x, "
                      "pAuthnLevel:0x%x, pImpLevel:0x%x, pAuthInfo:0x%x, "
                      "pCapabilites:0x%x\n",
                      pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                      pAuthnLevel, pImpLevel, pAuthInfo, pCapabilites));

    IClientSecurity *pICS = _pChnlObj ? _pChnlObj->GetSecurityInterface() : _pICS;
    Win4Assert(pICS);
    HRESULT hr =  pICS->QueryBlanket(pProxy, pAuthnSvc, pAuthzSvc,
                                     pServerPrincName, pAuthnLevel,
                                     pImpLevel, pAuthInfo, pCapabilites);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::QueryBlanket OUT hr:0x%x\n", hr));
    return hr;

}

STDMETHODIMP CClientCallMgr::SetBlanket(
                                       IUnknown                 *pProxy,
                                       DWORD                     AuthnSvc,
                                       DWORD                     AuthzSvc,
                                       OLECHAR                  *pServerPrincName,
                                       DWORD                     AuthnLevel,
                                       DWORD                     ImpLevel,
                                       void                     *pAuthInfo,
                                       DWORD                     Capabilities
                                       )
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::SetBlanket IN pProxy:0x%x, AuthnSvc:0x%x,"
                      " AuthzSvc:0x%x, pServerPrincName:0x%x, AuthnLevel:0x%x, "
                      "ImpLevel:0x%x, pAuthInfo:0x%x, Capabilities:0x%x\n",
                      pProxy, AuthnSvc, AuthzSvc, pServerPrincName, AuthnLevel,
                      ImpLevel, pAuthInfo, Capabilities));

    IClientSecurity *pICS = _pChnlObj ? _pChnlObj->GetSecurityInterface() : _pICS;
    Win4Assert(pICS);
    HRESULT hr = pICS->SetBlanket(pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                                  AuthnLevel, ImpLevel, pAuthInfo, Capabilities);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::SetBlanket OUT hr:0x%x\n", hr));
    return hr;
}

STDMETHODIMP CClientCallMgr::CopyProxy(
                                      IUnknown  *pProxy,
                                      IUnknown **ppCopy
                                      )
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CopyProxy IN pProxy:0x%x, ppCopy:0x%x\n",
                      pProxy, ppCopy));

    IClientSecurity *pICS = _pChnlObj ? _pChnlObj->GetSecurityInterface() : _pICS;
    Win4Assert(pICS);
    HRESULT hr = pICS->CopyProxy(pProxy, ppCopy);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CopyProxy OUT hr:0x%x\n",
                      hr));
    return hr;
}

HRESULT CClientCallMgr::VerifyInterface(IUnknown *pProxy)
{
    HRESULT hr;
    IUnknown *pUnk;

    if (!IsValidInterface(pProxy))
    {
        return E_INVALIDARG;
    }
    _privUnk.QueryInterface(_asyncIID, (LPVOID *) &pUnk);
    pUnk->Release();
    return(pProxy == pUnk) ? S_OK : E_INVALIDARG;

}

//+----------------------------------------------------------------------------
//
//  Interface:     ICancelMethodCalls
//
//  Synopsis:      ICancelMethodCalls methods are delegated to the channel
//                 call object
//
//  History:       27-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::Cancel(ULONG ulSeconds)
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::Cancel IN ulSeconds:%d\n",
                      ulSeconds));

    ICancelMethodCalls *pICMC = _pChnlObj ? _pChnlObj->GetCancelInterface() : _pICMC;
    Win4Assert(pICMC);
    HRESULT hr = pICMC->Cancel(ulSeconds);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::Cancel OUT hr:0x%x\n",
                      hr));
    return hr;
}

STDMETHODIMP CClientCallMgr::TestCancel()
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::TestCancel IN \n"));

    ICancelMethodCalls *pICMC = _pChnlObj ? _pChnlObj->GetCancelInterface() : _pICMC;
    Win4Assert(pICMC);
    HRESULT hr = pICMC->TestCancel();

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::TestCancel OUT hr:0x%x\n",
                      hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Interface:     ISynchronize
//
//  Synopsis:      ISynchronize methods are delegated to the StdEvent
//                 object
//
//  History:       21-Jul-98    GopalK    Created
//
//--------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::Wait(DWORD dwFlags, DWORD dwTimeout)
{
    return _cStdEvent.Wait(dwFlags, dwTimeout);
}

STDMETHODIMP CClientCallMgr::Signal()
{
    return _cStdEvent.Signal();
}

STDMETHODIMP CClientCallMgr::Reset()
{
    return _cStdEvent.Reset();
}


//+-------------------------------------------------------------------
//
//  Interface:     ISynchronizeHandle
//
//  Synopsis:      ISynchronizeHanle method is delegated to the StdEvent
//                 object
//
//  History:       21-Jul-98    GopalK    Created
//
//--------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::GetHandle(HANDLE *pHandle)
{
    return _cStdEvent.GetHandle(pHandle);
}





//+--------------------------------------------------------------------------------
//
//  Interface:      AsyncIUnknown
//
//  Synopsis:       Async version of IUnknown.  Uses internal AsyncIRemUnknown
//                  to talk to server asynchronously
//
//  History:        20-Jan-98 MattSmit       Created
//
//---------------------------------------------------------------------------------


CAsyncUnknownMgr::CAsyncUnknownMgr(IUnknown *pUnkOuter, REFIID syncIID, REFIID asyncIID,
                                         CStdIdentity *pStdId, CClientCallMgr *pNextMgr,
                                         HRESULT &hr, IUnknown **ppInnerUnk) :
_cRefs(1),
_dwFlags(0),
_pUnkOuter(pUnkOuter ? pUnkOuter : &_privUnk),
_pNextMgr(pNextMgr)
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CClientCallMgr IN -- this:0x%x",
                      this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Initialize state
    _pStdId = pStdId;
    Win4Assert(_pStdId);
    _pStdId->AddRef();

    _pARUObj = NULL;
    _pQIC = NULL;
    _ppMQI = NULL;
    _pIIDs = NULL;
    _pMQISave = NULL;

    // Init the out parameters
    hr = S_OK;
    *ppInnerUnk = &_privUnk;

    if (syncIID == IID_IUnknown)
    {
        _dwFlags |= AUMGR_IUNKNOWN;
    }
    else if (syncIID == IID_IMultiQI)
    {
        _dwFlags |= AUMGR_IMULTIQI;
    }
    else
    {
        Win4Assert(!"Bad Synchronous IID for CAsyncUnknownMgr");
    }


    IUnknown *pARUObj;
    AsyncIRemUnknown2 *pARU;


    hr = _pStdId->GetAsyncRemUnknown(GetControllingUnknown(), &pARU, &pARUObj);
    if (SUCCEEDED(hr))
    {
        // fix up reference count
        GetControllingUnknown()->Release();
        
        // Update state
        _pARUObj = pARUObj;
        pARUObj = NULL;
        _pARU = pARU;
        pARU = NULL;

    }
}

CAsyncUnknownMgr::~CAsyncUnknownMgr()
{
    if (_pStdId)
        _pStdId->Release();
    if (_pARUObj)
        _pARUObj->Release();
    PrivMemFree(_pQIC);
    PrivMemFree(_ppMQI);
    PrivMemFree(_pIIDs);
    PrivMemFree(_pMQISave);
}


//+-------------------------------------------------------------------
//
//  Member:     CAsyncUnknownMgr::CPrivUnknown::AddRef    public
//
//  Synopsis:   Implements inner unknown for CAsyncUnknownMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::CPrivUnknown::AddRef()
{
    CAsyncUnknownMgr *pCallMgr = GETPPARENT(this, CAsyncUnknownMgr, _privUnk);
    CairoleDebugOut((DEB_CHANNEL, "CAsyncUnknownMgr::CPrivUnknown::AddRef() _cRefs: %d\n",
                     pCallMgr->_cRefs+1));
    ULONG cRefs = InterlockedIncrement((long *) &(pCallMgr->_cRefs));
    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CAsyncUnknownMgr::CPrivUnknown::Release    public
//
//  Synopsis:   Implements inner unknown for CAsyncUnknownMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::CPrivUnknown::Release()
{
    CAsyncUnknownMgr *pCallMgr = GETPPARENT(this, CAsyncUnknownMgr, _privUnk);

    CairoleDebugOut((DEB_CHANNEL, "CAsyncUnknownMgr::CPrivUnknown::Release() _cRefs: %d\n",
                     pCallMgr->_cRefs-1));
    ULONG cRefs = (ULONG) InterlockedDecrement((PLONG) &pCallMgr->_cRefs);
    if (cRefs == 0)
    {
        delete pCallMgr;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CAsyncUnknownMgr::CPrivUnknown::QueryInterface    public
//
//  Synopsis:   Implements inner unknown for CAsyncUnknownMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::CPrivUnknown::QueryInterface(REFIID riid, void **ppv)
{
    CAsyncUnknownMgr *pCallMgr = GETPPARENT(this, CAsyncUnknownMgr, _privUnk);
    return pCallMgr->QueryInterfaceImpl(riid, ppv);
}

STDMETHODIMP CAsyncUnknownMgr::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return _pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CAsyncUnknownMgr::AddRef()
{
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CAsyncUnknownMgr::Release()
{
    return _pUnkOuter->Release();
}


HRESULT CAsyncUnknownMgr::QueryInterfaceImpl(REFIID riid, LPVOID *ppv)
{
    ComDebOut((DEB_CHANNEL,
               "CAsyncUnknownMgr::QueryInterfaceImpl riid:%I, ppv:0x%x\n",
               &riid, ppv));

    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;
    if (riid == IID_IUnknown)
    {
        *ppv = this;
    }
    else if ((riid == IID_ISynchronize) ||
             (riid == IID_IClientSecurity) ||
             (riid == IID_ICancelMethodCalls) ||
             (riid == IID_ISynchronizeHandle) ||
             (riid == IID_IStdCallObject))
    {
        return _pARUObj->QueryInterface(riid, ppv);
    }
    else if ((riid == IID_AsyncIUnknown) &&
             (_dwFlags & AUMGR_IUNKNOWN))
    {
        *ppv = (AsyncIUnknown  *) this;
    }
    else if ((riid == IID_AsyncIMultiQI) &&
             (_dwFlags & AUMGR_IMULTIQI))
    {
        *ppv = (AsyncIMultiQI  *) this;
    }


    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        Begin_QueryInterface
//
//  Synopsis:      Starts an asynchronous QueryInterface. Delegates
//                 to Begin_QueryMultipleInterfaces
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_QueryInterface(REFIID riid)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryInterface IN riid:%I\n", &riid));
    HRESULT hr;

    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Queryface EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    _MQI.pIID = &riid;
    _MQI.pItf = NULL;

    hr =  IBegin_QueryMultipleInterfaces(1, &_MQI);

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryInterface hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_QueryInterface
//
//  Synopsis:      Completes an QueryInterface call. Delegates to
//                 Finish_QueryInterfaces
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Finish_QueryInterface(LPVOID *ppv)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryInterface IN ppv:0x%x\n", ppv));

    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryInterface EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }


    hr = IFinish_QueryMultipleInterfaces(&_MQI);
    if (SUCCEEDED(hr))
    {
        hr = _MQI.hr;
        if (SUCCEEDED(hr))
        {
            *ppv = _MQI.pItf;
        }
    }

    LeaveFinish();

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryInterface OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Begin_QueryMultipleInterfaces
//
//  Synopsis:      Wrapper for IBegin_QueryMultipleInterfaces
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_QueryMultipleInterfaces(ULONG cMQIs, MULTI_QI *pMQIs)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryMultipleInterfaces IN cMQIs:%d, pMQIs:0x%x\n", cMQIs, pMQIs));
    HRESULT hr;
    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryMultipleInterfaces EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    hr = IBegin_QueryMultipleInterfaces(cMQIs, pMQIs);

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_QueryMultipleInterfaces
//
//  Synopsis:      Wrapper for IFinish_QueryMultipleInterfaces
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Finish_QueryMultipleInterfaces(MULTI_QI *pMQIs)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryMultipleInterfaces IN \n"));
    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryMultipleInterfaces EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }
    hr = IFinish_QueryMultipleInterfaces(pMQIs);
    LeaveFinish();
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces
//
//  Synopsis:      Starts and async QueryMultipleInterfaces call. If all the
//                 requests can be filled locally then the call is signaled
//                 immediately.  Otherwise a remote call is made and the
//                 call is completed when it completes
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces(ULONG cMQIs, MULTI_QI *pMQIs)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces IN cMQIs:0x%d, pMQIs:0x%x\n", cMQIs, pMQIs));

    HRESULT hr;
    IRemUnknown *pRU;

    // Make sure TLS is initialized.
    COleTls tls(hr);
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces FAILED tls not initiated\n"));
        return AbortBegin(GetControllingUnknown(), hr);
    }

    // ensure it is callable in the current apartment
    if (!_pStdId->IsCallableFromCurrentApartment(FALSE))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces FAILED not callable from current apartment\n"));
        CoVrfNotifySmuggledProxy(IID_IUnknown, 0, _pStdId->GetAptId());
        return AbortBegin(GetControllingUnknown(), RPC_E_WRONG_THREAD);
    }

    _pMQISave = (MULTI_QI *)  PrivMemAlloc(sizeof(MULTI_QI) * cMQIs);
    if (!_pMQISave)
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces FAILED cannot allocate memory\n"));
        return AbortBegin(GetControllingUnknown(), E_OUTOFMEMORY);
    }

    _pStdId->AssertValid();

    //
    // clone the in parameters
    //
    memcpy(_pMQISave, pMQIs, sizeof(MULTI_QI) * cMQIs);
    _cMQIs = cMQIs;

    // allocate some space on the stack for the intermediate results. declare
    // working pointers and remember the start address of the allocations.
    MULTI_QI  **ppMQIAlloc = (MULTI_QI **)_alloca(sizeof(MULTI_QI *) * cMQIs);
    IID       *pIIDAlloc   = (IID *)      _alloca(sizeof(IID) * cMQIs);

    USHORT cPending = _pStdId->m_InternalUnk.QueryMultipleInterfacesLocal(cMQIs, _pMQISave, ppMQIAlloc, pIIDAlloc, &_cAcquired);

    if (cPending > 0)
    {
        // some interfaces cannot be obtained locally so we will
        // query them remotely
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces Some interfaces not local, calling out\n"));

        hr = E_OUTOFMEMORY;

        _pQIC = (QICONTEXT *) PrivMemAlloc(QICONTEXT::SIZE(_pStdId, cPending));
        _ppMQI = (MULTI_QI **) PrivMemAlloc(sizeof(MULTI_QI*) * cPending);
        _pIIDs = (IID *) PrivMemAlloc(sizeof(IID) * cPending);
        if (_pQIC && _ppMQI && _pIIDs)
        {
            // begin can succeed
            hr = S_OK;

            // set up the context for the remote call
            _pQIC->Init(cPending);
            _pQIC->dwFlags |= QIC_ASYNC;
            _pQIC->pARU = _pARU;

            // copy the data for later
            memcpy(_ppMQI, ppMQIAlloc, (sizeof(MULTI_QI*) * cPending));
            memcpy(_pIIDs, pIIDAlloc, (sizeof(IID) * cPending));
            _pStdId->Begin_QueryRemoteInterfaces(cPending, _pIIDs, _pQIC);


            if (!(_pQIC->dwFlags & QIC_BEGINCALLED))
            {
                hr = SignalObject(GetControllingUnknown());
            }
        }
        else
        {
            hr = AbortBegin(GetControllingUnknown(), hr);
        }
    }
    else
    {
        // signal the client since RPC won't
        _dwFlags |= AUMGR_ALLLOCAL;
        hr = SignalObject(GetControllingUnknown());

    }

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces
//
//  Synopsis:      Completes the QueryMultipleInterfaces call by copying data
//                 recieved remotely to the data structure supplied by the
//                 application
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces(MULTI_QI *pMQI)
{

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces IN \n"));

    if (!(_dwFlags & AUMGR_ALLLOCAL))
    {
        // there were interfaces which we queried for remotely

        SQIResult *pQIResult = (SQIResult*) _alloca(sizeof(SQIResult) * _pQIC->cIIDs);

        // no need to check errors because _pQIC is always filled in
        _pStdId->Finish_QueryRemoteInterfaces(pQIResult, _pQIC);

        CopyToMQI(_pQIC->cIIDs, pQIResult, _ppMQI, &_cAcquired);
    }

    // copy to the out array
    // CODEWORK: this can be optimized. currently this information is copied
    // twice.
    ULONG i;
    for (i=0, _cAcquired=0; i<_cMQIs; i++)
    {
        if (SUCCEEDED(_pMQISave[i].hr))
        {
            pMQI[i].hr = _pMQISave[i].pItf->QueryInterface(*pMQI[i].pIID, (void **) &pMQI[i].pItf);
            _pMQISave[i].pItf->Release();
            if (SUCCEEDED(pMQI[i].hr))
            {
                _cAcquired++;
            }
        }
    }

    // if we got all the interfaces, return S_OK. If we got none of the
    // interfaces, return E_NOINTERFACE. If we got some, but not all, of
    // the interfaces, return S_FALSE;
    HRESULT hr;
    if (_cAcquired == _cMQIs)
        hr = S_OK;
    else if (_cAcquired > 0)
        hr = S_FALSE;
    else
        hr = E_NOINTERFACE;

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;

}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Begin_AddRef
//
//  Synopsis:      Addrefs the proxy manager and signals the client.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_AddRef()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_AddRef IN \n" ));
    HRESULT hr;
    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_AddRef EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    _ulRefs = AddRef();

    SignalObject(GetControllingUnknown());

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_AddRef OUT \n"));
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_AddRef
//
//  Synopsis:      Completes the call, filling in the references returned by
//                 the addref in the begin call.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::Finish_AddRef()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_AddRef IN ulrefs:%d\n", _ulRefs ));
    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_AddRef EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }
    ULONG ret = _ulRefs;
    LeaveFinish();
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_AddRef OUT ret:%d\n", ret ));
    return ret;

}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Begin_Release
//
//  Synopsis:      Starts a release call. Flags that if a need to go remote
//                 arises, it should be done asyncronously.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_Release()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Release IN \n"));
    HRESULT hr;
    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Release EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    _ulRefs = InterlockedDecrement((PLONG) &_cRefs);
    Win4Assert(_pStdId);
    if (_ulRefs == 0)
    {
        _cRefs = 1000;
        COleTls tls(hr);
        if (SUCCEEDED(hr))
        {
            // put the controlling unknown in TLS to pass through to
            // the destructor.

            // CODEWORK:: temporary solution. we will be using the
            // ref cache to handle async release in the future..
            tls->pAsyncRelease = _pARUObj;

            _ulRefs = _pStdId->Release();
            _pStdId = NULL;

            if (tls->pAsyncRelease)
            {
                SignalObject(tls->pAsyncRelease);
                tls->pAsyncRelease = NULL;
            }
        }
        else
        {
            hr = AbortBegin(GetControllingUnknown(), hr);
        }
    }
    else
    {
        SignalObject(GetControllingUnknown());
    }

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Release OUT 0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_Release
//
//  Synopsis:      Complete the call, fill in the return code.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::Finish_Release()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_Release IN \n"));
    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_Release EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }
    ULONG ret = _ulRefs;
    if (_ulRefs == 0)
    {
        delete this;
    }
    else
    {
        LeaveFinish();
    }

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_Release OUT ret:%d\n", ret));

    return ret;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::ResetStateForCall
//
//  Synopsis:      Resets per call object state
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncUnknownMgr::ResetStateForCall()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::ResetStateForCall IN \n"));
    HRESULT hr = S_OK;

    // in this function we should reset all actions which are owned
    // by this object. Specifically, the ALLLOCAL flag and freeing
    // memory allocated.  Notice that none of the objects _inside_
    // pQIC are released.  This should have been handled by the lower
    // levels which created them.
    _dwFlags &= !(AUMGR_ALLLOCAL);
    PrivMemFree(_pQIC);
    PrivMemFree(_ppMQI);
    PrivMemFree(_pIIDs);
    PrivMemFree(_pMQISave);
    _pQIC = NULL;
    _ppMQI = NULL;
    _pIIDs = NULL;
    _pMQISave = NULL;

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::ResetStateForCall OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::InitObject
//
//  Synopsis:      Initialize per call state
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::InitObject(IUnknown *pCtl)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::InitObject IN \n"));
    HRESULT hr;

    _hr = S_OK;
    hr = ResetStateForCall();
    if (SUCCEEDED(hr))
    {
        hr = ResetObject(pCtl);
    }

    if (FAILED(hr))
    {
        AbortBegin(pCtl, hr);
    }
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::InitObject OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::EnterBegin
//
//  Synopsis:      Verifies object is in a state that a begin call can be made.
//                 and initializes per call object state
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::EnterBegin(IUnknown *pCtl)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterBegin IN pCtl:0x%x\n", pCtl));

    HRESULT hr;

    // CODEWORK:: We could use Interlocked* operations instead of gChnlCallLock

    LOCK(gChnlCallLock);
    if ((_dwState != STATE_WAITINGFORBEGIN) &&
        (_dwState != STATE_BEGINABORTED))
    {
        hr =  RPC_S_CALLPENDING;
    }
    else
    {
        hr = S_OK;
        _dwState = STATE_INITIALIZINGOBJECT;

    }
    UNLOCK(gChnlCallLock);

    if (SUCCEEDED(hr))
    {
        // initialize and reset the object
        hr = InitObject(pCtl);
        if (SUCCEEDED(hr))
        {
            _dwState = STATE_WAITINGFORFINISH;
        }
    }


    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterBegin OUT hr:0x%x\n", hr));
    return hr;

}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::AbortBegin
//
//  Synopsis:      Called from begin upon determining that the call cannot
//                 complete successfully.  Signals the client and stores the
//                 HRESULT to give back in EnterFinish()
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::AbortBegin(IUnknown *pCtl, HRESULT hr)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::AbortBegin IN pCtl:0x%x, hr:0x%x\n", pCtl, hr));
    HRESULT hr2;
    Win4Assert(FAILED(hr));
    _hr = hr;
    _dwState = STATE_BEGINABORTED;
    hr2 = SignalObject(pCtl);
    if (FAILED(hr2))
    {
        hr = hr2;
    }

    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::AbortBegin OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::EnterFinish
//
//  Synopsis:      Verifies object is in a state that a Finish call can be made
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::EnterFinish(IUnknown *pCtl)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterFinish IN \n"));
    HRESULT hr;
    hr = WaitObject(pCtl, 0,  INFINITE);
    if (SUCCEEDED(hr))
    {
        LOCK(gChnlCallLock);
        if ((_dwState != STATE_WAITINGFORFINISH) &&
            (_dwState != STATE_BEGINABORTED))
        {
            hr =  E_UNEXPECTED;
        }
        else if (_dwState == STATE_BEGINABORTED)
        {
            Win4Assert(FAILED(_hr));
            hr = _hr;
            _dwState = STATE_WAITINGFORBEGIN;

        }
        else
        {
            hr = S_OK;
            _dwState = STATE_EXECUTINGFINISH;
        }
        UNLOCK(gChnlCallLock);
    }

    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterFinish OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::LeaveFinish
//
//  Synopsis:      Called when finish completes.
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
void CAsyncStateMachine::LeaveFinish()
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::LeaveFinish IN \n"));
    Win4Assert(_dwState == STATE_EXECUTINGFINISH);
    _dwState = STATE_WAITINGFORBEGIN;
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::LeaveFinish OUT\n"));
}


//+--------------------------------------------------------------------------------
//
//  Translation Functions
//
//---------------------------------------------------------------------------------

//+--------------------------------------------------------------------------------
//
//  Function:       GetSyncIIDFromAsyncIID
//
//  Params:         rasynciid -   [in] async IID
//                  psynciid  -   [out] where to place sync IID
//
//  Returns:        S_OK/failure
//
//  Synopsis:       Maps a synchrounous IID to its corresponding asynchronous IID
//                  using the registry.
//
//  History:        22-Sep-97 MattSmit       Created
//
//---------------------------------------------------------------------------------
HRESULT GetSyncIIDFromAsyncIID(REFIID rasynciid, IID *psynciid)
{
    //
    // check see if this is an internal IID.
    // if so just flip the bits.
    //
    DWORD *ptr = (DWORD *) &rasynciid;
    if (*(ptr+1) == 0x00000000 &&   //  all internal iid's have these
        *(ptr+2) == 0x000000C0 &&   //   common values
        *(ptr+3) == 0x46000000 &&
        (*(ptr) & 0xffff0000) == 0x000e0000)
    {
        *psynciid = rasynciid;

        *((DWORD *) psynciid) &= 0x0000ffff;
        return S_OK;
    }

    if (rasynciid == IID_AsyncIAdviseSink)
    {
        // save a registry call since we know this one
        *psynciid = IID_IAdviseSink;
        return S_OK;
    }
    else if (rasynciid == IID_AsyncIAdviseSink2)
    {
        // save a registry call since we know this one
        *psynciid = IID_IAdviseSink2;
        return S_OK;
    }

    return gRIFTbl.SyncFromAsync(rasynciid, psynciid);
}


//+--------------------------------------------------------------------------------
//
//  Function:       GetAsyncIIDFromSyncIID
//
//  Params:         rasynciid -   [in] async IID
//                  psynciid  -   [out] where to place sync IID
//
//  Returns:        S_OK/failure
//
//  Synopsis:       Maps a synchrounous IID to its corresponding asynchronous IID
//                  using the registry
//
//  History:        22-Sep-97 MattSmit       Created
//
//---------------------------------------------------------------------------------
HRESULT GetAsyncIIDFromSyncIID(REFIID rsynciid, IID *pasynciid)
{
    DWORD *ptr = (DWORD *) &rsynciid;

    //
    // check see if this is an internal IID.
    // if so just flip the bits.
    //

    if (*(ptr+1) == 0x00000000 &&   //  all internal iid's have these
        *(ptr+2) == 0x000000C0 &&   //   common values
        *(ptr+3) == 0x46000000 &&
        (*(ptr) & 0xffff0000) == 0x00000000)
    {
        *pasynciid = rsynciid;

        *((DWORD *) pasynciid) |= 0x000e0000;
        return S_OK;
    }

    if (rsynciid == IID_IAdviseSink)
    {
        // save a registry call since we know this one
        *pasynciid = IID_AsyncIAdviseSink;
        return S_OK;
    }
    else if (rsynciid == IID_IAdviseSink2)
    {
        // save a registry call since we know this one
        *pasynciid = IID_AsyncIAdviseSink2;
        return S_OK;
    }

    return gRIFTbl.AsyncFromSync(rsynciid, pasynciid);
}


//+----------------------------------------------------------------------------
//
//  Function:      GetAsyncCallObject
//
//  Synopsis:      Gets an async call object from a sync object
//
//  History:       9-Feb-98  MattSmit  Created
//                13-Jul-98  GopalK    Simplified
//
//-----------------------------------------------------------------------------
HRESULT GetAsyncCallObject(IUnknown *pSyncObj, IUnknown *pControl, REFIID IID_async,
                           REFIID IID_Return, IUnknown **ppInner, void **ppv)
{
    ComDebOut((DEB_CHANNEL,
               "GetAsyncCallObject IN pSyncObj:0x%x, pControl:0x%x, IID_async:%I, "
               "ppUnkInner:0x%x, ppv:0x%x\n", pSyncObj, pControl,
               &IID_async, ppInner, ppv));

    HRESULT hr;
    ICallFactory *pCF = NULL;
    IUnknown *pUnkInner = NULL;
    void *pv = NULL;

    // Try creating the async call object
    hr = pSyncObj->QueryInterface(IID_ICallFactory, (void **) &pCF);
    if (SUCCEEDED(hr))
    {
        hr = pCF->CreateCall(IID_async, pControl, IID_IUnknown, (IUnknown **) &pUnkInner);
        if (SUCCEEDED(hr))
        {
            // HACKHACK: There's a trick here.
            //
            // In CClientCallMgr, we replace IRemUnknown requests with IRundown, 
            // if at all possible.  This is for reasons to complicated to go into here.
            // (See CClientCallMgr::CClientCallMgr for details.)  Therefore, if what
            // you want is AsyncIRemUnknown, try AsyncIRundown first, because the pUnkInner 
            // we got might not want to respond in the affirmative for a derived interface.  
            //
            // (MIDL generated proxies do this.)
            if (IID_Return == IID_AsyncIRemUnknown)
            {
                hr = pUnkInner->QueryInterface(IID_AsyncIRundown, &pv);
                if (FAILED(hr))
                {
                    // Well, we must have really got an AsyncIRemUnknown.
                    hr = pUnkInner->QueryInterface(IID_Return, &pv);
                }
            }
            else
            {
                hr = pUnkInner->QueryInterface(IID_Return, &pv);
            }

            if (SUCCEEDED(hr))
            {
                *ppv = pv;
                pv = NULL;
                *ppInner = pUnkInner;
                pUnkInner = NULL;
            }
            if (pUnkInner)
                pUnkInner->Release();
        }
        pCF->Release();
    }

    ComDebOut((DEB_CHANNEL, "GetAsyncCallObject OUT hr:0x%x\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------------
//
//  Pending Call List
//
//---------------------------------------------------------------------------------

//+--------------------------------------------------------------------------------
//
//  Function:       GetPendingCallList
//
//  Params:         none
//
//  Return:         pointer to list head node
//
//  Synopsis:       Gets the right head node for the list of pending calls,
//                  depending on the apartment type
//
//  History:        22-Sep-97 MattSmit       Created
//
//---------------------------------------------------------------------------------
SPendingCall *GetPendingCallList()
{
    AsyncDebOutTrace((DEB_TRACE, "GetPendingCallList [IN] \n"));
    ASSERT_LOCK_HELD(gChnlCallLock);

    // Obatin the list head
    SPendingCall *pHead;
    if (IsSTAThread())
    {
        COleTls tls;
        pHead = (SPendingCall *) &tls->pvPendingCallsFront;
    }
    else
    {
        pHead = (SPendingCall *) &::MTAPendingCallList;
    }

    // Initialize the head if not already done
    if (pHead->pNext == NULL)
    {
        pHead->pNext = pHead;
        pHead->pPrev = pHead;
    }

    AsyncDebOutTrace((DEB_TRACE, "GetPendingCallListHeadNode [OUT] - Head:0x%x\n", pHead));
    return pHead;
}

//+----------------------------------------------------------------------------
//
//  Function:      CopyToMQI
//
//  Synopsis:      copy to the MULTI_QI structure.
//
//  History:       31-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------

void CopyToMQI(ULONG cIIDs, SQIResult *pSQIPending, MULTI_QI **ppMQIPending, ULONG *pcAcquired)
{
    ComDebOut((DEB_CHANNEL, "CopyToMQI IN pSQIPending:0x%x, ppMQIPending:0x%x, pcAquired:0x%x\n",
               pSQIPending, ppMQIPending, pcAcquired));

    ULONG &cAcquired = *pcAcquired;

    // got some interfaces, loop over the remote QI structure filling
    // in the rest of the MULTI_QI structure to return to the caller.
    // the proxies are already AddRef'd.

    ULONG i;

    for (i=0; i<cIIDs; i++, pSQIPending++, ppMQIPending++)
    {
        MULTI_QI *pMQI = *ppMQIPending;
        pMQI->pItf = (IUnknown *)(pSQIPending->pv);
        pMQI->hr   = pSQIPending->hr;

        if (SUCCEEDED(pMQI->hr))
        {
            // count one more acquired interface
            cAcquired++;
        }
    }

    ComDebOut((DEB_CHANNEL, "CopyToMQI OUT cAcquired:%d\n", cAcquired));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\chock.cxx ===
//+-------------------------------------------------------------------
//
//  File:       chock.cxx
//
//  Contents:   Channel hook APIs
//
//  Classes:    CDebugChannelHook
//
//--------------------------------------------------------------------
#include <ole2int.h>
extern "C"
{
#include "orpc_dbg.h"
}
#include <ctxchnl.hxx>
#include <ipidtbl.hxx>
#include <chock.hxx>
#include <stream.hxx>


//+----------------------------------------------------------------
// Macros.

// This macro converts a RIID pointer to a CMessageCall pointer.  It assumes
// that the riid references the iid which is the first field of
// SChannelHookCallInfo in CMessageCall.  Thus a little subtraction yields
// the correct pointer.
inline CMessageCall *RIID_TO_CALL( const IID *pIid )
{
    return (CMessageCall *) (((char *) pIid) - offsetof( CMessageCall, hook ));
}

//+----------------------------------------------------------------
// Definitions.

typedef struct SHookList
{
    struct SHookList *pNext;
    IChannelHook     *pHook;
    UUID              uExtension;
} SHookList;

//+----------------------------------------------------------------
// Global variables.
SHookList          gHookList     = { &gHookList, NULL };
ULONG              gNumExtent    = 0;
LONG               gcChannelHook = -1;
GUID              *gaChannelHook = NULL;


//+-------------------------------------------------------------------
//
//  Function:   CleanupChannelHooks
//
//  Synopsis:   Releases all the hooks in the list.
//
//--------------------------------------------------------------------
void CleanupChannelHooks()
{
    LOCK(gComLock);

    SHookList *pCurr = gHookList.pNext;

    // Release and free each entry.
    while (pCurr != &gHookList)
    {
        pCurr->pHook->Release();
        gHookList.pNext = pCurr->pNext;
        PrivMemFree( pCurr );
        pCurr = gHookList.pNext;
    }

    gNumExtent    = 0;
    gcChannelHook = -1;

    if (gaChannelHook != NULL)
    {
        MIDL_user_free( gaChannelHook );
        gaChannelHook = NULL;
    }

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CoRegisterChannelHook
//
//  Synopsis:   Adds a hook object to the list of hook objects.
//
//--------------------------------------------------------------------
WINOLEAPI CoRegisterChannelHook( REFGUID uExtension, IChannelHook *pCaptain )
{
    SHookList *pCurr;
    HRESULT    hr = S_OK;

    // ChannelProcessIntialize calls while holding the lock.
    ASSERT_LOCK_DONTCARE(gComLock);
    LOCK(gComLock);

#if DBG==1
    // See if the extenstion is already on the list.
    pCurr = gHookList.pNext;
    while (pCurr != &gHookList)
    {
        if (pCurr->uExtension == uExtension)
            break;
        pCurr = pCurr->pNext;
    }
    Win4Assert( pCurr == &gHookList );
    Win4Assert( pCaptain != NULL );
#endif

    // Add a node at the head.
    pCurr = (SHookList *) PrivMemAlloc( sizeof(SHookList) );
    if (pCurr != NULL)
    {
        pCaptain->AddRef();
        pCurr->uExtension = uExtension;
        pCurr->pHook      = pCaptain;
        pCurr->pNext      = gHookList.pNext;
        gHookList.pNext   = pCurr;
        gNumExtent       += 1;
    }
    else
        hr = E_OUTOFMEMORY;

    UNLOCK(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   InitHooksIfNecessary
//
//  Synopsis:   Registers debug channel hooks
//
//--------------------------------------------------------------------
void InitHooksIfNecessary()
{
    SHookList *pCurr;
    LONG       i;
    HRESULT    hr;

    // Register the channel hooks.  If some other thread resets cChannelHook,
    // then its ok to stop immediately.
    for (i = 0; i < gcChannelHook; i++)
    {
        IChannelHook *pCaptain = NULL;
        hr = CoCreateInstance( gaChannelHook[i], NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IChannelHook,
                               (void **) &pCaptain );
        if (FAILED(hr))
            ComDebOut((DEB_CHANNEL, "Creation of default channel hook failed hr:%x\n", hr));
        if (pCaptain != NULL)
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Is this hook already registered?
            pCurr = gHookList.pNext;
            while (pCurr != &gHookList)
            {
                if (pCurr->uExtension == gaChannelHook[i])
                    break;
                pCurr = pCurr->pNext;
            }

            // Register the channel hook if not already registered.
            if (pCurr == &gHookList)
                hr = CoRegisterChannelHook( gaChannelHook[i], pCaptain );

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            // Release the channel hook.
            if (FAILED(hr))
                ComDebOut((DEB_CHANNEL, "Registration of default channel hook failed hr:%x\n", hr));
            pCaptain->Release();
        }
    }

    gcChannelHook = -1;
}

//+-------------------------------------------------------------------
//
//  Function:   ClientGetSize
//
//  Synopsis:   Asks each hook in the list how much data it wishes to
//              place in the next request on this thread.
//
//--------------------------------------------------------------------
ULONG ClientGetSize( ULONG *cNumExtent, CMessageCall *pCall )
{
    SHookList *pCurr = gHookList.pNext;
    ULONG lSize      = SizeOfWireExtentArray;
    ULONG lPiece     = 0;
    *cNumExtent      = 0;

    // Ignore any hooks added to the head of the list.
    ASSERT_LOCK_DONTCARE(gComLock);

    // Ask each hook.
    while (pCurr != &gHookList)
    {
        pCurr->pHook->ClientGetSize( pCurr->uExtension, pCall->hook.iid,
                                     &lPiece );
        if (lPiece != 0)
        {
            lPiece       = ((lPiece + 7) & ~7) + sizeof(WireExtent);
            lSize       += lPiece;
            *cNumExtent += 1;
        }
        pCurr = pCurr->pNext;
    }

    // Round up the number of extents and add size for an array of unique
    // flags.
    *cNumExtent = (*cNumExtent + 1) & ~1;
    lSize      += SizeOfUniqueFlags (*cNumExtent);

    if (*cNumExtent != 0)
        return lSize;
    else
        return 0;
}

//+-------------------------------------------------------------------
//
//  Function:   FillBuffer
//
//  Synopsis:   Asks each hook in the list to place data in the buffer
//              for the next request on this thread.  Returns the final
//              buffer pointer.
//
//--------------------------------------------------------------------
void *FillBuffer( WireExtentArray *pArray, ULONG cMax,
                  ULONG cNumExtent, BOOL fClient, CMessageCall *pCall )
{
    SHookList       *pCurr;
    WireExtent      *pExtent;
    ULONG            lPiece;
    ULONG            cNumFill;
    ULONG            i;

    // Ignore any hooks added to the head of the list.
    ASSERT_LOCK_DONTCARE(gComLock);

    // Figure out where the extents start.
    pCurr      = gHookList.pNext;
    pExtent    = StartOfExtents (pArray, cNumExtent);
    cNumFill   = 0;
    cMax      -= SizeOfWireExtentArrayWithUniqueFlags (cNumExtent);

    // Ask each hook.
    while (pCurr != &gHookList && cMax > 0)
    {
        lPiece = cMax - sizeof(WireExtent);
        if (fClient)
            pCurr->pHook->ClientFillBuffer( pCurr->uExtension, pCall->hook.iid,
                                            &lPiece, pExtent+1 );
        else 
            pCurr->pHook->ServerFillBuffer( pCurr->uExtension, pCall->hook.iid,
                                            &lPiece, pExtent+1, S_OK );
                                            
        Win4Assert( ((lPiece+7)&~7) + sizeof(WireExtent) <= cMax );

        // If the hook put in data, initialize this extent and find the next.
        if (lPiece != 0)
        {
            pExtent->size         = lPiece;
            pExtent->rounded_size = (lPiece+7) & ~7;
            pExtent->id           = pCurr->uExtension;
            cNumFill             += 1;
            cMax                 -= pExtent->rounded_size + sizeof(WireExtent);
            pExtent               = (WireExtent *) ((char *) (pExtent+1) +
                                                    pExtent->rounded_size);

            Win4Assert( cNumFill <= cNumExtent );
        }
        pCurr = pCurr->pNext;
    }


    // If any hooks put in data, fill in the header.
    if (cNumFill != 0)
    {
        pArray->size         = cNumFill;
        pArray->reserved     = 0;
        pArray->unique       = 0x6d727453; // Any non-zero value.
        pArray->rounded_size = (cNumFill+1) & ~1;
        for (i = 0; i < cNumExtent; i++)
            if (i < cNumFill)
                pArray->unique_flag[i] = 0x79614b44; // Any non-zero value.
            else
                pArray->unique_flag[i] = 0;
        return pExtent;
    }

    // Otherwise return the original buffer.
    else
    {
        return pArray;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   FindExtentId
//
//  Synopsis:   Search for the specified extension id in the list of
//              registered extensions.  Return the index of the entry
//              if found
//
//--------------------------------------------------------------------
ULONG FindExtentId( SHookList *pHead, UUID uExtension )
{
    ULONG i = 0;
    while (pHead != &gHookList)
        if (pHead->uExtension == uExtension)
            return i;
        else
        {
            i += 1;
            pHead = pHead->pNext;
        }
    return 0xffffffff;
}

//+-------------------------------------------------------------------
//
//  Function:   VerifyExtent
//
//  Synopsis:   Verifies extent array and extents.
//
//--------------------------------------------------------------------
void *VerifyExtent( SHookList *pHead, WireExtentArray *pArray, ULONG cMax,
                      WireExtent **aExtent, DWORD dwRep )
{
    WireExtent      *pExtent;
    ULONG            i;
    ULONG            j;
    ULONG            cNumExtent;
    WireExtent      *pEnd;

    // Fail if the buffer isn't larger then the extent array header.
    if (cMax < SizeOfWireExtentArray)
        return NULL;

    // Byte swap the array header.
    if ((dwRep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
    {
        ByteSwapLong( pArray->size );
        // ByteSwapLong( pArray->reserved );
        ByteSwapLong( pArray->rounded_size );
    }

    // Validate the array header.
    if (cMax < SizeOfWireExtentArrayWithUniqueFlags (pArray->rounded_size) ||
        (pArray->rounded_size & 1) != 0                ||
        pArray->size > pArray->rounded_size            ||
        pArray->reserved != 0)
        return NULL;

    // Count how many unique flags are set.
    cNumExtent = 0;
    for (i = 0; i < pArray->size; i++)
        if (pArray->unique_flag[i])
            cNumExtent += 1;

    // Look up each extent from the packet in the registered list.
    pEnd    = (WireExtent *) ((char *) pArray + cMax);
    pExtent = (WireExtent *) &pArray->unique_flag[pArray->rounded_size];
    for (i = 0; i < cNumExtent; i++)
    {
        // Fail if the next extent header doesn't fit in the buffer.
        if (pExtent + 1 > pEnd)
            return NULL;

        // Byte swap the extent header.
        if ((dwRep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
        {
            ByteSwapLong( pExtent->rounded_size );
            ByteSwapLong( pExtent->size );
            ByteSwapLong( pExtent->id.Data1 );
            ByteSwapShort( pExtent->id.Data2 );
            ByteSwapShort( pExtent->id.Data3 );
        }

        // Validate the extent.
        if (pExtent->size > pExtent->rounded_size ||
            (pExtent->rounded_size & 1) != 0      ||
            ((char *) (pExtent+1)) + pExtent->rounded_size > (char *) pEnd)
            return NULL;

        // If the extension is registered, save a pointer to it.
        j = FindExtentId( pHead, pExtent->id );
        if (j != 0xffffffff)
            aExtent[j] = pExtent;

        // Find the next extension.
        pExtent = (WireExtent *) ((char *) (pExtent + 1) +
                  pExtent->rounded_size);
    }
    return pExtent;
}

//+-------------------------------------------------------------------
//
//  Function:   ClientNotify
//
//  Synopsis:   Calls each hook and passes data to those that received
//              data in a reply.
//
//  Notes: pOut is NULL for failed calls or async calls.
//
//--------------------------------------------------------------------
HRESULT ClientNotify( WireThat *pOut, ULONG cMax, void **pStubData,
                      DWORD dwRep, HRESULT hr, CMessageCall *pCall )
{
    SHookList       *pHead  = gHookList.pNext;
    SHookList       *pCurr;
    WireExtent     **aExtent;
    ULONG            cMaxExtent = gNumExtent;
    ULONG            i;

    // Return immediately if there is nothing to do.
    if(pOut)
        *pStubData = &pOut->d.ea;
    if (pHead == &gHookList &&
        (pOut == NULL || pOut->c.unique == FALSE))
        return hr;

	if (gNumExtent == 0)
	{
		Win4Assert(!"Somebody added a channel hook without changing gNumExtent!");
		return RPC_E_INVALID_EXTENSION;
	}

    // Initialize the array of extent pointers.
    aExtent = (WireExtent **) _alloca( cMaxExtent * sizeof(WireExtent *) );
    memset( aExtent, 0, cMaxExtent * sizeof( WireExtent *) );

    // If there are any extents, verify them and sort them.
    if (SUCCEEDED(hr) && pOut != NULL && pOut->c.unique)
    {
        *pStubData = VerifyExtent( pHead, &pOut->d.ea, cMax - sizeof(WireThatPart1),
                                   aExtent, dwRep );
        if (*pStubData == NULL)
            return RPC_E_INVALID_EXTENSION;
    }

    // Notify all the hooks
    for (pCurr = pHead, i = 0; pCurr != &gHookList; pCurr = pCurr->pNext, i++)
        pCurr->pHook->ClientNotify( pCurr->uExtension, pCall->hook.iid,
                             aExtent[i] != NULL ? aExtent[i]->size : 0,
                             aExtent[i] != NULL ? aExtent[i] + 1 : NULL,
                             dwRep, hr );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ServerNotify
//
//  Synopsis:   Calls each hook and passes data to those that receive
//              data in a request.
//
//--------------------------------------------------------------------
HRESULT ServerNotify( WireThis *pIn, ULONG cMax, void **pStubData,
                      DWORD dwRep, CMessageCall *pCall )
{
    SHookList       *pHead  = gHookList.pNext;
    SHookList       *pCurr;
    WireExtent     **aExtent;
    ULONG            cMaxExtent = gNumExtent;
    ULONG            i;

    // Return immediately if there is nothing to do.
    *pStubData = &pIn->d.ea;
    if (pHead == &gHookList && pIn->c.unique == FALSE)
        return S_OK;
	
	if (cMaxExtent == 0)
	{
		Win4Assert (!"Somebody added a channel hook to the list without changing gNumExtent!");
		return RPC_E_INVALID_EXTENSION;
	}

    // Initialize the array of extent pointers.
    aExtent = (WireExtent **) _alloca( cMaxExtent * sizeof(WireExtent *) );
    memset( aExtent, 0, cMaxExtent * sizeof( WireExtent *) );

    // If there are any extents, verify them and sort them.
    if (pIn->c.unique)
    {
        *pStubData = VerifyExtent( pHead, &pIn->d.ea, cMax - sizeof(WireThisPart1),
                                   aExtent, dwRep );
        if (*pStubData == NULL)
            return RPC_E_INVALID_EXTENSION;
    }

    // Notify all the hooks
    for (pCurr = pHead, i = 0; pCurr != &gHookList; pCurr = pCurr->pNext, i++)
        pCurr->pHook->ServerNotify( pCurr->uExtension, pCall->hook.iid,
                             aExtent[i] != NULL ? aExtent[i]->size : 0,
                             aExtent[i] != NULL ? aExtent[i] + 1 : NULL,
                             dwRep );

	// Another integrity check on the list?
	Win4Assert((pCurr == &gHookList) && (i == gNumExtent));

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   ServerGetSize
//
//  Synopsis:   Asks each hook in the list how much data it wishes to
//              place in the next reply on this thread.
//
//--------------------------------------------------------------------
ULONG ServerGetSize( ULONG *cNumExtent, CMessageCall *pCall )
{
    SHookList *pCurr  = gHookList.pNext;
    ULONG      lSize  = SizeOfWireExtentArray;
    ULONG      lPiece = 0;
    *cNumExtent       = 0;

    // Ask each hook.
    while (pCurr != &gHookList)
    {
        pCurr->pHook->ServerGetSize( pCurr->uExtension, pCall->hook.iid,
                                     S_OK, &lPiece );
        if (lPiece != 0)
        {
            lPiece       = ((lPiece + 7) & ~7) + sizeof(WireExtent);
            lSize       += lPiece;
            *cNumExtent += 1;
        }
        pCurr = pCurr->pNext;
    }

    // Round up the number of extents and add size for an array of unique
    // flags.
    *cNumExtent = (*cNumExtent + 1) & ~1;
    lSize      += SizeOfUniqueFlags (*cNumExtent);
    if (*cNumExtent != 0)
        return lSize;
    else
        return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ClientGetSize
//
//  Synopsis:   Asks the VC debugger how much data to put in the next
//              request on this thread.  Stores the result in TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ClientGetSize( REFGUID uExtension, REFIID riid,
                                       ULONG *pSize )
{
    COleTls tls;

    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (DoDebuggerHooks)
        tls->cDebugData = DebugORPCClientGetBufferSize( NULL,
                            riid, NULL, NULL, DebuggerArg, DoDebuggerHooks );
    else
        tls->cDebugData = 0;

    *pSize = tls->cDebugData;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ClientFillBuffer
//
//  Synopsis:   Asks the VC debugger to place data in the buffer for
//              the next request on this thread.  Uses the size stored
//              in TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ClientFillBuffer( REFGUID uExtension,
                                          REFIID riid,
                                          ULONG *pSize, void *pBuffer )
{
    COleTls       tls;
    CMessageCall *pCall = RIID_TO_CALL( &riid );

    Win4Assert( DEBUG_EXTENSION == uExtension );
    Win4Assert( tls->cDebugData <= *pSize );

    if (tls->cDebugData != 0)
    {
        DebugORPCClientFillBuffer(
            &pCall->message,
            riid,
            NULL,
            NULL,
            pBuffer,
            tls->cDebugData,
            DebuggerArg,
            DoDebuggerHooks );
    }

    *pSize = tls->cDebugData;

    // This permits a smooth foreground transfer when stepping from the
    // client into the server or vice versa during debugging.
    // We cannot do much if the call fails.
    AllowSetForegroundWindow(ASFW_ANY);
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ClientNotify
//
//  Synopsis:   Passes data to the VC debugger received on the last
//              reply on this thread.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ClientNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep, HRESULT hr )
{
    CMessageCall *pCall = RIID_TO_CALL( &riid );

    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (pBuffer != NULL || DoDebuggerHooks)
    {
        DebugORPCClientNotify(
            pCall == NULL ? NULL : &pCall->message,
            riid,
            NULL,
            NULL,
            hr,
            pBuffer,
            lSize,
            DebuggerArg,
            DoDebuggerHooks );
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ServerNotify
//
//  Synopsis:   Passes data to the VC debugger receive on the last
//              request on this thread.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ServerNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep )
{
    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (pBuffer != NULL || DoDebuggerHooks)
    {
        IPIDEntry    *pIpid;
        void         *pv = NULL;
        CMessageCall *pCall = RIID_TO_CALL( &riid );

        // Lookup the IPID entry.
        LOCK(gIPIDLock);
        HRESULT hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIpid, NULL);
        UNLOCK(gIPIDLock);
        Win4Assert(hr == S_OK && pIpid != NULL);

        // Get the object pointer from the stub because the IPID entry
        // might have a different pointer.
        ((IRpcStubBuffer *) pIpid->pStub)->DebugServerQueryInterface( &pv );

        // Call the debugger.
        DebugORPCServerNotify(
                   &pCall->message,
                   riid,
                   (IRpcChannelBuffer3 *) pIpid->pChnl,
                   pv,
                   NULL,
                   pBuffer,
                   lSize,
                   DebuggerArg,
                   DoDebuggerHooks );

        // Release the object pointer.
        if (pv != NULL)
            ((IRpcStubBuffer *) pIpid->pStub)->DebugServerRelease( pv );
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ServerGetSize
//
//  Synopsis:   Asks the VC debugger how much data to place in the buffer
//              for the next reply on this thread.  Stores the result
//              in TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ServerGetSize( REFGUID uExtension, REFIID riid,
                                       HRESULT hrFault, ULONG *pSize )
{
    COleTls       tls;
    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (DoDebuggerHooks)
    {
        IPIDEntry    *pIpid;
        void         *pv = NULL;
        CMessageCall *pCall = RIID_TO_CALL( &riid );

        // Lookup the IPID entry.
        LOCK(gIPIDLock);
        HRESULT hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIpid, NULL);
        UNLOCK(gIPIDLock);
        Win4Assert(hr == S_OK && pIpid != NULL);

        // Get the object pointer from the stub because the IPID entry
        // might have a different pointer.
        ((IRpcStubBuffer *) pIpid->pStub)->DebugServerQueryInterface( &pv );

        // Ask the debugger how much data it has.
        tls->cDebugData = DebugORPCServerGetBufferSize(
                            &pCall->message,
                            riid,
                            (IRpcChannelBuffer3 *)pIpid->pChnl,
                            pv,
                            NULL,
                            DebuggerArg,
                            DoDebuggerHooks );

        // Release the object pointer.
        if (pv != NULL)
            ((IRpcStubBuffer *) pIpid->pStub)->DebugServerRelease( pv );
    }
    else
        tls->cDebugData = 0;

    *pSize = tls->cDebugData;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ServerFillBuffer
//
//  Synopsis:   Asks the VC debugger to place data in the buffer for the
//              next reply on this thread.  Uses the size from TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ServerFillBuffer( REFGUID uExtension, REFIID riid,
                                 ULONG *pSize, void *pBuffer, HRESULT hrFault )
{
    COleTls       tls;

    Win4Assert( DEBUG_EXTENSION == uExtension );
    Win4Assert( tls->cDebugData <= *pSize );

    if (tls->cDebugData != 0)
    {
        IPIDEntry    *pIpid;
        void         *pv = NULL;
        CMessageCall *pCall = RIID_TO_CALL( &riid );

        // Lookup the IPID entry.
        LOCK(gIPIDLock);
        HRESULT hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIpid, NULL);
        UNLOCK(gIPIDLock);
        Win4Assert(hr == S_OK && pIpid != NULL);

        // Get the object pointer from the stub because the IPID entry
        // might have a different pointer.
        ((IRpcStubBuffer *) pIpid->pStub)->DebugServerQueryInterface( &pv );

        // Ask the debugger to write its data.
        DebugORPCServerFillBuffer(
                &pCall->message,
                riid,
                (IRpcChannelBuffer3 *)pIpid->pChnl,
                pv,
                NULL,
                pBuffer,
                tls->cDebugData,
                DebuggerArg,
                DoDebuggerHooks );

        // Release the object pointer.
        if (pv != NULL)
            ((IRpcStubBuffer *) pIpid->pStub)->DebugServerRelease( pv );
    }

    *pSize = tls->cDebugData;

    // This permits a smooth foreground transfer when stepping from the
    // client into the server or vice versa during debugging.
    // We cannot do much if the call fails.
    AllowSetForegroundWindow(ASFW_ANY);
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::QueryInterface
//
//  Synopsis:   Queries this object for interfaces
//
//--------------------------------------------------------------------
STDMETHODIMP CDebugChannelHook::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IChannelHook))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    // This object is not reference counted.
    // AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::AddRef
//
//  Synopsis:   Increments object reference count.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDebugChannelHook::AddRef( )
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::Release
//
//  Synopsis:   Decrements object reference count and deletes if zero.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDebugChannelHook::Release( )
{
    return 1;
}


//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ClientGetSize
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ClientGetSize( REFGUID uExtension, REFIID riid,
                                       ULONG *pSize )
{
    Win4Assert( ERROR_EXTENSION == uExtension );

    *pSize = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ClientFillBuffer
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ClientFillBuffer( REFGUID uExtension,
                                          REFIID riid,
                                          ULONG *pSize, void *pBuffer )
{
    Win4Assert( ERROR_EXTENSION == uExtension );

    *pSize = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ClientNotify
//
//  Synopsis:   Unmarshals the COM extended error information.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ClientNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep, HRESULT hr )
{
    COleTls tls;

    Win4Assert( ERROR_EXTENSION == uExtension );


    //Unmarshal the new error object.
    if ((pBuffer != NULL) && (lSize > 0))
    {
        CNdrStream MemStream((unsigned char *)pBuffer, lSize);

        //Release the old error object.
        if(tls->punkError != NULL)
        {
            tls->punkError->Release();
            tls->punkError = NULL;
        }

        CoUnmarshalInterface(&MemStream,
                             IID_IUnknown,
                             (void **) &tls->punkError);
    }
    else if((tls->punkError != NULL) &&
            !IsEqualIID(riid, IID_IRundown) &&
            !IsEqualIID(riid, IID_IRemUnknown) &&
            !IsEqualIID(riid, IID_IRemUnknown2) &&
            !IsEqualIID(riid, IID_ISupportErrorInfo))
    {
            //Release the old error object.
            tls->punkError->Release();
            tls->punkError = NULL;
    }

}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ServerNotify
//
//  Synopsis:   Clears the COM extended error information on an
//              incoming call.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ServerNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep )
{
    COleTls    tls;

    Win4Assert( ERROR_EXTENSION == uExtension );

    //Release the old error object.
    if(tls->punkError != NULL)
    {
        tls->punkError->Release();
        tls->punkError = NULL;
    }

}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ServerGetSize
//
//  Synopsis:   Calculates the size of the marshalled error object.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ServerGetSize( REFGUID uExtension, REFIID riid,
                                       HRESULT hrFault, ULONG *pSize )
{
    HRESULT       hr;
    COleTls       tls;
    CMessageCall *pCall = RIID_TO_CALL( &riid );

    Win4Assert( ERROR_EXTENSION == uExtension );

    tls->cbErrorData = 0;

    //Compute the size of the marshalled error object.
    if(tls->punkError != NULL)
    {
        hr = CoGetMarshalSizeMax( &tls->cbErrorData,
                                  IID_IUnknown,
                                  tls->punkError,
                                  pCall->GetDestCtx(),
                                  NULL,
                                  MSHLFLAGS_NORMAL );
        if(FAILED(hr))
        {
            //Release the error object.
            tls->punkError->Release();
            tls->punkError = NULL;
            tls->cbErrorData = 0;
        }
    }

    *pSize = tls->cbErrorData;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ServerFillBuffer
//
//  Synopsis:   Marshals the error object.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ServerFillBuffer( REFGUID uExtension, REFIID riid,
                                 ULONG *pSize, void *pBuffer, HRESULT hrFault )
{
    HRESULT       hr;
    COleTls       tls;
    ULONG         cbSize = 0;
    CMessageCall *pCall  = RIID_TO_CALL( &riid );
    IUnknown     *punkError;
    ULONG         cbErrorData;

    Win4Assert( ERROR_EXTENSION == uExtension );
    Win4Assert( tls->cbErrorData <= *pSize );

    // If the IErrorInfo is a proxy, and we're in an STA then this the 
    // TLS data might go away if we call out from this function.  Thus,
    // back our data up onto the stack and use that version instead of the
    // TLS stuff.  (For consistency's sake, we'll use it everywhere.)
    punkError   = tls->punkError;
    cbErrorData = tls->cbErrorData; 

    if(punkError != NULL)
    {
        //Marshal the error object.
        if(cbErrorData > 0)
        {
            CNdrStream MemStream((unsigned char *)pBuffer, cbErrorData);

            hr = CoMarshalInterface(&MemStream,
                                    IID_IUnknown,
                                    punkError,
                                    pCall->GetDestCtx(),
                                    NULL,
                                    MSHLFLAGS_NORMAL);

            if(FAILED(hr))
            {
                cbErrorData = 0;
            }
        } 

        //Release the error object.
        punkError->Release();

        //This is safe to do.  Any calls relying on this pointer now are
	//now complete and we can go ahead and zero-out this field (so that
	//it doesn't confuse us ever again)
	tls->punkError = NULL;
    }

    *pSize = cbErrorData;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::QueryInterface
//
//  Synopsis:   Queries this object for interfaces
//
//--------------------------------------------------------------------
STDMETHODIMP CErrorChannelHook::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IChannelHook))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    // This object is not reference counted.
    // AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::AddRef
//
//  Synopsis:   Increments object reference count.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CErrorChannelHook::AddRef( )
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::Release
//
//  Synopsis:   Decrements object reference count and deletes if zero.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CErrorChannelHook::Release( )
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\channelb.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       channelb.cxx
//
//  Contents:   This module contains thunking classes that allow proxies
//              and stubs to use a buffer interface on top of RPC for NT
//
//  Classes:    CRpcChannelBuffer
//
//  Functions:
//              ChannelThreadInitialize
//              Channelprocessinitialize
//              ChannelRegisterProtseq
//              ChannelThreadUninitialize
//              ChannelProcessUninitialize
//              CRpcChannelBuffer::AddRef
//              CRpcChannelBuffer::AppInvoke
//              CRpcChannelBuffer::CRpcChannelBuffer
//              CRpcChannelBuffer::FreeBuffer
//              CRpcChannelBuffer::GetBuffer
//              CRpcChannelBuffer::QueryInterface
//              CRpcChannelBuffer::Release
//              CRpcChannelBuffer::SendReceive
//              CRpcChannelBuffer::Send
//              CrpcChannelBuffer::Receive
//              CRpcChannelBuffer::CleanUpCanceledOrFailed
//              DllDebugObjectRPCHook
//              ThreadInvoke
//              ThreadSendReceive
//
//  History:    22 Jun 93 AlexMi        Created
//              31 Dec 93 ErikGav       Chicago port
//              15 Mar 94 JohannP       Added call category support.
//              09 Jun 94 BruceMa       Get call category from RPC message
//              19 Jul 94 CraigWi       Added support for ASYNC calls
//              01-Aug-94 BruceMa       Memory sift fix
//              12-Dec-96 Gopalk        Support for updating connection
//                                      status maintained by Std Identity
//              02-Jan-97 RichN         Add pipe support
//              17-Oct-97 RichN         Remove pipes.
//
//----------------------------------------------------------------------

#include <ole2int.h>
#include <ctxchnl.hxx>
#include <hash.hxx>         // CUUIDHashTable
#include <riftbl.hxx>       // gRIFTbl
#include <callctrl.hxx>     // CAptRpcChnl, AptInvoke
#include <threads.hxx>      // CRpcThreadCache
#include <service.hxx>      // StopListen
#include <resolver.hxx>     // CRpcResolver
#include <giptbl.hxx>       // CGIPTbl
#include <refcache.hxx>     // gROIDTbl
#include <reghelp.hxx>

extern "C"
{
#include "orpc_dbg.h"
}

#include <rpcdcep.h>
#include <rpcndr.h>
#include <obase.h>
#include <ipidtbl.hxx>
#include <security.hxx>
#include <chock.hxx>
#include <sync.hxx>         // CAutoComplete::QueryInterface
#include "aprtmnt.hxx"      // Apartment object.
#include <events.hxx>       // Event logging functions
#include <callmgr.hxx>
#include <excepn.hxx>       // Exception filter routines


// This is needed for the debug hooks.  See orpc_dbg.h
#pragma code_seg(".orpc")

extern CObjectContext *g_pNTAEmptyCtx;  // NTA empty context
extern HRESULT GetAsyncIIDFromSyncIID(REFIID rSyncIID, IID *pAsyncIID);
extern HINSTANCE g_hComSvcs;            // module handle of com svcs.


/***************************************************************************/
/* Defines. */
// This should just return a status to runtime, but runtime does not
// support both comm and fault status yet.
#define RETURN_COMM_STATUS( status ) RpcRaiseException( status )

// Default size of hash table.
const int INITIAL_NUM_BUCKETS = 20;

/***************************************************************************/
/* Macros. */

// Compute the size needed for the implicit this pointer including the
// various optional headers.
inline DWORD SIZENEEDED_ORPCTHIS( BOOL local, DWORD debug_size )
{
    if (debug_size == 0)
        return sizeof(WireThisPart1) + ((local) ? sizeof(LocalThis) : 0);
    else
        return sizeof(WireThisPart2) + ((local) ? sizeof(LocalThis) : 0) +
          debug_size;
}

inline DWORD SIZENEEDED_ORPCTHAT( DWORD debug_size )
{
    if (debug_size == 0)
        return sizeof(WireThatPart1);
    else
        return sizeof(WireThatPart2) + debug_size;
}

inline CALLCATEGORY GetCallCat( void *header )
{
    WireThis *pInb = (WireThis *) header;
    if (pInb->c.flags & ORPCF_ASYNC)
        return CALLCAT_ASYNC;
    else if (pInb->c.flags & ORPCF_INPUT_SYNC)
        return CALLCAT_INPUTSYNC;
    else
        return CALLCAT_SYNCHRONOUS;
}

inline HRESULT FIX_WIN32( HRESULT result )
{
    if ((ULONG) result > 0xfffffff7 || (ULONG) result < 0x2000)
        return MAKE_WIN32( result );
    else
        return result;
}

/***************************************************************************/
/* Globals. */

// Should the debugger hooks be called?
BOOL               DoDebuggerHooks = FALSE;
LPORPC_INIT_ARGS   DebuggerArg     = NULL;

// The extension identifier for debug data.
const uuid_t DEBUG_EXTENSION =
{ 0xf1f19680, 0x4d2a, 0x11ce, {0xa6, 0x6a, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};

// this is a special IID to get a pointer to the  C++ object itself
// on a CRpcChannelBuffer object  It is not exposed to the outside
// world.
const IID IID_CPPRpcChannelBuffer = {0x00000152,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


#if DBG == 1
// strings that prefix the call
WCHAR *wszDebugORPCCallPrefixString[8] = { L"In ",     // Invoke
                                           L"In ",
                                           L"Out",     // SendReceive
                                           L"Out",
                                           L"Snd",     // Send
                                           L"Snd",
                                           L"Rcv",     // Receive
                                           L"Rcv" };
// strings for call categories
WCHAR *wszCallCat[7] = { L"no call   ",
                         L"sync      ",
                         L"async     ",
                         L"input_sync",
                         L"sync      ",
                         L"input_sync",
                         L"SCM call  "};
#endif



// flag whether or not the channel has been initialized for current process
BOOL    gfChannelProcessInitialized = 0;
COleStaticMutexSem  gChannelInitLock;   // critical section to guard (un)init

// Channel debug hook object.
CDebugChannelHook gDebugHook;

// Channel error hook object.
CErrorChannelHook gErrorHook;

// Context hook
CCtxHook gCtxHook;

//******************************************************************************
// Prototypes
//
HRESULT CreateHandle  ( OXIDEntry *pOXIDEntry, DWORD eChannel,
                        CChannelHandle **ppHandle );
HRESULT ComInvokeWithLockAndIPID( CMessageCall *pCall, IPIDEntry *pIPIDEntry);

#if DBG==1
//-------------------------------------------------------------------------
//
//  Function:   GetInterfaceName
//
//  synopsis:   Gets the human readable name of an Interface given it's IID.
//
//  History:    12-Jun-95   Rickhi  Created
//
//-------------------------------------------------------------------------
LONG GetInterfaceName(REFIID riid, WCHAR *pwszName, size_t cchwszName)
{
    // convert the iid to a string
    CDbgGuidStr dbgsIID(riid);

    // Read the registry entry for the interface to get the interface name
    LONG ulcb=(LONG)cchwszName*sizeof(WCHAR);
    WCHAR szKey[80];

    pwszName[0] = L'\0';
    szKey[0] = L'\0';
    lstrcatW(szKey, L"Interface\\");
    lstrcatW(szKey, dbgsIID._wszGuid);

    LONG result = QueryClassesRootValueW(
        szKey,
        pwszName,
        &ulcb);

    return result;
}

//---------------------------------------------------------------------------
//
//  Function:   DebugPrintORPCCall
//
//  synopsis:   Prints the interface name and method number to the debugger
//              to allow simple ORPC call tracing.
//
//  History:    12-Jun-95   Rickhi  Created
//
//---------------------------------------------------------------------------
void DebugPrintORPCCall(DWORD dwFlag, REFIID riid, DWORD iMethod, DWORD CallCat)
{
    if(dwFlag >= 8)
        return;

    if (CairoleInfoLevel & DEB_RPCSPY)
    {
        COleTls tls;

        // construct the debug strings
        WCHAR *pwszDirection = wszDebugORPCCallPrefixString[dwFlag];
        WCHAR *pszCallCat = wszCallCat[CallCat];
        WCHAR *pszBeginEnd = L"{";
        WCHAR wszName[100];
        WCHAR wszIndent[20];
        int i;

        GetInterfaceName(riid, wszName, sizeof(wszName)/sizeof(*wszName));

        // adjust the nesting level for this thread.
        switch(dwFlag)
        {
        case ORPC_INVOKE_END:
        case ORPC_SENDRECEIVE_END:
        case ORPC_SEND_END:
            if(tls->cORPCNestingLevel > 0)
            {
                tls->cORPCNestingLevel--;
            }
            else
            {
                tls->cORPCNestingLevel = 0;
            }
            pszBeginEnd = L"}";
            break;
        default:
            break;
        }

        for(i = 0; i <= tls->cORPCNestingLevel && i < 10; i++)
        {
            wszIndent[i] = L' ';
        }
        wszIndent[i] = L'\0';

        ComDebOut((DEB_RPCSPY, "%ws %ws %d%ws%ws::%d %ws\n", pszCallCat,
                   pwszDirection, tls->cORPCNestingLevel, wszIndent,
                   wszName, iMethod & ~0x8000, pszBeginEnd));

        // adjust the nesting level for this thread.
        switch(dwFlag)
        {
        case ORPC_INVOKE_BEGIN:
        case ORPC_SENDRECEIVE_BEGIN:
        case ORPC_SEND_BEGIN:
            tls->cORPCNestingLevel++;
            break;
        default:
            break;
        }
    }
}
#endif

#if LOCK_PERF==1
//---------------------------------------------------------------------------
//
//  Function:   OutputHashPerfData, public
//
//  Synopsis:   Dumps the statistics gathered by the various hash tables
//              in the system.
//
//---------------------------------------------------------------------------
void OutputHashPerfData()
{
    char szHashPerfBuf[256];
    wsprintfA(szHashPerfBuf,"\n\n ============= HASH TABLE MAX SIZES ===========\n");
    OutputDebugStringA(szHashPerfBuf);

    OutputHashEntryData("gOIDTable ", gOIDTable.s_OIDHashTbl);
    OutputHashEntryData("gPIDTable ", gPIDTable.s_PIDHashTbl);
    OutputHashEntryData("gROIDTbl  ", gROIDTbl._ClientRegisteredOIDs);
    OutputHashEntryData("gPSTable  ", gPSTable.s_PSHashTbl);
    OutputHashEntryData("gMIDTbl   ", gMIDTbl._HashTbl);
    OutputHashEntryData("gRIFTbl   ", gRIFTbl._HashTbl);
}
#endif // LOCK_PERF

/***************************************************************************/
void ByteSwapThis( DWORD drep, WireThis *pInb )
{
    if ((drep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
    {
        // Extensions are swapped later.  If we ever use the reserved field,
        // swap it.
        ByteSwapShort( pInb->c.version.MajorVersion );
        ByteSwapShort( pInb->c.version.MinorVersion );
        ByteSwapLong( pInb->c.flags );
        // ByteSwapLong( pInb->c.reserved1 );
        ByteSwapLong( pInb->c.cid.Data1 );
        ByteSwapShort( pInb->c.cid.Data2 );
        ByteSwapShort( pInb->c.cid.Data3 );
    }
}

/***************************************************************************/
void ByteSwapThat( DWORD drep, WireThat *pOutb )
{
    if ((drep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
    {
        // Extensions are swapped later.
        ByteSwapLong( pOutb->c.flags );
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::AddRef
//
//  Synopsis:   Increase reference count on object.
//
//--------------------------------------------------------------------
void CChannelHandle::AddRef()
{
    InterlockedIncrement( (long *) &_cRef );
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::AdjustToken
//
//  Synopsis:   Adjust the thread token to the one RPC needs to see
//              to get the DCOM cloaking model.  The cases are as
//              follows.
//
//              Cross apartment
//                  Do nothing
//
//              Cross machine and cross process
//                  Set Blanket
//                      If no cloaking, set NULL token
//                      Else do nothing
//                  SendReceive
//                      Do nothing
//
//--------------------------------------------------------------------
void CChannelHandle::AdjustToken( DWORD dwCase, BOOL *pResume, HANDLE *pThread )
{
    // Return if cross apartment.
    *pResume = FALSE;
    if (pThread != NULL)
        *pThread = NULL;
    if (_eState & process_local_hs)
        return;

    // Handle the set blanket cases.
    if (dwCase == SET_BLANKET_AT)
    {

        // Set the thread token NULL for cross machine no cloaking.
        {
            if ((_eState & any_cloaking_hs) == 0)
            {
                // Return the current thread token.
                OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE,
                                 TRUE, pThread );

                // Set the thread token NULL.
                if (*pThread != NULL)
                {
                    Verify( SetThreadToken( NULL, NULL ) );
                    *pResume = TRUE;
                }
            }
        }
    }

    //              Cross process
    //                  SendReceive
    //                      If static cloaking, set saved token
    //                      If no cloaking, set NULL token
    //                      If dynamic cloaking, do nothing

    // Handle the send receive cases.
    else if (_eState & machine_local_hs)
    {

        // Set the thread token NULL for no cloaking machine local.
        if ((_eState & any_cloaking_hs) == 0)
        {
            // Return the current thread token.
            OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE,
                             TRUE, pThread );

            // Set the thread token NULL.
            if (*pThread != NULL)
            {
                Verify( SetThreadToken( NULL, NULL ) );
                *pResume = TRUE;
            }
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::CChannelHandle
//
//  Synopsis:   Construct a channel handle.
//
//--------------------------------------------------------------------
CChannelHandle::CChannelHandle( DWORD lAuthn, DWORD lImp,
                                DWORD dwCapabilities, OXIDEntry *pOXIDEntry,
                                DWORD eChannel, HRESULT *phr )
{
    RPC_STATUS      status = RPC_S_OK;

    // Initialize the members.
    _hRpc       = NULL;
    _hToken     = NULL;
    _lAuthn     = lAuthn;
    _lImp       = lImp;
    _cRef       = 1;
    _fFirstCall = TRUE;
    _eState     = 0;

    if (dwCapabilities & EOAC_STATIC_CLOAKING)
        _eState |= static_cloaking_hs;
    if (dwCapabilities & EOAC_DYNAMIC_CLOAKING)
        _eState |= dynamic_cloaking_hs;
    if (eChannel & process_local_cs)
        _eState |= process_local_hs;
    else if (pOXIDEntry->IsOnLocalMachine())
        _eState |= machine_local_hs;
    if (eChannel & app_security_cs)
        _eState |= app_security_hs;

    // For process local handles, get a token.
    *phr = S_OK;
    if (eChannel & process_local_cs)
    {
        // Only save the token if authentication and static cloaking are enabled.
        if (lAuthn != RPC_C_AUTHN_LEVEL_NONE &&
            (_eState & static_cloaking_hs))
            *phr = OpenThreadTokenAtLevel( _lImp, &_hToken );
    }

    // For remote handles get an RPC binding handle.
    else
    {
        // If the OXID has a binding handle, copy it.
        if (pOXIDEntry->_pRpc != NULL)
            status = RpcBindingCopy(pOXIDEntry->_pRpc->_hRpc, &_hRpc);

        // Otherwise create a binding handle from the OXID string bindings.
        else
            status = RpcBindingFromStringBinding((TCHAR *)pOXIDEntry->GetBinding()->aStringArray,
                                                 &_hRpc );
        // Turn off serialization.
        if (status == RPC_S_OK)
            status = RpcBindingSetOption( _hRpc, RPC_C_OPT_BINDING_NONCAUSAL,
                                          TRUE );
        if (status != RPC_S_OK)
            *phr = MAKE_WIN32(status);
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::CChannelHandle
//
//  Synopsis:   Copy a channel handle for a local call with dynamic
//              impersonation.  The copied channel contains the new
//              thread token.
//
//--------------------------------------------------------------------
CChannelHandle::CChannelHandle( CChannelHandle *pOrig, DWORD eChannel,
                                HRESULT *phr )
{
    // Copy the members.
    Win4Assert( pOrig->_eState & dynamic_cloaking_hs );
    Win4Assert( pOrig->_eState & process_local_hs );
    Win4Assert( pOrig->_lAuthn != RPC_C_AUTHN_LEVEL_NONE );

    _hRpc   = NULL;
    _hToken = NULL;
    _lAuthn = pOrig->_lAuthn;
    _lImp   = pOrig->_lImp;
    _eState = pOrig->_eState & ~(allow_hs | deny_hs);
    _cRef   = 1;

    // Get a token.
    *phr = OpenThreadTokenAtLevel( _lImp, &_hToken );
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::~CChannelHandle
//
//  Synopsis:   Destroy a channel handle.
//
//--------------------------------------------------------------------
CChannelHandle::~CChannelHandle()
{
    if (_hRpc != NULL)
        RpcBindingFree( &_hRpc );
    if (_hToken != NULL)
        CloseHandle( _hToken );
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::Release
//
//  Synopsis:   Decrease reference count on object and delete if zero.
//
//--------------------------------------------------------------------
void CChannelHandle::Release()
{
    if (InterlockedDecrement( (long*) &_cRef ) == 0)
        delete this;
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::RestoreToken
//
//  Synopsis:   If the resume flag is true, set the thread token to the
//              specified token.
//
//--------------------------------------------------------------------
void CChannelHandle::RestoreToken( BOOL fResume, HANDLE hToken )
{
    if (fResume)
    {
        Verify( SetThreadToken( NULL, hToken ) );
        if (hToken != NULL)
            CloseHandle( hToken );
    }
}

//+-------------------------------------------------------------------
//
//  Function:   ChannelProcessInitialize, public
//
//  Synopsis:   Initializes the channel subsystem per process data.
//
//  History:    23-Nov-93   AlexMit        Created
//
//--------------------------------------------------------------------
STDAPI ChannelProcessInitialize()
{
    ComDebOut((DEB_COMPOBJ, "ChannelProcessInitialize [IN]\n"));

    BOOL b;
    
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
    LOCK(gChannelInitLock);
    b = gfChannelProcessInitialized;
    UNLOCK(gChannelInitLock);
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
    
    // check if already initialized
    if (b)
        return S_OK;

    // Dont want to do process-wide channel initialization from the
    // NA - dont know what all might be affected.  So if thread is
    // in the NA, switch it out and switch it back on the way out.

    BOOL fRestoreThreadToNA = IsThreadInNTA();
    COleTls Tls;
    CObjectContext *pSavedCtx = NULL;
    CObjectContext *pDefaultCtx = IsSTAThread() ? Tls->pNativeCtx : g_pMTAEmptyCtx;
    if (fRestoreThreadToNA)
        pSavedCtx = LeaveNTA(pDefaultCtx);

    Win4Assert( (sizeof(WireThisPart1) & 7) == 0 );
    Win4Assert( (sizeof(WireThisPart2) & 7) == 0 );
    Win4Assert( (sizeof(LocalThis) & 7) == 0 );
    Win4Assert( (sizeof(WireThatPart1) & 7) == 0 );
    Win4Assert( (sizeof(WireThatPart2) & 7) == 0 );

    // we want to take the gChannelInitLock since that prevents other Rpc
    // threads from accessing anything we are about to create, in
    // particular, the event cache and CMessageCall cache are accessed
    // by Rpc worker threads of cancelled calls.

    // Initialize policy set table
    CPSTable::Initialize();

    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
    LOCK(gChannelInitLock);

    HRESULT hr = S_OK;

    if (!gfChannelProcessInitialized)
    {
        // Initialize the interface hash tables, the OID hash table, and
        // the MID hash table. We dont need to cleanup these on errors.

        gMIDTbl.Initialize();
        gOXIDTbl.Initialize();
        gRIFTbl.Initialize();
        gIPIDTbl.Initialize();
        gSRFTbl.Initialize();
        gGIPTbl.Initialize();
        gROIDTbl.Initialize();
        CServerSecurity::Initialize();

        // ronans - initialize endpoints table
        gEndpointsTable.Initialize();

        // Initialize CtxComChnl
        CCtxComChnl::Initialize(sizeof(CCtxComChnl));

        // Register the debug channel hook.
        hr = CoRegisterChannelHook( DEBUG_EXTENSION, &gDebugHook );

        // Register the error channel hook.
        if(SUCCEEDED(hr))
        {
            hr = CoRegisterChannelHook( ERROR_EXTENSION, &gErrorHook );
        }

        // Register the context hook.
        if(SUCCEEDED(hr))
        {
            hr = CoRegisterChannelHook( CONTEXT_EXTENSION, &gCtxHook );
        }

        // initialize the rest of the channel hooks
        InitHooksIfNecessary();

        // Initialize security.
        if (SUCCEEDED(hr))
        {
            hr = InitializeSecurity();
        }

        // Make sure lrpc has been registered.
        if (SUCCEEDED(hr))
            hr = CheckLrpc();

        // Initialize COM events reporting
        LogEventInitialize();

        // always set to TRUE if we initialized ANYTHING, regardless of
        // whether there were any errors. That way, ChannelProcessUninit
        // will cleanup anything we have initialized.
        gfChannelProcessInitialized = TRUE;

        if (FAILED(hr))
        {
            // cleanup anything we have created thus far. Do this without
            // releasing the lock since we want to ensure that another
            // thread blocked above waiting on the lock does not get to
            // run and think the channel is initialized.
            ChannelProcessUninitialize();
        }
    }

    UNLOCK(gChannelInitLock);
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);

    if (fRestoreThreadToNA)
    {
        pSavedCtx = EnterNTA(pSavedCtx);
        Win4Assert(pSavedCtx == pDefaultCtx);
    }

    ComDebOut((DEB_COMPOBJ, "ChannelProcessInitialize [OUT] hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ChannelProcessUninitialize, public
//
//  Synopsis:   Uninitializes the channel subsystem global data.
//
//  History:    23-Nov-93   Rickhi       Created
//              12-Feb-98   JohnStra     Made NTA aware
//
//  Notes:      This is called at process uninitialize, not thread
//              uninitialize.
//
//--------------------------------------------------------------------
STDAPI_(void) ChannelProcessUninitialize(void)
{
    ComDebOut((DEB_COMPOBJ, "ChannelProcessUninitialize [IN]\n"));

    // Note: This function may have been called by ChannelProcessInitialize
    // if the Initialization failed. In that case, the lock will still be
    // held. We need to do this to ensure that Init and cleanup on failure
    // is an atomic operation.
    ASSERT_LOCK_DONTCARE(gChannelInitLock);

    // revoke any entries still in the GIP table before taking
    // the lock (with exception for failed Init as indicated above).
    gGIPTbl.RevokeAllEntries();

    if (gfChannelProcessInitialized)
    {
        // Stop accepting calls from the object resolver and flag that service
        // is no longer initialized.  This can result in calls being
        // dispatched.  Do not hold the lock around this call.

        UnregisterDcomInterfaces();
    }

    gResolver.ReleaseSCMProxy();

    // we want to take the ChannelInitLock since that prevents other Rpc
    // threads from accessing anything we are about to cleanup, in
    // particular, the event cache and CMessageCall are accessed by
    // Rpc worker threads for cancelled calls.
    ASSERT_LOCK_DONTCARE(gChannelInitLock);
    LOCK(gChannelInitLock);

    if (gfChannelProcessInitialized)
    {
        // Uninitialize COM events reporting.
        LogEventCleanup();

        // Release the interface tables.  This causes RPC to stop dispatching
        // DCOM calls. This can result in calls being dispatched, thus we can't
        // be holding other Locks around this. UnRegisterServerInterface
        // releases and reaquires the riftable lock each time it is called.

        gRIFTbl.Cleanup();

        // Stop the MTA and NTA apartment remoting. Do this after the RIFTble
        // cleanup so we are not processing any calls while it happens.
        if (gpMTAApartment)
        {
            gpMTAApartment->CleanupRemoting();
        }
        if (gpNTAApartment)
        {
            gpNTAApartment->CleanupRemoting();
        }

        // cleanup the GIP, IPID, OXID, and MID tables
        gGIPTbl.Cleanup();
        CRefCache::Cleanup();
        gOXIDTbl.FreeExpiredEntries(GetTickCount()+1);
        gIPIDTbl.Cleanup();
        gOXIDTbl.Cleanup();
        gMIDTbl.Cleanup();
        gSRFTbl.Cleanup();        

        if (gpsaCurrentProcess)
        {
            // delete the string bindings for the current process
            PrivMemFree(gpsaCurrentProcess);
            gpsaCurrentProcess = NULL;
        }

        // cleanup endpoints table
        gEndpointsTable.Cleanup();

        // Cleanup the OID registration table.
        gROIDTbl.Cleanup();

        // Cleanup the call caches.
        CAsyncCall::Cleanup();
        CClientCall::Cleanup();
        CServerSecurity::Cleanup();
        gCallTbl.Cleanup();

        // Release all cached threads.
        gRpcThreadCache.ClearFreeList();

        // cleanup the event cache
        gEventCache.Cleanup();

        // Cleanup the channel hooks.
        CleanupChannelHooks();

        // Cleanup CtxComChnl
        CCtxComChnl::Cleanup();
    }

    // Free the comsvcs dll if the handle is still non-null
    HINSTANCE hComSvc = (HINSTANCE) InterlockedExchangePointer((PVOID *)&g_hComSvcs, NULL);

    if(hComSvc)
    {
        FreeLibrary(hComSvc);
        hComSvc = NULL;
    }

    // Always cleanup the RPC OXID resolver since security may initialize it.
    gResolver.Cleanup();

    // Cleanup security.
    UninitializeSecurity();

    // mark the channel as no longer intialized for this process
    gfChannelProcessInitialized = FALSE;

    // Cleanup contexts related stuff
    CObjectContext::Cleanup();

    // release the static unmarshaler
    if (gpStdMarshal)
    {
        ((CStdIdentity *) gpStdMarshal)->UnlockAndRelease();
        gpStdMarshal = NULL;
    }

    // Release the lock
    UNLOCK(gChannelInitLock);
    ASSERT_LOCK_DONTCARE(gChannelInitLock);

    // Cleanup policy set table
    CPSTable::Cleanup();

    ComDebOut((DEB_COMPOBJ, "ChannelProcessUninitialize [OUT]\n"));
    return;
}

//+-------------------------------------------------------------------
//
//  Function:   ChannelThreadUninitialize, private
//
//  Synopsis:   Uninitializes the channel subsystem per thread data.
//
//  History:    23-Nov-93   Rickhi       Created
//              12-Feb-98   JohnStra     Made NTA aware
//
//  Notes:      This is called at thread uninitialize, not process
//              uninitialize.
//
//--------------------------------------------------------------------
STDAPI_(void) ChannelThreadUninitialize(void)
{
    ComDebOut((DEB_COMPOBJ, "ChannelThreadUninitialize [IN]\n"));

    // release the per-thread call objects if any
    COleTls tls;
    CleanupThreadCallObjects(tls);

    // release the remoting stuff for this apartment
    CComApartment *pComApt = NULL;
    if (SUCCEEDED(GetCurrentComApartment(&pComApt)))
    {
        pComApt->CleanupRemoting();
        pComApt->Release();
    }

    APTKIND AptKind = GetCurrentApartmentKind(tls);
    if (AptKind != APTKIND_NEUTRALTHREADED)
    {
        // Cleanup policy set table for this thread
        gPSTable.ThreadCleanup(TRUE);
    }

    // mark the thread as no longer intialized for the channel
    tls->dwFlags &= ~OLETLS_CHANNELTHREADINITIALZED;

    ComDebOut((DEB_COMPOBJ, "ChannelThreadUninitialize [OUT]\n"));
}

//+-------------------------------------------------------------------
//
//  Function:   CleanupThreadCallObjects, public
//
//  Synopsis:   Deletes each call object held in TLS cache. Called
//              during ChannelThreadUnintialize or THREAD_DETACH.
//
//+-------------------------------------------------------------------
INTERNAL_(void) CleanupThreadCallObjects(SOleTlsData *pTls)
{
    if (pTls->pFreeClientCall)
    {
        CClientCall* pCallToDelete = pTls->pFreeClientCall;
        pTls->pFreeClientCall = NULL;
        delete pCallToDelete;
    }

    if (pTls->pFreeAsyncCall)
    {
        CAsyncCall* pCallToDelete = pTls->pFreeAsyncCall;
        pTls->pFreeAsyncCall = NULL;
        delete pCallToDelete;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   InitChannelIfNecessary, private
//
//  Synopsis:   Checks if the ORPC channel has been initialized for
//              the current apartment and initializes if not. This is
//              required by the delayed initialization logic.
//
//  History:    26-Oct-95   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL InitChannelIfNecessary()
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // get the current apartment and start it listening
    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);
    if (SUCCEEDED(hr))
    {
        hr = pComApt->StartServer();
        pComApt->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}


/***************************************************************************/
STDMETHODIMP_(ULONG) CRpcChannelBuffer::AddRef( THIS )
{
    // can't call AssertValid(FALSE) since it is used in asserts
    return InterlockedIncrement( (long *) &_cRefs );
}

/***************************************************************************/
HRESULT AppInvoke( CMessageCall      *pCall,
                   CRpcChannelBuffer *pChannel,
                   IRpcStubBuffer    *pStub,
                   void              *pv,
                   void              *pStubBuffer,
                   IPIDEntry         *pIPIDEntry,
                   LocalThis         *pLocalb)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPCOLEMESSAGE   *pMessage        = &pCall->message;
    void            *pDispatchBuffer = pMessage->Buffer;
    WireThat        *pOutb           = NULL;
    HRESULT          hresult;
    DWORD            dwFault;

    // Save a pointer to the inbound header.
    pCall->_pHeader = pMessage->Buffer;

    // Adjust the buffer.
    pMessage->cbBuffer  -= (ULONG) ((char *) pStubBuffer - (char *) pMessage->Buffer);
    pMessage->Buffer     = pStubBuffer;
    pMessage->iMethod   &= ~RPC_FLAGS_VALID_BIT;
    pMessage->reserved1  = pCall;

    // if the incoming call is from a non-NDR client, then set a bit in
    // the message flags field so the stub can figure out how to dispatch
    // the call.  This allows a 32bit server to simultaneously service a
    // 32bit client using NDR and a 16bit client using non-NDR, in particular,
    // to support OLE Automation.
    if (pLocalb != NULL && pLocalb->flags & LOCALF_NONNDR)
        pMessage->rpcFlags |= RPCFLG_NON_NDR;

    if (IsMTAThread() || IsThreadInNTA())
    {
        // do multi-threaded apartment invoke
        hresult = MTAInvoke( pMessage, GetCallCat( pCall->_pHeader ),
                             pStub, pChannel, pIPIDEntry, &dwFault );
    }
    else
    {
        // do single-threaded apartment invoke
        hresult = STAInvoke( pMessage, GetCallCat( pCall->_pHeader ),
                             pStub, pChannel, pv, pIPIDEntry, &dwFault );
    }

    // Don't do anything for async calls.
    ASSERT_LOCK_NOT_HELD(gComLock);
    if (pCall->ServerAsync())
        return S_OK;

    pCall->SetFault(dwFault);

    // For local calls, just free the in buffer. For non-local calls,
    // the RPC runtime does this for us.
    if (pMessage->rpcFlags & RPCFLG_LOCAL_CALL)
    {
        PrivMemFree8( pDispatchBuffer );
        pDispatchBuffer = NULL;

        // Set the complete bit.
        pMessage->rpcFlags |= RPC_BUFFER_COMPLETE;
    }

    // Find the header if a new buffer was returned.
    if (pMessage->Buffer != pStubBuffer && pMessage->Buffer != NULL)
    {
        // An out buffer exists, get the pointer to the channel header.
        Win4Assert( pCall->_pHeader != pDispatchBuffer );
        pMessage->cbBuffer += (ULONG) ((char *) pMessage->Buffer - (char *) pCall->_pHeader);
        pMessage->Buffer    = pCall->_pHeader;
        pOutb               = (WireThat *) pMessage->Buffer;
    }
    // Restore the pointer to the original buffer.
    else
        pMessage->Buffer = pDispatchBuffer;

    // Handle failures.
    if (hresult != S_OK)
    {
        if (hresult == RPC_E_CALL_REJECTED)
        {
            // Call was rejected.  If the caller is on another machine, just fail the
            // call.
            if (pCall->GetDestCtx() != MSHCTX_DIFFERENTMACHINE && pOutb != NULL)
            {
                // Otherwise return S_OK so the buffer gets back, but set the flag
                // to indicate it was rejected.
                pOutb->c.flags = ORPCF_LOCAL | ORPCF_REJECTED;
                hresult = S_OK;
            }
        }
        else if (hresult == RPC_E_SERVERCALL_RETRYLATER)
        {
            // Call was rejected.  If the caller is on another machine, just fail the
            // call.
            if (pCall->GetDestCtx() != MSHCTX_DIFFERENTMACHINE && pOutb != NULL)
            {
                // Otherwise return S_OK so the buffer gets back, but set the flag
                // to indicate it was rejected with retry later.
                pOutb->c.flags = ORPCF_LOCAL | ORPCF_RETRY_LATER;
                hresult = S_OK;
            }
        }
        // Maybe something should be cleaned up.
        else
        {
            // If a policy object is returning an error, don't free the buffer
            // It will be freed by the caller.
            if (!pCall->GetErrorFromPolicy()) 
            {
                pCall->_pHeader = NULL;
                if (pMessage->Buffer != pDispatchBuffer)
                {
                    // call failed and the call is local, free the out buffer. For
                    // non-local calls the RPC runtime does this for us.
                    if (pMessage->rpcFlags & RPCFLG_LOCAL_CALL)
                        PrivMemFree8( pMessage->Buffer );
                }
            }
        }
    }

    return hresult;
}



//+---------------------------------------------------------------------------
//
//  Function:   SyncStubInvoke
//
//  Synopsis:   Dispatch a call Synchronously
//
//  History:    June 08, 98      Gopalk     Created
//----------------------------------------------------------------------------
HRESULT SyncStubInvoke(RPCOLEMESSAGE *pMsg, REFIID riid,
                       CIDObject *pID, IRpcChannelBuffer *pChnl,
                       IRpcStubBuffer *pStub, DWORD *pdwFault)
{
    // Increment the call count on the server object
    HRESULT hr = S_OK;
    if(pID)
        hr = pID->IncrementCallCount();

    if(SUCCEEDED(hr))
    {
        _try
          {
              hr = pStub->Invoke(pMsg, pChnl);
          }
        _except(AppInvokeExceptionFilter(GetExceptionInformation(), 
                                         pID ? (pID->GetServer() ?  pID->GetServer() : pStub) : pStub,
                                         riid, 
                                         pMsg->iMethod))
          {
              hr = RPC_E_SERVERFAULT;
              *pdwFault = GetExceptionCode();
          }

        // Unlock the server
        if(pID)
            pID->DecrementCallCount();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AsyncStubInvoke
//
//  Synopsis:   Dispatch a call Asynchronously
//
//  History:    June 08, 98      Gopalk     Rewritten to handle server
//                                          exceptions and server lifetime
//                                          issues
//----------------------------------------------------------------------------
HRESULT AsyncStubInvoke(RPCOLEMESSAGE *pMsg, REFIID riid, CStdIdentity *pStdID,
                        IRpcChannelBuffer *pChnl, IRpcStubBuffer *pStub,
                        IPIDEntry *pIPIDEntry, DWORD *pdwFault, HRESULT *pAsyncHr)
{
    // Determine if the server supports async functionality
    CRpcChannelBuffer::CServerCallMgr *pStubAsync = NULL;
    HRESULT hr = CO_E_NOT_SUPPORTED;
    *pAsyncHr = hr;
    CMessageCall *_pCall  = (CMessageCall *) pMsg->reserved1;

    if((pIPIDEntry != NULL) /* DDE call */ &&
       _pCall->GetCallCategory() != CALLCAT_INPUTSYNC /* not input-sync call*/ &&
       (pStdID->GetServerPolicySet() == NULL) /* Default context */ &&
       ((!(pIPIDEntry->dwFlags & IPIDF_TRIED_ASYNC) /* not sure yet */) ||
        (pIPIDEntry->dwFlags & IPIDF_ASYNC_SERVER) /* definitely async */))
    {
        // Try creating an async call manager object
        hr = GetChannelCallMgr(pMsg, pStub, (IUnknown *)pIPIDEntry->pv, &pStubAsync);

        // Update the IPID about succeess or failure
        if(SUCCEEDED(hr))
        {
            // Sanity check
            Win4Assert(pStubAsync);
            pIPIDEntry->dwFlags |= (IPIDF_TRIED_ASYNC | IPIDF_ASYNC_SERVER);

            // Transfer context call object from TLS to async call object
            CCtxCall *pCtxCall = new CCtxCall(((CMessageCall *) pMsg->reserved1)->GetServerCtxCall());
            if(pCtxCall)
                pStubAsync->GetCall()->SetServerCtxCall(pCtxCall);
            else
                hr = E_OUTOFMEMORY;
            if(SUCCEEDED(hr))
            {
                CRpcChannelBuffer *pCChnl = CRpcChannelBuffer::SafeCast(pChnl);
                hr = pCChnl->RegisterAsync(pMsg, NULL);
                if(SUCCEEDED(hr))
                {
                    // Increment call count
                    CIDObject *pID = pStdID->GetIDObject();
                    if(pID)
                        hr = pID->IncrementCallCount();
                    if(SUCCEEDED(hr))
                    {
                        // AddRef async call object
                        pStubAsync->AddRef();

                        // Set the StdID on the async call mgr
                        pStubAsync->SetStdID(pStdID);

                        // Lock server
                        pStdID->RelockServer();

                        if(SUCCEEDED(hr))
                        {
                            // Call successfully registered as async. Invoke the begin method
                            ComDebOut((DEB_CHANNEL,
                                       "StubInvoke:: dispatching call asynchronously\n"));

                            _try
                              {
                                // Dispatch asynchronously
                                  hr = pStubAsync->Invoke(pMsg, pChnl);
                              }
                            _except(AppInvokeExceptionFilter(GetExceptionInformation(),
                                                             pIPIDEntry->pv,
                                                             riid, 
                                                             pMsg->iMethod))
                              {
                                  hr = RPC_E_SERVERFAULT;
                                  *pdwFault = GetExceptionCode();
                              }
                        }

                        // Check for failure
                        if(FAILED(hr))
                        {
                            // CODEWORK:: This type of error checking can be
                            // accomplished much more clearly by getting between
                            // the channel and the stub call object.

                            ComDebOut((DEB_CHANNEL,
                                       "StubInvoke:: invoke on async call object "
                                       "failed! hr = 0x%x\n",
                                       hr));

                            // Inform async call manager about failure returns
                            pStubAsync->MarkError(hr);
                        }
                    }
                }
            }
            // Pass real HRESULT to StubInvoke
            *pAsyncHr = hr;
            hr = S_OK;

            // Release async call object
            pStubAsync->Release();
        }
        else
        {
            hr = CO_E_NOT_SUPPORTED; //Force Async call not supported
            if(!(pIPIDEntry->dwFlags & IPIDF_TRIED_ASYNC))
            {
                // Sanity check
                Win4Assert(pStubAsync == NULL);
                pIPIDEntry->dwFlags |= IPIDF_TRIED_ASYNC;
            }
        }
    }

    return hr;
}


/***************************************************************************/
#if DBG == 1
DWORD AppInvoke_break = 0;
DWORD AppInvoke_count = 0;
#endif

HRESULT StubInvoke(RPCOLEMESSAGE *pMsg, CStdIdentity *pStdID,
                   IRpcStubBuffer *pStub, IRpcChannelBuffer *pChnl,
                   IPIDEntry *pIPIDEntry, DWORD *pdwFault)
{
    ComDebOut((DEB_CHANNEL, "StubInvoke pMsg:%x pStub:%x pChnl:%x pIPIDEntry:%x pdwFault:%x\n",
               pMsg, pStub, pChnl, pIPIDEntry, pdwFault));
    ASSERT_LOCK_NOT_HELD(gComLock);

    REFIID riid = pMsg->reserved2[1] ? *MSG_TO_IIDPTR(pMsg) : GUID_NULL;

#if DBG==1
    // Output debug statements
    ComDebOut((DEB_CHANNEL, "StubInvoke on iid:%I, iMethod:%d\n", &riid, pMsg->iMethod));
    Win4Assert((riid != IID_AsyncIAdviseSink) && (riid != IID_AsyncIAdviseSink));

    // On a debug build, we are able to break on a call by serial number.
    // This isn't really 100% thread safe, but is still extremely useful
    // when debugging a problem.
    DWORD dwBreakCount = ++AppInvoke_count;
    ComDebOut((DEB_CHANNEL, "AppInvoke(0x%x) calling method 0x%x iid %I\n",
               dwBreakCount, pMsg->iMethod, &riid));
    if(AppInvoke_break == dwBreakCount)
    {
        DebugBreak();
    }
#endif

    //
    // if VISTA event logging is turned on, log the call event.
    //
    ULONG_PTR RpcValues[6];     // LogEventStubException has one more argument
    BOOL fLogEventIsActive = pIPIDEntry && LogEventIsActive();
    if(fLogEventIsActive)
    {
        RpcValues[0] = (ULONG_PTR) &pIPIDEntry->ipid;   // Target handle
        RpcValues[1] = (ULONG_PTR) pIPIDEntry->pOXIDEntry->GetMoxidPtr(); // Apartment ID
        RpcValues[2] = (ULONG_PTR) &pMsg;                   // CorrelationID
        RpcValues[3] = (ULONG_PTR) &riid;         // IID
        RpcValues[4] = (ULONG_PTR) pMsg->iMethod;           // Method index

        // Log event before call into server
        LogEventStubEnter(RpcValues);
    }

    // Try dispatching the call asynchronously
    HRESULT hrAsync = S_OK;
    HRESULT hr = AsyncStubInvoke(pMsg, riid, pStdID, pChnl, pStub,
                                 pIPIDEntry, pdwFault, &hrAsync);
    if(hr == CO_E_NOT_SUPPORTED)
    {
        // Dispatch synchronously
        hr = SyncStubInvoke(pMsg, riid,
                            pStdID ? pStdID->GetIDObject() : NULL,
                            pChnl, pStub, pdwFault);
    }
    else
    {
        //Assert that Async call was attempted
        Win4Assert((hr==S_OK));
        // Async call was attempted, use that HRESULT
        hr = hrAsync;
    }

    if(fLogEventIsActive)
    {
        // Log event after return from server
        if(hr == RPC_E_SERVERFAULT)
        {
            RpcValues[5] = (ULONG_PTR) *pdwFault;
            LogEventStubException(RpcValues);
        }
        else
        {
            LogEventStubLeave(RpcValues);
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "StubInvoke hr:%x dwFault:%x\n", hr, *pdwFault));
    return hr;
}


/***************************************************************************/
HRESULT ComInvoke( CMessageCall *pCall)
{
    ComDebOut((DEB_CHANNEL, "ComInvoke pCall:%x\n", pCall));
    HRESULT hr = RPC_E_SERVER_DIED_DNE;
    IPIDEntry *pIPIDEntry = NULL;
    OXIDEntry *pOXIDEntry = NULL;
    HANDLE hSxsActCtx = INVALID_HANDLE_VALUE;
    ULONG_PTR ulActCtxCookie = INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE;

#if DBG == 1
    // Catch exceptions that might keep the lock.
    _try
      {
#endif
          ASSERT_LOCK_NOT_HELD(gIPIDLock);
          LOCK(gIPIDLock);

          // Find the IPID entry.  Fail if the IPID or the OXID are not ready.
          // If OK to dispatch, the OXIDEntry returned is AddRef'd.
          hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIPIDEntry, &pOXIDEntry);
          if (SUCCEEDED(hr))
          {
              // Dispatch the call. This subroutine releases the lock
              // before returning.

              // Get and activate sxs context if we're activating in-process
              if ((hSxsActCtx = pCall->GetSxsActCtx()) != INVALID_HANDLE_VALUE)
              {
                  if (!ActivateActCtx(hSxsActCtx, &ulActCtxCookie))
                  {
                      hr = HRESULT_FROM_WIN32(GetLastError());
                      if (SUCCEEDED(hr))
                          hr = E_FAIL;
                  }
              }

              if (SUCCEEDED(hr))
              {
                  hr = ComInvokeWithLockAndIPID(pCall, pIPIDEntry);
                  ASSERT_LOCK_NOT_HELD(gIPIDLock);

                  if (ulActCtxCookie != INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE)
                      DeactivateActCtx(0, ulActCtxCookie);
              }
              else
              {
                  // Need to unlock the lock ourselves.
                  UNLOCK(gIPIDLock);
                  ASSERT_LOCK_NOT_HELD(gIPIDLock);
              }

              // release the OXIDEntry.
              pOXIDEntry->DecRefCnt();
          }
          else
          {
              UNLOCK(gIPIDLock);
              ASSERT_LOCK_NOT_HELD(gIPIDLock);

              Win4Assert(hr == RPC_E_DISCONNECTED ||
                         hr == E_NOINTERFACE);
          }

          // Catch exceptions that might keep the lock.
#if DBG == 1
      }
    _except( ComInvokeExceptionFilter(GetExceptionCode(),
                                      GetExceptionInformation()) )
      {
      }
#endif

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_CHANNEL, "ComInvoke pCall:%x hr:%x\n", pCall, hr));
    return hr;
}

/***************************************************************************/
HRESULT ComInvokeWithLockAndIPID(CMessageCall *pCall, IPIDEntry *pIPIDEntry)
{
    ComDebOut((DEB_CHANNEL, "ComInvokeWithLockAndIPID call:%x header:%x\n",
               pCall, pCall->message.Buffer));
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(pIPIDEntry);

    // while still holding gIPIDLock, do the bare minimum amount of work
    // necessary to keep the object and apartment alive, then release the
    // lock and go on to do the rest of the work.

    // Ensure TLS is intialized, as EnterNTA requires it.
    HRESULT result;
    COleTls tls(result);
    if (FAILED(result))
    {
        UNLOCK(gIPIDLock);
        return CO_E_INIT_TLS;
    }

    // Tell the OXID there is one more incoming call. This keeps the OXID
    // object alive during the call.
    OXIDEntry *pOXIDEntry = pIPIDEntry->pOXIDEntry;
    pOXIDEntry->IncCallCnt();

    // If the server is in the NA, switch the thread to the NA.
    BOOL fSwitchedToNA = FALSE;
    BOOL fSwitchedFromNA = FALSE;
    CObjectContext *pDefaultCtx = NULL;
    CObjectContext *pSavedCtx = NULL;
    if (pOXIDEntry->IsNTAServer())
    {
        if (!IsThreadInNTA())
        {
            pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
            fSwitchedToNA = TRUE;
        }
    }
    else
    {
        if (IsThreadInNTA())
        {
            pDefaultCtx = IsSTAThread() ? tls->pNativeCtx : g_pMTAEmptyCtx;
            pSavedCtx = LeaveNTA(pDefaultCtx);
            fSwitchedFromNA = TRUE;
        }
    }

    // Lock StdID
    CRpcChannelBuffer *pChannel = pIPIDEntry->pChnl;
    Win4Assert( pChannel != NULL && pChannel->_pStdId != NULL );
    pChannel->_pStdId->LockServer();

    // We don't need the lock anymore, so release it.
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Ensure this thread has a causality ID. Do this before
    // CServerSecurity has a chance to autoimpersonate because UUIDCreate
    // can access the registry.
    if (!(tls->dwFlags & OLETLS_UUIDINITIALIZED))
    {
        RPC_STATUS st = UuidCreate(&tls->LogicalThreadId);
        Win4Assert(SUCCEEDED(st));
        tls->dwFlags |= OLETLS_UUIDINITIALIZED;
    }

    // Increment per thread outstanding call count
    ++tls->cCalls;

    RPCOLEMESSAGE *pMessage = &pCall->message;

    // Create a security object which may do auto impersonation now.
    result = E_OUTOFMEMORY;
    CServerSecurity *security = new CServerSecurity(pCall, pMessage->reserved1, &result);
    if(FAILED(result))
    {
        if (security)
            security->RestoreSecurity( TRUE );
    }
    else
    {
        WireThis   *pInb = (WireThis *) pMessage->Buffer;
        LocalThis  *localb;
        BOOL fSetDispatchThread = FALSE;

        // Save the original threadid & copy in the new one.
        UUID saved_threadid   = tls->LogicalThreadId;
        tls->LogicalThreadId  = pInb->c.cid;
        ComDebOut((DEB_CALLCONT, "ComInvoke: LogicalThreads Old:%I New:%I\n",
                   &saved_threadid, &tls->LogicalThreadId));

        // Ensure dispatch threads are marked
        if(!(tls->dwFlags & (OLETLS_APARTMENTTHREADED |
                             OLETLS_MULTITHREADED |
                             OLETLS_DISPATCHTHREAD)))
        {
            fSetDispatchThread = TRUE;
            tls->dwFlags |= OLETLS_DISPATCHTHREAD;
        }
        BOOL fDispThread = (tls->dwFlags & OLETLS_DISPATCHTHREAD);
        Win4Assert(!fDispThread || tls->cComInits==0);

        // Save the security context in TLS.
        IUnknown *save_context = tls->pCallContext;
        tls->pCallContext = (IServerSecurity *) security;

        // See if the caller is allowed access.
        result = CheckAccess( pIPIDEntry, pCall );
        if (SUCCEEDED(result))
        {
            // Create a new context call object
            CCtxCall ctxCall(CTXCALLFLAG_SERVER, pMessage->dataRepresentation);
            pCall->SetServerCtxCall(&ctxCall);

            // Save the call info in TLS.
            CMessageCall *next_call = tls->pCallInfo;
            tls->pCallInfo          = pCall;

            // Store context call object in TLS
            CCtxCall *pCurCall = ctxCall.StoreInTLS(tls);

            // Call the channel hooks.  Set up as much TLS data as possible before
            // calling the hooks so they can access it.
            char *stub_data;

            pCall->hook.uCausality    = pInb->c.cid;
            pCall->hook.dwServerPid   = pIPIDEntry->pOXIDEntry->GetPid();
            pCall->hook.iMethod       = pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
            pCall->hook.pObject       = pIPIDEntry->pv;
            result = ServerNotify( (WireThis *) pMessage->Buffer,
                                   pMessage->cbBuffer,
                                   (void **) &stub_data,
                                   pMessage->dataRepresentation,
                                   pCall );

            // Revoke context call object from TLS
            ctxCall.RevokeFromTLS(tls, pCurCall);

            // Find the local header.
            if (pInb->c.flags & ORPCF_LOCAL)
            {
                localb     = (LocalThis *) stub_data;
                stub_data += sizeof( LocalThis );
            }
            else
                localb = NULL;

            // Set the caller TID.  This is needed by some interop code in order
            // to do focus management via tying queues together. We first save the
            // current one so we can restore later to deal with nested calls
            // correctly.
            DWORD TIDCallerSaved  = tls->dwTIDCaller;
            BOOL fLocalSaved      = tls->dwFlags & OLETLS_LOCALTID;
            tls->dwTIDCaller      = localb != NULL ? localb->client_thread : 0;

            // Set the process local flag in TLS.
            if (pCall->ProcessLocal())
                tls->dwFlags |= OLETLS_LOCALTID;
            else
                tls->dwFlags &= ~OLETLS_LOCALTID;

            // Continue dispatching the call.
            if (result == S_OK)
            {
                result = AppInvoke( pCall, pChannel,
                                    (IRpcStubBuffer *) pIPIDEntry->pStub,
                                    pIPIDEntry->pv, stub_data, pIPIDEntry, localb );
            }

            // Restore the call info, dest context and thread id.
            tls->pCallInfo       = next_call;
            tls->dwTIDCaller     = TIDCallerSaved;

            if (fLocalSaved)
                tls->dwFlags |= OLETLS_LOCALTID;
            else
                tls->dwFlags &= ~OLETLS_LOCALTID;
        }

        // Restore the original thread id, security context and revert any
        // outstanding impersonation.
        tls->pCallContext    = save_context;
        security->RestoreSecurity( !pCall->ServerAsync() );
        tls->LogicalThreadId = saved_threadid;

        // Turn off dispatch bit if we set it
        if (fSetDispatchThread)
            tls->dwFlags &= ~OLETLS_DISPATCHTHREAD;

        // Ensure that cancellation is turned off
        // for any pooled threads.
        if (fDispThread)
            tls->cCallCancellation = 0;
    }

    // Unlock StdID
    pChannel->_pStdId->UnlockServer();

    // If we entered or left the NA before dispatching, switch the thread back
    // to its the previous state.
    if (fSwitchedToNA == TRUE)
    {
        pSavedCtx = LeaveNTA(pSavedCtx);
        Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
    }
    else if (fSwitchedFromNA == TRUE)
    {
        pSavedCtx = EnterNTA(pSavedCtx);
        Win4Assert(pSavedCtx == pDefaultCtx);
    }

    // Decrement the call count. Do this *after* calling UnLockServer
    // so the other thread does not blow away the server.
    pOXIDEntry->DecCallCnt();

    // Decrement per thread outstanding call count
    --tls->cCalls;
    Win4Assert((LONG) tls->cCalls >= 0);

    // Clear any pending uninit
    if((tls->dwFlags & OLETLS_PENDINGUNINIT) && (tls->cCalls == 0))
        CoUninitialize();

    if (security != NULL)
    {
        security->Release();
    }

    ComDebOut((DEB_CHANNEL, "ComInvokeWithLockAndIPID pCall:%x hr:%x\n", pCall, result));
    return result;
}


/***************************************************************************/
void CRpcChannelBuffer::UpdateCopy(CRpcChannelBuffer *chan)
{
    Win4Assert( !(state & server_cs) );

    chan->state       = proxy_cs | (state & ~client_cs);

    return;
}

/***************************************************************************

     Method:       CRpcChannelBuffer::GetHandle

     Synopsis:     Pick a handle to use for the call.

     Description:

          If the channel is using standard security, use either the default
     channel handle or the saved channel handle in the OXID.  If the channel
     is using custom security, use the custom channel handle.

     Addref the handle returned because the caller will release it.

     _hRpcDefault starts out NULL and changes once to the default handle.
     There after it does not change until the channel is released.  Thus
     _hRpcDefault can be accessed without holding the lock.

     _hRpcCustom starts out NULL and changes each time someone calls
     SetBlanket.  In a multithreaded apartment, it can change at any\
     moment so take the lock when accessing it.

***************************************************************************/
HRESULT CRpcChannelBuffer::GetHandle( CChannelHandle **ppHandle, BOOL fSave )
{
    HRESULT         result  = S_OK;
    BOOL            fLock   = _pRpcCustom != NULL;
    CChannelHandle *pHandle;

    // If there is a custom channel handle, take the lock because it
    // might be switched while we access it.
    if (fLock)
    {
        LOCK(gComLock);
        pHandle = _pRpcCustom;
    }
    else
        pHandle = _pRpcDefault;

    if (pHandle == NULL)
    {
        // this channel doesn't have a handle, figure out how to get one.
        if ((gCapabilities & EOAC_STATIC_CLOAKING) == 0 && !ProcessLocal())
        {
            // process remote call with no static cloaking, use the OXID handle.
            if (_pOXIDEntry->_pRpc == NULL)
            {
                // no handle on the OXIDEntry yet, create it.
                result = CreateHandle(_pOXIDEntry, state, &pHandle);

                if (InterlockedCompareExchangePointer((void **)&_pOXIDEntry->_pRpc,
                                                      pHandle, NULL) != NULL)
                {
                    // another thread created it first, release the one we just
                    // created and use the other one.
                    pHandle->Release();
                }
            }

            pHandle = _pOXIDEntry->_pRpc;

            // Going to be handing this one back, AddRef it now.
            if (pHandle)
                pHandle->AddRef();
        }
        else
        {
            // process local call or static cloaking, use one handle per proxy.
            result = CreateHandle( _pOXIDEntry, state, &pHandle );

            // Don't save handles created by QueryBlanket since they have
            // the wrong identity.
            if (fSave && SUCCEEDED(result))
            {
                if (InterlockedCompareExchangePointer((void **)&_pRpcDefault,
                                                      pHandle, NULL) != NULL)
                {
                    // another thread created it first, release the one we just
                    // created and use the other one.
                    pHandle->Release();
                    pHandle = _pRpcDefault;
                }

                // Going to be handing this back, AddRef it now.
                if (pHandle)
                    pHandle->AddRef();
            }
            else
            {
                // There's no need to do anything here-- we'll just be
                // giving away the reference we created. (As opposed to
                // putting another reference on the thread.)
                // fAddRef = FALSE;
            }
        }
    }
    else
    {
        pHandle->AddRef();
    }

    if (pHandle != NULL)
    {
        // For dynamic impersonation, get a handle with the current token.
        if (pHandle->_lAuthn != RPC_C_AUTHN_LEVEL_NONE &&
            (pHandle->_eState & (dynamic_cloaking_hs | process_local_hs)) ==
            (dynamic_cloaking_hs | process_local_hs))
        {
            // Save the original handle so it doesn't float away.
            CChannelHandle *pOrig = pHandle;
            // Create a new channel handle...
            pHandle = new CChannelHandle( pOrig, state, &result );
            // Release the original one.
            pOrig->Release();

            if (pHandle == NULL)
                result = E_OUTOFMEMORY;
            else if (FAILED(result))
            {
                pHandle->Release();
                pHandle = NULL;
            }
        }
    }

    // If there is a custom channel handle, the lock was held for this function.
    if (fLock)
        UNLOCK(gComLock);
    *ppHandle = pHandle;

    return result;
}

/***************************************************************************/
HRESULT CreateHandle( OXIDEntry *pOXIDEntry, DWORD eChannel,
                      CChannelHandle **ppHandle )
{
    ASSERT_LOCK_DONTCARE(gComLock);
    HRESULT         result  = S_OK;
    unsigned long     ulMarshaledTargetInfoLength = 0;
    unsigned char*    pMarshaledTargetInfo = NULL;
    WCHAR             *pTargetName = NULL;
    RPC_STATUS        sc;

    // Create a handle.
    CChannelHandle *pHandle = new CChannelHandle(gAuthnLevel,  gImpLevel,
                                                 gCapabilities, pOXIDEntry,
                                                 eChannel, &result );
    if (pHandle == NULL)
    {
        result = E_OUTOFMEMORY;
    }
    else if (SUCCEEDED(result) && (pHandle->_eState & process_local_hs) == 0)
    {
        // Setup the default security.
        SBlanket        sBlanket;
        HANDLE          hThread = NULL;
        DWORD           lSvcIndex;

        LOCK(gComLock);

        // Compute the default authentication service if unknown,
        // otherwise find the specified one in the bindings
        if (pOXIDEntry->GetAuthnSvc() == RPC_C_AUTHN_DEFAULT)
            lSvcIndex = DefaultAuthnSvc(pOXIDEntry);
        else
            lSvcIndex = GetAuthnSvcIndexForBinding (pOXIDEntry->GetAuthnSvc(),
                                                    pOXIDEntry->GetBinding());
        if ((!pOXIDEntry->IsOnLocalMachine()) && (lSvcIndex >= pOXIDEntry->GetBinding()->wNumEntries)) 
        {
           lSvcIndex = GetFirstAuthnSvcIndex(pOXIDEntry->GetBinding());
        }

        // Compute the default security blanket.
        sBlanket._lAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
        result = DefaultBlanket( lSvcIndex, pOXIDEntry, &sBlanket );

        // Only set security for secure or cross process binding handles.
        if (SUCCEEDED(result) &&
            (sBlanket._lAuthnLevel != RPC_C_AUTHN_LEVEL_NONE
             || (pHandle->_eState & machine_local_hs)
            ))
        {
            // If the default authentication level is secure and the
            // server is on another machine, there must be a matching
            // security provider.
            if (pOXIDEntry->GetAuthnSvc() >= pOXIDEntry->GetBinding()->wNumEntries &&
                (!pOXIDEntry->IsOnLocalMachine()))
                result = RPC_E_NO_GOOD_SECURITY_PACKAGES;

            // Remove the thread token for cross machine, no cloaking.
            else if ((pHandle->_eState & any_cloaking_hs) == 0)
                SuspendImpersonate( &hThread );
            

            // Set the default security on the binding handle.
            if (SUCCEEDED(result))
            {
                // Enable mutual authentication for machine local calls.
                if (sBlanket._pPrincipal != NULL)
                    sBlanket._sQos.Capabilities |= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;

                // RPC wants authentication service winnt for
                // unsecure same machine calls.
                if (sBlanket._lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE &&
                    sBlanket._lAuthnSvc   == RPC_C_AUTHN_NONE       &&
                    (pHandle->_eState & machine_local_hs))
                    sBlanket._lAuthnSvc = RPC_C_AUTHN_WINNT;

                pOXIDEntry->GetMarshaledTargetInfo(&ulMarshaledTargetInfoLength, &pMarshaledTargetInfo);
                if (ulMarshaledTargetInfoLength && pMarshaledTargetInfo && sBlanket._pPrincipal)
                {
                   DWORD dwLen = lstrlenW(sBlanket._pPrincipal)*sizeof(WCHAR)+ ulMarshaledTargetInfoLength + sizeof(WCHAR);
                   pTargetName = (WCHAR *)MIDL_user_allocate(dwLen);
                   if (pTargetName) 
                   {
                      memset(pTargetName,0,dwLen);
                      memcpy(pTargetName,sBlanket._pPrincipal,lstrlenW(sBlanket._pPrincipal)*sizeof(WCHAR));
                      memcpy(pTargetName+lstrlenW(sBlanket._pPrincipal), pMarshaledTargetInfo, ulMarshaledTargetInfoLength);
                      sBlanket._pPrincipal = pTargetName;
                   }
                   else
                      result = E_OUTOFMEMORY;
                }
                if (SUCCEEDED(result))
                {
                   sc = RpcBindingSetAuthInfoExW(
                       pHandle->_hRpc,
                       sBlanket._pPrincipal,
                       sBlanket._lAuthnLevel,
                       sBlanket._lAuthnSvc,
                       sBlanket._pAuthId,
                       sBlanket._lAuthzSvc,
                       &sBlanket._sQos );
                   if (pTargetName) 
                   {
                      MIDL_user_free(pTargetName);
                   }
                   if (sc != RPC_S_OK)
                       result = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
                }
            }

            // Restore the thread token.
            ResumeImpersonate( hThread );
        }

        UNLOCK(gComLock);
    }

    // If something failed, release the binding handle.
    if (FAILED(result) && pHandle != NULL)
    {
        pHandle->Release();
        pHandle = NULL;
    }

    *ppHandle = pHandle;

    ASSERT_LOCK_DONTCARE(gComLock);
    return result;
}

/***************************************************************************/
HRESULT CRpcChannelBuffer::InitClientSideHandle( CChannelHandle **pHandle )
{
    if (_pInterfaceInfo == NULL)
    {
        // Lookup the interface info. This cant fail.
        void *pInterfaceInfo = gRIFTbl.GetClientInterfaceInfo(_pIPIDEntry->iid);
        InterlockedCompareExchangePointer((void **)&_pInterfaceInfo,
                                          pInterfaceInfo, NULL);
    }

    return GetHandle( pHandle, TRUE );
}

/***************************************************************************/
CRpcChannelBuffer::CRpcChannelBuffer(CStdIdentity *standard_identity,
                                     OXIDEntry       *pOXIDEntry,
                                     DWORD            eState )
{
    ComDebOut((DEB_MARSHAL, "CRpcChannelBuffer %s Created this:%x pOXID:%x\n",
               (eState & client_cs) ? "CLIENT" : "SERVER", this, pOXIDEntry));

    DWORD dwDestCtx;

    // Fill in the easy fields first.
    _cRefs         = 1;
    _pStdId        = standard_identity;
    _pRpcDefault   = NULL;
    _pRpcCustom    = NULL;
    _pOXIDEntry    = pOXIDEntry;
    _pIPIDEntry    = NULL;
    _pInterfaceInfo= NULL;
    state          = eState;

    // Set process local flags.
    if (_pOXIDEntry->GetPid() == GetCurrentProcessId())
    {
        state |= process_local_cs;

        // If the object is in the NTA, mark the channel so it knows to
        // dispatch calls on the same thread.
        if (_pOXIDEntry->IsNTAServer())
        {
            ComDebOut((DEB_MARSHAL, "CRpcChannelBuffer %x marked NEUTRAL\n",this));
            state |= neutral_cs;
        }
    }

    if (state & (client_cs | proxy_cs))
    {
        // Determine the destination context.
        if (_pOXIDEntry->IsOnLocalMachine())
            if (!IsWOWThread() && (state & process_local_cs))
                dwDestCtx = MSHCTX_INPROC;
            else
                dwDestCtx = MSHCTX_LOCAL;
        else
            dwDestCtx = MSHCTX_DIFFERENTMACHINE;
    }
    else
    {
        // On the server side, the destination context isn't known
        // until a call arrives.
        dwDestCtx = -1;
    }

    // Initialize
    _destObj.SetDestCtx(dwDestCtx);
    _destObj.SetComVersion(_pOXIDEntry->GetComVersion());
}

/***************************************************************************/
CRpcChannelBuffer::~CRpcChannelBuffer()
{
    ComDebOut((DEB_MARSHAL, "CRpcChannelBuffer %s Deleted this:%x\n",
               Server() ? "SERVER" : "CLIENT", this));

    if (_pRpcDefault != NULL)
        _pRpcDefault->Release();
    if (_pRpcCustom != NULL)
        _pRpcCustom->Release();
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::FreeBuffer( RPCOLEMESSAGE *pMessage )
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    AssertValid( FALSE, TRUE );

    if (pMessage->Buffer == NULL)
        return S_OK;

    CMessageCall *pCall = (CMessageCall *) pMessage->reserved1;
    Win4Assert( pCall );
    Win4Assert( pCall->_pHeader );
    Win4Assert( IsClientSide() );

    // Free the buffer.
    if(pCall->ProcessLocal())
    {
        PrivMemFree( pCall->_pHeader );
    }
    else
    {
        pMessage->Buffer = pCall->_pHeader;
        I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
    }
    pMessage->Buffer = NULL;

    // Reset header as it has been freed
    pCall->_pHeader = NULL;

    // Release the AddRef we did earlier. Note that we can't do this until
    // after I_RpcFreeBuffer since it may release a binding handle that
    // I_RpcFreeBuffer needs.
    if (pCall->Locked())
        _pStdId->UnlockClient();

    pMessage->reserved1 = NULL;
#ifdef _WIN64
    ClearNDRSyntaxNegotiated();
#endif
    // Inform call object about call completion
    pCall->CallFinished();
    pCall->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetBuffer
//
//  Synopsis:   Calls ClientGetBuffer or ServerGetBuffer
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetBuffer( RPCOLEMESSAGE *pMessage,
                                           REFIID riid )
{
    gOXIDTbl.ValidateOXID();
    if (Proxy())
        return ClientGetBuffer( pMessage, riid );
    else
        return ServerGetBuffer( pMessage, riid );
}
#ifdef _WIN64
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::InitCallObject
//
//  Synopsis:   Common initialization for both ClientGetBuffer() and
//              NegotiateSyntax ()
//
//  History:    10-Jan-2000   Sajia  Created
//
//-------------------------------------------------------------------------

HRESULT CRpcChannelBuffer::InitCallObject( RPCOLEMESSAGE *pMessage,
                                           CALLCATEGORY   *pcallcat,
                                           DWORD dwCase,
                                           CChannelHandle **ppHandle)
{


    RPC_STATUS      status;
    CMessageCall   *pCall      = (CMessageCall *) pMessage->reserved1;

    // pCall should be NULL here.
    Win4Assert(!pCall);

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    *pcallcat    = CALLCAT_SYNCHRONOUS;
    // Initialize Buffer to NULL
    pMessage->Buffer = NULL;

    // Don't allow message calls.
    if (pMessage->rpcFlags & RPCFLG_MESSAGE)
        return E_NOTIMPL;

    // Determine if the call category is sync, async, or input sync.
    if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
    {
        *pcallcat = CALLCAT_ASYNC;
    }
    else if (pMessage->rpcFlags & RPCFLG_ASYNCHRONOUS)
    {
        Win4Assert( !"The old async flag is not supported" );
        return E_NOTIMPL;
    }
    else if (pMessage->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
    {
        *pcallcat = CALLCAT_INPUTSYNC;
    }
    // Note - RPC requires that the 16th bit of the proc num be set because
    // we use the rpcFlags field of the RPC_MESSAGE struct.
    pMessage->iMethod |= RPC_FLAGS_VALID_BIT;

    // Determine the flags for the call.
    if (state & process_local_cs)
    {
        pMessage->rpcFlags |= RPCFLG_LOCAL_CALL;
    }

    status = InitClientSideHandle(ppHandle);
    if (status != S_OK)
    {
        return status;
    }

    // Initialize transfet syntax and interface info
    if (GET_BUFFER_AT == dwCase) {
        // RPC will not negotiate for proxies that support NDR64 only.
        // In this case, the proxy will supply the RpcInterfaceInformation
        // in RPC_MESSAGE and we use it.
        // RPC will not negotiate for proxies that support NDR20 only.
        // In this case, the RpcInterfaceInformation in RPC_MESSAGE is
        // NULL and we use the fake one.
        if (!pMessage->reserved2[1]) {
            pMessage->reserved2[0]  = 0;
            pMessage->reserved2[1]  = _pInterfaceInfo;
        }
    }
    BOOL fAsyncCallObj = (pMessage->rpcFlags & RPC_BUFFER_ASYNC ||
                          (IsSTAThread() && !ProcessLocal()) ||
                          (IsMTAThread() && (tls->cCallCancellation > 0) && MachineLocal() && !ProcessLocal())
    ) ? TRUE : FALSE;
    status = GetCallObject(fAsyncCallObj, &pCall);

    if(SUCCEEDED(status))
    {
        status = pCall->InitCallObject(*pcallcat, pMessage, state, _pIPIDEntry->ipid,
                                       _destObj.GetDestCtx(), _destObj.GetComVersion(),
                                       *ppHandle);
        if(FAILED(status))
            pCall->Release();
    }

    // Check for failure and cleanup
    if(FAILED(status))
    {
        (*ppHandle)->Release();
        return status;
    }
    pMessage->reserved1  = pCall;
    return S_OK;
}
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::NegotiateSyntax
//
//  Synopsis:   Called by the proxy to negotiate NDR Transfer
//              Syntax
//
//  History:    10-Jan-2000   Sajia  Created
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::NegotiateSyntax( RPCOLEMESSAGE *pMessage)
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    CALLCATEGORY   callcat;
    CChannelHandle *pHandle;
    BOOL            resume     = FALSE;
    HANDLE          thread = NULL;


    // Sanity check
    Win4Assert(pMessage->reserved1 == NULL);


    // Create a call object and an RPC binding handle wrapper object
    RPC_STATUS status = InitCallObject(pMessage, &callcat, SYNTAX_NEGOTIATE_AT, &pHandle);
    if (status != RPC_S_OK)
        return MAKE_WIN32(status);

    // For process local calls,  return S_FALSE so proxy
    // knows it is a local call.
    if (state & process_local_cs)
    {
        SetNDRSyntaxNegotiated();
        return S_FALSE;
    }

    CMessageCall   *pCall = (CMessageCall *) pMessage->reserved1;
    Win4Assert(pCall);
    if (pHandle->_fFirstCall) {
        pHandle->AdjustToken( SYNTAX_NEGOTIATE_AT, &resume, &thread );
    }

    // call RPC to do Syntax Negotiation
    status = I_RpcNegotiateTransferSyntax ((RPC_MESSAGE *) &pCall->message);

    pHandle->RestoreToken( resume, thread );
    pHandle->Release();
    if (status != RPC_S_OK)
    {
        // For connection oriented protocols, I_RpcNegotiateTransferSyntax establishes
        // connection with the server process. Use its return value to
        // update connection status maintained by standard identity
        if(status == RPC_S_SERVER_UNAVAILABLE)
            _pStdId->SetConnectionStatus(MAKE_WIN32(status));

        pMessage->cbBuffer  = 0;
        pMessage->Buffer = NULL;
        pMessage->reserved1 = NULL;

        // Mark the call as finished
        pCall->CallFinished();
        pCall->Release();
        return MAKE_WIN32( status );
    }

    // copy back the negotiated syntax ID so that the proxy can
    // use it
    ((PRPC_SYNTAX_IDENTIFIER)(pMessage->reserved2))->SyntaxGUID =
      ((PRPC_SYNTAX_IDENTIFIER)(pCall->message.reserved2))->SyntaxGUID;

    // Mark the channel as negotiated, so that the GetBuffer stage knows
    SetNDRSyntaxNegotiated();
    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::ClientGetBuffer
//
//  Synopsis:   Gets a buffer and sets up client side stuff
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::ClientGetBuffer( RPCOLEMESSAGE *pMessage,
                                            REFIID riid )
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    CALLCATEGORY   callcat = CALLCAT_SYNCHRONOUS;
    RPC_STATUS      status;
    ULONG           debug_size;
    ULONG           num_extent;
    WireThis       *pInb;
    LocalThis      *localb;
    IID            *logical_thread;
    CMessageCall   *pCall      = (CMessageCall *) pMessage->reserved1;
    BOOL            resume     = FALSE;
    HANDLE          thread = NULL;
    CChannelHandle *pHandle;
    BOOL            old_async  = FALSE;


    Win4Assert(Proxy());
    AssertValid(FALSE, TRUE);

    logical_thread = (GUID *)&GUID_NULL;

    // Don't allow remote calls if DCOM is disabled.
    if (gDisableDCOM && _destObj.GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
        return RPC_E_REMOTE_DISABLED;

    if (!pCall)
    {
        // If we don't have a call object here, then go get one
        // This means that the channel has not been called to
        // negotiate NDR syntax (ie; legacy proxy).
        Win4Assert(!IsNDRSyntaxNegotiated());
        status = InitCallObject(pMessage, &callcat, GET_BUFFER_AT, &pHandle);
        if (RPC_S_OK != status)
            return MAKE_WIN32( status );
        else
        {
            pCall = (CMessageCall *) pMessage->reserved1;
            Win4Assert(pCall);
        }
    }
    else
    {
        // If we get here, this means that the channel has been called to
        // negotiate NDR syntax (ie; new proxy).We need to initialize
        // some fields in our copy of RPCOLEMESSAGE struct
        Win4Assert(IsNDRSyntaxNegotiated());
        pHandle = pCall->_pHandle;
        pHandle->AddRef();
        callcat = pCall->GetCallCategory();
        pCall->message.cbBuffer = pMessage->cbBuffer;
        //
        //  Should not set flag on the code path involving negotiation.
        //       pCall->message.iMethod |= RPC_FLAGS_VALID_BIT;
        //
        pCall->message.dataRepresentation = pMessage->dataRepresentation;
        ((PRPC_SYNTAX_IDENTIFIER)(pCall->message.reserved2))->SyntaxGUID =
          ((PRPC_SYNTAX_IDENTIFIER)(pMessage->reserved2))->SyntaxGUID;
    }
    if (CALLCAT_ASYNC == callcat)
    {
        // Set the callcat async only for these 2 special interfaces.
        if (riid == IID_AsyncIAdviseSink || riid == IID_AsyncIAdviseSink2)
        {
            // Calls from MTA apartments are not old style async.
            old_async = IsSTAThread();
        
            // these 2 interface are now truly async. But 
            // we need to keep the CID of the caller (if any)
            // otherwise we break casuality
            logical_thread = TLSGetLogicalThread();
            if (logical_thread == NULL)
            {
                return RPC_E_OUT_OF_RESOURCES;
            }
        }
    }
    else
    {
        logical_thread = TLSGetLogicalThread();
        if (logical_thread == NULL)
        {
            return RPC_E_OUT_OF_RESOURCES;
        }
    }

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    //Set cancel enabled for call object
    if ((tls->cCallCancellation > 0) || (pMessage->rpcFlags & RPC_BUFFER_ASYNC))
        pCall->SetCancelEnabled();


    // Fill in the hook data.
    pCall->hook.dwServerPid   = _pOXIDEntry->GetPid();
    pCall->hook.iMethod       = pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
    pCall->hook.pObject       = NULL;

    // Determine the causality id.
    if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) && 
        (riid != IID_AsyncIAdviseSink && 
         riid != IID_AsyncIAdviseSink2))
    {
        RPC_STATUS st = UuidCreate( &pCall->hook.uCausality );
        Win4Assert(SUCCEEDED(st));
    }
    else
    {
        Win4Assert(logical_thread != (GUID *)&GUID_NULL);
        pCall->hook.uCausality = *logical_thread;
    }

    // Find out if we need hook data.
    debug_size = ClientGetSize( &num_extent, pCall );
    pCall->message.cbBuffer += SIZENEEDED_ORPCTHIS(
        _pOXIDEntry->IsOnLocalMachine(),
        debug_size );

    // Adjust the thread token to the one RPC needs to see for this case.
    if (!IsNDRSyntaxNegotiated() && pHandle->_fFirstCall)
        pHandle->AdjustToken( GET_BUFFER_AT, &resume, &thread );

    // Get a buffer.
    if ( (pMessage->rpcFlags & RPCFLG_LOCAL_CALL))
    {
        pCall->message.dataRepresentation = NDR_ASCII_CHAR | NDR_LOCAL_ENDIAN |
          NDR_IEEE_FLOAT;
        pCall->message.Buffer = PrivMemAlloc8( pCall->message.cbBuffer );
        Win4Assert(((ULONG_PTR)pCall->message.Buffer & 0x7) == 0 &&
                   "Buffer not aligned properly");

        if (pCall->message.Buffer == NULL)
            status = RPC_S_OUT_OF_MEMORY;
        else
            status = RPC_S_OK;
    }
    else
    {
        ComDebOut((DEB_CHANNEL, "->I_RpcGetBufferWithObject(pmsg=0x%x,ipid=%I)\n",
                   (RPC_MESSAGE *) &pCall->message, &_pIPIDEntry->ipid));
        status = I_RpcGetBufferWithObject((RPC_MESSAGE *) &pCall->message,
                                          &_pIPIDEntry->ipid);
        pCall->_hRpc = pCall->message.reserved1;
        ComDebOut((DEB_CHANNEL, "<-I_RpcGetBufferWithObject(status=0x%x)\n",status));
    }
    pCall->_pHeader  = pCall->message.Buffer;
    pMessage->Buffer = pCall->message.Buffer;

    // Restore the thread token.
    pHandle->RestoreToken( resume, thread );

    if (status != RPC_S_OK)
    {
        // For connection oriented protocols, I_RpcGetBuffer establishes
        // connection with the server process. Use its return value to
        // update connection status maintained by standard identity
        if(status == RPC_S_SERVER_UNAVAILABLE)
            _pStdId->SetConnectionStatus(MAKE_WIN32(status));

        // Cleanup.
        pCall->_pHeader  = NULL;
        pMessage->cbBuffer  = 0;
        pMessage->Buffer = NULL;
        pMessage->reserved1 = NULL;

        // Mark the call as finished
        pCall->CallFinished();
        pCall->Release();
        pHandle->Release();
        return MAKE_WIN32( status );
    }

    // Save the impersonation flag.
    if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
        ((CAsyncCall *) pCall)->_pRequestBuffer = pCall->message.Buffer;

    // Fill in the COM header.
    pMessage->reserved1  = pCall;
    pInb                 = (WireThis *) pCall->_pHeader;
    pInb->c.version      = _pOXIDEntry->GetComVersion();
    pInb->c.reserved1    = 0;
    pInb->c.cid          = pCall->hook.uCausality;

    // Set the private flag for local calls.
    if (_pOXIDEntry->IsOnLocalMachine())
        pInb->c.flags = ORPCF_LOCAL;
    else
        pInb->c.flags = ORPCF_NULL;

    // Fill in any hook data and adjust the buffer pointer.
    if (debug_size != 0)
    {
        pMessage->Buffer = FillBuffer( &pInb->d.ea, debug_size, num_extent,
                                       TRUE, pCall );
        pInb->c.unique = 0x77646853; // Any non-zero value.
    }
    else
    {
        pMessage->Buffer    = (void *) &pInb->d.ea;
        pInb->c.unique       = FALSE;
    }

    // Fill in the local header.
    if (_pOXIDEntry->IsOnLocalMachine())
    {
        localb                      = (LocalThis *) pMessage->Buffer;
        localb->client_thread       = GetCurrentApartmentId();
        localb->flags               = 0;
        pMessage->Buffer            = localb + 1;
        if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) &&
            (((riid == IID_AsyncIAdviseSink) || (riid == IID_AsyncIAdviseSink2))
             ? old_async
             : FALSE
            ))
        {
            // this is what will determine if the server considers this
            // an async call.
            pInb->c.flags |= ORPCF_ASYNC;
        }
        else if (callcat == CALLCAT_INPUTSYNC)
            pInb->c.flags |= ORPCF_INPUT_SYNC;

        // if the caller is using a non-NDR proxy, set a bit in the local
        // header flags so that server side stub knows which way to unmarshal
        // the parameters. This lets a 32bit server simultaneously service calls
        // from 16bit non-NDR clients and 32bit NDR clients, in particular, to
        // support OLE Automation.

        if (_pIPIDEntry->dwFlags & (IPIDF_NONNDRPROXY | IPIDF_NONNDRSTUB))
            localb->flags |= LOCALF_NONNDR;
        if (pHandle->_eState & dynamic_cloaking_hs)
            pInb->c.flags |= ORPCF_DYNAMIC_CLOAKING;
    }

    pHandle->Release();

    Win4Assert(pMessage->Buffer > (void *)0x010);
    ComDebOut((DEB_CALLCONT, "ClientGetBuffer: LogicalThreadId:%I\n",
               &pInb->c.cid));
    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}
#else
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::ClientGetBuffer
//
//  Synopsis:   Gets a buffer and sets up client side stuff
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::ClientGetBuffer( RPCOLEMESSAGE *pMessage,
                                            REFIID riid )
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPC_STATUS      status;
    CALLCATEGORY    callcat    = CALLCAT_SYNCHRONOUS;
    ULONG           debug_size;
    ULONG           num_extent;
    WireThis       *pInb;
    LocalThis      *localb;
    IID            *logical_thread;
    CMessageCall   *pCall      = (CMessageCall *) pMessage->reserved1;
    BOOL            resume     = FALSE;
    HANDLE          thread = NULL;
    CChannelHandle *pHandle;
    BOOL            old_async  = FALSE;
    DWORD           flags      = state;


    Win4Assert(Proxy());
    AssertValid(FALSE, TRUE);

    logical_thread = (GUID *)&GUID_NULL;

    // Initialize Buffer to NULL
    pMessage->Buffer = NULL;

    // Don't allow remote calls if DCOM is disabled.
    if (gDisableDCOM && _destObj.GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
        return RPC_E_REMOTE_DISABLED;

    // Don't allow message calls.
    if (pMessage->rpcFlags & RPCFLG_MESSAGE)
        return E_NOTIMPL;

    // Determine if the call category is sync, async, or input sync.
    if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
    {
        // Set the callcat async only for these 2 special interfaces.
        if (riid == IID_AsyncIAdviseSink || riid == IID_AsyncIAdviseSink2)
        {
            // Calls from MTA apartments are not old style async.
            old_async = IsSTAThread();
        
            // these 2 interface are now truly async. But 
            // we need to keep the CID of the caller (if any)
            // otherwise we break casuality
            
            logical_thread = TLSGetLogicalThread();
            if (logical_thread == NULL)
            {
                return RPC_E_OUT_OF_RESOURCES;
            }
        }

        callcat = CALLCAT_ASYNC;
    }
    else if (pMessage->rpcFlags & RPCFLG_ASYNCHRONOUS)
    {
        Win4Assert( !"The old async flag is not supported" );
        return E_NOTIMPL;
    }
    else
    {
        logical_thread = TLSGetLogicalThread();
        if (logical_thread == NULL)
        {
            return RPC_E_OUT_OF_RESOURCES;
        }
        if (pMessage->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
        {
            callcat = CALLCAT_INPUTSYNC;
        }
    }

    // Note - RPC requires that the 16th bit of the proc num be set because
    // we use the rpcFlags field of the RPC_MESSAGE struct.
    pMessage->iMethod |= RPC_FLAGS_VALID_BIT;

    // Determine the flags for the call.
    if (state & process_local_cs)
    {
        pMessage->rpcFlags |= RPCFLG_LOCAL_CALL;
    }

    // Complete the channel initialization if needed.
    status = InitClientSideHandle( &pHandle );
    if (status != S_OK)
    {
        return status;
    }

    // Initialize transfet syntax and interface info
    pMessage->reserved2[0]  = 0;
    pMessage->reserved2[1]  = _pInterfaceInfo;

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    // Allocate and initialize a call record.
    Win4Assert(pCall == NULL && "GetBuffer call was not NULL.");
    BOOL fAsyncCallObj = (pMessage->rpcFlags & RPC_BUFFER_ASYNC ||
                          (IsSTAThread() && !ProcessLocal()) ||
                          (IsMTAThread() && (tls->cCallCancellation > 0) && MachineLocal() && !ProcessLocal())
    ) ? TRUE : FALSE;
    status = GetCallObject(fAsyncCallObj, &pCall);

    if(SUCCEEDED(status))
    {
        status = pCall->InitCallObject(callcat, pMessage, flags, _pIPIDEntry->ipid,
                                       _destObj.GetDestCtx(), _destObj.GetComVersion(),
                                       pHandle);
        if(FAILED(status))
            pCall->Release();
    }

    // Check for failure and cleanup
    if(FAILED(status))
    {
        pHandle->Release();
        return status;
    }

    //Set cancel enabled for call object
    if ((tls->cCallCancellation > 0) || (pMessage->rpcFlags & RPC_BUFFER_ASYNC))
        pCall->SetCancelEnabled();


    // Fill in the hook data.
    pCall->hook.dwServerPid   = _pOXIDEntry->GetPid();
    pCall->hook.iMethod       = pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
    pCall->hook.pObject       = NULL;

    // Determine the causality id.
    if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) && 
        (riid != IID_AsyncIAdviseSink && 
         riid != IID_AsyncIAdviseSink2))
    {
        RPC_STATUS st = UuidCreate( &pCall->hook.uCausality );
        Win4Assert(SUCCEEDED(st));
    }
    else
    {
        Win4Assert(logical_thread != (GUID *)&GUID_NULL);
        pCall->hook.uCausality = *logical_thread;
    }

    // Find out if we need hook data.
    debug_size = ClientGetSize( &num_extent, pCall );
    pCall->message.cbBuffer += SIZENEEDED_ORPCTHIS(
        _pOXIDEntry->IsOnLocalMachine(),
        debug_size );

    // Adjust the thread token to the one RPC needs to see for this case.
    if (pHandle->_fFirstCall)
        pHandle->AdjustToken( GET_BUFFER_AT, &resume, &thread );

    // Get a buffer.
    if ( (pMessage->rpcFlags & RPCFLG_LOCAL_CALL))
    {
        pCall->message.dataRepresentation = NDR_ASCII_CHAR | NDR_LOCAL_ENDIAN |
          NDR_IEEE_FLOAT;
        pCall->message.Buffer = PrivMemAlloc8( pCall->message.cbBuffer );
        Win4Assert(((ULONG_PTR)pCall->message.Buffer & 0x7) == 0 &&
                   "Buffer not aligned properly");

        if (pCall->message.Buffer == NULL)
            status = RPC_S_OUT_OF_MEMORY;
        else
            status = RPC_S_OK;
    }
    else
    {
        ComDebOut((DEB_CHANNEL, "->I_RpcGetBufferWithObject(pmsg=0x%x,ipid=%I)\n",
                   (RPC_MESSAGE *) &pCall->message, &_pIPIDEntry->ipid));
        status = I_RpcGetBufferWithObject((RPC_MESSAGE *) &pCall->message,
                                          &_pIPIDEntry->ipid);
        pCall->_hRpc = pCall->message.reserved1;
        ComDebOut((DEB_CHANNEL, "<-I_RpcGetBufferWithObject(status=0x%x)\n",status));
    }
    pCall->_pHeader  = pCall->message.Buffer;
    pMessage->Buffer = pCall->message.Buffer;

    // Restore the thread token.
    pHandle->RestoreToken( resume, thread );

    if (status != RPC_S_OK)
    {
        // For connection oriented protocols, I_RpcGetBuffer establishes
        // connection with the server process. Use its return value to
        // update connection status maintained by standard identity
        if(status == RPC_S_SERVER_UNAVAILABLE)
            _pStdId->SetConnectionStatus(MAKE_WIN32(status));

        // Cleanup.
        pCall->_pHeader  = NULL;
        pMessage->cbBuffer  = 0;
        pMessage->Buffer = NULL;
        pMessage->reserved1 = NULL;

        // Mark the call as finished
        pCall->CallFinished();
        pCall->Release();
        pHandle->Release();
        return MAKE_WIN32( status );
    }

    // Save the impersonation flag.
    if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
        ((CAsyncCall *) pCall)->_pRequestBuffer = pCall->message.Buffer;

    // Fill in the COM header.
    pMessage->reserved1  = pCall;
    pInb                 = (WireThis *) pCall->_pHeader;
    pInb->c.version      = _pOXIDEntry->GetComVersion();
    pInb->c.reserved1    = 0;
    pInb->c.cid          = pCall->hook.uCausality;

    // Set the private flag for local calls.
    if (_pOXIDEntry->IsOnLocalMachine())
        pInb->c.flags = ORPCF_LOCAL;
    else
        pInb->c.flags = ORPCF_NULL;

    // Fill in any hook data and adjust the buffer pointer.
    if (debug_size != 0)
    {
        pMessage->Buffer = FillBuffer( &pInb->d.ea, debug_size, num_extent,
                                       TRUE, pCall );
        pInb->c.unique = 0x77646853; // Any non-zero value.
    }
    else
    {
        pMessage->Buffer    = (void *) &pInb->d.ea;
        pInb->c.unique       = FALSE;
    }

    // Fill in the local header.
    if (_pOXIDEntry->IsOnLocalMachine())
    {
        localb                      = (LocalThis *) pMessage->Buffer;
        localb->client_thread       = GetCurrentApartmentId();
        localb->flags               = 0;
        pMessage->Buffer            = localb + 1;
        if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) &&
            (((riid == IID_AsyncIAdviseSink) || (riid == IID_AsyncIAdviseSink2))
             ? old_async
             : FALSE
            ))
        {
            // this is what will determine if the server considers this
            // an async call.
            pInb->c.flags |= ORPCF_ASYNC;
        }
        else if (callcat == CALLCAT_INPUTSYNC)
            pInb->c.flags |= ORPCF_INPUT_SYNC;

        // if the caller is using a non-NDR proxy, set a bit in the local
        // header flags so that server side stub knows which way to unmarshal
        // the parameters. This lets a 32bit server simultaneously service calls
        // from 16bit non-NDR clients and 32bit NDR clients, in particular, to
        // support OLE Automation.

        if (_pIPIDEntry->dwFlags & (IPIDF_NONNDRPROXY | IPIDF_NONNDRSTUB))
            localb->flags |= LOCALF_NONNDR;
        if (pHandle->_eState & dynamic_cloaking_hs)
            pInb->c.flags |= ORPCF_DYNAMIC_CLOAKING;
    }

    pHandle->Release();

    Win4Assert(pMessage->Buffer > (void *)0x010);
    ComDebOut((DEB_CALLCONT, "ClientGetBuffer: LogicalThreadId:%I\n",
               &pInb->c.cid));
    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}
#endif
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::ServerGetBuffer
//
//  Synopsis:   Gets a buffer and sets up server side stuff
//
//  Note: For async calls the stub must use its own copy of the buffer.
//        Otherwise pMessage will equal pCall->message.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::ServerGetBuffer( RPCOLEMESSAGE *pMessage,
                                            REFIID riid )
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPC_STATUS            status;
    ULONG                 debug_size = 0;
    ULONG                 size;
    ULONG                 num_extent = 0;
    HRESULT               result     = S_OK;
    WireThis             *pInb;
    WireThat             *pOutb;
    CMessageCall         *pCall = (CMessageCall *) pMessage->reserved1;
    void                 *stub_data;
    DWORD                 orig_size = pMessage->cbBuffer;

    // Debug checks
    Win4Assert( Server() );
    Win4Assert( pCall != NULL );
    AssertValid(FALSE, TRUE);

    // Tell RPC that we have set the flags field.
    pCall->message.iMethod  |= RPC_FLAGS_VALID_BIT;

    // Find out if we need debug data.
    debug_size = ServerGetSize( &num_extent, pCall );

    // Compute the total size.
    size = pMessage->cbBuffer + SIZENEEDED_ORPCTHAT( debug_size );

    // Get a buffer.
    pCall->message.cbBuffer       = size;
    pCall->_dwErrorBufSize = size;
    
    if (pMessage->rpcFlags & RPCFLG_LOCAL_CALL)
    {
        // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE
        pMessage->dataRepresentation = 0x00 | 0x10 | 0x0000;
        pCall->message.Buffer         = PrivMemAlloc8( size );

        Win4Assert(((ULONG_PTR)pCall->message.Buffer & 0x7) == 0 &&
                   "Buffer not aligned properly");

        if (pCall->message.Buffer == NULL)
            status = RPC_S_OUT_OF_MEMORY;
        else
            status = RPC_S_OK;
    }
    else
    {
        ComDebOut((DEB_CHANNEL, "->I_RpcGetBuffer(pmsg=0x%x)\n",(RPC_MESSAGE *) &pCall->message));

        pCall->message.reserved1 = pCall->_hRpc;
        status = I_RpcGetBuffer((RPC_MESSAGE *) &pCall->message);

        ComDebOut((DEB_CHANNEL, "<-I_RpcGetBuffer(status=0x%x)\n",status));
        Win4Assert( pCall->_pHeader != pCall->message.Buffer ||
                    status != RPC_S_OK );
        pCall->message.reserved1 = pCall;
    }

    // If the buffer allocation failed, give up.
    pCall->_pHeader = pCall->message.Buffer;
    if (status != RPC_S_OK)
    {
        pMessage->cbBuffer = 0;
        pMessage->Buffer   = NULL;

        return MAKE_WIN32( status );
    }

    pMessage->cbBuffer = orig_size;
    // Fill in the outbound COM header.
    pOutb = (WireThat *) pCall->message.Buffer;
    if (pCall->GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
        pOutb->c.flags = ORPCF_NULL;
    else
        pOutb->c.flags = ORPCF_LOCAL;
    if (debug_size != 0)
    {
        stub_data = FillBuffer( &pOutb->d.ea, debug_size, num_extent, FALSE,
                                pCall );
        pOutb->c.unique  = 0x77646853; // Any non-zero value.
        pMessage->Buffer = stub_data;
    }
    else
    {
        pOutb->c.unique    = 0;
        pMessage->Buffer   = &pOutb->d.ea;
    }

    ComDebOut((DEB_CHANNEL, "ServerGetBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::GetProtocolVersion(DWORD *pdwVersion)
{
    AssertValid(FALSE, FALSE);

    if (pdwVersion == NULL)
        return E_INVALIDARG;

    COMVERSION version;
    if (state & (client_cs | proxy_cs))
    {
        // On the client side, get the version from the channel's OXIDEntry.
        version = _pOXIDEntry->GetComVersion();
    }
    else
    {
        // On the server side, get the version from TLS.
        COleTls tls;
        Win4Assert( tls->pCallInfo != NULL );
        version = ((CMessageCall *) tls->pCallInfo)->GetComVersion();
    }

    *pdwVersion = MAKELONG(version.MajorVersion, version.MinorVersion);
    ComDebOut((DEB_CHANNEL,"GetProtocolVersion ver:%x hr:%x\n",*pdwVersion,S_OK));
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::GetDestCtx( DWORD FAR* lpdwDestCtx,
                                            LPVOID FAR* lplpvDestCtx )
{
    AssertValid(FALSE, FALSE);

    DWORD dwDestCtx;
    IDestInfo *pDestInfo;

    if (state & (client_cs | proxy_cs))
    {
        // On the client side, get the destination context from the channel.
        dwDestCtx = _destObj.GetDestCtx();
        pDestInfo = (IDestInfo *) &_destObj;
    }
    else
    {
        // On the server side, get the destination context from TLS.
        COleTls tls;
        if (tls->pCallInfo != NULL)
        {
            dwDestCtx = tls->pCallInfo->GetDestCtx();
            pDestInfo = (IDestInfo *) &tls->pCallInfo->_destObj;
        }
        else
            return RPC_E_NO_CONTEXT;
    }

    *lpdwDestCtx = dwDestCtx;
    if (lplpvDestCtx != NULL)
    {
        if(dwDestCtx == MSHCTX_DIFFERENTMACHINE)
            *lplpvDestCtx = pDestInfo;
        else
            *lplpvDestCtx = NULL;
    }

    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::IsConnected( THIS )
{
    // must be on right thread because it is only called by proxies and stubs.
    AssertValid(FALSE, TRUE);

    // Server channels never know if they are connected.  The only time the
    // client side knows it is disconnected is after the standard identity
    // has disconnected the proxy from the channel.  In that case it doesn't
    // matter.
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    AssertValid(FALSE, FALSE);

    // IMarshal is queried more frequently than any other interface, so
    // check for that first.

    if (IsEqualIID(riid, IID_IMarshal))
    {
        *ppvObj = (IMarshal *) this;
    }
    else if (IsEqualIID(riid, IID_IUnknown)      ||
             IsEqualIID(riid, IID_IRpcChannelBuffer)  ||
             IsEqualIID(riid, IID_IRpcChannelBuffer2) ||
             IsEqualIID(riid, IID_IRpcChannelBuffer3))
    {
        *ppvObj = (IRpcChannelBuffer3 *) this;
    }
    else if (IsEqualIID(riid, IID_INonNDRStub) &&
             (Proxy()) && _pIPIDEntry &&
             (_pIPIDEntry->dwFlags & IPIDF_NONNDRSTUB))
    {
        // this interface is used to tell proxies whether the server side speaks
        // NDR or not. Returns S_OK if NOT NDR.
        *ppvObj = (IRpcChannelBuffer3 *) this;
    }
    else if (IsEqualIID(riid, IID_IAsyncRpcChannelBuffer))
    {
        *ppvObj = (IAsyncRpcChannelBuffer *) this;
    }
#ifdef _WIN64
    // Sajia - Support NDR Transfer Syntax Negotiation
    else if (IsEqualIID(riid, IID_IRpcSyntaxNegotiate))
    {
        *ppvObj = (IRpcSyntaxNegotiate *) this;
    }
#endif
    else if (IsEqualIID(riid, IID_CPPRpcChannelBuffer))
    {
        // this is a special IID to get a pointer to the
        // C++ object itself.  It is not exposed to the outside
        // world.
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CRpcChannelBuffer::Release( THIS )
{
    // can't call AssertValid(FALSE) since it is used in asserts
    ULONG lRef = InterlockedDecrement( (long*) &_cRefs );
    if (lRef == 0)
    {
        delete this;
    }
    return lRef;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Cancel
//
//  Synopsis:   Cancels an asynchronous call.  Notifies the other side
//              that the call is complete an deletes the call if necessary.
//
//-------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::Cancel( RPCOLEMESSAGE *pMessage )
{
    CAsyncCall   *pCall = (CAsyncCall *) pMessage->reserved1;

    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::Cancel\n"));

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Don't allow cancel on the server side.
    if (!IsClientSide())
        return E_NOTIMPL;

    // Cancel it.
    return pCall->Cancel(FALSE, 0);
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetCallContext
//
//  Synopsis:   Returns the context object for a call.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetCallContext( RPCOLEMESSAGE *pMessage,
                                                REFIID riid,
                                                void **pInterface )
{
    CAsyncCall *pCall = (CAsyncCall *) pMessage->reserved1;

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Get the requested interface.
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::GetCallContext\n"));
    if (pCall->_pContext != NULL)
        return pCall->_pContext->QueryInterface( riid, pInterface );
    else
        return RPC_E_NO_CONTEXT;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetDestCtxEx
//
//  Synopsis:   Gets the destination context of an asynchronous calls.
//              Since there may be multiple calls outstanding, the
//              context must be retrieved from the call stored in the
//              message rather then TLS.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetDestCtxEx( RPCOLEMESSAGE *pMessage,
                                              DWORD *pdwDestContext,
                                              void **ppvDestContext )
{
    CAsyncCall *pCall = (CAsyncCall *) pMessage->reserved1;

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Get the dest context.
    *pdwDestContext = pCall->GetDestCtx();
    if (ppvDestContext != NULL)
    {
        if(pCall->GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
            *ppvDestContext = (IDestInfo *) &pCall->_destObj;
        else
            *ppvDestContext = NULL;
    }

    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::GetDestCtxEx\n"));
    return S_OK;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetState
//
//  Synopsis:   Gets the current status of an asynchronous call.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetState( RPCOLEMESSAGE *pMessage,
                                          DWORD *pState )
{
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::GetState\n"));
    CAsyncCall *pCall = (CAsyncCall *) pMessage->reserved1;

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Get the state from the call.
    return pCall->GetState( pState );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::RegisterAsync
//
//  Synopsis:   Registers the completion object to associate with a call.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::RegisterAsync( RPCOLEMESSAGE *pMessage,
                                          IAsyncManager *pComplete )
{
    CMessageCall   *pCall = (CMessageCall *) pMessage->reserved1;
    HRESULT         result;

    // Make sure there is a call
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::RegisterAsync\n"));
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Register async with RPC.  This has already been done for remote
    // calls to STA.
    if (!pCall->ProcessLocal() &&
        (Proxy() || IsMTAThread()))
    {
        if(!Proxy())
            pCall->message.reserved1 = pCall->_hRpc;
        result = I_RpcAsyncSetHandle((RPC_MESSAGE *) &pCall->message,
                                     &(((CAsyncCall *) pCall)->_AsyncState));
        if(!Proxy())
            pCall->message.reserved1 = pCall;
        if (result != RPC_S_OK)
            result = MAKE_WIN32( result );
    }
    else
        result = S_OK;

    // Change our state.
    if (SUCCEEDED(result))
    {
        // REVIEW: The assumption the call is CAsyncCall is
        //        not valid for process local sync calls made
        //        by the client that became async on the server
        //        side. GopalK

         
        // Mark the call as async.
        if (Proxy())
            pCall->SetClientAsync();
        else
            pCall->SetServerAsync();

        // On the server, save or replace the synchronize and save the
        // call context.
        if (Server())
        {
            // Keep the call alive
            pCall->AddRef();

            // Get the call context.
            if (pCall->_pContext == NULL)
            {
                COleTls tls;
                pCall->_pContext = tls->pCallContext;
                pCall->_pContext->AddRef();
            }

            // Mark the call as async.
            pMessage->rpcFlags      |= RPC_BUFFER_ASYNC;
            pCall->message.rpcFlags |= RPC_BUFFER_ASYNC;
        }
        // On the client side save the synchronize.
        else
        {
            Win4Assert(pComplete);
            ((CAsyncCall *)pCall)->_pChnlObj = (CChannelObject *) pComplete;
        }
    }
    else if(Proxy())
    {
        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;

        // If the call failed, clean up.
        result = ClientNotify( NULL, 0, NULL, 0, result,
                               pCall );

        // Clean up the call.
        pCall->CallFinished();
        pCall->Release();
        pMessage->reserved1 = NULL;

        // Update connection status maintained by standard identity
        if (result == RPC_E_SERVER_DIED     ||
            result == RPC_E_SERVER_DIED_DNE ||
            result == RPC_E_DISCONNECTED    ||
            result == MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
            _pStdId->SetConnectionStatus(result);
    }

    return result;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Send
//
//  Synopsis:   Wrapper for send.  Used when no apartment call control
//              wraps the channel
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Send( RPCOLEMESSAGE *pMessage,
                                      ULONG *pulStatus )
{
    return Send2( pMessage, pulStatus );
}
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Send
//
//  Synopsis:   Wrapper for send.  Used when no apartment call control
//              wraps the channel
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Send(RPCOLEMESSAGE *pMsg, ISynchronize *pSync, PULONG pulStatus)
{
    HRESULT hr = S_OK;
    if (Proxy())
    {
        Win4Assert(pSync);
        hr = RegisterAsync(pMsg, ((IAsyncManager *) pSync));
    }
    else
        Win4Assert(!pSync && "ISynchronize supplied on the server side");

    if (SUCCEEDED(hr))
        hr = CRpcChannelBuffer::Send2(pMsg, pulStatus);

    return hr;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Send2
//
//  Synopsis:   Pick whether to use PipeSend or AsyncSend
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Send2( RPCOLEMESSAGE *pMessage,
                                       ULONG *pulStatus )
{
    if ( pMessage->rpcFlags & RPC_BUFFER_PARTIAL )
        return E_INVALIDARG;

    return AsyncSend( pMessage, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::AsyncSend
//
//  Synopsis:   Sends a packet for an asynchronous call.  On the client
//              side it sends the request.  On the server side it sends
//              the reply.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::AsyncSend( RPCOLEMESSAGE *pMessage, ULONG *pulStatus )
{
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncSend pChnl:%x pMsg:%x\n",
               this, pMessage));

    AssertValid(FALSE, TRUE);
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert( pMessage->rpcFlags & RPC_BUFFER_ASYNC );

    HRESULT      result;
    CAsyncCall  *pCall = (CAsyncCall *) pMessage->reserved1;
    BOOL         fCanceled;

    // Return an error if the call is canceled.
    if (pCall == NULL)
        return RPC_E_CALL_CANCELED;

    // Client side.
    if (Proxy())
    {
        // we must ensure that we dont go away during this call. we will Release
        // ourselves in the FreeBuffer call, or in the error handling at the
        // end of this function.
        _pStdId->LockClient();

        pCall->InitClientHwnd(); // get the hwnd for the client thread

        // Send the request.
        if (pCall->ProcessLocal())
        {
            // Make the same changes to the message that RPC would.
            pCall->message.rpcFlags    |= RPC_BUFFER_COMPLETE;
            pCall->message.reserved2[3] = NULL;

            // get a reference to give to the thread
            pCall->AddRef();

            if (_pOXIDEntry->IsMTAServer())
            {
                result = CacheCreateThread( ThreadDispatch, pCall );
            }
            else
            {
                result = _pOXIDEntry->PostCallToSTA(pCall);
            }

            if (FAILED(result))
            {
                // fix up the reference count if we fail to get
                // to the other thread.
                pCall->Release();
            }
        }
        else
        {
            LOCK(gComLock);
            Win4Assert( pCall->_eSignalState != pending_ss );
            pCall->_eSignalState = pending_ss;
            UNLOCK(gComLock);

            result = I_RpcSend( (RPC_MESSAGE *) &pCall->message );
            if (result != S_OK)
            {
                result = FIX_WIN32( result );
                pCall->_eSignalState = failed_ss;
                pCall->_pHeader   = NULL;
            }
        }

        if(SUCCEEDED(result))
        {
            pCall->_pHandle->_fFirstCall = FALSE;
            if(FAILED(pCall->CallSent()))
                pCall->Cancel(FALSE, 0);
        }

        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;

        // If the call failed, clean up.
        if (result != S_OK)
        {
            result = ClientNotify( NULL, 0, NULL, 0, result,
                                   pCall );

            // Clean up the call.
            _pStdId->UnlockClient();
            pCall->CallFinished();
            pCall->Release();
            pMessage->reserved1 = NULL;

            // Update connection status maintained by standard identity
            if (result == RPC_E_SERVER_DIED     ||
                result == RPC_E_SERVER_DIED_DNE ||
                result == RPC_E_DISCONNECTED    ||
                result == MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
                _pStdId->SetConnectionStatus(result);
        }

        // Make sure the call gets unlocked in FreeBuffer or Cancel.
        else
        {
            pCall->Lock();
        }
    }
    // Server side.
    else
    {
        // Prevent app from trying to resend the reply.
        pMessage->reserved1 = NULL;
        result              = S_OK;

        // Local
        if (pCall->ProcessLocal())
        {
            // Free request buffer
            PrivMemFree8( pCall->_pRequestBuffer );

            // Clean up the call context and server signal.
            if (pCall->_pContext)
            {
                pCall->_pContext->Release();
                pCall->_pContext = NULL;
            }

            // Send reply
            pMessage->cbBuffer += (ULONG) ((char *) pMessage->Buffer -
                                           (char *) pCall->_pHeader);
            pMessage->Buffer    = pCall->_pHeader;

            // Change call state only after updating call completion
            // state
            pCall->CallCompleted( &fCanceled );

            // If the client is still waiting, wake him up.
            if (!fCanceled)
                SignalTheClient(pCall);

            // Balance the AddRef in RegisterAsync
            pCall->Release();
        }
        // Remote
        else
        {
            pCall->message.reserved1          = pCall->_hRpc;
            pCall->message.cbBuffer           = pMessage->cbBuffer +
              (ULONG) ((char *) pMessage->Buffer -
                       (char *) pCall->_pHeader);
            pCall->message.Buffer             = pCall->_pHeader;
            pCall->message.dataRepresentation = pMessage->dataRepresentation;

            // Send reply.  Ignore errors because replies can fail.
            HRESULT result2 = I_RpcSend( (RPC_MESSAGE *) &pCall->message );

            if (FAILED(result2))
            {

                pCall->Release();
                ComDebOut((DEB_ERROR, "CRpcChannelBuffer::AsyncSend: I_RpcSend failure when sending reply: 0x%x\n",
                           result2));
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncSend hr:%x\n", result));
    *pulStatus = result;
    return result;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Receive
//
//  Synopsis:   Wrapper for receive.  Used when no apartment call controller
//              wraps the channel.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Receive( RPCOLEMESSAGE *pMessage,
                                         ULONG uSize, ULONG *pulStatus )
{
    return Receive2( pMessage, uSize, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Receive
//
//  Synopsis:   Wrapper for receive.  Used when no apartment call controller
//              wraps the channel.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Receive( RPCOLEMESSAGE *pMessage, ULONG *pulStatus )
{
    return Receive( pMessage, 0, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Receive2
//
//  Synopsis:   Forwards to PipeReceive or AsyncReceive.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::Receive2( RPCOLEMESSAGE *pMessage,
                                     ULONG uSize, ULONG *pulStatus )
{
    if ( pMessage->rpcFlags & RPC_BUFFER_PARTIAL )
        return E_INVALIDARG;

    return AsyncReceive( pMessage, uSize, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::AsyncReceive
//
//  Synopsis:   Receives the reply for an asynchronous call.  Cleans up
//              the call and deletes it if necessary.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::AsyncReceive( RPCOLEMESSAGE *pMessage,
                                         ULONG uSize, ULONG *pulStatus )
{
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncReceive pChnl:%x pMsg:%x\n",
               this, pMessage));

    AssertValid(FALSE, TRUE);
    Win4Assert( Proxy() );
    Win4Assert( pMessage->rpcFlags & RPC_BUFFER_ASYNC );
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT          result;
    HRESULT          tmp;
    CAsyncCall      *pCall = (CAsyncCall *) pMessage->reserved1;
    WireThat        *pOutb = NULL;
    char            *stub_data;

    // Return an error if the call is canceled.
    if (pCall == NULL)
        return RPC_E_CALL_CANCELED;

    // Receive the reply buffer
    if (pCall->ProcessLocal())
    {
        // Make sure the call completed.
        if (pCall->IsCallCompleted())
        {
            pOutb  = (WireThat *) pCall->_pHeader;
            result = pCall->GetResult();
        }
        else if (pCall->IsCallCanceled() && pCall->GetTimeout()==0)
            result = RPC_E_CALL_CANCELED;
        else
            result = RPC_S_CALLPENDING;
    }
    else
    {
        // Ask unto RPC for the reply.
        result = I_RpcReceive( (RPC_MESSAGE *) &pCall->message, 0 );

        // Byte swap the reply header.  Fail the call if the buffer is too
        // small.
        if (result == RPC_S_OK)
        {
            pCall->_pHeader = pCall->message.Buffer;
            pOutb           = (WireThat *) pCall->_pHeader;
            if (pCall->message.cbBuffer >= sizeof(WireThatPart1))
            {
                ByteSwapThat( pCall->message.dataRepresentation, pOutb);
            }
            else
            {
                pOutb = NULL;
                I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
                result = RPC_E_INVALID_HEADER;
            }
        }

        // Convert status pending to HRESULT pending.
        else if (result == RPC_S_ASYNC_CALL_PENDING)
            result = RPC_S_CALLPENDING;
        else
            result = FIX_WIN32( result );
    }

    // Don't clean up or complete it if the call is still pending.
    if (result == RPC_S_CALLPENDING)
    {
        *pulStatus = result;
        return result;
    }

    // If the apartment is bad, fail the call and clean up.
    if (GetCurrentApartmentId() != pCall->_lApt)
    {
        CoVrfNotifySmuggledProxy(pCall->hook.iid, pMessage->iMethod, pCall->_lApt);
        result = RPC_E_WRONG_THREAD;
    }

    // Figure out when to retry.
    //    FreeThreaded - treat retry as a failure.
    //    Apartment    - return the buffer and let call control decide.
    if (result == S_OK)
    {
        if (IsMTAThread())
        {
            if (pOutb->c.flags & ORPCF_REJECTED)
                result = RPC_E_CALL_REJECTED;
            else if (pOutb->c.flags & ORPCF_RETRY_LATER)
                result = RPC_E_SERVERCALL_RETRYLATER;
            else
                *pulStatus = S_OK;
        }
        else if (pOutb->c.flags & ORPCF_REJECTED)
            *pulStatus = (ULONG) RPC_E_CALL_REJECTED;
        else if (pOutb->c.flags & ORPCF_RETRY_LATER)
            *pulStatus = (ULONG) RPC_E_SERVERCALL_RETRYLATER;
        else
            *pulStatus = S_OK;
    }

    // Check the packet extensions.
    stub_data = (char *) pCall->_pHeader;
    tmp       = ClientNotify( pOutb, pCall->message.cbBuffer,
                              (void **) &stub_data,
                              pCall->message.dataRepresentation,
                              result, pCall );

    // If the packet header was bad, clean up the call.
    if (SUCCEEDED(result) && FAILED(tmp))
    {
        Win4Assert( !pCall->ProcessLocal() );
        I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
        result           = tmp;
    }

    // Call succeeded.
    if (result == S_OK)
    {
        // Set up the proxy's message.
        pMessage->Buffer       = stub_data;
        pMessage->cbBuffer     = pCall->message.cbBuffer -
          (ULONG)(stub_data - (char *) pCall->_pHeader);
        pMessage->dataRepresentation = pCall->message.dataRepresentation;
        result                 = *pulStatus;
    }
    else
    {
        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;
        if(!pCall->ProcessLocal())
            pCall->_pHeader  = NULL;

        // If the result is server fault, get the exception code from the CMessageCall.
        if (result == RPC_E_SERVERFAULT)
        {
            *pulStatus = pCall->GetFault();
        }
        // Everything else is a comm fault.
        else if (result != S_OK)
        {
            *pulStatus = result;
            result = RPC_E_FAULT;
        }

        // Since result is almost always mapped to RPC_E_FAULT, display the
        // real error here to assist debugging.
        if (*pulStatus != S_OK)
        {
            ComDebOut((DEB_CHANNEL, "ORPC call failed. status = %x\n", *pulStatus));

            // Update connection status maintained by standard identity
            if(*pulStatus==RPC_E_SERVER_DIED ||
               *pulStatus==RPC_E_SERVER_DIED_DNE ||
               *pulStatus==RPC_E_DISCONNECTED ||
               *pulStatus==(ULONG)MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
                _pStdId->SetConnectionStatus(*pulStatus);
        }
        // Clean up the call. For auto-complete calls, this will 
        // destroy the stdid object
        if (pCall->Locked())
            _pStdId->UnlockClient();
        pCall->CallFinished();
        pCall->Release();
        pMessage->reserved1 = NULL;
        Win4Assert(*pulStatus != S_OK);
    }

    // Update connection status if the call succeeded
    if(*pulStatus==S_OK && _pStdId->GetConnectionStatus()!=S_OK)
        _pStdId->SetConnectionStatus(S_OK);

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncReceive hr:%x\n", result));
    return result;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::SendReceive( THIS_ RPCOLEMESSAGE *pMessage,
                                             ULONG *status )
{
    return CRpcChannelBuffer::SendReceive2(pMessage, status);
}


/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::SendReceive2( THIS_ RPCOLEMESSAGE *pMessage,
                                              ULONG *status )
{
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive2 pChnl:%x pMsg:%x\n",
               this, pMessage));

    gOXIDTbl.ValidateOXID();
    AssertValid(FALSE, TRUE);
    Win4Assert( Proxy() );
    ASSERT_LOCK_NOT_HELD(gComLock);
    
    HRESULT          result;
    HRESULT          resultSave = S_OK;
    WireThat        *pOutb;
    char            *stub_data;
    BOOL            bEnumRpcErrorInfo = FALSE;
    BOOL            bSaveResult = FALSE;
    RPC_ERROR_ENUM_HANDLE EnumHandle;
    RPC_EXTENDED_ERROR_INFO ErrorInfo;
    CMessageCall *pCall = (CMessageCall *) pMessage->reserved1;
    Win4Assert( pCall != NULL );
    Win4Assert( (pMessage->rpcFlags & RPC_BUFFER_ASYNC) == 0 );
    
    // Make sure the user isn't holding any locks.
    CoVrfHoldingNoLocks();
    
    // Set up the header pointers.
    WireThis *pInb = (WireThis *) pCall->_pHeader;
    IID iid = *MSG_TO_IIDPTR( &pCall->message );
    
    // we must ensure that we dont go away during this call. we will Release
    // ourselves in the FreeBuffer call, or in the error handling at the
    // end of this function.
    _pStdId->LockClient();
    
#if DBG==1
    DWORD CallCat = GetCallCat( pInb );
    DebugPrintORPCCall(ORPC_SENDRECEIVE_BEGIN, iid, pCall->message.iMethod, CallCat);
    RpcSpy((CALLOUT_BEGIN, pInb, iid, pCall->message.iMethod, 0));
#endif
    
    BOOL fLogEventIsActive = LogEventIsActive();
    ULONG_PTR RpcValues[5];               // Store for logging parameters
    
    if (fLogEventIsActive)            // Log before/after the call if necessary
    {
        RpcValues[0] = (ULONG_PTR) (_pIPIDEntry ? &_pIPIDEntry->ipid         : &GUID_NULL);
        RpcValues[1] = (ULONG_PTR) (_pOXIDEntry ? _pOXIDEntry->GetMoxidPtr() : &GUID_NULL);
        RpcValues[2] = (ULONG_PTR) &pMessage;               // CorrelationID
        RpcValues[3] = (ULONG_PTR) &iid;                    // IID
        RpcValues[4] = (ULONG_PTR) pCall->message.iMethod;  // Method index
        
        LogEventClientCall(RpcValues);
    }
    
    
    // If it is local we have to set the rpcFlags like the rpc runtime would.
    // Don't set the flag for remote calls, RPC complains.
    if (pCall->ProcessLocal())
        pCall->message.rpcFlags |= RPC_BUFFER_COMPLETE;
    
    // Send the request.
    result = SwitchAptAndDispatchCall( &pCall );
    
    if (fLogEventIsActive)
    {
        LogEventClientReturn(RpcValues);
    }
    
#if DBG==1
    DebugPrintORPCCall(ORPC_SENDRECEIVE_END, iid, pMessage->iMethod, CallCat);
    RpcSpy((CALLOUT_END, pInb, iid, pMessage->iMethod, result));
#endif
    
    pOutb = (WireThat *) pCall->_pHeader;
    ULONG cMax = pCall->message.cbBuffer;
    // Figure out when to retry.
    //    FreeThreaded - treat retry as a failure.
    //    Apartment    - return the buffer and let call control decide.
    
    if (result == S_OK)
    {
        if (IsMTAThread())
        {
            if (pOutb->c.flags & ORPCF_REJECTED)
                result = RPC_E_CALL_REJECTED;
            else if (pOutb->c.flags & ORPCF_RETRY_LATER)
                result = RPC_E_SERVERCALL_RETRYLATER;
            else
                *status = S_OK;
        }
        else if (pOutb->c.flags & ORPCF_REJECTED)
            *status = (ULONG) RPC_E_CALL_REJECTED;
        else if (pOutb->c.flags & ORPCF_RETRY_LATER)
            *status = (ULONG) RPC_E_SERVERCALL_RETRYLATER;
        else
            *status = S_OK;
    }
    else
    {
        if (pCall->ProcessLocal()) 
        {
            if (pCall->GetErrorFromPolicy()) 
            {
                bSaveResult = TRUE;
                resultSave = result;
                result = S_OK;
                pCall->ResetErrorFromPolicy();
            }
        }
        else
        {
            // see if we have extended error information in the 
            // fault PDU
            RPC_STATUS status;
            status = RpcErrorStartEnumeration(&EnumHandle);
#if DBG==1
            if (RPC_S_OK != status && RPC_S_ENTRY_NOT_FOUND != status) 
            {
                ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive2 RpcErrorStartEnumeration:%x \n",
                           status));
            }
#endif       
            if (RPC_S_OK == status)
                bEnumRpcErrorInfo = TRUE;
            while(RPC_S_OK == status)
            {
                ErrorInfo.Version = RPC_EEINFO_VERSION;
                ErrorInfo.Flags = 0;
                ErrorInfo.NumberOfParameters = 4;
                status = RpcErrorGetNextRecord(&EnumHandle, FALSE, &ErrorInfo);   
#if DBG==1
                if (RPC_S_OK != status && RPC_S_ENTRY_NOT_FOUND != status) 
                {
                    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive2 RpcErrorStartEnumeration:%x \n",
                               status));
                }
#endif       
                if (RPC_S_OK != status) 
                {
                    break;
                }
                if (ErrorInfo.GeneratingComponent == EEInfoGCCOM &&
                    ErrorInfo.NumberOfParameters == 1 &&
                    ErrorInfo.Parameters[0].ParameterType == eeptBinary) 
                {
                    cMax = ErrorInfo.Parameters[0].u.BVal.Size;
                    pOutb = (WireThat *)ErrorInfo.Parameters[0].u.BVal.Buffer;
                    Win4Assert(ErrorInfo.Status == result);
                    bSaveResult = TRUE;
                    resultSave = result;
                    result = S_OK;
                }
            }
        }
    }
    
    stub_data = (char *) pOutb;
    result = ClientNotify( pOutb, cMax,
                           (void **) &stub_data,
                           pCall->message.dataRepresentation,
                           result, pCall );
    
    if (bEnumRpcErrorInfo) 
    {
        RpcErrorEndEnumeration(&EnumHandle);       
    }
    if (bSaveResult && result == S_OK) 
    {
        result = resultSave;
    }
    // Call succeeded.
    if (result == S_OK)
    {
        // The locked flag lets FreeBuffer know that it has to call
        // RH->UnlockClient.
        pCall->Lock();
        pMessage->Buffer       = stub_data;
        pMessage->cbBuffer     = pCall->message.cbBuffer -
          (ULONG)(stub_data - (char *) pCall->_pHeader);
        pMessage->dataRepresentation = pCall->message.dataRepresentation;
        result                 = *status;
    }
    else
    {
        // Clean up the call.
        _pStdId->UnlockClient();
        
        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;
        
        // If the result is server fault, get the exception code from the CMessageCall.
        if (result == RPC_E_SERVERFAULT)
        {
            *status = pCall->GetFault();
        }
        // Everything else is a comm fault.
        else if (result != S_OK)
        {
            *status = result;
            result = RPC_E_FAULT;
        }
        
        // Inform call object about the failure
        pCall->CallFinished();
        pCall->Release();
        
        // Since result is almost always mapped to RPC_E_FAULT, display the
        // real error here to assist debugging.
        if (*status != S_OK)
        {
            ComDebOut((DEB_CHANNEL, "ORPC call failed. status = %x\n", *status));
            
            // Update connection status maintained by standard identity
            if(*status==RPC_E_SERVER_DIED ||
               *status==RPC_E_SERVER_DIED_DNE ||
               *status==RPC_E_DISCONNECTED ||
               *status==(ULONG)MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
                _pStdId->SetConnectionStatus(*status);
        }
    }
    
    // Update connection status if the call succeeded
    if(*status==S_OK && _pStdId->GetConnectionStatus()!=S_OK)
        _pStdId->SetConnectionStatus(S_OK);
    
    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive hr:%x\n", result));
    return result;
}

//+-------------------------------------------------------------------------
//
//  Member:     DispatchCall
//
//  Synopsis:   Dispatches the call to the servers apartment.
//
//  History:    26-Feb-98   Johnstra    Created
//              05-06-98    Rickhi      Separated from SwitchAptAndDispatch
//
//--------------------------------------------------------------------------
HRESULT DispatchCall(CMessageCall* pCall)
{
    ComDebOut((DEB_APT, "DispatchCall: call :%x\n", pCall));

    // ThreadDispatch expects a reference on the call object
    pCall->AddRef();

    // In order to prevent an assert in CEventCache::Free, we must
    // indicate that this is a thread-local call.  This prevents
    // ThreadDispatch from setting the call event.  Normally, this
    // event is set to signal a waiting thread.  Because there is
    // no waiting thread to reset the event, CEventCache::Free
    // asserts because the event is set
    BOOL fThreadLocal = pCall->ThreadLocal();
    pCall->SetThreadLocal(TRUE);

    // Dispatch the call on this thread
    ThreadDispatch(pCall);

    // Reset the calls state
    pCall->SetThreadLocal( fThreadLocal );

    // return the result of the call
    ComDebOut((DEB_APT, "DispatchCall: returning:%x\n", pCall->GetResult()));
    return pCall->GetResult();
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::SwitchAptAndDispatchCall
//
//  Synopsis:   Dispatches the call to the servers apartment.  If the caller
//              or callee are in the NA, this function enters/leaves the
//              NTA or leaves/reenters the NA, as appropriate and saves
//              and restores any necessary TLS state.
//
//  History:    26-Feb-98   Johnstra    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::SwitchAptAndDispatchCall( CMessageCall** ppCall )
{
    ComDebOut(( DEB_APT, "SwitchAptAndDispatchCall, ppCall:%08X\n", ppCall ));

    CMessageCall*    pCall  = *ppCall;
    HRESULT          result;

    if (pCall->ProcessLocal())
    {
        if( pCall->IsClientSide() )
            pCall->message.reserved2[3] = NULL;

        if (pCall->Neutral())
        {
            // The server is in the NTA.
            Win4Assert(!IsThreadInNTA() && "Thread in NTA");

            result = DispatchCall(pCall);

            Win4Assert(!IsThreadInNTA() && "Thread is still in NTA");
        }
        else if (IsThreadInNTA())
        {
            // Calling out of the NA into either the MTA or an STA.  We leave
            // the NA and then dispatch the call depending on the type of
            // server we are calling and the type of thread in which the client
            // is executing.  Then, when we return from the call, we place
            // ourselves back in the NA.
            //
            BOOL fSTA = IsSTAThread();
            COleTls Tls;
            CObjectContext *pDefaultCtx = fSTA ? Tls->pNativeCtx : g_pMTAEmptyCtx;
            CObjectContext *pSavedCtx = LeaveNTA(pDefaultCtx);
            Win4Assert(!IsThreadInNTA() && "Thread is in NA");

            if (_pOXIDEntry->IsMTAServer())
            {
                // The server is in the MTA.

                // We decide whether a thread switch is required by looking at
                // the client apartments thread type.
                //
                if (fSTA)
                {
                    // The client is on an STA thread, therefore we must do a
                    // thread switch to get to the MTA.
                    //
                    result = SwitchSTA(_pOXIDEntry, ppCall);
                }
                else
                {
                    // The client is on an MTA thread, therefore no thread switch
                    // is required, just switch the apartment type and invoke the
                    // call on this thread.
#if DBG == 1
                    pCall->SetNAToMTAFlag();
#endif
                    result = DispatchCall(pCall);
#if DBG == 1
                    pCall->ResetNAToMTAFlag();
#endif
                }
            }
            else
            {
                // The server is in an STA.

                // How we get to the servers STA depends on the client
                // apartments thread type.
                //
                if (fSTA)
                {
                    // The client is on an STA thread.  We must switch
                    // to the servers STA.  Note that the server may or may not
                    // be on this thread (i.e. we may have called from an STA
                    // into the NA and are now calling back into a different object
                    // in the same STA).
                    //
#if DBG == 1
                    pCall->SetNAToSTAFlag();
#endif
                    result = SwitchSTA(_pOXIDEntry, ppCall);
#if DBG == 1
                    pCall->ResetNAToSTAFlag();
#endif
                }
                else
                {
                    // The client is on an MTA thread.  We must switch to the
                    // servers STA.
                    //
                    result = GetToSTA(_pOXIDEntry, pCall);
                }
            }

            // Hop back into the NTA.
            //
            pSavedCtx = EnterNTA(pSavedCtx);
            Win4Assert(pSavedCtx == pDefaultCtx);

            Win4Assert(IsThreadInNTA() && "Thread is not in NTA" );
        }
        else if (IsSTAThread())
        {
            // Calling out of one STA to another STA.
            //
            result = SwitchSTA( _pOXIDEntry, ppCall );
        }
        else
        {
            // Calling out of the MTA into an STA.
            result = GetToSTA( _pOXIDEntry,  pCall );
        }
    }
    else
    {
        // For non-local MTA, call ThreadSendReceive directly.
        //
        // Upper layer focus management! Only if we are going
        // to an STA on the local machine
        if (_pOXIDEntry->IsOnLocalMachine() &&
            _pOXIDEntry->IsSTAServer() )
        {
            BOOL bASFW = FALSE;
            REFIID riid = *MSG_TO_IIDPTR( &pCall->message );
            if ((&pCall->message)->iMethod==11)
            {
                if (riid == IID_IOleObject)
                {
                    bASFW = TRUE;
                }
            }
            else if ((&pCall->message)->iMethod==7)
            {
                if (riid == IID_IAdviseSink)
                {
                    bASFW = TRUE;
                }
            }
            if (bASFW)
            {
                // The target app is likely to attempt & take focus
                // so give it the permission to do so.
                // Not much we can do if the call fails.
                AllowSetForegroundWindow(_pOXIDEntry->GetPid());
            }
        }

        result = ThreadSendReceive( pCall );
    }

    ComDebOut(( DEB_APT, "SwitchAptAndDispatchCall: leaving result:%08X\n", result ));
    return result;
}


#if DBG == 1
//+-------------------------------------------------------------------
//
//  Member: CRpcChannelBuffer::AssertValid
//
//  Synopsis:   Validates that the state of the object is consistent.
//
//  History:    25-Jan-94   CraigWi Created.
//
// DCOMWORK - Put in some asserts.
//
//--------------------------------------------------------------------
void CRpcChannelBuffer::AssertValid(BOOL fKnownDisconnected,
                                    BOOL fMustBeOnCOMThread)
{
    Win4Assert(state & (proxy_cs | client_cs | server_cs ));

    if (state & (client_cs | proxy_cs))
    {
        ;
    }
    else if (Server())
    {
        if (fMustBeOnCOMThread && IsSTAThread())
            Win4Assert(IsMTAThread()
                       || _pOXIDEntry->GetTid() == GetCurrentThreadId()
                       || IsThreadInNTA());

        // ref count can be 0 in various stages of connection and disconnection
        Win4Assert(_cRefs < 0x7fff && "Channel ref count unreasonably high");

        // the pStdId pointer can not be NULL
        // Win4Assert(IsValidInterface(_pStdId));
    }
}
#endif // DBG == 1

/***************************************************************************/
extern "C"
BOOL _stdcall DllDebugObjectRPCHook( BOOL trace, LPORPC_INIT_ARGS pass_through )
{
    if (!IsWOWThread())
    {
        DoDebuggerHooks = trace;
        DebuggerArg     = pass_through;
        return TRUE;
    }
    else
        return FALSE;
}

/***************************************************************************/
BOOL LocalCall()
{
    // Get the call info from TLS.
    COleTls tls;
    CMessageCall *pCall = (CMessageCall *) tls->pCallInfo;
    Win4Assert( pCall != NULL );
    return pCall->ProcessLocal();
}

/***************************************************************************/
/* This routine returns both comm status and server faults to the runtime
   by raising exceptions.  If FreeThreading is true, ComInvoke will throw
   exceptions to indicate server faults.  These will not be caught and will
   propagate directly to the runtime.  If FreeThreading is false, ComInvoke
   will return the result and fault in the CMessageCall record.

   NOTE:
   This function switches to the 32 bit stack under WIN95.
   An exception has to be caught while switched to the 32 bit stack.
   The exceptions has to be  pass as a value and rethrown again on the
   16 bit stack (see SSInvoke in stkswtch.cxx)
*/

void
SSAPI(ThreadInvoke)(RPC_MESSAGE *pMessage )
{
    HRESULT          result = S_OK;

    ComDebOut((DEB_CHANNEL,"ThreadInvoke pMsg:%x\n", pMessage));
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    WireThis        *pInb    = (WireThis *) pMessage->Buffer;
    IPID             ipid;
    RPC_STATUS       status;
    unsigned int     transport_type;
    DWORD            authn_level;
    BOOL             fFakeAsync = FALSE;
    CAsyncCall      *pCall  = NULL;
    OXIDEntry       *pOXIDEntry = NULL;
    IPIDEntry       *pIPIDEntry = NULL;


    // Byte swap the header.
    ByteSwapThis( pMessage->DataRepresentation, pInb );

    // Validate several things:
    //            The packet size is larger then the first header size.
    //            No extra flags are set.
    //            The procedure number is greater then 2 (not QI, AddRef, Release).
    if (sizeof(WireThisPart1) > pMessage->BufferLength                ||
        (pInb->c.flags & ~(ORPCF_LOCAL | ORPCF_RESERVED1 |
                           ORPCF_RESERVED2 | ORPCF_RESERVED3 | ORPCF_RESERVED4)) != 0 ||
        pMessage->ProcNum < 3)
    {
        RETURN_COMM_STATUS( RPC_E_INVALID_HEADER );
    }

    // Validate the version.
    if (pInb->c.version.MajorVersion != COM_MAJOR_VERSION ||
        pInb->c.version.MinorVersion > COM_MINOR_VERSION)
        RETURN_COMM_STATUS( RPC_E_VERSION_MISMATCH );

    // Get the transport the call arrived on.
    ComDebOut((DEB_CHANNEL,"->I_RpcBindingInqTransportType\n"));
    status = I_RpcBindingInqTransportType(NULL, &transport_type );
    ComDebOut((DEB_CHANNEL,"<-I_RpcBindingInqTransportType(status=0x%x, transport_type=0x%x\n", status, transport_type));
    if (status != RPC_S_OK)
        RETURN_COMM_STATUS( RPC_E_SYS_CALL_FAILED );

    if (pInb->c.flags & ORPCF_LOCAL)
    {
        // Don't accept the local header on remote calls.
        if (transport_type != TRANSPORT_TYPE_LPC)
            RETURN_COMM_STATUS( RPC_E_INVALID_HEADER );

        // For local calls the authentication level will always be encrypt.
        authn_level = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    }
    else if (gDisableDCOM &&
             (transport_type == TRANSPORT_TYPE_CN || transport_type == TRANSPORT_TYPE_DG))
    {
        // Don't accept remote calls if DCOM is disabled.
        RETURN_COMM_STATUS( RPC_E_CALL_REJECTED );
    }

#if DBG==1
    _try
      {
#endif

          // Find the ipid from the RPC messsage.
          ComDebOut((DEB_CHANNEL,"->RpcBindingInqObject(hdl=0x%x)\n", pMessage->Handle));
          status = RpcBindingInqObject( pMessage->Handle, &ipid );
          ComDebOut((DEB_CHANNEL,"<-RpcBindingInqObject(status=0x%x, ipid=%I)\n", status, &ipid));

          if (status == RPC_S_OK)
          {
              // Create a call object
              status = GetCallObject(TRUE /*fAsync */, (CMessageCall **)&pCall);
              if (SUCCEEDED(status))
              {
                  status = pCall->InitCallObject(GetCallCat( pInb ),
                                                 (RPCOLEMESSAGE *) pMessage,
                                                 server_cs,
                                                 ipid,
                                                 (pInb->c.flags & ORPCF_LOCAL) ? MSHCTX_LOCAL
                                                 : MSHCTX_DIFFERENTMACHINE,
                                                 pInb->c.version,
                                                 NULL);

                  if (SUCCEEDED(status))
                  {
                      // Save some fields from the RPC message
                      Win4Assert( status == S_OK );
                      pCall->_hRpc           = pMessage->Handle;
                      pCall->_pRequestBuffer = pMessage->Buffer;

                      ASSERT_LOCK_NOT_HELD(gIPIDLock);
                      LOCK(gIPIDLock);

                      // Find the ipid entry from the ipid.

                      result = gIPIDTbl.LookupFromIPIDTables(ipid, &pIPIDEntry, &pOXIDEntry);
                      if (FAILED(result))
                      {
                          UNLOCK(gIPIDLock);
                          ASSERT_LOCK_NOT_HELD(gIPIDLock);
                          Win4Assert(result == RPC_E_DISCONNECTED ||
                                     result == E_NOINTERFACE);
                      }
                      else
                      {
                          if (pOXIDEntry->IsMTAServer() ||
                              pOXIDEntry->IsNTAServer() )
                          {
                              // The call is destined for the MTA or NTA apartment, call
                              // ComInvoke on this thread. This subroutine releases
                              // the lock before it returns.
                              result = ComInvokeWithLockAndIPID( pCall, pIPIDEntry );
                              ASSERT_LOCK_NOT_HELD(gIPIDLock);
                          }
                          else
                          {
                              UNLOCK(gIPIDLock);
                              ASSERT_LOCK_NOT_HELD(gIPIDLock);

                              // For calls to a STA, switch threads and let this thread
                              // return.  The reply will be sent from the STA thread.

                              // Register async
                              Win4Assert(pOXIDEntry->GetTid() != GetCurrentThreadId());
                              status = I_RpcAsyncSetHandle( pMessage, &pCall->_AsyncState );

                              // Wake up the server thread
                              if (status == RPC_S_OK)
                              {
                                  fFakeAsync = TRUE;

                                  if (pCall->GetCallCategory() == CALLCAT_INPUTSYNC)
                                  {
                                // For input sync, use SendMessage.
                                      result = pOXIDEntry->SendCallToSTA(pCall);
                                  }
                                  else
                                  {
                                // For sync use PostMessage.
                                      result = pOXIDEntry->PostCallToSTA(pCall);
                                  }

                                  if (result == S_OK)
                                  {
                                // we gave away our reference on the call object to
                                // the server thread
                                      pCall = NULL;
                                  }
                              }
                              else
                              {
                                  result = MAKE_WIN32(status);
                              }
                          }

                          // Release the OXID.
                          pOXIDEntry->DecRefCnt();
                      }
                  }
              }
          }
          else
          {
              result = MAKE_WIN32( status );
          }

#if DBG==1
      }
    _except(ThreadInvokeExceptionFilter(GetExceptionCode(), GetExceptionInformation()))
      {
      }
#endif

    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Check if the call was implicitly converted to async
    if(fFakeAsync)
    {
        if(pCall)
        {
            // Abort the call
            Win4Assert(FAILED(result));
            I_RpcAsyncAbortCall( &pCall->_AsyncState, result );
            pCall->Release();
        }
    }
    else
    {
        if (pCall)
        {
            // Copy from the call message to RPC's message.
            pMessage->Buffer       = pCall->message.Buffer;
            pMessage->BufferLength = pCall->message.cbBuffer;
            pCall->Release();
            pCall = NULL;
        }

        // For comm and server faults, generate an exception.  Otherwise the buffer
        // is set up correctly.
        if (result != S_OK)
        {
            RETURN_COMM_STATUS(result);
        }
    }
}


/***************************************************************************/
HRESULT SSAPI(ThreadSendReceive( CMessageCall *pCall ))
{
    ComDebOut((DEB_CHANNEL, "ThreadSendReceive pCall:%x\n", pCall));

    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT            result;
    RPCOLEMESSAGE     *pMessage = &((CMessageCall *) pCall)->message;
    WireThat          *pOutb;
    BOOL              fFree = FALSE;
    BOOL              fSent = FALSE;
    CAsyncCall        *pAsyncCall;

    // Assert that this method is invoked only on the client side
    Win4Assert(pCall->IsClientSide());

    // Check with call object if it is OK to dispatch the call
    result = pCall->CanDispatch();
    ComDebOut((DEB_CHANNEL, "CanDispatch rc:%x\n", result));

    if(SUCCEEDED(result))
    {
        // Check for fake async calls
        if (pCall->FakeAsync())
        {
            if(SUCCEEDED(result))
            {
                // Register async.
                Win4Assert( !pCall->ClientAsync() );
                pAsyncCall = (CAsyncCall *) pCall;
                result = I_RpcAsyncSetHandle( (RPC_MESSAGE *) &pCall->message,
                                              &pAsyncCall->_AsyncState );
                ComDebOut((DEB_CHANNEL, "I_RpcAsyncSetHandle rc:%x\n", result));

                if (result != RPC_S_OK)
                {
                    fFree = TRUE;
                    result = MAKE_WIN32( result );
                }
                else
                {
                    // Send
                    // AddRef the async call object before calling RPC
                    // This reference is released inside ThreadSignal
                    pAsyncCall->AddRef();
#if DBG==1
                    Win4Assert(pAsyncCall->Release() != 0);
                    pAsyncCall->AddRef();
#endif

                    Win4Assert( pAsyncCall->_eSignalState != pending_ss );
                    pAsyncCall->_eSignalState = pending_ss;
                    result = I_RpcSend( (RPC_MESSAGE *) &pCall->message );
                    ComDebOut((DEB_CHANNEL, "I_RpcSend rc:%x\n", result));

                    if (result != RPC_S_OK)
                    {
                        // Fix up the ref count
                        pAsyncCall->_eSignalState = failed_ss;
                        Win4Assert(!pAsyncCall->IsSignaled());
                        pAsyncCall->Release();
                        result = MAKE_WIN32( result );
                    }
                    else if (IsSTAThread())
                    {
                        ComDebOut((DEB_CHANNEL, "STA Thread FakeAsync\n"));
                        // STA Thread
                        // Inform async call object that the call has
                        // been sent
                        fSent = TRUE;

                        // Enter a modal loop.
                        result = ModalLoop(pCall);
                        ComDebOut((DEB_CHANNEL, "ModalLoop rc:%x\n", result));

                        // Receive
                        result = I_RpcReceive( (RPC_MESSAGE *) &pCall->message, 0 );
                        ComDebOut((DEB_CHANNEL, "I_RpcReceive rc:%x\n", result));
                        Win4Assert( result != RPC_S_ASYNC_CALL_PENDING );

                        // Assert that call completed has been called
                        Win4Assert(pCall->IsCallCompleted());
                    }
                    else
                    {
                        // MTA Thread
                        // Wait for the either the call to complete
                        // or get canceled or timeout to occur

                        Win4Assert(IsMTAThread());
                        ComDebOut((DEB_CHANNEL, "MTA Thread FakeAsync\n"));

                        // Inform async call object that the call has
                        // been sent
                        fSent = TRUE;

                        result = RPC_S_CALLPENDING;
                        while(result == RPC_S_CALLPENDING)
                        {
                            DWORD dwTimeout = pCall->GetTimeout();
                            DWORD dwReason = WaitForSingleObject(pCall->GetEvent(),
                                                                 dwTimeout);
                            if(dwReason==WAIT_OBJECT_0)
                            {
                                result = S_OK;
                            }
                            else if(dwReason==WAIT_TIMEOUT)
                            {
                                result = RPC_E_CALL_CANCELED;
                                Win4Assert(pCall->GetTimeout() == 0);
                            }
                            else
                            {
                                result = RPC_E_SYS_CALL_FAILED;
                                break;
                            }

                            result = pCall->RslvCancel(dwReason, result, FALSE, NULL);
                        }
                        result = I_RpcReceive( (RPC_MESSAGE *) &pCall->message, 0 );
                        ComDebOut((DEB_CHANNEL, "I_RpcReceive rc:%x\n", result));
                        Win4Assert( result != RPC_S_ASYNC_CALL_PENDING );

                        // Assert that call completed has been called
                        Win4Assert(pCall->IsCallCompleted());
                    }
                }

                // Inform async call object about failure if the call
                // could not be sent
                if(!fSent)
                {
                    pCall->CallCompleted(result);
                }
            }
        }
        else
        {
            // Make a blocking send receive.
            if (SUCCEEDED(result))
            {
                ComDebOut((DEB_CHANNEL,"<-I_RpcSendReceive(pmsg=0x%x)\n",
                           (RPC_MESSAGE *) pMessage));
                result = I_RpcSendReceive( (RPC_MESSAGE *) pMessage );
                ComDebOut((DEB_CHANNEL,"<-I_RpcSendReceive(status=0x%x)\n", result));

                // Inform call object that the call completed
                pCall->CallCompleted(result);
            }
        }
    }
    else
    {
        fFree = TRUE;
    }

    // If the result is small, it is probably a Win32 code.
    if (result != RPC_S_OK)
    {
        if (result == RPC_S_CALL_CANCELLED)
        {
            // The call was canceled, change RPC error to COM error
            result = RPC_E_CALL_CANCELED;
        }
        else
        {
            // Change the error to a win32 code
            result = FIX_WIN32( result );
        }

        if(fFree)
            I_RpcFreeBuffer((RPC_MESSAGE *) pMessage);

        pCall->_pHeader   = NULL;
    }
    else
    {
        // Byte swap the reply header.  Fail the call if the buffer is too
        // small.
        pCall->_pHandle->_fFirstCall = FALSE;
        pCall->_pHeader = pMessage->Buffer;
        pOutb           = (WireThat *) pMessage->Buffer;
        if (pMessage->cbBuffer >= sizeof(WireThatPart1))
        {
            ByteSwapThat( pMessage->dataRepresentation, pOutb);
        }
        else
        {
            I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
            pCall->_pHeader = NULL;
            result = RPC_E_INVALID_HEADER;
        }
    }

    ComDebOut((DEB_CHANNEL, "ThreadSendReceive pCall:%x hr:%x\n", pCall, result));
    return result;
}


//+-------------------------------------------------------------------------
//
//  Class:      CRpcChannelBuffer::CServerCallMgr
//
//  Synopsis:   Server side manager object for async calls
//
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------------
//
//  Function:   GetChannelCallMgr
//
//  Returns:    S_OK/Failure
//
//  Parameters: pMsg          - the RPC message structure for
//                              handing out to stubs
//              pStub         - the synchronous stub object
//              pServer       - the synchronous server object
//              ppStubBuffer  - out prm for IRpcStubBuffer if. on the obj.
//
//  Synopsis:   Construct an object an get the IRpcStubBuffer interface.
//
//--------------------------------------------------------------------------------
HRESULT GetChannelCallMgr(RPCOLEMESSAGE *pMsg, IUnknown * pStub,
                          IUnknown *pServer, CRpcChannelBuffer::CServerCallMgr **ppStubBuffer)
{
    ComDebOut((DEB_CHANNEL,
               "GetChannelCallMgr [IN] - pMsg:%x, pStub:%x,  pServer:%x, ppStubBuffer:%x\n",
               pMsg, pStub, pServer, ppStubBuffer));

    ASSERT_LOCK_NOT_HELD(gComLock);

    *ppStubBuffer = NULL;

    if (IsWOWProcess() &&
        !(IsEqualGUID(*MSG_TO_IIDPTR(pMsg), IID_IAdviseSink) ||
          IsEqualGUID(*MSG_TO_IIDPTR(pMsg), IID_IAdviseSink2)))
    {
        // don't even try async in WOW.
        return E_FAIL;
    }

    IUnknown *pTest = NULL;
    HRESULT hr;

    _try
      {
          hr = pServer->QueryInterface(IID_ICallFactory, (void **)&pTest);
      }
    _except (AppInvokeExceptionFilter(GetExceptionInformation(), pServer, IID_IUnknown, 0))
      {
          ComDebOut((DEB_CHANNEL | DEB_WARN, "Server 0x%p threw an exception\n", pServer));
          hr = RPC_E_SERVERFAULT;
      }

    if (SUCCEEDED(hr))
    {
        if (pTest)
            pTest->Release();

        // create the object composite
        CRpcChannelBuffer::CServerCallMgr *pObj =
          new CRpcChannelBuffer::CServerCallMgr(pMsg, pStub, pServer, hr);


        if (SUCCEEDED(hr))
        {
            *ppStubBuffer = pObj;
            (*ppStubBuffer)->AddRef();
        }

        // release the reference from the create
        if (pObj)
        {
            pObj->Release();
        }
    }

    ComDebOut((DEB_CHANNEL, "GetChannelCallMgr [OUT]- hr:0x%x\n",hr));
    return hr;
}



//+-------------------------------------------------------------------------------
//
//  Member:     Constructor
//
//  Parameters: pMsg          - the RPC message structure for
//                              handing out to stubs
//              pStub         - the synchronous stub object
//              pServer       - the synchronous server object
//              hr            - success code
//
//  Synopsis:   Create and aggregate all subordinate objects, connect to the
//              stub call object and set up object state.
//
//--------------------------------------------------------------------------------
CRpcChannelBuffer::CServerCallMgr::CServerCallMgr(RPCOLEMESSAGE *pMsg, IUnknown * pStub,
                                                  IUnknown *pServer, HRESULT &hr)
  :
  _cRefs(1),
  _dwState(STATE_WAITINGFORSIGNAL),
  _iid(((RPC_SERVER_INTERFACE *) pMsg->reserved2[1])->InterfaceId.SyntaxGUID),
  _pUnkStubCallMgr(NULL),
  _pUnkServerCallMgr(NULL),
  _pSync(NULL),
  _pSB(NULL),
  _pCall(NULL),
#if DBG==1
  _hr(S_OK),
#endif
  _pStdID(NULL)
{
    ICallFactory *pCFServer;

    // Get the object server's call factory
    hr = pServer->QueryInterface(IID_ICallFactory, (void **) &pCFServer);
    if (SUCCEEDED(hr))
    {
        // get the async interface's ID
        hr = GetAsyncIIDFromSyncIID(_iid, &_iidAsync);
        if (SUCCEEDED(hr))
        {
            // create the server call manager
            IUnknown *pUnkServerCallMgr;
            hr = pCFServer->CreateCall(_iidAsync, (ISynchronize *) this, IID_IUnknown,
                                       (LPUNKNOWN*) &pUnkServerCallMgr);
            if (SUCCEEDED(hr))
            {
                // get the async interface on the server
                IUnknown *pAsyncInterface;
                hr = pUnkServerCallMgr->QueryInterface(_iidAsync, (void **) &pAsyncInterface);
                if (SUCCEEDED(hr))
                {
                    // get the stub's call factory
                    ICallFactory *pCFStub;
                    hr = pStub->QueryInterface(IID_ICallFactory, (void **) &pCFStub);
                    if (SUCCEEDED(hr))
                    {

                        // create the stub's call manager
                        IUnknown *pUnkStubCallMgr;
                        hr = pCFStub->CreateCall(_iidAsync, NULL, IID_IUnknown,
                                                 (LPUNKNOWN*) &pUnkStubCallMgr);
                        if (SUCCEEDED(hr))
                        {
                            // get the ISychronize interface on the stub
                            ISynchronize *pSync;
                            hr = pUnkStubCallMgr->QueryInterface(IID_ISynchronize, (void **) &pSync);
                            if (SUCCEEDED(hr))
                            {
                                // get the IRpcStubBuffer interface on the stub
                                IRpcStubBuffer *pSB;
                                hr = pUnkStubCallMgr->QueryInterface(IID_IRpcStubBuffer, (void **) &pSB);
                                if (SUCCEEDED(hr))
                                {
                                    // connect the stub to the server object

                                    // ALERT: Connect will expect the v-table for
                                    // the async interface.  It will NOT QI.

                                    hr = pSB->Connect(pAsyncInterface);
                                    if (SUCCEEDED(hr))
                                    {
                                        // everything is ok, so set up the object's
                                        // state

                                        _pUnkStubCallMgr = pUnkStubCallMgr;
                                        _pUnkStubCallMgr->AddRef();

                                        _pUnkServerCallMgr = pUnkServerCallMgr;
                                        _pUnkServerCallMgr->AddRef();


                                        _pSync = pSync; // not AddRef'd because we
                                        _pSB = pSB;     // addref'd the punk


                                        _pCall  = (CMessageCall *) pMsg->reserved1;
                                        _pCall->AddRef();
                                    }
                                    pSB->Release();
                                }
                                pSync->Release();
                            }
                            pUnkStubCallMgr->Release();
                        }
                        pCFStub->Release();
                    }
                    pAsyncInterface->Release();
                }
                pUnkServerCallMgr->Release();
            }
        }
        pCFServer->Release();
    }

}

//+-------------------------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   clean up object state
//
//--------------------------------------------------------------------------------

CRpcChannelBuffer::CServerCallMgr::~CServerCallMgr()
{
    if (_pUnkStubCallMgr)
    {
        _pUnkStubCallMgr->Release();
        _pUnkStubCallMgr = 0;
        _pSB = 0;
        _pSync = 0;
    }
    if (_pUnkServerCallMgr)
    {
        _pUnkServerCallMgr->Release();
        _pUnkServerCallMgr = 0;
    }
    if (_pCall)
    {
        _pCall->Release();
    }
    Win4Assert(_pStdID == NULL);
}



//+-------------------------------------------------------------------------------
//
//  Member:     MarkError
//
//  Synopsis:   Atomically mark this call as in an error state and
//              return whether Signal executed or not.
//
//--------------------------------------------------------------------------------

DWORD CRpcChannelBuffer::CServerCallMgr::MarkError(HRESULT hr)
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    DWORD dwState = _dwState;
    BOOL fAbort = FALSE;

    // Initialize
#if DBG==1
    _hr = hr;
#endif

    if (_dwState == STATE_WAITINGFORSIGNAL)
    {
        // Signal has not been started. Mark this call as in
        // the error state and return TRUE to abort the call.
        // If Signal does start it will simply return _hr.
        _dwState = STATE_ERROR;

        // Abort
        fAbort = TRUE;
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Abort the call if neccessary
    if(fAbort)
    {
        // Abort the call
        GetCall()->Abort();

        // Delete the context call object
        if(GetCall()->GetServerCtxCall())
            delete GetCall()->GetServerCtxCall();

        // Unlock the server
        CIDObject *pID = _pStdID->GetIDObject();
        if(pID)
            pID->DecrementCallCount();
        _pStdID->UnlockServer();
#if DBG==1
        _pStdID = NULL;
#endif
        // Fixup the refcount. This release would otherwise
        // have been done in Signal
        Release();
    }

    return(dwState);
}


//+-------------------------------------------------------------------------------------
//
// Interface:         IUnknown
//
//--------------------------------------------------------------------------------------


STDMETHODIMP_(ULONG) CRpcChannelBuffer::CServerCallMgr::AddRef()
{
    return (ULONG) InterlockedIncrement((PLONG) &_cRefs);
}

STDMETHODIMP_(ULONG) CRpcChannelBuffer::CServerCallMgr::Release()
{
    ULONG ret = InterlockedDecrement((PLONG) &_cRefs);
    if (ret == 0)
    {
        // protect against reentrancy
        _cRefs = 100;
        delete this;
        return 0;
    }
    return ret;
}


STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::QueryInterface(REFIID riid, LPVOID * ppv)
{

    void *pv = 0;

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISynchronize))
    {
        pv = (ISynchronize *) this;
    }
    else if (riid == IID_IServerSecurity)
    {
        pv = (IServerSecurity *) this;
    }
    else if (riid == IID_ICancelMethodCalls)
    {
        pv = (ICancelMethodCalls *) this;
    }
    else if (riid == IID_IRpcStubBuffer)
    {
        pv = (IRpcStubBuffer *) this;
    }

    if (pv)
    {
        AddRef();
        *ppv = pv;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}


//+-------------------------------------------------------------------------------------
//
// Interface:         ISynchronize
//
// Synopsis:          Most methods are delegated to the stub's ISynchronize. Signal
//                    is hooked for special behavior
//
//--------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------------
//
//  Member:     Wait
//
//  Synopsis:   Delegate to Stub
//
//--------------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Wait(DWORD dwFlags, DWORD dwTime)
{
    return _pSync->Wait(0,dwTime);
}


//+-------------------------------------------------------------------------------
//
//  Member:     Signal
//
//  Synopsis:   Check state for errors, setup TLS so context operations work
//              properly during the Finish call, call Signal on the Stub.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Signal()
{
    HRESULT hr;

    // Acquire lock
    LOCK(gComLock);

    if (_dwState == STATE_WAITINGFORSIGNAL)
    {
        _dwState = STATE_SIGNALED;
        hr = S_OK;
    }
    else
        hr = E_UNEXPECTED;

    // Release lock
    UNLOCK(gComLock);

    // Check for the need to call signal on the stub
    if(SUCCEEDED(hr))
    {
        // Setup TLS
        COleTls tls(hr);
        if (SUCCEEDED(hr))
        {
            IUnknown *pContextPrev = tls->pCallContext;
            tls->pCallContext = GetCall()->_pContext;
            tls->pCallContext->AddRef();
            ((CServerSecurity *) (IServerSecurity *) tls->pCallContext)->SetupSecurity();
            CMessageCall *pCallPrev = tls->pCallInfo;
            tls->pCallInfo = GetCall();

            // REVIEW: Deliver CALLTYPE_FINISHLEAVE events
            //         to enter server context. Gopalk

            // Delegate to stub
            hr = _pSync->Signal();
            Win4Assert(SUCCEEDED(_hr) || (_hr == hr));

            // Tear down TLS
            ((CServerSecurity *) (IServerSecurity *) tls->pCallContext)->RestoreSecurity(TRUE);
            tls->pCallContext->Release();
            tls->pCallContext = pContextPrev;
            tls->pCallInfo = pCallPrev;
        }

#if DBG==1
        _hr = hr;
#endif

        // Abort failed calls
        if(FAILED(hr))
            GetCall()->Abort();

        // disconnect stub
        _pSB->Disconnect();
        _pSB = 0;
        _pSync = 0;

        // Delete context call object
        delete GetCall()->GetServerCtxCall();

        // Unlock the server
        CIDObject *pID = _pStdID->GetIDObject();
        if(pID)
            pID->DecrementCallCount();
        _pStdID->UnlockServer();
#if DBG==1
        _pStdID = NULL;
#endif
        // Release this async call manager
        Release();
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     Reset
//
//  Synopsis:   Delegate to Stub
//
//--------------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Reset()
{
    return _pSync->Reset();
}


//+-------------------------------------------------------------------------------------
//
// Interface:         IRpcStubBuffer
//
// Synopsis:          Delegation of IRpcStubBuffer to stub call object
//
//--------------------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Connect(IUnknown *pUnkServer)
{
    return _pSB->Connect(pUnkServer);
}

STDMETHODIMP_(void) CRpcChannelBuffer::CServerCallMgr::Disconnect()
{
    _pSB->Disconnect();
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Invoke(RPCOLEMESSAGE *_prpcmsg,
                                                       IRpcChannelBuffer *_pRpcChannelBuffer)
{
    return _pSB->Invoke(_prpcmsg, _pRpcChannelBuffer);
}

STDMETHODIMP_(IRpcStubBuffer *)  CRpcChannelBuffer::CServerCallMgr::IsIIDSupported(REFIID riid)
{
    return _pSB->IsIIDSupported(riid);
}

STDMETHODIMP_(ULONG) CRpcChannelBuffer::CServerCallMgr::CountRefs()
{
    return _pSB->CountRefs();
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::DebugServerQueryInterface(void **ppv)
{
    return _pSB->DebugServerQueryInterface(ppv);
}
STDMETHODIMP_(void) CRpcChannelBuffer::CServerCallMgr::DebugServerRelease(void *pv)
{
    _pSB->DebugServerRelease(pv);
}


//+-------------------------------------------------------------------------------------
//
// Interface:         IServerSecurity
//
// Synopsis:          Delegation of IServerSecurity to channel call object
//
//--------------------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::QueryBlanket
(
    DWORD    *pAuthnSvc,
    DWORD    *pAuthzSvc,
    OLECHAR **pServerPrincName,
    DWORD    *pAuthnLevel,
    DWORD    *pImpLevel,
    void    **pPrivs,
    DWORD    *pCapabilities
)
{
    HRESULT hr;
    IServerSecurity * pSS;
    if (!GetCall())
    {
        return RPC_E_CALL_CANCELED;
    }
    if (SUCCEEDED(hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS)))
    {
        hr = pSS->QueryBlanket(pAuthnSvc, pAuthzSvc, pServerPrincName,
                               pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
        pSS->Release();
    }

    return hr;
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::ImpersonateClient()
{
    HRESULT hr;
    IServerSecurity * pSS;
    if (!GetCall())
    {
        return RPC_E_CALL_CANCELED;
    }
    if (SUCCEEDED(hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS)))
    {
        hr = pSS->ImpersonateClient();
        pSS->Release();
    }

    return hr;
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::RevertToSelf()
{
    HRESULT hr;
    IServerSecurity * pSS;
    if (!GetCall())
    {
        return RPC_E_CALL_CANCELED;
    }
    if (SUCCEEDED(hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS)))
    {
        hr = pSS->RevertToSelf();
        pSS->Release();
    }

    return hr;
}

STDMETHODIMP_(BOOL) CRpcChannelBuffer::CServerCallMgr::IsImpersonating()
{
    BOOL ret = FALSE;
    
    if (GetCall())
    {
        IServerSecurity * pSS;
        HRESULT hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS);
        if (SUCCEEDED(hr))
        {
            ret = pSS->IsImpersonating();
            pSS->Release();
        }
    }

    return ret;
}


//+----------------------------------------------------------------------------
//
//  Member:        CRpcChannelBuffer::CServerCallMgr::Cancel
//
//  Synopsis:      Cancel not implemented for servers
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Cancel(DWORD dwTime)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:        CRpcChannelBuffer::CServerCallMgr::TestCancel
//
//  Synopsis:      Query call to see if it has been cancelled.
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::TestCancel()
{
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::CServerCallMgr::TestCancel IN \n" ));
    HRESULT hr = S_OK;

    LOCK(gComLock);
    if (_dwState != STATE_WAITINGFORSIGNAL)
    {
        hr = RPC_E_CALL_COMPLETE;
    }
    UNLOCK(gComLock);

    if (SUCCEEDED(hr))
    {
        hr = _pCall->TestCancel();
    }

    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::CServerCallMgr::TestCancel OUT hr:0x%x\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\coapi.cxx ===
//+-------------------------------------------------------------------
//
//  File:       coapi.cxx
//
//  Contents:   Public COM remote subsystem APIs
//
//  Classes:    CDestObjectWrapper          - wraps CDestObject for ContextMarshaling
//
//  Functions:  CoGetStandardMarshal       - returns IMarshal for given interface
//              CoGetMarshalSizeMax        - sends size requests one of two ways
//              CoDirectGetMarshalSizeMax  - returns max size buffer needed
//              CoMarshalInterface         - sends marshal requests one of two ways
//              CoDirectMarshalInterface   - marshals an interface
//              CoUnmarshalInterface       - unmarshals an interface
//              CoReleaseMarshalData       - releases data from marshaled interface
//              CoLockObjectExternal       - keep object alive or releases it
//              CoDisconnectObject         - kills sessions held by remote clients
//              CoIsHandlerConnected       - try to determine if handler connected
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//              05-Jul-94   BruceMa     Check for end of stream
//              20-Feb-95   Rickhi      Major changes for DCOM
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <olerem.h>
#include <marshal.hxx>      // CStdMarshal
#include <stdid.hxx>        // CStdIdentity, IDTable APIs
#include <service.hxx>      // SASIZE
#include <crossctx.hxx>     // CStdWrapper
#include <destobj.hxx>          // IDestInfo
#include <resolver.hxx>

// static unmarshaler
IMarshal *gpStdMarshal = NULL;

//+-------------------------------------------------------------------
//
//  Function:   CoGetStdMarshalEx, public
//
//  Synopsis:   Returns an instance of the standard IMarshal aggregated
//              into the specifed object.
//
//  Arguements: [punkOuter] - outer object's controlling IUnknown
//              [dwFlags] - flags (HANDLER | SERVER)
//              [ppUnkInner] - where to return the inner IUnknown
//
//  Algorithm:  lookup or create a CStdIdentity (and CStdMarshal) for
//              the object.
//
//  Notes:      On the client side, the outer IUnknown must be the
//              CStdIdentity object.
//
//  History:    16-Nov-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDAPI CoGetStdMarshalEx(IUnknown *punkOuter, DWORD dwFlags, IUnknown **ppUnkInner)
{
    ComDebOut((DEB_MARSHAL,"CoGetStdMarshalEx pUnkOuter:%x dwFlags:%x ppUnkInner:%x\n",
               punkOuter, dwFlags, ppUnkInner));

    // validate the input parameters
    if ( !IsValidInterface(punkOuter) ||
        (dwFlags != SMEXF_HANDLER && dwFlags != SMEXF_SERVER) ||
         ppUnkInner == NULL )
    {
        return (E_INVALIDARG);
    }

    // init the out parameters
    *ppUnkInner = NULL;

    HRESULT hr = InitChannelIfNecessary();
    if ( FAILED(hr) )
        return (hr);


    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown, &punkOuter);

    // determine if the punkOuter is our Identity object. This has
    // to be done for both the client and server side in order to
    // determine if the dwFlags parameter is correct.

    CStdIdentity *pStdId;
    hr = punkOuter->QueryInterface(IID_IStdIdentity, (void **)&pStdId);
    if (SUCCEEDED(hr))
    {
        if (dwFlags == SMEXF_HANDLER)
        {
            // client (handler) requested.
            // pUnkOuter is AggID, return the inner IUnknown
            *ppUnkInner = pStdId->GetInternalUnk();
            (*ppUnkInner)->AddRef();
        }
        else
        {
            // requesting SMEXF_SERVER when the controlling unknown
            // is the client AggID. Not legal (would cause an infinite recursion).
            hr = E_INVALIDARG;
        }

        pStdId->Release();
    }
    else
    {
        if (dwFlags == SMEXF_SERVER)
        {
            // server side.  First, get the real controlling unknown, since
            // the app may have passed in some other interface.
            IUnknown *pUnkRealOuter = NULL;
            hr = punkOuter->QueryInterface(IID_IUnknown, (void **)&pUnkRealOuter);
            if (SUCCEEDED(hr))
            {
                // We put a reference on the StdId so that the ID does not get
                // disconnected when the last external Release occurs.
                hr = GetStdId(pUnkRealOuter, ppUnkInner);
                pUnkRealOuter->Release();
            }
        }
        else
        {
            // requesting SMEXF_HANDLER when the controlling unknown is NOT
            // the AggId.
            hr = E_INVALIDARG;
        }
    }

    ComDebOut((DEB_MARSHAL, "CoGetStdMarshalEx: ppUnkInner:%x hr:%x\n", *ppUnkInner, hr));
    return (hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoGetStandardMarshal, public
//
//  Synopsis:   Returns an instance of the standard IMarshal for the
//              specifed object.
//
//  Algorithm:  lookup or create a CStdIdentity (and CStdMarshal) for
//              the object.
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//              20-Feb-95   Rickhi      Switched to CStdMarshal
//
//--------------------------------------------------------------------
STDAPI CoGetStandardMarshal(REFIID riid, IUnknown *pUnk, DWORD dwDestCtx,
                            void *pvDestCtx, DWORD mshlflags, IMarshal **ppMarshal)
{
    ComDebOut((DEB_MARSHAL,
        "CoGetStandardMarshal riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
        &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));

    // validate the input parameters
    if (ppMarshal == NULL ||
        FAILED(ValidateMarshalFlags(dwDestCtx, pvDestCtx, mshlflags)))
    {
        return E_INVALIDARG;
    }

    *ppMarshal = NULL;

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    if (pUnk == NULL)
    {
        // this is the unmarshal side. any instance will do so we return
        // the static one. Calling UnmarshalInterface will return the real
        // proxy.

        hr = GetStaticUnMarshaler(ppMarshal);
    }
    else
    {
        // this is the marshal side. We put a strong reference on the StdId
        // so that the ID does not get disconnected when the last external
        // Release occurs.

        CALLHOOKOBJECT(S_OK,CLSID_NULL,riid,&pUnk);

        DWORD dwFlags = IDLF_CREATE;
        if (mshlflags & MSHLFLAGS_NOPING)
        {
            // requesting NOPING, so set the IDL flags accordingly
            dwFlags |= IDLF_NOPING;
        }

        // Initialize TLS.  We'll need this if this is an FTM object.
        //
        HRESULT hr2;
        COleTls tls(hr2);

        // Create a variable for the supplied flags.  We'll need to modify
        // them if this is an FTM object.
        //
        DWORD dwMrshlFlags = dwFlags;

        // Ok, find out if this object aggregates the FTM.  If it does,
        // we need to switch the thread to the NA to create the StdId.
        //
        CObjectContext* pSavedCtx = NULL;
        BOOL fFTM = FALSE;
        IMarshal* pIM = NULL;
        if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshal, (void **)&pIM)))
        {
            IUnknown* pJunk = NULL;
            if (SUCCEEDED(pIM->QueryInterface(IID_IStdFreeMarshal, (void**)&pJunk)))
            {
                // This is an FTM object.  Set the flag indicating so, verify that
                // we have valid TLS info, and switch the thread to the NA.
                fFTM = TRUE;

                dwMrshlFlags |=  IDLF_FTM;

                if (FAILED(hr2))
                    return (hr2);

                // Switch to the default context of NTA
                pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
            }

            // Release the IMarshal interface.
            //
            pIM->Release();
        }

        // Create the StdId object.  We may be in the NA now if the supplied punk
        // is an FTM object and the dwDestCtx is OOP.
        //
        CStdIdentity *pStdId;
        hr = ObtainStdIDFromUnk(pUnk, GetCurrentApartmentId(), GetCurrentContext(),
                                                        dwMrshlFlags, &pStdId);
        *ppMarshal = (IMarshal *)pStdId;

        // If the supplied object aggregates the FTM, make sure we leave in the
        // same apartment we arrived in.
        //
        if (fFTM)
        {
            CObjectContext *pDefaultNTACtx = LeaveNTA(pSavedCtx);
            Win4Assert(g_pNTAEmptyCtx == pDefaultNTACtx);
        }
    }

    ComDebOut((DEB_MARSHAL, "CoGetStandardMarshal: pIM:%x hr:%x\n",
               *ppMarshal, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   EnsureLegacySupport,    INTERNAL
//
//  synopsis:   Ensures backward compatibility by making the changes
//              needed to support legacy objects that are not context
//              aware
//
//  History:    21-Mar-98   Gopalk      Created
//
//--------------------------------------------------------------------
BOOL EnsureLegacySupport(IUnknown *pUnk, DWORD &dwDestCtx, void *&pvDestCtx)
{
    BOOL fLegacy = FALSE;

    // Check destination context
    if (dwDestCtx == MSHCTX_CROSSCTX || pvDestCtx)
    {
        IMarshal2 *pIM2;
        HRESULT hr = pUnk->QueryInterface(IID_IMarshal2, (void **) &pIM2);
        if (FAILED(hr))
        {
            // Make legacy support changes
            if (dwDestCtx == MSHCTX_CROSSCTX)
                dwDestCtx = MSHCTX_INPROC;

            if (pvDestCtx)
            {
                Win4Assert(dwDestCtx == MSHCTX_DIFFERENTMACHINE);
                pvDestCtx = NULL;
            }
            fLegacy = TRUE;
        }
        else
        {
            pIM2->Release();
        }
    }

    return (fLegacy);
}

//+-------------------------------------------------------------------
//
//  Class:      CDestObjectWrapper, private
//
//  Synopsis:   wraps the CDestObject wrapper to pass to context marshalers
//              carries along an IContextMarshaler they use to call back
//              into us.
//
//  Interfaces: IDestInfo - delegates to receieved CDestObject
//              IContextMarshaler - does the "rest" of CoMarshalInterface
//                                  and CoGetMarshalSizeMax
//
//  History:    01-May-98   SteveSw             Created
//
//--------------------------------------------------------------------
class CDestObjectWrapper : public IDestInfo, IContextMarshaler
{
public:
    //  Constructors and destructors
    CDestObjectWrapper(void* pvDestCtx) : m_cRef(1), m_pIDI(NULL)
    {
        if (pvDestCtx != NULL)
        {
            (void) ((IUnknown*) pvDestCtx)->QueryInterface(IID_IDestInfo, (void**) &m_pIDI);
        }
    }
    ~CDestObjectWrapper()
    {
        if (m_pIDI != NULL)
        {
            m_pIDI->Release();
        }
    }

//  IUnknown interface
public:
    STDMETHOD(QueryInterface)(REFIID riid, void** ppvoid);
    STDMETHOD_(ULONG,AddRef)(void)
    {
        return (InterlockedIncrement(&m_cRef));
    }
    STDMETHOD_(ULONG,Release)(void)
    {
        // these guys are always allocated on the stack
        // so don't delete them here
        return InterlockedDecrement(&m_cRef);
    }

//  IDestInfo interface
public:
    STDMETHOD(GetComVersion)(COMVERSION &cv)
    {
        return (m_pIDI ? m_pIDI->GetComVersion(cv) : E_NOTIMPL);
    }
    STDMETHOD(SetComVersion)(COMVERSION &cv)
    {
        return (m_pIDI ? m_pIDI->SetComVersion(cv) : E_NOTIMPL);
    }
    STDMETHOD(GetDestCtx)(DWORD &dwDestCtx)
    {
        return (m_pIDI ? m_pIDI->GetDestCtx(dwDestCtx) : E_NOTIMPL);
    }
    STDMETHOD(SetDestCtx)(DWORD dwDestCtx)
    {
        return (m_pIDI ? m_pIDI->SetDestCtx(dwDestCtx) : E_NOTIMPL);
    }

//  IContextMarshaler interface
public:
    STDMETHOD(GetMarshalSizeMax) (REFIID riid,
                                  void* pv,
                                  DWORD dwDestContext,
                                  void* pvDestContext,
                                  DWORD mshlflags,
                                  DWORD* pSize);

    STDMETHOD(MarshalInterface) (IStream* pStream,
                                 REFIID riid,
                                 void* pv,
                                 DWORD dwDestContext,
                                 void* pvDestContext,
                                 DWORD mshlflags);

//  Backdoor routines
public:
    STDMETHOD_(void, GetIDestInfo) (void** ppIDI)
    {
        *ppIDI = (void*) m_pIDI;
        if ( *ppIDI != NULL )
        {
            ((IUnknown*) *ppIDI)->AddRef();
        }
    }

//  Members
private:
    LONG            m_cRef;
    IDestInfo*      m_pIDI;
};

//+-------------------------------------------------------------------
//
//  Member:     CDestObjectWrapper::QueryInterface, private
//
//  synopsis:   Standard QI() for CDestObjectWrapper
//
//  History:    01-May-98   SteveSw             Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDestObjectWrapper::QueryInterface(REFIID riid, void** ppvoid)
{
    if ( ppvoid == NULL )
    {
        //  We can't cope with bad arguments here. So we whinge.
        return (E_POINTER);
    }

    if (riid == IID_IDestInfo ||
        riid == IID_IUnknown)
    {
        //  The IUnknown is out of IDestInfo (so people who own this object can convert
        //  between the two by casting, as is done in channelb.cxx)
        *ppvoid = static_cast<IDestInfo*>(this);
    }
    else if (riid == IID_IContextMarshaler)
    {
        //  We implement IContextMarshaler
        *ppvoid = static_cast<IContextMarshaler*>(this);
    }
    else
    {
        //  Yes, we have no bananas.
        *ppvoid = NULL;
        return (E_NOINTERFACE);
    }

    (void) ((IUnknown*) *ppvoid)->AddRef();
    return (S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CDestObjectWrapper::GetMarshalSizeMax, private
//
//  synopsis:   returns max size needed to marshal the specified interface.
//
//  History:    01-May-98   SteveSw             Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDestObjectWrapper::GetMarshalSizeMax (REFIID riid,
                                                    void* pv,
                                                    DWORD dwDestCtx,
                                                    void* pvDestObjectWrapper,
                                                    DWORD mshlflags,
                                                    DWORD* pSize)
{
    ComDebOut((DEB_MARSHAL,
              "CDestObjectWrapper::GetMarshalSizeMax: riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
               &riid, pv, dwDestCtx, pvDestObjectWrapper, mshlflags));

    HRESULT hr = E_FAIL;
    IUnknown* pUnk = (IUnknown*) pv;
    IMarshal *pIM = NULL;
    void* pvDestCtx;

    *pSize = 0;

    //  Unwrap the pvDestCtx from the wrapper
    ((CDestObjectWrapper*) pvDestObjectWrapper)->GetIDestInfo(&pvDestCtx);

    if ((mshlflags & MSHLFLAGS_NO_IMARSHAL) != MSHLFLAGS_NO_IMARSHAL)
    {
        hr = pUnk->QueryInterface(IID_IMarshal, (void **)&pIM);
    }

    if (SUCCEEDED(hr) && !pIM)
    {
        Win4Assert(!"QI for IMarshal succeeded but returned NULL!");
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr))
    {        
        // Ensure legacy support
        // CODEWORK: we need to get the context based marshal flags
        // for non-legacy custom marshallers

        EnsureLegacySupport(pUnk, dwDestCtx, pvDestCtx);

        // object supports custom marshalling, ask it how much space it needs
        hr = pIM->GetMarshalSizeMax(riid, pv, dwDestCtx,
                                    pvDestCtx, mshlflags, pSize);
        pIM->Release();

        // add in the size of the stuff CoMarshalInterface will write
        *pSize += sizeof(OBJREF);
    }
    else
    {
        hr = MarshalSizeHelper(dwDestCtx, pvDestCtx, mshlflags,
                               GetCurrentContext(), TRUE, pSize);
    }

    if (pvDestCtx != NULL)
    {
        ((IDestInfo*)pvDestCtx)->Release();
    }

    ComDebOut((DEB_MARSHAL, "CDestObjectWrapper::GetMarshalSizeMax: pUnk:%x size:%x hr:%x\n",
                       pv, *pSize, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CDestObjectWrapper::MarshalInterface, private
//
//  Synopsis:   marshals the specified interface into the given stream
//
//  History:    01-May-98   SteveSw     Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDestObjectWrapper::MarshalInterface(IStream *pStm,
                                                  REFIID riid,
                                                  void* pv,
                                                  DWORD dwDestCtx,
                                                  void *pDestObjectWrapper,
                                                  DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL,
                       "CDestObjectWrapper::MarshalInterface: pStm:%x riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
                       pStm, &riid, pv, dwDestCtx, pDestObjectWrapper, mshlflags));

    HRESULT hr = E_FAIL;
    IMarshal *pIM = NULL;
    IUnknown* pUnk = (IUnknown*) pv;
    void* pvDestCtx;

    //  Unwrap the pvDestCtx from the wrapper
    ((CDestObjectWrapper*) pDestObjectWrapper)->GetIDestInfo(&pvDestCtx);

    // determine whether to do custom or standard marshaling
    if ((mshlflags & MSHLFLAGS_NO_IMARSHAL) != MSHLFLAGS_NO_IMARSHAL)
    {
        hr = ((IUnknown*)pv)->QueryInterface(IID_IMarshal, (void **)&pIM);
    }

    if (SUCCEEDED(hr))
    {
        // object supports custom marshaling, use it. we package the
        // custom data inside an OBJREF.
        Win4Assert(pIM);

        // Ensure legacy support
        EnsureLegacySupport(pUnk, dwDestCtx, pvDestCtx);

        CLSID UnmarshalCLSID;
        DWORD dwSize;

        // get the clsid for unmarshaling
        hr = pIM->GetUnmarshalClass(riid, pUnk, dwDestCtx, pvDestCtx,
                                    mshlflags, &UnmarshalCLSID);

        if ( SUCCEEDED(hr) && !IsEqualCLSID(CLSID_StdMarshal, UnmarshalCLSID) )
        {
            // get the size of data to marshal
            hr = pIM->GetMarshalSizeMax(riid, pv, dwDestCtx,
                                        pvDestCtx, mshlflags, &dwSize);
            if (SUCCEEDED(hr))
            {
                hr = WriteCustomObjrefHeaderToStream(riid, UnmarshalCLSID, dwSize, pStm);
            }
        }
        if (SUCCEEDED(hr))
        {
            // tell the marshaler to write the rest of the data
            hr = pIM->MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                       pvDestCtx, mshlflags);
        }

        pIM->Release();
    }
    else
    {
		//
        // Decide between wrapper and std marshaling.
		//
		BOOL fUseWrapper = FALSE;

		if (!(mshlflags & MSHLFLAGS_TABLEWEAK))
		{
			if (dwDestCtx == MSHCTX_CROSSCTX)
				fUseWrapper = TRUE;
			else if (dwDestCtx == MSHCTX_INPROC && IsThreadInNTA())
				fUseWrapper = TRUE;				
		}

		if (fUseWrapper)
        {
            hr = WriteCustomObjrefHeaderToStream(riid, CLSID_StdWrapper,
                                                 sizeof(XCtxMarshalData), pStm);
            // Wrapper marshaling
            if (SUCCEEDED(hr))
            {
                hr = WrapperMarshalObject(pStm, riid, pUnk, dwDestCtx, pvDestCtx,
                                          mshlflags);
            }
        }
        else
        {
            // Standard marshaling
            hr = StdMarshalObject(pStm, riid, pUnk, GetCurrentContext(),
                                  dwDestCtx, pvDestCtx, mshlflags);
        }
    }

    if (pvDestCtx != NULL)
    {
        ((IDestInfo*)pvDestCtx)->Release();
    }

    ComDebOut((DEB_MARSHAL,"CDestObjectWrapper::MarshalInterface: pUnk:%x hr:%x\n",pUnk,hr));
    return (hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoGetMarshalSizeMax, public
//
//  synopsis:   figures max size needed to marshal the specified interface
//                              by delegating to ContextMarshaler or CoDirectGetMarshalSizeMax()
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to static marshaler
//              20-Feb-95   Rickhi      Return correct sizes once again.
//              21-Mar-98   Gopalk      Simplified for context work
//              22-Apr-98   SatishT     Added support for context marshallers
//              01-May-98   SteveSw             Changed support for context marshalers
//
//--------------------------------------------------------------------
STDAPI CoGetMarshalSizeMax(ULONG *pulSize, REFIID riid, IUnknown *pUnk,
                           DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL,
              "CoGetMarshalSizeMax: riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
               &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));

    // validate the input parameters
    if (pulSize == NULL || pUnk == NULL ||
        FAILED(ValidateMarshalFlags(dwDestCtx, pvDestCtx, mshlflags)))
    {
        return E_INVALIDARG;
    }

    *pulSize = 0;

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
    {
        return (hr);
    }

    CALLHOOKOBJECT(S_OK,CLSID_NULL,riid,&pUnk);

    //  Here we delegate to the context marshaler, if it's there. We
    //  create a wrapper around the destObject that maintains its
    //  interfaces but adds an IContextMarshaler, which the context
    //  marshaler will use to get back into our code. If there's no
    //  context marshaler, we just go ahead and do what the context
    //  marshaler would have done, call back into the wrapper for
    //  the "real" work.

    IContextMarshaler *pICM = NULL;
    hr = (GetCurrentContext())->GetContextMarshaler(&pICM);
    Win4Assert(hr == S_OK);

    CDestObjectWrapper DOW(pvDestCtx);

    if (pICM != NULL)
    {
        hr = pICM->GetMarshalSizeMax(riid, (void*) pUnk, dwDestCtx,
                                     (void*) &DOW, mshlflags, pulSize);
        *pulSize += sizeof(OBJREF);
        ((IUnknown*) pICM)->Release();
    }
    else
    {
        hr = DOW.GetMarshalSizeMax(riid, (void*) pUnk, dwDestCtx,
                                   (void*) &DOW, mshlflags, pulSize);
    }

    ComDebOut((DEB_MARSHAL, "CoGetMarshalSizeMax: pUnk:%x size:%x hr:%x\n",
              pUnk, *pulSize, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoMarshalInterface, public
//
//  Synopsis:   marshals the specified interface into the given stream
//                              using ContextMarshaler or CoDirectMarshalInterface
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object and
//                                      new marshaling format
//              20-Feb-95   Rickhi      switched to newer marshal format
//              21-Mar-98   Gopalk      Added support for wrapper marshalling
//              22-Apr-98   SatishT     Added support for context marshallers
//              01-May-98   SteveSw     Changed support for context marshallers
//
//--------------------------------------------------------------------
STDAPI CoMarshalInterface(IStream *pStm, REFIID riid, IUnknown *pUnk,
                          DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    ComDebOut((DEB_MARSHAL,
              "CoMarshalInterface: pStm:%x riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
               pStm, &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));

    // validate the input parameters
    HRESULT hr = ValidateMarshalParams(pStm, pUnk, dwDestCtx, pvDestCtx, mshlflags);
    if (FAILED(hr))
        return hr;

    hr = InitChannelIfNecessary();
    if (FAILED(hr))
    {
        return (hr);
    }

    CALLHOOKOBJECT(S_OK,CLSID_NULL,riid,(IUnknown **)&pUnk);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pStm);

    //  Here we delegate to the context marshaler, if it's there. We
    //  create a wrapper around the destObject that maintains its
    //  interfaces but adds an IContextMarshaler, which the context
    //  marshaler will use to get back into our code. If there's no
    //  context marshaler, we just go ahead and do what the context
    //  marshaler would have done, call back into the wrapper for
    //  the "real" work.

    IContextMarshaler *pICM = NULL;
    hr = (GetCurrentContext())->GetContextMarshaler(&pICM);
    Win4Assert(hr == S_OK);

    CDestObjectWrapper DOW(pvDestCtx);

    if (pICM != NULL)
    {
        hr = pICM->MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                   (void*) &DOW, mshlflags);
        ((IUnknown*) pICM)->Release();
    }
    else
    {
        hr = DOW.MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                  (void*) &DOW, mshlflags);
    }

    ComDebOut((DEB_MARSHAL,"CoMarshalInterface: pUnk:%x hr:%x\n",pUnk,hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   WriteCustomObjrefHeaderToStream
//
//  Synopsis:   Crafts up a header for a custom OBJREF and writes it
//              to a stream.
//
//  History:    24-Apr-97   MattSmit          Created
//
//--------------------------------------------------------------------
HRESULT WriteCustomObjrefHeaderToStream(REFIID riid, REFCLSID rclsid, DWORD dwSize, IStream *pStm)
{
    OBJREF objref;

    objref.signature = OBJREF_SIGNATURE;
    objref.flags     = OBJREF_CUSTOM;
    objref.iid       = riid;
    ORCST(objref).clsid     = rclsid;
    ORCST(objref).size      = dwSize;

    // currently we dont write any extensions into the custom
    // objref. The provision is there so we can do it in the
    // future, for example,  if the unmarshaler does not have the
    // unmarshal class code available we could to provide a callback
    // mechanism by putting the OXID, and saResAddr in there.
    ORCST(objref).cbExtension = 0;

    // write the objref header info into the stream
    ULONG cbToWrite = PtrToUlong( (LPVOID)( (BYTE *)(&ORCST(objref).pData) - (BYTE *)&objref ) );
    return (pStm->Write(&objref, cbToWrite, NULL));
}

//+-------------------------------------------------------------------
//
//  Function:   GetCustomUnmarshaler, private
//
//  Synopsis:   Creates the custom unmarshaler of the given clsid.  Checks
//              for common known clsid's first. Goes through CCI if not
//              one of the known clsids. Called by CoUnmarshalInterface
//              and CoReleaseMarshalData.
//
//  History:    14-Jan-99   Rickhi      Made into common subroutine
//
//--------------------------------------------------------------------
HRESULT GetCustomUnmarshaler(REFCLSID rclsid, IStream *pStm, IMarshal **ppIM)
{
    HRESULT hr;

    if (InlineIsEqualGUID(CLSID_StdWrapper, rclsid))
    {
        hr = GetStaticWrapper(ppIM);
    }
    else if (InlineIsEqualGUID(CLSID_InProcFreeMarshaler, rclsid))
    {
        hr = GetInProcFreeMarshaler(ppIM);
    }
    else if (InlineIsEqualGUID(CLSID_ContextMarshaler, rclsid))
    {
        hr = GetStaticContextUnmarshal(ppIM);
    }
    else if (InlineIsEqualGUID(CLSID_AggStdMarshal, rclsid))
    {
        hr = FindAggStdMarshal(pStm, ppIM);
    }
    else
    {
        DWORD dwFlags = CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD;
        dwFlags |= (gCapabilities & EOAC_NO_CUSTOM_MARSHAL)
                                  ? CLSCTX_NO_CUSTOM_MARSHAL : 0;

        hr = CoCreateInstance(rclsid, NULL, dwFlags, IID_IMarshal,
                              (void **)ppIM);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoUnmarshalInterface, public
//
//  Synopsis:   Unmarshals a marshaled interface pointer from the stream.
//
//  Notes:      when a controlling unknown is supplied, it is assumed that
//              the HANDLER for the class has done a CreateInstance and wants
//              to aggregate just the proxymanager, ie. we dont want to
//              instantiate a new class handler (the default unmarshalling
//              behaviour).
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to static marshaler and
//                                      new marshaling format
//              20-Feb-95   Rickhi      switched to newer marshal format
//
//--------------------------------------------------------------------
STDAPI CoUnmarshalInterface(IStream *pStm, REFIID riid, void **ppv)
{
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pStm);
    ComDebOut((DEB_MARSHAL,
              "CoUnmarshalInterface: pStm:%x riid:%I\n", pStm, &riid));

    // validate the input parameters
    if (pStm == NULL || ppv == NULL)
    {
        return (E_INVALIDARG);
    }

    *ppv = NULL;

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    // read the objref from the stream.
    OBJREF  objref;
    hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        if (objref.flags & OBJREF_CUSTOM)
        {
            // uses custom marshaling, create an instance and ask that guy
            // to do the unmarshaling. special case createinstance for the
            // freethreaded marshaler and aggregated standard marshaler.

            COleTls tls(hr);
            if (SUCCEEDED (hr))
            {
                // Watch out for infinite loops - custom marshallers can themselves
                // be custom marshalled, so the potential exists for the sort of
                // hang/stack overflow that unwise ISVs call PSS about.

                if (tls->cCustomMarshallerRecursion == MAX_CUSTOM_MARSHALLER_RECURSION)
                {
                    hr = E_ABORT;
                }
                else
                {
                    IMarshal *pIM = NULL;

                    tls->cCustomMarshallerRecursion ++;
                    hr = GetCustomUnmarshaler(ORCST(objref).clsid, pStm, &pIM);
                    tls->cCustomMarshallerRecursion --;

                    if (SUCCEEDED(hr))
                    {
                        hr = pIM->UnmarshalInterface(pStm, objref.iid, ppv);
                        pIM->Release();
                    }
                    else
                    {
                        // seek past the custom marshalers data so we leave the
                        // stream at the correct position.

                        LARGE_INTEGER libMove;
                        libMove.LowPart  = ORCST(objref).size;
                        libMove.HighPart = 0;
                        pStm->Seek(libMove, STREAM_SEEK_CUR, NULL);
                    }
                }
            }
        }
        else
        {
            // uses standard marshaling, call API to find or create the
            // instance of CStdMarshal for the oid inside the objref, and
            // ask that instance to unmarshal the interface. This covers
            // handler unmarshaling also.

            hr = UnmarshalObjRef(objref, ppv);
        }

        // free the objref we read above
        FreeObjRef(objref);

        if (!InlineIsEqualGUID(riid, GUID_NULL) &&
            !InlineIsEqualGUID(riid, objref.iid) && SUCCEEDED(hr) )
        {
            // the interface iid requested was different than the one that
            // was marshaled (and was not GUID_NULL), so go get the requested
            // one and release the marshaled one. GUID_NULL is used by the Ndr
            // unmarshaling engine and means return whatever interface was
            // marshaled.

            IUnknown *pUnk = (IUnknown *)*ppv;

            hr = pUnk->QueryInterface(riid, ppv);
            pUnk->Release();
        }
    }

    ComDebOut((DEB_MARSHAL, "CoUnmarshalInterface: pUnk:%x hr:%x\n",
                       *ppv, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoReleaseMarshalData, public
//
//  Synopsis:   release the reference created by CoMarshalInterface
//
//  Algorithm:
//
//  History:    23-Nov-92   Rickhi
//              11-Dec-93   CraigWi     Switched to static marshaler and
//                                      new marshaling format
//              20-Feb-95   Rickhi      switched to newer marshal format
//
//--------------------------------------------------------------------
STDAPI CoReleaseMarshalData(IStream *pStm)
{
    ComDebOut((DEB_MARSHAL, "CoReleaseMarshalData pStm:%x\n", pStm));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **) &pStm);

    // validate the input parameters
    if (pStm == NULL)
    {
        return (E_INVALIDARG);
    }

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    // read the objref from the stream.
    OBJREF  objref;
    hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        if (objref.flags & OBJREF_CUSTOM)
        {
            // object uses custom marshaling. create an instance of the
            // unmarshaling code and ask it to release the marshaled data.

            IMarshal *pIM;
            hr = GetCustomUnmarshaler(ORCST(objref).clsid, pStm, &pIM);

            if (SUCCEEDED(hr))
            {
                hr = pIM->ReleaseMarshalData(pStm);
                pIM->Release();
            }
            else
            {
                // seek past the custom marshalers data so we leave the
                // stream at the correct position.

                LARGE_INTEGER libMove;
                libMove.LowPart  = ORCST(objref).size;
                libMove.HighPart = 0;
                pStm->Seek(libMove, STREAM_SEEK_CUR, NULL);
            }
        }
        else
        {
            hr = ReleaseMarshalObjRef(objref);
        }

        // free the objref we read above
        FreeObjRef(objref);
    }

    ComDebOut((DEB_MARSHAL, "CoReleaseMarshalData hr:%x\n", hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoDisconnectObject, public
//
//  synopsis:   disconnects all clients of an object by marking their
//              connections as terminted abnormaly.
//
//  History:    04-Oct-93   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//
//--------------------------------------------------------------------
STDAPI CoDisconnectObject(IUnknown *pUnk, DWORD dwReserved)
{
    ComDebOut((DEB_MARSHAL, "CoDisconnectObject pUnk:%x dwRes:%x\n",
                       pUnk, dwReserved));

    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    // validate the input parameters
    if (pUnk == NULL || dwReserved != 0)
    {
        return (E_INVALIDARG);
    }

    if (!IsValidInterface(pUnk))
        return (E_INVALIDARG);

    if (!IsApartmentInitialized())
    {
        return (CO_E_NOTINITIALIZED);
    }

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown,&pUnk);

    IMarshal *pIM = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IMarshal, (void **)&pIM);

    if (FAILED(hr))
    {
        // object does not support IMarshal directly. Find its standard
        // marshaler if there is one, otherwise return an error.

        IUnknown *pServer;
        hr = pUnk->QueryInterface(IID_IUnknown, (void **) &pServer);
        if (SUCCEEDED(hr))
        {
            CIDObject *pID = NULL;
            CObjectContext* pContext = GetCurrentContext();
	    CStdIdentity *pStdID = NULL;			
            // Because it so common for folks to call CoDisconnectObject
            // when their dll gets unloaded (think ATL here), we check 
            // for a NULL current context here.   
            if (pContext)
            {
                LOCK(gComLock);
                pID = gPIDTable.Lookup(pServer, pContext);
		if ( pID )
		{
		    pStdID = pID->GetStdID();
		    if ( pStdID )
		    {
		       pStdID->AddRef();
		    }
		}
                UNLOCK(gComLock);
            }
            if ( pID )
            {
		if ( pStdID )
                {
                    hr = pStdID->DisconnectObject(0);
                    pStdID->Release();
                }
                if ( SUCCEEDED(hr) )
                {
                    CStdWrapper *pWrapper = pID->GetWrapper();
                    if ( pWrapper )
                    {
                        pWrapper->InternalAddRef();
                        hr = pWrapper->DisconnectObject(0);
                        pWrapper->InternalRelease(NULL);
                    }
                }

                // Release the ID object
                pID->Release();
            }

            // Release the server object
            pServer->Release();
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = pIM->DisconnectObject(dwReserved);
        pIM->Release();
    }

    ComDebOut((DEB_MARSHAL,"CoDisconnectObject pIM:%x hr:%x\n", pIM, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoLockObjectExternal, public
//
//  synopsis:   adds/revokes a strong reference count to/from the
//              identity for the given object.
//
//  parameters: [punkObject] - IUnknown of the object
//              [fLock] - lock/unlock the object
//              [fLastUR] - last unlock releases.
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//
//--------------------------------------------------------------------
STDAPI  CoLockObjectExternal(IUnknown *pUnk, BOOL fLock, BOOL fLastUR)
{
    ComDebOut((DEB_MARSHAL,
        "CoLockObjectExternal pUnk:%x fLock:%x fLastUR:%x\n", pUnk, fLock, fLastUR));

    if (!IsValidInterface(pUnk))
        return (E_INVALIDARG);

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown,(IUnknown **)&pUnk);

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    DWORD dwFlags = fLock ? IDLF_CREATE : 0;

    // Initialize TLS.  We'll need this if this is an FTM object.
    //
    HRESULT hr2;
    COleTls tls(hr2);

    // Ok, find out if this object aggregates the FTM.  If it does,
    // we need to switch the thread to the NA to create the StdId.
    //
    CObjectContext* pSavedCtx = NULL;
    BOOL fFTM = FALSE;
    IMarshal* pIM = NULL;
    if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshal, (void **)&pIM)))
    {
        IUnknown* pJunk = NULL;
        if ( SUCCEEDED(pIM->QueryInterface(IID_IStdFreeMarshal, (void**)&pJunk)) )
        {
            // This is an FTM object.  Set the flag indicating so, verify that
            // we have valid TLS info, and switch the thread to the NA.
            //
            fFTM = TRUE;

            dwFlags |= IDLF_FTM;

            if (FAILED(hr2))
                return (hr2);

            // Switch to the default context of NTA
            pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
        }

        // Release the IMarshal interface.
        //
        pIM->Release();
    }

    CStdIdentity *pStdID;
    hr = ObtainStdIDFromUnk(pUnk, GetCurrentApartmentId(),
                            GetCurrentContext(),
                            dwFlags,
                            &pStdID);

    // If the supplied object aggregates the FTM, make sure we leave in the
    // same apartment we arrived in.
    //
    if (fFTM)
    {
        CObjectContext *pDefaultNTACtx = LeaveNTA(pSavedCtx);
        Win4Assert(g_pNTAEmptyCtx == pDefaultNTACtx);
    }

    switch (hr)
    {
    case S_OK:
        // REF COUNTING: inc or dec external ref count
        hr = pStdID->LockObjectExternal(fLock, fLastUR);
        pStdID->Release();
        break;

    case CO_E_OBJNOTREG:
        // unlock when not registered; 16bit code returned NOERROR;
        // disconnected handler goes to S_OK case above.
        hr = S_OK;
        break;

    case E_OUTOFMEMORY:
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    ComDebOut((DEB_MARSHAL, "CoLockObjectExternal pStdID:%x hr:%x\n", pStdID, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoIsHandlerConnected, public
//
//  Synopsis:   Returns whether or not handler is connected to remote
//
//  Algorithm:  QueryInterface to IProxyManager. If this is supported,
//              then this is a handler. We ask the handler
//              for its opinion otherwise we simply return TRUE.
//
//  History:    04-Oct-93   Rickhi      Created
//
//  Notes:      The answer of this routine may be wrong by the time
//              the routine returns.  This is correct behavior as
//              this routine is primilary to cleanup state associated
//              with connections.
//
//--------------------------------------------------------------------
STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk)
{
    // validate input parameters
    if (!IsValidInterface(pUnk))
        return (FALSE);

    // Assume it is connected
    BOOL fResult = TRUE;

    // Handler should support IProxyManager
    IProxyManager *pPM;
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown,(IUnknown **)&pUnk);
    if (SUCCEEDED(pUnk->QueryInterface(IID_IProxyManager, (void **)&pPM)))
    {
        // We have something that thinks its is an Ole handler so we ask
        fResult = pPM->IsConnected();
        pPM->Release();
    }

    return (fResult);
}

//+-------------------------------------------------------------------
//
//  Function:   GetStaticUnMarshaler, private
//
//  Synopsis:   Returns the static instance of the CStdMarshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      The standard marshaler must be able to resolve identity, that
//              is two proxies for the same object must never be created in
//              the same apartment. Given that, it makes sense to let the
//              standard guy do the unmarshaling. Since we dont know the
//              identity of the object upfront, and any instance will do, we
//              use a static instance to handle unmarshal.
//
//--------------------------------------------------------------------
INTERNAL GetStaticUnMarshaler(IMarshal **ppIM)
{
    HRESULT hr = S_OK;

    if (gpStdMarshal == NULL)
    {
		IMarshal *pTemp = NULL;
		
        // the global instance has not been created yet, so go make it now.
        hr = CreateIdentityHandler(NULL,
                                   STDID_CLIENT |
                                   STDID_FREETHREADED |
                                   STDID_SYSTEM |
                                   STDID_LOCKEDINMEM,
                                   NULL,
                                   GetCurrentApartmentId(),
                                   IID_IMarshal,
                                   (void **)&pTemp);

		// Only allow one thread to set gpStdMarshal
        if(InterlockedCompareExchangePointer((void **)&gpStdMarshal,pTemp,NULL)!=NULL)
        {
	        ((CStdIdentity *) pTemp)->UnlockAndRelease();
        }
    }
	
    *ppIM = gpStdMarshal;
    if (gpStdMarshal)
    {
        gpStdMarshal->AddRef();
    }
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   GetIIDFromObjRef, private
//
//  Synopsis:   Returns the IID embedded inside a marshaled interface
//              pointer OBJREF. Needed by the x86 thunking code and
//              NDR marshaling engine.
//
//  History:    10-Oct-97   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT GetIIDFromObjRef(OBJREF &objref, IID **piid)
{
    // check to ensure the objref is at least partially sane
    if ((objref.signature != OBJREF_SIGNATURE) ||
        (objref.flags & OBJREF_RSRVD_MBZ)      ||
        (objref.flags == 0) )
    {
        // the objref signature is bad, or one of the reserved
        // bits in the flags is set, or none of the required bits
        // in the flags is set. the objref cant be interpreted so
        // fail the call.

        Win4Assert(!"Invalid Objref Header");
        return (RPC_E_INVALID_OBJREF);
    }

    // extract the IID
    *piid = &objref.iid;
    return (S_OK);
}


//+-------------------------------------------------------------------
//
//  Function:   CoDeactivateObject         public
//
//  Synopsis:   Releases all the references kept on the given object
//              without tearing down the stub manager and wrapper
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDAPI CoDeactivateObject(IUnknown *pUnk, IUnknown **ppCookie)
{
    ContextDebugOut((DEB_ACTDEACT, "CoDeactivateObject pUnk:%x\n", pUnk));

    // Initialize return value.
    *ppCookie = NULL;

    // Obtain the identity of the server
    IUnknown *pServer;
    HRESULT hr = pUnk->QueryInterface(IID_IUnknown, (void **) &pServer);
    if (SUCCEEDED(hr))
    {
        hr = CO_E_OBJNOTCONNECTED; // assume already disconnected.

        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        // Lookup the IDObject representing the server
        CIDObject *pID = gPIDTable.Lookup(pServer, GetCurrentContext());

        if (pID)
        {
            // deactivate the IDObject, releases the lock
            hr = pID->Deactivate();
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (SUCCEEDED(hr))
            {
                // set the return parameter, caller now owns the
                // IDObject reference.
                *ppCookie = pID;
                pID = NULL;
            }
            else
            {
                pID->Release();
            }
        }
        else
        {
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }

        pServer->Release();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    ContextDebugOut((DEB_ACTDEACT,
            "CoDeactivateObject hr:0x%x cookie:%x\n", hr, *ppCookie));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoReactivateObject         public
//
//  Synopsis:   Reconnects the given object to the stub manager and
//              wrapper specified by the IDObject
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDAPI CoReactivateObject(IUnknown *pUnk, IUnknown *pCookie)
{
    ContextDebugOut((DEB_ACTDEACT,
            "CoReactivateObject pUnk:%x cookie:%x\n", pUnk, pCookie));
    ASSERT_LOCK_NOT_HELD(gComLock);
    
    // Validate params
    if (pCookie == NULL || pUnk == NULL)
        return E_INVALIDARG;

    // Ensure that the cookie is indeed an IDObject
    CIDObject *pID;
    HRESULT hr = pCookie->QueryInterface(IID_IStdIDObject, (void **) &pID);
    if (SUCCEEDED(hr))
    {
        // Obtain the identity of the server
        IUnknown *pServer;
        hr = pUnk->QueryInterface(IID_IUnknown, (void **) &pServer);
        if (SUCCEEDED(hr))
        {
            hr = pID->Reactivate(pServer);
            pServer->Release();
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        pID->Release();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_ACTDEACT, "CoReactivateObject hr 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoAllowSetForegroundWindow  public
//
//  Synopsis:   Grants foreground transfer permissions to the server
//              process of an object from the client process.
//
//  Algorithm:  Queries the pUnk for IForegroundTransfer and calls
//              the AllowForegroundTransfer method on it.
//
//  History:    02-Feb-99   MPrabhu     Created
//
//+-------------------------------------------------------------------

STDAPI CoAllowSetForegroundWindow(IUnknown *pUnk, void* lpvReserved)
{
    HRESULT hr;
    IForegroundTransfer *pFGT = NULL;

    // validate input parameters
    if (!IsValidInterface(pUnk) || (lpvReserved!=NULL))
        return (E_INVALIDARG);

    hr = pUnk->QueryInterface(IID_IForegroundTransfer, (void **)&pFGT);

    if (SUCCEEDED(hr))
    {
        Win4Assert(pFGT);
        hr = pFGT->AllowForegroundTransfer(lpvReserved);
        pFGT->Release();
    }
    else
    {
        hr = (E_NOINTERFACE);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   DcomChannelSetHResult  public
//
//  Synopsis:   COM+ services requires that policies registered to
//              receive event notifications on calls to configured
//              classes have access to the actual HRESULT returned by
//              called methods. Because the server's HRESULT cannot be
//              safely fetched from the reply buffer, RPC uses this
//              API to supply us with the HRESULT, which we ship back
//              to the other side using the context extents.
//
//  Algorithm:  If the call is on an object of a configured class,
//              the supplied HRESULT is stored in the context call
//              object in TLS.
//
//  History:    27-Mar-99   Johnstra     Created
//              21-Feb-01   JSimmons     Modifed to accept a NULL first
//                                       parameter - in this case we now
//                                       try to store the hresult in tls.
//
//  Notes:   This function is (as of whistler) defined in objbase.h with
//     the signature below.   RPCRT4 is calling this api as well (since 
//     W2K) but they expect the first parameter to be an RPCOLEMESSAGE*, 
//     hence the cast in the code below.   
//
//+-------------------------------------------------------------------
STDAPI DcomChannelSetHResult(
    LPVOID         pvRpcOleMsg,      
    ULONG         *pReserve,
    HRESULT        appsHR
    )
{
    RPCOLEMESSAGE* pMsg = (RPCOLEMESSAGE*)pvRpcOleMsg;

    if (NULL == pMsg)
    {
        // This is the case where somebody
        // other than RPC is calling us
        return PrivSetServerHRESULTInTLS(pReserve, appsHR);
    }

    // If no call object, punt.
    if (pMsg->reserved1 == NULL)
        return S_OK;

    // If the supplied HRESULT is S_OK, don't do anything.  Only
    // non-S_OK return codes are relevant.
    if (appsHR != S_OK)
        return PrivSetServerHResult(pMsg, pReserve, appsHR);
        
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Function:   CoInvalidateRemoteMachineBindings
//
//  Synopsis:   API to provide users a way to flush the SCM's remote
//              binding handle cache.    pszMachineName can be "" which
//              means flush the entire cache.    
//
//  Algorithm:  Verify non-NULL arguments, then pass call on to the resolver.
//
//  History:    21-May-00   JSimmons   Created
//
//+-------------------------------------------------------------------
STDAPI CoInvalidateRemoteMachineBindings(
                LPOLESTR pszMachineName
                )
{	
    if (!pszMachineName)
        return E_INVALIDARG;

    // Pass call on to the resolver
    return gResolver.FlushSCMBindings(pszMachineName);
}


//+-------------------------------------------------------------------
//
//  Function:   CoRetireServer  (this api is currently unpublished!)
//
//  Synopsis:   API that when called immediately marks the specified
//              process as no longer eligible for activations.  COM+ 
//              uses this api to support their process recycling feature.
//              SCM will check that we are an administrator, or call will
//              fail.
//
//  Algorithm:  Verify arg is non-NULL, then pass call on to the
//              resolver.
//
//  History:    21-May-00   JSimmons   Created
//
//+-------------------------------------------------------------------
STDAPI CoRetireServer(
                GUID* pguidProcessIdentifier
                )
{
    if (!pguidProcessIdentifier)
        return E_INVALIDARG;
    
    return gResolver.RetireServer(pguidProcessIdentifier);
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetProcessIdentifier  (this api is currently unpublished!)
//
//  Synopsis:   API to retrieve this process's RPCSS-allocated guid identifier.
//
//  Algorithm:  Verify arg is non-NULL, then pass call on to the
//              resolver.
//
//  History:    24-May-00   JSimmons   Created
//
//+-------------------------------------------------------------------
STDAPI CoGetProcessIdentifier(
                GUID* pguidProcessIdentifier
                )
{
    if (!pguidProcessIdentifier)
        return E_INVALIDARG;
    
	*pguidProcessIdentifier = *gResolver.GetRPCSSProcessIdentifier();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetContextToken
//
//  Synopsis:   Gets a context token as fast as possible.
//
//  History:    10-Nov-00   ddriver   Created
//
//+-------------------------------------------------------------------
STDAPI CoGetContextToken(ULONG_PTR* pToken)
{
    if(!pToken) return(E_POINTER);

    // This makes sure TLS is initialized:
    if (!IsApartmentInitialized())
    {
        return (CO_E_NOTINITIALIZED);
    }

    *pToken = (ULONG_PTR)(IObjContext*)(GetCurrentContext());
    ASSERT(*pToken);

    return(S_OK);
}



//+-------------------------------------------------------------------
//
//  Function:   CoGetDefaultContext           public
//
//  Synopsis:   Obtains the default object context for specified
//              apartment. 
//
//  History:    13-Jan-2000 a-sergiv    Created
//              28-Mar-2001 JohnDoty    Modified slightly-- now takes
//                                      an APTTYPE to indicate which
//                                      apartment, supports getting
//                                      specific context.
//
//+-------------------------------------------------------------------
STDAPI CoGetDefaultContext(APTTYPE aptType, REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_POLICYSET, "CoGetDefaultContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Initialize
    *ppv = NULL;

    // Cannot ask for STA directly-- what STA do you mean?
    if (aptType == APTTYPE_STA)
        return E_INVALIDARG;

    // Initalize channel
    hr = InitChannelIfNecessary();
    if(SUCCEEDED(hr))
    {
        COleTls tls;

        if(aptType == APTTYPE_CURRENT)
        {
            if (tls.IsNULL())
            {
                // No TLS, must be in implicit MTA (if anywhere)
                aptType = APTTYPE_MTA;
            }
            else
            {
                APTKIND aptKind = GetCurrentApartmentKind(tls);
                switch (aptKind)
                {
                case APTKIND_APARTMENTTHREADED: aptType = APTTYPE_STA; break;
                case APTKIND_MULTITHREADED:     aptType = APTTYPE_MTA; break;
                case APTKIND_NEUTRALTHREADED:   aptType = APTTYPE_NA;  break;
                }
            }
        }
        
        CObjectContext *pDefCtx = NULL;
            
        switch(aptType)
        {
        case APTTYPE_MTA:
            pDefCtx = g_pMTAEmptyCtx;
            break;
            
        case APTTYPE_NA:
            pDefCtx = g_pNTAEmptyCtx;
            break;
            
        case APTTYPE_MAINSTA:
            // Get the TLS for the main STA.
            if (gdwMainThreadId)
            {
                SOleTlsData *pMainTls = TLSLookupThreadId(gdwMainThreadId);
                if (pMainTls)
                {
                    pDefCtx = pMainTls->pEmptyCtx;
                }
                //TODO: Assert if NULL?  The main thread should have TLS,
                //      since it's initialized.
            }
            break;

        case APTTYPE_STA:
            // TLS had better be there.. see how we resolve aptType.
            // We cannot get here without having tls.
            Win4Assert(!tls.IsNULL()); 
            pDefCtx = tls->pEmptyCtx;
            break;

        default:
            hr = E_INVALIDARG;
            break;
        }

        if (SUCCEEDED(hr))
        {
            if (pDefCtx)
            {
                hr = pDefCtx->QueryInterface(riid, ppv);
            }
            else
            {
                hr = CO_E_NOTINITIALIZED;
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CoGetObjectContext pv:%x hr:0x%x\n", *ppv, hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\context.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       context.cxx
//
//  Contents:   Implementation of COM contexts.
//
//  Classes:    CObjectContext
//              CEnumContextProps
//              CContextPropList
//              CObjectContextFac
//
//  History:    19-Dec-97   Johnstra      Created
//              12-Nov-98   TarunA        Caching of contexts
//
//-----------------------------------------------------------------------------
#include <ole2int.h>
#include <locks.hxx>
#include <hash.hxx>
#include <pstable.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <crossctx.hxx>

extern DWORD g_cMTAInits;
extern DWORD g_cSTAInits;

ULARGE_INTEGER gNextContextId = { 0 };

//-----------------------------------------------------------------------------
// Static Member Declarations
//-----------------------------------------------------------------------------
// CObjectContext:
CPageAllocator   CObjectContext::s_CXAllocator;         // Object context allocator
BOOL             CObjectContext::s_fInitialized;        // Indicates if initialized
ULONG            CObjectContext::s_cInstances;          // Count of instances

// CContextPropList:
CPageAllocator   CContextPropList::s_NodeAllocator; // List node allocator

// CCtxTable
BOOL                CCtxTable::s_fInitialized;             // Set when the table is initialized
CCtxPropHashTable   CCtxTable::s_CtxPropHashTable;         // Hash table of contexts based on properties
CCtxUUIDHashTable   CCtxTable::s_CtxUUIDHashTable;         // Hash table of contexts based on UUID

SHashChain CCtxTable::s_CtxPropBuckets[NUM_HASH_BUCKETS] = {    // Hash buckets for the property based table
    {&s_CtxPropBuckets[0],  &s_CtxPropBuckets[0]},
    {&s_CtxPropBuckets[1],  &s_CtxPropBuckets[1]},
    {&s_CtxPropBuckets[2],  &s_CtxPropBuckets[2]},
    {&s_CtxPropBuckets[3],  &s_CtxPropBuckets[3]},
    {&s_CtxPropBuckets[4],  &s_CtxPropBuckets[4]},
    {&s_CtxPropBuckets[5],  &s_CtxPropBuckets[5]},
    {&s_CtxPropBuckets[6],  &s_CtxPropBuckets[6]},
    {&s_CtxPropBuckets[7],  &s_CtxPropBuckets[7]},
    {&s_CtxPropBuckets[8],  &s_CtxPropBuckets[8]},
    {&s_CtxPropBuckets[9],  &s_CtxPropBuckets[9]},
    {&s_CtxPropBuckets[10], &s_CtxPropBuckets[10]},
    {&s_CtxPropBuckets[11], &s_CtxPropBuckets[11]},
    {&s_CtxPropBuckets[12], &s_CtxPropBuckets[12]},
    {&s_CtxPropBuckets[13], &s_CtxPropBuckets[13]},
    {&s_CtxPropBuckets[14], &s_CtxPropBuckets[14]},
    {&s_CtxPropBuckets[15], &s_CtxPropBuckets[15]},
    {&s_CtxPropBuckets[16], &s_CtxPropBuckets[16]},
    {&s_CtxPropBuckets[17], &s_CtxPropBuckets[17]},
    {&s_CtxPropBuckets[18], &s_CtxPropBuckets[18]},
    {&s_CtxPropBuckets[19], &s_CtxPropBuckets[19]},
    {&s_CtxPropBuckets[20], &s_CtxPropBuckets[20]},
    {&s_CtxPropBuckets[21], &s_CtxPropBuckets[21]},
    {&s_CtxPropBuckets[22], &s_CtxPropBuckets[22]}
};

SHashChain CCtxTable::s_CtxUUIDBuckets[NUM_HASH_BUCKETS] = { // Hash buckets for the UUID based table
    {&s_CtxUUIDBuckets[0],  &s_CtxUUIDBuckets[0]},
    {&s_CtxUUIDBuckets[1],  &s_CtxUUIDBuckets[1]},
    {&s_CtxUUIDBuckets[2],  &s_CtxUUIDBuckets[2]},
    {&s_CtxUUIDBuckets[3],  &s_CtxUUIDBuckets[3]},
    {&s_CtxUUIDBuckets[4],  &s_CtxUUIDBuckets[4]},
    {&s_CtxUUIDBuckets[5],  &s_CtxUUIDBuckets[5]},
    {&s_CtxUUIDBuckets[6],  &s_CtxUUIDBuckets[6]},
    {&s_CtxUUIDBuckets[7],  &s_CtxUUIDBuckets[7]},
    {&s_CtxUUIDBuckets[8],  &s_CtxUUIDBuckets[8]},
    {&s_CtxUUIDBuckets[9],  &s_CtxUUIDBuckets[9]},
    {&s_CtxUUIDBuckets[10], &s_CtxUUIDBuckets[10]},
    {&s_CtxUUIDBuckets[11], &s_CtxUUIDBuckets[11]},
    {&s_CtxUUIDBuckets[12], &s_CtxUUIDBuckets[12]},
    {&s_CtxUUIDBuckets[13], &s_CtxUUIDBuckets[13]},
    {&s_CtxUUIDBuckets[14], &s_CtxUUIDBuckets[14]},
    {&s_CtxUUIDBuckets[15], &s_CtxUUIDBuckets[15]},
    {&s_CtxUUIDBuckets[16], &s_CtxUUIDBuckets[16]},
    {&s_CtxUUIDBuckets[17], &s_CtxUUIDBuckets[17]},
    {&s_CtxUUIDBuckets[18], &s_CtxUUIDBuckets[18]},
    {&s_CtxUUIDBuckets[19], &s_CtxUUIDBuckets[19]},
    {&s_CtxUUIDBuckets[20], &s_CtxUUIDBuckets[20]},
    {&s_CtxUUIDBuckets[21], &s_CtxUUIDBuckets[21]},
    {&s_CtxUUIDBuckets[22], &s_CtxUUIDBuckets[22]}
};


//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------
#if DBG == 1

DWORD g_cCtxTableLookupSucceeded;           // Number of lookups that succeeded
DWORD g_cCtxTableLookup;                    // Total number of lookups
DWORD g_cCtxTableAdd;                       // Number of Context table additions
DWORD g_cCtxTableRemove;                    // Number of Context table removes
#endif
COleStaticMutexSem gContextLock(TRUE);    // critical section for contexts

//----------------------------------------------------------------------------
// Finalizer bypass regkey check
//----------------------------------------------------------------------------

static DWORD g_dwFinBypassStatus = -1;
static DWORD g_dwGipBypassStatus = -1;

static DWORD GetRegSetting(LPCWSTR pwszValue, DWORD dwDefault, DWORD* pdwOutput)
{
    DWORD dwNewValue = dwDefault;
    HKEY hk;
    LONG lRes;

    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\COM3",
        0, KEY_READ, &hk);

    if(lRes == ERROR_SUCCESS)
    {
        DWORD dwType, dwValue;
        DWORD cbValue = sizeof(DWORD);

        lRes = RegQueryValueEx(hk, pwszValue, NULL,
            &dwType, (LPBYTE) &dwValue, &cbValue);

        if(lRes == ERROR_SUCCESS && dwType == REG_DWORD)
            dwNewValue = dwValue;

        RegCloseKey(hk);
    }

    InterlockedCompareExchange(
        (LPLONG) pdwOutput, (LONG) dwNewValue, (LONG) -1);

    return *pdwOutput;
}

BOOL FinalizerBypassEnabled()  // for Finalizers
{
    if(g_dwFinBypassStatus != -1)
        return !!g_dwFinBypassStatus;
    else
        return !!GetRegSetting(L"FinalizerActivityBypass", TRUE, &g_dwFinBypassStatus);
}

BOOL GipBypassEnabled()        // for GIP
{
    if(g_dwGipBypassStatus != -1)
        return !!g_dwGipBypassStatus;
    else
        return !!GetRegSetting(L"GipActivityBypass", FALSE, &g_dwGipBypassStatus);
}

//----------------------------------------------------------------------------
// CEnumContextProps Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::QueryInterface , public
//
//  Synopsis:   Standard IUnknown::QueryInterface implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if (IID_IUnknown == riid || IID_IEnumContextProps == riid)
    {
        *ppv = (IEnumContextProps *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::AddRef , public
//
//  Synopsis:   Standard IUnknown::AddRef implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumContextProps::AddRef()
{
    return InterlockedIncrement(&_cRefs);
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Release , public
//
//  Synopsis:   Standard IUnknown::Release implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumContextProps::Release()
{
    LONG lRef = InterlockedDecrement(&_cRefs);
    if (lRef == 0)
    {
        delete this;
    }
    return lRef;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Next , public
//
//  Synopsis:   Returns the next ContextProp on a ComContext.
//
//  Returns:    S_OK         - if the number of items requested is returned
//              E_INVALIDARG - if the arguments are not valid
//              S_FALSE      - if the number of items requested could not be
//                             provided
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Next(
    ULONG            celt,
    ContextProperty* pCtxProps,
    ULONG*           pceltFetched
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Next celt: %d\n", celt));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pCtxProps != NULL);

    //
    // The spec says that if pceltFetched is NULL, then celt must be one.
    // Enforce that here.
    //

    if (pceltFetched == NULL)
    {
        if (celt != 1)
            return E_INVALIDARG;
    }
    else
    {
        *pceltFetched = 0;
    }

    //
    // Allocate an array of IUnknown*s on the stack so we can AddRef all the
    // properties we supply to the caller outside while not holding the
    // lock.
    //

    IUnknown** PunkArr = (IUnknown**) _alloca(sizeof(IUnknown*) * celt);

    //
    // Copy as many of the requested items as possible from the list into the
    // caller supplied array.
    //

    ULONG ItemsCopied = 0;
    ULONG idx = 0;
    LOCK(gContextLock);
    if (_CurrentPosition < _cItems)
    {
        ContextProperty* pDstProp = pCtxProps + ItemsCopied;
        ContextProperty* pSrcProp = &_pList[_CurrentPosition];
        while ((ItemsCopied < celt) && (_CurrentPosition++ < _cItems))
        {
            PunkArr[idx++] = pSrcProp->pUnk;
            CopyMemory(pDstProp++, pSrcProp++, sizeof(ContextProperty));
            ItemsCopied++;
        }
    }
    UNLOCK(gContextLock);

    //
    // Now AddRef all the properties we are returning.
    //

    for (ULONG i = 0; i < ItemsCopied; i++)
        PunkArr[i]->AddRef();

    //
    // Indicate the number of objects we are returning.
    //

    if (pceltFetched != NULL)
        *pceltFetched = ItemsCopied;

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CEnumContextProps::Next returning hr:%08X pceltFetched:%d\n",
        (ItemsCopied == celt) ? S_OK : S_FALSE, ItemsCopied));
    return (ItemsCopied == celt) ? S_OK : S_FALSE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Skip , public
//
//  Synopsis:   Skips over the current ContextProp on a ComContext.
//
//  Returns:    S_OK    - if the number of items specified is skipped
//              S_FALSE - otherwise
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Skip(
    ULONG celt
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Skip\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    HRESULT hr = S_OK;
    LOCK(gContextLock);
    _CurrentPosition += celt;
    if (_CurrentPosition > _cItems)
    {
        _CurrentPosition = _cItems;
        hr = S_FALSE;
    }
    UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CEnumContextProps::Skip returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Reset , public
//
//  Synopsis:   Resets the ComContext enumerator to the beginning of the
//              collection of properties.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Reset()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Reset\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    LOCK(gContextLock);
    _CurrentPosition = 0;
    UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Clone , public
//
//  Synopsis:   Returns a pointer to a clone of this context property
//              enumerator.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Clone(
    IEnumContextProps** ppEnumCtxProps
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Clone\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    LOCK(gContextLock);
    *ppEnumCtxProps = new CEnumContextProps(this);
    UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CEnumContextProps::Clone returning hr:%08X\n",
        (*ppEnumCtxProps != NULL) ? S_OK : E_OUTOFMEMORY));
    return (*ppEnumCtxProps != NULL) ? S_OK : E_OUTOFMEMORY;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::GetCount , public
//
//  Synopsis:   Returns the number of items in the collection being
//              enumerated.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Count(
    PULONG pulCount
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Count\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    *pulCount = _cItems;
    return S_OK;
}




//////////////////////////////////////////////////////////////////////////////
//
// CContextPropList Implementation.
//
//////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::CreateCompareBuffer , public
//
//  Synopsis:   Creates a comparison buffer which is used to determine if
//              two contexts are equal.  The buffer contains all of the
//              ContextProperty objects added to this context which are
//              not explicitly marked as DONTCOMPARE.
//
//              This is also where we compute the hash value for this context.
//              Again, only those properties not explicitly marked DONTCOMPARE
//              are included in the calculation.
//
//  History:    29-Nov-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
BOOL CContextPropList::CreateCompareBuffer(void)
{
    if (0 == _cCompareProps)
        return TRUE;

    // Allocate enough space for the buffer.

    _pCompareBuffer = new ContextProperty[_cCompareProps];
    if (!_pCompareBuffer)
        return FALSE;

    // Walk through all the properties, and add those not explicitly marked
    // DONTCOMPARE to the comparison buffer.  Also use those properties
    // not marked DONTCOMPARE to compute the context's hash value.

    ContextProperty *buf = _pCompareBuffer;
    int i = _iFirst;
    do
    {
        if (!(_pProps[_pIndex[i].idx].flags & CPFLAG_DONTCOMPARE))
        {
            // Include this property in the context's hash value.
            _Hash += HashPtr(_pProps[_pIndex[i].idx].pUnk);

            // Add the property to the comparison buffer.
            *buf++ = _pProps[_pIndex[i].idx];
        }

        // Advance to the next property.
        i = _pIndex[i].next;
    } while(i != _iFirst);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CContextPropList::Initialize , public
//
//  Synopsis:   Initializes the property list.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//-----------------------------------------------------------------------------
void CContextPropList::Initialize()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CContextPropList::Initialize\n"));
    ASSERT_LOCK_HELD(gContextLock);

    // caller guarantees mutual exclusion to the allocator
    s_NodeAllocator.Initialize(sizeof(ContextProperty), CP_PER_PAGE, NULL);
}


//+----------------------------------------------------------------------------
//
//  Member:     CContextPropList::Initialize , public
//
//  Synopsis:   Cleans up the property list.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//-----------------------------------------------------------------------------
void CContextPropList::Cleanup()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CContextPropList::Cleanup\n"));
    ASSERT_LOCK_HELD(gContextLock);

    s_NodeAllocator.Cleanup();

    ASSERT_LOCK_HELD(gContextLock);
}


//+----------------------------------------------------------------------------
//
//  Member:     CContextPropList::Initialize , private
//
//  Synopsis:   Grows the internal array of ContextProperties when more space
//              is needed.
//
//  History:    30-Nov-98   Johnstra      Created.
//
//-----------------------------------------------------------------------------
BOOL CContextPropList::Grow()
{
    // Allocate a single chunk of memory.

    int cElements = _Max ? (_Max * 2) : CTX_PROPS;
    ULONG cBytes = sizeof(ContextProperty) * cElements +
                   sizeof(SCtxListIndex) * cElements +
                   sizeof(int) * cElements;
    PUCHAR chunk = new UCHAR[cBytes];
    if (!chunk)
        return FALSE;

    // Carve the chunk into the data structures we need.

    ContextProperty *pNewProps = (ContextProperty *) chunk;
    SCtxListIndex   *pNewIndex = (SCtxListIndex *) (pNewProps + cElements);
    int             *pNewSlots = (int *) (pNewIndex + cElements);

    // Initialize the new slot array and the new index array.

    int i;
    for(i = 0; i < _Max; i++)
    {
       pNewIndex[i].idx  = _pIndex[i].idx;
       pNewIndex[i].next = _pIndex[i].next;
       pNewIndex[i].prev = _pIndex[i].prev;
       pNewSlots[i] = _pSlots[i];
    }
    for (i = _Max; i < cElements; i++)
    {
        pNewIndex[i].idx  = i;
        pNewIndex[i].next = i+1;
        pNewIndex[i].prev = i-1;
        pNewSlots[i] = i;
    }
    pNewIndex[0].prev = _Count - 1;
    pNewIndex[_Count-1].next = 0;

    // Update the max number of elements.

    _Max = cElements;

    // If there are properties, copy them old array into the new array and
    // delete the existing chunk of memory.

    if (_Count)
    {
        ContextProperty *pCurProp = pNewProps;
        int i = _iFirst;
        do
        {
            *pCurProp++ = _pProps[_pIndex[i].idx];
            i = _pIndex[i].next;
        } while(i != _iFirst);

        _iFirst  = 0;
        _iLast   = _Count - 1;
        _slotIdx = _Count;

        PUCHAR oldChunk = _chunk;
        delete [] oldChunk;
    }

    // Update member variables.

    _pProps = pNewProps;
    _pIndex = pNewIndex;
    _pSlots = pNewSlots;
    _chunk  = chunk;

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::Add , public
//
//  Synopsis:   Add the property represented by the supplied tuple to the
//              the list.  The supplied pUnk has been AddRef'd by the caller.
//
//  Returns:    TRUE      - if property is added successfully
//              FALSE     - if resources are unavailable
//
//  History:    22-Dec-97   Johnstra      Created.
//              24-Nov-98   JohnStra      Rewrote using flat array
//
//----------------------------------------------------------------------------
BOOL CContextPropList::Add(
    REFGUID   rGUID,
    CPFLAGS   flags,
    IUnknown* pUnk
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CContextPropList::Add rGUID:%I flags:%08X pUnk:%p\n",
               &rGUID, flags, pUnk));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);
    //
    // Don't add a property if it is already in the list.
    //
    ContextProperty* pcp = Get(rGUID);
    if (pcp != NULL)
    {
       UNLOCK(gContextLock);
       return FALSE;
    }

    // Grow our internal data structures if necessary.

    if (_Count >= _Max)
        if (!Grow())
	{
	   UNLOCK(gContextLock);
	   return FALSE;
	}

    // Get the next available slot..

    int slot = PopSlot();

    if (0 == _Count)
    {
        // The list is empty so we have to initialize our first and
        // last pointers.

        _iFirst = slot;
        _iLast = slot;
    }

    // Link in the slot.

    _pIndex[_iFirst].prev = slot;
    _pIndex[_iLast].next  = slot;
    _pIndex[slot].next = _iFirst;
    _pIndex[slot].prev = _iLast;
    _iLast = slot;

    // Fill in the information in the appropriate slot.
    // Note: we need to memset the structure to zero,
    // because on 64 bit platforms there is padding that
    // can cause CContextPropList::operator== to fail
    ContextProperty* pcpProp = _pProps + _pIndex[slot].idx;
    
    memset (pcpProp, 0, sizeof (ContextProperty));
    pcpProp->policyId = rGUID;
    pcpProp->flags    = flags;
    pcpProp->pUnk     = pUnk;

    // Increment the number of properties in the list.

    _Count++;
    if (!(flags & CPFLAG_DONTCOMPARE))
        _cCompareProps++;

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::Remove , public
//
//  Synopsis:   Remove the specified item from the list.
//
//  History:    22-Dec-97   Johnstra      Created.
//              24-Nov-98   JohnStra      Rewritten to use flat array
//
//----------------------------------------------------------------------------
void CContextPropList::Remove(
    REFGUID rGuid
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CContextPropList::Remove\n"));
    ASSERT_LOCK_HELD(gContextLock);

    if (0 == _Count)
        return;

    // Scan the list for the specified property.

    BOOL fFound = FALSE;
    int i = _iFirst;
    do
    {
        if (IsEqualGUID(rGuid, _pProps[_pIndex[i].idx].policyId))
        {
            fFound = TRUE;
            break;
        }

        i = _pIndex[i].next;
    } while(i != _iFirst);

    // If we found the specified property, unlink it from the list, push the
    // slot on the available stack, and decrement the count by one.

    if (fFound)
    {
        if (i == _iFirst)
            _iFirst = _pIndex[i].next;

        if (i == _iLast)
            _iLast = _pIndex[i].prev;

        _pIndex[_pIndex[i].next].prev = _pIndex[i].prev;
        _pIndex[_pIndex[i].prev].next = _pIndex[i].next;

        PushSlot(i);

        _Count--;
        if (!(_pProps[_pIndex[i].idx].flags & CPFLAG_DONTCOMPARE))
            _cCompareProps--;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::Get , public
//
//  Synopsis:   Get the specified item from the list.
//
//  Returns:    S_OK   - If the specified item is found.
//              E_FAIL - If the item cannot be found.
//
//  History:    22-Dec-97   Johnstra      Created.
//              24-Nov-98   JohnStra      Rewritten to use flat array
//
//----------------------------------------------------------------------------
ContextProperty* CContextPropList::Get(
    REFGUID    rGUID
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CContextPropList::Get rGUID:%I\n", &rGUID));

    if (0 == _Count)
        return NULL;

    // Scan the list for the specified property.

    ContextProperty *pcp = NULL;
    int i = _iFirst;
    do
    {
        if (IsEqualGUID(rGUID, _pProps[_pIndex[i].idx].policyId))
            pcp = &_pProps[_pIndex[i].idx];

        i = _pIndex[i].next;
    } while(!pcp && i != _iFirst);

    ComDebOut((DEB_OBJECTCONTEXT,
        "CContextPropList::Get returning pcp:%p\n", pcp));
    return pcp;
}




//////////////////////////////////////////////////////////////////////////////
//
// CObjectContext Implementation.
//
//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::CreatePrototypeContext     public
//
//  Synopsis:   Returns a new context which contains all of the same
//              properties in the current context which are marked
//              CPFLAG_PROPAGATE.
//
// History:     11 Nov 1998  Johnstra    Created
//
//+-------------------------------------------------------------------
HRESULT CObjectContext::CreatePrototypeContext(
    CObjectContext  *pClientContext,
    CObjectContext **pProto
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pClientContext);
    Win4Assert(pProto);

    // The client context must be fozen.

    if (!pClientContext->IsFrozen())
    {
        *pProto = NULL;
        return E_INVALIDARG;
    }

    // Initialize hr to S_OK; and the context we will return to NULL.  If
    // client context has no properties, we don't have to do anything.

    HRESULT hr = S_OK;
    CObjectContext *pContext = NULL;

    // Get the number of properties.

    ULONG cPropsAdded = 0;
    ULONG cProps = pClientContext->GetCount();
    if (cProps)
    {
        // Create a new object context.

        hr = E_OUTOFMEMORY;
        pContext = CreateObjectContext(NULL, 0);
        if (pContext)
        {
            // Get an enumerator for the properties of the client context.

            IEnumContextProps *pEnum = NULL;
            hr = pClientContext->EnumContextProps(&pEnum);
            if (SUCCEEDED(hr))
            {
                // Allocate space for an array of properties on the stack.

                ContextProperty *pProps =
                    (ContextProperty*) _alloca(sizeof(ContextProperty) * cProps);
                if (pProps)
                {
                    // Get all the properties at once from the enumerator.

                    ULONG cReturned;
                    hr = pEnum->Next(cProps, pProps, &cReturned);
                    if (S_OK == hr)
                    {
                        // Add all the properties that are marked
                        // CPFLAG_PROPAGATE to the prototype.

                        while (cProps)
                        {
                            if (pProps->flags & CPFLAG_PROPAGATE)
                            {
                                hr = pContext->SetProperty(pProps->policyId,
                                                           pProps->flags,
                                                           pProps->pUnk);
                                if (FAILED(hr))
                                {
                                    if(pProps->pUnk)
                                    {
                                        pProps->pUnk->Release();
                                    }
                                    break;
                                }
                                ++cPropsAdded;
                            }
                            pProps->pUnk->Release();
                            --cProps;
                            ++pProps;
                        }
                    }
                }

                // Done with the enumerator.  Release it.

                pEnum->Release();
            }

            // If we didn't make it through all of the properties because of an
            // error, or if there were no PROPAGATE properties, release and
            // NULL the prototype.

            if (cProps || !cPropsAdded)
            {
                pContext->InternalRelease();
                pContext = NULL;
            }
        }
    }

    // Give the caller the context.

    *pProto = pContext;

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}


//+-------------------------------------------------------------------
//
//   Method:   CObjectContext::CreateUniqueID     static
//
// synopsis:   Creates a unique identifier for an object context.
//
//  History:   24-Nov-98  Johnstra    Created
//
//+-------------------------------------------------------------------
HRESULT CObjectContext::CreateUniqueID(
    ContextID& CtxID)
{
    return CoCreateGuid(&CtxID);
}


CObjectContext* CObjectContext::CreateObjectContext(
    DATAELEMENT *pDE,
    DWORD        dwFlags
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);

    CObjectContext *pContext    = NULL;
    CObjectContext *pRelCtx     = NULL;
    GUID            contextId   = GUID_NULL;
    BOOL            fAddToTable = TRUE;

    LOCK(gContextLock);

    if (pDE == NULL)
    {
        fAddToTable = ((dwFlags & CONTEXTFLAGS_STATICCONTEXT) == 0);
        if (SUCCEEDED(CoCreateGuid(&contextId)))
        {
            pContext = new CObjectContext(dwFlags, contextId, NULL);
        }
    }
    else
    {
        // We have been supplied with a DATAELEMENT which contains a marshaled
        // envoy context.  This means we are to either lookup an existing or
        // create a new envoy.

        // First, try to lookup the specified context.  If we find it in this
        // process, we can AddRef it and return it.

        contextId = pDE->dataID;
        pContext = CCtxTable::LookupExistingContext(contextId);

        if (pContext == NULL)
        {
            pContext = new CObjectContext(dwFlags, GUID_NULL, pDE);

            // The above ctor releases the lock in the SetEnvoyData call,
            // thus we need to lookup the context in the table again
            // before adding it, since another thread could have added it
            // in the meantime.

            ASSERT_LOCK_HELD(gContextLock);

            CObjectContext *pCtx = CCtxTable::LookupExistingContext(contextId);
            if (pCtx == NULL)
            {
                if (pContext != NULL)
                {
                    pContext->SetContextId(contextId);
                }
            }
            else
            {
                fAddToTable = FALSE;
                if (pContext != NULL)
                {
                    pRelCtx = pContext;
                }
                pCtx->InternalAddRef();
                pContext = pCtx;
            }
        }
        else
        {
            fAddToTable = FALSE;
            pContext->InternalAddRef();
            PrivMemFree(((DWORD *) pDE)-1);
        }
    }

    // New contexts are always added to the table with the exception of the
    // static unmarshaler context object.

    if (pContext && fAddToTable)
    {
        Win4Assert(NULL == pContext->GetUUIDHashChain()->pPrev &&
                   NULL == pContext->GetUUIDHashChain()->pNext);
        CCtxTable::s_CtxUUIDHashTable.Add(pContext);
    }

    UNLOCK(gContextLock);

    if (pRelCtx)
    {
        // Another thread unmarshaled the same envoy we unmarshaled and added
        // it to the table before we could.  We looked up the one the other
        // thread unmarshaled, so we don't need this one.  We can release it.

        pRelCtx->InternalRelease();
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return pContext;
}


void CleanupCtxTableEntry(SHashChain* pNode)
{
    Win4Assert("!CleanupCtxEntry got called \n");
}


CObjectContext::CObjectContext(
    DWORD        dwFlags,
    REFGUID      contextId,
    DATAELEMENT *pDE
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::CObjectContext this:%x\n",this));

    // Initialize the appropriate ref count to 1
    _cRefs   = 1;
    _cInternalRefs  = 1;
    _cUserRefs      = 0;

    _dwFlags        = dwFlags;
    _pifData        = (pDE) ? (InterfaceData *) (((PCHAR) pDE) - sizeof(DWORD)) : NULL;
    _MarshalSizeMax = (pDE) ? pDE->cbSize + sizeof(DATAELEMENT) - sizeof(BYTE) : NULL;
    if(_pifData)
        _pifData->ulCntData = _MarshalSizeMax;
    _pMarshalProp   = NULL;
    _pApartment     = NULL;
    CPolicySet::InitPSCache(&_PSCache);
    _contextId      = contextId;
    ULARGE_INTEGER NewId;
    GetNextContextId(NewId);
    _urtCtxId       = NewId.QuadPart;
    _dwHashOfId     = HashGuid(_contextId);
    _cReleaseThreads = 0;
    _pMtsContext    = NULL;
    _pContextLife   = NULL;

#if DBG==1
    _ValidMarker     = VALID_MARK;
    _propChain.pNext = NULL;
    _propChain.pPrev = NULL;
    _uuidChain.pNext = NULL;
    _uuidChain.pPrev = NULL;
#endif

    if (pDE)
    {
        Win4Assert(GUID_NULL != pDE->dataID);
        SetEnvoyData(pDE);
    }
}


CObjectContext::~CObjectContext()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::~CObjectContext this:%x\n",this));
#if DBG==1
    _ValidMarker = 0;
    _contextId = GUID_NULL;
    _uuidChain.pPrev = NULL;
    _uuidChain.pNext = NULL;
#endif

    // Remove ourselves from the context map.
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(_cRefs & CINDESTRUCTOR);

    _dwFlags &= ~CONTEXTFLAGS_STATICCONTEXT;

    // If _pifData points to an InterfaceData object, we own it, so
    // we need to delete it.
    if (_pifData != NULL)
        PrivMemFree(_pifData);

    // Release the reference to our apartment object.
    if (_pApartment)
        _pApartment->Release();

    // Release our reference to the special marshaling property if
    // we hold one.
    if (_pMarshalProp)
        ((IUnknown*)_pMarshalProp)->Release();

    if (_pMtsContext)
    {
        _pMtsContext->Release();
        _pMtsContext = NULL;
    }

    if (_pContextLife)
    {
        _pContextLife->SetDead();
        _pContextLife->Release();
        _pContextLife = NULL;
    }

    CPolicySet::DestroyPSCache(this);
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::operator new     public
//
//  Synopsis:   new operator of object context
//
// History:     22 Dec 1997  Johnstra    Created
//
//+-------------------------------------------------------------------
void* CObjectContext::operator new(
    size_t size
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::operator new s_cInstances:%d\n", s_cInstances));
    ASSERT_LOCK_HELD(gContextLock);

    //
    // CObjectContext can be inherited only by those objects with overloaded
    // new and delete operators.
    //

    Win4Assert((size == sizeof(CObjectContext))
                && "CObjectContext improperly inherited");

    //
    // Make sure allocators are initialized.
    //

    if (s_fInitialized == FALSE)
        Initialize();

    //
    // Allocate memory for the object and increment the instance count.
    //

    void* pv = (void*) s_CXAllocator.AllocEntry();
    if (pv != NULL)
        s_cInstances++;

    ASSERT_LOCK_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::operator new returning pv: %08X\n", pv));
    return pv;
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::operator delete     public
//
//  Synopsis:   delete operator of object context
//
//  History:    22 Dec 1997   Johnstra    Created
//
//+-------------------------------------------------------------------
void CObjectContext::operator delete(
    void *pv
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::operator delete s_cInstances: %d\n", s_cInstances));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

#if DBG==1
    //
    // Ensure that pv was allocated by the our allocator.
    //

    LONG index = s_CXAllocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1 && "pv not allocated by CObjectContext allocator");
#endif

    //
    // Release the pointer
    //

    s_CXAllocator.ReleaseEntry((PageEntry *) pv);
    --s_cInstances;

    //
    // If allocators are initialized and the instance count touches
    // zero, clean up the allocators.
    //

    if (s_fInitialized == FALSE && s_cInstances == 0)
    {
        // Cleanup allocators
        s_CXAllocator.Cleanup();
        CContextPropList::Cleanup();

        // cleanup the context table
        CCtxTable::Cleanup();
    }

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::Initialize     public
//
//  Synopsis:   Initializes allocators for policy sets
//
//  History:    22 Dec 1997   Johnstra   Created
//
//+-------------------------------------------------------------------
void CObjectContext::Initialize()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::Initialize\n"));
    ASSERT_LOCK_HELD(gContextLock);

    Win4Assert(!s_fInitialized && "CObjectContext already initialized");

    //
    // Initialze the allocators.
    //
    if (s_cInstances == 0)
    {
        // Initialize allocators
        // caller guarantees mutual exclusion
        s_CXAllocator.Initialize(sizeof(CObjectContext), CX_PER_PAGE, NULL);
        CContextPropList::Initialize();

        // Initialize the context table.
        CCtxTable::Initialize();
    }

    //
    // Mark the state as initialized.
    //
    s_fInitialized = TRUE;

    ASSERT_LOCK_HELD(gContextLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::Cleanup     public
//
//  Synopsis:   Cleanup allocators of contexts and context objects.
//
//  History:    22 Dec 1997   Johnstra    Created
//
//+-------------------------------------------------------------------
void CObjectContext::Cleanup()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

    //
    // Cleanup allocators.
    //

    if (s_fInitialized == TRUE)
    {
        if (s_cInstances == 0)
        {
            // Cleanup allocators
            s_CXAllocator.Cleanup();
            CContextPropList::Cleanup();

            // Clean up the context table.
            CCtxTable::Cleanup();
        }

        //
        // Reset state.
        //

        s_fInitialized = FALSE;
    }

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);
    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::QueryInterface , public
//
//  Synopsis:   Standard IUnknown::QueryInterface implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    return QIHelper(riid, ppv, FALSE);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::AddRef , public
//
//  Synopsis:   Standard IUnknown::AddRef implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CObjectContext::AddRef()
{
    InterlockedIncrement((LONG*)&_cRefs);
    return InterlockedIncrement(&_cUserRefs);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Release , public
//
//  Synopsis:   Standard IUnknown::Release implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CObjectContext::Release()
{
    ULONG cRefs = InterlockedDecrement(&_cUserRefs);
    CommonRelease();
    return cRefs;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::InternalQueryInterface , public
//
//  History:    16-Dec-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::InternalQueryInterface(
    REFIID   riid,
    void   **ppv
    )
{
    return QIHelper(riid, ppv, TRUE);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::AddRef , public
//
//  History:    16-Dec-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
ULONG CObjectContext::InternalAddRef()
{
    InterlockedIncrement((LONG*)&_cRefs);
    return InterlockedIncrement(&_cInternalRefs);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::InternalRelease , public
//
//  History:    16-Dec-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
ULONG CObjectContext::InternalRelease()
{
    ULONG cRefs = InterlockedDecrement(&_cInternalRefs);
    CommonRelease();
    return cRefs;
}


HRESULT CObjectContext::QIHelper(
    REFIID   riid,
    void   **ppv,
    BOOL     fInternal
    )
{
    if (IID_IObjContext == riid || IID_IContext == riid)
    {
        *ppv = (IObjContext *) this;
    }
    else if (IID_IContextCallback == riid)
    {
        *ppv = (IContextCallback *) this;
    }
    else if (IID_IUnknown == riid)
    {
        *ppv = (IUnknown*)(IObjContext*)this;
    }
    else if (IID_IMarshalEnvoy == riid)
    {
        *ppv = (IMarshalEnvoy *) this;
    }
    else if (IID_IMarshal == riid)
    {
        *ppv = (IMarshal *) this;
    }
    else if (IID_IStdObjectContext == riid)
    {
        *ppv = this;
    }
    else if (IID_IComThreadingInfo == riid)
    {
        *ppv = (IComThreadingInfo *) this;
    }
    else if (IID_IAggregator == riid)
    {
        *ppv = (IAggregator *) this;
    }
    else if (IID_IGetContextId == riid)
    {
        *ppv = (IGetContextId *) this;
    }
    else if (_pMtsContext)
    {
        return _pMtsContext->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    if (fInternal)
        ((CObjectContext*)*ppv)->InternalAddRef();
    else
        ((IUnknown*)*ppv)->AddRef();

    return S_OK;
}


ULONG CObjectContext::DecideDestruction()
{
    ULONG cRefs;
    BOOL fDelete = FALSE;

    // acquire the same lock that the table uses when it
    // gives out references.
    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

    cRefs = _cRefs;
    if (cRefs == 0)
    {
        if (GUID_NULL != _contextId)
            CleanupTables();

        _dwFlags |= CONTEXTFLAGS_INDESTRUCTOR;
        _cRefs = CINDESTRUCTOR;

        fDelete = TRUE;
    }

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    if (fDelete)
        delete this;

    return cRefs;
}


ULONG CObjectContext::CommonRelease()
{
    ULONG cRefs = InterlockedDecrement((LONG *)&_cRefs);

    if (cRefs == 0)
    {
        if(!(_dwFlags & CONTEXTFLAGS_INDESTRUCTOR))
        {
            cRefs = DecideDestruction();
        }
    }

    return cRefs;
}

void CObjectContext::CleanupTables()
{
    ASSERT_LOCK_HELD(gContextLock);

#if DBG==1
    // In debug builds, ensure that the node is present in the table

    // Obtain Hash value for UUID based hash table
    CObjectContext *pExistingContext = CCtxTable::LookupExistingContext(_contextId);
    Win4Assert( (pExistingContext != NULL || IsStatic()) && "Ctx not in table" );
    Win4Assert( (pExistingContext == this || IsStatic()) && "Wrong Ctx found" );

    // If the context is frozen, obtain Hash value for property
    // based hash table
    if (IsInPropTable() && GetPropertyList()->GetCount())
    {
        pExistingContext = CCtxTable::LookupExistingContext(this);
        Win4Assert(pExistingContext == this || IsStatic());
    }
#endif

    // The static context object is never added to the tables
    // so it should not be removed
    if (!IsStatic())
    {
        CCtxTable::s_CtxUUIDHashTable.Remove(this);

        if (IsInPropTable())
            CCtxTable::s_CtxPropHashTable.Remove(this);
    }

#if DBG == 1
    Win4Assert(NULL == CCtxTable::LookupExistingContext(_contextId));
    _propChain.pNext = NULL;
    _propChain.pPrev = NULL;
    _uuidChain.pNext = NULL;
    _uuidChain.pPrev = NULL;
#endif
    ASSERT_LOCK_HELD(gContextLock);
}


typedef struct tagENVOYDATA
{
    GUID  contextId;
    ULONG ulJunk1;
    ULONG ulJunk2;
} ENVOYDATA;


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoyData , private
//
//  Synopsis:   Returns a pointer to an InterfaceData object that contains
//              the marshaled context.
//
//  History:    27-Jan-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetEnvoyData(
    DATAELEMENT**  ppDE
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::GetEnvoyData\n"));
    Win4Assert(ppDE != NULL);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    HRESULT hr = E_FAIL;
    *ppDE = NULL;
    if (IsFrozen())
    {
        hr = S_OK;
        if (_pifData == NULL)
        {
            //
            // Get the space requirements of the contexts marshal packet.
            //

            hr = GetEnvoySizeMax(0, &_MarshalSizeMax);
            if (SUCCEEDED(hr))
            {
                //
                // Adjust the space requirements to accommodate the size of
                // a DATAELEMENT structure.
                //

                ULONG cbSize = _MarshalSizeMax - (sizeof(DATAELEMENT) - sizeof(BYTE));

                //
                // Allocate a stream into which the context and all its
                // properties gets marshaled.
                //

                CXmitRpcStream strm(_MarshalSizeMax);

                //
                // Write the header info required by COM into the stream.
                //

                ENVOYDATA EnvoyData;
                EnvoyData.contextId = _contextId;
                EnvoyData.ulJunk1   = cbSize;
                EnvoyData.ulJunk2   = cbSize;
                hr = strm.Write(&EnvoyData, sizeof(ENVOYDATA), NULL);
                if (SUCCEEDED(hr))
                {
                    //
                    // Marshal the context into the stream.
                    //

                    hr = MarshalEnvoy(&strm, 0);
                    if (SUCCEEDED(hr))
                    {
                        LOCK(gContextLock);
                        if (NULL == _pifData)
                        {
                            // We now own the buffer.
                            strm.AssignSerializedInterface(&_pifData);
                            if (_pifData == NULL)
                                hr = E_OUTOFMEMORY;
                        }
                        UNLOCK(gContextLock);
                    }
                }
            }
        }

        //
        // If we successfully created the marshaling buffer, copy the
        // address of the buffer into the supplied pointer.
        //

        if (SUCCEEDED(hr))
        {
            *ppDE = (DATAELEMENT*) _pifData->abData;
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoyData , private
//
//  Synopsis:   Unmarshals an object context from the information stored
//              in the supplied InterfaceData object.  This method should
//              only be called by infrastructure code to unmarshal a
//              previously marshaled context.
//
//              It is assumed that the context will be frozen when
//              unmarshaling completes.
//
//  History:    27-Jan-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::SetEnvoyData(
    DATAELEMENT* pDE
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::SetEnvoyData cb:%d\n",
               pDE->cbSize));
    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(_pifData != NULL);

    //
    // Initialize the contexts state using the information in the supplied
    // buffer.
    //

    CXmitRpcStream strm(_pifData);

    //
    // Read past the header info.
    //

    ENVOYDATA EnvoyData;
    HRESULT hr = strm.Read(&EnvoyData, sizeof(ENVOYDATA), NULL);
    if (SUCCEEDED(hr))
    {
        //
        // Unmarshal the object context from the stream.
        //

        UNLOCK(gContextLock);
        ASSERT_LOCK_NOT_HELD(gContextLock);

        CObjectContext *pCtx = NULL;
        hr = UnmarshalEnvoy(&strm, IID_IObjContext, (void **) &pCtx);

        ASSERT_LOCK_NOT_HELD(gContextLock);
        LOCK(gContextLock);

        if (SUCCEEDED(hr))
        {
#if DBG==1
            Win4Assert(pCtx->IsValid());
            if (pCtx->IsValid())
            {
                pCtx->Release();
            }
#else
            pCtx->Release();
#endif
        }
    }

    ASSERT_LOCK_HELD(gContextLock);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetUnmarshalClass , public
//
//  Synopsis:   Provides caller with the CLSID of the proxy for this class.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetUnmarshalClass(
    REFIID  riid,
    void*   pv,
    DWORD   dwDestContext,
    void*   pvDestContext,
    DWORD   mshlflags,
    CLSID*  pclsid
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
     "CObjectContext::GetUnmarshalClass _dwFlags:%08X riid:%I mshlflags:%08X\n",
               _dwFlags, &riid, mshlflags));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    *pclsid = CLSID_ContextMarshaler;
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetMarshalSizeMax , public
//
//  Synopsis:   Provides caller with number of bytes required to marshal the
//              the context.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetMarshalSizeMax(
    REFIID  riid,
    void*   pv,
    DWORD   dwDestContext,
    void*   pvDestContext,
    DWORD   mshlflags,
    ULONG*  pcb
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
      "CObjectContext::GetMarshalSizeMax [IN] this:%08X mshlflags:%08X\n",
               this, mshlflags));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pcb != NULL);

    HRESULT hr        = S_OK;
    ULONG   TotalSize = 0;
    ULONG   Count     = 0;

    if (dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_CROSSCTX)
    {
        //
        // This is a cross-context-same-apartment case, we know the size.
        //

        *pcb = sizeof(CONTEXTHEADER) + sizeof(this);
    }
    else
    {
        //
        // If there are properties to marshal, get their size requirements
        // first.
        //

        Count = _properties.GetCount();
        if (Count > 0)
        {
            ULONG PropSize = 0;
            hr = GetPropertiesSizeMax(IID_IUnknown,
                                      pv,
                                      dwDestContext,
                                      pvDestContext,
                                      mshlflags,
                                      Count,
                                      FALSE,
                                      PropSize);
            if (SUCCEEDED(hr))
                TotalSize = PropSize;
        }

        //
        // Add to the total the number of bytes needed by this context.
        //

        TotalSize += sizeof(CONTEXTHEADER);

        //
        // Copy the calculated size into the supplied pointer.
        //

        *pcb = (SUCCEEDED(hr)) ? TotalSize : 0;
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetMarshalSizeMax [OUT] returning hr:%08X pcb:%d\n",
               hr, *pcb));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalInterface , public
//
//  Synopsis:   Marshals the context into the provided stream.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::MarshalInterface(
    IStream*  pstm,
    REFIID    riid,
    void*     pv,
    DWORD     dwDestContext,
    void*     pvDestContext,
    DWORD     mshlflags
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
     "CObjectContext::MarshalInterface _dwFlags:%08X riid:%I mshlflags:%08X\n",
               _dwFlags, &riid, mshlflags));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    ULARGE_INTEGER ulibPosition = {0}, ulibPosEnd = {0}, ulibInfo;
    LARGE_INTEGER  dlibMove;
    BOOL           fResetSeekPtr       = FALSE;
    ULONG          Count               = _properties.GetCount();
    HRESULT        hr                  = S_OK;
    BOOL           fJustMarshalPointer = FALSE;
    BOOL           fWroteProps         = FALSE;

    //
    // If this is a cross-context-same-apartment scenario, we only need to
    // marshal a pointer into the stream.
    //

    if (dwDestContext == MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        fJustMarshalPointer = TRUE;
    }

    if (fJustMarshalPointer == FALSE && Count > 0)
    {
        //
        // Attempt to allocate on the stack memory into which all the
        // properties can be serialized.
        //

        hr = E_OUTOFMEMORY;
        ContextProperty* pProps =
           (ContextProperty *) _alloca(sizeof(ContextProperty) * Count);

        if (pProps != NULL)
        {
            //
            // We have the necessary memory, so serialize all the
            // properties into the vector.
            //

            _properties.SerializeToVector(pProps);

            //
            // We try to marshal all the properties first, even though
            // we want the context information to precede the property
            // info in the stream.  We do this because one component of
            // the context info we marshal is the number of properties
            // and since all of the properties on the context may not
            // marshal, the value representing the number of properties
            // may change.  So by doing the properties first, we can fixup
            // the count value.  To do this, we seek past where the context
            // info will go in the stream, marshal the property info, then
            // seek back and marshal the context info.
            //

            hr = GetStreamPos(pstm, &ulibPosition);
            if (SUCCEEDED(hr))
            {
                hr = AdvanceStreamPos(pstm, sizeof(CONTEXTHEADER), &ulibInfo);
                if (SUCCEEDED(hr))
                {
                    hr = MarshalProperties(Count,
                                           pProps,
                                           pstm,
                                           IID_IUnknown,
                                           pv,
                                           dwDestContext,
                                           pvDestContext,
                                           mshlflags);
                    fWroteProps = TRUE;
                }
            }
        }
    }

    // Save the current stream pointer and reset the stream to the
    // position where we write the header.
    //
    if (fWroteProps && SUCCEEDED(hr))
    {
        fResetSeekPtr = TRUE;
        hr = GetStreamPos(pstm, &ulibPosEnd);

        if (SUCCEEDED(hr))
        {
            hr = SetStreamPos(pstm, ulibPosition.QuadPart, NULL);
        }
    }

    //
    // If the properties were successfully marshaled (or if there were no
    // properties to marshal or if we are just mashaling a pointer)
    // marshal the context information.
    //

    if (SUCCEEDED(hr))
    {
        CONTEXTHEADER hdr;
        hdr.Version.ThisVersion = OBJCONTEXT_VERSION;
        hdr.Version.MinVersion  = OBJCONTEXT_MINVERSION;
        hdr.CmnHdr.ContextId    = _contextId;
        hdr.CmnHdr.Flags        = (fJustMarshalPointer) ? 0 : CTXMSHLFLAGS_BYVAL;
//      hdr.CmnHdr.Flags        |= CTXMSHLFLAGS_HASMRSHPROP;
        hdr.CmnHdr.Reserved     = 0;
        hdr.CmnHdr.dwNumExtents = 0;
        hdr.CmnHdr.cbExtents    = 0;
        hdr.CmnHdr.MshlFlags    = mshlflags;

        if (fJustMarshalPointer == TRUE)
        {
            // Just marshaling a pointer.  Fill out the rest of the
            // header information and write the pointer into the stream.

            hdr.ByRefHdr.Reserved  = mshlflags;
            hdr.ByRefHdr.ProcessId = GetCurrentProcessId();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                hr = pstm->Write(&pv, sizeof(pv), NULL);

                // Bump reference count based on type of marshal.

                if (SUCCEEDED(hr) && (mshlflags != MSHLFLAGS_TABLEWEAK))
                {
                    // In case you're wondering why this is not an
                    // InternalAddRef... RPC releases this ref for
                    // us and they don't know anything about our internal
                    // ref count, so we just take a user reference.
                    ((IUnknown *) pv)->AddRef();
                }
            }
        }
        else
        {
            // Deep copy.  Fill out the rest of the CONTEXTHEADER and write
            // it to the stream.

            hdr.ByValHdr.Count  = Count;
            hdr.ByValHdr.Frozen = !!IsFrozen();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                // If we wrote properties into the stream, reset the seek ptr
                // to the end of the last property.

                if (fResetSeekPtr == TRUE)
                {
                    hr = SetStreamPos(pstm, ulibPosEnd.QuadPart, &ulibInfo);
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalInterface returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::ReadStreamHdrAndProcessExtents , private
//
//  Synopsis:   Reads the header from the supplied stream.  If we don't
//              understand the stream version, return
//              CO_E_INCOMPATIBLESTREAMVERSION.  Process any extensions
//              in the stream.
//
//  History:    23-Apr-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::ReadStreamHdrAndProcessExtents(
    IStream*       pstm,
    CONTEXTHEADER& hdr
    )
{
    // Read the header.
    //
    HRESULT hr = pstm->Read(&hdr, sizeof(CONTEXTHEADER), NULL);

    if (SUCCEEDED(hr))
    {
        // Verify that we recognize the stream version.
        //
        if (hdr.Version.MinVersion < OBJCONTEXT_MINVERSION)
        {
                hr = CO_E_INCOMPATIBLESTREAMVERSION;
        }
        else
        {
            if (hdr.CmnHdr.dwNumExtents != 0)
            {
                // We don't know about any extensions; skip over them.
                //
                LARGE_INTEGER dlibMove;
                dlibMove.LowPart  = hdr.CmnHdr.cbExtents;
                dlibMove.HighPart = 0;
                hr = pstm->Seek(dlibMove, STREAM_SEEK_CUR, NULL);
            }
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::UnmarshalInterface , public
//
//  Synopsis:   Unmarshals a context from the provided stream.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::UnmarshalInterface(
    IStream* pstm,
    REFIID   riid,
    void**   ppv)
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::UnmarshalInterface _dwFlags:%08X riid:%I\n",
               _dwFlags, &riid));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppv != NULL);

    *ppv = NULL;

    HRESULT         hr          = E_FAIL;
    SHORT           Version     = 0;
    SHORT           MinVersion  = 0;
    DWORD           mshlflags   = 0;
    ULONG           count       = 0;
    CObjectContext *pContext    = NULL;
    BOOL            bNewCtxId   = FALSE;

    // Read the context header and any extensions from the stream.

    CONTEXTHEADER hdr;
    hr = ReadStreamHdrAndProcessExtents(pstm, hdr);
    if (FAILED(hr))
        return hr;

    ContextID ContextId = MarshaledContextId(hdr);

    if (MarshaledByReference(hdr))
    {
        // Do a sanity check on the process ID to ensure that the pointer
        // in the stream is valid in this process.

        if (!MarshaledByThisProcess(hdr))
        {
            Win4Assert(FALSE && "Marshaled ctx ptr not valid in this process!");
            return E_FAIL;
        }

        // This is a cross-context-same-apartment or inproc case.  The
        // stream contains only a pointer to an existing context.  Read
        // the pointer.

        hr = pstm->Read(ppv, sizeof(*ppv), NULL);

        if (SUCCEEDED(hr))
        {
            // What we do with the context at this point depends on how it was
            // marshaled.  There are 3 possibilities:
            // 1) TABLEWEAK:
            //    Multiple clients may unmarshal the context.  Thus we
            //    AddRef each copy we unmarshal.  Because the table does not
            //    hold a reference however, we must make sure the context is
            //    still alive before we attempt to reference it.
            // 2) TABLESTRONG:
            //    Multiple clients may unmarshal the context.  Thus we
            //    AddRef each copy we unmarshal.  Because the table does
            //    hold a reference, we may assume the context is still alive.
            // 3) NORMAL:
            //    Only one client may unmarshal the context.  Thus we do
            //    not AddRef the context before returning it.

            if (MarshaledTableWeak(hdr))
            {
                // TABLEWEAK: we do not know if the interface is still
                // alive.  Look for the interface in our table.  If it
                // is not in the table, fail.

                LOCK(gContextLock);
                pContext = CCtxTable::LookupExistingContext(ContextId);
                if (NULL == pContext)
                    hr = E_FAIL;
                else
                    ((CObjectContext*) *ppv)->InternalAddRef();
                UNLOCK(gContextLock);

            }
            else if (MarshaledTableStrong(hdr))
            {
                // TABLESTRONG: We know the interface is still alive
                // because we AddRef'd it when we marshaled it.  Thus,
                // we can safely AddRef it and hand it out now.

                ((CObjectContext *) *ppv)->InternalAddRef();
            }
        }

        return hr;
    }

    // The common header contains the context id.  If the marshaled context
    // exists in this process, and if the existing context is not an envoy,
    // QI the existing context context for the desired IID instead of
    // unmarshaling a new one.

    LOCK(gContextLock);
    pContext = CCtxTable::LookupExistingContext(ContextId);
    if (pContext)
    {
        // We hold an uncounted ref to the context we found.  Bump the
        // ref count before releasing the lock.

        pContext->InternalAddRef();
        UNLOCK(gContextLock);

        if (pContext->IsEnvoy())
        {
            // The context we found is an envoy, so we want to go ahead
            // and unmarshal, but let's give the new context a
            // new ID so it does not clash with the existing envoy.

            bNewCtxId = TRUE;
        }
        else
        {
            // The marshaled context already lives in this process, so
            // just return a ref to the existing one.

            hr = pContext->QueryInterface(riid, ppv);
        }

        // Release the reference we took before we released the lock.

        pContext->InternalRelease();
        pContext = NULL;

        // If the context we found was not an envoy, return the results
        // of the QI to the caller.

        if (!bNewCtxId)
            return hr;
    }
    else
        UNLOCK(gContextLock);

    // The marshaled context is new to this process.  Unmarshal then add this
    // new context to our table to prevent us from unmarshaling it again in
    // the future.

    ULONG Props = MarshaledPropertyCount(hdr);
    if (SUCCEEDED(hr) && (Props > 0))
    {
        ULONG i = 0;
        do
        {
            // Try to read the property header info from the stream.

            PROPMARSHALHEADER PropHeader;
            hr = pstm->Read(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);

            // Calculate and store the stream pos of the next property.

            ULARGE_INTEGER ulibNextProp;
            if (SUCCEEDED(hr))
            {
                hr = GetStreamPos(pstm, &ulibNextProp);
                if (SUCCEEDED(hr))
                    ulibNextProp.QuadPart += PropHeader.cb;
            }

            if (SUCCEEDED(hr))
            {
                // Unmarshal the property.

                IUnknown* pUnk = NULL;
                hr = CoUnmarshalInterface(pstm, IID_IUnknown, (void**) &pUnk);
                if (SUCCEEDED(hr))
                {
                    // Add the property to this context.

                    hr = SetProperty(PropHeader.policyId, PropHeader.flags, pUnk);

                    // Release our reference to the property.

                    pUnk->Release();

                    if (SUCCEEDED(hr))
                    {
                        // Advance the stream pointer to the next property.

                        hr = SetStreamPos(pstm, ulibNextProp.QuadPart, &ulibNextProp);
                    }
                }
            }
        } while ((++i < Props) && SUCCEEDED(hr));
    }

    // If all is well, check the context table again before returning a
    // reference to ourself.  After releasing the lock above, another thread
    // could have unmarshaled this context.

    if (SUCCEEDED(hr))
    {
        // If the context was marshaled frozen, then we need to freeze
        // this context.  Otherwise, we need to create a new unique ID
        // for this context.

        if (MarshaledFrozen(hdr))
            Freeze();
        else
            bNewCtxId = TRUE;

        // Take the lock and try to find a context in this process with
        // the same ContextId.

        LOCK(gContextLock);
        pContext = CCtxTable::LookupExistingContext(ContextId);
        if (pContext && pContext->IsEnvoy())
        {
            // An envoy for the marshaled context exists in this process.
            // We want to go ahead and unmarshal, but let's give the
            // unmarshaled context a new ID so it does not clash with the
            // existing envoy.

            bNewCtxId = TRUE;
            pContext = NULL;
        }

        if (pContext)
        {
            // LookupExistingContext returned an uncounted reference.  We
            // need to bump the refcount on the context before we release
            // the lock.

            pContext->InternalAddRef();
            UNLOCK(gContextLock);

            // Another thread did unmarshal this context after we released the
            // lock above.  Return a reference to the existing context instead
            // of to ourself.

            hr = pContext->QueryInterface(riid, ppv);

            // Release our reference to the context.

            pContext->InternalRelease();
            pContext = NULL;
        }
        else
        {
            if (bNewCtxId)
            {
                hr = CreateUniqueID(ContextId);
                if (FAILED(hr))
                    return hr;
            }

            if (_dwFlags & CONTEXTFLAGS_STATICCONTEXT)
                _dwFlags &= ~CONTEXTFLAGS_STATICCONTEXT;

            _contextId = ContextId;
            _dwHashOfId = HashGuid(_contextId);

            // We do not add static objects to the tables
            if(!IsStatic())
            {
                // Make sure that the chain is not linked up at the time of
                // addition to the hash tables
//                    Win4Assert(NULL == _propChain.pNext && NULL == _propChain.pPrev);
//                    Win4Assert(NULL == _uuidChain.pNext && NULL == _uuidChain.pPrev);
                CCtxTable::s_CtxUUIDHashTable.Add(this);
            }

            UNLOCK(gContextLock);
            hr = this->QueryInterface(riid, ppv);
            if (FAILED(hr))
            {
                LOCK(gContextLock);
                CCtxTable::s_CtxUUIDHashTable.Remove(this);
                UNLOCK(gContextLock);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::ReleaseMarshalData , public
//
//  Synopsis:   Releases any data used in marshaling context.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::ReleaseMarshalData(
    IStream* pstm
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::ReleaseMarshaldata\n"));

    HRESULT hr = E_INVALIDARG;
    Win4Assert(pstm);
    if (!pstm)
        return hr;

    // Read the context header and any extensions from the stream.

    CONTEXTHEADER hdr;
    hr = ReadStreamHdrAndProcessExtents(pstm, hdr);
    if (FAILED(hr))
        return hr;

    if (MarshaledByReference(hdr))
    {
        // If the objref contains a context marshaled by reference, the
        // pointer must be valid in this process's address space.  If it
        // isn't we can't do anything with it.

        if (!MarshaledByThisProcess(hdr))
            return E_INVALIDARG;

        // If the object was marshaled TABLESTRONG or NORMAL, the objref
        // holds a reference to the object which we need to release.

        if (!MarshaledTableWeak(hdr))
        {
            CObjectContext *pCtx = NULL;
            hr = pstm->Read(&pCtx, sizeof(pCtx), NULL);
            if (SUCCEEDED(hr))
            {
                pCtx->InternalRelease();
            }
        }
    }
    else
    {
        // How many properties do we have.
        ULONG Props = MarshaledPropertyCount(hdr);

        // Unmarshal and release all the properties.
        while (Props-- > 0 && SUCCEEDED(hr))
        {
            ULARGE_INTEGER ulibNextProp;
            PROPMARSHALHEADER PropHeader;

            // Read the property header.
            hr = pstm->Read(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);
            if (FAILED(hr))
                break;

            // Get the current stream position.
            hr = GetStreamPos(pstm, &ulibNextProp);
            if (FAILED(hr))
                break;

            // Calculate the location of the next property in the stream.
            ulibNextProp.QuadPart += PropHeader.cb;

            // Unmarshal the property, release it's marshal data, and remove
            // it from the property list.
            IMarshal *pMI = NULL;
            hr = CoReleaseMarshalData(pstm);
            if (SUCCEEDED(hr))
            {
                RemoveProperty(PropHeader.policyId);
            }

            // Advance the stream pointer to the next property.
            hr = SetStreamPos(pstm, ulibNextProp.QuadPart, &ulibNextProp);
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::DisconnectObject , public
//
//  Synopsis:   Disconnects from remote object.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::DisconnectObject(
    DWORD dwReserved
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::DisconnectObject\n"));
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoyUnmarshalClass , public
//
//  Synopsis:   Provides caller with the CLSID of the proxy for this class.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetEnvoyUnmarshalClass(
    DWORD  dwDestContext,
    CLSID* pclsid
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::GetEnvoyUnmarshalClass\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    *pclsid = CLSID_ObjectContext;
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoySizeMax , public
//
//  Synopsis:   Provides the maximum size of the the marshaling packet.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetEnvoySizeMax(
    DWORD  dwDestContext,
    DWORD* pcb
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetEnvoySizeMax _dwFlags:%08X\n", _dwFlags));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pcb != NULL);

    ULONG   TotalSize = 0;
    HRESULT hr        = S_OK;
    ULONG   Count     = _properties.GetCount();

    // If the size requirements have already been calculated for this context,
    // do not calculate again.  Just use the previously calculated value.
    //
    if (_pifData)
    {
        *pcb = _MarshalSizeMax;
        return hr;
    }

    if (dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_CROSSCTX)
    {
        //
        // This is an cross-context-same-apartment or inproc case.  Only a
        // pointer to this will be marshaled, so we know the size.
        //

        *pcb = sizeof(CONTEXTHEADER) + sizeof(DATAELEMENT)
            - sizeof(BYTE) + sizeof(this);
        return hr;
    }

    if (Count > 0)
    {
        ULONG PropSize = 0;
        hr = GetPropertiesSizeMax(IID_NULL,
                                  NULL,
                                  dwDestContext,
                                  NULL,
                                  0,
                                  Count,
                                  TRUE,
                                  PropSize);
        if (SUCCEEDED(hr))
            TotalSize = PropSize;
    }

    //
    // Add to the total the number of bytes needed by this context.
    //

    TotalSize += (sizeof(CONTEXTHEADER) + sizeof(DATAELEMENT) - sizeof(BYTE));

    //
    // Copy the calculated size into the supplied pointer.
    //

    Win4Assert(hr==S_OK);
    *pcb = (SUCCEEDED(hr)) ? TotalSize : 0;

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetEnvoySizeMax returning hr:%08X pcb:%d\n",
               hr, *pcb));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalEnvoy , public
//
//  Synopsis:   Write marshaling packet into the provided stream.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::MarshalEnvoy(
    IStream* pstm,
    DWORD    dwDestContext
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::MarshalEnvoy\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    ULARGE_INTEGER ulibPosition = {0}, ulibPosEnd = {0}, ulibInfo;
    LARGE_INTEGER  dlibMove;
    BOOL           fResetSeekPtr       = FALSE;
    ULONG          Count               = _properties.GetCount();
    HRESULT        hr                  = S_OK;
    BOOL           fJustMarshalPointer = FALSE;
    BOOL           fWroteProps         = FALSE;

    // If this context has already been envoy marshaled, just write the
    // InterfaceData to the stream.
    //
    if (_pifData)
    {
        return pstm->Write(&_pifData->abData, _pifData->ulCntData, NULL);
    }

    //
    // If this is a cross-context-same-apartment scenario, we only need to
    // marshal a pointer into the stream.
    //

    if (dwDestContext == MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        fJustMarshalPointer = TRUE;
    }

    if (fJustMarshalPointer == FALSE && Count > 0)
    {
        //
        // Attempt to allocate on the stack memory into which all the
        // properties can be serialized.
        //

        hr = E_OUTOFMEMORY;
        ContextProperty* pProps =
           (ContextProperty *) _alloca(sizeof(ContextProperty) * Count);

        if (pProps != NULL)
        {
            //
            // We have the necessary memory, so serialize all the
            // properties into the vector.
            //

            _properties.SerializeToVector(pProps);

            //
            // We try to marshal all the properties first, even though
            // we want the context information to precede the property
            // info in the stream.  We do this because one component of
            // the context info we marshal is the number of properties
            // and since all of the properties on the context may not
            // marshal, the value representing the number of properties
            // may change.  So by doing the properties first, we can fixup
            // the count value.  To do this, we seek past where the context
            // info will go in the stream, marshal the property info, then
            // seek back and marshal the context info.
            //

            hr = GetStreamPos(pstm, &ulibPosition);
            if (SUCCEEDED(hr))
            {
                hr = AdvanceStreamPos(pstm, sizeof(CONTEXTHEADER), &ulibInfo);
                if (SUCCEEDED(hr))
                {
                    hr = MarshalEnvoyProperties(Count,
                                                pProps,
                                                pstm,
                                                dwDestContext);
                    fWroteProps = TRUE;
                }
            }
        }
    }

    // Save the current stream pointer and reset the stream to the
    // position where we write the header.
    //
    if (fWroteProps && SUCCEEDED(hr))
    {
        fResetSeekPtr = TRUE;
        hr = GetStreamPos(pstm, &ulibPosEnd);

        if (SUCCEEDED(hr))
        {
            hr = SetStreamPos(pstm, ulibPosition.QuadPart, NULL);
        }
    }

    //
    // If the properties were successfully marshaled, marshal the context
    // information.
    //

    if (SUCCEEDED(hr))
    {
        CONTEXTHEADER hdr;
        hdr.Version.ThisVersion = OBJCONTEXT_VERSION;
        hdr.Version.MinVersion  = OBJCONTEXT_MINVERSION;
        hdr.CmnHdr.ContextId    = _contextId;
        hdr.CmnHdr.Flags        = (fJustMarshalPointer) ? 0 : CTXMSHLFLAGS_BYVAL;
//      hdr.CmnHdr.Flags        |= CTXMSHLFLAGS_HASMRSHPROP;
        hdr.CmnHdr.Reserved     = 0;
        hdr.CmnHdr.dwNumExtents = 0;
        hdr.CmnHdr.cbExtents    = 0;
        hdr.CmnHdr.MshlFlags    = 0;

        if (fJustMarshalPointer == TRUE)
        {
            // Just marshaling a pointer.  Fill out the rest of the
            // header information and write the pointer into the stream.

            hdr.ByRefHdr.Reserved  = 0;
            hdr.ByRefHdr.ProcessId = GetCurrentProcessId();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                void* pv = this;
                hr = pstm->Write(&pv, sizeof(pv), NULL);

                // Because RPC has no knowledge of our internal ref count,
                // we have to take a user reference here so the RPC release
                // works correctly.
                ((IUnknown *) pv)->AddRef();
            }
        }
        else
        {
            hdr.ByValHdr.Count  = Count;
            hdr.ByValHdr.Frozen = !!IsFrozen();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                // If we wrote properties into the stream, reset the seek ptr
                // to the end of the last property.

                if (fResetSeekPtr == TRUE)
                    hr = SetStreamPos(pstm, ulibPosEnd.QuadPart, &ulibInfo);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalEnvoy returning hr:%08X\n", hr));
    return hr;
}


// Helper function for IsPunkInModule (lifted from task.cxx)
inline BOOL IsPathSeparator( WCHAR ch )
{
    return (ch == L'\\' || ch == L'/' || ch == L':');
}

//+--------------------------------------------------------------------------
//
//  Member:     IsPunkInModule , private
//
//  Synopsis:   This function determines if the supplied interface pointer
//              points to an object that is implemented in the supplied
//              module.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
BOOL IsPunkInModule(
    IUnknown* pUnk,
    LPCWSTR   lpszIn
    )
{
    BOOL retval = FALSE;

    // Get the address of the supplied interface's QI function.
    //
    DWORD* lpVtbl = *(DWORD**)pUnk;
    DWORD_PTR dwQIAddr = *lpVtbl;

    // Try to get the module handle of the named module.  If we can't get this,
    // we know COMSVCS is not even loaded, so we know the given address is not
    // in it.
    //
    HMODULE hSvcs = GetModuleHandleW(lpszIn);
    if (hSvcs)
    {
        // Let's try to query the system for information about the supplied
        // address.
        //
        MEMORY_BASIC_INFORMATION MBI;
        if (VirtualQuery((LPVOID)dwQIAddr, &MBI, sizeof(MBI)))
        {
            // If the address is mapped into an image section, we are still
            // in business.  Otherwise, we know it's not in the COMSVCS dll.
            //
            if (MBI.Type == MEM_IMAGE)
            {
                // Get the path of the image file.
                //
                WCHAR lpModuleName[MAX_PATH+1];

                *lpModuleName = L'\0';	// PREfix bug: Uninitialized variable

                DWORD nSize = GetModuleFileName((HINSTANCE)MBI.AllocationBase,
                                                lpModuleName, sizeof(lpModuleName)/sizeof(lpModuleName[0]));

                lpModuleName[sizeof(lpModuleName)/sizeof(lpModuleName[0])-1] = L'\0';
                if (nSize != 0 && nSize < MAX_PATH)
                {
                    // Find the end of the string and determine the string length.
                    //
                    WCHAR* pch = NULL;
                    for (pch=lpModuleName; *pch; pch++);

                    DecLpch(lpModuleName, pch);

                    while (!IsPathSeparator(*pch))
                       DecLpch(lpModuleName, pch);

                    // we're at the last separator.
                    //
                    if (!lstrcmpiW(pch+1, lpszIn))
                        retval = TRUE;
                }
            }
        }
    }

    return retval;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::UnmarshalEnvoy , public
//
//  Synopsis:   Unmarshal the IObjContext.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::UnmarshalEnvoy(
    IStream* pstm,
    REFIID riid,
    void** ppv
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::UnmarshalEnvoy riid:%I\n",
               &riid));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppv != NULL);

    // Read the stream header and any extensions.
    //
    CONTEXTHEADER hdr;
    HRESULT hr = ReadStreamHdrAndProcessExtents(pstm, hdr);

    if (SUCCEEDED(hr) && (MarshaledByReference(hdr)))
    {
        Win4Assert(FALSE && "UnmarshalEnvoy by reference?!");
        return E_UNEXPECTED;
    }

    // If everything is still ok, try to reconstitute any properties.
    //
    ULONG Props = MarshaledPropertyCount(hdr);
    if (SUCCEEDED(hr) && (Props > 0))
    {
        HRESULT hrProp = S_OK;
        ULONG i = 0;
        do
        {
            // Try to read the property header info from the stream.
            //
            PROPMARSHALHEADER PropHeader;
            hr = pstm->Read(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);

            // Calculate and store the stream ptr for the next property.
            //
            ULARGE_INTEGER ulibNextProp;
            LARGE_INTEGER  dlibMove;
            if (SUCCEEDED(hr))
            {
                hr = GetStreamPos(pstm, &ulibNextProp);
                if (SUCCEEDED(hr))
                    ulibNextProp.QuadPart += PropHeader.cb;
            }

            if (SUCCEEDED(hr))
            {
                // Create an instance of the proxy, asking for a pointer to its
                // IMarshalEnvoy interface.
                //
                IMarshalEnvoy* pME = NULL;
                hrProp = CoCreateInstance(PropHeader.clsid, NULL, CLSCTX_SERVER,
                                          IID_IMarshalEnvoy, (void**) &pME);
                if (SUCCEEDED(hrProp))
                {
                    // Unmarshal the property.
                    //
                    IUnknown* pUnk = NULL;
                    hrProp = pME->UnmarshalEnvoy(pstm, IID_IUnknown, (void**) &pUnk);
                    if (SUCCEEDED(hrProp))
                    {
                        hr = SetProperty(PropHeader.policyId, PropHeader.flags, pUnk);
                        pUnk->Release();
                    }

                    // Release the IMarshalEnvoy.
                    //
                    pME->Release();
                }

                // Advance stream pointer to beginning of next property.
                //
                if (SUCCEEDED(hr))
                {
                    hr = SetStreamPos(pstm, ulibNextProp.QuadPart, &ulibNextProp);
                }
            }
        } while ((++i < Props) && SUCCEEDED(hr));
    }

    // If all is well, set our frozen-ness state using the value read from the
    // stream and return a pointer to this object.
    //
    if (SUCCEEDED(hr))
    {
        if (MarshaledFrozen(hdr))
            Freeze();
        hr = this->QueryInterface(riid, ppv);
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::UnmarshalEnvoy returning hr:%08X\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetPropertiesSizeMax , public
//
//  Synopsis:   Gets the number of bytes required to marshal all the
//              properterties on the context.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetPropertiesSizeMax(
    REFIID  riid,
    void*   pv,
    DWORD   dwDestContext,
    void*   pvDestContext,
    DWORD   mshlflags,
    ULONG   cProps,
    BOOL    fEnvoy,
    ULONG&  PropSize
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::GetPropertiesSizeMax [IN] cProps:%d\n", cProps));

    PropSize = 0;
    ULONG size = 0;

    //
    // Attempt to allocate space on the stack for a vector into which
    // the properties can be serialized.
    //

    HRESULT hr = E_OUTOFMEMORY;
    ContextProperty* pProps =
       (ContextProperty *) _alloca(sizeof(ContextProperty) * cProps);

    if (pProps != NULL)
    {
        //
        // We have the needed memory, so serialize all the properties
        // into a vector and initialize a pointer to the first
        // property.
        //

        _properties.SerializeToVector(pProps);
        ContextProperty* pCurProp = pProps;

        //
        // Now loop through all the properties and accumulate the
        // amount of space needed to marshal them.
        //

        ULONG i = 0;
        hr = S_OK;
        CPFLAGS cpflags = (fEnvoy == TRUE) ? CPFLAG_ENVOY : CPFLAG_EXPOSE;

        do
        {
            if (PropOkToMarshal(pCurProp, cpflags) == TRUE)
            {
                ULONG cb = 0;
                IUnknown* punk = pCurProp->pUnk;
                if (fEnvoy == TRUE)
                {
                    IMarshalEnvoy* pME  = NULL;
                    if (SUCCEEDED(punk->QueryInterface(IID_IMarshalEnvoy,
                                                       (void **) &pME)))
                    {
                        hr = pME->GetEnvoySizeMax(dwDestContext, &cb);
                        pME->Release();
                        size += sizeof(PROPMARSHALHEADER);
                    }
                }
                else
                {
                    hr = CoGetMarshalSizeMax(&cb,
                                             riid,
                                             punk,
                                             dwDestContext,
                                             pvDestContext,
                                             mshlflags);

                    size += sizeof(PROPMARSHALHEADER);
                }

                size += ((cb + 7) & ~7);
            }

            pCurProp++;

        } while ((++i < cProps) && SUCCEEDED(hr));
    }

    if (SUCCEEDED(hr))
        PropSize = size;

    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::GetPropertiesSizeMax [OUT] PropSize:%08X\n", PropSize));
    return hr;
}


STDMETHODIMP CObjectContext::SetContextMarshaler(IContextMarshaler* pProp)
{
    if (IsFrozen())
    {
        return E_UNEXPECTED;
    }
    else
    {
        if (_pMarshalProp != NULL)
        {
            ((IUnknown*)_pMarshalProp)->Release();
            _pMarshalProp = NULL;
        }

        if (pProp != NULL)
        {
            return ((IUnknown*)pProp)->QueryInterface(IID_IMarshal, (void**) &_pMarshalProp);
        }
        else
        {
            _pMarshalProp = NULL;
            return S_OK;
        }
    }
}


STDMETHODIMP CObjectContext::GetContextMarshaler(IContextMarshaler** ppProp)
{
    if (_pMarshalProp != NULL)
    {
        return ((IUnknown*)_pMarshalProp)->QueryInterface(IID_IContextMarshaler, (void**) ppProp);
    }
    else
    {
        *ppProp = NULL;
        return S_OK;
    }
}


STDMETHODIMP CObjectContext::SetContextFlags(DWORD dwFlags)
{
    if (IsFrozen())
    {
        return E_UNEXPECTED;
    }
    else
    {
        _dwFlags |= dwFlags;
        return S_OK;
    }
}


STDMETHODIMP CObjectContext::ClearContextFlags(DWORD dwFlags)
{
    if (IsFrozen())
    {
        return E_UNEXPECTED;
    }
    else
    {
        _dwFlags &= ~dwFlags;
        return S_OK;
    }
}


STDMETHODIMP CObjectContext::GetContextFlags(DWORD *pdwFlags)
{
    if (NULL == pdwFlags)
    {
        return E_INVALIDARG;
    }
    else
    {
        *pdwFlags = _dwFlags;
        return S_OK;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalEnvoyProperties , private
//
//  Synopsis:   This method attempts to marshal each property into the
//              supplied IStream pointer.  If a property cannot be marshaled,
//              it is simply not marshaled into the stream.
//
//  Returns:    S_OK     if successful
//              E_FAIL   if an error occurs
//
//  History:    20-Apr-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::MarshalEnvoyProperties(
    ULONG&            Count,
    ContextProperty*& pProps,
    IStream*          pstm,
    DWORD             dwDestContext
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(Count > 0);
    Win4Assert(pProps != NULL);

    HRESULT           hr        = S_OK;
    int               i         = Count;
    ContextProperty*  pCurProp  = pProps;
    PROPMARSHALHEADER PropHeader;
    LARGE_INTEGER     libMove;
    ULARGE_INTEGER    ulibHeaderPos, ulibBegin, ulibEnd;

    do
    {
        // Assume the property could not be marshaled.
        //
        BOOL fAddedProperty = FALSE;

        // Attempt to marshal the property.
        //
        IUnknown* punk = pCurProp->pUnk;
        if (PropOkToMarshal(pCurProp, CPFLAG_ENVOY) == TRUE)
        {
            // QI the property for the IMarshalEnvoy interface.  If the
            // property doesn't support IMarshalEnvoy, we can't marshal it.
            //
            IMarshalEnvoy* pME = NULL;
            if (SUCCEEDED(punk->QueryInterface(IID_IMarshalEnvoy, (void**)&pME)))
            {
                // Get the property's unmarshal CLSID.
                //
                CLSID clsid;
                hr = pME->GetEnvoyUnmarshalClass(dwDestContext, &clsid);
                if (SUCCEEDED(hr))
                {
                    // Get the stream's present seek ptr. This is where we'll
                    // reset to later to write the property header information.
                    //
                    hr = GetStreamPos(pstm, &ulibHeaderPos);
                    if (SUCCEEDED(hr))
                    {
                        // Now advance the seek ptr past where the header
                        // info will go. Note that we save the position
                        // returned - the beginning of the property data.
                        //
                        hr = AdvanceStreamPos(pstm, sizeof(PROPMARSHALHEADER),
                                              &ulibBegin);
                        if (SUCCEEDED(hr))
                        {
                            // Ask the property to marshal its data into the
                            // stream.
                            //
                            hr = pME->MarshalEnvoy(pstm, dwDestContext);
                            if (SUCCEEDED(hr))
                            {
                                // Write a header for the property into the stream.
                                //
                                hr = MarshalPropertyHeader(pstm,
                                                           clsid,
                                                           pCurProp,
                                                           ulibBegin,
                                                           ulibHeaderPos);
                                if (SUCCEEDED(hr))
                                    fAddedProperty = TRUE;
                            }
                        }
                    }
                }

                // Release the marshaling interface pointer.
                pME->Release();
            }
        }

        // If the property could not be marshaled, decrement the count.
        //
        if (fAddedProperty == FALSE)
            --Count;

        // Advance pointer to the next property.
        //
        ++pCurProp;
    } while ((--i > 0) && (SUCCEEDED(hr)));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalEnvoyProperties returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalProperties , private
//
//  Synopsis:   This method attempts to marshal each property into the
//              supplied IStream pointer.  If a property cannot be marshaled,
//              it is simply not marshaled into the stream.
//
//  Returns:    S_OK     if successful
//              E_FAIL   if an error occurs
//
//  History:    18-Jan-98   Johnstra      Created.
//              20-Apr-98   Johnstra      1) Broke envoy marshaling out into
//                                           separate function.
//                                        2) Use CoMarshalInterface to support
//                                           properties that need to be
//                                           standard marshaled.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::MarshalProperties(
    ULONG&            Count,
    ContextProperty*& pProps,
    IStream*          pstm,
    REFIID            riid,
    void*             pv,
    DWORD             dwDestContext,
    void*             pvDestContext,
    DWORD             mshlflags
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(Count > 0);
    Win4Assert(pProps != NULL);

    HRESULT           hr        = S_OK;
    int               i         = Count;
    ContextProperty*  pCurProp  = pProps;
    LARGE_INTEGER     libMove;
    ULARGE_INTEGER    ulibHeaderPos, ulibBegin, ulibEnd;

    do
    {
        // Assume the property does not get marshaled.
        //
        BOOL fAddedProperty = FALSE;

        // If the property qualifies, marshal it.
        //
        IUnknown* punk = pCurProp->pUnk;
        if (PropOkToMarshal(pCurProp, CPFLAG_EXPOSE) == TRUE)
        {
            // Get the stream's present seek ptr. This is where we'll
            // reset to later to write the property header information.
            //
            hr = GetStreamPos(pstm, &ulibHeaderPos);
            if (SUCCEEDED(hr))
            {
                // Now advance the seek ptr past where the header
                // info will go. Note that we save the position
                // returned - the beginning of the property data.
                //
                hr = AdvanceStreamPos(pstm, sizeof(PROPMARSHALHEADER), &ulibBegin);
                if (SUCCEEDED(hr))
                {
                    // Marshal the property into the stream.
                    //
                    hr = CoMarshalInterface(pstm, riid, punk, dwDestContext,
                                                pvDestContext, mshlflags);
                    if (SUCCEEDED(hr))
                    {
                        // Write a header for the property into the stream.
                        //
                        hr = MarshalPropertyHeader(pstm, CLSID_NULL, pCurProp,
                                                   ulibBegin, ulibHeaderPos);
                        if (SUCCEEDED(hr))
                            fAddedProperty = TRUE;
                    }
                }
            }
        }

        // If the property could not be marshaled, decrement the count.
        //
        if (fAddedProperty == FALSE)
            --Count;

        // Advance pointer to the next property.
        //
        ++pCurProp;
    } while ((--i > 0) && (SUCCEEDED(hr)));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalProperties returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalPropertyHeader , private
//
//  Synopsis:   This method marshals the per-property information required
//              to reconstitute the property when unmarshaling.  In order
//              to unmarshal, the context needs to know the CLSID of the
//              proxy, the property id, the property flags, and the number
//              of bytes padding between the end of the current property and
//              the beginning of the next one.
//
//  History:    18-Jan-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::MarshalPropertyHeader(
    IStream*&           pstm,
    REFCLSID            clsid,
    ContextProperty*    pProp,
    ULARGE_INTEGER&     ulibBegin,
    ULARGE_INTEGER&     ulibHeaderPos
    )
{
    // Align the stream on the next 8-byte boundary.
    //
    HRESULT hr = (PadStream(pstm)) ? S_OK : E_FAIL;

    if (SUCCEEDED(hr))
    {
        // Get the  stream's seek pointer.  We need this to restore the stream
        // pointer after writing the header.
        //
        ULARGE_INTEGER ulibEnd;
        hr = GetStreamPos(pstm, &ulibEnd);

        if (SUCCEEDED(hr))
        {
            // Move back in the stream to the location where the header is to
            // be written.
            //
            hr = SetStreamPos(pstm, ulibHeaderPos.QuadPart, NULL);

            if (SUCCEEDED(hr))
            {
                // Initialize a header for the property.
                //
                PROPMARSHALHEADER PropHeader;
                PropHeader.clsid    = clsid;
                PropHeader.policyId = pProp->policyId;
                PropHeader.flags    = pProp->flags;
                PropHeader.cb       = (ULONG) ulibEnd.LowPart - ulibBegin.LowPart;

                // Write the header into the stream.
                //
                hr = pstm->Write(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);

                if (SUCCEEDED(hr))
                {
                    // And finally, move the seek ptr back to the end of the property
                    // info.  If this succeeds, we indicate that the property was
                    // successfully marshaled.
                    //
                    hr = SetStreamPos(pstm, ulibEnd.QuadPart, NULL);
                }
            }
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::SetProperty , public
//
//  Synopsis:   Adds the supplied tuple to the internal list of context
//              properties.  If the internal list already contains a property
//              whose elements match those supplied, the call fails.
//
//  Returns:    S_OK          - if property is successfully Set/Added
//              E_INVALIDARG  - if a NULL pUnk is supplied.
//              E_FAIL        - if the object context is frozen or a property
//                              with the supplied GUID is already in the list
//              E_OUTOFMEMORY - if resources are not available
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::SetProperty(
    REFGUID   rGUID,
    CPFLAGS   flags,
    IUnknown* pUnk
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::SetProperty GUID:%I flags:0x08X\n", &rGUID, flags));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    //
    // It is expressly forbidden to add a property with a NULL GUID.
    //

    Win4Assert(!(pUnk == NULL));
    if (pUnk == NULL)
        return E_INVALIDARG;

    //
    // If the context is frozen, the specified property is already in
    // the list, or the property isn't valid, return E_FAIL.
    //

    HRESULT hr = E_FAIL;

    if (!IsFrozen())
    {
        //
        // Do validity checks:
        // 1) If the object supports IMarshalEnvoy, CPFLAG_ENVOY must be set.
        //

        hr = S_OK;

#if 0
        // Unfortunately neither this check nor the inverse check
	// works. There are plenty of properties (Partition, Security etc)
	// that call with CPFLAG_ENVOY set, but don't implement
	// IMarshalEnvoy. There is at least one property (TransactionProperty)
	// that calls without CPFLAG_ENVOY set, but implements
	// IMarshalEnvoy. Go Figure. Sajia.
	
	IMarshalEnvoy* pME = NULL;
	if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshalEnvoy,
					   (void **) &pME)))
	{
	   pME->Release();
	   if (CPFLAG_ENVOY != (flags & CPFLAG_ENVOY))
	   {
	      Win4Assert(0 && "Succeeded QI for IID_IMarshalEnvoy but CPFLAG_ENVOY flag not set in SetProperty");
	      hr = E_FAIL;
	   }
	}
#endif
        //
        // If the property passed validity checks, try to add it.
        //

        if (SUCCEEDED(hr))
        {
            // Context may have been frozen by another thread.  Set return
            // value to E_FAIL just in case.

            hr = E_FAIL;

            Win4Assert(!IsFrozen());
            if (!IsFrozen())
            {
	       if (_properties.Add(rGUID, flags, pUnk) == TRUE)
	       {
		  hr = S_OK;
	       }
            }
        }
    }

    //
    // AddRef pUnk if the Add succeeded.
    //

    if (SUCCEEDED(hr))
        pUnk->AddRef();

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::SetProperty returning hr: %08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetProperty , public
//
//  Synopsis:   Returns the context property identified by GUID to the caller.
//
//  Returns:    S_OK
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetProperty(
    REFGUID    rGUID,
    CPFLAGS*   pFlags,
    IUnknown** ppUnk
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetProperty GUID:%I\n", &rGUID));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppUnk != NULL);
    Win4Assert(pFlags != NULL);

    HRESULT hr = S_OK;

    //
    // Initialize returned interface ptr to NULL.
    //

    *ppUnk = NULL;

    //
    // Take the lock if the context is not frozen.
    //

    BOOL fLocked = FALSE;
    if (!IsFrozen())
    {
        LOCK(gContextLock);
        fLocked = TRUE;
    }

    //
    // Try to get the specified property.
    //

    ContextProperty* pProp = _properties.Get(rGUID);

    //
    // Release the lock if we hold it.
    //

    if (fLocked == TRUE)
        UNLOCK(gContextLock);

    //
    // If a property was retrieved, copy the flags and interface ptr
    // into the out params and AddRef the interface ptr.
    //

    if (pProp != NULL)
    {
        *pFlags = pProp->flags;
        *ppUnk = pProp->pUnk;
        (*ppUnk)->AddRef();
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::RemoveProperty , public
//
//  Synopsis:   Removes the specified property from the context.
//
//  Returns:    S_OK    - If the specified property is removed.
//              E_FAIL  - If the context is frozen or if the specified property
//                        is not present on the context.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::RemoveProperty(
    REFGUID rGUID
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
            "CObjectContext::RemoveProperty GUID:%I\n", &rGUID));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    //
    // If the context is not frozen, attempt to remove the specified property
    // from the list, release our reference to the propertys punk, and
    // delete the property.
    //

    HRESULT hr = E_FAIL;
    if (!IsFrozen())
    {
        LOCK(gContextLock);
        if (!IsFrozen())
        {
            _properties.Remove(rGUID);
            hr = S_OK;
        }
        UNLOCK(gContextLock);
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::RemoveProperty returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::EnumContextProps , public
//
//  Synopsis:   Returns an IEnumContextProps interface pointer to the caller.
//              Creates a snapshot of the internal list of context properties
//              so the enumerator will have a consitent collection to work
//              with.
//
//  Returns:    S_OK           - if the enumerator is successfully created.
//              E_OUTOFMEMORY  - if resources are not available.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::EnumContextProps(
    IEnumContextProps** ppEnumContextProps
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::EnumContextProps\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppEnumContextProps != NULL);

    //
    // Initialize the out param to zero.
    //

    *ppEnumContextProps = NULL;

    //
    // Take the lock only if the property is not frozen.
    //

    BOOL fLocked = FALSE;
    if (!IsFrozen())
    {
        LOCK(gContextLock);
        fLocked = TRUE;
    }

    //
    // Create a snapshot of the property list for the enumerator to use.  This
    // is just an immutable vector of ContextProperty objects.
    //

    ContextProperty* pList = NULL;
    CEnumContextProps* pEnumContextProps = NULL;

    ULONG cItems = _properties.GetCount();
    if (cItems != 0)
    {
        pList = new ContextProperty[sizeof(ContextProperty) * cItems];
        if (pList != NULL)
        {
            _properties.SerializeToVector(pList);
            for (ULONG i = 0; i < cItems; i++)
                pList[i].pUnk->AddRef();
        }
        else
            goto exit_point;
    }

    //
    // Create the enumerator object.
    //

    pEnumContextProps = new CEnumContextProps(pList, cItems);
    if (pEnumContextProps && !pEnumContextProps->ListRefsOk())
    {
        delete pEnumContextProps;
        pEnumContextProps = NULL;
    }


exit_point:

    *ppEnumContextProps = pEnumContextProps;

    //
    // Release the lock if took it.
    //

    if (fLocked == TRUE)
        UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::EnumContextProps returning hr: %08X\n",
        (*ppEnumContextProps) ? S_OK : E_OUTOFMEMORY));
    return (*ppEnumContextProps != NULL) ? S_OK : E_OUTOFMEMORY;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Freeze , public
//
//  Synopsis:   Freezes the object context.  Once the context is frozen,
//              properties cannot be added/removed.
//
//  Returns:    S_OK
//
//  History:    19-Dec-97   Johnstra      Created.
//
//              27-Jan-98   Johnstra      Call Freeze method on all properties
//                                        that support IPolicyMaker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::Freeze()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::Freeze\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    // If already frozen, return S_OK.

    HRESULT hr = S_OK;
    if (!IsFrozen())
    {
        // Pin down the apartment for the context now

        hr = GetCurrentComApartment(&_pApartment);
        Win4Assert(SUCCEEDED(hr) && _pApartment);

        // Freeze the context and get the number of properties.

        LOCK(gContextLock);
        ULONG cnt = 0;
        if (_properties.CreateCompareBuffer())
        {
            _dwFlags |= CONTEXTFLAGS_FROZEN;
            cnt = _properties.GetCount();
        }
        UNLOCK(gContextLock);

        if (cnt)
        {
            // Try to serialize all the properties into a vector.

            hr = E_OUTOFMEMORY;
            ContextProperty* pList =
               (ContextProperty *) _alloca(sizeof(ContextProperty) * cnt);
            if (pList != NULL)
            {
                hr = S_OK;
                _properties.SerializeToVector(pList);

                // Cycle through the properties.  Call Freeze on any
                // that implement IPolicyMaker.

                for (ULONG i = 0; i < cnt && SUCCEEDED(hr); i++)
                {
                    IUnknown* pUnk = pList[i].pUnk;
                    IPolicyMaker* pPM = NULL;
                    if (SUCCEEDED(pUnk->QueryInterface(IID_IPolicyMaker,
                                                       (void**) &pPM)))
                    {
                        hr = pPM->Freeze((IObjContext *) this);
                        pPM->Release();
                    }
                }
            }

            // Un-freeze if the properties were not successfully frozen

            if (FAILED(hr))
                _dwFlags &= ~CONTEXTFLAGS_FROZEN;
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::DoCallback , public
//
//  Synopsis:   Calls the supplied function.  This method enables a caller
//              with a pointer to an object context to call a function from
//              that context while the caller's code is not necessarily in
//              the context.
//
//  History:    29-Jan-98   Johnstra      Created
//              19-Apr-98   Johnstra      Switches to the context's apt if
//                                        the caller is not in the same apt.
//              30-Jun-98   GopalK        Rewritten
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::DoCallback(PFNCTXCALLBACK pfnCallback,
                                        void *pParam, REFIID riid,
                                        unsigned int iMethod)
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::DoCallback [IN]\n"));

    HRESULT hr = InternalContextCallback(pfnCallback, pParam, riid, iMethod, NULL);

    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::DoCallback [OUT] hr=0x%x\n", hr));
    return(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::ContextCallback    public
//
//  Synopsis:   This is the public version of IObjContext::DoCall. The pParam argument is
//              used to pass structured (but still arbitrary) information that can be used by
//              Context policies.
//
//              Calls the supplied function.  This method enables a caller
//              with a pointer to an object context to call a function from
//              that context while the caller's code is not necessarily in
//              the context.
//
//
//  History:    26-Jun-98   GopalK      Created
//              14-May-99   ScottRob    Split ContextCallback to make InternalContextCallback
//
//----------------------------------------------------------------------------
extern "C" GUID GUID_FinalizerCID;
extern "C" IID  IID_IEnterActivityWithNoLock;

STDMETHODIMP CObjectContext::ContextCallback(PFNCONTEXTCALL pfnCallback,
                                             ComCallData *pParam,
                                             REFIID riid,
                                             int iMethod,
                                             IUnknown *pUnk)
{
  ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::ContextCallback\n"));

  GUID guidOriginalCID;
  BOOL fNeedToRestore = FALSE;
  HRESULT hr;

  if(FinalizerBypassEnabled() && riid == IID_IEnterActivityWithNoLock)
  {
      fNeedToRestore = TRUE;
      hr = GetCurrentLogicalThreadId(&guidOriginalCID);
      if(SUCCEEDED(hr))
         SetCurrentLogicalThreadId(GUID_FinalizerCID);
      if(FAILED(hr))
         return hr;
  }

  hr = InternalContextCallback((PFNCTXCALLBACK) pfnCallback,(void*) pParam, riid, iMethod, pUnk);

  if(fNeedToRestore)
  {
     HRESULT hr2 = SetCurrentLogicalThreadId(guidOriginalCID);
     if(FAILED(hr2)) hr = hr2;
  }

  ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::ContextCallback [OUT] hr=0x%x\n", hr));
  return(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::InternalContextCallback    public
//
//  Synopsis:   Switches to the given context and calls the supplied function.
//              This is an out-of-band mechansim used by the service providers
//              to execute code inside a context while executing potentially
//              outside the context
//
//  History:    26-Jun-98   GopalK      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::InternalContextCallback(PFNCTXCALLBACK pfnCallback,
                                             void *pParam,
                                             REFIID riid,
                                             int iMethod,
                                             IUnknown *pUnk)
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::InternalContextCallback\n"));

    ASSERT_LOCK_NOT_HELD(gContextLock);

    HRESULT hr = E_INVALIDARG;

    // Ensure that the context has been pinned to an apartment
    if(_pApartment)
    {
        // Initialize channel
        hr = InitChannelIfNecessary();
        if(SUCCEEDED(hr))
        {
            // Check for the need to switch apartments
            if(_pApartment->GetAptId() != GetCurrentApartmentId())
            {
                BOOL fCreate = TRUE;
                CPolicySet *pPS = NULL;

                Win4Assert (pfnCallback && "Must have a callback to switch between apartments");

                // Make sure the apartment we're calling into is started, if
                // we have anything to say about it.
                hr = _pApartment->StartServerExternal();
                if (SUCCEEDED(hr))
                {
                    // Obtain the RemUnk proxy
                    IRemUnknownN *pRemUnk = NULL;                
                    hr = _pApartment->GetRemUnk(&pRemUnk);

                    if(SUCCEEDED(hr))
                    {
                        // Obatin SPSNode between current context and server context
                        hr = ObtainPolicySet(GetCurrentContext(), this,
                                             PSFLAG_PROXYSIDE, &fCreate,
                                             &pPS);
                    }
                    
                    // Check for success
                    if(SUCCEEDED(hr))
                    {
                        XAptCallback callbackData;
                        COleTls Tls;
                        
                        // Save SPSNode in Tls
                        CPolicySet *pOldPS = Tls->pPS;
                        Tls->pPS = pPS;
                        
                        // Initialize
                        callbackData.pfnCallback = (PTRMEM) pfnCallback;
                        callbackData.pParam      = (PTRMEM) pParam;
                        callbackData.pServerCtx  = (PTRMEM) this;
                        callbackData.pUnk        = (PTRMEM) pUnk;
                        callbackData.iid         = riid;
                        callbackData.iMethod     = iMethod;

                        hr = gProcessSecret.GetProcessSecret(&(callbackData.guidProcessSecret));
                        if (SUCCEEDED(hr))
                        {
                            // Execute the callback
                            hr = pRemUnk->DoCallback(&callbackData);
                        }
                        
                        // Restore TLS state
                        Tls->pPS = pOldPS;
                        
                        // Release SPSNode
                        pPS->Release();
                    }

                    // Release the RemUnk proxy
                    if(pRemUnk)
                        pRemUnk->Release();
                }
            }
            else
            {
                // Execute the callback
                hr = PerformCallback(this, pfnCallback, pParam, riid, iMethod, pUnk);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::InternalContextCallback returning hr:0x%x\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Reset              , private
//              CObjectContext::GetCount           , private
//              CObjectContext::GetNextProperty    , private
//
//  Synopsis:   These internal functions are used to enumerate over the
//              context's policy set.
//
//  History:    10-Jan-98   Johnstra      Created
//              24-Nov-98   JohnStra      Rewritten to use flat array
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::Reset(
    void **cookie
    )
{
    if (IsFrozen())
        *(int*)cookie = _properties._iFirst;
    else
        *(int*)cookie = -1;
    return (IsFrozen()) ? S_OK : E_FAIL;
}

ULONG CObjectContext::GetCount()
{
    // don't assert FROZEN here because activation code needs to
    // call this before freezing
    return _properties.GetCount();
}

ContextProperty* CObjectContext::GetNextProperty(
    void** cookie
    )
{
    Win4Assert(IsFrozen());

    if (0 == _properties._Count)
    {
        *(int*)cookie = -1;
        return NULL;
    }

    ContextProperty *pcp = NULL;
    int slot = *(int*)cookie;
    if (slot != -1)
    {
        pcp = &_properties._pProps[_properties._pIndex[slot].idx];
        if (slot == _properties._iLast)
            *(int*)cookie = -1;
        else
            *(int*)cookie = _properties._pIndex[slot].next;
    }

    return pcp;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetCurrentApartmentType , public
//
//  Synopsis:   Returns the apartment type in which the callers thread is
//              executing.
//
//  History:    9-Mar-98   Johnstra      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetCurrentApartmentType(
    APTTYPE* pAptType
    )
{
    // If the caller passed a NULL output param, return E_INVALIDARG.

    HRESULT hr = E_INVALIDARG;
    if (pAptType != NULL)
    {
        // If an apartment is not initialized for the current thread, return
        // E_FAIL.  Otherwise, map the value returned from
        // GetCurrentApartmentKind onto one of the APTTYPEs.

        hr = E_FAIL;
        if (IsApartmentInitialized())
        {
            hr = S_OK;
            APTKIND aptkind = GetCurrentApartmentKind();

            if (aptkind == APTKIND_APARTMENTTHREADED)
            {
                // This thread is in an STA.  Is it the main STA?

                if (GetCurrentThreadId() == gdwMainThreadId)
                    *pAptType = APTTYPE_MAINSTA;
                else
                    *pAptType = APTTYPE_STA;
            }
            else if (aptkind == APTKIND_NEUTRALTHREADED)
            {
                // This thread is in the NA.

                *pAptType = APTTYPE_NA;
            }
            else
            {
                // This thread is in the MTA

                *pAptType = APTTYPE_MTA;
            }
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetCurrentThreadType , public
//
//  Synopsis:   Returns the type of the thread the caller is executing on,
//              one has an associated message loop or not.  Basically
//              identifies whether the thread is associated with an MTA or
//              an STA.
//
//  History:    9-Mar-98   Johnstra      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetCurrentThreadType(
    THDTYPE* pThreadType
    )
{
    HRESULT hr;

    if (pThreadType == NULL)
        return E_INVALIDARG;

    hr = E_FAIL;
    if (IsApartmentInitialized())
    {
        hr = S_OK;
        *pThreadType = (IsSTAThread()) ? THDTYPE_PROCESSMESSAGES :
                                         THDTYPE_BLOCKMESSAGES;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetCurrentLogicalThreadId , public
//
//  Synopsis:   Returns the LogicalThreadId associated with this thread.
//
//  History:    7-Jul-99   ScottRob      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetCurrentLogicalThreadId(
    GUID* pguid
    )
{
    HRESULT hr = E_INVALIDARG;

    if (IsValidPtrOut(pguid, sizeof(*pguid)))
    {
      GUID *pguidTmp = TLSGetLogicalThread();
      if (pguidTmp != NULL)
      {
              *pguid = *pguidTmp;

              ComDebOut((DEB_OBJECTCONTEXT,
                      "CObjectContext::GetCurrentLogicalThreadId returning hr:S_OK GUID:%I\n", pguid));
              return S_OK;
      }
      hr = E_OUTOFMEMORY;
    }

    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetCurrentLogicalThreadId returning hr:%08X\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::SetCurrentLogicalThreadId , public
//
//  Synopsis:   Forces the LogicalThreadId associated with this thread to a
//              particular value.
//
//  History:    7-Jul-99   ScottRob      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::SetCurrentLogicalThreadId(
    REFGUID rguid
    )
{
    HRESULT hr;
    ComDebOut((DEB_OBJECTCONTEXT,
            "CObjectContext::SetCurrentLogicalThreadId GUID:%I\n", &rguid));

    COleTls tls(hr);

    if (SUCCEEDED(hr)) {
      tls->LogicalThreadId = rguid;
      tls->dwFlags |= OLETLS_UUIDINITIALIZED;
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::CreateIdentity , private
//
//  Synopsis:   Notifies all interested context properties that a new
//              identity object has been created in this context.
//
//  History:    15-Apr-98   JimLyon       Created
//
//----------------------------------------------------------------------------
void CObjectContext::CreateIdentity(
        IComObjIdentity* pID
        )
{
        void* cookie;
        ContextProperty* pProp;
        IPolicyMaker* pPM;
        HRESULT hr;


        Win4Assert(GetCurrentContext() == this);

        Reset(&cookie);
        for (;;)
        {
                pProp = GetNextProperty(&cookie);
                if (pProp == NULL)
                        break;

                if (pProp->flags & CPFLAG_MONITORSTUB)
                {
                        hr = pProp->pUnk->QueryInterface(IID_IPolicyMaker, (void**)&pPM);
                        if (hr == S_OK)
                        {
                                // we don't check return code from CreateStub; he must say S_OK
                                pPM->CreateStub(pID);
                                pPM->Release();
                        }
                }
        }
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::DestroyIdentity , private
//
//  Synopsis:   Notifies all interested context properties that a new
//              identity object is about to be destroyed in this context.
//
//  History:    15-Apr-98   JimLyon       Created
//
//----------------------------------------------------------------------------
void CObjectContext::DestroyIdentity(
        IComObjIdentity* pID
        )
{
        void* cookie;
        ContextProperty* pProp;
        IPolicyMaker* pPM;
        HRESULT hr;

        Win4Assert(GetCurrentContext() == this);

        Reset(&cookie);
        for (;;)
        {
                pProp = GetNextProperty(&cookie);
                if (pProp == NULL)
                        break;

                if (pProp->flags & CPFLAG_MONITORSTUB)
                {
                        hr = pProp->pUnk->QueryInterface(IID_IPolicyMaker, (void**)&pPM);
                        if (hr == S_OK)
                        {
                                // we don't check return code from DestroyStub; he must say S_OK
                                pPM->DestroyStub(pID);
                                pPM->Release();
                        }
                }
        }
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Aggregate , public
//
//  Synopsis:   This method aggregates the supplied interface into the
//              object context.  It is intended for use by COM Services
//              as a way to expose existing MTS interfaces directly from
//              the object context.
//
//  History:    19-Jun-98   Johnstra      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::Aggregate(
    IUnknown*  pInnerUnk
    )
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // The supplied interface pointer must not be NULL.

    if (!pInnerUnk)
        return E_INVALIDARG;

    // Take lock and aggregate.

    BOOL fSet = FALSE;
    if (!_pMtsContext)
    {
        LOCK(gComLock);
        if (!_pMtsContext)
        {
            _pMtsContext = pInnerUnk;
            fSet = TRUE;
        }
        UNLOCK(gComLock);
    }

    // If we did aggregate the supplied punk, AddRef it.

    if (fSet)
        _pMtsContext->AddRef();

    return fSet ? S_OK : E_FAIL;
}


//+--------------------------------------------------------------------------
//
//  Function:   CoGetApartmentID
//
//  Synopsis:   Returns the apartment ID of the specified apartment type.
//
//  History:    9-Mar-98   Johnstra      Created
//
//  Note:       This function can fail with E_FAIL if it's called from a thread whose aptid isn't
//              in gApartmentTbl and whose current context is not the empty context
//              This is by design under the grounds that this isn't a public API and it's only
//              called from places where we know it's in the table.
//              However, in the future this might have to change - we might need to fault
//              apartments into the table when necessary, by jumping to the empty context
//              and calling GetCurrentApartmentToken from there.
//              mfeingol - Oct-09-2001
//
//----------------------------------------------------------------------------
STDAPI CoGetApartmentID(
    APTTYPE      dAptType,
    HActivator * pAptID
    )
{
    ComDebOut(( DEB_OBJECTCONTEXT, "CoGetApartmentID [IN]\n" ));
    ASSERT_LOCK_NOT_HELD( gContextLock );

    HRESULT hr;

    // If the supplied out param is NULL or if the supplied APTTYPE
    // is STA, return E_INVALIDARG.

    if (pAptID == NULL || dAptType == APTTYPE_STA)
        return E_INVALIDARG;

    if (dAptType != APTTYPE_CURRENT)
        return E_NOTIMPL;

    // Assume failure
    hr = E_FAIL;
    if (dAptType == APTTYPE_CURRENT)
    {
        // Check if the apartment is initialized
        if(IsApartmentInitialized())
        {
            hr = GetCurrentApartmentToken(*pAptID, (GetCurrentContext() == GetEmptyContext()));
        }
        else
            hr = CO_E_NOTINITIALIZED;
    }

    ASSERT_LOCK_NOT_HELD( gContextLock );
    ComDebOut(( DEB_OBJECTCONTEXT, "CoGetApartmentID [OUT]\n" ));
    return hr;
}


//--------------------------------------------------------------------
//
// Function:    CObjectContextCF_CreateInstance
//
// Params:
//              pUnkOuter - controlling unknown
//              riid      - interface id requested
//              ppv       - location for requested object
//
// Synopsis:    construct object, QI for interface.
//
// History:     22-Dec-97  JohnStra    Created
//
//---------------------------------------------------------------------
HRESULT CObjectContextCF_CreateInstance(
    IUnknown* pUnkOuter,
    REFIID    riid,
    void**    ppv)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContextCF_CreateInstance pUnkOuter:0x%x, riid:%I, ppv:0x%x\n",
        pUnkOuter, &riid, ppv));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    //
    // instantiate a CObjectContext.
    //

    HRESULT hr = E_OUTOFMEMORY;
    CObjectContext *pTemp = CObjectContext::CreateObjectContext(NULL, 0);

    //
    // if an ObjectContext was instantiated, QI for the specified interface,
    // then release the ObjectContext.
    //

    if (NULL != pTemp)
    {
        hr = pTemp->QueryInterface(riid, ppv);
        pTemp->InternalRelease();
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContextCF_CreateInstance returning hr:%08X\n", hr));
    return hr;
}


HRESULT GetStaticContextUnmarshal(IMarshal** ppIM)
{
    HRESULT hr = E_OUTOFMEMORY;
    CObjectContext *pCtx = CObjectContext::CreateObjectContext(NULL, CONTEXTFLAGS_STATICCONTEXT);
    if (pCtx)
    {
        hr = pCtx->QueryInterface(IID_IMarshal, (void **) ppIM);
        pCtx->InternalRelease();
    }
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::NotifyServerException    private
//
//  Synopsis:   Notifies all interested context properties about server exception
//
//  History:    14-Aug-98   GopalK       Created
//
//----------------------------------------------------------------------------
void CObjectContext::NotifyServerException(EXCEPTION_POINTERS *pExceptPtrs)
{
    void *pvCookie;
    ContextProperty *pCtxProp;
    IExceptionNotification *pExceptNotification;
    HRESULT hr;

    // This method can only be called from current context
    Win4Assert(GetCurrentContext() == this);

    // Enumerate properties
    Reset(&pvCookie);
    do
    {
        pCtxProp = GetNextProperty(&pvCookie);
        if(pCtxProp)
        {
            hr = pCtxProp->pUnk->QueryInterface(IID_IExceptionNotification,
                                                (void **) &pExceptNotification);
            if(SUCCEEDED(hr))
            {
                // Notify exception
                pExceptNotification->ServerException(pExceptPtrs);
                pExceptNotification->Release();
            }
        }
    } while(pCtxProp);

	// The above loop will not deliver an exception notification to the
	// aggregated mts-compatibility context prop.  Special case this:
	if (_pMtsContext)
	{
		hr = _pMtsContext->QueryInterface(IID_IExceptionNotification, (void **) &pExceptNotification);
		if (SUCCEEDED(hr))
		{
			pExceptNotification->ServerException(pExceptPtrs);
			pExceptNotification->Release();
		}
	}

    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::NotifyContextAbandonment    private
//
//  Synopsis:   Notifies all interested context properties about an abandoned context
//
//  History:    14-Aug-98   GopalK       Created
//
//----------------------------------------------------------------------------
void CObjectContext::NotifyContextAbandonment()
{
    void *pvCookie;
    ContextProperty *pCtxProp;
    IAbandonmentNotification *pAbandonNotification;
    HRESULT hr;

    // Enumerate properties
    Reset(&pvCookie);
    do
    {
        pCtxProp = GetNextProperty(&pvCookie);
        if(pCtxProp)
        {
            hr = pCtxProp->pUnk->QueryInterface(IID_IAbandonmentNotification,
                                                (void **) &pAbandonNotification);
            if(SUCCEEDED(hr))
            {
                // Notify abandonment
                pAbandonNotification->Abandoned (this);
                pAbandonNotification->Release();
            }
        }
    } while(pCtxProp);

	// The above loop will not deliver an exception notification to the
	// aggregated mts-compatibility context prop.  Special case this:
	if (_pMtsContext)
	{
		hr = _pMtsContext->QueryInterface(IID_IAbandonmentNotification, (void **) &pAbandonNotification);
		if (SUCCEEDED(hr))
		{
			pAbandonNotification->Abandoned (this);
			pAbandonNotification->Release();
		}
	}

    return;
}

//---------------------------------------------------------------------------
//
//  Method:     CObjectContext::GetLife
//
//  Synopsis:   Returns a the CContextLife object for this context, creating
//              it if it doesn't exist.  The CContextLife object is 
//              essentially a weak reference to the context.
//
//  History:    17-Oct-00   JohnDoty      Created
//
//---------------------------------------------------------------------------
CContextLife *CObjectContext::GetLife()
{
    CContextLife *pCtxLife = _pContextLife;
    if (NULL == pCtxLife)
    {
        // CContextLife begins with 1 reference.
        pCtxLife = new CContextLife;
        if (NULL == pCtxLife)
            return NULL;

        if (InterlockedCompareExchangePointer((void **)&_pContextLife, 
                                              pCtxLife, NULL) != NULL)
        {
            // Somebody beat me.  Oh well.  Release my instance.
            pCtxLife->Release();
            pCtxLife = _pContextLife;
        }
    }

    pCtxLife->AddRef();
    return pCtxLife;
}

#define GetPropListFromHashNode(n)      \
    CObjectContext::HashPropChainToContext((n))->GetPropertyList();

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given node
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline DWORD CCtxPropHashTable::HashNode(SHashChain *pNode)
{
    ASSERT_LOCK_HELD(gContextLock);

    // Preconditions: caller must hold context lock.

    CContextPropList* pList = GetPropListFromHashNode(pNode);

    // We can't be looking up contexts with ZERO properties
    // in the property based hash table

    Win4Assert(pList->GetCount() && "Hashing a null property list in context hash table");

    return pList->GetHash();
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Rewritten
//
//---------------------------------------------------------------------------
BOOL CCtxPropHashTable::Compare(
    const void  *pv,
    SHashChain  *pNode,
    DWORD        dwHash
    )
{
    // Preconditions: caller must hold context lock.

    ASSERT_LOCK_HELD(gContextLock);

    CContextPropList *pList1 = GetPropListFromHashNode(pNode);
    CContextPropList *pList2 = ((CObjectContext*)pv)->GetPropertyList();

    // We can't be comparing contexts with ZERO properties in their lists
    // in the property based hash table.

    Win4Assert(pList1->GetCount() && pList2->GetCount() &&
                "Comparing null property lists in context hash table");

    return (*pList1 == *pList2);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Lookup
//
//  Synopsis:   Lookup in a property based hash table.  We want to be as
//              fast as possible here.  This means we only want to compare
//              the property lists if we must.  Before we attempt to do that
//              we make sure the two contexts we are comparing have the same
//              hash value and the same number of properties.
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Rewritten for speed and took out
//                                      sort.
//
//---------------------------------------------------------------------------
inline CObjectContext *CCtxPropHashTable::Lookup(
    CObjectContext *pContext
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Lookup [IN] pContext:%p\n", pContext));

    // Preconditions: caller must hold context lock and context must be frozen.

    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(pContext->IsFrozen());


    // Get the hash value and the number of properties on the supplied context.

    DWORD dwHash = pContext->GetPropertyList()->GetHash();
    int   iCount = pContext->GetPropertyList()->GetCompareCount();
    ComDebOut((DEB_OBJECTCONTEXT, "   dwHash:%d iCount:%d\n", dwHash, iCount));

    // Must be properties in the list to do a comparison.

    if (0 == pContext->GetPropertyList()->GetCount())
        return NULL;

    // Scan the appropriate hash chain for an entry that has the same hash
    // value and the same number of properties.

    CObjectContext *pKey    = NULL;
    CObjectContext *pCtxOut = NULL;
    ULONG           iHash   = dwHash % NUM_HASH_BUCKETS;
    SHashChain     *pNode   = &CCtxTable::s_CtxPropBuckets[iHash];
    pNode   = pNode->pNext;

    ComDebOut((DEB_OBJECTCONTEXT,
        "   pHead:%p pNode:%p iHash:%d\n",
        &CCtxTable::s_CtxPropBuckets[iHash], pNode, iHash));

    while (pNode != &CCtxTable::s_CtxPropBuckets[iHash])
    {
        pKey = CObjectContext::HashPropChainToContext(pNode);
        ComDebOut((DEB_OBJECTCONTEXT, "   pNode:%p pKey:%p\n", pNode, pKey));

        if (pKey->GetPropertyList()->GetHash() == dwHash &&
            pKey->GetPropertyList()->GetCompareCount() == iCount)
        {
            // We've found a context with the same hash value and the same
            // number of properties.  Let's compare the property buffers.

            if (Compare(pContext, pNode, dwHash))
            {
                // We've found a match.  We're finished.

                pCtxOut = pKey;
                break;
            }
        }

        // Advance to the next node in the hash chain.

        pNode = pNode->pNext;
    }

    // Postconditions: must still hold context lock.

    ASSERT_LOCK_HELD(gContextLock);

    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Lookup [OUT] pCtxOut:%p\n", pCtxOut));
    return pCtxOut;
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Add
//
//  Synopsis:   Add element in a property based hash table
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Take out sort
//
//---------------------------------------------------------------------------
inline void CCtxPropHashTable::Add(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxPropHashTable::Add [IN] pContext:%p count:%d\n",
        pContext, pContext->GetPropertyList()->GetCount()));

    // Preconditions: caller must hold context lock and context must be frozen.
    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(pContext->IsFrozen());

    if(pContext->GetPropertyList()->GetCount())
    {
        DWORD dwHash = pContext->GetPropertyList()->GetHash() % NUM_HASH_BUCKETS;
        ComDebOut((DEB_OBJECTCONTEXT, "   dwHash:%d\n", dwHash));

        // Sanity check
        Win4Assert(dwHash == (CCtxTable::s_CtxPropHashTable.HashNode(
                          pContext->GetPropHashChain()) % NUM_HASH_BUCKETS));

        CHashTable::Add(dwHash, pContext->GetPropHashChain());

#if DBG==1
        ComDebOut((DEB_OBJECTCONTEXT,
            "   &CCtxTable::s_CtxPropBuckets[%d]:%p\n",
            dwHash, &CCtxTable::s_CtxPropBuckets[dwHash]));

        CObjectContext* pKey;
        SHashChain *pHead = &CCtxTable::s_CtxPropBuckets[dwHash];
        SHashChain *pNode = pHead->pNext;
        while (pNode != &CCtxTable::s_CtxPropBuckets[dwHash])
        {
            pKey = CObjectContext::HashPropChainToContext(pNode);
            ComDebOut((DEB_OBJECTCONTEXT,
                "      pNode:%p pNext:%p pPrev:%p pKey:%p\n",
                pNode, pNode->pNext, pNode->pPrev, pKey));
            pNode = pNode->pNext;
        }
#endif
    }

    // Postconditions: must still hold context lock.
    ASSERT_LOCK_HELD(gContextLock);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Remove
//
//  Synopsis:   Remove element in a property based hash table
//
//              NOTE: A context is removed in from the table only if
//              (1) The property list is sorted
//              (2) There are non-zero number of elements in the list
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Take out sort
//
//---------------------------------------------------------------------------
inline void CCtxPropHashTable::Remove(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Remove [IN] pContext:%p\n", pContext));

    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    ComDebOut((DEB_OBJECTCONTEXT, "   pContext:%p\n", pContext));

    // Remove only if there are elements in the sorted list
    if (pContext->GetPropertyList()->GetCount())
    {
        CHashTable::Remove(pContext->GetPropHashChain());

#if DBG==1
        DWORD dwHash =
            pContext->GetPropertyList()->GetHash() % NUM_HASH_BUCKETS;

        ComDebOut((DEB_OBJECTCONTEXT, "   dwHash:%d\n", dwHash));
        ComDebOut((DEB_OBJECTCONTEXT,
            "   &CCtxTable::s_CtxPropBuckets[%d]:%p\n",
            dwHash, &CCtxTable::s_CtxPropBuckets[dwHash]));

        CObjectContext* pKey;
        SHashChain *pHead = &CCtxTable::s_CtxPropBuckets[dwHash];
        SHashChain *pNode = pHead->pNext;
        while (pNode != &CCtxTable::s_CtxPropBuckets[dwHash])
        {
            pKey = CObjectContext::HashPropChainToContext(pNode);
            ComDebOut((DEB_OBJECTCONTEXT,
                "      pNode:%p pNext:%p pPrev:%p pKey:%p\n",
                pNode, pNode->pNext, pNode->pPrev, pKey));
            pNode = pNode->pNext;
        }
#endif

        pContext->InPropTable(FALSE);
    }

    // Postconditions: Must still hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Remove [OUT] pContext:%p\n"));
}


//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given node
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline DWORD CCtxUUIDHashTable::HashNode(SHashChain *pNode)
{
    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

	Win4Assert(pNode && "Attempted to hash a NULL CObjectContext pointer");
	if (pNode == NULL)
		return 0;

    return (CObjectContext::HashUUIDChainToContext(pNode))->GetHashOfId();
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CCtxUUIDHashTable::Compare(
    const void *pv,
    SHashChain *pNode,
    DWORD       dwHash)
{
    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    CObjectContext *pContext = CObjectContext::HashUUIDChainToContext(pNode);
    ContextID *pID = (ContextID *) pv;

    Win4Assert(pContext && "Comparing null context in context hash table");
	if (pContext == NULL)
		return (FALSE);

    // If the contextIds match then return TRUE else FALSE
    if(InlineIsEqualGUID(*pID, pContext->GetContextId()))
        return(TRUE);
    else
        return(FALSE);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Lookup
//
//  Synopsis:   Lookup in a UUID based hash table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline CObjectContext *CCtxUUIDHashTable::Lookup(REFGUID rguid)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxUUIDHashTable::Lookup for riid:%I\n", &rguid));

    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    DWORD dwHash = HashGuid(rguid);
    return(CObjectContext::HashUUIDChainToContext(CHashTable::Lookup(dwHash,
                                                  (const void *)&rguid)));
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Add
//
//  Synopsis:   Add element in a UUID based hash table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline void CCtxUUIDHashTable::Add(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxUUIDHashTable::Add pContext:%p riid:%I\n",
        pContext, &pContext->GetContextId()));

    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    DWORD dwHash = pContext->GetHashOfId();

    // Perform some sanity checks.

    // Verify that the hash value returned by the table when you hash the
    // node represented by this context and the cached hash value match.
    Win4Assert( dwHash == CCtxTable::s_CtxUUIDHashTable.HashNode(pContext->GetUUIDHashChain()) );

    // Verify that the cached hash value makes sense.
    Win4Assert( dwHash == HashGuid(pContext->GetContextId()) );

    // Verify that no other context having the same ContextId is in the list.
    Win4Assert( Lookup( pContext->GetContextId() ) == NULL );

    CHashTable::Add(dwHash, pContext->GetUUIDHashChain());

#if DBG == 1
    // Sanity check on the hash table list to which we added
    g_cCtxTableAdd++;
    SHashChain* pNode = &CCtxTable::s_CtxUUIDBuckets[dwHash];
    pNode = pNode->pNext;
    while(pNode !=  &CCtxTable::s_CtxUUIDBuckets[dwHash])
    {
        Win4Assert(pNode->pNext != pNode && pNode->pPrev != pNode);
        pNode = pNode->pNext;
    }
#endif

    // Postconditions: must still hold context lock.
    ASSERT_LOCK_HELD(gContextLock);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Remove
//
//  Synopsis:   Remove element in a UUID based hash table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline void CCtxUUIDHashTable::Remove(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxUUIDHashTable::Remove pContext:%p riid:%I\n",
        pContext, &pContext->GetContextId()));

    // Preconditions: caller must hold the context lock.
    ASSERT_LOCK_HELD(gContextLock);

    CHashTable::Remove(pContext->GetUUIDHashChain());

#if DBG == 1
    g_cCtxTableRemove++;

    // Sanity check on the hash table list from which we removed
    DWORD iHash = (pContext->GetHashOfId());
    SHashChain* pNode = &CCtxTable::s_CtxUUIDBuckets[iHash];
    pNode = pNode->pNext;
    while(pNode !=  &CCtxTable::s_CtxUUIDBuckets[iHash])
    {
        Win4Assert((pNode->pNext != pNode) && (pNode->pPrev != pNode));
        pNode = pNode->pNext;
    }
#endif

    // Postconditions: should still be holding context lock.
    ASSERT_LOCK_HELD(gContextLock);
}


//---------------------------------------------------------------------------
//
//  Method:     CCtxTable::Initialize
//
//  Synopsis:   Initailizes the context table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
void CCtxTable::Initialize()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxTable::Initialize\n"));
    ASSERT_LOCK_HELD(gContextLock);

    // Avoid double init
    if(!s_fInitialized)
    {
        // Initialize property based hash table
        s_CtxPropHashTable.Initialize(s_CtxPropBuckets, &gContextLock);

        // Initialize UUID based hash table
        s_CtxUUIDHashTable.Initialize(s_CtxUUIDBuckets, &gContextLock);

        // Mark the state as initialized
        s_fInitialized = TRUE;
    }

    ASSERT_LOCK_HELD(gContextLock);
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxTable::Cleanup
//
//  Synopsis:   Cleanup the context table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
void CCtxTable::Cleanup()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxTable::Cleanup\n"));
    ASSERT_LOCK_HELD(gContextLock);

    // Check if the table was initialized
    if(s_fInitialized)
    {
        // Cleanup property based hash table
        s_CtxPropHashTable.Cleanup(CleanupCtxTableEntry);

        // Cleanup UUID based hash table
        s_CtxUUIDHashTable.Cleanup(CleanupCtxTableEntry);

        // State is no longer initialized
        s_fInitialized = FALSE;
    }

    ASSERT_LOCK_HELD(gContextLock);
    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCtxTable::LookupExistingContext    public
//
//  Synopsis:   Lookup the property based hash table to find a matching
//              context
//
//  Notes:      This is called during the activation path to reuse
//              existing contexts.
//
//  History:    12-Nov-98   TarunA       Created
//              24-Nov-98   JohnStra     Take out sort
//
//----------------------------------------------------------------------------
CObjectContext* CCtxTable::LookupExistingContext(CObjectContext *pContext)
{
    // Preconditions: Caller must hold the context lock and the context
    // must be frozen.
    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(pContext->IsFrozen());

    // look in the property based hash table for a matching context
    CObjectContext *pMatchingContext = s_CtxPropHashTable.Lookup(pContext);
    if (pMatchingContext)
    {
        // Addref the context
        pMatchingContext->InternalAddRef();

#if DBG == 1
/*
    In debug builds, update some counters to keep track of how the
    cache is behaving.
*/

        // Found a matching context
        g_cCtxTableLookupSucceeded++;
    }

    // Number of lookups done
    g_cCtxTableLookup++;
#else
    }
#endif

    ASSERT_LOCK_HELD(gContextLock);
    return pMatchingContext;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCtxTable::LookupExistingContext    public
//
//  Synopsis:   Lookup the UUID based hash table to find a matching context
//
//  History:    12-Nov-98   TarunA       Created
//
//----------------------------------------------------------------------------
CObjectContext* CCtxTable::LookupExistingContext(REFGUID rguid)
{
    ASSERT_LOCK_HELD(gContextLock);

    // lookup the context in the uuid based hash table
    return s_CtxUUIDHashTable.Lookup(rguid);
}

//+--------------------------------------------------------------------------
//
//  Member:     CCtxTable::AddContext    public
//
//  Synopsis:   Adds a context to the hash table based on properties
//
//  History:    12-Nov-98   TarunA       Created
//              24-Nov-98   JohnStra     Take out sort
//
//----------------------------------------------------------------------------
HRESULT CCtxTable::AddContext(CObjectContext *pContext)
{
    // The context must be frozen
    Win4Assert(pContext->IsFrozen());

    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

    // Add it to the table
    s_CtxPropHashTable.Add(pContext);
    pContext->InPropTable(TRUE);

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);
    return S_OK;
}

INTERNAL PrivGetObjectContext(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_OBJECTCONTEXT, "PrivGetObjectContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Initialize

    *ppv = NULL;

    // Initalize channel

    hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        CObjectContext *pContext = GetCurrentContext();
        if (pContext)
            hr = pContext->InternalQueryInterface(riid, ppv);
        else
            hr = CO_E_NOTINITIALIZED;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_OBJECTCONTEXT,
                     "PrivGetObjectContext returning 0x%x\n", hr));
    return(hr);
}


INTERNAL PushServiceDomainContext (const ContextStackNode& csnCtxNode)
{
    HRESULT hr;
    
    COleTls tls (hr);
    if (SUCCEEDED(hr))
    {
        // Save the old context in a stack node
        ContextStackNode* pCtxNode = new ContextStackNode;
        if (!pCtxNode)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory (pCtxNode, &csnCtxNode, sizeof (ContextStackNode));

            pCtxNode->pNext = tls->pContextStack;    
            tls->pContextStack = pCtxNode;
        }
    }
    
    return hr;
}


INTERNAL PopServiceDomainContext (ContextStackNode* pcsnCtxNode)
{
    HRESULT hr;

    Win4Assert (pcsnCtxNode);
    ZeroMemory (pcsnCtxNode, sizeof (ContextStackNode));
    
    COleTls tls (hr);    
    if (SUCCEEDED(hr))
    {
        ContextStackNode* pOldNode = tls->pContextStack;
        if (!pOldNode)
        {
            hr = CONTEXT_E_NOCONTEXT;
        }
        else
        {
            tls->pContextStack = pOldNode->pNext;
            
            // Restore the new context
            CopyMemory (pcsnCtxNode, pOldNode, sizeof (ContextStackNode));
            
            delete pOldNode;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\destobj.cxx ===
//+-------------------------------------------------------------------
//
//  File:       DestObj.cxx
//
//  Contents:   Object tracking destination context for marshaling
//
//  Classes:    CDestObject
//
//  History:    18-Mar-98   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <destobj.hxx>

//+-------------------------------------------------------------------
//
//  Method:     CDestObject::QueryInterface     public
//
//  Synopsis:   QI behavior of destination object
//
//  History:    18-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CDestObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if(IsEqualIID(riid, IID_IDestInfo) ||
       IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IDestInfo *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    // No need to addref
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\ctxchnl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       CtxChnl.cxx
//
//  Contents:   Support for context channels
//
//  Functions:  CCtxComChnl methods
//
//  History:    20-Dec-97   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <callctrl.hxx>
#include <ctxchnl.hxx>
#include <context.hxx>
#include <crossctx.hxx>

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator     CCtxComChnl::s_allocator;    // Allocator for channel
COleStaticMutexSem CCtxComChnl::_mxsCtxChnlLock;// critical section
#if DBG==1
BOOL               CCtxComChnl::s_fInitialized; // Relied on being FALSE
size_t             CCtxComChnl::s_size;         // Relied on being ZERO
#endif

//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::QueryInterface     public
//
//  Synopsis:   QI behavior of CRpcCall object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_ICall))
    {
        *ppv = (ICall *) this;
    }
    else if(IsEqualIID(riid, IID_IRpcCall))
    {
        *ppv = (IRpcCall *) this;
    }
    else if(IsEqualIID(riid, IID_ICallInfo))
    {
        *ppv = (ICallInfo *) this;
    }
    else if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) (ICall *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_RPCCALL, "CRpcCall::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::AddRef     public
//
//  Synopsis:   AddRefs CRpcCall object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcCall::AddRef()
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::AddRef\n"));

    // Increment ref count
    // This object is not required to be thread safe
    return(++_cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::Release     public
//
//  Synopsis:   Release CRpcCall object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcCall::Release()
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::Release\n"));

    ULONG cRefs;

    // Decrement ref count
    // This object is not required to be thread safe
    cRefs = --_cRefs;
    // Check if this is the last release
    if(cRefs == 0)
    {
        // Delete call
        delete this;
    }

    ContextDebugOut((DEB_RPCCALL, "CRpcCall::Release returning 0x%x\n",
                     cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetCallInfo     public
//
//  Synopsis:   Implements IRpcCall::GetCallInfo
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetCallInfo(const void **ppIdentity, IID *pIID,
                                   DWORD *pdwMethod, HRESULT *phr)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallInfo\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    if(ppIdentity)
        *ppIdentity = _pIdentity;
    if(pIID)
        *pIID = _riid;
    if(pdwMethod)
        *pdwMethod = _pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
    if(phr)
        *phr = _hrRet;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetRpcOleMessage     public
//
//  Synopsis:   Implements IRpcCall::GetRpcOleMessage
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetRpcOleMessage(RPCOLEMESSAGE **ppMessage)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallInfo\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    *ppMessage = _pMessage;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::Nullify     public
//
//  Synopsis:   Implements IRpcCall::Nullify
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::Nullify(HRESULT hr)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallInfo\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (_hrRet == S_OK)
        _hrRet = hr;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetServerHr     public
//
//  Synopsis:   Implements IRpcCall::GetServerHr
//
//  History:    2-Feb-99   Johnstra      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetServerHR(HRESULT *phr)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetServerHr\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    if(phr)
        *phr = _ServerHR;
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetCallSource     public
//
//  Synopsis:   Implements ICallInfo::GetCallSource
//
//  History:    03-Feb-99   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetCallSource(CALLSOURCE* pCallSource)
                                   
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallSource\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    *pCallSource = _callSource;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Initialize     public
//
//  Synopsis:   Initializes allocator for channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxComChnl::Initialize(size_t size)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    LOCK(_mxsCtxChnlLock);

    // Assert that this initailization is not done twice
    Win4Assert(!s_fInitialized);
    Win4Assert(size == sizeof(CCtxComChnl));

    // Initialze the allocator
    s_allocator.Initialize(size, CHANNELS_PER_PAGE, &_mxsCtxChnlLock);

#if DBG==1
    s_fInitialized = TRUE;
    s_size = size;
#endif

    UNLOCK(_mxsCtxChnlLock);
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::operator new     public
//
//  Synopsis:   new operator of channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CCtxComChnl::operator new(size_t size)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::operator new\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);

    void *pv;

    // Assert that correct size is being requested
    Win4Assert(size == s_size &&
               "CCtxComChnl improperly initialized");

    // Allocate memory
    pv = (void *) s_allocator.AllocEntry();

    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::operator delete     public
//
//  Synopsis:   delete operator of channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxComChnl::operator delete(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::operator delete\n"));
    ASSERT_LOCK_DONTCARE(_mxsCtxChnlLock);

    // Assert that allocator was initialized earlier
    Win4Assert(s_fInitialized);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CCtxComChnl can be inherited only by those objects
    // with overloaded new and delete operators
    LOCK(_mxsCtxChnlLock);
    LONG index = s_allocator.GetEntryIndex((PageEntry *) pv);
    UNLOCK(_mxsCtxChnlLock);
    Win4Assert(index != -1);
#endif

    // Release the pointer
    s_allocator.ReleaseEntry((PageEntry *) pv);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Cleanup     public
//
//  Synopsis:   Cleanup call objects and allocator for context channels
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxComChnl::Cleanup()
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    LOCK(_mxsCtxChnlLock);

    // Sanity check
    Win4Assert(s_fInitialized);

    // Cleanup context call object cache
    CCtxCall::Cleanup();

    // Cleanup allocator
    s_allocator.Cleanup();

    // Reset state
#if DBG==1
    s_fInitialized = FALSE;
#endif

    UNLOCK(_mxsCtxChnlLock);
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::CCtxComChnl     public
//
//  Synopsis:   Constructor of channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxComChnl::CCtxComChnl(CStdIdentity *pStdId, OXIDEntry *pOXIDEntry,
                         DWORD eState) :
    CAptRpcChnl(pStdId, pOXIDEntry, eState)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::CCtxComChnl\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::~CCtxComChnl     public
//
//  Synopsis:   Destructor of channel object
//
//+-------------------------------------------------------------------
CCtxComChnl::~CCtxComChnl()
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::~CCtxComChnl\n"));
    ASSERT_LOCK_DONTCARE(_mxsCtxChnlLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::GetBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetBuffer
//
//              This method ensures that the interface has legally been
//              unmarshaled in the client context, identifies the right
//              policy set, asks it to resize the buffer requested by its
//              caller, saves the context call object in TLS, passes on
//              the request to CAptRpcChnl::GetBuffer, and finally returns
//              to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::GetBuffer(RPCOLEMESSAGE *pMessage, REFIID riid)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::GetBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName, sizeof(iidName)/sizeof(*iidName));
        char *side = Proxy() ? "ClientGetBuffer" : "ServerGetBuffer";

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName, pMessage->iMethod));
    }
#endif

    // Initialize channel if necessary
    HRESULT hr = InitChannelIfNecessary();
    if(SUCCEEDED(hr))
    {
        HRESULT hrCall = S_OK;
        BOOL fClientSide = Proxy();
        CPolicySet *pPS;
        CCtxCall *pCtxCall = NULL;
        COleTls Tls;

        // Initialize
        pMessage->Buffer = NULL;

        // Check the current side
        if(fClientSide)
        {
#ifndef _WIN64
            // Sanity check
            Win4Assert(pMessage->reserved1 == NULL);
#endif	   
            // Obtain policy set
            CStdIdentity *pStdID = GetStdId();
            pPS = pStdID->GetClientPolicySet();

            // Ensure that the interface has legally been unmarshaled
            if((pPS == NULL) && pStdID->GetServerCtx() &&
               (GetCurrentContext() != GetEmptyContext()))
            {
                // Check for FTM proxies
                if(pStdID->IsFTM() || pStdID->IsFreeThreaded())
                {
                    BOOL fCreate = TRUE;
                    hr = ObtainPolicySet(GetCurrentContext(), NULL,
                                         PSFLAG_PROXYSIDE, &fCreate, &pPS);
                    if(SUCCEEDED(hr))
                    {
                        hr = pStdID->SetClientPolicySet(pPS);
                        pPS->Release();
                    }
                }
                else if(!pStdID->SystemObject())
                {
                    CoVrfNotifySmuggledProxy(riid, pMessage->iMethod, pStdID->GetAptId());
                    hr = RPC_E_WRONG_THREAD;
                }
            }

            // Create a new context call object when policy set
            // is present
            if(pPS)
            {
                pCtxCall = new CCtxCall(CTXCALLFLAG_CLIENT,
                                        pMessage->dataRepresentation);
                if(pCtxCall == NULL)
                    hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            // On the server side, use the existing context call object
            // that was created inside ComInvoke
            pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetServerCtxCall();
            pPS = pCtxCall->_pPS;
            Win4Assert(pCtxCall);
            Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SERVER);
            Win4Assert(pPS == GetStdId()->GetServerPolicySet());
        }

        if(SUCCEEDED(hr))
        {
            if(pPS)
            {
                // Create rpc call object on the stack
                CRpcCall rpcCall(GetStdId()->GetIdentity(),
                                 pMessage, riid, hrCall, CALLSOURCE_CROSSAPT);

                // Size the buffer as needed
                hr = pPS->GetSize(&rpcCall,
                                  fClientSide ? CALLTYPE_SYNCCALL : CALLTYPE_SYNCLEAVE,
                                  pCtxCall);

                // GetSize fails on the server side only if no policy
                // expressed interest in sending data to client side
                Win4Assert(SUCCEEDED(hr) || pCtxCall->_cbExtent==0);
            }

            // Check for the need to abort
            if(SUCCEEDED(hr))
            {
                // Store context call object in TLS
                CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

                // Delegate to CAptRpcChnl::GetBuffer
                hr = CAptRpcChnl::GetBuffer(pMessage, riid);
                Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);

                // Revoke context call object from TLS
                pCtxCall->RevokeFromTLS(Tls, pCurCall);
            }

            // Update state before returning to the proxy/stub
            if(SUCCEEDED(hr))
            {
                // On the clientside, save policy set inside context call
                // object for future reference
                if(fClientSide)
                {
                    // Save the context call object inside message call object
                    ((CMessageCall *) pMessage->reserved1)->SetClientCtxCall(pCtxCall);
                    if(pPS)
                    {
                        pPS->AddRef();
                        pCtxCall->_pPS = pPS;
                    }

                    // Increment per thread outstanding call count
                    if(!(pMessage->rpcFlags & RPC_BUFFER_ASYNC))
                        ++Tls->cCalls;
                }

                // Update state inside context call object
                if(pCtxCall)
                {
                    pCtxCall->_dwFlags |= CTXCALLFLAG_GBSUCCESS;
                    pCtxCall->_hr = hrCall;
                }
            }
            else
            {
                // Check side
                if(fClientSide)
                {
                    // delete context call object and
                    if(pCtxCall)
                        delete pCtxCall;
                }
                else
                {
                    // Reset state inside context call object
                    if(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE)
                        PrivMemFree(pCtxCall->_pvExtent);
                    CPolicySet::ResetState(pCtxCall);
                    pCtxCall->_dwFlags |= CTXCALLFLAG_GBFAILED;
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::GetBuffer is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::SendReceive     public
//
//  Synopsis:   Implements IRpcChannelBuffer::SendReceive
//
//              This method identifies the right policy set, asks it
//              to obtain client buffers from the policies, switches the
//              context, passes the request to CAptRpcChnl::SendReceive,
//              asks the policy set to deliver the buffers created by
//              the polices on the server side, and finally returns
//              to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::SendReceive(RPCOLEMESSAGE *pMessage, ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::SendReceive\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(GetIPIDEntry()->iid, iidName, sizeof(iidName)/sizeof(*iidName));

        ContextDebugOut((DEB_TRACECALLS,
                         "SendReceive on interface %I (%ws) method 0x%x\n",
                         &GetIPIDEntry()->iid, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    // Assert that this routine is called only on the client side
    Win4Assert(Proxy());

    // Obtain the context call object
    HRESULT hr = S_OK;
    COleTls Tls;
    CCtxCall *pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall();

    // Store context call object in TLS
    CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

    // Check for context functionality
    if(pCtxCall)
    {
        // Ensure that GetBuffer succeeded
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);

        // Create rpc call object on the stack
        CRpcCall rpcCall(GetStdId()->GetIdentity(),
                         pMessage, GetIPIDEntry()->iid, hr, CALLSOURCE_CROSSAPT);

        // Obtain the policy set that delivers events
        CPolicySet *pPS = pCtxCall->_pPS;
        Win4Assert(pPS);

        // Deliver client side call events
        hr = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCCALL, pCtxCall);

        // Reset state inside context call object
        CPolicySet::ResetState(pCtxCall);

        // Check for the need to abort
        BOOL fFreeBuffer = TRUE;
        if(SUCCEEDED(hr))
        {
            // Save current context inside context call object
            pCtxCall->_pContext = Tls->pCurrentCtx;

            // Delegate to CAptRpcChnl::SendReceive
            hr = CAptRpcChnl::SendReceive(pMessage, pulStatus);
            Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);

            // FreeBuffer need not be called for failure returns
            if(FAILED(hr))
            {
                // Do not touch any member variables here after as the
                // proxy manager might have deleted the channel due to
                // a nested release
                Win4Assert(pMessage->Buffer == NULL);
                fFreeBuffer = FALSE;
            }
        }
        else
        {
            // The call was failed during delivery of client-side call
            // events.  Free any marshaled interface ptrs in the marshal
            // buffer.
            ReleaseMarshalBuffer(pMessage, (IRpcProxyBuffer *)GetIPIDEntry()->pStub, FALSE);
        }

        // Deliver client side notification events
        hr = pPS->Notify(&rpcCall, CALLTYPE_SYNCRETURN, pCtxCall);

        // FreeBuffer if the call is being aborted
        if(FAILED(hr) && fFreeBuffer)
        {
            // The call was failed during the delivery of client-side
            // notify events.  Free any marshaled out-param interface
            // ptrs in the marshal buffer.
            ReleaseMarshalBuffer(pMessage, (IRpcProxyBuffer *)GetIPIDEntry()->pStub, TRUE);
            
            // Free the buffer obtained from CAptRpcChnl::GetBuffer
            CAptRpcChnl::FreeBuffer(pMessage);
            Win4Assert(pMessage->Buffer == NULL);

            *pulStatus = hr;
            hr = RPC_E_FAULT;
        }

        // Delete context call object for failure returns
        if(SUCCEEDED(hr))
            pCtxCall->_dwFlags |= CTXCALLFLAG_SRSUCCESS;
        else
            delete pCtxCall;
    }
    else
    {
        // Delegate to CAptRpcChnl::SendReceive
        hr = CAptRpcChnl::SendReceive(pMessage, pulStatus);
    }

    // Revoke context call object from TLS
    pCtxCall->RevokeFromTLS(Tls, pCurCall);

    // Check for failure returns
    if(FAILED(hr))
    {
        // Decrement per thread outstanding call count
        --Tls->cCalls;
        Win4Assert((LONG) Tls->cCalls >= 0);

        // Clear any pending uninit
        if((Tls->dwFlags & OLETLS_PENDINGUNINIT) && (Tls->cCalls == 0))
            CoUninitialize();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::SendReceive is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Send       public
//
//  Synopsis:   Implements IRpcChannelBuffer::Send
//
//              This method identifies the right policy set, asks it
//              to obtain buffers from the policies, passes the
//              request to CAptRpcChnl::Send, and returns to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::Send(RPCOLEMESSAGE *pMessage, ISynchronize *pSync,
                               ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Send\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    BOOL fClientSide = Proxy();
    REFIID riid = fClientSide ? GetIPIDEntry()->iid : *MSG_TO_IIDPTR(pMessage);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];
        char *side = Proxy() ? "ClientSend" : "ServerSend";

        iidName[0] = 0;
        GetInterfaceName(riid, iidName, sizeof(iidName)/sizeof(*iidName));

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    // Assert that this routine is called only for async call
    Win4Assert(pMessage->rpcFlags & RPC_BUFFER_ASYNC);

    // Obtain the context call object
    HRESULT hr = S_OK;
    COleTls Tls;
    CCtxCall *pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall();

    // Check for context functionality
    if(pCtxCall)
    {
        EnumCallType eCallType;

        // Ensure that GetBuffer was called before
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);
        if(fClientSide)
        {
            // Sanity check
            Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);

            // Init the call type
            eCallType = CALLTYPE_BEGINCALL;
        }
        else
        {
            // Ensure that GetBuffer was called before
            Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SERVER);

            // Init the call type
            eCallType = CALLTYPE_FINISHLEAVE;
        }

        // Create rpc call object on the stack
        CRpcCall rpcCall(GetStdId()->GetIdentity(),
                         pMessage, riid, hr, CALLSOURCE_CROSSAPT);

        // Obtain the policy set that delivers events
        CPolicySet *pPS = pCtxCall->_pPS;
        Win4Assert(pPS);

        // Deliver client side call events
        hr = pPS->FillBuffer(&rpcCall, eCallType, pCtxCall);

        // Reset state inside context call object
        if(fClientSide)
            CPolicySet::ResetState(pCtxCall);

        // Check for the need to abort
        BOOL fFreeBuffer = TRUE;
        if(SUCCEEDED(hr))
        {
            // Save current context inside context call object
            pCtxCall->_pContext = Tls->pCurrentCtx;

            // As there is no need for modal loop,
            // delegate to CRpcChannelBuffer::Send directly
            hr = CRpcChannelBuffer::Send(pMessage, pSync, pulStatus);
            Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);
            if(FAILED(hr))
                fFreeBuffer = FALSE;
        }

        // Check for success return on the client side
        if(SUCCEEDED(hr) && fClientSide)
        {
            // Deliver BeginReturn events
            pPS->DeliverEvents(&rpcCall, CALLTYPE_BEGINRETURN, pCtxCall);

            // Ignore Nullify calls
            hr = S_OK;
        }

        if(FAILED(hr) && fFreeBuffer)
        {
            // Initialize return code
            *pulStatus = hr;
            hr = RPC_E_FAULT;

            // Cleanup
            if(fClientSide)
            {
                // Free the buffer obtained from CAptRpcChnl::GetBuffer
                CAptRpcChnl::FreeBuffer(pMessage);
                Win4Assert(pMessage->Buffer == NULL);
            }
            else
            {
                // Abort the call on the server side
		// NOTE: a) Currently, Abort is implemented in CMessageCall
		// so the cast is not really necessary.
		// The impl does nothing.
		// b) Async calls to/from contexts are unsupported
		// at present. If it is ever supported
		// this code needs to be revisited. Abort would need
		// to be overridden in CAsyncCall and the the RPC 
		// async abort API needs to be called.
		 
                ((CAsyncCall *) pMessage->reserved1)->Abort();
            }
        }

        // Delete context call object for failure returns on the client side
        if(SUCCEEDED(hr))
        {
            pCtxCall->_dwFlags |= CTXCALLFLAG_SSUCCESS;
        }
        else if(fClientSide)
        {
            delete pCtxCall;
        }
    }
    else
    {
        // As there is no need for modal loop,
        // delegate to CRpcChannelBuffer::Send directly
        hr = CRpcChannelBuffer::Send(pMessage, pSync, pulStatus);
        Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::Send is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Receive       public
//
//  Synopsis:   Implements IRpcChannelBuffer::Receive
//
//              This method delegates the request to CAptRpcChnl::Receive,
//              identifies the right policy set, asks it to deliver server
//              side buffers, and finally returns to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::Receive(RPCOLEMESSAGE *pMessage, ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Receive\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(GetIPIDEntry()->iid, iidName, sizeof(iidName)/sizeof(*iidName));

        ContextDebugOut((DEB_TRACECALLS,
                         "Receive on interface %I (%ws) method 0x%x\n",
                         &GetIPIDEntry()->iid, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    // In the absense of pipes this routine is called
    // only on the client side
    Win4Assert(Proxy());
    // Assert that this routine is called only for async call
    Win4Assert(pMessage->rpcFlags & RPC_BUFFER_ASYNC);

    // Obtain the context call object
    HRESULT hr = S_OK;
    COleTls Tls;
    CCtxCall *pCtxCall = pMessage->reserved1 ?
                         ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall() :
                         NULL;

    // Store context call object in TLS
    CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

    // Check for context functionality
    if(pCtxCall)
    {
        // Sanity checks
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SSUCCESS);

        // Create rpc call object on the stack
        CRpcCall rpcCall(GetStdId()->GetIdentity(),
                         pMessage, GetIPIDEntry()->iid, hr, CALLSOURCE_CROSSAPT);

        // Obtain the policy set that delivers events
        CPolicySet *pPS = pCtxCall->_pPS;
        Win4Assert(pPS);

        // Deliver client side call events
        hr = pPS->FillBuffer(&rpcCall, CALLTYPE_FINISHCALL, pCtxCall);

        // Ignore Nullify calls
        hr = S_OK;

        // Save current context inside context call object
        pCtxCall->_pContext = Tls->pCurrentCtx;

        // As there is no need for modal loop,
        // delegate to CRpcChannelBuffer::Receive directly
        BOOL fFreeBuffer = TRUE;
        hr = CRpcChannelBuffer::Receive(pMessage, pulStatus);
        Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);

        // FreeBuffer need not be called for failure returns
        if(FAILED(hr))
            fFreeBuffer = FALSE;

        // Deliver FinishReturn  events
        hr = pPS->DeliverEvents(&rpcCall, CALLTYPE_FINISHRETURN, pCtxCall);

        // Check for premature failure case
        if(FAILED(hr) && fFreeBuffer)
        {
            // Free the buffer obtained from CAptRpcChnl::Receive
            CAptRpcChnl::FreeBuffer(pMessage);
            Win4Assert(pMessage->Buffer == NULL);

            *pulStatus = hr;
            hr = RPC_E_FAULT;
        }

        // Delete context call object for failure returns
        if(SUCCEEDED(hr))
            pCtxCall->_dwFlags |= CTXCALLFLAG_RSUCCESS;
        else
            delete pCtxCall;
    }
    else
    {
        // As there is no need for modal loop,
        // delegate to CRpcChannelBuffer::Receive directly
        hr = CRpcChannelBuffer::Receive(pMessage, pulStatus);
        Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);
    }

    // Revoke context call object from TLS
    pCtxCall->RevokeFromTLS(Tls, pCurCall);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::Receive is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::FreeBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::FreeBuffer
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::FreeBuffer(RPCOLEMESSAGE *pMessage)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::FreeBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    CCtxCall *pCtxCall;
    COleTls Tls;

    // This method is never called on the server side
    Win4Assert(Proxy());

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        IID *iidCalled;
        WCHAR iidName[256];

        iidCalled = &((RPC_CLIENT_INTERFACE *) pMessage->reserved2[1])->InterfaceId.SyntaxGUID;
        iidName[0] = 0;
        GetInterfaceName(*iidCalled, iidName, sizeof(iidName)/sizeof(*iidName));

        ContextDebugOut((DEB_TRACECALLS,
                         "FreeBuffer on interface %I (%ws) method 0x%x\n",
                         iidCalled, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    if(pMessage->Buffer)
    {
        // Obtain the context call object
        pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall();

        // Sanity Checks
        Win4Assert(!pCtxCall || pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(!pCtxCall || pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);

        // Delete the context call object
        if(pCtxCall)
            delete pCtxCall;

        // Delegate to CAptRpcChnl::FreeBuffer
        hr = CAptRpcChnl::FreeBuffer(pMessage);
        Win4Assert(pMessage->Buffer == NULL);

        // Decrement per thread outstanding call count
        if(!(pMessage->rpcFlags & RPC_BUFFER_ASYNC))
        {
            --Tls->cCalls;
            Win4Assert((LONG) Tls->cCalls >= 0);

            // Clear any pending uninit
            if((Tls->dwFlags & OLETLS_PENDINGUNINIT) && (Tls->cCalls == 0))
                CoUninitialize();
        }
    }
	else
	{
		// No buffer to free, everything is just fine.
		hr = S_OK;
	}

    // Do not touch any member variables here after as the proxy manager
    // might have deleted the channel due to a nested release

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::FreeBuffer is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::ContextInvoke     public
//
//  Synopsis:   This method switches the context, identifies the right
//              policy set, asks the policy set to deliver the buffers
//              created by the polices on the client side, invokes the
//              call on the server object through StubInvoke, obtains
//              server side buffers through policy set and finally
//              returns to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::ContextInvoke(RPCOLEMESSAGE *pMessage,
                                        IRpcStubBuffer *pStub,
                                        IPIDEntry *pIPIDEntry,
                                        DWORD *pdwFault)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::ContextInvoke\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        IID *iidCalled;
        WCHAR iidName[256];

        iidCalled = MSG_TO_IIDPTR(pMessage);
        iidName[0] = 0;
        GetInterfaceName(*iidCalled, iidName, sizeof(iidName)/sizeof(*iidName));
        ContextDebugOut((DEB_TRACECALLS,
                         "ContextInvoke on interface %I (%ws) method 0x%x\n",
                         iidCalled, iidName, pMessage->iMethod));
    }
#endif

    // This method is never called on the client side
    Win4Assert(Server());

    // Obtain context call object
    CCtxCall *pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetServerCtxCall();

    // Obtain the policy set node
    CPolicySet *pPS = GetStdId()->GetServerPolicySet();
    CObjectContext *pSavedCtx, *pServerCtx;

    // Obtain server object context
    if(pPS)
    {
        // Object lives inside a non-empty context
        pServerCtx = pPS->GetServerContext();
    }
    else
    {
        // Object lives in empty context
        pServerCtx = GetEmptyContext();
    }

    // Assert that there is server empty context
    Win4Assert(pServerCtx);

    // if pServerCtx is NULL it means the MTA has been released out from under us
    // by another thread. This code doesn't fix the problem, but it's better than an AV.
    if(!pServerCtx)
        return CO_E_NOTINITIALIZED;

    // Save current context
    COleTls Tls;
    pSavedCtx = Tls->pCurrentCtx;

    // Switch to the server object context
    Tls->pCurrentCtx = pServerCtx;
    Tls->ContextId = pServerCtx->GetId();
    pServerCtx->InternalAddRef();
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                     pSavedCtx, pServerCtx));

    // Update context call object
    pCtxCall->_pPS = pPS;
    pCtxCall->_pContext = pServerCtx;

    // Create rpc call object on the stack
    HRESULT hrCall = S_OK;
    CRpcCall rpcCall(GetStdId()->GetIdentity(), pMessage,
                     *MSG_TO_IIDPTR(pMessage), hrCall, CALLSOURCE_CROSSAPT);

    // Deliver server side notification events
    if(pPS)
        hrCall = pPS->Notify(&rpcCall, CALLTYPE_SYNCENTER, pCtxCall);

    // Check for the need to dispatch call to server object
    BOOL fDoCleanup = TRUE;
    if(SUCCEEDED(hrCall))
    {
        // Delegate to StubInvoke
        hrCall = StubInvoke(pMessage, GetStdId(), pStub,
                            (IRpcChannelBuffer3 *)this,
                            pIPIDEntry, pdwFault);
        if (FAILED(hrCall))
        {
            // StubInvoke failed, therefore we don't want to try to
            // clean up the marshal buffer later if event delivery
            // fails.
            fDoCleanup = FALSE;
        }

        // Make sure we're back on the right context
        CheckContextAfterCall (Tls, pServerCtx);
    }
    else
    {
        // The call was aborted during delivery of server-side notify
        // events.  We need to release any marshaled in-param interface
        // ptrs in the marshal buffer.
        ReleaseMarshalBuffer(pMessage, pStub, FALSE);
	fDoCleanup = FALSE;
    }

    // Deliver server side leave events
    if(pPS && (hrCall != RPC_E_INVALID_HEADER))
    {
        // Check if GetBuffer was called by the stub
        if(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS)
        {
            // Update call status to that saved in GetBuffer
            if(FAILED(pCtxCall->_hr))
                hrCall = pCtxCall->_hr;
        }
        else if(!(pCtxCall->_dwFlags & CTXCALLFLAG_GBFAILED))
        {
            // The call must have failed
            Win4Assert(FAILED(hrCall));

            // Initailize
            CPolicySet::ResetState(pCtxCall);
            pMessage->cbBuffer = 0;

            // Obtain the buffer size needed by the server side policies
            // GetSize will fail on the server side only if no policy
            // expressed interest in sending data to the client side
            pPS->GetSize(&rpcCall, CALLTYPE_SYNCLEAVE, pCtxCall);

	    // Store context call object in TLS
	    CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

	    // Delegate to CAptRpcChnl::GetBuffer
	    HRESULT hr = CAptRpcChnl::GetBuffer(pMessage, *MSG_TO_IIDPTR(pMessage));
	    if(FAILED(hr))
	       CPolicySet::ResetState(pCtxCall);
	    else
	       fDoCleanup = TRUE;
		   
	    // Revoke context call object from TLS
	    pCtxCall->RevokeFromTLS(Tls, pCurCall);
            
            //Process Local calls do not use RPC, so do not use extended error info
	    if ( ((CMessageCall *) pMessage->reserved1)->ProcessLocal())
	    {
               ((CMessageCall *) pMessage->reserved1)->SetErrorFromPolicy();
	    }
	    else
	    {
               RPC_EXTENDED_ERROR_INFO ErrorInfo;	    
               memset(&ErrorInfo, 0, sizeof(ErrorInfo));	
               ErrorInfo.Version = RPC_EEINFO_VERSION;
               ErrorInfo.NumberOfParameters = 1;
               ErrorInfo.GeneratingComponent = EEInfoGCCOM;
               ErrorInfo.Status = hrCall;
               ErrorInfo.Parameters[0].u.BVal.Buffer = ((CMessageCall *) pMessage->reserved1)->_pHeader;
               ErrorInfo.Parameters[0].u.BVal.Size =(short)((CMessageCall *) pMessage->reserved1)->_dwErrorBufSize;
               ErrorInfo.Parameters[0].ParameterType = eeptBinary;
               // If this fails, we do nothing. We are already in an error path
               // and this API is a best-efforts deal.
               RPC_STATUS status = RpcErrorAddRecord(&ErrorInfo);
   #if DBG==1
               if (RPC_S_OK != status ) 
               {
                   ContextDebugOut((DEB_CTXCOMCHNL,
                    "CCtxComChnl::ContextInvoke RpcErrorAddRecord failed 0x%x\n", status));
               }
   #endif	    
            }
        }

        hrCall = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCLEAVE, pCtxCall);
        if (fDoCleanup && FAILED(hrCall))
        {
            // StubInvoke succeeded but the call was aborted during delivery
            // of server-side leave events.  We need to release any
            // marshaled out-param interface ptrs that are in the
            // marshal buffer.
            ReleaseMarshalBuffer(pMessage, pStub, TRUE);
        }
    }

    // Switch back to the saved context
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                     pSavedCtx, pServerCtx));
    pServerCtx->InternalRelease();
    Tls->pCurrentCtx = pSavedCtx;
    Tls->ContextId = (pSavedCtx) ? pSavedCtx->GetId() : (ULONGLONG)-1;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::ContextInvoke is returning hr:0x%x\n", hrCall));
    return(hrCall);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Copy     public
//
//  Synopsis:   Used by CStdIdentity to create channel copies on the
//              client side
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxComChnl *CCtxComChnl::Copy(OXIDEntry *pOXIDEntry, REFIPID ripid,
                               REFIID riid)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Copy\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // This routine is called only on client channels
    Win4Assert(IsClientChannel() || Proxy());

    // Make a new context channel
    CCtxComChnl *pChannel = new CCtxComChnl(GetStdId(), pOXIDEntry, GetState());
    if(pChannel)
        CAptRpcChnl::UpdateCopy(pChannel);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::Copy returning pChannel:0x%x\n", pChannel));
    return pChannel;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::QueryInterface     public
//
//  Synopsis:   QI behavior of CCtxHook object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxHook::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::QueryInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IChannelHook))
    {
        *ppv = (IChannelHook *) this;
    }
    else if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // No need to AddRef the interface before returning
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ClientGetSize     public
//
//  Synopsis:   Returns the size of extent saved in the context call
//              object inside CPolicySet::GetSize
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ClientGetSize(REFGUID rguid, REFIID riid,
                                            ULONG *pcb)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientGetSize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT));

    // Return extent size saved inside context call object
    // For rejected calls, return 0
    if(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_MFRETRY))
        *pcb = 0;
    else
        *pcb = pCtxCall->_cbExtent;

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ClientFillBuffer     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::FillBuffer
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ClientFillBuffer(REFGUID rguid, REFIID riid,
                                               ULONG *pcb, void *pv)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientFillBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT));

    // Save the buffer pointer inside context call object
    // For rejected calls, return 0
    if(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_MFRETRY))
    {
        *pcb = 0;
    }
    else
    {
        *pcb = pCtxCall->_cbExtent;
         if(pCtxCall->_cbExtent)
             pCtxCall->_pvExtent = pv;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ServerNotify     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::Notify
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------                                  void *, DWORD);
STDMETHODIMP_(void) CCtxHook::ServerNotify(REFGUID rguid, REFIID riid,
                                           ULONG cb, void *pv,
                                           DWORD dwDataRep)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ServerNotify\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_SERVER));

    // Save the extent pointer inside context call object
    if(cb)
        pCtxCall->_pvExtent = pv;

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ServerGetSize     public
//
//  Synopsis:   Returns the size of extent saved in the context call
//              object inside CPolicySet::GetSize
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ServerGetSize(REFGUID rguid, REFIID riid,
                                            HRESULT hrRet, ULONG *pcb)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ServerGetSize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_SERVER));

    // Return extent size saved inside context call object
    *pcb = pCtxCall->_cbExtent;
    if(!(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE))
    {
        CPolicySet::ResetState(pCtxCall);

        // Sergei O. Ivanov (a-sergiv)  9/22/99  NTBUG #403726
        // We must clear this flag, since ResetState just cleared pvExtent in pCtxCall.
        // Leaving this flag set will instruct DeliverEvents to reuse the buffer and crash.

        pCtxCall->_dwFlags &= ~CTXCALLFLAG_GBINIT;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ServerFillBuffer     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::FillBuffer
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ServerFillBuffer(REFGUID rguid, REFIID riid,
                                               ULONG *pcb, void *pv,
                                               HRESULT hrRet)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ServerFillBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_SERVER));

    // Save the buffer pointer inside context call object
    *pcb = pCtxCall->_cbExtent;
    if(pCtxCall->_cbExtent)
    {
        if(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE)
        {
            memcpy(pv, pCtxCall->_pvExtent, pCtxCall->_cbExtent);
            PrivMemFree(pCtxCall->_pvExtent);
        }
        pCtxCall->_pvExtent = pv;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ClientNotify     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::Notify
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ClientNotify(REFGUID rguid, REFIID riid,
                                           ULONG cb, void *pv,
                                           DWORD dwDataRep, HRESULT hrRet)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientNotify\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    if(pCtxCall)
    {
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(pCtxCall->_pvExtent == NULL);

        // Save the extent pointer inside context call object
        if(cb)
            pCtxCall->_pvExtent = pv;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::PrepareForRetry     private
//
//  Synopsis:   Called from Apartment call control to inform that
//              Message Filter has decided to retry a rejected call
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxHook::PrepareForRetry(CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientNotify\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Obtain the context call object
    Win4Assert(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT));

    // Mark the call as being retried through Message Filter
    if(pCtxCall)
    {
        pCtxCall->_dwFlags |= CTXCALLFLAG_MFRETRY;
        pCtxCall->_pvExtent = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\excepn.cxx ===
//+-------------------------------------------------------------------
//
//  File:       excepn.cxx
//
//  Contents:   Exception handling routines
//
//  Classes:    
//
//  History:    11-Jan-99   TarunA      Created
//										
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <excepn.hxx>
#include <pstable.hxx>      // GetCurrentContext()


/***************************************************************************/
/* Globals. */

#if DBG==1
LPEXCEPTION_POINTERS g_pExcep = NULL;

// Silences checked build excepn popups when true
extern BOOL gfSuppressDebugExceptionPopup = FALSE; 
#endif

// Should the debugger hooks be called?
BOOL gfCatchServerExceptions = TRUE;
BOOL gfBreakOnSilencedExceptions = TRUE;

//-------------------------------------------------------------------------
//
//  Function:   ServerExceptionFilter
//
//  synopsis:   Determines if DCOM should catch the server exception or not.
//
//  History:    25-Jan-97   Rickhi  Created
//
//-------------------------------------------------------------------------
LONG ServerExceptionFilter(LPEXCEPTION_POINTERS lpep)
{
    if (!gfCatchServerExceptions)
    {
        // the system admin does not want DCOM servers to catch
        // some exceptions (helps ISVs debug their servers).
        if (ServerExceptionOfInterest(lpep->ExceptionRecord->ExceptionCode))
        {
            return EXCEPTION_CONTINUE_SEARCH;
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


#if DBG==1
BOOL RunningInSystemDesktop()
{
    WCHAR   wszWinsta[64];
    HWINSTA hWinsta;
    DWORD   Size;

    hWinsta = GetProcessWindowStation();
    Size = sizeof(wszWinsta);
    wszWinsta[0] = 0;

    if ( hWinsta )
    {
        (void) GetUserObjectInformation(
                                       hWinsta,
                                       UOI_NAME,
                                       wszWinsta,
                                       Size,
                                       &Size );
    }

    //
    // This makes popups from non-interactive servers/services (including
    // rpcss) visible.
    //
    if (wszWinsta[0] && (lstrcmpiW(wszWinsta,L"Winsta0") != 0))
    {
        return TRUE;
    }

    return FALSE;
}
#endif

BOOL IsKernelDebuggerPresent()
{
    return USER_SHARED_DATA->KdDebuggerEnabled;
}

void PrintFriendlyDebugMessage (LPEXCEPTION_POINTERS lpep, LPVOID pvObject)
{
    DbgPrint("\n"
             "The exception pointers are located at 0x%p\n"
             "To get the faulting stack do the following:\n"
             "\n"
             "1) Do a '.exr 0x%p' to display the exception record\n"
             "2) Do a '.cxr 0x%p' to display the context record\n"
             "3) Do a 'kb' to display the stack\n"
             "\n",
             lpep,
             lpep->ExceptionRecord,
             lpep->ContextRecord);
    if (pvObject)
    {
        DbgPrint("The object we attempted to call is at 0x%p.\n", pvObject);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PeekMessageExceptionFilter
//
//  Synopsis:   When PeekMessage throws an exception, print out enough information for
//              the 'user' to debug the problem
//
//  Arguments:  [lpep] -- Exception context records
//
//  History:    1-02-02   mfeingol  Created
//
//----------------------------------------------------------------------------

LONG PeekMessageExceptionFilter (LPEXCEPTION_POINTERS lpep)
{
    if (IsDebuggerPresent() || IsKernelDebuggerPresent())
    {
        DbgPrint("OLE has caught a fault 0x%08x during a call to PeekMessage\n", lpep->ExceptionRecord->ExceptionCode);
        PrintFriendlyDebugMessage (lpep, NULL);
        DebugBreak();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

//+---------------------------------------------------------------------------
//
//  Function:   SymAPIExceptionFilter
//
//  Synopsis:   When a SymXX API throws an exception, print out enough information for
//              the 'user' to debug the problem
//
//  Arguments:  [lpep] -- Exception context records
//
//  History:    1-16-02   mfeingol  Created
//
//----------------------------------------------------------------------------
LONG SymAPIExceptionFilter (LPEXCEPTION_POINTERS lpep)
{
    if (IsDebuggerPresent() || IsKernelDebuggerPresent())
    {
        DbgPrint("OLE has caught a fault 0x%08x during a call to a dbghelp API\n", lpep->ExceptionRecord->ExceptionCode);
        PrintFriendlyDebugMessage (lpep, NULL);
        DebugBreak();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

//+---------------------------------------------------------------------------
//
//  Function:   AppInvokeExceptionFilter
//
//  Synopsis:   Determine if the application as thrown an exception we want
//              to report. If it has, then print out enough information for
//              the 'user' to debug the problem
//
//  Arguments:  [lpep] -- Exception context records
//
//  History:    6-20-95   kevinro   Created
//              6-09-98   Gopalk    Modified to be useful for debugging
//              9-25-98   stevesw   provide stack information....
//
//----------------------------------------------------------------------------
LONG AppInvokeExceptionFilter(LPEXCEPTION_POINTERS lpep, 
                              LPVOID pvObject,
                              REFIID riid,
                              DWORD dwMethod)
{
    LONG ret = ServerExceptionFilter(lpep);
    DWORD dwFault = lpep->ExceptionRecord->ExceptionCode;

    // First, send the exception into the verifier to let it have first
    // crack at it.
    BOOL bUserNotified = CoVrfBreakOnException(lpep, pvObject, &riid, dwMethod);

    // TODO: Should the rest of this break stuff still exist?  The verifier stop
    //       should be what everybody sees, I think...
#if DBG==1    
    if(ServerExceptionOfInterest(dwFault) && !gfSuppressDebugExceptionPopup && !bUserNotified)
    {           
        // Save the exception info in a local since somebody will surely not read the msg
        // below and we'll end up debugging it anyway.
        LPEXCEPTION_POINTERS lpepLocal = lpep;
		
        // We also save the exception info in a global for super-easy access.  Note that
        // if we have two server exceptions in the same process, the second one will overwrite
        // the global contents set by the first exception.
        g_pExcep = lpep;

        UINT uiMBFlags;
        WCHAR iidName[256];
        WCHAR szProgname[256];
        WCHAR szPopupMsg[768];

        WCHAR szInterfaceGuid[50];

        // Initialize
        iidName[0] = 0;
        szProgname[0] = 0;
        GetModuleFileName(NULL, szProgname, sizeof(szProgname) / sizeof(WCHAR));
		szProgname[(sizeof(szProgname) / sizeof(WCHAR)) - 1] = 0;
        GetInterfaceName(riid, iidName, sizeof(iidName)/sizeof(*iidName));
        StringFromGUID2(riid, szInterfaceGuid, 50);

        // Output to debugger
        DbgPrint("OLE has caught a fault 0x%08x on behalf of the server %ws\n",
                   dwFault, szProgname);
        DbgPrint("The fault occurred when OLE called the interface %ws (%ws) "
                   "method 0x%x\n", szInterfaceGuid, iidName, dwMethod);
        
        // if there is a debugger, we will break. Otherwise do the popup.
        if (IsDebuggerPresent() || IsKernelDebuggerPresent() )
        {
           PrintFriendlyDebugMessage (lpep, pvObject);
           DebugBreak();
        }
        else
        {
           // Ask user if they want to debug this
           wsprintf(szPopupMsg, L"OLE has caught a fault 0x%08x on behalf of the server %ws. "
                                L"The fault occurred when OLE called method %0x on interface %ws (%ws)."
                                L"\r\n\r\n"
                                L"Press Cancel to debug.",
                                dwFault,
                                szProgname,
                                dwMethod,
                                szInterfaceGuid,
                                iidName);
           
           // Set message box flags
           uiMBFlags = MB_SETFOREGROUND | MB_TOPMOST | MB_OKCANCEL | MB_ICONHAND | MB_TASKMODAL;
   
           if (RunningInSystemDesktop())
           {
               // This makes popups from non-interactive servers/services (including
               // rpcss) visible.
               uiMBFlags |= MB_SERVICE_NOTIFICATION;
           }
   
           if (IDCANCEL == MessageBox(NULL, 
                                      szPopupMsg, 
                                      L"Unhandled exception", 
                                      uiMBFlags))
           {
               PrintFriendlyDebugMessage (lpep, pvObject);
               DebugBreak();
           }
        }

        bUserNotified = TRUE;
    }
#endif

    // Deliver exception notification to current context
    // COM+ 23780 - do this on all exceptions, not just those of interest
    GetCurrentContext()->NotifyServerException(lpep);

    // We have historically caught exceptions and silenced them.
    // This is a bad idea for exceptions of interest because valuable debugging
    // information is lost, particularly while developing a new OS.
    //
    // So, for now, if we were going to silence the exception and 
    // there's a debugger around to handle an int 3, use it.
    //
    // This will probably cause enough appcompat issues that we'll want to remove
    // it before Whistler RTM.  However, for now this is going in.
    if (gfBreakOnSilencedExceptions &&
        !bUserNotified &&
        ret == EXCEPTION_EXECUTE_HANDLER && 
        (IsDebuggerPresent() || IsKernelDebuggerPresent()))
    {
        DbgPrint("OLE has caught a fault 0x%08x on behalf of an OLE server\n", dwFault);
        PrintFriendlyDebugMessage (lpep, pvObject);
        DebugBreak();
    }

    return ret;
}

/***************************************************************************/
#if DBG==1
LONG ComInvokeExceptionFilter( DWORD lCode,
                               LPEXCEPTION_POINTERS lpep )
{
    ComDebOut((DEB_ERROR, "Exception 0x%x in ComInvoke at address 0x%x\n",
               lCode, lpep->ExceptionRecord->ExceptionAddress));
    LONG lfilter = ServerExceptionFilter(lpep);
    if (lfilter == EXCEPTION_EXECUTE_HANDLER)
    {
        DebugBreak();
    }
    return lfilter;
}
#endif

/***************************************************************************/
LONG ThreadInvokeExceptionFilter( DWORD lCode,
                                  LPEXCEPTION_POINTERS lpep )
{
    ComDebOut((DEB_ERROR, "Exception 0x%x in ThreadInvoke at address 0x%x\n",
               lCode, lpep->ExceptionRecord->ExceptionAddress));
    LONG lfilter = ServerExceptionFilter(lpep);
    if (lfilter == EXCEPTION_EXECUTE_HANDLER)
    {
        DebugBreak();
    }
    return lfilter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\giptbl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       giptbl.cxx
//
//  Contents:   code for storing/retrieving interfaces from global ptrs
//
//  Functions:  RegisterInterfaceInGlobal
//              RevokeInterfaceFromGlobal
//              GetInterfaceFromGlobal
//
//  History:    18-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <giptbl.hxx>
#include <marshal.hxx>
#include <stdid.hxx>
#include <xmit.hxx>
#include <chancont.hxx> // Event cache

// global GIP table
CGIPTable          gGIPTbl;
DWORD              CGIPTable::_dwCurrSeqNo  = GIP_SEQNO_MIN;
BOOL               CGIPTable::_fInRevokeAll = FALSE;
GIPEntry           CGIPTable::_InUseHead    = { &_InUseHead, &_InUseHead };
CPageAllocator     CGIPTable::_palloc;   // allocator for GIPEntries
COleStaticMutexSem CGIPTable::_mxs;      // critical section for table

typedef struct
{
    HANDLE _hEvent;
    DWORD  _dwCookie;
} STwoBits;

// function prototypes
HRESULT __stdcall ReleaseCallback(void *prm);


//+-------------------------------------------------------------------
//
//  Function:   RevokeFromMTA
//
//  Synopsis:   helper function for CacheCreateThread
//
//+-------------------------------------------------------------------
DWORD _stdcall RevokeFromMTA(void *param)
{
    STwoBits *pParam = (STwoBits *) param;
    HRESULT   hr;
    COleTls   tls(hr);
    if (SUCCEEDED(hr))
    {
        hr = gGIPTbl.RevokeInterfaceFromGlobal(pParam->_dwCookie);

        // HACK ALERT
        // 
        // RevokeInterfaceFromGlobal can leave the pCurrentCtx state
        // in tls pointing to bogus memory (we are on a worker thread
        // here, this should not be the case).  I am NULL-ing itout  
        // as a quick fix.  long term we need to define what cleanup
        // actions a worker thread (or the things that it calls) should
        // do when going back into the idle state.
        tls->pCurrentCtx = NULL;
    }
    SetEvent(pParam->_hEvent);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::Initialize, public
//
//+-------------------------------------------------------------------
void CGIPTable::Initialize()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ComDebOut((DEB_MARSHAL, "CGIPTable::Initialize\n"));
    // allocations are single-threaded by the calling code, so the
    // allocator doesn't need to take the lock.
    _palloc.Initialize(sizeof(GIPEntry), GIPS_PER_PAGE, NULL);
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::Cleanup, public
//
//  Synopsis:   cleans up the page allocator.
//
//+-------------------------------------------------------------------
void CGIPTable::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ComDebOut((DEB_MARSHAL, "CIPIDTable::Cleanup\n"));
    _palloc.Cleanup();
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::ApartmentCleanup, public
//
//  Synopsis:   cleans up the left-over entries for the current
//              apartment.
//
//  CODEWORK: RICKHI - this method may be temporary
//
//+-------------------------------------------------------------------
#define MAX_GIPS_TO_RELEASE 50

void CGIPTable::ApartmentCleanup()
{
    ComDebOut((DEB_MARSHAL, "CIPIDTable::ApartmentCleanup\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);

    DWORD dwCurrentAptId = GetCurrentApartmentId();
    BOOL  fMore;

    do
    {
        fMore = FALSE;      // exit the while loop unless told otherwise
        int i = 0;          // count of cookies to release
        DWORD dwCookie[MAX_GIPS_TO_RELEASE]; // cache of cookies to release

        ASSERT_LOCK_NOT_HELD(_mxs);
        LOCK(_mxs);

        // loop over existing GIPEntries
        GIPEntry *pGIPEntry = _InUseHead.pNext;
        while (pGIPEntry != &_InUseHead)
        {
            if (pGIPEntry->dwAptId == dwCurrentAptId)
            {
                // the entry was registered by the current apartment.
                // remember the cookie and count one more entry to revoke.
                dwCookie[i] = _palloc.GetEntryIndex((PageEntry *)pGIPEntry);
                dwCookie[i] |= pGIPEntry->dwSeqNo;
                i++;
                if (i>=MAX_GIPS_TO_RELEASE)
                {
                    // we have exhausted our cache, after we go free the ones
                    // we currently have, come back again for another round.
                    fMore = TRUE;
                    break;
                }
            }

            // next entry
            pGIPEntry = pGIPEntry->pNext;
        }

        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);

        // if we found any leftover entries for the current apartment
        // revoke them.
        for (int j=0; j<i; j++)
        {
            RevokeInterfaceFromGlobal(dwCookie[j]);
        }

    } while (fMore);

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "CIPIDTable::ApartmentCleanup\n"));
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RevokeAllEntries, public
//
//  Synopsis:   Walks the InUse list to cleanup any leftover
//              entries.
//
//+-------------------------------------------------------------------
void CGIPTable::RevokeAllEntries()
{
    ComDebOut((DEB_MARSHAL, "CGIPTable::RevokeAllEntries\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);

    // walk the InUse list and cleanup leftover entries
    _fInRevokeAll = TRUE;
    while (_InUseHead.pNext != &_InUseHead)
    {
        // get the cookie and release the entry
        DWORD dwCookie = _palloc.GetEntryIndex((PageEntry *)_InUseHead.pNext);
        dwCookie |= _InUseHead.pNext->dwSeqNo;
        RevokeInterfaceFromGlobal(dwCookie);
    }
    _fInRevokeAll = FALSE;

    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Methods:    CGIPTable::AllocEntry, private
//
//  Synopsis:   Allocates an entry in the table, assigns a cookie and
//              sequence number, and increments the sequence number.
//
//+-------------------------------------------------------------------
HRESULT CGIPTable::AllocEntry(GIPEntry **ppGIPEntry, DWORD *pdwCookie)
{
    HRESULT hr = E_OUTOFMEMORY;
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // allocate an entry
    DWORD dwCookie = 0;
    GIPEntry *pGIPEntry = (GIPEntry *) _palloc.AllocEntry();
    if (pGIPEntry)
    {
        // chain it on the list of inuse entries
        pGIPEntry->pPrev        = &_InUseHead;
        _InUseHead.pNext->pPrev = pGIPEntry;
        pGIPEntry->pNext        = _InUseHead.pNext;
        _InUseHead.pNext        = pGIPEntry;

        // get and increment the sequence number
        DWORD dwSeqNo = pGIPEntry->dwSeqNo & GIP_SEQNO_MASK;
        if (dwSeqNo != 0)
        {
            // the entry has been used before so just increment
            // the existing sequence number for this entry.
            dwSeqNo += GIP_SEQNO_MIN;
            if (dwSeqNo > GIP_SEQNO_MAX)
                dwSeqNo = GIP_SEQNO_MIN;
        }
        else
        {
            // the entry has never been used before so initialize
            // it's sequence number to the current global sequence
            //  number and increment the global sequence number.
            dwSeqNo = _dwCurrSeqNo;
            _dwCurrSeqNo += GIP_SEQNO_MIN;
            if (_dwCurrSeqNo > GIP_SEQNO_MAX)
                _dwCurrSeqNo = GIP_SEQNO_MIN;
        }

        // store the seqno in the entry
        pGIPEntry->dwSeqNo = dwSeqNo;

        // compute the cookie for the entry
        dwCookie = _palloc.GetEntryIndex((PageEntry *)pGIPEntry);
        dwCookie |= pGIPEntry->dwSeqNo;

        pGIPEntry->dwType    = ORT_UNUSED;
        pGIPEntry->cUsage    = -1;   // gets set to 0 if Register succeeds
        pGIPEntry->dwAptId   = GetCurrentApartmentId();
        pGIPEntry->hWndApt   = NULL;
        pGIPEntry->pContext  = NULL;
        pGIPEntry->pUnk      = NULL;
        pGIPEntry->pUnkProxy = NULL;
        pGIPEntry->u.pIFD    = NULL;
        hr = S_OK;
    }

    *pdwCookie = dwCookie;
    *ppGIPEntry = pGIPEntry;

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Methods:    CGIPTable::FreeEntry, private
//
//  Synopsis:   Dechains the entry from the inuse list, marks it as
//              unused, and returns it to the table.
//
//+-------------------------------------------------------------------
void CGIPTable::FreeEntry(GIPEntry *pGIPEntry)
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // ensure the usage count is -1
    Win4Assert(pGIPEntry->cUsage == -1);

    // unchain it from the list of InUse entries
    pGIPEntry->pPrev->pNext = pGIPEntry->pNext;
    pGIPEntry->pNext->pPrev = pGIPEntry->pPrev;

    // return it to the table
    pGIPEntry->dwType = ORT_UNUSED;
    _palloc.ReleaseEntry((PageEntry *)pGIPEntry);

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::ChangeUsageCount, private
//
//  Synopsis:   Thread-Safe increment or decrement of usage count
//
//  History:    09-Apr-98   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CGIPTable::ChangeUsageCount(GIPEntry *pGIPEntry, LONG lDelta)
{
    LONG cUsage = pGIPEntry->cUsage;
    while (cUsage != -1)
    {
        // try to atomically change the usage count
        if (InterlockedCompareExchange(&pGIPEntry->cUsage, cUsage + lDelta,
                                       cUsage) == cUsage)
        {
            // exchange occurred, we're done.
            return S_OK;
        }
        cUsage = pGIPEntry->cUsage;
    }

    return E_INVALIDARG;
}

//+-------------------------------------------------------------------
//
//  Methods:    CGIPTable::GetEntryPtr, private
//
//  Synopsis:   From a cookie, finds the entry pointer. Ensures the
//              cookie is a valid index and the entry has a matching
//              sequence number.
//
//  Returns:    S_OK - The GIPEntry ptr, with the cUsage incremented.
//                     ReleaseEntryPtr must be called to dec cUsage.
//              E_INVALIDARG - otherwise
//
//+-------------------------------------------------------------------
HRESULT CGIPTable::GetEntryPtr(DWORD dwCookie, GIPEntry **ppGIPEntry)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwSeqNo = dwCookie & GIP_SEQNO_MASK;
    dwCookie &= ~GIP_SEQNO_MASK;

    if (_palloc.IsValidIndex(dwCookie))
    {
        GIPEntry *pGIPEntry = (GIPEntry *)_palloc.GetEntryPtr(dwCookie);
        if (pGIPEntry &&
            pGIPEntry->dwSeqNo == dwSeqNo &&
            pGIPEntry->dwType != ORT_UNUSED)
        {
            // count one more user to ensure no races between GetInterface
            // and RevokeInterface.
            if (SUCCEEDED(ChangeUsageCount(pGIPEntry, 1)))
            {
                // ensure it was not released and re-used
                if (pGIPEntry->dwSeqNo == dwSeqNo)
                {
                    // OK.
                    *ppGIPEntry = pGIPEntry;
                    hr = S_OK;
                }
                else
                {
                    // re-used, release the count and return an error.
                    ChangeUsageCount(pGIPEntry, -1);
                }
            }
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::QueryInterface, public
//
//  History:    18-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CGIPTable::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IGlobalInterfaceTable))
    {
        *ppv = (IGlobalInterfaceTable *)this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RegisterInterfaceInGlobal, public
//
//  Synopsis:   Registers an interface for storage in a global.
//
//  Arguments:  [pUnk] - interface to register
//              [riid] - iid of interface punk
//              [pdwCookie] - registration cookie returned
//
//  History:    18-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CGIPTable::RegisterInterfaceInGlobal(IUnknown *pUnk,
                                                  REFIID riid, DWORD *pdwCookie)
{
    // call helper function to do the work.
    return RegisterInterfaceInGlobalHlp(pUnk,
                                        riid,
                                        MSHLFLAGS_TABLESTRONG,
                                        pdwCookie);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RegisterInterfaceInGlobalHlp, public
//
//  Synopsis:   Registers an interface for storage in a global.
//
//  Arguments:  [pUnk] - interface to register
//              [riid] - iid of interface punk
//              [pdwCookie] - registration cookie returned
//
//  History:    18-Mar-97   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//
//--------------------------------------------------------------------
HRESULT CGIPTable::RegisterInterfaceInGlobalHlp(IUnknown *pUnk,
                                                REFIID riid,
                                                DWORD mshlflags,
                                                DWORD *pdwCookie)
{
    ComDebOut((DEB_MARSHAL,"RegisterInterfaceInGlobal pUnk:%x riid:%I pdwCookie:%x\n",
               pUnk, &riid, pdwCookie));
    ASSERT_LOCK_NOT_HELD(_mxs);


    // check the input parameters
    if (!IsValidInterface(pUnk) || pdwCookie == NULL)
    {
        return E_INVALIDARG;
    }

    // init in case of error
    *pdwCookie = 0;

    // ensure the channel is initialized.
    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    // get the window handle to place in the GIPEntry
    // to handle revoke from the wrong apartment.
    OXIDEntry *pOXIDEntry = NULL;
    hr = GetLocalOXIDEntry(&pOXIDEntry);
    if (FAILED(hr))
    {
        return hr;
    }
    HWND hwndApt = pOXIDEntry->GetServerHwnd();

    // allocate an entry in the GIPTable
    DWORD dwCookie = 0;
    GIPEntry *pGIPEntry = NULL;
    hr = AllocEntry(&pGIPEntry, &dwCookie);

    if (SUCCEEDED(hr))
    {
        IMarshal *pIM = NULL;
        CStdIdentity *pStdId = NULL;

        if (SUCCEEDED(pUnk->QueryInterface(IID_IStdIdentity,
                                           (void **)&pStdId)))
        {
            // Object is a proxy.
            if (pStdId->FTMObject())
            {
                // This is a proxy for an FTM object that has been marshaled
                // out of proc.  The proxy lives in the NA and it is agile,
                // so just store a pointer to it.
                pGIPEntry->dwType = ORT_FREETM;
                hr = S_OK;
            }
            else
            {
                // Marshal the proxy.
                pGIPEntry->dwType = ORT_OBJREF;
                hr = E_OUTOFMEMORY;
                pGIPEntry->u.pobjref = (OBJREF *)PrivMemAlloc(sizeof(OBJREF));
                if (pGIPEntry->u.pobjref)
                {
                    hr = pStdId->MarshalObjRef(*(pGIPEntry->u.pobjref), riid,  mshlflags,
                                                 MSHCTX_INPROC, NULL, 0);
                }
            }
            pStdId->Release();
        }
        else if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshal, (void **)&pIM)))
        {
            // object supports IMarshal, check for FreeThreadedMarshaler
            CLSID clsid;
            hr = pIM->GetUnmarshalClass(riid, pUnk, MSHCTX_INPROC, 0,
                                        mshlflags, &clsid);

            if (SUCCEEDED(hr) && IsEqualCLSID(clsid, CLSID_InProcFreeMarshaler))
            {
                // supports FTM, just store it's pointer directly
                pGIPEntry->dwType = ORT_FREETM;
                hr = S_OK;
            }
            else
            {
                // object supports custom Marshalling, marshal it
                pGIPEntry->dwType = ORT_STREAM;
                CXmitRpcStream Stm;
                hr = CoMarshalInterface(&Stm, riid, pUnk,
                                        MSHCTX_INPROC, 0, mshlflags);
                if (SUCCEEDED(hr))
                {
                    Stm.AssignSerializedInterface(&pGIPEntry->u.pIFD);
                }
            }
            pIM->Release();
        }
        else
        {
            // use standard marshaling, but delay marshaling it until the first
            // caller requests to use it. This avoids doing a lot of work if
            // the cookie is never actually used, or if it is used only by the
            // current apartment.
            pGIPEntry->dwType = (mshlflags & MSHLFLAGS_AGILE) ?
                                 ORT_LAZY_AGILE : ORT_LAZY_OBJREF;
            pGIPEntry->mp.mshlflags = mshlflags;
            pGIPEntry->mp.iid       = riid;
        }

        if (SUCCEEDED(hr))
        {
            // Remember the apartment and context it was marshaled in
            pGIPEntry->cUsage   = 0;
            pGIPEntry->hWndApt  = hwndApt;
            pGIPEntry->pContext = GetCurrentContext();
            pGIPEntry->pContext->InternalAddRef();

            // addref and remember the pointer
            pGIPEntry->pUnk = pUnk;
            pUnk->AddRef();
        }
        else
        {
            // Failed. Cleanup and free the entry.
            PrivMemFree(pGIPEntry->u.pobjref);
            pGIPEntry->u.pobjref = NULL;
            pGIPEntry->dwType    = ORT_UNUSED;
            FreeEntry(pGIPEntry);
            dwCookie = 0;
        }
    }

    *pdwCookie = dwCookie;

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "RegisterInterfaceInGlobal: dwCookie:%x hr:%x\n",
               *pdwCookie, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RevokeInterfaceFromGlobal, public
//
//  Synopsis:   Revokes an interface registered for storage in a global.
//
//  Arguments:  [dwCookie] - registration cookie
//
//  History:    18-Mar-97   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//              29-Mar-98   Johnstra    NA support
//
//--------------------------------------------------------------------
STDMETHODIMP CGIPTable::RevokeInterfaceFromGlobal(DWORD dwCookie)
{
    ComDebOut((DEB_MARSHAL,"RevokeInterfaceFromGlobal dwCookie:%x\n",
               dwCookie));
    ASSERT_LOCK_NOT_HELD(_mxs);

    if (!IsApartmentInitialized()) return CO_E_NOTINITIALIZED;

    GIPEntry *pGIPEntry;
    HRESULT hr = GetEntryPtr(dwCookie, &pGIPEntry);
    if (SUCCEEDED(hr))
    {
        BOOL fSameApt = (pGIPEntry->dwAptId == GetCurrentApartmentId());
        if (!fSameApt && !_fInRevokeAll)
        {
            // can only revoke from the same apartment that registered
            // so go switch to that apartment now.
            hr = S_OK;

            // release the entry ptr we acquired since we want another
            // thread to do the revoke and we don't want to prevent that
            // from happening due to our own usage count.
            DWORD dwAptId = pGIPEntry->dwAptId;
            HWND  hWndApt = pGIPEntry->hWndApt;
            ReleaseEntryPtr(pGIPEntry);

            if (dwAptId == MTATID)
            {
                // the revoke needs to happen in the MTA so go do that
                STwoBits sParam;
                sParam._dwCookie = dwCookie;
                hr = gEventCache.Get(&sParam._hEvent);
                if (SUCCEEDED(hr))
                {
                    hr = CacheCreateThread(RevokeFromMTA, &sParam);
                    if (SUCCEEDED(hr))
                    {
                        // use CoWaitForMultipleHandles so we
                        // pump messages while we're waiting for
                        // the worker thread to get done.
                        DWORD dwIndex;
                        DWORD iLoop = 0;

                        //
                        // The loop below exits on one of two conditions:
                        //
                        // 1) an error occurred
                        // 2) our event was signalled
                        //
                        // We explicitly check for the event (WAIT_OBJECT_0) since
                        // we are waiting alertably and it is possible for CWFMH to
                        // return (with a success code) due to an APC being processed.
                        //
                        do
                        {                           
                            hr = CoWaitForMultipleHandles(
                                                COWAIT_ALERTABLE,
                                                INFINITE,
                                                1,
                                                &(sParam._hEvent),
                                                &dwIndex);
                            iLoop++; // counter in case we get stuck here
                        } 
                        while ((hr == RPC_S_CALLPENDING) ||
                               (SUCCEEDED(hr) && (dwIndex != WAIT_OBJECT_0)));

                        if (SUCCEEDED(hr))
                        {
                            Win4Assert(dwIndex == WAIT_OBJECT_0);
                        }
                        else
                        {
                            // Broke out of the loop with a failure of some kind.  Not 
                            // good.  If the RevokeFromMTA thread finishes after this
                            // point, we might give a signalled event back to the cache.
                            // To avoid this, make sure the event is signalled before
                            // returning.
                            (void)WaitForSingleObject(sParam._hEvent, INFINITE);
                        }
                    }
                    gEventCache.Free(sParam._hEvent);
                }
            }
            else if (dwAptId == NTATID)
            {
                // Switch to NA to revoke.
                CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
                hr = gGIPTbl.RevokeInterfaceFromGlobal(dwCookie);
                pSavedCtx = LeaveNTA(pSavedCtx);
                Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
            }
            else if (hWndApt)
            {
                CComApartment *pApt;
                hr = GetApartmentByID(dwAptId, &pApt);
                if (SUCCEEDED(hr))
                {
                    CGIPMessageParam *pMsg = new CGIPMessageParam(dwCookie);
                    if (pMsg)
                    {
                        hr = pApt->QueueMessage(WM_OLE_GIP_REVOKE, pMsg);
                        Win4Assert(SUCCEEDED(hr));
                        if (SUCCEEDED(hr))
                        {
                            // post a message to the real thread to revoke the entry
                            if (!PostMessage(hWndApt, WM_OLE_GIP_REVOKE,
                                             WMSG_MAGIC_VALUE, (LPARAM)((IMessageParam *)pMsg)))
                            {
                                // Clean up reference taken by QueueMessage above.
                                hr = pApt->RemoveMessage(WM_OLE_GIP_REVOKE, pMsg);
                                if (SUCCEEDED(hr))
                                    pMsg->Release();

                                hr = RPC_E_SERVER_DIED;
                            }
                        }
                        
                        pMsg->Release();
                    }
                    else
                        hr = E_OUTOFMEMORY;

                    pApt->Release();
                }
            }

            return hr;
        }

        // OK to Revoke in this apartment. First, make sure no other threads
        // are using this entry. The current thread should be the only thread with
        // a reference on the entry right now.
        if (InterlockedCompareExchange(&pGIPEntry->cUsage, -1, 1) != 1)
        {
            // The entry is busy. Return an error and let the caller retry.
            // Note that this is a bug in the calling app, we just prevent
            // corruption of state, AVs, etc.
            ReleaseEntryPtr(pGIPEntry);
            hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        }
        else
        {
            // The entry was not busy and is now marked with a usage count of -1
            // so no other threads will attempt to do a Get at this time. Go
            // ahead and do the cleanup.

            if (pGIPEntry->pUnkProxy)
            {
                // Release the agile proxy
                Win4Assert(pGIPEntry->dwType == ORT_AGILE);
                pGIPEntry->pUnkProxy->Release();
                pGIPEntry->pUnkProxy = NULL;
            }

            if (pGIPEntry->dwType == ORT_OBJREF      ||
                pGIPEntry->dwType == ORT_LAZY_OBJREF ||
                pGIPEntry->dwType == ORT_AGILE       ||
                pGIPEntry->dwType == ORT_LAZY_AGILE)
            {
                if (pGIPEntry->u.pobjref)
                {
                    // release the marshaled objref
                    hr = ReleaseMarshalObjRef(*(pGIPEntry->u.pobjref));
                    FreeObjRef(*(pGIPEntry->u.pobjref));
                    PrivMemFree(pGIPEntry->u.pobjref);
                    pGIPEntry->u.pobjref = NULL;
                }
            }
            else if (pGIPEntry->dwType == ORT_STREAM)
            {
                if (pGIPEntry->u.pIFD)
                {
                    // release the custom marshaled interface
                    CXmitRpcStream Stm(pGIPEntry->u.pIFD);
                    hr = CoReleaseMarshalData(&Stm);
                    CoTaskMemFree(pGIPEntry->u.pIFD);
                }
            }

            if (fSameApt && IsValidInterface(pGIPEntry->pUnk))
            {
                if (pGIPEntry->pContext)
                {
                    // was registered in a different context so go do the
                    // release in that context.
                    pGIPEntry->pContext->InternalContextCallback(ReleaseCallback, pGIPEntry->pUnk,
                                                         IID_IUnknown, 2 /* Release() */,
                                                         NULL);
                    pGIPEntry->pContext->InternalRelease();
                    pGIPEntry->pContext = NULL;
                }
                else
                {
                    // release the pUnk object
                    pGIPEntry->pUnk->Release();
                }

                pGIPEntry->pUnk = NULL;
            }

            // return the entry to the table
            FreeEntry(pGIPEntry);
            hr = S_OK;
        }
    }

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "RevokeInterfaceFromGlobal: hr:%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     LazyMarshalGIPEntry
//
//  Synopsis:   Does the marshaling for a lazy-marshaled OBJREF
//
//  History:    11-Nov-98   RickHi      Created
//
//--------------------------------------------------------------------
HRESULT CGIPTable::LazyMarshalGIPEntry(DWORD dwCookie)
{
    ComDebOut((DEB_MARSHAL,"LazyMarshalGIPEntry: dwCookie:%x\n", dwCookie));
    ASSERT_LOCK_NOT_HELD(_mxs);

    // get the GIPEntry from the cookie
    GIPEntry *pGIPEntry;
    HRESULT hr = GetEntryPtr(dwCookie, &pGIPEntry);
    if (FAILED(hr))
    {
        // cookie is bad
        return hr;
    }

    if (pGIPEntry->u.pobjref == NULL)
    {
        // allocate space for the OBJREF
        hr = E_OUTOFMEMORY;
        OBJREF *pObjRef = (OBJREF *)PrivMemAlloc(sizeof(OBJREF));

        if (pObjRef)
        {
            DWORD dwNewType = ORT_UNUSED;

            if (pGIPEntry->dwType == ORT_LAZY_AGILE)
            {
                // marshal an agile proxy
                hr = MarshalInternalObjRef(*pObjRef,
                                           pGIPEntry->mp.iid,
                                           pGIPEntry->pUnk,
                                           pGIPEntry->mp.mshlflags,
                                           NULL);
                dwNewType = ORT_AGILE;
            }
            else if (pGIPEntry->dwType == ORT_LAZY_OBJREF)
            {
                // the normal case
                hr = MarshalObjRef(*pObjRef,
                                    pGIPEntry->mp.iid,
                                    pGIPEntry->pUnk,
                                    pGIPEntry->mp.mshlflags,
                                    MSHCTX_INPROC, NULL);
                dwNewType = ORT_OBJREF;
            }
            else
            {
                // should never be anything else, unless a race is occuring,
                // in which case we skip the work below and by the time we
                // get back to the calling context everything should be set
                // up correctly and this error is ignored.
                hr = E_UNEXPECTED;
            }

            if (SUCCEEDED(hr))
            {
                if (InterlockedCompareExchangePointer((void **)&pGIPEntry->u.pobjref,
                                                      pObjRef, NULL) == NULL)
                {
                    // update the type (must be done after the interlocked exchange)
                    pGIPEntry->dwType = dwNewType;
                }
                else
                {
                    // some other thread beat us to it, so just release the
                    // objref we created and continue on using the objref
                    // that is present.
                    ReleaseMarshalObjRef(*pObjRef);
                    FreeObjRef(*pObjRef);
                    PrivMemFree(pObjRef);
                }
            }
            else
            {
                PrivMemFree(pObjRef);
            }
        }
    }
    else
    {
        // already marshalled
        hr = S_OK;
    }

    // release the reference acquired by Get
    ReleaseEntryPtr(pGIPEntry);

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "LazyMarshalGIPEntry: hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   LazyMarshalGIPEntryCallback
//
//  Synopsis:   tells the GIPEntry to marshal the OBJREF
//
//  History:    11-Nov-98   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT __stdcall LazyMarshalGIPEntryCallback(void *cookie)
{
    ComDebOut((DEB_MARSHAL,"LazyMarshalGIPEntryCallback cookie:%x\n", cookie));

    DWORD dwCookie = PtrToUlong(cookie);
    HRESULT hr = gGIPTbl.LazyMarshalGIPEntry(dwCookie);

    ComDebOut((DEB_MARSHAL,"LazyMarshalGIPEntryCallback dwCookie:%x\n",
              dwCookie));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ReleaseCallback
//
//  Synopsis:   calls release in the correct context
//
//  History:    11-Nov-98   MattSmit      Created
//
//--------------------------------------------------------------------
HRESULT __stdcall ReleaseCallback(void *prm)
{
    ((IUnknown *) prm)->Release();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::GetRequestedInterface  private
//
//  Synopsis:   returns the requested interface on the supplied object
//
//  History:    26-Mar-98   GopalK      Created
//
//--------------------------------------------------------------------
HRESULT CGIPTable::GetRequestedInterface(IUnknown *pUnk, REFIID riid, void **ppv)
{
    // Validate the server object
    HRESULT hr = CO_E_OBJNOTCONNECTED;
    if (IsValidInterface(pUnk))
    {
        // object is still valid, get the requested interface
        hr = pUnk->QueryInterface(riid, ppv);
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::GetInterfaceFromGlobal, public
//
//  Synopsis:   returns the marshaled interface associated with the cookie
//
//  Arguments:  [dwCookie] - registration cookie
//              [riid]     - interface iid requested
//              [ppv]      - where to return the interface
//
//  History:    18-Mar-97   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//
//--------------------------------------------------------------------
extern "C" IID IID_IEnterActivityWithNoLock;
BOOL GipBypassEnabled();

STDMETHODIMP CGIPTable::GetInterfaceFromGlobal(DWORD dwCookie,
                                               REFIID riid, void **ppv)
{
    ComDebOut((DEB_MARSHAL,"GetInterfaceFromGlobal dwCookie:%x riid:%I ppv:%x\n",
               dwCookie, &riid, ppv));
    ASSERT_LOCK_NOT_HELD(_mxs);

    *ppv = NULL;

    if (!IsApartmentInitialized()) return CO_E_NOTINITIALIZED;

    GIPEntry *pGIPEntry;
    HRESULT hr = GetEntryPtr(dwCookie, &pGIPEntry);
    if (SUCCEEDED(hr))
    {
        // look for fast-path cases first...

        if ((pGIPEntry->dwType == ORT_FREETM) ||
            (pGIPEntry->pContext == GetCurrentContext()))
        {
            // object is free-threaded or we are already in the
            // context in which it was registered. Just use the
            // interface pointer that is stored there directly.
            hr = GetRequestedInterface(pGIPEntry->pUnk, riid, ppv);
        }
        else if ((pGIPEntry->dwType == ORT_AGILE ||
                  pGIPEntry->dwType == ORT_LAZY_AGILE) &&
                 pGIPEntry->dwAptId == GetCurrentApartmentId())
        {
            // object is agile and we are already in the apartment in
            // which it was registered. Just use the interface pointer
            // that is stored there directly.
            hr = GetRequestedInterface(pGIPEntry->pUnk, riid, ppv);
        }
        else
        {
            // can't use a fast-path this case, we'll need to do
            // some unmarshaling and possibly some lazy marshaling...

            hr = E_UNEXPECTED;

            if (pGIPEntry->dwType == ORT_LAZY_AGILE ||
                pGIPEntry->dwType == ORT_LAZY_OBJREF)
            {
                // the server object has not yet been marshaled. call back to
                // the server apartment/context to really do the marshaling.

                if (GipBypassEnabled())
                {
                    pGIPEntry->pContext->InternalContextCallback(LazyMarshalGIPEntryCallback,
                                                        (void *)LongToPtr(dwCookie),
                                                        IID_IEnterActivityWithNoLock, 2 /*Release*/,
                                                        NULL);
                }
                else
                {
                    pGIPEntry->pContext->InternalContextCallback(LazyMarshalGIPEntryCallback,
                                                        (void *)LongToPtr(dwCookie),
                                                        IID_IUnknown, 2 /*Release*/,
                                                        NULL);
                }

                // ignore the return code, since it is possible to return an
                // error when a race happens. We will still unmarshal correctly
                // below if we are able to.
            }

            if (pGIPEntry->dwType == ORT_AGILE)
            {
                // it's an agile reference
                Win4Assert(pGIPEntry->dwAptId != GetCurrentApartmentId()); // handled above

                if (pGIPEntry->pUnkProxy == NULL)
                {
                    // an agile proxy has not yet been created, do it now
                    IUnknown *pUnkTemp = NULL;
                    hr = UnmarshalInternalObjRef(*(pGIPEntry->u.pobjref),
                                                (void **) &pUnkTemp);
                    if (SUCCEEDED(hr))
                    {
                        // someone else might have unmarshaled at the same time,
                        // check for duplicate
                        if (InterlockedCompareExchangePointer(
                                  (void **)&pGIPEntry->pUnkProxy,
                                   pUnkTemp, NULL) != NULL)
                        {
                            // duplicate, Release the ref we created
                            pUnkTemp->Release();
                        }
                    }
                }

                if (pGIPEntry->pUnkProxy != NULL)
                {
                    hr = GetRequestedInterface(pGIPEntry->pUnkProxy, riid, ppv);
                }
            }
            else if (pGIPEntry->dwType == ORT_OBJREF)
            {
                // entry is an OBJREF, just unmarshal it
                hr = UnmarshalObjRef(*(pGIPEntry->u.pobjref), ppv, GipBypassEnabled());
                if (SUCCEEDED(hr) && !InlineIsEqualGUID(riid, pGIPEntry->u.pobjref->iid))
                {
                    // caller is asking for a different interface than was marshaled.
                    // Query for it now.
                    IUnknown *pUnk = (IUnknown *) *ppv;
                    *ppv = NULL;
                    hr = pUnk->QueryInterface(riid, ppv);
                    pUnk->Release();
                }
            }
            else if (pGIPEntry->dwType == ORT_STREAM)
            {
                // entry is ptr to stream of custom marshal data, unmarshal it
                CXmitRpcStream Stm(pGIPEntry->u.pIFD);
                hr = CoUnmarshalInterface(&Stm, riid, ppv);
            }
        }

        // Release the reference acquired in Get above
        ReleaseEntryPtr(pGIPEntry);
    }

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "GetInterfaceFromGlobal: hr:%x pv:%x\n", hr, *ppv));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CGIPTableCF_CreateInstance, public
//
//  History:    18-Mar-97   Rickhi      Created
//
//  Notes:      Class Factory CreateInstance function. Always returns
//              the one global instance of the GIP table.
//
//--------------------------------------------------------------------
HRESULT CGIPTableCF_CreateInstance(IUnknown *pUnkOuter,
                                   REFIID riid, void **ppv)
{
    Win4Assert(pUnkOuter == NULL);
    return gGIPTbl.QueryInterface(riid, ppv);
}

//+-------------------------------------------------------------------
//
//  Function:   CGIPTableApartmentUninitialize, public
//
//  History:    09-Oct-97   Rickhi      Created
//
//--------------------------------------------------------------------
void GIPTableApartmentUninitialize()
{
    gGIPTbl.ApartmentCleanup();
}

//+-------------------------------------------------------------------
//
//  Function:   CGIPTableProcessUninitialize, public
//
//  History:    09-Oct-97   Rickhi      Created
//
//--------------------------------------------------------------------
void GIPTableProcessUninitialize()
{
    gGIPTbl.RevokeAllEntries();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\globalopt.cxx ===
//+-------------------------------------------------------------------
//
//  File:       globalopt.cxx
//
//  Contents:   Implements classes for setting/querying global ole32 options
//
//  Classes:    CGlobalOptions
//
//  History:    06-13-02   sajia      Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <globalopt.h>    // interface defn
#include "globalopt.hxx"  // class defn
#include "security.hxx"   // for gGotSecurityData
#include "channelb.hxx"   // for gfCatchServerExceptions


STDMETHODIMP CGlobalOptions::QueryInterface(REFIID riid, void** ppv)
{
    if (!ppv)
        return E_POINTER;
    
    *ppv = NULL;
    
    if (riid == IID_IUnknown ||
        riid == IID_IGlobalOptions)
    {
        *ppv = static_cast<IGlobalOptions*>(this);
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CGlobalOptions::AddRef()
{
    return InterlockedIncrement((PLONG)&_lRefs);
}

STDMETHODIMP_(ULONG) CGlobalOptions::Release()
{
    ULONG lRefs = InterlockedDecrement((PLONG)&_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }
    return lRefs;
}

CGlobalOptions::CGlobalOptions() :
    _lRefs(1)
{
}

CGlobalOptions::~CGlobalOptions()
{
    Win4Assert(_lRefs == 0);

}

//+-------------------------------------------------------------------
//
// Member:     Set
//
// Synopsis:   Set values for various global ole32 options
//
// Arguments:
//   dwProperty - [in] A single DWORD value from the COMGLB_xxxx enumeration
//   dwValue -    [in] A single DWORD specifying the value for the
//                property being set.
//
// Returns:    S_OK, E_INVALIDARG, E_FAIL, CO_E_NOTINITIALIZED
//
//
// History:    06-12-02    sajia  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CGlobalOptions::Set(DWORD      dwProperty,
                               ULONG_PTR  dwValue)
{
    ComDebOut((DEB_TRACE, "CGlobalOptions::Set dwProperty = 0x%x, dwValue = 0x%p\n",
               dwProperty, dwValue));

    // Fail if OLE is not initialized or TLS cannot be allocated.
    if (!IsApartmentInitialized())
        return CO_E_NOTINITIALIZED;
    
    if (!gGotSecurityData)
    {
       ComDebOut((DEB_TRACE, "Must be called after CoInitializeSecurity\n"));
       return E_FAIL;
    }
    HRESULT hr = S_OK;
    // parameter checking
    if (dwProperty != COMGLB_EXCEPTION_HANDLING)
    {
        hr = E_INVALIDARG;
    }
    else
    {
       // Implements COMGLB_EXCEPTION_HANDLING
       if (COMGLB_EXCEPTION_HANDLE == dwValue) 
       {
          gfCatchServerExceptions = 1;
       }
       else if (COMGLB_EXCEPTION_DONOT_HANDLE == dwValue) 
       {
          gfCatchServerExceptions = 0;
       }
       else
          hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
// Member:     Query
//
// Synopsis:   Query values for various global ole32 options
//
// Arguments:
//   dwProperty - [in] A single DWORD value from the COMGLB_xxxx enumeration
//   dwValue -    [out] A ptr specifying the value for the
//                property being queried.
//
// Returns:    S_OK, E_INVALIDARG
//
//
// History:    06-12-02    sajia  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CGlobalOptions::Query(DWORD dwProperty,
                                 ULONG_PTR * pdwValue)
{
    ComDebOut((DEB_TRACE, "CGlobalOptions::Query dwProperty = 0x%x, pdwValue = 0x%p\n",
               dwProperty, pdwValue));

    HRESULT hr = S_OK;
    // parameter checking

    if (!(IsValidPtrOut(pdwValue, sizeof(ULONG_PTR))) ||
        (dwProperty != COMGLB_EXCEPTION_HANDLING))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // For COMGLB_EXCEPTION_HANDLING
       if (COMGLB_EXCEPTION_HANDLING == dwProperty) 
       {
          if (gfCatchServerExceptions)
          {
             *pdwValue = COMGLB_EXCEPTION_HANDLE;
          }
          else
          {
             *pdwValue = COMGLB_EXCEPTION_DONOT_HANDLE;
          }
       }

    }
    return hr;

}

 
// Function used for creating objects
HRESULT CGlobalOptionsCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(!pUnkOuter);

    if (!ppv)
        return E_POINTER;
    
    *ppv = NULL;
    
    CGlobalOptions* pLocal = new CGlobalOptions();
    if (!pLocal)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pLocal->QueryInterface(riid, ppv);

    pLocal->Release();

    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\hash.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       hash.cxx
//
//  Contents:   class for maintaining a hash table.
//
//  Classes:    CUUIDHashTable
//
//---------------------------------------------------------------------------
#include <ole2int.h>
#include <hash.hxx>         // CUUIDHashTable
#include <locks.hxx>        // ASSERT_LOCK_HELD_IF_NECESSARY
#include <service.hxx>      // SASIZE


//+------------------------------------------------------------------------
// Type definitions

typedef struct
{
    const IPID      *pIpid;
    SECURITYBINDING *pName;
} SNameKey;

//+------------------------------------------------------------------------
//
//  Secure references hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain SRFBuckets[23] =
{
    {&SRFBuckets[0],  &SRFBuckets[0]},
    {&SRFBuckets[1],  &SRFBuckets[1]},
    {&SRFBuckets[2],  &SRFBuckets[2]},
    {&SRFBuckets[3],  &SRFBuckets[3]},
    {&SRFBuckets[4],  &SRFBuckets[4]},
    {&SRFBuckets[5],  &SRFBuckets[5]},
    {&SRFBuckets[6],  &SRFBuckets[6]},
    {&SRFBuckets[7],  &SRFBuckets[7]},
    {&SRFBuckets[8],  &SRFBuckets[8]},
    {&SRFBuckets[9],  &SRFBuckets[9]},
    {&SRFBuckets[10], &SRFBuckets[10]},
    {&SRFBuckets[11], &SRFBuckets[11]},
    {&SRFBuckets[12], &SRFBuckets[12]},
    {&SRFBuckets[13], &SRFBuckets[13]},
    {&SRFBuckets[14], &SRFBuckets[14]},
    {&SRFBuckets[15], &SRFBuckets[15]},
    {&SRFBuckets[16], &SRFBuckets[16]},
    {&SRFBuckets[17], &SRFBuckets[17]},
    {&SRFBuckets[18], &SRFBuckets[18]},
    {&SRFBuckets[19], &SRFBuckets[19]},
    {&SRFBuckets[20], &SRFBuckets[20]},
    {&SRFBuckets[21], &SRFBuckets[21]},
    {&SRFBuckets[22], &SRFBuckets[22]}
};

CNameHashTable gSRFTbl;


//---------------------------------------------------------------------------
//
//  Function:   DummyCleanup
//
//  Synopsis:   Callback for CHashTable::Cleanup that does nothing.
//
//---------------------------------------------------------------------------
void DummyCleanup( SHashChain *pIgnore )
{
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::EnumAndRemove
//
//  Synopsis:   Enumerates the hash table and removes the elements identified
//              by the PFNREMOVE function.
//
//  History:    14-May-97   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL CHashTable::EnumAndRemove(PFNREMOVE *pfnRemove, void *pvData,
                               ULONG *pulSize, void **ppNodes)
{
    Win4Assert(pfnRemove);
    AssertHashLocked();

    SHashChain *pPrev, *pNext;
    ULONG ulCount = 0;
    BOOL fDone = TRUE;

    for (ULONG iHash=0; iHash < NUM_HASH_BUCKETS; iHash++)
    {
        // Obtain bucket head
        SHashChain *pNode  = _buckets[iHash].pNext;

        // Enumerate bucket
        while (pNode != &_buckets[iHash])
        {
            // Save the previous and next nodes
            pPrev = pNode->pPrev;
            pNext = pNode->pNext;

            // Invoke the supplied function
            if((pfnRemove)(pNode, pvData))
            {
                pPrev->pNext = pNext;
                pNext->pPrev = pPrev;
                if(ppNodes)
                {
                    ppNodes[ulCount] = pNode;
                    ++ulCount;
                    if(ulCount == *pulSize)
                    {
                        fDone = FALSE;
                        goto End;
                    }
                }
            }

            // Skip to next node
            pNode = pNext;
        }
    }

End:
    if(pulSize)
        *pulSize = ulCount;

    return(fDone);
}


//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Cleanup
//
//  Synopsis:   Cleans up the hash table by deleteing leftover entries.
//
//---------------------------------------------------------------------------
void CHashTable::Cleanup(PFNCLEANUP *pfnCleanup)
{
    Win4Assert(pfnCleanup);
    AssertHashLocked();

    for (ULONG iHash=0; iHash < NUM_HASH_BUCKETS; iHash++)
    {
        // the ptrs could be NULL if the hash table was never initialized.

        while (_buckets[iHash].pNext != NULL &&
               _buckets[iHash].pNext != &_buckets[iHash])
        {
            // remove the entry from the list and call it's cleanup function
            SHashChain *pNode = _buckets[iHash].pNext;

            Remove(pNode);
            (pfnCleanup)(pNode);
        }
    }

#if DBG==1
    // Verify that the hash table is empty or uninitialized.
    for (iHash = 0; iHash < NUM_HASH_BUCKETS; iHash++)
    {
        Win4Assert( _buckets[iHash].pNext == &_buckets[iHash] ||
                    _buckets[iHash].pNext == NULL);
        Win4Assert( _buckets[iHash].pPrev == &_buckets[iHash] ||
                    _buckets[iHash].pPrev == NULL);
    }
#endif
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Lookup
//
//  Synopsis:   Searches for a given key in the hash table.
//
//  Note:       iHash is between 0 and -1, not 0 and NUM_HASH_BUCKETS
//
//---------------------------------------------------------------------------
SHashChain *CHashTable::Lookup(DWORD dwHash, const void *k)
{
    AssertHashLocked();

    // compute the index to the hash chain (it's the hash value of the key
    // mod the number of buckets in the hash table)

    DWORD iHash = dwHash % NUM_HASH_BUCKETS;

    SHashChain *pNode  = _buckets[iHash].pNext;

    // Search the destination bucket for the key.
    while (pNode != &_buckets[iHash])
    {
        if (Compare( k, pNode, dwHash ))
            return pNode;

        pNode = pNode->pNext;
    }

    return NULL;
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Add
//
//  Synopsis:   Adds an element to the hash table. The Cleanup method will
//              call a Cleanup function that can be used to delete the
//              element.
//
//  Note:       iHash is between 0 and -1, not 0 and NUM_HASH_BUCKETS
//
//---------------------------------------------------------------------------
void CHashTable::Add(DWORD dwHash, SHashChain *pNode)
{
    AssertHashLocked();

    // Add the node to the bucket chain.
    SHashChain *pHead   = &_buckets[dwHash % NUM_HASH_BUCKETS];
    SHashChain *pNew    = pNode;

    pNew->pPrev         = pHead;
    pHead->pNext->pPrev = pNew;
    pNew->pNext         = pHead->pNext;
    pHead->pNext        = pNew;

    // count one more entry
    _cCurEntries++;
    if (_cCurEntries > _cMaxEntries)
        _cMaxEntries = _cCurEntries;
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Remove
//
//  Synopsis:   Removes an element from the hash table.
//
//---------------------------------------------------------------------------
void CHashTable::Remove(SHashChain *pNode)
{
    AssertHashLocked();

    pNode->pPrev->pNext = pNode->pNext;
    pNode->pNext->pPrev = pNode->pPrev;

    // count one less entry
    _cCurEntries--;
}

#if LOCK_PERF==1
//---------------------------------------------------------------------------
//
//  Function:   OutputHashEntryData, public
//
//  Synopsis:   Dumps the statistics gathered by the various hash tables
//              in the system.
//
//---------------------------------------------------------------------------
void OutputHashEntryData(char *pszName, CHashTable &HashTbl)
{
    char szHashPerfBuf[256];
    wsprintfA(szHashPerfBuf,"\tHashTable:%.220s \tMaxEntryCount:%7u\n",
              pszName, HashTbl.GetMaxEntryCount());
    OutputDebugStringA(szHashPerfBuf);
}
#endif // LOCK_PERF

//---------------------------------------------------------------------------
//
//  Method:     CDWORDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CDWORDHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return PtrToUlong(k) == ((SDWORDHashNode *)pNode)->key;
}

//---------------------------------------------------------------------------
//
//  Method:     CPointerHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CPointerHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return k == ((SPointerHashNode *)pNode)->key;
}

//---------------------------------------------------------------------------
//
//  Method:     CUUIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CUUIDHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return InlineIsEqualGUID(*(const UUID *)k,
                            ((SUUIDHashNode *)pNode)->key);
}

//---------------------------------------------------------------------------
//
//  Method:     CMultiGUIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//              k is a pointer to the key, SHashChain is the node to compare
//              against.
//
//---------------------------------------------------------------------------
BOOL CMultiGUIDHashTable::Compare(const void *k, SHashChain *pHashNode, DWORD dwHash)
{
    SMultiGUIDKey      *pKey = (SMultiGUIDKey *)k;
    SMultiGUIDHashNode *pNode = (SMultiGUIDHashNode *)pHashNode;

    if (pKey->cGUID != pNode->key.cGUID)
    {
        return FALSE;
    }
     
    for (int i = 0; i < pKey->cGUID; i++)
    {
        if (!InlineIsEqualGUID(pKey->aGUID[i], pNode->key.aGUID[i]))
            return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
//
//  Method:     CStringHashTable::Hash
//
//  Synopsis:   Computes the hash value for a given key.
//
//---------------------------------------------------------------------------
DWORD CStringHashTable::Hash(DUALSTRINGARRAY *psaKey)
{
    DWORD dwHash  = 0;
    DWORD *pdw    = (DWORD *) &psaKey->aStringArray[0];

    for (USHORT i=0; i< (psaKey->wNumEntries/2); i++)
    {
        dwHash = (dwHash << 8) ^ *pdw++;
    }

    return dwHash;
}

//---------------------------------------------------------------------------
//
//  Method:     CStringHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CStringHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    SStringHashNode       *pSNode = (SStringHashNode *) pNode;
    const DUALSTRINGARRAY *psaKey = (const DUALSTRINGARRAY *) k;

    if (dwHash == pSNode->dwHash)
    {
        // a quick compare of the hash values found a match, now do
        // a full compare of the key (Note: if the sizes of the two
        // Keys are different, we exit the memcmp on the first dword,
        // so we dont have to worry about walking off the endo of one
        // of the Keys during the memcmp).

        return !memcmp(psaKey, pSNode->psaKey, SASIZE(psaKey->wNumEntries));
    }
    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::Cleanup
//
//  Synopsis:   Call the base cleanup routine with a dummy callback function
//
//---------------------------------------------------------------------------
void CNameHashTable::Cleanup()
{
    LOCK(gIPIDLock);
    CHashTable::Cleanup( DummyCleanup );
    UNLOCK(gIPIDLock);
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::Hash
//
//  Synopsis:   Computes the hash value for a given key.
//
//---------------------------------------------------------------------------
DWORD CNameHashTable::Hash( REFIPID ipid, SECURITYBINDING *pName )
{
    DWORD  dwHash  = 0;
    DWORD *pdw     = (DWORD *) &ipid;
    DWORD  dwLen   = lstrlenW( (WCHAR *) pName ) >> 1;
    ULONG  i;

    // First hash the IPID.
    for (i=0; i < 4; i++)
    {
        dwHash = (dwHash << 8) ^ *pdw++;
    }

    // Then hash the name.
    pdw = (DWORD *) pName;
    for (i=0; i < dwLen; i++)
    {
        dwHash = (dwHash << 8) ^ *pdw++;
    }

    return dwHash;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CNameHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    SNameHashNode  *pNNode = (SNameHashNode *) pNode;
    const SNameKey *pKey   = (const SNameKey *) k;

    if (dwHash == pNNode->dwHash)
    {
        // a quick compare of the hash values found a match, now do
        // a full compare of the key
        if (*pKey->pIpid == pNNode->ipid)
            return !lstrcmpW( (WCHAR *) pKey->pName, (WCHAR *) &pNNode->sName );
        else
            return FALSE;
    }

    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::IncRef
//
//  Synopsis:   Find or create an entry for the specified name.  Increment
//              its reference count.
//
//---------------------------------------------------------------------------
HRESULT CNameHashTable::IncRef( ULONG cRefs, REFIPID ipid,
                                SECURITYBINDING *pName )
{
    AssertHashLocked();

    HRESULT  hr  = S_OK;

    // See if there is already a node in the table.
    DWORD dwHash = Hash( ipid, pName );
    SNameKey  key;
    key.pIpid = &ipid;
    key.pName = pName;
    SNameHashNode *pNode = (SNameHashNode *) Lookup( dwHash, &key );

    // If not, create one.
    if (pNode == NULL)
    {
        ULONG lLen = lstrlenW( (WCHAR *) pName );
        pNode = (SNameHashNode *) PrivMemAlloc( sizeof(SNameHashNode) +
                                                lLen*sizeof(WCHAR) );
        if (pNode != NULL)
        {
            pNode->cRef   = 0;
            pNode->dwHash = dwHash;
            pNode->ipid   = ipid;
            memcpy( &pNode->sName, pName, (lLen + 1) * sizeof(WCHAR) );
            Add( dwHash, &pNode->chain );
        }
        else
            hr = E_OUTOFMEMORY;
    }

    // Increment the reference count on the node.
    if (pNode != NULL)
        pNode->cRef += cRefs;

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::DecRef
//
//  Synopsis:   Decrement references for the specified name.  Do not decrement
//              more references then exist.  Return the actual decrement count.
//
//---------------------------------------------------------------------------
ULONG CNameHashTable::DecRef( ULONG cRefs, REFIPID ipid,
                              SECURITYBINDING *pName )
{
    AssertHashLocked();

    // Lookup the name.
    DWORD          dwHash = Hash( ipid, pName );
    SNameKey       key;
    key.pIpid = &ipid;
    key.pName = pName;
    SNameHashNode *pNode = (SNameHashNode *) Lookup( dwHash, &key );

    if (pNode != NULL)
    {
        if (pNode->cRef < cRefs)
            cRefs = pNode->cRef;

        pNode->cRef -= cRefs;
        if (pNode->cRef == 0)
        {
            Remove( &pNode->chain );
            PrivMemFree( pNode );
        }
    }
    else
        cRefs = 0;

    return cRefs;
}

//---------------------------------------------------------------------------
//
//  Method:     CExtHashTable::Hash
//
//  Synopsis:   Computes the hash value for a given key.
//
//---------------------------------------------------------------------------
DWORD CExtHashTable::Hash( LPCWSTR pwszExt )
{
    DWORD  dwHash  = 0;
    WORD   *pw     = (WORD *) pwszExt;
    DWORD  dwLen   = lstrlenW( pwszExt );
    ULONG  i;

    // Hash the name.
    for (i=0; i < dwLen; i++)
    {
        dwHash = (dwHash << 8) ^ *pw++;
    }

    return dwHash;
}

//---------------------------------------------------------------------------
//
//  Method:     CExtHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CExtHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return !lstrcmpW((LPCWSTR)k, ((SExtHashNode *)pNode)->pwszExt);
}

//---------------------------------------------------------------------------
//
//  Method:     CMIPIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CMIPIDHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    MIPID *p1 = (MIPID *)k;
    MIPID *p2 = (MIPID *)&((SMIPIDHashNode *)pNode)->mipid;
    return (p1->mid == p2->mid && p1->ipid == p2->ipid && p1->dwApt == p2->dwApt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\events.cxx ===
//+-------------------------------------------------------------------
//
//  File:       events.cxx
//
//  Contents:   Vista events and related functions
//
//  History:    26-Sep-97  RongC  Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <scm.h>
#include <ipidtbl.hxx>
#include <marshal.hxx>
#include <events.hxx>
#include <vsevfire.h>

// TRICK:
// Under the treat as key, we have the forwarding CLSID and the switch
// to enable/disable event logging.
// When the apps create IEC (in-proc part of the event logging monitor),
// they use CLSID_VSA_IEC as class ID, and the
// IEC class factory uses CLSID_VSA_IEC, too.  We, ole32, intercept
// the CoCreateInstance() and give apps a wrapper object of IEC.
// As the real LEC (the event logging monitor of the local machine) starts
// up, it will signal a named event, created in dcomss\warpper\start.cxx.
// As soon as we see the signal, we are going to create the real IEC
// in the app process and forwarding all calls from the wrapper to IEC.
// To avoid dead loop on create IEC (as we use CoCreateInstance() to create
// IEC also), we use a different CLSID, namely CLSID_VSA_IEC_TREATAS.
//
extern const CLSID CLSID_VSA_IEC_TREATAS =
    {0x6C736DB0,0xBD94,0x11D0,{0x8A,0x23,0x00,0xAA,0x00,0xB5,0x8E,0x10}};


// Event IDs are just IDs, so we pick the ones we are familiar with.
// The advantages are (1) we can easily tell the messages are from us;
// (2) same some space when re-using the old GUIDs.
//
const GUID GUID_ComEventLogSession =
    {0x95734d90,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClassRegistration =
    {0x95734d91,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClassRevokation =
    {0x95734d92,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClientCall =
    {0x95734d93,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClientReturn =
    {0x95734d94,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComStubEnter =
    {0x95734d95,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComStubLeave =
    {0x95734d96,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComStubException =
    {0x95734d97,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComMarshal =
    {0x95734d98,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComDisconnectMarshal =
    {0x95734d99,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComUnmarshal =
    {0x95734d9a,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComDisconnectUnmarshal =
    {0x95734d9b,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};


// Predefine some event Keys and Types to speed things up.
//
static DWORD ClsTypes[3] = {
    (DWORD) cVSAParameterValueGUID,
    (DWORD) cVSAParameterValueDWORD,
    (DWORD) cVSAParameterValueDWORD
};

static ULONG_PTR ClsKeys[3] = {
    (ULONG_PTR) cVSAStandardParameterSourceHandle,
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) cVSAStandardParameterReturnValue
};

static DWORD RpcTypes[6] = {
    (DWORD) cVSAParameterValueGUID,
    (DWORD) (cVSAParameterValueGUID | cVSAParameterKeyString),
    (DWORD) cVSAParameterValueDWORD,
    (DWORD) (cVSAParameterValueGUID | cVSAParameterKeyString),
    (DWORD) (cVSAParameterValueDWORD | cVSAParameterKeyString),
    (DWORD) cVSAParameterValueDWORD
};

static LPCOLESTR pApartmentID   = L"MOXID";
static LPCOLESTR pInterfaceID   = L"IID";
static LPCOLESTR pMethodNumber  = L"Method#";
static LPCOLESTR pBinding       = L"Binding";

// Used by LogEventClientCall(), LogEventClientReturn(),
// LogEventStubEnter(), LogEventStubLeave(), LogEventStubException()
//
static ULONG_PTR RpcKeys[6] = {
    (ULONG_PTR) cVSAStandardParameterTargetHandle,
    (ULONG_PTR) pApartmentID,
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) pInterfaceID,
    (ULONG_PTR) pMethodNumber,
    (ULONG_PTR) cVSAStandardParameterReturnValue
};

// Used by LogEventMarshal() and LogEventUnmarshal()
//
static ULONG_PTR MrsKeys[5] = {
    (ULONG_PTR) cVSAStandardParameterSourceHandle,
    (ULONG_PTR) pApartmentID,
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) pInterfaceID,
    (ULONG_PTR) pBinding
};

// Used by LogEventDisconnect()
//
static ULONG_PTR DisKeys[2] = {
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) pBinding
};


// Global vars
//
static HANDLE g_hEventLogger = NULL;    // Win32 NamedEvent to sync with logger
static ISystemDebugEventFire * g_pEventFire = NULL; // The instance for ole32



//+-------------------------------------------------------------------
//
//  Class:      CDebugEventFire
//
//  Synopsis:   The wrapper class for event logging object (IEC)
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
class CDebugEventFire : public ISystemDebugEventFire
{
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppv);
    ULONG   STDMETHODCALLTYPE AddRef();
    ULONG   STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE BeginSession(
        /* [in] */ REFGUID guidSourceID,
        /* [in] */ LPCOLESTR strSessionName);

    HRESULT STDMETHODCALLTYPE EndSession( void);

    HRESULT STDMETHODCALLTYPE IsActive( void);

    HRESULT STDMETHODCALLTYPE FireEvent(
        /* [in] */ REFGUID guidEvent,
        /* [in] */ int nEntries,
        /* [size_is][in] */ PULONG_PTR rgKeys,
        /* [size_is][in] */ PULONG_PTR rgValues,
        /* [size_is][in] */ LPDWORD rgTypes,
        /* [in] */ DWORD dwTimeLow,
        /* [in] */ LONG dwTimeHigh,
        /* [in] */ VSAEventFlags dwFlags);

    HRESULT Initialize();
    void Cleanup();

    virtual void _CreateLogger();
    virtual void _DestroyLogger();

    HRESULT GetEventLogger(ISystemDebugEventFire **);

    void* operator new(size_t size)         { return(PrivMemAlloc(size)); }
    void  operator delete(void * pv)        { PrivMemFree(pv); }

protected:
    friend static void _CreateLoggerHelper(CDebugEventFire *);

    unsigned long _cRef;                    // ref count
    CRITICAL_SECTION _csEventFire;          // for thread safety
    BOOL _fLogDisabled;                     // disable the obj
    GUID _guidSession;                      // session id
    LPOLESTR _strSessionName;               // session name
    ISystemDebugEventFire * _pEventFire;    // the real IEC, if it's not NULL
    IUnknown * _punkFTM;
};


//+-------------------------------------------------------------------
//
//  Class:      COle32DebugEventFire
//
//  Synopsis:   The wrapper class of IEC that lives in OLE32.
//              There should be only one instance of this.
//              We could make it a global variable, I suppose.
//              The whole reason we need this is that we can't
//              CoCreateInstance on demand deep down in the channel
//              code as the IEC will use DCOM to create LEC.
//              That is, we must create/destroy IEC differently from
//              what we usually do in the app layer.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
class COle32DebugEventFire : public CDebugEventFire
{
public:
    virtual void _CreateLogger();
    virtual void _DestroyLogger();
};


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::Initialize()
//
//  Synopsis:   Initialize the wrapper for IEC.  Didn't define it as
//              constructor because, it's possible that we will use
//              CDebugEventFire as global or static var sometimes.
//              We don't want to incur early init over head or
//              late init threading problems.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFire::Initialize()
{
    NTSTATUS status;

    _cRef = 0;
    _strSessionName = NULL;
    _pEventFire = NULL;
    _fLogDisabled = FALSE;
    _punkFTM = NULL;

    status = RtlInitializeCriticalSection(&_csEventFire);
    return NT_SUCCESS(status) ? S_OK : E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::Cleanup()
//
//  Synopsis:   The opposite of init.  Destruction are done differently for
//              app and OLE32 IEC, that is, one uses DCOM and one does not.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void CDebugEventFire::Cleanup()
{
    EnterCriticalSection(&_csEventFire);

    if (_strSessionName != NULL)
    {
        PrivMemFree(_strSessionName);
        _strSessionName = NULL;
    }

    if (_punkFTM != NULL)
    {
        _punkFTM->Release();
    }

    _DestroyLogger();

    LeaveCriticalSection(&_csEventFire);
    DeleteCriticalSection(&_csEventFire);
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::_DestroyLogger()
//
//  Synopsis:   The normal version for applications
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void CDebugEventFire::_DestroyLogger()
{
    // holding the lock already

    if (_pEventFire != NULL)
    {
        _pEventFire->Release();
        _pEventFire = NULL;
    }
}


//+-------------------------------------------------------------------
//
//  Member:     COle32DebugEventFire::_DestroyLogger()
//
//  Synopsis:   The OLE32 version for DCOM
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void COle32DebugEventFire::_DestroyLogger()
{
    // holding the lock already

    if (_pEventFire != NULL)
    {
        ISystemDebugEventShutdown * pShutdown;
        HRESULT hr;
        hr = _pEventFire->QueryInterface(
                        IID_ISystemDebugEventShutdown, (void**)&pShutdown);
        if (SUCCEEDED(hr))
        {
            pShutdown->Shutdown();
            pShutdown->Release();
        }
        _pEventFire->Release();
        _pEventFire = NULL;
    }
}


//+-------------------------------------------------------------------
//
//  Function:   _CreateLoggerHelper (private)
//
//  Synopsis:   Create the real IEC and forward the begin session call
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
static void _CreateLoggerHelper(CDebugEventFire * pThis)
{
    // CoCreateInstance() and ISystemDebugEventFire::BeginSession() below
    // might make RPC calls, that is, recursions could happen.

    // Create event logging monitor if possible

    // We create a wrapper for Vista IEC object for everyone
    // CoCreateinstance() with CLSID_VSA_IEC whether Vista is
    // on the system or not.  When the Vista LEC is ready,
    // we must forward the calls by creating a real IEC.
    // CLSID_VSA_IEC_TREATAS is the class ID we use internally.
    //
    ISystemDebugEventFire * pEventFire;
    HRESULT hr = CoCreateInstance(CLSID_VSA_IEC_TREATAS, NULL,
                                  (CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD),
                                  IID_ISystemDebugEventFire,
                                  (void**) &pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->BeginSession(
                            pThis->_guidSession, pThis->_strSessionName);
        if (SUCCEEDED(hr))
        {
            pThis->_pEventFire = pEventFire;    // Make it public
            pThis->_fLogDisabled = FALSE;       // Enable the event logging
        }
    }

    if (FAILED(hr))                             // Fail and we never come back
    {
        if (pEventFire != NULL)                 // BeginSession() failed
        {
            pEventFire->Release();
            pThis->_fLogDisabled = TRUE;        // Disable this logger
        }
        else                                    // CoCreateInstance failed
        {
            // Disable all subsequent even logging activities
            CloseHandle(g_hEventLogger);
            g_hEventLogger = NULL;
        }
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::_CreateLogger()
//
//  Synopsis:   Create the real IEC the normal way
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void CDebugEventFire::_CreateLogger()
{
    HRESULT hr;
    COleTls tls(hr);    // Make sure TLS is initialized on this thread
    if (FAILED(hr))
        return;

    // App may try to create Vista LEC, so we must prevent OLE32.dll
    // from creating its LEC for now, or we might deadlock
    //
    tls->dwFlags |= OLETLS_DISABLE_EVENTLOGGER; // Prevent recursion

    // holding the lock already
    _CreateLoggerHelper(this);

    tls->dwFlags &= ~OLETLS_DISABLE_EVENTLOGGER;
}


//+-------------------------------------------------------------------
//
//  Function:   _CreateLoggerWorker (private)
//
//  Synopsis:   Worker thread routine to create the real IEC
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
static
DWORD WINAPI _CreateLoggerWorker(LPVOID pv)
{
    HRESULT hr;
    COleTls tls(hr);    // Make sure TLS is initialized on this thread
    if (FAILED(hr))
        return 0;

    // We set this per thread flag so we know not to enter here again.
    // The code will dead lock on trying to get the wrapper's critical
    // section without this flag.  We could use _fLogDisabled for
    // same reason, but somehow it was not reliable (mmm...).
    // As we need to test for 16 bit using Tls anyway, one more bit
    // does not cost much.  So do it at least for now.
    //
    tls->dwFlags |= OLETLS_DISABLE_EVENTLOGGER; // Prevent recursion

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(hr))
    {
        _CreateLoggerHelper((CDebugEventFire *) pv);

        Win4Assert(tls->dwFlags & OLETLS_DISABLE_EVENTLOGGER);
        CoUninitialize();
    }

    tls->dwFlags &= ~OLETLS_DISABLE_EVENTLOGGER;
    return 0;
}


//+-------------------------------------------------------------------
//
//  Member:     COle32DebugEventFire::_CreateLogger()
//
//  Synopsis:   Create a thread to create the real IEC
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void COle32DebugEventFire::_CreateLogger()
{
    // holding the lock already
    _fLogDisabled = TRUE;           // Prevent new thread re-enter here

    DWORD dwThreadId;
    HANDLE hThread = CreateThread(
                        NULL, 0, _CreateLoggerWorker, this, 0, &dwThreadId);
    if (hThread)
    {
        // Wait for the worker thread to finish.
        // We might not want to wait in the future for efficiency.
        // In that case, we need to revisit the threading issues.
        // For now, this thread hangs, and the worker modifies the wrapper.
        //
        WaitForSingleObject(hThread, 7000);  // 7 seconds
        CloseHandle(hThread);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::GetEventLogger
//
//  Synopsis:   Create the real event logger on demand if LEC has signaled.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT
CDebugEventFire::GetEventLogger(ISystemDebugEventFire ** ppEventFire)
{
    if (g_hEventLogger == NULL || WaitForSingleObject(g_hEventLogger, 0) != WAIT_OBJECT_0)
    {
        // Logger event is not signaled

        if (_pEventFire != NULL)
        {
            EnterCriticalSection(&_csEventFire);
            _DestroyLogger();                       // Free the old logger
            LeaveCriticalSection(&_csEventFire);
        }
        return E_FAIL;
    }

    // Check if either the whole process or this logger has been turned off
    if (_fLogDisabled || g_hEventLogger == NULL || _strSessionName == NULL)
    {
        return E_FAIL;
    }

    HRESULT hr = E_FAIL;
    EnterCriticalSection(&_csEventFire);

    if (! _fLogDisabled && g_hEventLogger != NULL)
    {
        // Logger event is signaled
        // The logger has been created and not being disabled

        if (_pEventFire == NULL)
        {
            // Starting event logger...
            // Only the first thread will make it here

            _CreateLogger();        // Will set _pEventFire if succeeded
        }

        if (_pEventFire != NULL)
        {
            _pEventFire->AddRef();
            *ppEventFire = _pEventFire;

            hr = NOERROR;
        }
    }

    LeaveCriticalSection(&_csEventFire);
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::QueryInterface
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_ISystemDebugEventFire))
    {
        *ppv = (ISystemDebugEventFire *) this;
        AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(riid, IID_IMarshal) ||
             IsEqualGUID(riid, IID_IMarshal2))
    {
        if (_punkFTM == NULL)
        {
            hr = CoCreateFreeThreadedMarshaler((ISystemDebugEventFire *)this,
                                               (LPUNKNOWN *)&_punkFTM);
            if (FAILED(hr))
            {
                *ppv = NULL;
                return hr;
            }
        }

        hr = _punkFTM->QueryInterface(riid, ppv);
    }
    else {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::AddRef
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CDebugEventFire::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return _cRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::Release
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CDebugEventFire::Release()
{
    ULONG count = InterlockedDecrement((long *) &_cRef);

    if (count == 0)
    {
        this->Cleanup();
        delete this;
    }

    return count;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::BeginSession
//
//  Synopsis:   Simulate IEC BeginSession
//              Wrapper class caches the info for later use
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::BeginSession(
        /* [in] */ REFGUID guidSourceID,
        /* [in] */ LPCOLESTR strSessionName)
{
    LogEventInitialize();

    EnterCriticalSection(&_csEventFire);

    if (_strSessionName != NULL)
        PrivMemFree(_strSessionName);

    DWORD cbSize = (lstrlenW(strSessionName) + 1) * sizeof(WCHAR);
    _strSessionName = (LPOLESTR) PrivMemAlloc(cbSize);
    if (_strSessionName == NULL)
        return E_OUTOFMEMORY;

    lstrcpyW(_strSessionName, strSessionName);
    _guidSession = guidSourceID;

    LeaveCriticalSection(&_csEventFire);
    return NOERROR;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::EndSession
//
//  Synopsis:   Forwarding IEC EndSession() if it is there
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::EndSession()
{
    ISystemDebugEventFire * pEventFire;
    HRESULT hr = GetEventLogger(&pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->EndSession();
        pEventFire->Release();

        EnterCriticalSection(&_csEventFire);
        _DestroyLogger();                       // Free the old logger
        LeaveCriticalSection(&_csEventFire);
    }
    else if (hr == E_FAIL)
    {
        hr = NOERROR;       // ignore wrapper errors
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::IsActive
//
//  Synopsis:   Forwarding IEC IsActive() if it is there
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::IsActive()
{
    // Check this first, so machines disabled/without event logging
    // would pay little overhead.
    //
    if (g_hEventLogger == NULL)
        return S_FALSE;

    ISystemDebugEventFire * pEventFire;
    HRESULT hr = GetEventLogger(&pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->IsActive();
        pEventFire->Release();
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::FireEvent
//
//  Synopsis:   Forwarding IEC FireEvent() if it is there
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::FireEvent(
        /* [in] */ REFGUID guidEvent,
        /* [in] */ int nEntries,
        /* [size_is][in] */ PULONG_PTR rgKeys,
        /* [size_is][in] */ PULONG_PTR rgValues,
        /* [size_is][in] */ LPDWORD rgTypes,
        /* [in] */ DWORD dwTimeLow,
        /* [in] */ LONG dwTimeHigh,
        /* [in] */ VSAEventFlags dwFlags)
{
    ISystemDebugEventFire * pEventFire;
    HRESULT hr = GetEventLogger(&pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->FireEvent(
                            guidEvent, nEntries,
                            rgKeys, rgValues, rgTypes,
                            dwTimeLow, dwTimeHigh, dwFlags);
        pEventFire->Release();
    }
    else if (hr == E_FAIL)
    {
        hr = NOERROR;       // ignore wrapper errors
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Class:      CDebugEventFireCF
//
//  Synopsis:   To create the IEC wrapper for apps
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
class CDebugEventFireCF : public IClassFactory
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown *punkOuter, REFIID riid, void **ppv);
    STDMETHOD(LockServer)(BOOL fLockServer);
};

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::QueryInterface
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFireCF::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory*) this;
        return NOERROR;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::AddRef
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG CDebugEventFireCF::AddRef(void)
{
    return 1;       // there is only one instance in the global space
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::AddRef
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG CDebugEventFireCF::Release(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::CreateInstance
//
//  Synopsis:
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFireCF::CreateInstance(IUnknown *punkOuter,
        REFIID riid, void **ppv)
{
    HRESULT hr;

	*ppv = NULL;

    if (punkOuter != NULL)
    {        
        return CLASS_E_NOAGGREGATION;
    }

    CDebugEventFire * pCEventFire;
    pCEventFire = (CDebugEventFire *) new CDebugEventFire;
    if (pCEventFire == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pCEventFire->Initialize();
    if (FAILED(hr))
    {
        // don't need to call Cleanup here
        delete pCEventFire;
        return hr;
    }

    hr = pCEventFire->QueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        pCEventFire->Cleanup();
        delete pCEventFire;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::LockServer
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFireCF::LockServer(BOOL fLockServer)
{
    return NOERROR;
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventGetClassObject
//
//  Synopsis:   Called from CoGetClassObject (as one of the internal classes)
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT LogEventGetClassObject(REFIID riid, void **ppv)
{
    static CDebugEventFireCF g_EventFireCF;  // the only instance
    return g_EventFireCF.QueryInterface(riid, ppv);
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventInitialize
//
//  Synopsis:   Init Logger, Called by ChannelProcessInitialize(void)
//              This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventInitialize()
{
    if (g_hEventLogger != NULL)     // Has been initialized, do nothing
        return;

    // Check if we are inside VSA LEC process.
    // If so quit, since we can't launch LEC against ourselves.
    //
    char szA[40];
    DWORD procID = GetCurrentProcessId();
    wsprintfA(szA, "MSFT.VSA.COM.DISABLE.%d", procID);

    HANDLE hVSA = OpenEventA(EVENT_ALL_ACCESS, FALSE, szA);
    if (hVSA != NULL)
    {
        CloseHandle(hVSA);
        return;
    }

    // RPCSS creates this named event, and Visat will signal it.
    g_hEventLogger = OpenEventA(EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE,
                                "MSFT.VSA.IEC.STATUS.6c736db0");

    if (g_hEventLogger != NULL)
    {
        COle32DebugEventFire * pCEventFire = new COle32DebugEventFire;
        if (pCEventFire == NULL)       // out of memory?
        {
            CloseHandle(g_hEventLogger);
            g_hEventLogger = NULL;
            g_pEventFire = NULL;
            return;
        }

        pCEventFire->Initialize();
        pCEventFire->QueryInterface(
                     IID_ISystemDebugEventFire, (void**)&g_pEventFire);

        OLECHAR sz[32];
        wsprintf(sz, L"COM Runtime %d", procID);
        g_pEventFire->BeginSession(GUID_ComEventLogSession, sz);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventCleanup
//
//  Synopsis:   UnInit Logger, Called by ChannelProcessUninitialize(void)
//              This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventCleanup()
{
    if (g_hEventLogger == NULL)     // Not yet initialized, do nothing
        return;

    if (g_pEventFire != NULL)
    {
        g_pEventFire->Release();
        g_pEventFire = NULL;
    }

    CloseHandle(g_hEventLogger);
    g_hEventLogger = NULL;
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventIsActive
//
//  Synopsis:   Forward IEC IsActive if the logger is there.
//              Disable 16 bit apps as they don't init things correctly.
//              This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
BOOL LogEventIsActive()
{
    // Make sure we are not holding the lock, or we will deadlock
    // on creating the event logger.
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (g_hEventLogger == NULL)     // most machines don't have logging
        return FALSE;

    HRESULT hr;
    COleTls tls(hr);    // Make sure TLS is initialized on this thread
    if (FAILED(hr) ||
        (tls->dwFlags & (OLETLS_WOWTHREAD | OLETLS_DISABLE_EVENTLOGGER)) != 0)
    {
        // If we are in 16 bit thread or inside _CreateLogger(), do nothing
        return FALSE;
    }

    if (g_pEventFire != NULL)
    {
        return (g_pEventFire->IsActive()==S_OK);
    }
    return FALSE;
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClassRegistration
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClassRegistration(HRESULT hr, RegInput* pRegIn, RegOutput* pRegOut)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR ClsValues[3];
        ClsValues[2] = (ULONG_PTR) hr;

        DWORD Entries = pRegIn->dwSize;
        RegInputEntry * pRegInEntry = pRegIn->rginent;
        DWORD * pRegOutEntry = pRegOut->RegKeys;

        for (DWORD i = 0; i < Entries; i++, pRegInEntry++, pRegOutEntry++)
        {
            ClsValues[0] = (ULONG_PTR) &pRegInEntry->clsid;
            ClsValues[1] = (ULONG_PTR) *pRegOutEntry;
            g_pEventFire->FireEvent(
                    GUID_ComClassRegistration, 3, ClsKeys, ClsValues, ClsTypes,
                    0, 0, cVSAEventDefaultSource);
        }
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClassRevokation
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClassRevokation(REFCLSID rclsid, DWORD dwReg)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR ClsValues[2];
        ClsValues[0] = (ULONG_PTR) &rclsid;
        ClsValues[1] = (ULONG_PTR) dwReg;

        g_pEventFire->FireEvent(
                GUID_ComClassRevokation, 2, ClsKeys, ClsValues, ClsTypes,
                0, 0, cVSAEventDefaultSource);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClientCall
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClientCall(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComClientCall, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultSource);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClientReturn
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClientReturn(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComClientReturn, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultSource);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventStubEnter
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventStubEnter(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComStubEnter, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultTarget);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventStubLeave
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventStubLeave(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComStubLeave, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultTarget);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventStubException
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventStubException(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComStubException, 6, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultTarget);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventMarshalHelper
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
static void LogEventMarshalHelper(
            OBJREF& objref, ULONG_PTR * MrsValues, DWORD * MrsTypes)
{
    OXIDEntry * pOXIDEntry = GetOXIDFromObjRef(objref);
    STDOBJREF * pStd = &ORSTD(objref).std;
    MOID moid;
    MOIDFromOIDAndMID(pStd->oid, pOXIDEntry->GetMid(), &moid);

    DUALSTRINGARRAY* psa = NULL;
    MIDEntry* pMIDEntry = NULL;

    pMIDEntry = pOXIDEntry->GetMIDEntry();
    if (pMIDEntry == NULL)
    {
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);

        gMIDTbl.GetLocalMIDEntry(&pMIDEntry);
        psa = (pMIDEntry ? pMIDEntry->Getpsa() : NULL);

        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
    }
    else
    {
        psa = pMIDEntry->Getpsa();
    }

    MrsValues[0] = (ULONG_PTR) &pStd->ipid;
    MrsValues[1] = (ULONG_PTR) pOXIDEntry->GetMoxidPtr();
    MrsValues[2] = (ULONG_PTR) &moid;
    MrsValues[3] = (ULONG_PTR) &objref.iid;
    MrsValues[4] = (ULONG_PTR) (psa ? psa->aStringArray : NULL);

    MrsTypes[0] = (DWORD) cVSAParameterValueGUID,
    MrsTypes[1] = (DWORD) (cVSAParameterValueGUID|cVSAParameterKeyString),
    MrsTypes[2] = (DWORD) cVSAParameterValueGUID,
    MrsTypes[3] = (DWORD) (cVSAParameterValueGUID|cVSAParameterKeyString),
    MrsTypes[4] = (DWORD)
        (cVSAParameterValueBYTEArray | cVSAParameterKeyString) |
        ((psa ? (psa->wNumEntries * sizeof(short)) : 0) & cVSAParameterValueLengthMask);

    // Deref mid entry if we had to use it
    if (pMIDEntry) 
        pMIDEntry->DecRefCnt();
}

//+-------------------------------------------------------------------
//
//  Function:   LogEventMarshal
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventMarshal(OBJREF& objref)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR MrsValues[5];
        DWORD MrsTypes[5];
        LogEventMarshalHelper(objref, MrsValues, MrsTypes);

        g_pEventFire->FireEvent(
            GUID_ComMarshal, 5, MrsKeys, MrsValues, MrsTypes,
            0, 0, cVSAEventDefaultTarget);
    }
}

//+-------------------------------------------------------------------
//
//  Function:   LogEventUnmarshal
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventUnmarshal(OBJREF& objref)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR MrsValues[5];
        DWORD MrsTypes[5];
        LogEventMarshalHelper(objref, MrsValues, MrsTypes);

        g_pEventFire->FireEvent(
                GUID_ComUnmarshal, 5, MrsKeys, MrsValues, MrsTypes,
                0, 0, cVSAEventDefaultSource);
    }
}

//+-------------------------------------------------------------------
//
//  Function:   LogEventDisconnect
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventDisconnect(const MOID * pMoid, MIDEntry * pMIDEntry,
                        BOOL fServerSide)
{
    Win4Assert(pMIDEntry);

    if (g_pEventFire == NULL)
        return;

    ULONG_PTR values[2];
    values[0] = (ULONG_PTR) pMoid;

    DUALSTRINGARRAY * psa;
    psa = pMIDEntry->Getpsa();
    values[1] = (ULONG_PTR) psa->aStringArray;

    DWORD types[2];
    types[0] = (DWORD) cVSAParameterValueGUID,
    types[1] = (DWORD)
        (cVSAParameterValueBYTEArray | cVSAParameterKeyString) |
        ((psa->wNumEntries * sizeof(short)) & cVSAParameterValueLengthMask);

    const GUID * pGuid;
    VSAEventFlags EventFlags;
    if (fServerSide)
    {
        pGuid = &GUID_ComDisconnectMarshal;
        EventFlags = cVSAEventDefaultTarget;
    }
    else
    {
        pGuid = &GUID_ComDisconnectUnmarshal;
        EventFlags = cVSAEventDefaultSource;
    }

    g_pEventFire->FireEvent(
            *pGuid, 2, DisKeys, values, types, 0, 0, EventFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\idobj.cxx ===
//+-------------------------------------------------------------------
//
//  File:       IDObj.cxx
//
//  Contents:   Data structures tracking object identity
//
//  Classes:    CIDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <idobj.hxx>
#include <comsrgt.hxx>
#include <stdid.hxx>
#include <crossctx.hxx>
#include <surract.hxx>

#define MAX_NODES_TO_REMOVE    100

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator CIDObject::s_allocator;       // Allocator for IDObjects
DWORD          CIDObject::s_cIDs;            // Relied on being ZERO
BOOL           CIDObject::s_fInitialized;    // Relied on being FALSE

BOOL           CPIDTable::s_fInitialized;    // Relied on being FALSE
// Hash Buckets for pointer id table
SHashChain CPIDTable::s_PIDBuckets[NUM_HASH_BUCKETS] = {
    {&s_PIDBuckets[0],  &s_PIDBuckets[0]},
    {&s_PIDBuckets[1],  &s_PIDBuckets[1]},
    {&s_PIDBuckets[2],  &s_PIDBuckets[2]},
    {&s_PIDBuckets[3],  &s_PIDBuckets[3]},
    {&s_PIDBuckets[4],  &s_PIDBuckets[4]},
    {&s_PIDBuckets[5],  &s_PIDBuckets[5]},
    {&s_PIDBuckets[6],  &s_PIDBuckets[6]},
    {&s_PIDBuckets[7],  &s_PIDBuckets[7]},
    {&s_PIDBuckets[8],  &s_PIDBuckets[8]},
    {&s_PIDBuckets[9],  &s_PIDBuckets[9]},
    {&s_PIDBuckets[10], &s_PIDBuckets[10]},
    {&s_PIDBuckets[11], &s_PIDBuckets[11]},
    {&s_PIDBuckets[12], &s_PIDBuckets[12]},
    {&s_PIDBuckets[13], &s_PIDBuckets[13]},
    {&s_PIDBuckets[14], &s_PIDBuckets[14]},
    {&s_PIDBuckets[15], &s_PIDBuckets[15]},
    {&s_PIDBuckets[16], &s_PIDBuckets[16]},
    {&s_PIDBuckets[17], &s_PIDBuckets[17]},
    {&s_PIDBuckets[18], &s_PIDBuckets[18]},
    {&s_PIDBuckets[19], &s_PIDBuckets[19]},
    {&s_PIDBuckets[20], &s_PIDBuckets[20]},
    {&s_PIDBuckets[21], &s_PIDBuckets[21]},
    {&s_PIDBuckets[22], &s_PIDBuckets[22]}
};
CPIDHashTable CPIDTable::s_PIDHashTbl;      // Hash table for pointer id table
CPIDTable gPIDTable;                        // Global pointer id table

BOOL           COIDTable::s_fInitialized;    // Relied on being FALSE
// Hash Buckets for OIDtable
SHashChain COIDTable::s_OIDBuckets[NUM_HASH_BUCKETS] = {
    {&s_OIDBuckets[0],  &s_OIDBuckets[0]},
    {&s_OIDBuckets[1],  &s_OIDBuckets[1]},
    {&s_OIDBuckets[2],  &s_OIDBuckets[2]},
    {&s_OIDBuckets[3],  &s_OIDBuckets[3]},
    {&s_OIDBuckets[4],  &s_OIDBuckets[4]},
    {&s_OIDBuckets[5],  &s_OIDBuckets[5]},
    {&s_OIDBuckets[6],  &s_OIDBuckets[6]},
    {&s_OIDBuckets[7],  &s_OIDBuckets[7]},
    {&s_OIDBuckets[8],  &s_OIDBuckets[8]},
    {&s_OIDBuckets[9],  &s_OIDBuckets[9]},
    {&s_OIDBuckets[10], &s_OIDBuckets[10]},
    {&s_OIDBuckets[11], &s_OIDBuckets[11]},
    {&s_OIDBuckets[12], &s_OIDBuckets[12]},
    {&s_OIDBuckets[13], &s_OIDBuckets[13]},
    {&s_OIDBuckets[14], &s_OIDBuckets[14]},
    {&s_OIDBuckets[15], &s_OIDBuckets[15]},
    {&s_OIDBuckets[16], &s_OIDBuckets[16]},
    {&s_OIDBuckets[17], &s_OIDBuckets[17]},
    {&s_OIDBuckets[18], &s_OIDBuckets[18]},
    {&s_OIDBuckets[19], &s_OIDBuckets[19]},
    {&s_OIDBuckets[20], &s_OIDBuckets[20]},
    {&s_OIDBuckets[21], &s_OIDBuckets[21]},
    {&s_OIDBuckets[22], &s_OIDBuckets[22]}
};
COIDHashTable COIDTable::s_OIDHashTbl;      // Hash table for OIDtable
COIDTable gOIDTable;                        // Global OIDtable
ULONG COIDTable::s_UnpinReqsPending;        // # of oid unpin req's pending
SHashChain COIDTable::s_OIDUnpinRequests;   // oid unpin requests pending

long gServerOIDCount;                       // Count of server OIDs

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Initialize     public
//
//  Synopsis:   Initializes allocator for IDObjects
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CIDObject::Initialize()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Initialize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Check init status
    if(s_fInitialized == FALSE)
    {
        // Initialize the allocators only if needed
        if(s_cIDs == 0)
            s_allocator.Initialize(sizeof(CIDObject), IDS_PER_PAGE, &gComLock);

        // Mark the state as initialized
        s_fInitialized = TRUE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::operator new     public
//
//  Synopsis:   new operator of IDObject
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CIDObject::operator new(size_t size)
{
    ASSERT_LOCK_HELD(gComLock);

    void *pv;
    Win4Assert(size == sizeof(CIDObject) &&
               "CIDObject improperly inherited");

    // Make sure allocator is initialized
    Win4Assert(s_fInitialized);

    // Allocate memory
    pv = (void *) s_allocator.AllocEntry();
    ++s_cIDs;

    ASSERT_LOCK_HELD(gComLock);
    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::operator delete     public
//
//  Synopsis:   delete operator of IDObject
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CIDObject::operator delete(void *pv)
{
#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CPolicySet can be inherited only by those objects
    // with overloaded new and delete operators
    LONG index = s_allocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Aquire lock
    LOCK(gComLock);

    // Release the pointer
    s_allocator.ReleaseEntry((PageEntry *) pv);
    --s_cIDs;
    // Cleanup allocator if needed
    if(s_fInitialized==FALSE && s_cIDs==0)
        s_allocator.Cleanup();

    // Release lock
    UNLOCK(gComLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Cleanup     public
//
//  Synopsis:   Cleanup allocator of IDObjects
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CIDObject::Cleanup()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Check if initialized
    if(s_fInitialized)
    {
        // Ensure that there are no Identities
        if(s_cIDs == 0)
            s_allocator.Cleanup();

        // Reset state
        s_fInitialized = FALSE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::CIDObject     public
//
//  Synopsis:   Constructor of IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CIDObject::CIDObject(IUnknown *pServer, CObjectContext *pServerCtx,
                     APTID aptID, DWORD dwState)
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::CIDObject this:%x pServer:%x\n"
                    , this, pServer));
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(dwState == IDFLAG_SERVER || dwState == IDFLAG_CLIENT);

    _cRefs       = 1;
    _oid         = GUID_NULL;
    _cCalls      = 0;
    _cLocks      = 0;

    _pStdWrapper = NULL;
    _pStdID      = NULL;
    _dwState     = dwState | IDFLAG_NOWRAPPERREF | IDFLAG_NOSTDIDREF;
    _aptID       = aptID;
    _pServer     = pServer;     // _pServer is a non-AddRef'd pointer
    
    _pvObjectTrackCookie = CoVrfTrackObject(_pServer);

    // Save server context
    _pServerCtx  = pServerCtx;
    if (pServerCtx)
        pServerCtx->InternalAddRef();

    if (IsServer())
    {
        Win4Assert(_pServerCtx == GetCurrentContext());
        _pServerCtx->CreateIdentity(this);
    }
    else
    {
        Win4Assert(_pServerCtx != GetCurrentContext());
    }

    _oidUnpinReqChain.pNext = &_oidUnpinReqChain;
    _oidUnpinReqChain.pPrev = &_oidUnpinReqChain;
    _dwOidUnpinReqState = OIDUPREQ_NO_STATE;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::~CIDObject     public
//
//  Synopsis:   Destructor of IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CIDObject::~CIDObject()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::~CIDObject\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Actually being in the oid unpin request list does not
    // take an extra reference on this object.  So, if we do
    // find ourselves in that list at this point, force
    // a removal.
    COIDTable::SpecialCleanup(this);

    Win4Assert(!InOIDTable());
    Win4Assert(!InPIDTable());
    Win4Assert(IsZombie());
    Win4Assert(_pStdID == NULL);
    Win4Assert(_pStdWrapper == NULL);
    Win4Assert(_pServer == NULL);
    Win4Assert(_pServerCtx == NULL);
    Win4Assert(_pvObjectTrackCookie == NULL);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::QueryInterface     public
//
//  Synopsis:   QI behavior of IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CIDObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IComObjIdentity *) this;
    }
    else if(IsEqualIID(riid, IID_IComObjIdentity))
    {
        *ppv = (IComObjIdentity *) this;
    }
    else if(IsEqualIID(riid, IID_IStdIDObject))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_IDOBJECT, "CIDObject::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::AddRef     public
//
//  Synopsis:   AddRefs IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CIDObject::AddRef()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::AddRef\n"));

    ULONG cRefs;

    // Increment ref count
    cRefs = InterlockedIncrement((LONG *) &_cRefs);

    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Release     public
//
//  Synopsis:   Release IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CIDObject::Release()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Release\n"));

    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &_cRefs);
    // Check if this is the last release
    if(cRefs == 0)
    {
        ASSERT_LOCK_NOT_HELD(gComLock);

        // Release server context
        CObjectContext *pServerCtx = NULL;
        if(_pServerCtx)
        {
            if(IsServer())
            {
                Win4Assert(_pServer || IsDeactivated());
                Win4Assert(_pServerCtx == GetCurrentContext());
            }

            pServerCtx = _pServerCtx;
        }

        // Delete IDObject
        LOCK(gComLock);

        // Remove from PIDTable if still present.
        // This can happen only under stress when we fail to create
        // a StdID.
        if(InPIDTable())
        {
            Win4Assert(IsServer());
            gPIDTable.Remove(this);
        }

        CoVrfStopTrackingObject(_pvObjectTrackCookie);
        _pvObjectTrackCookie = NULL;

#if DBG==1
        _pServerCtx = NULL;
        _pServer = NULL; // _pServer is a non-AddRef'd pointer
#endif
        delete this;
        UNLOCK(gComLock);

        // Release server context if necessary
        if(pServerCtx)
            pServerCtx->InternalRelease();

    }

    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Release returning 0x%x\n",
                     cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::GetIdentity     public
//
//  Synopsis:   Return the controlling unknown of the identified object.
//
//  History:    15-Apr-98   JimLyon     Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CIDObject::GetIdentity(IUnknown **ppUnk)
{
    if (ppUnk == NULL)
        return E_INVALIDARG;

    if (_pServer != NULL)
    {
        _pServer->AddRef();
        *ppUnk = _pServer;
        return S_OK;
    }
    else
    {
        *ppUnk = NULL;
        return CO_E_OBJNOTCONNECTED;
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::SetZombie     private
//
//  Synopsis:   Set IDFLAG_NOWRAPPERREF or NOSTDIDREF, and if this
//              results in us becoming a zombie, deal with that.
//
//  History:    15-Apr-98   JimLyon     Created
//              03-May-98   GopalK      Rewritten
//
//+-------------------------------------------------------------------
void CIDObject::SetZombie(DWORD dwIDFlag)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    BOOL fRelease = FALSE;

    // Aquire lock
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    // Update state
    if(dwIDFlag == IDFLAG_NOWRAPPERREF)
    {
        if(_pStdWrapper == NULL)
            _dwState |= dwIDFlag;
    }
    else
    {
        Win4Assert(dwIDFlag == IDFLAG_NOSTDIDREF);
        if(_pStdID == NULL)
            _dwState |= dwIDFlag;
    }

    // Check if the object has become a zombie object
    if (((_dwState & (IDFLAG_NOWRAPPERREF | IDFLAG_NOSTDIDREF)) ==
        (IDFLAG_NOWRAPPERREF | IDFLAG_NOSTDIDREF)) &&
        (_cLocks == 0))
    {
        // Sanity check
        Win4Assert(!IsZombie());

        // Update state
        _dwState |= IDFLAG_ZOMBIE;
        fRelease = TRUE;
    }

    // Check for the need to release state
    if(!fRelease)
    {
        // Release lock
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);
    }
    else
    {
        CoVrfStopTrackingObject(_pvObjectTrackCookie);
        _pvObjectTrackCookie = NULL;

        if(!IsServer())
        {
            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }
        else
        {   
            // Sanity check
            Win4Assert(_pServer || IsDeactivated());
            Win4Assert(_pServerCtx == GetCurrentContext());

            // Remove from PIDTable if still present.
            // This can happen only under stress when we fail to create
            // a StdID.
            // We need to hold the lock for this operation
            if(InPIDTable())
            {
                gPIDTable.Remove(this);
            }

            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            _pServerCtx->DestroyIdentity(this);
        }

        if(_pServerCtx)
            _pServerCtx->InternalRelease();
        _pServerCtx = NULL;

        _pServer = NULL;    // _pServer is a non-AddRef'd pointer
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Deactivate   public
//
//  Synopsis:   Deactivates an object for JIT by releasing all
//              references to the real server.
//
//  History:    30-Dec-98   Rickhi      Created from other pieces
//
//+-------------------------------------------------------------------
HRESULT CIDObject::Deactivate()
{
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(IsServer());
    Win4Assert(!IsDeactivated());

    HRESULT hr = E_FAIL;

    // ensure no calls pending and the object does not
    // support IExternalConnection.
    if (_cCalls == 0 && (!_pStdID || _pStdID->GetIEC() == NULL))
    {
        // OK to deactivate, mark state as deactivation started.
        _dwState |= IDFLAG_DEACTIVATIONSTARTED;

        // remove from the PID table
        gPIDTable.Remove(this);

        hr = S_OK;
    }

    // release the lock for the rest of the work.
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (SUCCEEDED(hr))
    {
        // Stop tracking object now (in case we end up destroying
        // the object below).
        CoVrfStopTrackingObject(_pvObjectTrackCookie);
        _pvObjectTrackCookie = NULL;

        // Deactivate wrapper
        if (_pStdWrapper)
            _pStdWrapper->Deactivate();

        // Deactivate StdId
        if (_pStdID)
            _pStdID->Deactivate();

        // update the state to say we are done.
        _dwState &= ~IDFLAG_DEACTIVATIONSTARTED;
        _dwState |= IDFLAG_DEACTIVATED;
        _pServer = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Reactivate   public
//
//  Synopsis:   Reactivates an object for JIT by re-establishing all
//              references to the real server.
//
//  History:    30-Dec-98   Rickhi      Created from other pieces
//
//+-------------------------------------------------------------------
HRESULT CIDObject::Reactivate(IUnknown *pServer)
{
    Win4Assert(IsServer());

    HRESULT hr = CO_E_OBJNOTCONNECTED;

    if (!IsZombie())
    {
        hr = E_FAIL;

        // The server can only be reactivated in its
        // original context
        if (GetServerCtx() == GetCurrentContext())
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Ensure that the server has been deactivated
            if (IsDeactivated())
            {
                // Mark the ID as Reactivated
                _pServer  = pServer;
                _dwState &= ~IDFLAG_DEACTIVATED;

                // Start tracking new object.
                _pvObjectTrackCookie = CoVrfTrackObject(_pServer);

                // Add the ID to the PID Table
                hr = gPIDTable.Add(this);                
            }

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (SUCCEEDED(hr))
            {
                // Reactivate stub manager
                if (_pStdID)
                    _pStdID->Reactivate(pServer);

                // Reactivate wrapper
                if(_pStdWrapper)
                   _pStdWrapper->Reactivate(pServer);
            }
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::NotifyOIDIsPinned   public
//
//  Synopsis:   Turns on the oid pin bit, and attempts to deregister
//              an oid unpin request if one is outstanding.  The std
//              marshal object calls this right before returning a
//              ORS_OID_PINNED status to the resolver.
//
//  History:    13-Mar-01   jsimmons     Created
//
//+-------------------------------------------------------------------
void CIDObject::NotifyOIDIsPinned()
{   
    ASSERT_LOCK_DONTCARE(gComLock);

    LOCK(gComLock);
	
    Win4Assert(InOIDTable());
    _dwState |= IDFLAG_OID_IS_PINNED; 

    // This may or may not succeed, it is just an optimization...
    gOIDTable.RemoveOIDUnpinRequest(this);

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::NotifyOIDIsUnpinned   public
//
//  Synopsis:   Turns off the oid pin bit and requests an oid unpin 
//              request if this idobject was previously pinned.
//
//  History:    13-Mar-01   jsimmons     Created
//
//+-------------------------------------------------------------------
void CIDObject::NotifyOIDIsUnpinned()
{
    ASSERT_LOCK_DONTCARE(gComLock);

    LOCK(gComLock);
	
    if (IsOIDPinned())
    {
        // If we are a pinned oid, then we ought to be
        // in the oid table.   Assert this is true:
        Win4Assert(InOIDTable());

        gOIDTable.AddOIDUnpinRequest(this);
        _dwState &= ~IDFLAG_OID_IS_PINNED; 
    }

    UNLOCK(gComLock);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given object pointer id
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
DWORD CPIDHashTable::HashNode(SHashChain *pPIDChain)
{
    CIDObject *pID = CIDObject::PIDChainToIDObject(pPIDChain);

    Win4Assert (pID && "Attempting to hash NULL CIDObject!");
    return (pID ? Hash(pID->GetServer(), pID->GetServerCtx()) : 0);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDHashTable::Compare
//
//  Synopsis:   Compares a object pointer id and a key.
//
//---------------------------------------------------------------------------
BOOL CPIDHashTable::Compare(const void *pv, SHashChain *pPIDChain, DWORD dwHash)
{
    CIDObject *pID = CIDObject::PIDChainToIDObject(pPIDChain);
    PIDData *pPIDData = (PIDData *) pv;

    Win4Assert (pID && "Attempting to compare NULL CIDObject!");
    if(pID && (pID->GetServer() == pPIDData->pServer &&
               pID->GetServerCtx() == pPIDData->pServerCtx))
       return(TRUE);

    return(FALSE);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Initialize
//
//  Synopsis:   Initailizes the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::Initialize()
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Initailize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is not initialized
    Win4Assert(!s_fInitialized);

    // Initialize hash table
    s_PIDHashTbl.Initialize(s_PIDBuckets, &gComLock);

    // Initialize IDObjects
    CIDObject::Initialize();

    // Mark the state as initialized
    s_fInitialized = TRUE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   CleanupIdentity
//
//  Synopsis:   Used for cleaning up entries inside the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CleanupIdentity(SHashChain *pNode)
{
    Win4Assert(!"CleanupIdentity got called");
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   RemovePID
//
//  Synopsis:   Removes the object identity from the pointer id table
//              if the object belongs to current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL RemovePID(SHashChain *pPIDChain, void *pvData)
{
    ASSERT_LOCK_HELD(gComLock);
    CIDObject *pID = CIDObject::PIDChainToIDObject(pPIDChain);
    C_ASSERT(sizeof(APTID) == sizeof(ULONG));
    DWORD aptID = PtrToUlong(pvData);
    BOOL fRemove = FALSE;

	Win4Assert(pID && "Trying to RemovePID on a NULL IDObject");
    if(pID && (pID->GetAptID() == aptID))
    {
       CStdIdentity *pStdID = pID->GetStdID();
        // Sanity check
        Win4Assert(!pStdID || pStdID->IsIgnoringOID() || !"Leaking stub managers");
        if (pStdID && pStdID->IsIgnoringOID()) 
        {
           UNLOCK(gComLock);
           pID->AddRef();
           pStdID->Release();
           LOCK(gComLock);
           pID->SetStdID(NULL);
        }
        // Update state
        CStdWrapper* pWrapper = pID->GetWrapper();
        if (pWrapper)
            pWrapper->InternalAddRef();

        pID->RemovedFromPIDTable();
        fRemove = TRUE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return(fRemove);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::ThreadCleanup
//
//  Synopsis:   Cleanup the pointer id table for the current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::ThreadCleanup()
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::ThreadCleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    DWORD aptID;

    // Cleanup for the thread only if the pointer id table
    // was initialized
    if(s_fInitialized)
    {
        ULONG ulSize, i;
        SHashChain *pPIDsRemoved[MAX_NODES_TO_REMOVE];
        CIDObject *pID;
        CStdWrapper *pWrapper;
        BOOL fDone = FALSE;

        // Initialize
        aptID = GetCurrentApartmentId();

        while(!fDone)
        {
            ulSize = MAX_NODES_TO_REMOVE;

            // Aquire lock
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Remove object identities belonging to this apartment
            fDone = s_PIDHashTbl.EnumAndRemove(RemovePID, (void *) LongToPtr(aptID),
                                               &ulSize, (void **) pPIDsRemoved);

            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            // Cleanup the returned IDs
            for(i = 0;i < ulSize; i++)
            {
                // Obtain the IDObject to be removed
                pID = CIDObject::PIDChainToIDObject(pPIDsRemoved[i]);
                Win4Assert(pID && "Removed a NULL IDObject from the hash table!");
                if (pID)
                {
                    pWrapper = pID->GetWrapper();
                    Win4Assert(pID->GetStdID() == NULL);

                    // Disconnect wrapper
                    if(pWrapper)
                    {
                        ContextDebugOut((DEB_ERROR,
                                         "Object at 0x%p still has [%x] outstanding "
                                         "connections\n", pWrapper->GetServer(),
                                         pWrapper->GetRefCount()-1));

                        pWrapper->Disconnect(NULL);
                        while(pWrapper->InternalRelease(NULL))
                            ;
                    }
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Cleanup
//
//  Synopsis:   Cleanup the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::Cleanup()
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is initialized
    Win4Assert(s_fInitialized);

    // Cleanup IDObjects
    CIDObject::Cleanup();

    // Cleanup hash table
    s_PIDHashTbl.Cleanup(CleanupIdentity);

    // Mark the state as initialized
    s_fInitialized = FALSE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Add
//
//  Synopsis:   Adds object identity into the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT CPIDTable::Add(CIDObject *pAddID)
{
    HRESULT hr = S_OK;
    ContextDebugOut((DEB_IDTABLE,
                     "CPIDTable::Add(ID:0x%x, pUnk:0x%p, Ctx:0x%p)\n",
                     pAddID, pAddID->GetServer(), pAddID->GetServerCtx()));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pAddID);

    // Create PIDData on the stack
    PIDData desiredPID;
    desiredPID.pServer = pAddID->GetServer();
    desiredPID.pServerCtx = pAddID->GetServerCtx();

    // Obtain Hash value
    DWORD dwHash = s_PIDHashTbl.Hash(desiredPID.pServer, desiredPID.pServerCtx);

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // If the object already exists in the table then we are trying to 
    // reactivate an active object
    if(NULL != pExistingID)
    {
        hr = E_INVALIDARG;
        Win4Assert(!"ID object already present");
    }


    if(SUCCEEDED(hr))
    {    
        // Add object identity to the Hash table
        s_PIDHashTbl.Add(dwHash, pAddID);
        pAddID->AddedToPIDTable();
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Add returning\n"));
    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Remove
//
//  Synopsis:   Removes given object identity from the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::Remove(CIDObject *pRemoveID)
{
    ContextDebugOut((DEB_IDTABLE,
                     "CPIDTable::Remove(ID:0x%x, pUnk:0x%p, Ctx:0x%p)\n",
                     pRemoveID, pRemoveID->GetServer(), pRemoveID->GetServerCtx()));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pRemoveID);
#if DBG==1
    // Create PIDData on the stack
    PIDData desiredPID;
    desiredPID.pServer = pRemoveID->GetServer();
    desiredPID.pServerCtx = pRemoveID->GetServerCtx();

    // Obtain Hash value
    DWORD dwHash = s_PIDHashTbl.Hash(desiredPID.pServer, desiredPID.pServerCtx);

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // Sanity check
    Win4Assert(pExistingID == pRemoveID);
#endif

    // Remove the given IDObject from the table
    s_PIDHashTbl.Remove(pRemoveID);
    pRemoveID->RemovedFromPIDTable();

#if DBG==1
    // Check for duplicate entries

    // Obatin the IDObject in the table
    pExistingID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // Sanity check
    Win4Assert((NULL == pExistingID) || !"Duplicate ID entries present");
#endif

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Remove returning\n"));
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Lookup
//
//  Synopsis:   Obtains object identity representing for the given pointer id
//              and context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CIDObject *CPIDTable::Lookup(IUnknown *pServer, CObjectContext *pServerCtx,
                             BOOL fAddRef)
{
    ContextDebugOut((DEB_IDTABLE,
                     "CPIDTable::Lookup(pUnk:0x%x, pCtx:0x%x, fAddRef:%x)\n",
                     pServer, pServerCtx, fAddRef));
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(pServer && pServerCtx);

    // Initialize
    PIDData desiredPID;
    desiredPID.pServer = pServer;
    desiredPID.pServerCtx = pServerCtx;

    // Obtain Hash value
    DWORD dwHash = s_PIDHashTbl.Hash(pServer, pServerCtx);
    CIDObject *pID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // AddRef the node before returning
    if(pID && fAddRef)
        pID->AddRef();

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Lookup returning IDObject:0x%x\n",
                     pID));
    return(pID);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::FindOrCreateIDObject
//
//  Synopsis:   returns the IDObject for the passed in pUnkServer. Creates it
//              if it does not already exist and fCreate is TRUE.
//              Returned pointer is AddRef'd and already in the gPIDTable.
//
//  Parameters: [pUnkServer] - controlling IUnknown of the server object
//              [pServerCtx] - context in which the object lives
//              [fCreate]    - TRUE: create the IDObject if it does not exist
//              [dwAptId]    - ID of apartment
//              [ppID]       - where to return the CIDObject ptr, AddRef'd.
//
//  History:    06-Jan-99   Rickhi      Created from other pieces.
//
//---------------------------------------------------------------------------
HRESULT CPIDTable::FindOrCreateIDObject(IUnknown *pUnkServer,
                                        CObjectContext *pServerCtx,
                                        BOOL fCreate, APTID dwAptId,
                                        CIDObject **ppID)
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::FindOrCreateIDObject pUnkServer:%x\n",
                    pUnkServer));
    ASSERT_LOCK_HELD(gComLock);

    // Lookup IDObject for the server object
    HRESULT hr = S_OK;
    *ppID = gPIDTable.Lookup(pUnkServer, pServerCtx, TRUE /* fAddRef */);

    if (*ppID == NULL)
    {
        // Not found.
        hr = CO_E_OBJNOTREG;

        if (fCreate)
        {
            // create the object identity representing
            // the server object and add it to the table.
            hr = E_OUTOFMEMORY;  // assume OOM

            *ppID = new CIDObject(pUnkServer, pServerCtx, dwAptId,
                                  IDFLAG_SERVER);
            if (*ppID)
            {
                // created OK, add it to the table
                Add(*ppID);
                hr = S_OK;
            }
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::FindOrCreateIDObject hr:%x pIDObject:%x\n",
                    hr, *ppID));
    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     CIDObject::GetOrCreateWrapper
//
//  Synopsis:   returns the wrapper object for this CIDObject. Creates it if
//              it does not already exist. Returned pointer is
//              InternalAddRef'd.
//
//  Parameters: [fCreate] - TRUE: create the wrapper if it does not exist
//              [dwFlags] - creation flags (from IDLF_*).
//              [ppWrapper] - where to return the wrapper ptr.
//
//  History:    06-Jan-99   Rickhi      Created from various pieces
//
//---------------------------------------------------------------------------
HRESULT CIDObject::GetOrCreateWrapper(BOOL fCreate, DWORD dwFlags,
                                      CStdWrapper **ppWrapper)
{
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateWrapper this:%x\n", this));
    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr = S_OK;
    *ppWrapper = _pStdWrapper;

    if (*ppWrapper == NULL)
    {
        if (fCreate)
        {
            // Create a new wrapper for the server object
            // Fill in the wrapper flags
            DWORD dwState = 0;
            if ((dwFlags & IDLF_NOIEC)  || (_pStdID && !_pStdID->GetIEC()))
                dwState |= WRAPPERFLAG_NOIEC;
            if ((dwFlags & IDLF_NOPING) || (_pStdID && _pStdID->IsPinged() == FALSE))
                dwState |= WRAPPERFLAG_NOPING;
            
            hr = E_OUTOFMEMORY; // assume OOM
            _pStdWrapper = new CStdWrapper(_pServer, dwState, this);
            
            if (_pStdWrapper != NULL)
            {
                *ppWrapper = _pStdWrapper;
                hr = S_OK;
            }
        }
        else
        {
            // We don't have a wrapper and we're not allowed to create
            // one.  Return CO_E_OBJNOTCONNECTED.
            hr = CO_E_OBJNOTCONNECTED;
        }
    }
    else
    {
        hr = S_OK;
        (*ppWrapper)->InternalAddRef();
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateWrapper hr:%x pWrapper:%x\n",
                    hr, *ppWrapper));
    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CIDObject::GetOrCreateStdID
//
//  Synopsis:   returns the StdID object for this CIDObject. Creates it if
//              it does not already exist. Returned pointer is either
//              AddRef'd or IncStrongCnt'd.
//
//  Parameters: [fCreate] - TRUE: create the stdid if it does not exist
//              [dwFlags] - creation flags (from IDLF_*).
//              [ppStdId] - where to return the StdId ptr.
//
//  History:    06-Jan-99   Rickhi      Created from various pieces
//
//---------------------------------------------------------------------------
HRESULT CIDObject::GetOrCreateStdID(BOOL fCreate, DWORD dwFlags,
                                    CStdIdentity **ppStdID)
{
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateStdID this:%x\n", this));
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(_pServerCtx == GetCurrentContext());

    BOOL          fStdIdCreated = FALSE;
    CStdIdentity *pCleanupStdID = NULL;
    CPolicySet   *pPS           = NULL;

    // Before we release gComLock, lock this object so that it will
    // not get disconnected before we complete our business.
    IncLockCount();

    HRESULT hr = CO_E_OBJNOTCONNECTED;
    CStdIdentity *pStdID = _pStdID;

    if (pStdID == NULL && (dwFlags & IDLF_CREATE))
    {
        // no StdID exists yet for this object, so go create one now.

        // Release the lock while doing this as this will call into
        // app code and can take a long time.
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);

        // Check for non empty context
        hr = S_OK;
        if (_pServerCtx != GetEmptyContext())
        {
            // Obtain the policy set between NULL client context and
            // current server context
            BOOL fCreate = TRUE;
            hr = ObtainPolicySet(NULL, _pServerCtx, PSFLAG_STUBSIDE,
                                 &fCreate, &pPS);
        }

        if (SUCCEEDED(hr))
        {
            // Set the creation flags based on what was passed in and
            // what has previously been used for the wrapper (if any).
            DWORD dwWrapFlags = GetWrapper() ? GetWrapper()->GetState() : 0;

            if (dwWrapFlags & WRAPPERFLAG_NOPING)
            {
                // the object does not use pinging.
                dwFlags |= IDLF_NOPING;
            }

            DWORD dwStdIdFlags = STDID_SERVER;
            if (dwFlags & IDLF_FTM)
            {
                // the object aggregates the FTM, set a flag in the StdId.
                dwStdIdFlags |= STDID_FTM;
            }

            if ((dwFlags & IDLF_NOIEC) || (dwWrapFlags & WRAPPERFLAG_NOIEC))
            {
                // the object should not use IExternalConnection, set a flag
                // in the StdId.
                dwStdIdFlags |= STDID_NOIEC;
            }

            // Create a StdID for the server. Assume OOM.
            hr = E_OUTOFMEMORY;
            IUnknown *pUnkID;
            BOOL fSuccess = FALSE;
            pStdID = new CStdIdentity(dwStdIdFlags, _aptID, NULL,
                                      _pServer, &pUnkID, &fSuccess);

            MOID moid;

            if (pStdID && fSuccess == FALSE)
            {
                delete pStdID;
                pStdID = NULL;
            }
            
            if (pStdID)
            {
                // Obtain OID for the object
                if (dwFlags & IDLF_NOPING)
                {
                    // object wont be pinged so dont bother using a
                    // pre-registered oid, just use a reserved one. Save
                    // the pre-registered ones for pinged objects
                    hr = gResolver.ServerGetReservedMOID(&moid);
                }
                else
                {
                    // object will be pinged, so get a pre-registered OID.
                    // Note this could yield if we have to pre-register
                    // more OIDs so do this before checking the table again.
                    hr = GetPreRegMOID(&moid);
                }
            }

            // Reacquire the lock
            LOCK(gComLock);
            ASSERT_LOCK_HELD(gComLock);

            if (SUCCEEDED(hr))
            {
                // while we released the lock, another thread could have
                // come along and created the StdId for this object so
                // we need to check again.
                if (_pStdID == NULL)
                {
                    // still NULL so use the StdID we created.
                    fStdIdCreated = TRUE;

                    // Set object identity inside StdID. This will
                    // AddRef the IDObject.
                    pStdID->SetIDObject(this);

                    // Set our _pStdID ptr
                    SetStdID(pStdID);

                    // Establish the OID for the object, this adds the OID
                    // to the gOIDTable.
                    pStdID->SetOID(moid);

                    // need to set the marshal time of the object to
                    // ensure that it does not run down before first
                    // marshal is complete
                    pStdID->SetMarshalTime();

                    // Save ping status for the object
                    if (dwFlags & IDLF_NOPING)
                    {
                        pStdID->SetNoPing();
                    }

                    // Set policy set inside the StdID
                    if (pPS)
                    {
                        pStdID->SetServerPolicySet(pPS);
                        pPS = NULL;
                    }
                }
                else
                {
                    // Release the newly created StdID and use the one obtained
                    // from the table.
                    pCleanupStdID = pStdID;
                    pStdID = _pStdID;

                    if (!(dwFlags & IDLF_NOPING))
                    {
                        // Also free the OID we allocated.
                        FreePreRegMOID(moid);
                    }
                }
            }
            else
            {
                // Could not allocate a StdID or an OID. Release the newly created
                // StdID (if any).
                pCleanupStdID = pStdID;
                pStdID = NULL;
            }
        }
        else
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);
        }
    }

    if (pStdID)
    {
        // AddRef the StdID being returned based on the flags
        // passed in.
        hr = S_OK;

        if (dwFlags & IDLF_STRONG)
        {
            pStdID->IncStrongCnt();
            if (fStdIdCreated)
                pStdID->Release();
        }
        else if (!fStdIdCreated)
        {
            pStdID->AddRef();
        }
    }

    if (pCleanupStdID || pPS)
    {
        // need to release the StdID or PolicySet we created.
        // Release the lock to do this since it will call app code.
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);

        if (pCleanupStdID)
            pCleanupStdID->Release();

        if (pPS)
            pPS->Release();

        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);
    }

    // allow disconnects back in
    DecLockCount();

    // Initialize return parameter
    *ppStdID = pStdID;

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateStdID this:%x hr:%x pStdID:%x\n",
              this, hr, *ppStdID));
    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given object pointer id
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
DWORD COIDHashTable::HashNode(SHashChain *pOIDChain)
{
    CIDObject *pID = CIDObject::OIDChainToIDObject(pOIDChain);

	Win4Assert (pID && "Attempting to hash NULL CIDObject");
	return (pID ? Hash(pID->GetOID(), pID->GetAptID()) : 0);
}


//---------------------------------------------------------------------------
//
//  Method:     COIDHashTable::Compare
//
//  Synopsis:   Compares a object OIDand a key.
//
//---------------------------------------------------------------------------
BOOL COIDHashTable::Compare(const void *pv, SHashChain *pOIDChain, DWORD dwHash)
{
    CIDObject *pID = CIDObject::OIDChainToIDObject(pOIDChain);
    OIDData *pOIDData = (OIDData *) pv;

	Win4Assert(pID && "Attempting to compare NULL CIDObject");
    if(pID && IsEqualGUID(pID->GetOID(), *pOIDData->pmoid) &&
       pID->GetAptID() == pOIDData->aptID)
       return(TRUE);

    return(FALSE);
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Initialize
//
//  Synopsis:   Initailizes the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Initialize()
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Initailize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is not initialized
    Win4Assert(!s_fInitialized);

    // Initialize hash table
    s_OIDHashTbl.Initialize(s_OIDBuckets, &gComLock);

    // Initialize IDObjects
    CIDObject::Initialize();

    // Initialize oid unpin request list head
    s_OIDUnpinRequests.pPrev = &s_OIDUnpinRequests;
    s_OIDUnpinRequests.pNext = &s_OIDUnpinRequests;

    // Mark the state as initialized
    s_fInitialized = TRUE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   RemoveOID
//
//  Synopsis:   Removes the object identity from the OIDtable
//              if the object belongs to current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL RemoveOID(SHashChain *pOIDChain, void *pvData)
{
    ASSERT_LOCK_HELD(gComLock);
    CIDObject *pID = CIDObject::OIDChainToIDObject(pOIDChain);
    C_ASSERT(sizeof(APTID) == sizeof(ULONG));
    DWORD aptID = PtrToUlong( pvData);
    BOOL fRemove = FALSE;

    Win4Assert(pID && "RemoveOID: Trying to remove NULL CIDObject");
    if (pID && (pID->GetAptID() == aptID))
    {
        // Remove from oid unpin req list if necessary
        COIDTable::SpecialCleanup(pID);

        // Update state
        pID->GetStdID()->AddRef();
        pID->GetStdID()->IgnoreOID();
        pID->RemovedFromOIDTable();
        fRemove = TRUE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return(fRemove);
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::ThreadCleanup
//
//  Synopsis:   Cleanup the OIDtable for the current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::ThreadCleanup()
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::ThreadCleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    DWORD aptID;

    // Cleanup for the thread only if the OIDtable
    // was initialized
    if(s_fInitialized)
    {
        ULONG ulSize, i;
        SHashChain *pOIDsRemoved[MAX_NODES_TO_REMOVE];
        CIDObject *pID;
        CStdIdentity *pStdID;
        BOOL fDone = FALSE;

        // Initialize
        aptID = GetCurrentApartmentId();

        while(!fDone)
        {
            ulSize = MAX_NODES_TO_REMOVE;

            // Aquire lock
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Remove object identities belonging to this apartment
            fDone = s_OIDHashTbl.EnumAndRemove(RemoveOID, (void *) LongToPtr(aptID),
                                               &ulSize, (void **) pOIDsRemoved);

            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            // Cleanup the returned IDs
            for(i = 0;i < ulSize; i++)
            {
                // Obtain the IDObject to be removed
                pID = CIDObject::OIDChainToIDObject(pOIDsRemoved[i]);
                if (!pID) continue;

                pStdID = pID->GetStdID();

                // Disconnect StdID
                if(pStdID)
                {
                    // Dump StdID
                    ComDebOut((DEB_ERROR,
                        "Object [%s] at 0x%p still has [%x] connections\n",
                         pStdID->IsClient() ? "CLIENT" : "SERVER",
                         pStdID->GetServer(), pStdID->GetRC()));
                    pStdID->DbgDumpInterfaceList();

#if DBG==1
                    BOOL fAggregated = pStdID->IsAggregated();
                    ULONG cRefs = pStdID->GetRC();
#endif
                    // Disconnect
                    pStdID->DisconnectAndRelease(DISCTYPE_UNINIT);
#if DBG==1
                    if(fAggregated==FALSE && cRefs!=1)
                        ComDebOut((DEB_ERROR,
                                   "The above object also has "
                                   "outstanding references on it\n"
                                   "\t\t\tProbable cause: Not revoking "
                                   "it from GIP Table\n"));
#endif
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Cleanup
//
//  Synopsis:   Cleanup the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Cleanup()
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is initialized
    Win4Assert(s_fInitialized);

    // Cleanup IDObjects
    CIDObject::Cleanup();

    // Cleanup hash table
    s_OIDHashTbl.Cleanup(CleanupIdentity);

    // The oid unpin request table should be empty here (either normally or
    // cleaned up when the various apartments went away).
    Win4Assert((s_OIDUnpinRequests.pNext == &s_OIDUnpinRequests) && 
               (s_OIDUnpinRequests.pPrev == &s_OIDUnpinRequests) &&
               (s_UnpinReqsPending == 0));

    // Mark the state as initialized
    s_fInitialized = FALSE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Add
//
//  Synopsis:   Adds object identity into the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Add(CIDObject *pAddID)
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Add\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pAddID);
#if DBG==1
    // Create OIDData on the stack
    OIDData desiredOID;
    desiredOID.pmoid = &pAddID->GetOID();
    desiredOID.aptID = pAddID->GetAptID();

    // Obtain Hash value
    DWORD dwHash2 = s_OIDHashTbl.Hash(pAddID->GetOID(), pAddID->GetAptID());

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_OIDHashTbl.Lookup(dwHash2, &desiredOID);

    // Sanity check
    Win4Assert(pExistingID==NULL || !"ID already present in the OID Table");
#endif

    // Obtain Hash value
    DWORD dwHash = s_OIDHashTbl.Hash(pAddID->GetOID(), pAddID->GetAptID());

    // Add object identity to the Hash table
    s_OIDHashTbl.Add(dwHash, pAddID);
    pAddID->AddedToOIDTable();
    if(pAddID->IsServer())
    {
        // Increment count of exported server objects
        InterlockedIncrement(&gServerOIDCount);
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Add returning"));
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Remove
//
//  Synopsis:   Removes given object identity from the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Remove(CIDObject *pRemoveID)
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Remove\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pRemoveID);
#if DBG==1
    // Create OIDData on the stack
    OIDData desiredOID;
    desiredOID.pmoid = &pRemoveID->GetOID();
    desiredOID.aptID = pRemoveID->GetAptID();

    // Obtain Hash value
    DWORD dwHash = s_OIDHashTbl.Hash(pRemoveID->GetOID(), pRemoveID->GetAptID());

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_OIDHashTbl.Lookup(dwHash, &desiredOID);

    // Sanity check
    Win4Assert(pExistingID == pRemoveID);
#endif

    // Remove the given IDObject from the table
    s_OIDHashTbl.Remove(pRemoveID);
    pRemoveID->RemovedFromOIDTable();
    if(pRemoveID->IsServer())
    {
        // Decrement count of exported server objects
        InterlockedDecrement(&gServerOIDCount);
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Remove returning\n"));
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::AddOIDUnpinRequest
//
//  Synopsis:   Adds the specified identity object to the list of oids that
//              need to be unpinned.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::AddOIDUnpinRequest(CIDObject *pIDObject)
{
    DWORD dwOUPState;

    ASSERT_LOCK_HELD(gComLock);
    
    // To avoid having to store a structure in the oid table (idobject ptr
    // + state bits), we borrow some state space from the id object.  The id
    // object itself does not depend on this state, and never looks at it.
    dwOUPState = pIDObject->GetOIDUnpinReqState();
    if (dwOUPState & OIDUPREQ_INOUPLIST)
    {
        // It's already in the unpin list.

        if (!(dwOUPState & OIDUPREQ_PENDING))
        {
            // If not pending, then should already be requested
            Win4Assert(dwOUPState & OIDUPREQ_UNPIN_REQUESTED);
        }

        // Turn on the requested flag
        dwOUPState |= OIDUPREQ_UNPIN_REQUESTED;

        // Remember new setting
        pIDObject->SetOIDUnpinReqState(dwOUPState);
    }
    else
    {
        DWORD dwNewOUPState;

        Win4Assert(dwOUPState == OIDUPREQ_NO_STATE); // if not in list should have no state

        // Add it to the end of the unpin list.   
        SHashChain* pNew = pIDObject->IDObjectToOIDUPReqChain();
        
        AddToOUPReqList(pNew);

        dwNewOUPState = (OIDUPREQ_INOUPLIST | OIDUPREQ_UNPIN_REQUESTED);
		
        pIDObject->SetOIDUnpinReqState(dwNewOUPState);

        s_UnpinReqsPending++;
    }

    ASSERT_LOCK_HELD(gComLock);
    
    // Notify the roid table that we have some work for it to
    // do on its worker thread. This is a perf thing to avoid
    // having our own worker thread.
    gROIDTbl.NotifyWorkWaiting();

    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::RemoveOIDUnpinRequest
//
//  Synopsis:   Removes the specified identity object from the list of oids that
//              need to be unpinned.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::RemoveOIDUnpinRequest(CIDObject *pIDObject)
{
    ASSERT_LOCK_HELD(gComLock);
    
    DWORD dwOUPState = pIDObject->GetOIDUnpinReqState();

    if (dwOUPState & OIDUPREQ_INOUPLIST)
    {
        // Okay, this id object has previously requested an unpin.  Find
        // out if we can remove it immediately, or if the worker thread
        // has picked it up in the meantime.
        if (!(dwOUPState & OIDUPREQ_PENDING))
        {
            // Not yet picked up by worker thread.  Just remove it.
            Win4Assert(dwOUPState & OIDUPREQ_UNPIN_REQUESTED);

            RemoveFromOUPReqList(pIDObject->IDObjectToOIDUPReqChain());

            // Reset oup state to nothing
            pIDObject->SetOIDUnpinReqState(OIDUPREQ_NO_STATE);

            s_UnpinReqsPending--;
        }
        else
        {
            // Since the worker thread got it, we're stuck.  Just leave it.  The
            // worst that can happen is extra rundown calls.
        }
    }

    ASSERT_LOCK_HELD(gComLock);        

    return;
}
	
//---------------------------------------------------------------------------
//
//  Method:     COIDTable::AddToOUPReqList, RemoveFromOUPReqList
//
//  Synopsis:   Adds\removes the specified list node to the oid unpin req list.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::AddToOUPReqList(SHashChain* pNewRequest)
{
    ASSERT_LOCK_HELD(gComLock);

    // Assert new request is chained to itself
    Win4Assert(pNewRequest == pNewRequest->pNext);
    Win4Assert(pNewRequest == pNewRequest->pPrev);
	
    // Add it to the end of the list
    pNewRequest->pPrev = &s_OIDUnpinRequests;
    s_OIDUnpinRequests.pNext->pPrev = pNewRequest;
    pNewRequest->pNext = s_OIDUnpinRequests.pNext;
    s_OIDUnpinRequests.pNext = pNewRequest;
}

void COIDTable::RemoveFromOUPReqList(SHashChain* pRequest)
{
    ASSERT_LOCK_HELD(gComLock);
	
    // Assert new request is not chained to itself
    Win4Assert(pRequest != pRequest->pNext);
    Win4Assert(pRequest != pRequest->pPrev);
    
    pRequest->pPrev->pNext = pRequest->pNext;
    pRequest->pNext->pPrev = pRequest->pPrev;
    pRequest->pPrev = pRequest;
    pRequest->pNext = pRequest;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::GetServerOidsToUnpin
//
//  Synopsis:   Fills in the supplied array with up to *pcSOidsToUnpin oids to
//              unpin.  Updates *pcSOidsToUnpin with the actual # filled in.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::GetServerOidsToUnpin(OID* pSOidsToUnpin, ULONG* pcSOidsToUnpin)
{
    Win4Assert(pSOidsToUnpin && pcSOidsToUnpin);

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    ULONG cSOidsAdded = 0;
    SHashChain* pNext = s_OIDUnpinRequests.pNext;
    while (pNext != &s_OIDUnpinRequests && (cSOidsAdded < *pcSOidsToUnpin))
    {
        CIDObject* pIDObject;
        DWORD dwOUPState;

        pIDObject = CIDObject::OIDUnpinReqChainToIDObject(pNext);
        Win4Assert(pIDObject);
        
        dwOUPState = pIDObject->GetOIDUnpinReqState();

        // Assert in list and unpin not already pending
        Win4Assert((dwOUPState & OIDUPREQ_INOUPLIST) && !(dwOUPState & OIDUPREQ_PENDING));

        // If unpin requested (almost always will be) add it to the [out] array
        if (dwOUPState & OIDUPREQ_UNPIN_REQUESTED)
        {
            OIDFromMOID(pIDObject->GetOID(), &(pSOidsToUnpin[cSOidsAdded]));

            // Turn off the requested bit, turn on the pending bit
            dwOUPState &= ~OIDUPREQ_UNPIN_REQUESTED;
            dwOUPState |= OIDUPREQ_PENDING;

            pIDObject->SetOIDUnpinReqState(dwOUPState);

            cSOidsAdded++;
        }
		
        pNext = pNext->pNext;
        Win4Assert(pNext);
    }
    
    *pcSOidsToUnpin = cSOidsAdded;

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::NotifyUnpinOutcome
//
//  Synopsis:   This gets called from the worker thread after a set of oid
//              unpin requests has been sent to the SCM.   The outcome is 
//              considered successful if the call returned a success code.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::NotifyUnpinOutcome(BOOL fOutcome) 
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    // Walk the list of unpin requests looking for ones that are currently 
    // pending (ie, we gave them to the worker thread to be unpinned).
    SHashChain* pCurrent = s_OIDUnpinRequests.pNext;
    while (pCurrent != &s_OIDUnpinRequests)
    {
        SHashChain* pNext = pCurrent->pNext;
        CIDObject* pIDObject;
        DWORD dwOUPState;

        pIDObject = CIDObject::OIDUnpinReqChainToIDObject(pCurrent);
        Win4Assert(pIDObject);

        dwOUPState = pIDObject->GetOIDUnpinReqState();

        // Assert in list
        Win4Assert(dwOUPState & OIDUPREQ_INOUPLIST);
        if (dwOUPState & OIDUPREQ_PENDING)
        {
            // If outcome succeeded, and another unpin request was not
            // queued while the worker thread was doing its thing, then
            // remove the request.  Otherwise keep it.
            if (fOutcome && !(dwOUPState & OIDUPREQ_UNPIN_REQUESTED))
            {
                pIDObject->SetOIDUnpinReqState(OIDUPREQ_NO_STATE);

                RemoveFromOUPReqList(pIDObject->IDObjectToOIDUPReqChain());

                s_UnpinReqsPending--;
            }
            else
            {
                // Either outcome was unclear, or another unpin request was
                // sent while we were pending.   Leave it in the list.

                // Optimization: we could add a "cancellation" bit, that if requested
                // while the unpin was pending, would allow us to remove the
                // request here instead of keeping it.  Probably not worth it.
                dwOUPState &= ~OIDUPREQ_PENDING;
                dwOUPState |= OIDUPREQ_UNPIN_REQUESTED;
                pIDObject->SetOIDUnpinReqState(dwOUPState);
            }
        }
        else
        {
            // This is a new request, added after we gave the last batch
            // to the worker thread.  Just assert that an unpin has been
            // requested for this oid.
            Win4Assert(dwOUPState & OIDUPREQ_UNPIN_REQUESTED);
        }
        
        pCurrent = pNext;
    }

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::SpecialCleanup
//
//  Synopsis:   This is a special function called during thread\apt cleanup,
//              and when an idobject is destructed. It is used to cleanup 
//              oids\idobjects that are being orphaned in the oid unpin request 
//              at that time.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::SpecialCleanup(CIDObject* pIDObject)
{
    ASSERT_LOCK_HELD(gComLock);

    DWORD dwOUPState = pIDObject->GetOIDUnpinReqState();
    if (dwOUPState & OIDUPREQ_INOUPLIST)
    {
        // Note that even if an unpin request is pending for this oid on
        // the worker thread, that's ok - the worker thread just won't
        // find this oid during its post-call cleanup work.
        SHashChain* pChain = pIDObject->IDObjectToOIDUPReqChain();
        RemoveFromOUPReqList(pChain);
        pIDObject->SetOIDUnpinReqState(OIDUPREQ_NO_STATE);
        
        s_UnpinReqsPending--;
    }
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Lookup
//
//  Synopsis:   Obtains object identity representing for the given pointer id
//              and context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CIDObject *COIDTable::Lookup(const MOID &roid, APTID aptID)
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Lookup\n"));
    ASSERT_LOCK_HELD(gComLock);

    CIDObject *pID;
    DWORD dwHash;

    // Initialize
    OIDData desiredOID;
    desiredOID.pmoid = &roid;
    desiredOID.aptID = aptID;

    // Obtain Hash value
    dwHash = s_OIDHashTbl.Hash(roid, aptID);
    pID = s_OIDHashTbl.Lookup(dwHash, &desiredOID);

    // AddRef the node before returning
    if(pID)
        pID->AddRef();

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Lookup returning IDObject:0x%x\n",
                     pID));
    return(pID);
}

//---------------------------------------------------------------------------
//
//  Method:     FreeSurrogateIfNecessary
//
//  Synopsis:   Start shutdown process of surrogate if (1) this is a
//              surrogate process; (2) there is no more outside ref counts.
//              We can't do this in COIDTable::Remove() because there would
//              be race conditions with releasing last server obj ref, see
//              CStdMarshal::Disconnect() in marshal.cxx.
//
//  History:    16-Nov-98   RongC      Created
//
//---------------------------------------------------------------------------
INTERNAL_(void) FreeSurrogateIfNecessary(void)
{
    // Let's see if this is a surrogate process.  If not, get out
    CSurrogateActivator* pSurrAct = CSurrogateActivator::GetSurrogateActivator();

    if ((pSurrAct == NULL) &&
        !CoIsSurrogateProcess())
        return;

    DWORD dwIdleCount = pSurrAct != NULL ? pSurrAct->GetObjectCountAtIdleTime() : 0;

    // for surrogates, we need to detect when there are no clients
    // using servers in the surrogate process -- we rely on the
    // fact that the OIDTable must be empty when there are no clients
    if(gServerOIDCount == dwIdleCount)
    {
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);
        if(gServerOIDCount == dwIdleCount)      // Double check just to be sure
        {
            (void)CCOMSurrogate::FreeSurrogate();
        }
        UNLOCK(gComLock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\ipidtbl.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       ipidtbl.cxx
//
//  Contents:   IPID (interface pointer identifier) table.
//
//  Classes:    CIPIDTable
//
//  History:    02-Feb-95   Rickhi      Created
//
//  Notes:      All synchronization is the responsibility of the caller.
//
//-------------------------------------------------------------------------
#include    <ole2int.h>
#include    <ipidtbl.hxx>       // CIPIDTable
#include    <resolver.hxx>      // CRpcResolver
#include    <service.hxx>       // SASIZE
#include    <remoteu.hxx>       // CRemoteUnknown
#include    <marshal.hxx>       // UnmarshalObjRef
#include    <callctrl.hxx>      // OleModalLoopBlockFn

extern void CancelPendingCalls(HWND hwnd);

// global tables
CMIDTable        gMIDTbl;       // machine ID table
COXIDTable       gOXIDTbl;      // object exported ID table
CIPIDTable       gIPIDTbl;      // interface pointer ID table

COleStaticMutexSem gOXIDLock;         // critical section for OXID and MID tables
COleStaticMutexSem gIPIDLock(TRUE);   // critical section for IPID tbl & CStdMarshal

OXIDEntry        COXIDTable::_InUseHead;
OXIDEntry        COXIDTable::_CleanupHead;
OXIDEntry        COXIDTable::_ExpireHead;
DWORD            COXIDTable::_cExpired  = 0;

CStringHashTable CMIDTable::_HashTbl;               // hash table for MIDEntries
CPageAllocator   CMIDTable::_palloc;                // allocator for MIDEntries
MIDEntry        *CMIDTable::_pLocalMIDEntry = NULL; // local machine MIDEntry

CPageAllocator   CIPIDTable::_palloc;               // allocator for IPIDEntries
IPIDEntry        CIPIDTable::_oidListHead;          // OIDs holding IPID entries
CPageAllocator   OXIDEntry::_palloc;                // allocator for OXIDEntries

//+------------------------------------------------------------------------
//
//  Machine Identifier hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain MIDBuckets[23] = {
    {&MIDBuckets[0],  &MIDBuckets[0]},
    {&MIDBuckets[1],  &MIDBuckets[1]},
    {&MIDBuckets[2],  &MIDBuckets[2]},
    {&MIDBuckets[3],  &MIDBuckets[3]},
    {&MIDBuckets[4],  &MIDBuckets[4]},
    {&MIDBuckets[5],  &MIDBuckets[5]},
    {&MIDBuckets[6],  &MIDBuckets[6]},
    {&MIDBuckets[7],  &MIDBuckets[7]},
    {&MIDBuckets[8],  &MIDBuckets[8]},
    {&MIDBuckets[9],  &MIDBuckets[9]},
    {&MIDBuckets[10], &MIDBuckets[10]},
    {&MIDBuckets[11], &MIDBuckets[11]},
    {&MIDBuckets[12], &MIDBuckets[12]},
    {&MIDBuckets[13], &MIDBuckets[13]},
    {&MIDBuckets[14], &MIDBuckets[14]},
    {&MIDBuckets[15], &MIDBuckets[15]},
    {&MIDBuckets[16], &MIDBuckets[16]},
    {&MIDBuckets[17], &MIDBuckets[17]},
    {&MIDBuckets[18], &MIDBuckets[18]},
    {&MIDBuckets[19], &MIDBuckets[19]},
    {&MIDBuckets[20], &MIDBuckets[20]},
    {&MIDBuckets[21], &MIDBuckets[21]},
    {&MIDBuckets[22], &MIDBuckets[22]}
};

//+------------------------------------------------------------------------
//
//  Member:     CIPIDTbl::Initialize, public
//
//  Synopsis:   Initializes the IPID table.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CIPIDTable::Initialize()
{
    ComDebOut((DEB_OXID, "CIPIDTable::Initialize\n"));
    LOCK(gIPIDLock);
    _oidListHead.pOIDFLink = &_oidListHead;
    _oidListHead.pOIDBLink = &_oidListHead;
    _palloc.Initialize(sizeof(IPIDEntry), IPIDS_PER_PAGE, NULL);
    UNLOCK(gIPIDLock);

    Win4Assert((2 << (BITS_PER_IPID_PG_OFFSET-1)) >= IPIDS_PER_PAGE);
    Win4Assert(BITS_PER_IPID_PG_OFFSET <= 32);  // 32 bits in one DWORD
}

//+------------------------------------------------------------------------
//
//  Member:     CIPIDTbl::Cleanup, public
//
//  Synopsis:   Cleanup the ipid table.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CIPIDTable::Cleanup()
{
    ComDebOut((DEB_OXID, "CIPIDTable::Cleanup\n"));
    LOCK(gIPIDLock);

    // Can't assert this because it fires too often
    //_palloc.AssertEmpty();
    _palloc.Cleanup();
    UNLOCK(gIPIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CIPIDTbl::LookupIPID, public
//
//  Synopsis:   Finds an entry in the IPID table with the given IPID.
//              This is used by the unmarshalling code, the dispatch
//              code, and CRemoteUnknown.
//
//  Notes:      This method should be called instead of GetEntryPtr
//              whenever you dont know if the IPID is valid or not (eg it
//              came in off the network), since this validates the IPID
//              index to ensure its within the table size, as well as
//              validating the rest of the IPID.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
IPIDEntry *CIPIDTable::LookupIPID(REFIPID ripid)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // Validate the IPID index that is passed in, since this came in off
    // off the net it could be bogus and we dont want to fault on it.
    // first dword of the ipid is the index into the ipid table.

    DWORD dwPageIndex = ripid.Data1 & IPID_PG_INDEX_MASK;
    
    if (_palloc.IsValidIndex(dwPageIndex))
    {
        IPIDEntry *pIPIDEntry = GetEntryPtr(dwPageIndex);

        // entry must be server side and not vacant
        if (pIPIDEntry && (pIPIDEntry->dwFlags & (IPIDF_SERVERENTRY | IPIDF_VACANT)) == IPIDF_SERVERENTRY)
        {
            // validate the rest of the guid
            if (InlineIsEqualGUID(pIPIDEntry->ipid, ripid))
                return pIPIDEntry;
        }
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   LookupFromIPIDTables, public
//
//  Synopsys:   Looks up the IPID in the IPIDtable, if found and valid,
//              returns the IPIDEntry pointer and the OXIDEntry pointer
//              with the OXIDEntry AddRef'd.
//
//  History:    28-Oct-96   t-KevinH    Created
//
//-------------------------------------------------------------------------
HRESULT CIPIDTable::LookupFromIPIDTables(REFIPID ripid, IPIDEntry **ppIPIDEntry,
                                         OXIDEntry **ppOXIDEntry)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    HRESULT hr = S_OK;

    IPIDEntry *pIPIDEntry = LookupIPID(ripid);
    if (pIPIDEntry != NULL && !(pIPIDEntry->dwFlags & IPIDF_DISCONNECTED) &&
        pIPIDEntry->pChnl != NULL && !(pIPIDEntry->pOXIDEntry->IsStopped()))
    {
        // OK to dispatch the call
        *ppIPIDEntry = pIPIDEntry;

        // Keep the OXID from going away till the call is dispatched.
        if (ppOXIDEntry)
        {
            *ppOXIDEntry = pIPIDEntry->pOXIDEntry;
            (*ppOXIDEntry)->IncRefCnt();
        }
    }
    else
    {
        // not OK to dispatch the call
        if (pIPIDEntry != NULL && pIPIDEntry->pStub == NULL)
            hr = E_NOINTERFACE;
        else
            hr = RPC_E_DISCONNECTED;

        *ppIPIDEntry = NULL;
        if (ppOXIDEntry)
            *ppOXIDEntry = NULL;
    }

    ComDebOut((DEB_CHANNEL,"LookupFromIPIDTables hr:%x pIPIDEntry:%x pOXIDEntry:%x\n",
              hr, *ppIPIDEntry, (ppOXIDEntry) ? *ppOXIDEntry : NULL));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CIPIDTable::ReleaseEntryList
//
//  Synopsis:   return a linked list of IPIDEntry to the table's free list
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CIPIDTable::ReleaseEntryList(IPIDEntry *pFirst, IPIDEntry *pLast)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(pLast->pNextIPID == NULL);

#if DBG==1
    // In debug, walk the list to ensure they are released, vacant,
    // disconnected etc.
    IPIDEntry *pEntry = pFirst;
    while (pEntry != NULL)
    {
        Win4Assert(pEntry->pOXIDEntry == NULL); // must already be released
        Win4Assert(pEntry->dwFlags & IPIDF_VACANT);
        Win4Assert(pEntry->dwFlags & IPIDF_DISCONNECTED);

        pEntry = pEntry->pNextIPID;
    }
#endif

    _palloc.ReleaseEntryList((PageEntry *)pFirst, (PageEntry *)pLast);
}

//+-------------------------------------------------------------------
//
//  Member:     CIPIDTable::ReleaseEntry
//
//  Synopsis:   return an IPIDEntry
//
//  History:    02-Sep-99   Johnstra  Created.
//
//--------------------------------------------------------------------
void CIPIDTable::ReleaseEntry(IPIDEntry *pEntry)
{
    ASSERT_LOCK_HELD(gIPIDLock);

#if DBG==1
    Win4Assert(pEntry->pOXIDEntry == NULL); // must already be released
    Win4Assert(pEntry->dwFlags & IPIDF_VACANT);
    Win4Assert(pEntry->dwFlags & IPIDF_DISCONNECTED);
#endif

    _palloc.ReleaseEntry((PageEntry *)pEntry);
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CIPIDTable::ValidateIPIDEntry
//
//  Synopsis:   Ensures the IPIDEntry is valid.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CIPIDTable::ValidateIPIDEntry(IPIDEntry *pEntry, BOOL fServerSide,
                                   CCtxComChnl *pChnl)
{
    // validate the IPID flags
    Win4Assert(!(pEntry->dwFlags & IPIDF_VACANT));
    if (fServerSide)
    {
        // server side must have SERVERENTRY ipids
        Win4Assert(pEntry->dwFlags & IPIDF_SERVERENTRY);
    }
    else
    {
        // client side must not have SERVERENTRY ipids
        Win4Assert(!(pEntry->dwFlags & IPIDF_SERVERENTRY));
    }


    // Validate the pStub interface
    if (IsEqualIID(pEntry->iid, IID_IUnknown))
    {
        // there is no proxy or stub for IUnknown interface
        Win4Assert(pEntry->pStub == NULL);
    }
    else
    {
        if ((pEntry->dwFlags & IPIDF_DISCONNECTED) &&
            (pEntry->dwFlags & IPIDF_SERVERENTRY))
        {
            // disconnected server side has NULL pStub
            Win4Assert(pEntry->pStub == NULL);
        }
        else
        {
            // both connected and disconnected client side has valid proxy
            Win4Assert(pEntry->pStub != NULL);
            Win4Assert(IsValidInterface(pEntry->pStub));
        }
    }


    // Validate the interface pointer (pv)
    if (!(pEntry->dwFlags & (IPIDF_DISCONNECTED | IPIDF_DEACTIVATED)))
    {
        Win4Assert(pEntry->pv != NULL);
        Win4Assert(IsValidInterface(pEntry->pv));
    }


    // Validate the channel ptr
    if (fServerSide)
    {
        // all stubs share the same channel on the server side
        Win4Assert(pEntry->pChnl == pChnl ||
                   (pEntry->dwFlags & IPIDF_DISCONNECTED));
    }
    else
    {
        // all proxies have their own different channel on client side
        Win4Assert(pEntry->pChnl != pChnl || pEntry->pChnl == NULL);
    }

    // Validate the RefCnts
    if (!(pEntry->dwFlags & IPIDF_DISCONNECTED) && !fServerSide)
    {
        // if connected, must be > 0 refcnt on client side.
        // potentially not > 0 if TABLE marshal on server side.
        ULONG cRefs = pEntry->cStrongRefs + pEntry->cWeakRefs;
        IRCEntry *pIRCEntry = pEntry->pIRCEntry;
        if (pIRCEntry)
            cRefs += pIRCEntry->cStrongRefs + pIRCEntry->cWeakRefs;

        Win4Assert(cRefs > 0);
    }

    // Validate the OXIDEntry
    if (pEntry->pOXIDEntry)
    {
        OXIDEntry *pOX = pEntry->pOXIDEntry;
        COMVERSION version = pOX->GetComVersion();
        Win4Assert(version.MajorVersion == COM_MAJOR_VERSION);
        Win4Assert(version.MinorVersion <= COM_MINOR_VERSION);

        if (fServerSide)
        {
            // check OXID tid and pid
            Win4Assert(pOX->GetPid() == GetCurrentProcessId());
            if (pOX->IsMTAServer())
                Win4Assert(pOX->GetTid() == MTATID);
            else if (pOX->IsNTAServer())
                Win4Assert(pOX->GetTid() == NTATID);
            else
                Win4Assert(pOX->GetTid() == GetCurrentThreadId());

            if (pChnl != NULL)
            {
                // CODEWORK: ensure OXID is same as the rest of the object
                // Win4Assert(IsEqualGUID(pOX->moxid, GetMOXID()));
            }
        }
    }


    // Validate the pNextIPID
    if (pEntry->pNextIPID != NULL)
    {
        // ensure it is within the bounds of the table
        Win4Assert(GetEntryIndex(pEntry) != -1);

        // cant point back to self or we have a circular list
        Win4Assert(pEntry->pNextIPID != pEntry);
    }

}
#endif

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::operator new, private
//
//+-------------------------------------------------------------------
void *OXIDEntry::operator new(size_t size)
{
    ASSERT_LOCK_HELD(gOXIDLock);

    // Allocate memory from page allocator
    void *pv = (void *) _palloc.AllocEntry();

    ComDebOut((DEB_OXID, "OXIDEntry::operator new this:%x\n",pv));
    return(pv);
}

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::operator delete, private
//
//+-------------------------------------------------------------------
void OXIDEntry::operator delete(void *pv)
{
    ComDebOut((DEB_OXID, "OXIDEntry::operator delete this:%x\n",pv));
    LOCK(gOXIDLock);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    LONG index = _palloc.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Release the pointer
    _palloc.ReleaseEntry((PageEntry *) pv);
    UNLOCK(gOXIDLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::OXIDEntry, private
//
//  Synopsis:   ctor for OXIDEntry
//
//+--------------------------------------------------------------------
OXIDEntry::OXIDEntry(REFOXID roxid, MIDEntry *pMIDEntry,
                   OXID_INFO *poxidInfo, unsigned long ulMarshaledTargetInfoLength, 
                   unsigned char *pMarshaledTargetInfo,DWORD dwAuthSvc, HRESULT &hr)
{
    // the Resolver should have correctly negotiated the version by now
    Win4Assert(poxidInfo->version.MajorVersion == COM_MAJOR_VERSION);
    Win4Assert(poxidInfo->version.MinorVersion <= COM_MINOR_VERSION);

    // init the chain to itself
    ChainToSelf();

    // Copy oxidInfo into OXIDEntry.
    MOXIDFromOXIDAndMID(roxid, pMIDEntry->GetMid(), &_moxid);
    _cRefs        = 1;       // caller gets one reference
    _dwPid        = poxidInfo->dwPid;
    _dwTid        = poxidInfo->dwTid;
    _version      = poxidInfo->version;
    _dwFlags      = (poxidInfo->dwPid == 0) ? 0 : OXIDF_MACHINE_LOCAL;

    if(poxidInfo->dwPid)
    {
        if(poxidInfo->dwTid == NTATID)
            _dwFlags |= OXIDF_NTASERVER;
        else if(poxidInfo->dwTid == MTATID)
            _dwFlags |= OXIDF_MTASERVER;
        else
            _dwFlags |= OXIDF_STASERVER;
    }

    _pRUSTA       = NULL;
    _ipidRundown  = poxidInfo->ipidRemUnknown;
    _pRpc         = NULL;
    _pAuthId      = NULL;
    _pBinding     = NULL;
    _dwAuthnHint  = RPC_C_AUTHN_LEVEL_NONE;

    // Past behavior was to use RPC_C_AUTHN_DEFAULT by default, which in practice usually
    // meant snego.   See bug 406902.   Now, if we are constructing a OXIDEntry for a remote
    // server we use the specified authentication service.     
    if (IsOnLocalMachine())
      _dwAuthnSvc   = RPC_C_AUTHN_DEFAULT;
    else
      _dwAuthnSvc   = dwAuthSvc;

    _ulMarshaledTargetInfoLength = ulMarshaledTargetInfoLength;
    _pMarshaledTargetInfo = pMarshaledTargetInfo;
    _pMIDEntry    = pMIDEntry;
    _hComplete    = NULL;
    _cCalls       = 0;
    _cResolverRef = 0;
    _hServerSTA   = NULL;
    _pParentApt   = NULL;

    pMIDEntry->IncRefCnt();

    // Save a copy of the mid value.  This is so we can return it later
    // (via GetMID) w/o taking a lock.
    _mid = pMIDEntry->GetMid();

    hr = S_OK;

    if (poxidInfo->dwPid != GetCurrentProcessId())
    {
        // Set security on this entry.
        hr = SetAuthnService(poxidInfo);
    }
    else if (IsMTAServer() || IsNTAServer())
    {
        // Get a shutdown event for server side MTAs.  Don't use the event
        // cache because the event isn't always reset.
        _hComplete = CreateEventA( NULL, FALSE, FALSE, NULL );
        if (_hComplete == NULL)
            hr = RPC_E_OUT_OF_RESOURCES;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::DecRefCnt, public
//
//  Synopsis:   Decrement the refcnt and Release the entry if it went to 0.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
ULONG OXIDEntry::DecRefCnt()
{
    ComDebOut((DEB_OXID, "OXIDEntry::DecRefCnt %x cRefs[%x]\n", this, _cRefs-1));

    ULONG cRefs = InterlockedDecrement((long *)&_cRefs);
    if (cRefs == 0)
    {
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);

        // Assert that the MTA OXID for this process is stopped by the
        // time it gets released.
        const DWORD LOCAL_MTA = OXIDF_MTASERVER | OXIDF_MACHINE_LOCAL | OXIDF_REGISTERED;
        Win4Assert((_dwPid != GetCurrentProcessId())     ||
                   (_dwFlags & LOCAL_MTA) != LOCAL_MTA   ||
                   (_dwFlags & OXIDF_STOPPED) == OXIDF_STOPPED);

        // refcnt went to zero, see if OK to delete this
        // entry from the global table.
        if (_cRefs == 0)
        {
            // move the entry to the free list
            gOXIDTbl.ReleaseOXIDEntry(this);
        }

        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
    }

    return cRefs;
}

ULONG OXIDEntry::DecRefCntAndFreeProxiesIfNecessary(BOOL* pfFreedProxies)
{
    ComDebOut((DEB_OXID, "OXIDEntry::DecRefCntAndCleanupIfNecessary %x cRefs[%x]\n", this, _cRefs-1));

    *pfFreedProxies = FALSE;
    
    ULONG cRefs = InterlockedDecrement((long *)&_cRefs);
    if (cRefs == 0)
    {
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);

        // Assert that the MTA OXID for this process is stopped by the
        // time it gets released.
        const DWORD LOCAL_MTA = OXIDF_MTASERVER | OXIDF_MACHINE_LOCAL;
        Win4Assert((_dwPid != GetCurrentProcessId())     ||
                   (_dwFlags & LOCAL_MTA) != LOCAL_MTA   ||
                   (_dwFlags & OXIDF_STOPPED) == OXIDF_STOPPED);

        // refcnt went to zero, see if OK to delete this
        // entry from the global table.
        if (_cRefs == 0)
        {
            // move the entry to the free list
            gOXIDTbl.ReleaseOXIDEntryAndFreeIPIDs(this);
            *pfFreedProxies = TRUE;
        }

        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
    }

    return cRefs;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::DecCallCnt, public
//
//  Synopsis:
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
ULONG OXIDEntry::DecCallCnt()
{
    ComDebOut((DEB_OXID, "OXIDEntry::DecCallCnt %x cRefs[%x]\n", this, _cCalls-1));

    ULONG cCalls = InterlockedDecrement((long *)&_cCalls);
    if (cCalls == 0)
    {
        // The call count went to zero.  If the MTA or NTA is waiting to
        // uninitialize, wake up the uninitializing thread.
        if ((_dwFlags & OXIDF_MTASTOPPED) == OXIDF_MTASTOPPED ||
            (_dwFlags & OXIDF_NTASTOPPED) == OXIDF_NTASTOPPED)
        {
            if (_hComplete)
                SetEvent(_hComplete);
        }
    }

    return cCalls;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::FillOXID_INFO, public
//
//  Synopsis:   fills out an OXID_INFO structure from an OXIDEntry
//
//  History:    02-Mar-97   Rickhi      Created
//
//-------------------------------------------------------------------------
void OXIDEntry::FillOXID_INFO(OXID_INFO *pOxidInfo)
{
    pOxidInfo->dwTid          = _dwTid;
    pOxidInfo->dwPid          = _dwPid;
    pOxidInfo->version        = _version;
    pOxidInfo->ipidRemUnknown = _ipidRundown;
    pOxidInfo->dwAuthnHint    = gAuthnLevel;
    pOxidInfo->dwFlags        = 0;
    pOxidInfo->psa            = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::GetRemUnk, public
//
//  Synopsis:   Find or create the proxy for the IRemUnknown for the
//              specified OXID
//
//  History:    27-Mar-95   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::GetRemUnk(IRemUnknown **ppRemUnk)
{
    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnk pOXIDEntry:%x ppRemUnk:%x\n",
                    this, ppRemUnk));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    HRESULT hr = S_OK;

    if (_pRUSTA == NULL)
    {
        hr = MakeRemUnk();
    }
    *ppRemUnk = _pRUSTA;

    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnk pOXIDEntry:%x pRU:%x hr:%x\n",
                    this, *ppRemUnk, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::GetRemUnkNoCreate, public
//
//  Synopsis:   Find the proxy for the IRemUnknown for the OXID
//
//  History:    02-Sep-99   JohnStra     Created
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::GetRemUnkNoCreate( IRemUnknown **ppRemUnk )
{
    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnkNoCreate pOXIDEntry:%x ppRemUnk:%x\n",
                    this, ppRemUnk));
    
    ASSERT_LOCK_HELD(gOXIDLock);
    *ppRemUnk = _pRUSTA;

    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnkNoCreate pOXIDEntry:%x pRU:%x hr:%x\n",
                    this, *ppRemUnk, S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::MakeRemUnk, private
//
//  Synopsis:   Create the proxy for the IRemUnknown for the
//              specified OXID and current apartments threading model.
//
//  History:    27-Mar-95   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::MakeRemUnk()
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // There is no remote unknown proxy for this entry, get one.
    // on the same machine, we ask for the IRundown interface since we may
    // need the RemChangeRef method. IRundown inherits from IRemUnknownN.

    REFIID riid = (IsOnLocalMachine()) ? IID_IRundown
                   : (_version.MinorVersion >= COM_MINOR_VERSION)
                     ? IID_IRemUnknown2
                     : IID_IRemUnknown;

    IRemUnknown *pRU = NULL;
    HRESULT hr = UnmarshalRemUnk(riid, (void **)&pRU);

    if (SUCCEEDED(hr))
    {
        if (InterlockedCompareExchangePointer((void**)&_pRUSTA, pRU, NULL) == NULL)
        {
            // need to adjust the internal refcnt on the OXIDEntry, since
            // the IRemUnknown has an IPID that holds a reference to it.
            // Dont use DecRefCnt since that would delete if it was 0.
            Win4Assert(_cRefs > 0);
            InterlockedDecrement((long *)&_cRefs);
        }
        else
        {
            // some other thread already created the proxy. Release
            // the one we made.
            pRU->Release();
        }
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnk pOXIDEntry:%x _pRUSTA:%x hr:%x\n",
               this, _pRUSTA, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::UnmarshalRemUnk, private
//
//  Synopsis:   Create a proxy for the requested IRemUnknown derivative
//              for the specified OXID.
//
//  History:    26-Nov-96        Rickhi Separated From MakeRemUnk
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::UnmarshalRemUnk(REFIID riid, void **ppv)
{
    ComDebOut((DEB_OXID,
        "OXIDEntry::UnmarshalRemUnk riid:%I pOXIDEntry:%x ppv:%x\n",
         &riid, this, ppv));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // Make up an objref, then unmarshal it to create a proxy to
    // the remunk object in the server.

    OBJREF objref;
    HRESULT hr = MakeFakeObjRef(objref, this, _ipidRundown, riid);

    if (SUCCEEDED(hr))
    {
        hr = UnmarshalInternalObjRef(objref, ppv);
        if(SUCCEEDED(hr))
        {
            CStdIdentity *pStdID;
            hr = ((IUnknown *) (*ppv))->QueryInterface(IID_IStdIdentity,
                                                       (void **) &pStdID);
            Win4Assert(SUCCEEDED(hr));
            // The check below is not needed given the assert above. However
            // this keeps some apps that worked on NT4 from AVing on NT5
            // See NT bugs 218523, 272390.

            if (SUCCEEDED(hr))
            {
                pStdID->UseClientPolicySet();
                pStdID->Release();
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "OXIDEntry::UnmarshalRemUnk ppv:%x hr:%x\n", *ppv, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::SetAuthnService, private
//
//  Synopsis:   Copy and save the security binding.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::SetAuthnService(OXID_INFO *pOxidInfo)
{
    // Copy the string array.
    ASSERT_LOCK_HELD(gOXIDLock);
    _dwAuthnHint = pOxidInfo->dwAuthnHint;
    return CopyStringArray(pOxidInfo->psa, NULL, &_pBinding);
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::FindPidMatchingTid, public
//
//  Synopsis:   Walks the chained OXIDEntries looking for one whose
//              pid matches that of the caller.
//
//--------------------------------------------------------------------
DWORD OXIDEntry::FindPidMatchingTid(DWORD tidCaller)
{
    DWORD pidCallee = 0;
    OXIDEntry *pOXIDEntry = this;

    LOCK(gOXIDLock);

    do
    {
        if (pOXIDEntry->GetTid() == tidCaller)
        {
            pidCallee = pOXIDEntry->GetPid();
            break;
        }
        pOXIDEntry = pOXIDEntry->_pNext;
    }
    while (pOXIDEntry != this);

    UNLOCK(gOXIDLock);

    return pidCallee;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::ExpireEntry, private
//
//  Synopsis:   deletes all state associated with an OXIDEntry that has
//              been expired.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void OXIDEntry::ExpireEntry()
{
    ComDebOut((DEB_OXID, "COXIDTable::ExpireEntry pEntry:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    if (_pRUSTA)
    {
       CStdIdentity *pStdID;
       HRESULT hr = ((IUnknown *) (_pRUSTA))->QueryInterface(IID_IStdIdentity,
					  (void **) &pStdID);
       Win4Assert(SUCCEEDED(hr));

       if (SUCCEEDED(hr))
       {
	  pStdID->NullOXIDReferencesInIPIDEntries();
	  pStdID->Release();
       }
	
	// release the IRemUnknown. Note that the IRemUnk is an object
        // proxy who's IPIDEntry holds a reference back to the very
        // OXIDEntry we are releasing.

        _pRUSTA->Release();
    }

    // Note that if hServerSTA is an HWND (apartment model, same process)
    // then it should have been cleaned up already in ThreadStop.
    Win4Assert(_hServerSTA == NULL);

    if (_pRpc != NULL)
    {
        // Release the channel handle and authentication information.
        _pRpc->Release();
    }
    if (_pAuthId)
    {
        PrivMemFree(_pAuthId);
    }
    PrivMemFree(_pBinding);

    // Release the call shutdown event.
    if (_hComplete != NULL)
        CloseHandle(_hComplete );

    // dec the refcnt on the MIDEntry
    // Normally we would not want to touch _pMIDEntry like this, since a
    // resolver binding update might change it out from underneath us. Here
    // we don't need to worry about that, because we have already been taken
    // off of the cleanup list, hence the binding update thread won't see us.
    _pMIDEntry->DecRefCnt();

    if (_ulMarshaledTargetInfoLength) {
       MIDL_user_free(_pMarshaledTargetInfo);
    }
    
    // CODEWORK: is this needed?
    // zero out the fields
    memset(this, 0, sizeof(OXIDEntry));

    // return it to the allocator
    delete this;

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"OXIDTable::ExpireEntry pEntry:%x\n", this));
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::InitRemoting, public
//
//  Synopsis:   Initialize the object for remoting.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::InitRemoting(CComApartment *pParentApt)
{
    ComDebOut((DEB_OXID, "OXIDEntry::InitRemoting this:%x.\n", this));

    // initially stopped
    _dwFlags |= OXIDF_STOPPED;

    HRESULT hr = S_OK;

    if (IsSTAServer())
    {
        // create the callctrl before calling StartServer, since the latter
        // tries to register with the call controller. We might already have
        // a callctrl if some DDE stuff has already run.

        COleTls tls;
        if (tls->pCallCtrl == NULL)
        {
            // assume OOM and try to create callctrl. ctor sets tls.
            hr = E_OUTOFMEMORY;
            CAptCallCtrl *pCallCtrl = new CAptCallCtrl();
        }

        if (tls->pCallCtrl)
        {
            // mark the channel as initialized.
            tls->dwFlags |= OLETLS_CHANNELTHREADINITIALZED;
            hr = S_OK;
        }
    }

    _pParentApt = pParentApt;

    ComDebOut((DEB_OXID, "OXIDEntry::InitRemoting this:%x hr:%x.\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::InitRundown, public
//
//  Synopsis:   Initialize the ipid for the IRemUnknown object for remoting.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
void OXIDEntry::InitRundown(IPID &ipidRundown)
{
    ComDebOut((DEB_OXID, "OXIDEntry::InitRundown this:%x IPID%I.\n",
              this, &ipidRundown));

    _ipidRundown = ipidRundown;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::CleanupRemoting, public
//
//  Synopsis:   Release the window for the thread.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::CleanupRemoting()
{
    ComDebOut((DEB_OXID, "OXIDEntry::CleanupRemoting this:%x.\n", this));
    Win4Assert((_dwFlags & OXIDF_STOPPED));

    if (IsSTAServer())
    {
        // Destroy the window. This will unblock any pending SendMessages.
        HWND hwnd;

        if (_hServerSTA  != NULL)
        {
            hwnd  = _hServerSTA ;
            _hServerSTA = NULL;
        }
        else
        {
            hwnd = TLSGethwndSTA();
        }

        // Don't hold a lock across DestroyWindow because USER32 will
        // randomly pick another window to make active. This can
        // result in a call being dispatched on another thread for a
        // different window which will try to acquire the gOXIDLock. If
        // we hold gOXIDLock on this thread, a deadlock will result.
        ASSERT_LOCK_HELD(gOXIDLock);
        UNLOCK(gOXIDLock);

        if (gdwMainThreadId == GetCurrentThreadId())
        {
            // destroy the main window
            UninitMainThreadWnd();
        }
        else
        {
            // This may fail if threads get terminated.
            if (IsWindow(hwnd))
            {
                DestroyWindow(hwnd);
            }
        }

        TLSSethwndSTA(NULL); // wipe out from the TLS also

        // Free the apartment call control.
        COleTls tls;

        delete tls->pCallCtrl;
        tls->pCallCtrl = NULL;

        // Free any registered MessageFilter that has not been picked
        // up by the call ctrl.
        if (tls->pMsgFilter)
        {
            tls->pMsgFilter->Release();
            tls->pMsgFilter = NULL;
        }

        LOCK(gOXIDLock);
        ASSERT_LOCK_HELD(gOXIDLock);
    }

    ComDebOut((DEB_OXID, "OXIDEntry::CleanupRemoting this:%x done.\n",this));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::StartServer, public
//
//  Synopsis:   Start the transport accepting incomming ORPC calls.
//
//  History:    02-Nov-98    Rickhi  Created, from various pieces
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::StartServer(void)
{
    ComDebOut((DEB_OXID, "OXIDEntry::StartServer this:%x\n", this));
    Win4Assert((_dwFlags & OXIDF_STOPPED));

    HRESULT    hr = S_OK;

    if (IsSTAServer())
    {
        HWND hwnd = GetOrCreateSTAWindow();
        if (hwnd)
        {
            // remembeer the hwnd
            _hServerSTA = hwnd;

            // Override the window proc function
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)ThreadWndProc);

            // get the local call control object, and register the
            // the window with it. Note that it MUST exist cause we
            // created it in ChannelThreadInitialize.

            CAptCallCtrl *pCallCtrl = GetAptCallCtrl();
            pCallCtrl->Register(hwnd, WM_USER, 0x7fff );
        }
        else
        {
            hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        _dwFlags &= ~OXIDF_STOPPED;
    }

    ComDebOut((DEB_OXID, "OXIDEntry::StartServer this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::StopServer, public
//
//  Synopsis:   Stop accepting incomming ORPC calls.
//
//  History:    ??-???-??  ?         Created
//              05-Jul-94  AlexT     Separated thread and process uninit
//              11-Feb-98  JohnStra  Made NTA aware
//              02-Jul-98  GopalK    Simplified
//              02-Nov-98  Rickhi    Made into method on OXIDEntry
//
//  Notes:      We are holding the single thread mutex during this call
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::StopServer()
{
    ComDebOut((DEB_OXID, "OXIDEntry::StopServer this:%x\n", this));

    // Stop the transport from accepting any more incomming calls.
    LOCK(gOXIDLock);
    _dwFlags |= OXIDF_STOPPED;
    UNLOCK(gOXIDLock);

    // Drain currently executing calls in the apartment
    HWND hwnd = IsSTAThread() ? GetServerHwnd() : NULL;
    CancelPendingCalls(hwnd);

    // Wait for any pending calls to complete
    WaitForApartmentShutdown();

    Win4Assert(_dwFlags & OXIDF_STOPPED);
    ComDebOut((DEB_OXID, "OXIDEntry::StopServer this:%x\n", this));
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::WaitForApartmentShutdown, private
//
//  Synopsis:   deletes all state associated with an OXIDEntry that has
//              been expired.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
extern void PeekTillDone(HWND hwnd);

void OXIDEntry::WaitForApartmentShutdown()
{
    // Wait for the apartment to shutdown.
    if (IsNTAServer())
    {
        if (_cCalls != 0)
        {
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: NTA shutdown pending\n" ));
            ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
            Win4Assert( _hComplete != NULL );
            WaitForSingleObject( _hComplete, INFINITE );
            ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: NTA shutdown complete\n" ));
        }
    }
    else if (IsMTAServer())
    {
        if (_cCalls != 0)
        {
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: MTA shutdown pending\n" ));
            ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
            Win4Assert( _hComplete != NULL );
            WaitForSingleObject( _hComplete, INFINITE );
            ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: MTA shutdown complete\n" ));
        }
    }
    else
    {
        ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: STA shutdown pending\n" ));
        ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
        PeekTillDone(GetServerHwnd());
        ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
        ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: STA shutdown complete\n" ));
    }
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::UpdateMIDEntry, public
//
//  Synopsis:   replaces the cached mid entry with the supplied one;
//              returns the old one, which the caller must release 
//              outside of gOXIDLock.               
//
//  History:    27-Nov-00  JSimmons   Created
//
//--------------------------------------------------------------------
MIDEntry* OXIDEntry::UpdateMIDEntry(MIDEntry* pNewMIDEntry)
{
    MIDEntry* pOldMIDEntry;

    Win4Assert(pNewMIDEntry);

    ASSERT_LOCK_HELD(gOXIDLock);
    
    Win4Assert(_pMIDEntry);  // this may go away (?)

    pOldMIDEntry = _pMIDEntry;

    _pMIDEntry = pNewMIDEntry;
    _pMIDEntry->IncRefCnt();

    ASSERT_LOCK_HELD(gOXIDLock);

    return pOldMIDEntry;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::GetMIDEntry, public
//
//  Synopsis:   returns a ref-counted pointer to the current midentry
//              for this oxidentry.              
//
//  History:    27-Nov-00  JSimmons   Created
//
//--------------------------------------------------------------------
MIDEntry* OXIDEntry::GetMIDEntry()
{
    MIDEntry* pCurrentMIDEntry;

    ASSERT_LOCK_DONTCARE(gOXIDLock);
    LOCK(gOXIDLock);
    
    Win4Assert(_pMIDEntry);

    pCurrentMIDEntry = _pMIDEntry;
    if (_pMIDEntry)
    {
        _pMIDEntry->IncRefCnt();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    UNLOCK(gOXIDLock);
    
    return pCurrentMIDEntry;
}


//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::RegisterOXIDAndOIDs, public
//
//  Synopsis:   allocate an OXID and Object IDs with the local ping server
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::RegisterOXIDAndOIDs(ULONG *pcOids, OID *pOids)
{
    ComDebOut((DEB_OXID, "OXIDEntry::RegisterOXID this%x TID:%x\n",
              this, GetCurrentThreadId()));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // OXID has not yet been registered with the resolver, do that
    // now along with pre-registering a bunch of OIDs.

    // init the oxidinfo structure from the OXIDEntry
    OXID_INFO oxidInfo;
    FillOXID_INFO(&oxidInfo);

    OXID oxid;
    HRESULT hr = gResolver.ServerRegisterOXID(oxidInfo, &oxid, pcOids, pOids);

    if (hr == S_OK)
    {
        // mark the OXID as registered with the resolver, and replace
        // the (temporarily zero) oxid with the real one the resolver
        // returned to us.

        _dwFlags |=  OXIDF_REGISTERED;
        MOXIDFromOXIDAndMID(oxid, gLocalMid, &_moxid);

#ifdef SHRMEM_OBJEX
        // at this point we can also start the timer for an STA server
        if (!IsMTAServer())
        {
            uiTimer = SetTimer(GetServerHwnd(),
                               IDT_DCOM_RUNDOWN,
                               RUNDOWN_TIMER_INTERVAL,
                               (TIMERPROC) RundownTimerProc);
        }
#endif // SHRMEM_OBJEX
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "ServerRegisterOXID this:%x hr:%x moxid:%I\n",
              this, hr, &_moxid));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::AllocOIDs, public
//
//  Synopsis:   allocates more pre-registered OIDs
//              with the local ping server
//
//  History:    20-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::AllocOIDs(ULONG *pcOidsAlloc, OID *pOidsAlloc,
                             ULONG cOidsReturn, OID *pOidsReturn)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    HRESULT hr;

    if (!(IsRegistered()))
    {
        // have not yet registered the OXID, so go do that at the same time
        // we allocate OIDs.
        Win4Assert(cOidsReturn == 0);   // should not be any OIDs to return
        hr = RegisterOXIDAndOIDs(pcOidsAlloc, pOidsAlloc);
    }
    else
    {
        // just get more OIDs from the resolver
        OXID oxid;
        OXIDFromMOXID(_moxid, &oxid);
        hr = gResolver.ServerAllocOIDs(oxid, pcOidsAlloc, pOidsAlloc,
                                       cOidsReturn, pOidsReturn);
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::FreeOXIDAndOIDs, public
//
//  Synopsis:   frees an OXID and associated OIDs that were  pre-registered
//              with the local ping server
//
//  History:    20-Jan-96   Rickhi      Created.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::FreeOXIDAndOIDs(ULONG cOids, OID *pOids)
{
    ComDebOut((DEB_OXID, "OXIDEntry::FreeOXIDAndOIDs TID:%x\n", GetCurrentThreadId()));
    ASSERT_LOCK_HELD(gOXIDLock);

    if (!IsRegistered())
    {
        // OXID was never registered, just return
        return S_OK;
    }

    // mark the OXIDEntry as no longer registered
    _dwFlags &= ~OXIDF_REGISTERED;

    // extract the OXID and tell the resolver it is no longer in use
    UNLOCK(gOXIDLock);
    OXID oxid;
    OXIDFromMOXID(_moxid, &oxid);
    HRESULT hr = gResolver.ServerFreeOXIDAndOIDs(oxid, cOids, pOids);
    LOCK(gOXIDLock);

    return hr;
}

#if DBG==1
//----------------------------------------------------------------------------
//
//  Function:   PostCallToSTAExceptionFilter
//
//  Synopsis:   Filters exceptions from PostCallToSTA
//
//----------------------------------------------------------------------------
LONG PostCallToSTAExceptionFilter( DWORD lCode,
                                   LPEXCEPTION_POINTERS lpep )
{
    ComDebOut((DEB_ERROR, "Exception 0x%x in PostCallToSTA at address 0x%x\n",
               lCode, lpep->ExceptionRecord->ExceptionAddress));
    DebugBreak();
    return EXCEPTION_EXECUTE_HANDLER;
}
#endif // DBG

//----------------------------------------------------------------------------
//
//  Method:     OXIDEntry::PostCallToSTA
//
//  Synopsis:   Executed on client thread (in local case) and RPC thread
//              (in remote case). Posts a message to the server thread,
//              guarding against disconnected threads
//
//----------------------------------------------------------------------------
HRESULT OXIDEntry::PostCallToSTA(CMessageCall *pCall)
{
    
    // ensure we are not posting to ourself (except from NTA) and that the
    // target apartment is not an MTA apartment.
   
    
    // the original check was incorrect. When calling from the NA
    // to the STA, we leave the NA before we get here.
    // The new check is to handle the case where we call from an STA to
    // NA and then call back into the same STA - Sajia
    Win4Assert( (_dwTid != GetCurrentThreadId() || pCall->IsNAToSTAFlagSet()) && 
                (!IsMTAServer()));

    HRESULT hr = RPC_E_SERVER_DIED_DNE;
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (!IsStopped())
    {
        HRESULT hr2 = _pParentApt->QueueMessage(WM_OLE_ORPC_POST, (IMessageParam *)(pCall));
        Win4Assert(SUCCEEDED(hr2));
        if (SUCCEEDED(hr2))
        {
#if DBG==1
            _try
            {
#endif
                // Pass the thread id to aid debugging.
                if (PostMessage(_hServerSTA, WM_OLE_ORPC_POST,
                                WMSG_MAGIC_VALUE, (LPARAM)((IMessageParam *)pCall)))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = RPC_E_SYS_CALL_FAILED;

                    // Cleanup the reference taken by the apartment.
                    hr2 = _pParentApt->RemoveMessage(WM_OLE_ORPC_POST, (IMessageParam*)pCall);
                    if (SUCCEEDED(hr2))
                        pCall->Release();
                }
#if DBG==1
            }
            _except( PostCallToSTAExceptionFilter(GetExceptionCode(),
                                                  GetExceptionInformation()) )
            {
            }
#endif
        }
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "OXIDEntry::PostCallToSTA this:%x pCall:%x hr:%x\n",
              this, pCall, hr));
    return hr;
}

//----------------------------------------------------------------------------
//
//  Method:     OXIDEntry::SendCallToSTA
//
//  Synopsis:   Executed on client thread (in local case) and RPC thread
//              (in remote case). Sends a message to the server thread,
//              guarding against disconnected apartments.
//
//----------------------------------------------------------------------------
HRESULT OXIDEntry::SendCallToSTA(CMessageCall *pCall)
{
    // make sure we are going someplace else
    Win4Assert(_dwTid != GetCurrentThreadId());

    HRESULT hr = RPC_E_SERVER_DIED_DNE;

    if (!IsStopped())
    {
        // On CoUninitialize this may fail when the window is destroyed.

        //02-05-2001 
        //Removed usage of SetLastError-GetLastError around the call to SendMessage; 
        //GetLastError is meaningful only if was called after an API that could set the last error
        //and that API failed
        //What we really care about here is if the message was successfully send to _hServerSTA
        //If SendMessage itself fails, it will return 0, otherwise it will return whatever ThreadWndProc
        //returns, after processing the message
        //So, in order to correctly interpret 0 as an error, ThreadWndProc will return a code different 
        //from 0 if it processed the message        

        HRESULT hr2 = _pParentApt->QueueMessage(WM_OLE_ORPC_SEND, pCall);
        Win4Assert(SUCCEEDED(hr2));
        if (SUCCEEDED(hr2))
        {
            LRESULT lres = SendMessage(_hServerSTA, WM_OLE_ORPC_SEND,
                                       WMSG_MAGIC_VALUE, (LPARAM)((IMessageParam *)pCall));
            
            if(0 == lres) //lres 0 means that SendMessage itself had errors (ThreadWndProc returns a code different from 0 if it processes the message)
            {                
                hr = RPC_E_SERVER_DIED;

                // Release the reference taken by the apartment.
                hr2 = _pParentApt->RemoveMessage(WM_OLE_ORPC_SEND, pCall);
                if (SUCCEEDED(hr2))
                    pCall->Release();
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    ComDebOut((DEB_OXID, "OXIDEntry::SendCallToSTA this:%x pCall:%x hr:%x\n",
              this, pCall, hr));
    return hr;
}


#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::AssertValid, public
//
//  Synopsis:   ensures the state of the OXIDEntry is valid
//
//  History:    20-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
void OXIDEntry::AssertValid()
{
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::Initialize, public
//
//  Synopsis:
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::Initialize()
{
    ComDebOut((DEB_OXID, "COXIDTable::Initialize\n"));
    LOCK(gOXIDLock);

    // initialize the chains
    _InUseHead.ChainToSelf();
    _CleanupHead.ChainToSelf();
    _ExpireHead.ChainToSelf();

    // initialize the allocator
    OXIDEntry::_palloc.Initialize(sizeof(OXIDEntry), OXIDS_PER_PAGE, NULL);

    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::Cleanup, public
//
//  Synopsis:   Cleanup the OXID table.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::Cleanup()
{
    ComDebOut((DEB_OXID, "COXIDTable::Cleanup\n"));
    LOCK(gOXIDLock);

    // the lists better be empty before we delete the entries
    AssertListsEmpty();
    OXIDEntry::_palloc.AssertEmpty();
    OXIDEntry::_palloc.Cleanup();

    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::AddOXIDEntry, private
//
//  Synopsis:   Adds an entry to the OXID table. The entry is AddRef'd.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT COXIDTable::AddOXIDEntry(REFOXID roxid, OXID_INFO *poxidInfo,
                                 MIDEntry *pMIDEntry, unsigned long ulMarshaledTargetInfoLength, 
                                 unsigned char *pMarshaledTargetInfo,DWORD dwAuthSvc, OXIDEntry **ppEntry)
{
    Win4Assert(poxidInfo != NULL);
    Win4Assert(pMIDEntry != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);
	
    *ppEntry = NULL;

    // find first free entry slot, grow table if necessary
    HRESULT hr = E_OUTOFMEMORY;
    OXIDEntry *pEntry = (OXIDEntry *) new OXIDEntry(roxid, pMIDEntry, poxidInfo, ulMarshaledTargetInfoLength, pMarshaledTargetInfo, dwAuthSvc, hr);
    if (pEntry == NULL)
    {
        ComDebOut((DEB_ERROR,"Out Of Memory in COXIDTable::AddOXIDEntry\n"));
        return hr;
    }
    else if (FAILED(hr))
    {
        // Partially initialized oxidentries should never be cached; just
        // delete them immediately.
        UNLOCK(gOXIDLock);
        pEntry->ExpireEntry();
        LOCK(gOXIDLock);
        return hr;
    }

    // chain it on the list of inuse entries
    pEntry->AddToChain(&_InUseHead);

    *ppEntry = pEntry;

    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_OXID,"COXIDTable::AddOXIDEntry pEntry:%x moxid:%I\n",
                    pEntry, (pEntry) ? pEntry->GetMoxidPtr() : &GUID_NULL));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::LookupOXID, private
//
//  Synopsis:   finds an entry in the OXID table with the given OXID.
//              This is used by the unmarshalling code. The returned
//              entry has been AddRef'd.
//
//  History:    02-Feb-95   Rickhi      Created
//
//  PERFWORK:   we could move the OXIDEntry to the head of the InUse list on
//              the assumption that it will be the most frequently used item
//              in the near future.
//
//-------------------------------------------------------------------------
OXIDEntry *COXIDTable::LookupOXID(REFOXID roxid, REFMID rmid)
{
    ASSERT_LOCK_HELD(gOXIDLock);

    MOXID moxid;
    MOXIDFromOXIDAndMID(roxid, rmid, &moxid);

    // first, search the InUse list.
    OXIDEntry *pEntry = SearchList(moxid, &_InUseHead);

    if (pEntry == NULL)
    {
        // not found on InUse list, search the Expire list.
        if ((pEntry = SearchList(moxid, &_ExpireHead)) != NULL)
        {
            // found it, unchain it from the list of Expire entries
            pEntry->RemoveFromChain();

            // Remove pending Release Flag
            pEntry->_dwFlags &= ~OXIDF_PENDINGRELEASE;
            pEntry->ResetExpiredTime();

            // chain it on the list of InUse entries
            pEntry->AddToChain(&_InUseHead);

            _cExpired--;
        }
    }

    ComDebOut((DEB_OXID,"COXIDTable::LookupOXID pEntry:%x moxid:%I\n",
                    pEntry, &moxid));
    gOXIDTbl.ValidateOXID();
    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::SearchList, private
//
//  Synopsis:   Searches the specified list for a matching OXID entry.
//              This is a subroutine of LookupOXID.
//
//  History:    25-Aug-95   Rickhi      Created
//
//-------------------------------------------------------------------------
OXIDEntry *COXIDTable::SearchList(REFMOXID rmoxid, OXIDEntry *pStart)
{
    ASSERT_LOCK_HELD(gOXIDLock);

    OXIDEntry *pEntry = pStart->_pNext;
    while (pEntry != pStart)
    {
        if (InlineIsEqualGUID(rmoxid, pEntry->_moxid))
        {
            pEntry->IncRefCnt();
            return pEntry;      // found a match, return it
        }

        pEntry = pEntry->_pNext; // try next one in use
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::ReleaseOXIDEntry, public
//
//  Synopsis:   removes an entry from the OXID table InUse list and
//              places it on the Expire list. Entries on the Expire list
//              will be cleaned up by a worker thread at a later time, or
//              placed back on the InUse list by LookupOXID.
//              If called from an apartment thread, delete entries on the
//              cleanup list.  If called from a worker thread, don't release
//              the lock and skip the cleanup list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::ReleaseOXIDEntry(OXIDEntry *pOXIDEntry)
{
    Win4Assert(pOXIDEntry);
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_HELD(gOXIDLock);
    
    // if already being deleted, just ignore.
    if (!(pOXIDEntry->_dwFlags & OXIDF_PENDINGRELEASE))
    {
        pOXIDEntry->_dwFlags |= OXIDF_PENDINGRELEASE;

        // unchain it from the list of InUse entries
        pOXIDEntry->RemoveFromChain();

        // chain it on the *END* of the list of Expire entries, and
        // count one more expired entry.
        pOXIDEntry->AddToChain(&gOXIDTbl._ExpireHead);
        pOXIDEntry->SetExpiredTime();
        _cExpired++;

        // Free anything hanging around on the cleanup list.  This may release
        // the lock.
        FreeCleanupEntries();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"COXIDTable::ReleaseOXIDEntry pEntry:%x\n", pOXIDEntry));
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::ReleaseOXIDEntryAndFreeIPIDs, public
//
//  Synopsis:   removes an entry from the OXID table InUse list and
//              places it on the Expire list. Entries on the Expire list
//              will be cleaned up by a worker thread at a later time, or
//              placed back on the InUse list by LookupOXID.
//              If called from an apartment thread, delete entries on the
//              cleanup list.  If called from a worker thread, don't release
//              the lock and skip the cleanup list.
//
//              Upon placing the OXID in the expire list, this routine
//              frees all the IPIDs associated with the OXID.  This prevents
//              runaway memory consumption in scenarios where clients create
//              lots of copies of the IUnknown proxy.
//
//  History:    07-Sep-99   JohnStra      Created
//
//-------------------------------------------------------------------------
void COXIDTable::ReleaseOXIDEntryAndFreeIPIDs(OXIDEntry* pOXIDEntry)
{
    Win4Assert(pOXIDEntry);
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_HELD(gOXIDLock);
    
    // if already being deleted, just ignore.
    if (!(pOXIDEntry->_dwFlags & OXIDF_PENDINGRELEASE))
    {
        pOXIDEntry->_dwFlags |= OXIDF_PENDINGRELEASE;

        // unchain it from the list of InUse entries
        pOXIDEntry->RemoveFromChain();

        // chain it on the *END* of the list of Expire entries, and
        // count one more expired entry.
        pOXIDEntry->AddToChain(&gOXIDTbl._ExpireHead);
        pOXIDEntry->SetExpiredTime();
        _cExpired++;

        // We want to free up all the IPID entries associated with this
        // OXIDEntry since we know that there are presently no references
        // on the OXIDEntry, thus the proxies are not being used.
        IRemUnknown* pRemUnk;
        HRESULT hr = pOXIDEntry->GetRemUnkNoCreate(&pRemUnk);
        if (SUCCEEDED(hr) && pRemUnk)
        {
            // Get the StdId for the remote unknown.
            CStdIdentity* pStdId;
            hr = pRemUnk->QueryInterface(IID_IStdIdentity, (void**)&pStdId);
            if (SUCCEEDED(hr))
            {
                // This releases the OXID lock.
                pStdId->ReleaseUnusedIPIDEntries();                    
                ASSERT_LOCK_NOT_HELD(gOXIDLock);
                
                pStdId->Release();
                
                // Reacquire the lock for FreeCleanupEntries.
                LOCK(gOXIDLock);
            }
        }        
        
        // Free anything hanging around on the cleanup list.  This may release
        // the lock and retake it.
        FreeCleanupEntries();    
    }

    ASSERT_LOCK_HELD(gOXIDLock);        
    ComDebOut((DEB_OXID,"COXIDTable::ReleaseOXIDEntryAndFreeIPIDs pEntry:%x\n", pOXIDEntry));
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::FreeExpiredEntries, public
//
//  Synopsis:   Walks the Expire list and deletes the OXIDEntries that
//              were placed on the expire list before the given time.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::FreeExpiredEntries(DWORD dwTime)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);


    // Move all items from the expired list to the cleanup list
    while(_ExpireHead._pNext != &_ExpireHead)
    {
        // unchain it from the list of Expire entries and, count one less
        // expired entry.
        OXIDEntry *pEntry = _ExpireHead._pNext;
        _cExpired--;
        pEntry->RemoveFromChain();
        pEntry->AddToChain(&_CleanupHead);
    }

    // The bulk-update worker thread moves entries to the cleanup list while
    // holding the lock. Since the expire list is now empty no more OXIDs can be
    // added to the cleanup list. Now would be a good time to free items on the
    // cleanup list.
    FreeCleanupEntries();

    AssertListsEmpty();     // the lists better be empty now

    UNLOCK(gOXIDLock);

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "COXIDTable::FreeExpiredEntries dwTime:%x\n", dwTime));
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::FreeCleanupEntries, private
//
//  Synopsis:   Deletes all OXID entries on the Cleanup list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::FreeCleanupEntries()
{
    ASSERT_LOCK_HELD(gOXIDLock);

    // release the entries in batches to reduce the number of locks/unlocks
    const int cCleanupSize = 25;
    OXIDEntry **ppCleanupList = (OXIDEntry **) _alloca(sizeof(OXIDEntry *)
                                                       * cCleanupSize);
    // _alloca never returns if it fails
    Win4Assert(ppCleanupList);

    // Cleanup the free list
    while (_CleanupHead._pNext != &_CleanupHead)
    {
        int iCleanupNum = 0;

        // Cleanup the free list
        while (_CleanupHead._pNext != &_CleanupHead)
        {
            // Unchain the entries and free all resources it holds.
            OXIDEntry *pEntry = _CleanupHead._pNext;
            pEntry->RemoveFromChain();
            ppCleanupList[iCleanupNum] = pEntry;
            ++iCleanupNum;
            if(iCleanupNum == cCleanupSize)
                break;
        }

        if(iCleanupNum)
        {
            UNLOCK(gOXIDLock);
            ASSERT_LOCK_NOT_HELD(gOXIDLock);

            // Cleanup entries
            for(int i=0;i<iCleanupNum;i++)
            {
                ComDebOut((DEB_OXID,
                           "Cleaning up OXID with PID:0x%x and TID:0x%x\n",
                           ppCleanupList[i]->GetPid(), ppCleanupList[i]->GetTid()));

                ppCleanupList[i]->ExpireEntry();
            }

            ASSERT_LOCK_NOT_HELD(gOXIDLock);
            LOCK(gOXIDLock);
        }
    }

    ComDebOut((DEB_OXID, "COXIDTable::FreeCleanupEntries\n"));
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTable::GetOxidsToRemove
//
//  Synopsis:   Builds a list of OXIDs old enough to be deleted.  Removes
//              them from the expired list and puts them on the cleanup list.
//              Moves machine local OXIDs directly to the cleanup list.
//
//  History:    03-Jun-42   AlexMit     Created
//
//-------------------------------------------------------------------------
void COXIDTable::GetOxidsToRemove(OXID_REF *pRef, DWORD *pcMaxRemoteToRemove)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    // Expire entries until the expired list has been walked, or until
    // the passed in buffer has been filled up.
    DWORD dwLifeTime     = GetTickCount() - (BULK_UPDATE_RATE * 2);
    DWORD cRemoteRemoved = 0;

    OXIDEntry *pNextEntry = _ExpireHead._pNext;
    while (pNextEntry != &_ExpireHead)
    {
        // Get the entry and its next entry
        OXIDEntry *pEntry = pNextEntry;
        pNextEntry = pEntry->_pNext;

        // Ensure that the OXID entry stayed in the expired list for at least
        // one interation of bulk update loop
        if (pEntry->GetExpiredTime() > dwLifeTime)
            continue;

        // Only tell the resolver about machine remote OXIDs, since that
        // is all that it cares about.
        if (!(pEntry->IsOnLocalMachine()))
        {
            if (cRemoteRemoved >= *pcMaxRemoteToRemove)
            {
                // we have filled up the caller's buffer, so
                // leave the rest of the entries alone.
                break;
            }

            // Add the OXID to the list to deregister.
            MIDFromMOXID(pEntry->GetMoxid(), &pRef->mid);
            OXIDFromMOXID(pEntry->GetMoxid(), &pRef->oxid);
            pRef->refs = pEntry->_cResolverRef;
            pRef++;
            cRemoteRemoved++;
        }

        // Remove the OXID from the expired list and put it on a list
        // of OXIDs to be released by some apartment thread.
        _cExpired--;
        pEntry->RemoveFromChain();
        pEntry->AddToChain(&_CleanupHead);
    }

    // release any entries currently on the cleanup list
    FreeCleanupEntries();

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // update the caller's count of entries to remove
    *pcMaxRemoteToRemove = cRemoteRemoved;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::MakeServerEntry, public
//
//  Synopsis:   Creates a partially initialized entry in the OXID table for
//              the local apartment. The rest of the initialization is done
//              in Initialize.
//
//  History:    20-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT COXIDTable::MakeServerEntry(OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID, "COXIDTable::MakeServerEntry ppOXIDEntry:%x\n", ppOXIDEntry));
    ASSERT_LOCK_HELD(gOXIDLock);

    MIDEntry  *pMIDEntry;
    HRESULT hr = gMIDTbl.GetLocalMIDEntry(&pMIDEntry);

    if (SUCCEEDED(hr))
    {
        // NOTE: Chicken And Egg Problem.
        //
        // Marshaling needs the local OXIDEntry. The local OXIDEntry needs
        // the local OXID. To get the local OXID we have to call the resolver.
        // To call the resolver we need the IPID for IRemUnknown. To get the
        // IPID for IRemUnknown, we need to marshal CRemoteUnknown!
        //
        // To get around this problem, we create a local OXIDEntry (that has
        // a 0 OXID and NULL ipidRemUnknown) so that marshaling can find it.
        // Then we marshal the RemoteUnknown and extract its IPID value, stick
        // it in the local OXIDEntry. When we call the resolver (to get some
        // pre-registered OIDs) we get the real OXID value which we then stuff
        // in the local OXIDEntry.

        OXID_INFO oxidInfo;
        oxidInfo.dwTid          = GetCurrentApartmentId();
        oxidInfo.dwPid          = GetCurrentProcessId();
        oxidInfo.ipidRemUnknown = GUID_NULL;
        oxidInfo.version.MajorVersion = COM_MAJOR_VERSION;
        oxidInfo.version.MinorVersion = COM_MINOR_VERSION;
        oxidInfo.dwAuthnHint    = RPC_C_AUTHN_LEVEL_NONE;
        oxidInfo.dwFlags        = 0;
        oxidInfo.psa            = NULL;

        // NOTE: temp creation of OXID. We dont know the real OXID until
        // we call the resolver. So, we use 0 temporarily (it wont conflict
        // with any other MOXIDs we might be searching for because we already
        // have the real MID and our local resolver wont give out a 0 OXID).
        // The OXID will be replaced with the real one when we register
        // with the resolver in CRpcResolver::ServerRegisterOXID.

        OXID oxid;
        memset(&oxid, 0, sizeof(oxid));

        hr = AddOXIDEntry(oxid, &oxidInfo, pMIDEntry, 0, NULL, RPC_C_AUTHN_DEFAULT, ppOXIDEntry);

        // Normally you do not want to hold gOXIDLock when dereferencing a
        // midentry; however, it is safe here since this will never be the last
        // release since we didn't release the lock after calling
        // GetLocalMIDEntry above.
        pMIDEntry->DecRefCnt();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "COXIDTable::MakeServerEntry hr:%x pOXIDEntry:%x\n",
              hr, *ppOXIDEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     COXIDTable::MakeSCMEntry, public
//
//  Synopsis:   Makes and returns an OXIDEntry for the SCM process.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT COXIDTable::MakeSCMEntry(REFOXID roxid, OXID_INFO *poxidInfo,
                                 OXIDEntry **ppOXIDEntry)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    // Get the local MIDEntry
    MIDEntry  *pMIDEntry;
    HRESULT hr = gMIDTbl.GetLocalMIDEntry(&pMIDEntry);
    if (SUCCEEDED(hr))
    {
        hr = AddOXIDEntry(roxid, poxidInfo, pMIDEntry, 0, NULL, RPC_C_AUTHN_DEFAULT, ppOXIDEntry);

        // Normally you do not want to hold gOXIDLock when dereferencing a
        // midentry; however, it is safe here since this will never be the last
        // release since we didn't release the lock after calling
        // GetLocalMIDEntry above.
        pMIDEntry->DecRefCnt();
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     COXIDTable::ClientResolveOXID, public
//
//  Synopsis:   Resolve client-side OXID and returns the OXIDEntry, AddRef'd.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT COXIDTable::ClientResolveOXID(REFOXID roxid,
                                      DUALSTRINGARRAY *psaResolver,
                                      OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID,"COXIDTable::ClientResolveOXID oxid:%08x %08x psa:%x\n",
               roxid, psaResolver));

    HRESULT hr = S_OK;
    *ppOXIDEntry = NULL;

    // Look for a MID entry for the resolver. if we cant find it
    // then we know we dont have an OXIDEntry for the oxid.

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    DWORD dwHash;
    MIDEntry *pMIDEntry = gMIDTbl.LookupMID(psaResolver, &dwHash);
    if (pMIDEntry)
    {
        // found the MID, now look for the OXID
        *ppOXIDEntry = LookupOXID(roxid, pMIDEntry->GetMid());
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    if (*ppOXIDEntry == NULL)
    {
        // didn't find the OXIDEntry in the table so we need to resolve it.
        MID       mid;
        OXID_INFO oxidInfo;
        USHORT    usAuthnSvc;  
        oxidInfo.psa = NULL;
        unsigned long ulMarshaledTargetInfoLength = 0;
        unsigned char *pMarshaledTargetInfo = NULL;
        hr = gResolver.ClientResolveOXID(roxid, &oxidInfo, &mid, psaResolver, &ulMarshaledTargetInfoLength, &pMarshaledTargetInfo, &usAuthnSvc);

        if (SUCCEEDED(hr))
        {
           // if we find that the server's PID is our PID, then this reference is 
           // to an object in a dead local process which happened to have the same 
           // PID as ours (remote PIDs are always 0). If we let the unmarshal 
           // continue, calls on the proxy will most likely get confused and 
           // hang. Fail now.
           if (oxidInfo.dwPid == GetCurrentProcessId()) 
           {
              ComDebOut((DEB_OXID,"COXIDTable::ClientResolveOXID PID re-usage, fail unmarshal pOXIDEntry:%x\n",
                  *ppOXIDEntry));
              if (ulMarshaledTargetInfoLength) 
              {
                 Win4Assert(pMarshaledTargetInfo);
                 MIDL_user_free(pMarshaledTargetInfo);
              }
              hr = HRESULT_FROM_WIN32(OR_INVALID_OXID);    
           }
           if (SUCCEEDED(hr))
           {
              // create an OXIDEntry.
              hr = FindOrCreateOXIDEntry(roxid, oxidInfo, FOCOXID_REF,
                                         psaResolver,
                                         mid, pMIDEntry, ulMarshaledTargetInfoLength, pMarshaledTargetInfo, usAuthnSvc, ppOXIDEntry);
           }
           // free the returned string bindings
           MIDL_user_free(oxidInfo.psa);
        }
    }

    if (pMIDEntry)
    {
        pMIDEntry->DecRefCnt();
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"COXIDTable::ClientResolveOXID hr:%x pOXIDEntry:%x\n",
        hr, *ppOXIDEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FindOrCreateOXIDEntry
//
//  Synopsis:   finds or adds an OXIDEntry for the given OXID. May
//              also create a MIDEntry if one does not yet exist.
//
//  History:    22-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT COXIDTable::FindOrCreateOXIDEntry(REFOXID roxid,
                              OXID_INFO &oxidInfo,
                              FOCOXID   eResolverRef,
                              DUALSTRINGARRAY *psaResolver,
                              REFMID    rmid,
                              MIDEntry  *pMIDEntry,
                              unsigned long   ulMarshaledTargetInfoLength,
                              unsigned char   *pMarshaledTargetInfo, 
                              DWORD     dwAuthSvcToUseIfOxidNotFound,
                              OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID,"FindOrCreateOXIDEntry oxid:%08x %08x oxidInfo:%x psa:%ws pMIDEntry:%x\n",
               roxid, &oxidInfo, psaResolver, pMIDEntry));
    ValidateOXID();

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    HRESULT hr = S_OK;
    BOOL    fReleaseMIDEntry = FALSE;

    // check if the OXIDEntry was created while we were resolving it.
    *ppOXIDEntry = LookupOXID(roxid, rmid);

    if (*ppOXIDEntry == NULL)
    {
        if (pMIDEntry == NULL)
        {
            // dont yet have a MIDEntry for the machine so go add it
            hr = gMIDTbl.FindOrCreateMIDEntry(rmid, psaResolver, &pMIDEntry);
            fReleaseMIDEntry = TRUE;
        }

        if (pMIDEntry)
        {
            // add a new OXIDEntry
           hr = AddOXIDEntry(roxid, &oxidInfo, pMIDEntry, ulMarshaledTargetInfoLength, pMarshaledTargetInfo, dwAuthSvcToUseIfOxidNotFound, ppOXIDEntry);
        }
    }

    if (SUCCEEDED(hr) && eResolverRef == FOCOXID_REF)
    {
        // Increment the count of references handed to us from the resolver.
        (*ppOXIDEntry)->IncResolverRef();
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    if (fReleaseMIDEntry && pMIDEntry)
    {
        // undo the reference added by FindOrCreateMIDEntry
        pMIDEntry->DecRefCnt();
    }

    ValidateOXID();
    ComDebOut((DEB_OXID,"FindOrCreateOXIDEntry pOXIDEntry:%x hr:%x\n",
        *ppOXIDEntry, hr));
    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   UpdateCachedLocalMIDEntries, public
//
//  Synopsis:   Queries the mid table for the current local mid entry; then
//              walks all current oxids in the table; any that have cached
//              pointers to the (old) local mid entry are updated with 
//              the current one.
//
//  History:    27-Nov-00  JSimmons     Created
//
//-------------------------------------------------------------------------
HRESULT COXIDTable::UpdateCachedLocalMIDEntries()
{
    const DWORD INITIAL_MIDENTRY_ARRAY_SIZE = 100;
    const DWORD MIDENTRY_ARRAY_INCREMENT = 100;
    HRESULT hr;
    MIDEntry* pCurrentLocalMIDEntry;
    OXIDEntry* pNextEntry;
    MID localMID;
    DWORD dwcOldMIDEntries = INITIAL_MIDENTRY_ARRAY_SIZE;
    DWORD dwCurrentOldMIDEntry = 0;
    MIDEntry** ppOldMIDEntries;
    DWORD i;

    // No need to walk the cleanup list, those oxid entries
    // will be going away soon anyway
    OXIDEntry* pListHeads[] = { &_InUseHead, &_ExpireHead };

    // Allocate an array to hold the old mid entries returned
    // to us by the oxid entries.  This is because you're not
    // supposed to release mid entries inside of gOXIDLock....
    ppOldMIDEntries = new MIDEntry*[dwcOldMIDEntries];
    if (!ppOldMIDEntries)
        return E_OUTOFMEMORY;
    
    ZeroMemory(ppOldMIDEntries, dwcOldMIDEntries * sizeof(MIDEntry*));
    
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);
    
    // Get the current local mid entry
    hr = gMIDTbl.GetLocalMIDEntry(&pCurrentLocalMIDEntry);
    if (SUCCEEDED(hr))
    {    
        Win4Assert(pCurrentLocalMIDEntry);
    
        // Save the mid id
        localMID = pCurrentLocalMIDEntry->GetMid();
    
        for (i = 0; i < sizeof(pListHeads) / sizeof(OXIDEntry*); i++)
        {
            pNextEntry = pListHeads[i]->_pNext;
            while (pNextEntry != pListHeads[i])
            {
                if (pNextEntry->GetMid() == localMID)
                {
                    // Check if we need to grow our array
                    if (dwCurrentOldMIDEntry == dwcOldMIDEntries)
                    {
                        MIDEntry** ppNewArray;
                        DWORD dwcNewArraySize = dwcOldMIDEntries + MIDENTRY_ARRAY_INCREMENT;
                        ppNewArray = new MIDEntry*[dwcNewArraySize];
                        if (!ppNewArray)
                        {
                            // break out of the loop. no more work will be done, 
                            // but we will cleanup what we already have saved
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        
                        // Clear new memory
                        ZeroMemory(ppNewArray, dwcNewArraySize * sizeof(MIDEntry*));
                        // Copy entries from old array
                        CopyMemory(ppNewArray, ppOldMIDEntries, dwcOldMIDEntries * sizeof(MIDEntry*));
                        // Delete old memory
                        delete ppOldMIDEntries;
                        // Update state
                        ppOldMIDEntries = ppNewArray;
                        dwcOldMIDEntries = dwcNewArraySize;                 
                    }

                    // Update the oxidentry, and save its previous
                    // mid entry for later release outside the lock
                    ppOldMIDEntries[dwCurrentOldMIDEntry++] = 
                        pNextEntry->UpdateMIDEntry(pCurrentLocalMIDEntry);
                }
                pNextEntry = pNextEntry->_pNext;
            }

            // If we broke out of the while loop with a failure,
            // then break out of the for loop as well.
            if (FAILED(hr))
            {
                break;
            }
        }        
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    
    // Release mid entries outside of gOXIDLock
    if (pCurrentLocalMIDEntry)
        pCurrentLocalMIDEntry->DecRefCnt();

    for (i = 0; i < dwCurrentOldMIDEntry; i++)
    {
        Win4Assert(ppOldMIDEntries[i]);
        if (ppOldMIDEntries[i])
        {
            ppOldMIDEntries[i]->DecRefCnt();
        }
    }

    delete ppOldMIDEntries;

    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   GetLocalOXIDEntry, public
//
//  Synopsis:   Get either the global or the TLS OXIDEntry based on the
//              threading model of the current thread.
//
//  History:    05-May-95  AlexMit      Created
//              11-Feb-98  JohnStra     Made NTA aware
//
//-------------------------------------------------------------------------
INTERNAL GetLocalOXIDEntry(OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID,"GetLocalOXIDEntry ppOXIDEntry:%x\n", ppOXIDEntry));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    *ppOXIDEntry = NULL;

    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);

    if (SUCCEEDED(hr))
    {
        hr = pComApt->GetOXIDEntry(ppOXIDEntry);
        pComApt->Release();
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"GetLocalOXIDEntry hr:%x pOXIDEntry:%x\n",
              *ppOXIDEntry, hr));
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     MIDEntry::DecRefCnt, public
//
//  Synopsis:   Decement the number of references and release if zero
//
//  History:    02-Feb-96   Rickhi      Created
//              14-Dec-98   GopalK      Interlock destruction
//
//-------------------------------------------------------------------------
DWORD MIDEntry::DecRefCnt()
{
    ComDebOut((DEB_OXID, "MIDEntry::DecRefCnt %x cRefs[%x]\n", this, _cRefs));

    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL fTryToDelete = InterlockedDecRefCnt(&_cRefs, &cNewRefs);

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry
        BOOL fActuallyDeleted = FALSE;

        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);

        if (_cRefs == CINDESTRUCTOR)
        {
            // the refcnt did not change while we acquired the lock.
            // OK to delete. Move the entry to the free list
            gMIDTbl.ReleaseMIDEntry(this);
            fActuallyDeleted = TRUE;
        }

        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);

        if (fActuallyDeleted == TRUE)
            break;  // all done. the entry has been deleted.

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&_cRefs, &cNewRefs);
    }

    return (cNewRefs & ~CINDESTRUCTOR);
}


//+------------------------------------------------------------------------
//
//  Function:   CleanupMIDEntry
//
//  Synopsis:   Called by the MID hash table when cleaning up any leftover
//              entries.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CleanupMIDEntry(SHashChain *pNode)
{
    gMIDTbl.ReleaseMIDEntry((MIDEntry *)pNode);
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTbl::Initialize, public
//
//  Synopsis:   Initializes the MID table.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CMIDTable::Initialize()
{
    ComDebOut((DEB_OXID, "CMIDTable::Initialize\n"));
    LOCK(gOXIDLock);
    _HashTbl.Initialize(MIDBuckets, &gOXIDLock);
    _palloc.Initialize(sizeof(MIDEntry), MIDS_PER_PAGE, NULL);
    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTbl::Cleanup, public
//
//  Synopsis:   Cleanup the MID table.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CMIDTable::Cleanup()
{
    ComDebOut((DEB_OXID, "CMIDTable::Cleanup\n"));

    if (_pLocalMIDEntry)
    {
        // release the local MIDEntry
        MIDEntry *pMIDEntry = _pLocalMIDEntry;
        _pLocalMIDEntry = NULL;
        pMIDEntry->DecRefCnt();
    }

    LOCK(gOXIDLock);
    _HashTbl.Cleanup(CleanupMIDEntry);
    _palloc.Cleanup();
    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::LookupMID, public
//
//  Synopsis:   Looks for existing copy of the string array in the MID table.
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
MIDEntry *CMIDTable::LookupMID(DUALSTRINGARRAY *psaResolver, DWORD *pdwHash)
{
    ComDebOut((DEB_OXID, "CMIDTable::LookupMID psa:%x\n", psaResolver));
    Win4Assert(psaResolver != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);

    *pdwHash = _HashTbl.Hash(psaResolver);
    MIDEntry *pMIDEntry = (MIDEntry *) _HashTbl.Lookup(*pdwHash, psaResolver);

    if (pMIDEntry)
    {
        // found the node, AddRef it and return
        pMIDEntry->IncRefCnt();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CMIDTable::LookupMID pMIDEntry:%x\n", pMIDEntry));
    return pMIDEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::FindOrCreateMIDEntry, public
//
//  Synopsis:   Looks for existing copy of the string array in the MID table,
//              creates one if not found
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::FindOrCreateMIDEntry(REFMID rmid,
                                        DUALSTRINGARRAY *psaResolver,
                                        MIDEntry **ppMIDEntry)
{
    ComDebOut((DEB_OXID, "CMIDTable::FindOrCreateMIDEntry psa:%x\n", psaResolver));
    Win4Assert(psaResolver != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);

    HRESULT hr = S_OK;
    DWORD   dwHash;

    *ppMIDEntry = LookupMID(psaResolver, &dwHash);

    if (*ppMIDEntry == NULL)
    {
        hr = AddMIDEntry(rmid, dwHash, psaResolver, ppMIDEntry);
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CMIDTable::FindOrCreateEntry pMIDEntry:%x hr:%x\n", *ppMIDEntry, hr));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::AddMIDEntry, private
//
//  Synopsis:   Adds an entry to the MID table. The entry is AddRef'd.
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::AddMIDEntry(REFMID rmid, DWORD dwHash,
                               DUALSTRINGARRAY *psaResolver,
                               MIDEntry **ppMIDEntry)
{
    ComDebOut((DEB_OXID, "CMIDTable::AddMIDEntry rmid:%08x %08x dwHash:%x psa:%x\n",
              rmid, dwHash, psaResolver));
    Win4Assert(psaResolver != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);

    // We must make a copy of the psa to store in the table, since we are
    // using the one read in from ReadObjRef (or allocated by MIDL).

    DUALSTRINGARRAY *psaNew;
    HRESULT hr = CopyStringArray(psaResolver, NULL, &psaNew);
    if (FAILED(hr))
        return hr;

    MIDEntry *pMIDEntry = (MIDEntry *) _palloc.AllocEntry();

    if (pMIDEntry)
    {
        pMIDEntry->Init(rmid);

        // add the entry to the hash table
        _HashTbl.Add(dwHash, psaNew, pMIDEntry->GetHashNode());

        hr = S_OK;

        // set the maximum size of any resolver PSA we have seen. This is used
        // when computing the max marshal size during interface marshaling.

        DWORD dwpsaSize = SASIZE(psaNew->wNumEntries);
        if (dwpsaSize > gdwPsaMaxSize)
        {
            gdwPsaMaxSize = dwpsaSize;
        }
    }
    else
    {
        // cant create a MIDEntry, free the copy of the string array.
        PrivMemFree(psaNew);
        hr = E_OUTOFMEMORY;
    }

    *ppMIDEntry = pMIDEntry;

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CMIDTable::AddMIDEntry pMIDEntry:%x hr:%x\n", *ppMIDEntry, hr));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::ReleaseMIDEntry, public
//
//  Synopsis:   remove the MIDEntry from the hash table and free the memory
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CMIDTable::ReleaseMIDEntry(MIDEntry *pMIDEntry)
{
    ComDebOut((DEB_OXID, "CMIDTable::ReleaseMIDEntry pMIDEntry:%x\n", pMIDEntry));
    pMIDEntry->AssertInDestructor();
    ASSERT_LOCK_HELD(gOXIDLock);

    // delete the string array
    PrivMemFree(pMIDEntry->Getpsa());

    // remove from the hash chain and delete the node
    _HashTbl.Remove(&pMIDEntry->GetHashNode()->chain);

    _palloc.ReleaseEntry((PageEntry *)pMIDEntry);
}

//+------------------------------------------------------------------------
//
//  Method:     CMIDTable::GetLocalMIDEntry, public
//
//  Synopsis:   Get or create the MID (Machine ID) entry for the local
//              machine. _pLocalMIDEntry holds the network address for the
//              local OXID resolver.
//
//  History:    05-Jan-96  Rickhi       Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::GetLocalMIDEntry(MIDEntry **ppMIDEntry)
{
    ASSERT_LOCK_HELD(gOXIDLock);
    HRESULT hr = S_OK;

    if (_pLocalMIDEntry == NULL)
    {
        // make sure we have the local resolver string bindings
        hr = gResolver.GetConnection();
        if (SUCCEEDED(hr))
        {
            CDualStringArray* pdsaLocalResolver;  // current bindings for resolver

            hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
            if (SUCCEEDED(hr))
            {
                // Create a MID entry for the Local Resolver
                hr = gMIDTbl.FindOrCreateMIDEntry(gLocalMid, pdsaLocalResolver->DSA(),
                                                  &_pLocalMIDEntry);

                pdsaLocalResolver->Release();
            }
        }
    }

    // Now we always return an addref'd midentry
    if (_pLocalMIDEntry)
        _pLocalMIDEntry->IncRefCnt();

    *ppMIDEntry = _pLocalMIDEntry;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::ReplaceLocalEntry
//
//  Synopsis:   Replaces the current _LocalMidEntry member with a new one
//              created from the supplied bindings.
//
//  History:    10-Oct-00   JSimmons   Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::ReplaceLocalEntry(DUALSTRINGARRAY* pdsaResolver)
{
    ComDebOut((DEB_OXID,"CMIDTable::ReplaceLocalEntry psa:%x\n",pdsaResolver));

    HRESULT hr = S_OK;
    MIDEntry* pMIDEntry;
    DWORD dwHash;
    BOOL bNeedToReplace = TRUE;
    MIDEntry* pOldLocalMIDEntry = NULL;
	
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);
    ASSERT_LOCK_HELD(gOXIDLock);
    
    // If we are doing this, then we should probably 
    // have an existing local mid entry
    Win4Assert(_pLocalMIDEntry);

    // Check to see if we already have the correct entry
    // cached.  Cannot use the resolver hash for this, due
    // to collisions.
    if (_pLocalMIDEntry)
    {       
        // Only replace if they are different
        bNeedToReplace = !DSACompare(
                              _pLocalMIDEntry->GetHashNode()->psaKey,
                              pdsaResolver);                                 
    }

    if (bNeedToReplace)
    {
        // Get hash for new bindings
        dwHash = _HashTbl.Hash(pdsaResolver);

        // First see if this entry is still hanging 
        // around in the table.
        pMIDEntry = LookupMID(pdsaResolver, &dwHash);
        if (!pMIDEntry)
        {
            // It's not, add it
            ASSERT_LOCK_HELD(gOXIDLock);
            hr = AddMIDEntry(gLocalMid,
                             dwHash,
                             pdsaResolver,
                             &pMIDEntry);
        }
            
        if (SUCCEEDED(hr))
        {
            // Replace local entry with the new one
            pOldLocalMIDEntry = _pLocalMIDEntry;
            _pLocalMIDEntry = pMIDEntry;
        }
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // Release the old local mid entry outside the lock
    if (pOldLocalMIDEntry)
        pOldLocalMIDEntry->DecRefCnt();

    ComDebOut((DEB_OXID, "CMIDTable::ReplaceLocalEntry _pLocalMIDEntry:%x hr:%x\n",
                          _pLocalMIDEntry, hr));
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDualStringArray methods
//

DWORD CDualStringArray::AddRef()
{
    DWORD cRef = InterlockedIncrement(&_cRef);
    return cRef;
}

DWORD CDualStringArray::Release()
{
    DWORD cRef = InterlockedDecrement(&_cRef);
    if (cRef == 0)
    {
        delete this;
    }
    return cRef;
}

CDualStringArray::~CDualStringArray()
{
    PrivMemFree(_pdsa);
}

// Helper function for allocating and copying dualstringarrays
HRESULT CopyDualStringArray(DUALSTRINGARRAY *psa, DUALSTRINGARRAY **ppsaNew)
{
    DWORD ulSize = sizeof(USHORT) + 
                   sizeof(USHORT) + 
                   (psa->wNumEntries * sizeof(WCHAR));
    
    *ppsaNew = (DUALSTRINGARRAY*)PrivMemAlloc(ulSize);
    if (*ppsaNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*ppsaNew, psa, ulSize);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\locks.cxx ===
//+-------------------------------------------------------------------
//
//  File:       locks.cxx
//
//  Contents:   functions used in DBG builds to validate the lock state.
//
//  History:    20-Feb-95   Rickhi      Created
//              20-Aug-96   Mattsmit    Functionality moved to 
//                                      OleStaticLock class
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <locks.hxx>

COleStaticMutexSem  gComLock(TRUE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\ipaddr.cxx ===
//+-------------------------------------------------------------------
//
//  File:       ipaddr.cxx
//
//  Contents:   Implements classes\code for supporting the IP address
//              cache control functionality.
//
//  Classes:    CAddrControl, CAddrExclusionList
//
//  History:    07-Oct-00   jsimmons      Created
//--------------------------------------------------------------------

#include <ole2int.h>
#include <resolver.hxx>
#include "ipaddr.hxx"

// Single instance of this object
CAddrControl gAddrControl;

// IAddrTrackingControl implementation
STDMETHODIMP CAddrControl::EnableCOMDynamicAddrTracking()
{
	return gResolver.EnableDisableDynamicIPTracking(TRUE);
}

STDMETHODIMP CAddrControl::DisableCOMDynamicAddrTracking()
{
	return gResolver.EnableDisableDynamicIPTracking(FALSE);
}

// IAddrExclusionControl implementation
STDMETHODIMP CAddrControl::GetCurrentAddrExclusionList(REFIID riid, void** ppEnumerator)
{
	HRESULT hr = S_OK;
	DWORD dwNumStrings = 0;
	LPWSTR* ppszStrings = NULL;
	CAddrExclusionList* pAddrList;

	if (!ppEnumerator)
		return E_INVALIDARG;

	*ppEnumerator = NULL;
	
	pAddrList = new CAddrExclusionList();
	if (!pAddrList) 
		hr = E_OUTOFMEMORY;
	if (SUCCEEDED(hr))
	{		
		hr = gResolver.GetCurrentAddrExclusionList(&dwNumStrings, &ppszStrings);
		if (SUCCEEDED(hr))
		{
			hr = pAddrList->AddrExclListInitialize(dwNumStrings, ppszStrings);
			if (SUCCEEDED(hr))
			{
				hr = pAddrList->QueryInterface(riid, ppEnumerator);
			}
		}

		pAddrList->Release();
	}

	return hr;
}

STDMETHODIMP CAddrControl::UpdateAddrExclusionList(IUnknown* pEnumerator)
{
	HRESULT hr;
	IEnumString* pIEnumString;

	if (!pEnumerator)
		return E_INVALIDARG;

	// All we care about right now is IEnumString
	hr = pEnumerator->QueryInterface(IID_IEnumString, (void**)&pIEnumString);
	if (FAILED(hr))
		return hr;

	// create a CAddrExclusionList object
	hr = E_OUTOFMEMORY;
	CAddrExclusionList* pAddrList = new CAddrExclusionList();
	if (pAddrList)
	{
		hr = pAddrList->AddrExclListInitialize2(pIEnumString, 0);
		if (SUCCEEDED(hr))
		{
			// CAddrExclusionList composes the new list for us 
			// into a suitable format
			DWORD dwNumStrings;
			LPOLESTR* ppszStrings;

			hr = pAddrList->GetMarshallingData(&dwNumStrings, &ppszStrings);
			if (SUCCEEDED(hr))
			{
				hr = gResolver.SetAddrExclusionList(dwNumStrings, ppszStrings);
			}
		}
		pAddrList->Release();
	}

	pIEnumString->Release();

	return hr;
}


// IUnknown implementation for CIPAddControl
STDMETHODIMP CAddrControl::QueryInterface(REFIID riid, void** ppv)
{
	if (!ppv)
		return E_POINTER;
	
	*ppv = NULL;
	
	if (riid == IID_IUnknown || riid == IID_IAddrTrackingControl)
	{
		*ppv = static_cast<IAddrTrackingControl*>(this);
		AddRef();
		return S_OK;
	}
	else if (riid == IID_IAddrExclusionControl)
	{
		*ppv = static_cast<IAddrExclusionControl*>(this);
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAddrControl::AddRef()
{
	return 1;  // global singleton
}

STDMETHODIMP_(ULONG) CAddrControl::Release()
{
	return 1;  // global singleton
}


// Function used for creating objects
HRESULT CAddrControlCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
	// just return reference on process-wide singleton
	return gAddrControl.QueryInterface(riid, ppv);
}



//
//  CAddrExclusionList implementation
// 

CAddrExclusionList::CAddrExclusionList() :
	_lRefs(1), // starts with refcount of 1!
	_dwCursor(0),
	_dwNumStrings(0),
	_ppszStrings(NULL)
{
}

CAddrExclusionList::~CAddrExclusionList()
{
	Win4Assert(_lRefs == 0);
	FreeCurrentBuffers();
}

HRESULT CAddrExclusionList::AddrExclListInitialize(
		DWORD dwNumStrings,
		LPWSTR* ppszStrings)
{
	FreeCurrentBuffers();
	
	// We now own the passed-in buffers
	_dwNumStrings = dwNumStrings;
	_ppszStrings = ppszStrings;

	return S_OK;
}

// Initialize this object from another 
HRESULT CAddrExclusionList::AddrExclListInitialize2(IEnumString* pIEnumString, DWORD dwNewCursor)
{
	HRESULT hr;
	DWORD i;
	DWORD dwNumStringsPass1;
	LPOLESTR pszString;
	LPOLESTR* ppszStrings;

	FreeCurrentBuffers();
	
	// Set new cursor position.  On success it will be correct, on
	// failure it won't matter.
	_dwCursor = dwNewCursor;

	// Make one pass to discover how many strings are in the enumerator; too
	// bad IEnum*** doesn't expose a method to retrieve this.
	hr = pIEnumString->Reset();
	if (FAILED(hr)) 
		return hr;

	dwNumStringsPass1 = 0;
	for (;;)
	{
		hr = pIEnumString->Next(1, &pszString, NULL);
		if (hr == S_OK)
		{
			dwNumStringsPass1++;
			CoTaskMemFree(pszString);
		}
		else if (hr == S_FALSE)
		{
			// no more, we're done
			break;
		}
		else
		{
			// unexpected error
			Win4Assert("Unexpected error from enumerator");
			return hr;
		}
	}

    // Check to see if user passed in an empty enumerator
    if (dwNumStringsPass1 == 0)
    {
        // yep.  nothing else to do
        return S_OK;
    }

    // Reset enumerator back to beginning
    hr = pIEnumString->Reset();
    if (FAILED(hr)) 
        return hr;

	// Allocate memory to store the caller's strings.  Use same allocator as
	// used in FreeCurrentBuffers.
	ppszStrings = (LPOLESTR*)MIDL_user_allocate(sizeof(LPOLESTR) * dwNumStringsPass1);
	if (!ppszStrings)
		return E_OUTOFMEMORY;

	ZeroMemory(ppszStrings, sizeof(LPOLESTR) * dwNumStringsPass1);

	// Make second pass, this time saving off a copy of each string
	for (i = 0; i < dwNumStringsPass1; i++)
	{
		hr = pIEnumString->Next(1, &pszString, NULL);
		switch (hr)
		{
		case S_OK:
			ppszStrings[i] = (LPOLESTR)MIDL_user_allocate(
							sizeof(WCHAR) * (lstrlen(pszString) + 1));
			if (!ppszStrings[i])
			{
				// Free buffers allocated so far
				for (i = 0; i < dwNumStringsPass1; i++)
					if (ppszStrings[i])  MIDL_user_free(ppszStrings[i]);

				MIDL_user_free(ppszStrings);

				CoTaskMemFree(pszString);

				return E_OUTOFMEMORY;
			}
			lstrcpy(ppszStrings[i], pszString);
			CoTaskMemFree(pszString);
			break;

		case S_FALSE:
			// unexpected error -- second pass had less than the first one
			Win4Assert("Weird behavior from enumerator");

			// ** Intentional fallthru here to cleanup code **
		default:
			
			// Free buffers allocated so far
			for (i = 0; i < dwNumStringsPass1; i++)
				if (ppszStrings[i])  MIDL_user_free(ppszStrings[i]);

			MIDL_user_free(ppszStrings);

			return (hr == S_FALSE ? E_UNEXPECTED : hr);
			break;
		}
	}
	
	// Done
	_dwNumStrings = dwNumStringsPass1;
	_ppszStrings = ppszStrings;

	return S_OK;
}

// 
// GetMarshallingData
// 
// Caller is responsible for making sure that this object is not in use while it's
// member data is being marshalled.
//
HRESULT CAddrExclusionList::GetMarshallingData(DWORD* pdwNumStrings, LPWSTR** pppszStrings)
{
	Win4Assert(_lRefs > 0);
	*pdwNumStrings = _dwNumStrings;
	*pppszStrings = _ppszStrings;
	return S_OK;
}

void CAddrExclusionList::FreeCurrentBuffers()
{
	Win4Assert((_dwNumStrings == 0 && _ppszStrings == 0) ||
		       (_dwNumStrings != 0 && _ppszStrings != 0));
		
	DWORD i;

	VDATEHEAP();

	for (i = 0; i < _dwNumStrings; i++)
	{
		// these strings came from rpc, so free them with m_u_f
		MIDL_user_free(_ppszStrings[i]);
	}

	if (_ppszStrings)
		MIDL_user_free(_ppszStrings);

	VDATEHEAP();
	
	_dwCursor = 0;  // reset cursor
	_dwNumStrings = 0;
	_ppszStrings = NULL;

	return;
}

// IEnumString implementation for CAddrExclusionList
STDMETHODIMP CAddrExclusionList::Next(
				ULONG ulcStrings, 
				LPOLESTR* ppszStrings, 
				ULONG* pulFetched)
{
	Win4Assert(_lRefs > 0);

	if (!ppszStrings)
		return E_INVALIDARG;

	ZeroMemory(ppszStrings, sizeof(WCHAR*) * ulcStrings);

	DWORD i;
	DWORD dwFetched = 0;

	for (i = _dwCursor; 
	     (i < _dwNumStrings) && (dwFetched < ulcStrings);
		 i++, dwFetched++)
	{
		ppszStrings[dwFetched] = (LPOLESTR)CoTaskMemAlloc(
			    sizeof(WCHAR) * (lstrlen(_ppszStrings[i]) + 1));
		if (!ppszStrings[dwFetched])
		{
			// if we get an out-of-mem error part-way thru, we free up the 
			// already allocated strings and return an error
			for (i = 0; i < ulcStrings; i++)
			{
				if (ppszStrings[i])
				{
					CoTaskMemFree(ppszStrings[i]);
					ppszStrings[i] = NULL;
				}
			}
			return E_OUTOFMEMORY;
		}

		// Copy the string
		lstrcpy(ppszStrings[dwFetched], _ppszStrings[i]);
	}
	
	// Advance the cursor
	_dwCursor += dwFetched;

	// Tell how many they got, if they care
	if (pulFetched) 
		*pulFetched = dwFetched;

	return (dwFetched == ulcStrings) ? S_OK : S_FALSE;
}


STDMETHODIMP CAddrExclusionList::Skip(ULONG celt)
{
	Win4Assert(_lRefs > 0);

	_dwCursor += celt;
	if (_dwCursor > _dwNumStrings)
	{
		_dwCursor = _dwNumStrings;
		return S_FALSE;
	}

	return S_OK;
}

STDMETHODIMP CAddrExclusionList::Reset()
{
	Win4Assert(_lRefs > 0);
	_dwCursor = 0;
	return S_OK;
}

STDMETHODIMP CAddrExclusionList::Clone(IEnumString** ppEnum)
{
	HRESULT hr;

	if (!ppEnum)
		return E_INVALIDARG;

	Win4Assert(_lRefs > 0);

	*ppEnum = NULL;

	CAddrExclusionList* pClonedList = new CAddrExclusionList();
	if (!pClonedList)
		return E_OUTOFMEMORY;

	hr = pClonedList->AddrExclListInitialize2(static_cast<IEnumString*>(this), _dwCursor);
	if (SUCCEEDED(hr))
	{
		hr = pClonedList->QueryInterface(IID_IEnumString, (void**)ppEnum);
	}
	pClonedList->Release();

	return hr;
}

// IUnknown implementation for CAddrExclusionList
STDMETHODIMP CAddrExclusionList::QueryInterface(REFIID riid, void** ppv)
{
	if (!ppv)
		return E_POINTER;
	
	Win4Assert(_lRefs > 0);

	*ppv = NULL;
	
	if (riid == IID_IUnknown || riid == IID_IEnumString)
	{
        *ppv = static_cast<IEnumString*>(this);
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAddrExclusionList::AddRef()
{
	Win4Assert(_lRefs != 0);
	return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CAddrExclusionList::Release()
{
	Win4Assert(_lRefs > 0);
	LONG lRefs = InterlockedDecrement(&_lRefs);
	if (lRefs == 0)
	{
		delete this;
	}
	return lRefs;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\ipmrshl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       ipmrshl.cpp
//
//  Contents:   Code the implements the standard free thread in process
//              marshaler.
//
//  Classes:    CFreeMarshaler
//              CFmCtrlUnknown
//
//  Functions:  CoCreateFreeThreadedMarshaler
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <stdid.hxx>

#include    "apcompat.hxx"

//+-------------------------------------------------------------------
//
//  Class:    CFreeMarshaler
//
//  Synopsis: Generic marshaling class
//
//  Methods:  IUnknown
//            IMarshal
//
//  History:  15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class CFreeMarshaler : public IMarshal, public CPrivAlloc
{
public:
                        CFreeMarshaler(IUnknown *punk);

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

                        // IMarshal Interface
    STDMETHODIMP        GetUnmarshalClass(
                            REFIID riid,
                            void *pv,
                            DWORD dwDestContext,
                            void *pvDestContext,
                            DWORD mshlflags,
                            CLSID *pCid);

    STDMETHODIMP        GetMarshalSizeMax(
                            REFIID riid,
                            void *pv,
                            DWORD dwDestContext,
                            void *pvDestContext,
                            DWORD mshlflags,
                            DWORD *pSize);

    STDMETHODIMP        MarshalInterface(
                            IStream __RPC_FAR *pStm,
                            REFIID riid,
                            void *pv,
                            DWORD dwDestContext,
                            void *pvDestContext,
                            DWORD mshlflags);

    STDMETHODIMP        UnmarshalInterface(
                            IStream *pStm,
                            REFIID riid,
                            void **ppv);

    STDMETHODIMP        ReleaseMarshalData(IStream *pStm);

    STDMETHODIMP        DisconnectObject(DWORD dwReserved);

private:
    STDMETHODIMP        InitSecret   (void);

    friend class CFmCtrlUnknown;
	
    IUnknown *_punkCtrl;                           // Server object
	
    static BYTE               _SecretBlock[16];    // A random secret block to keep people 
                                                   // from tricking us into unmarshalling 
                                                   // raw pointers out of process.
    static BOOL               _fSecretInit;        // Whether or not the secret has been 
                                                   // filled.
    static COleStaticMutexSem _SecretLock;         // Prevent races on block init
};

BOOL               CFreeMarshaler::_fSecretInit = FALSE;
BYTE               CFreeMarshaler::_SecretBlock[16];
COleStaticMutexSem CFreeMarshaler::_SecretLock;


//+-------------------------------------------------------------------
//
//  Class:    CFmCtrlUnknown
//
//  Synopsis: Controlling IUnknown for generic marshaling class.
//
//  Methods:  IUnknown
//            IMarshal
//
//  History:  15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class CFmCtrlUnknown : public IUnknown, public CPrivAlloc
{
                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void **ppv);

    STDMETHODIMP_(ULONG) AddRef(void);

    STDMETHODIMP_(ULONG) Release(void);

private:

    friend HRESULT      CFreeThreadedMarshalerCF_CreateInstance(
                                                IUnknown *punkOuter,
                                                REFIID riid,
                                                void** ppv);


    friend HRESULT      GetInProcFreeMarshaler(IMarshal **ppIM);

                        CFmCtrlUnknown(void);

                        ~CFmCtrlUnknown(void);

    CFreeMarshaler *    _pfm;

    ULONG               _cRefs;
};


//+-------------------------------------------------------------------
//
//  Function:   CFreeThreadedMarshalerCF_CreateInstance, private
//
//  Synopsis:   CreateInstance method used by the standard class factory for the
//              free threaded marshaler, i.e., for CLSID_InProcFreeMarshaler
//
//  Arguments:  [punkOuter] - controlling unknown
//              [riid] - IID asked for
//              [ppunkMarshal] - controlling unknown for marshaler.
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              E_NOINTERFACE
//
//  History:    11-Mar-98  SatishT  Created
//
//--------------------------------------------------------------------

HRESULT CFreeThreadedMarshalerCF_CreateInstance(IUnknown *punkOuter, REFIID riid, void** ppv)
{
    HRESULT hr = E_INVALIDARG;

    IUnknown *pUnk = NULL;

    // Validate the parameters
    if (((punkOuter == NULL) || IsValidInterface(punkOuter))
        && IsValidPtrOut(ppv, sizeof(void *)))
    {
        // Assume failure
        hr = E_OUTOFMEMORY;

        // Allocate new free marshal object
        CFmCtrlUnknown *pfmc = new CFmCtrlUnknown();

        if (pfmc != NULL)
        {
            if (punkOuter == NULL)
            {
                // Caller wants a non-aggreagated object
                punkOuter = pfmc;
            }

            // Initialize the pointer
            pfmc->_pfm = new CFreeMarshaler(punkOuter);

            if (pfmc->_pfm != NULL)
            {
                pUnk = pfmc;
                hr = S_OK;
            }
            else
            {
                delete pfmc;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(riid,ppv);
        pUnk->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoCreateFreeThreadedMarshaler, public
//
//  Synopsis:   Create the controlling unknown for the marshaler
//
//  Arguments:  [punkOuter] - controlling unknown
//              [ppunkMarshal] - controlling unknown for marshaler.
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
HRESULT CoCreateFreeThreadedMarshaler(
    IUnknown *punkOuter,
    IUnknown **ppunkMarshal)
{
    return CFreeThreadedMarshalerCF_CreateInstance(
                                            punkOuter,
                                            IID_IUnknown,
                                            (LPVOID*)ppunkMarshal);
}



//+-------------------------------------------------------------------
//
//  Function:   GetInProcFreeMarshaler, public
//
//  Synopsis:   Create the controlling unknown for the marshaler
//
//  Arguments:  [ppIM] - where to put inproc marshaler
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
HRESULT GetInProcFreeMarshaler(IMarshal **ppIM)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Allocate new free marshal object
    CFmCtrlUnknown *pfmc = new CFmCtrlUnknown();

    if (pfmc != NULL)
    {
        // Initialize the pointer
        pfmc->_pfm = new CFreeMarshaler(pfmc);

        if (pfmc->_pfm != NULL)
        {
            *ppIM = pfmc->_pfm;
            hr = S_OK;
        }
        else
        {
            delete pfmc;
        }
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::CFmCtrlUnknown
//
//  Synopsis:   The constructor for controling IUnknown of free marshaler
//
//  Arguments:  None
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CFmCtrlUnknown::CFmCtrlUnknown(void) : _cRefs(1), _pfm(NULL)
{
    // Header does all the work.
}




//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::~CFmCtrlUnknown
//
//  Synopsis:   The destructor for controling IUnknown of free marshaler
//
//  Arguments:  None
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CFmCtrlUnknown::~CFmCtrlUnknown(void)
{
    delete _pfm;
}




//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::QueryInterface
//
//  Returns:    S_OK
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFmCtrlUnknown::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;

    if (IsEqualGUID(iid, IID_IUnknown))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(iid, IID_IMarshal) || IsEqualGUID(iid, IID_IMarshal2))
    {
        *ppv = _pfm;
        _pfm->AddRef();
        hr = S_OK;
    }

    return hr;
}



//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFmCtrlUnknown::AddRef(void)
{
    InterlockedIncrement((LONG *) &_cRefs);

    return _cRefs;
}




//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::Release
//
//  Synopsis:   Standard stuff
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFmCtrlUnknown::Release(void)
{
    ULONG cRefs = InterlockedDecrement((LONG *) &_cRefs);

    if (cRefs == 0)
    {
        delete this;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::CFreeMarshaler()
//
//  Synopsis:   The constructor for CFreeMarshaler.
//
//  Arguments:  None
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CFreeMarshaler::CFreeMarshaler(IUnknown *punkCtrl)
    : _punkCtrl(punkCtrl)
{
    // Header does all the work.
}



//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::QueryInterface
//
//  Synopsis:   Pass QI to our controlling IUnknown
//
//  Returns:    S_OK
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::QueryInterface(REFIID iid, void **ppv)
{
     // HACKALERT: Need a way to determine if an object aggregates the FTM
     // withough calling GetUnmarshalClass.
     if (IsEqualGUID(iid, IID_IStdFreeMarshal))
     {
         *ppv = (void*)LongToPtr(0xffffffff);
         return S_OK;
     }
     return _punkCtrl->QueryInterface(iid, ppv);
}




//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::AddRef
//
//  Synopsis:   Pass AddRef to our controlling IUnknown
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFreeMarshaler::AddRef(void)
{
    return _punkCtrl->AddRef();
}




//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::Release
//
//  Synopsis:   Pass release to our controlling IUnknown
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFreeMarshaler::Release(void)
{
    return _punkCtrl->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::GetUnmarshalClass
//
//  Synopsis:   Return the unmarshaling class
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::GetUnmarshalClass(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    CLSID *pCid)
{
    // Inprocess context?
    if (dwDestContext==MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        // If this is an inproc marshal then we are the class
        // that can unmarshal.
        *pCid = CLSID_InProcFreeMarshaler;
        return S_OK;
    }

    // we can just use the static guy here and save a lot of work.
    IMarshal *pmrshlStd;
    HRESULT hr = GetStaticUnMarshaler(&pmrshlStd);

    if (pmrshlStd != NULL)
    {
        BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();

        CObjectContext *pCurrentCtx = NULL;
        if (!fUseCurrentApartment)
            pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

        hr = pmrshlStd->GetUnmarshalClass(riid, pv, dwDestContext,
                                          pvDestContext,
                                          (fUseCurrentApartment ? mshlflags : (mshlflags| MSHLFLAGS_AGILE)),
                                          pCid);
        pmrshlStd->Release();

        if (!fUseCurrentApartment)
        {
            pCurrentCtx = LeaveNTA(pCurrentCtx);
            Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::GetMarshalSizeMax
//
//  Synopsis:   Return maximum bytes need for marshaling
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::GetMarshalSizeMax(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    DWORD *pSize)
{
    // Inprocess context?
    if (dwDestContext==MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        // If this is an inproc marshal then we know the size
        *pSize = sizeof(DWORD)         // Flags
			   + sizeof(__int64)       // Pointer rounded up to 64 bits
			   + sizeof(_SecretBlock); // Secret... shhhhh!!!
        return S_OK;
    }

    // we can just use the static guy here and save a lot of work.
    IMarshal *pmrshlStd;
    HRESULT hr = GetStaticUnMarshaler(&pmrshlStd);

    if (pmrshlStd != NULL)
    {
        BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();

        CObjectContext *pCurrentCtx = NULL;
        if (!fUseCurrentApartment)
            pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

        hr = pmrshlStd->GetMarshalSizeMax(riid, pv, dwDestContext,
                                          pvDestContext,
                                          (fUseCurrentApartment ? mshlflags : (mshlflags| MSHLFLAGS_AGILE)),
                                          pSize);
        pmrshlStd->Release();

        if (!fUseCurrentApartment)
        {
            pCurrentCtx = LeaveNTA(pCurrentCtx);
            Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::InitSecret
//
//  Synopsis:   Fill our secret block with crytographically random
//              data.
//
//  History:    05-Jan-2000  JohnDoty    Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::InitSecret ()
{
    HRESULT      hr = S_OK;

    COleStaticLock lock(_SecretLock);

    // Hey, somebody beat us to it.  Good for them!
    if (_fSecretInit) return S_OK;

    // The easy way to get mostly random bits
    // (Random for all but 3 bytes)
    hr = CoCreateGuid((GUID *)_SecretBlock);
    if (SUCCEEDED(hr))
    {
        _fSecretInit = TRUE;        
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::MarshalInterface
//
//  Synopsis:   Marshal the interface
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags)
{
    HRESULT hr;

    // Inprocess context?
    if (dwDestContext==MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        void *pvNew=NULL;
        hr = ((IUnknown *) pv)->QueryInterface(riid, &pvNew);

        if (SUCCEEDED(hr))
        {
            Win4Assert(pvNew != NULL);

            // Write the marshal flags into the stream
            hr = pStm->Write(&mshlflags, sizeof(mshlflags), NULL);

            if (hr == NOERROR)
            {
                // Write the pointer into the stream
                // Cast it to an int64 so it always takes up the same amount of space
                __int64 tpv = (__int64)(pvNew);

                hr = pStm->Write(&tpv, sizeof(tpv), NULL);

                if (SUCCEEDED(hr))
                {
                    // Make sure we have filled in our random block of data
                    if (!_fSecretInit)
                        hr = InitSecret();

                    if (SUCCEEDED(hr))
                    {
                        // Write the random block into the stream
                        hr = pStm->Write(_SecretBlock, sizeof(_SecretBlock), NULL);
                    }
                }
            }

            // Bump reference count based on type of marshal
            if ((hr != NOERROR) || (mshlflags == MSHLFLAGS_TABLEWEAK))
            {
                ((IUnknown *) pvNew)->Release();
            }
        }

        return hr;
    }

    BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();

    CObjectContext *pCurrentCtx = NULL;
    if (!fUseCurrentApartment)
        pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

    // make sure the channel is initialized
    hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // Marshal the FTM object into a STDOBJREF.
        //
        hr = StdMarshalObject(pStm,
                              riid,
                              (IUnknown *) pv,
                              GetEmptyContext(),
                              dwDestContext,
                              pvDestContext,
                              (fUseCurrentApartment ? mshlflags : (mshlflags| MSHLFLAGS_AGILE)));
    }

    if (!fUseCurrentApartment)
    {
        pCurrentCtx = LeaveNTA(pCurrentCtx);
        Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::UnmarshalInterface
//
//  Synopsis:   Unmarshal the interface
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::UnmarshalInterface(
    IStream *pStm,
    REFIID riid,
    void **ppv)
{
    DWORD mshlflags;
    DWORD cbSize;
    BYTE  secret[sizeof(_SecretBlock)];

    // Initialize
    *ppv = NULL;

    // You can only unmarshal stuff you've marshaled!
    // If you marshaled something then fSecretInit is TRUE!
    if (!_fSecretInit)
        return E_UNEXPECTED;

    HRESULT hr = pStm->Read(&mshlflags, sizeof(mshlflags), &cbSize);
    if(cbSize == sizeof(mshlflags))
    {
        // Read the pointer out of the stream
        __int64 tpv;

        hr = pStm->Read(&tpv, sizeof(tpv), &cbSize);
        if(cbSize == sizeof(tpv))
        {
            // Read out the secret
            hr = pStm->Read(secret, sizeof(secret), &cbSize);
            if (cbSize == sizeof(secret))
            {
                // Make sure it's correct
                if (memcmp(_SecretBlock, secret, sizeof(_SecretBlock)) == 0)
                {
                    *ppv = (void *)(tpv);

                    // AddRef the pointer if table marshaled
                    if((mshlflags == MSHLFLAGS_TABLEWEAK) ||
                       (mshlflags == MSHLFLAGS_TABLESTRONG))
                        ((IUnknown *) *ppv)->AddRef();
                }
                else
                    hr = E_UNEXPECTED;
            }
            else
                hr = E_UNEXPECTED;
        }
        else
            hr = E_UNEXPECTED;
    }
    else
        hr = E_UNEXPECTED;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::ReleaseMarshalData
//
//  Synopsis:   Release the marshaled data
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::ReleaseMarshalData(IStream *pStm)
{
    DWORD mshlflags;
    DWORD cbSize = 0;
    BYTE  secret[sizeof(_SecretBlock)];

    // You can only release stuff you've marshaled!
    // If you marshaled something then fSecretInit is TRUE!
    if (!_fSecretInit)
        return E_UNEXPECTED;

    HRESULT hr = pStm->Read(&mshlflags, sizeof(mshlflags), &cbSize);
    if(cbSize == sizeof(mshlflags))
    {
        // Read the pointer out of the stream
        __int64 tpv;

        hr = pStm->Read(&tpv, sizeof(tpv), &cbSize);
        if(cbSize == sizeof(tpv))
        {
            // Read out the secret
            hr = pStm->Read(secret, sizeof(secret), &cbSize);
            if (cbSize == sizeof(secret))
            {
                // Make sure it's correct
                if (memcmp(_SecretBlock, secret, sizeof(_SecretBlock)) == 0)
                {
		            if(mshlflags != MSHLFLAGS_TABLEWEAK)
		                ((IUnknown *)tpv)->Release();
                }
            }
            else
            	hr = E_UNEXPECTED;
        }
        else
        	hr = E_UNEXPECTED;
    }
    else
        hr = E_UNEXPECTED;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::DisconnectObject
//
//  Synopsis:   Disconnect the object
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::DisconnectObject(DWORD dwReserved)
{
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();
    
    CObjectContext *pCurrentCtx = NULL;
    if (!fUseCurrentApartment)
        pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

    CStdIdentity *pStdId;
    hr = ObtainStdIDFromUnk(_punkCtrl, GetCurrentApartmentId(),
                            GetCurrentContext(), 0, &pStdId);
    if (SUCCEEDED(hr))
    {
        hr = pStdId->DisconnectObject(dwReserved);
        pStdId->Release();
    }
    else
    {
        // already disconnected, report success
        hr = S_OK;
    }

    // Leave if we entered the NA.
    if (!fUseCurrentApartment)
    {
        pCurrentCtx = LeaveNTA(pCurrentCtx);
        Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\crossctx.cxx ===
//+-------------------------------------------------------------------
//
//  File:       CrossCtx.cxx
//
//  Contents:   Cross context data structures
//
//  Classes:    CStdWrapper
//              CCtxChnl
//
//  History:    19-Jan-98   Gopalk      Created
//              30-Sep-98   TarunA      Lightweight p/s
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <crossctx.hxx>
#include <ctxchnl.hxx>
#include <riftbl.hxx>
#include <actprops.hxx>
#include <callobj.h>        // Callframe aka inteceptor routines
#include <excepn.hxx>       // Exception filter routines

#if DBG==1
#define INTERCEPT_NOINOUT 0x00000001
#define INTERCEPT_NOIDISP 0x00000002
#define INTERCEPT_ON      0x10000000
ULONG g_dwInterceptLevel = INTERCEPT_ON | INTERCEPT_NOINOUT;
#endif

// Forward declaration
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv);

#define CROSSCTX_SIGNATURE     (0x4E535956)

extern INTERNAL ICoGetClassObject(
    REFCLSID rclsid,
    DWORD dwContext,
    COSERVERINFO * pvReserved,
    REFIID riid,
    DWORD dwActvFlags,
    void FAR* FAR* ppvClassObj,
    ActivationPropertiesIn *pActIn);

extern INTERNAL CleanupLeakedDomainStack (COleTls& Tls, CObjectContext* pCorrectCtx);

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator CtxEntry::s_allocator;        // Allocator for CtxEntries
COleStaticMutexSem CtxEntry::s_allocLock(TRUE); // Lock for the CPageAllocator
BOOL           CtxEntry::s_fInitialized;     // Relied on being FALSE
ULONG          CtxEntry::s_cEntries;         // Relied on being 0

CPageAllocator CStdWrapper::s_allocator;     // Allocator for wrapper objects
CPageAllocator IFaceEntry::s_allocator;      // Allocator for IFaceEntries
BOOL           CStdWrapper::s_fInitialized;  // Relied on being FALSE
DWORD          CStdWrapper::s_cObjects;      // Relied on being 0

CPageAllocator CCtxChnl::s_allocator;        // Allocator for context channel
#if DBG==1
ULONG          CCtxChnl::s_cChannels;        // Relied on being 0
#endif
CStaticWrapper *gpStaticWrapper;            // Global static wrapper object

extern "C"
HRESULT __stdcall CoGetInterceptorForOle32(REFIID, 
										   IUnknown *, 
										   REFIID, 
										   void**);
   
//+-------------------------------------------------------------------
//
//  Method:     CtxEntry::DeleteCtxEntries     public
//
//  Synopsis:   Deletes all the context entries chained off the given
//              head
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CtxEntry::DeleteCtxEntries(CtxEntry *&pHead, DWORD dwFlags)
{
    if (!(dwFlags & CTXENTRYFLAG_PRIVLOCKED))
    {
        ASSERT_LOCK_HELD(gComLock);
    }

    CtxEntry *pEntry, *pNext;

    // Sanity check
    Win4Assert(pHead);

    // Loop through the list and delete each entry
    // after preparing it for destruction
    pEntry = pHead;
    do
    {
        pNext = pEntry->_pNext;
        delete pEntry;
        pEntry = pNext;
    } while(pEntry != NULL);

    if (!(dwFlags & CTXENTRYFLAG_PRIVLOCKED))
    {
        ASSERT_LOCK_HELD(gComLock);
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CtxEntry::PrepareCtxEntries     public
//
//  Synopsis:   Prepares all the context entries chained off the given
//              head for destruction
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CtxEntry::PrepareCtxEntries(CtxEntry *pHead, DWORD dwFlags)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    CtxEntry *pEntry, *pNext;

    // Sanity check
    Win4Assert(pHead);

    // Loop through the list and delete each entry
    // after preparing it for destruction
    pEntry = pHead;
    do
    {
        if(dwFlags & CTXENTRYFLAG_IDENTRY)
        {
            Win4Assert((pEntry->_cRefs == 0) || (dwFlags & CTXENTRYFLAG_DISCONNECTED));
            if(pEntry->_pPS)
                pEntry->_pPS->Release();
        }
        pEntry->_pPS = NULL;

        if (pEntry->_pLife)
        {
            pEntry->_pLife->Release();
            pEntry->_pLife = NULL;
        }

        pEntry = pEntry->_pNext;
    } while(pEntry != NULL);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CtxEntry::LookupEntry     public
//
//  Synopsis:   Looks up the context entry with the given context as
//              the client context
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CtxEntry *CtxEntry::LookupEntry(CtxEntry *pHead, CObjectContext *pClientCtx, 
                                CtxEntry **ppFreeList, DWORD dwFlags)
{
    ASSERT_LOCK_DONTCARE(gComLock);
    Win4Assert(pHead);

    // Loop through the list till an entry with the given client
    // context is found
    CtxEntry *pFound = NULL, *pEntry = pHead;
    do
    {
        if((pEntry->_pPS != NULL) &&
           (pEntry->_pPS->GetClientContext() == pClientCtx))
        {
            pFound = pEntry;
            break;
        }

        // If there is a lifetime object here, ping it....
        // This path is used by CStdMarshal.
        if (pEntry->_pLife && ppFreeList)
        {
            if (!pEntry->_pLife->IsAlive())
            {
                // Release our reference on the policy set.
                if (dwFlags & CTXENTRYFLAG_IDENTRY)
                    pEntry->_pPS->Release();
                pEntry->AddToFreeList(ppFreeList, dwFlags);
            }
        }

        pEntry = pEntry->_pNext;
    }
    while(pEntry != NULL);

    return(pFound);
}


//+-------------------------------------------------------------------
//
//  Method:     IFaceEntry::IFaceEntry     public
//
//  Synopsis:   Constructor
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
IFaceEntry::IFaceEntry(IFaceEntry *pNext,
                       void *pProxy, IRpcProxyBuffer *pRpcProxy,
                       void *pServer, IRpcStubBuffer *pRpcStub,
                       REFIID riid, CCtxChnl *pCtxChnl,
                       ICallInterceptor* pInterceptor,
                       IUnknown* pUnkInner)
{
    ASSERT_LOCK_HELD(gComLock);

    CStdWrapper *pWrapper;

    // Obtain the wrapper object
    pWrapper = pCtxChnl->GetWrapper();

    // Assert that the current context is the server context
    Win4Assert(pWrapper->GetServerContext() == GetCurrentContext());

    // Initialize
    _pNext = pNext;
    _iid = riid;
    _pHead = NULL;
    _pFreeList = NULL;

    // Save client side pointers
    _pProxy = pProxy;
    _pRpcProxy = pRpcProxy;

    // Save server side pointers
    _pServer = pServer;
    _pRpcStub = pRpcStub;

    // Save channel pointer
    _pCtxChnl = pCtxChnl;

    // Initialize lightweight p/s variables
    _pInterceptor = pInterceptor;
    _pUnkInner = pUnkInner;

    ASSERT_LOCK_HELD(gComLock);
}

//+-------------------------------------------------------------------
//
//  Method:     IFaceEntry::PrepareForDestruction     public
//
//  Synopsis:   Cleanup state associated with an IFaceEntry
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void IFaceEntry::PrepareForDestruction()
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Obtain the wrapper object
    CStdWrapper *pWrapper = _pCtxChnl->GetWrapper();

    // Assert that the current context is the server context
    Win4Assert(pWrapper->IsDisconnected() ||
               pWrapper->GetServerContext()==GetCurrentContext());

    // Release client side pointers
    pWrapper->InternalAddRef();
    ((IUnknown *) _pProxy)->Release();

    // Release the interceptor and the associated inner object and
    // any sinks that are registered with it
    if(_pInterceptor)
    {
        // This will decrement the refcount on the sink which in
        // our case is the channel
        _pInterceptor->RegisterSink(NULL);
        pWrapper->InternalAddRef();
        ((IUnknown *) _pInterceptor)->Release();
    }

    if(_pUnkInner)
        _pUnkInner->Release();

    // Release proxy/stub pointers
    if(_pRpcProxy)
    {
        _pRpcProxy->Disconnect();
        _pRpcProxy->Release();
    }

    if(_pRpcStub)
    {
        // Release server side pointers
        _pRpcStub->Disconnect();
        _pRpcStub->Release();
    }

    // Prepare CtxEntries associated with this IFaceEntry for
    // destruction
    if(_pHead)
        CtxEntry::PrepareCtxEntries(_pHead, CTXENTRYFLAG_STDWRAPPER);

    if(_pServer)
        ((IUnknown *) _pServer)->Release();

    // Release channel
    _pCtxChnl->Release();

#if DBG==1
    _pProxy = NULL;
    _pRpcProxy = NULL;
    _pRpcStub = NULL;
    _pServer = NULL;
    _pCtxChnl = NULL;
    _pInterceptor = NULL;
    _pUnkInner = NULL;
#endif

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Initialize     public
//
//  Synopsis:   Initializes allocators for CtxEntries, IFaceEntries
//              and wrapper objects. Also initializes ID tables
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Initialize()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Acquire lock
    LOCK(gComLock);

    // Sanity check
    Win4Assert(s_fInitialized == FALSE);

    // Initialize the allocators only if needed
    if(s_cObjects == 0)
    {
        // Initialize CtxEntries
        CtxEntry::Initialize();

        // Initialize IFaceEntry allocator
        IFaceEntry::s_allocator.Initialize(sizeof(IFaceEntry),
                                           IFACEENTRIES_PER_PAGE,
                                           &gComLock);
        // Initialize allocator for wrapper
        s_allocator.Initialize(sizeof(CStdWrapper), WRAPPERS_PER_PAGE,
                               &gComLock);

        // Initialize context channel
        CCtxChnl::Initialize();
    }

    // Initialize ID tables
    gPIDTable.Initialize();
    gOIDTable.Initialize();

    // Mark the state as initialized
    s_fInitialized = TRUE;

    // Release lock
    UNLOCK(gComLock);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::operator new     public
//
//  Synopsis:   new operator of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CStdWrapper::operator new(size_t size)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::operator new\n"));
    
    ASSERT_LOCK_HELD(gComLock);

    void *pv;

    // CStdWrapper can be inherited only by those objects
    // with overloaded new and delete operators
    Win4Assert(size == sizeof(CStdWrapper) &&
               "CStdWrapper improperly inherited");

    // Ensure that wrappers have been initialized
    Win4Assert(s_fInitialized);

    // Allocate memory
    pv = (void *) s_allocator.AllocEntry();
    if(pv)
        ++s_cObjects;

    ASSERT_LOCK_HELD(gComLock);
    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::operator delete     public
//
//  Synopsis:   delete operator of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::operator delete(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::operator delete\n"));
    ASSERT_LOCK_HELD(gComLock);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CStdWrapper can be inherited only by those objects
    // with overloaded new and delete operators
    LONG index = s_allocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Release the pointer
    s_allocator.ReleaseEntry((PageEntry *) pv);
    --s_cObjects;
    // Cleanup if needed
    if(s_fInitialized==FALSE && s_cObjects==0)
        PrivateCleanup();

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Cleanup     public
//
//  Synopsis:   Cleanup allocator of wrapper objects and
//              ID tables
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Cleanup()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Acquire lock
    LOCK(gComLock);

    // Check if initialized
    if(s_fInitialized)
    {
        // Ensure that there are no wrapper objects
        if(s_cObjects == 0)
            PrivateCleanup();

        // Cleanup ID tables
        gPIDTable.Cleanup();
        gOIDTable.Cleanup();

        // Reset state
        s_fInitialized = FALSE;
    }

    // Release lock
    UNLOCK(gComLock);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::PrivateCleanup     private
//
//  Synopsis:   Cleanup allocator of wrapper objects and
//              ID tables
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::PrivateCleanup()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::PrivateCleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Delete static wrapper
    if(gpStaticWrapper)
    {
        delete gpStaticWrapper;
        gpStaticWrapper = NULL;
    }

    // Cleanup allocators
    IFaceEntry::s_allocator.Cleanup();
    s_allocator.Cleanup();

    // Cleanup CtxEntries
    CtxEntry::Cleanup();

    // Cleanup context channel
    CCtxChnl::Cleanup();

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::CStdWrapper     public
//
//  Synopsis:   Constructor of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CStdWrapper::CStdWrapper(IUnknown *pServer, DWORD dwState, CIDObject *pID)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::CStdWrapper this:%x\n",this));
    ASSERT_LOCK_HELD(gComLock);

    _dwState       = dwState;
    _cRefs         = 1;
    _cCalls        = 0;
    _cIFaces       = 0;
    _pIFaceHead    = NULL;
    _pCtxEntryHead = NULL;
    _pCtxFreeList  = NULL;

    _pServer       = pServer;
    if (_pServer)
        _pServer->AddRef();

    _pID = pID;
    _pID->SetWrapper(this);
    _pID->AddRef();

    ASSERT_LOCK_HELD(gComLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::~CStdWrapper     private
//
//  Synopsis:   Destructor of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CStdWrapper::~CStdWrapper()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::~CStdWrapper this:%x\n",this));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity checks
    Win4Assert(_pID == NULL);
    Win4Assert(_pServer == NULL);

    // Delete IFaceEntries
    IFaceEntry *pIFEntry = _pIFaceHead;
    while(pIFEntry)
    {
        // Save next entry
        IFaceEntry *pIFNext = pIFEntry->_pNext;
        delete pIFEntry;
        --_cIFaces;
        pIFEntry = pIFNext;
    }
    Win4Assert(_cIFaces == 0);

    // Delete context entries
    if(_pCtxEntryHead)
        CtxEntry::DeleteCtxEntries(_pCtxEntryHead);

    ASSERT_LOCK_HELD(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::DecideDestruction     private
//
//  Synopsis:   Destroys the object after ensuring that the wrapper
//              table has not given out a reference to this object to
//              another thread
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
ULONG CStdWrapper::DecideDestruction(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::DecideDestruction\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ULONG cRefs;

    // Assert that double destruction has been prevented
    Win4Assert(!(_dwState & WRAPPERFLAG_INDESTRUCTOR));

    // Acquire lock
    LOCK(gComLock);

    // Ensure that the PID table has not given
    // out a reference to this object from a different
    // thread
    cRefs = _cRefs;
    if(cRefs == 0)
    {
		// Remove wrapper from ID object
		if(_pID && _pID->RemoveWrapper())
			_dwState |= WRAPPERFLAG_DESTROYID;
		
		// No other thread has a reference to this object
		// Mark as in destructor
		_dwState |= WRAPPERFLAG_INDESTRUCTOR;
		_cRefs = CINDESTRUCTOR;
		
		// Release lock
		UNLOCK(gComLock);
		ASSERT_LOCK_NOT_HELD(gComLock);
		
		// Cleanup state before final destruction
		PrepareForDestruction(pPS);
		
		// Acquire lock
		ASSERT_LOCK_NOT_HELD(gComLock);
		LOCK(gComLock);
		
		// Delete wrapper object
		delete this;
	}

    // Release lock
	UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::DecideDestruction returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Function:   PrepareWrapperForDestruction     private
//
//  Synopsis:   This function is called in the server context. It
//              prepares the specified wrapper for its destruction
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT PrepareWrapperForDestruction(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "PrepareWrapperForDestruction\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CStdWrapper *pWrapper = (CStdWrapper *) pv;

    // Prepare the specified wrapper for destruction
    pWrapper->PrepareForDestruction(NULL);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "PrepareWrapperForDestruction returning S_OK\n"));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::PrepareForDestruction     private
//
//  Synopsis:   Destroys the object after ensuring that the wrapper
//              table has not given out a reference to this object to
//              another thread
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::PrepareForDestruction(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::PrepareForDestruction\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Obtain current context
    CObjectContext *pCurrentCtx = GetCurrentContext();

    // Check current context
    if(!IsDisconnected() && _pID && (_pID->GetServerCtx() != GetCurrentContext()))
    {
        BOOL fRelease = FALSE;

        // Lookup policy set if not given
        if(pPS == NULL)
        {
            HRESULT hr;
            BOOL fCreate = TRUE;

            // Lookup policy set
            hr = ObtainPolicySet(pCurrentCtx, _pID->GetServerCtx(), PSFLAG_LOCAL,
                                 &fCreate, &pPS);
            fRelease = TRUE;
            if(FAILED(hr))
            {
                ContextDebugOut((DEB_ERROR,
                                 "CStdWrapper::PrepareForDestruction failed to "
                                 "obtain a policy set for contexts 0x%x-->0x%x "
                                 "with hr:0x%x\n", pCurrentCtx, _pID->GetServerCtx(),
                                 hr));
            }
        }

        // Check availability of policy set
        if(pPS)
        {
            // Switch to server context
            SwitchForCallback(pPS, PrepareWrapperForDestruction,
                              this, IID_IUnknown, 2, NULL);

            // Release policy set if not given
            if(fRelease)
                pPS->Release();
        }
    }
    else
    {
        // Currently in the server context
        // Prepare IFaceEntries for destruction
        IFaceEntry *pEntry = _pIFaceHead;
        while(pEntry)
        {
            pEntry->PrepareForDestruction();
            pEntry = pEntry->_pNext;
        }

        // Prepare object entries for destruction
        if(_pCtxEntryHead)
        {
            DWORD dwFlags = (CTXENTRYFLAG_IDENTRY | CTXENTRYFLAG_STDWRAPPER);
            dwFlags |= IsDisconnected() ? (CTXENTRYFLAG_DISCONNECTED) : 0;
            CtxEntry::PrepareCtxEntries(_pCtxEntryHead, dwFlags);
        }

        // Release IDObject
        if(_pID)
        {
            _pID->WrapperRelease();
            _pID->Release();
        }

        // Release server object, but not before calling WrapperRelease on
        // the IDObject because WrapperRelease will cause the SetZombie
        // sequence which requires a server reference to be held
        if(_pServer)
            _pServer->Release();

        _pServer = NULL;
        _pID = NULL;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::PrepareForDestruction returning\n"));
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::InternalAddRef     private
//
//  Synopsis:   Increments refcount on the wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
ULONG CStdWrapper::InternalAddRef()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::InternalAddRef\n"));

    ULONG cRefs;

    // Increment total ref count
    cRefs = InterlockedIncrement((LONG *)& _cRefs);
    // Always return 0 when inside the destructor
    if(_dwState & WRAPPERFLAG_INDESTRUCTOR)
    {
        // Nested AddRef will happen due to following
        // aggregation rules
        cRefs = 0;
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::InternalAddRef returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::InternalRelease     private
//
//  Synopsis:   Decerement refcount on the wrapper object
//              and delete the object if it drops to zero
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
ULONG CStdWrapper::InternalRelease(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::InternalRelease\n"));

    ULONG cRefs;

    // Decerement total ref count
    cRefs = InterlockedDecrement((LONG *)& _cRefs);
    // Check if this is the last release
    if(cRefs == 0)
    {
        // Avoid double destruction
        if(!(_dwState & WRAPPERFLAG_INDESTRUCTOR))
        {
            cRefs = DecideDestruction(pPS);
        }
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::InternalRelease returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetPSFactory    private
//
//  Synopsis:   Obtains the PSFactory for the given interface
//
//  History:    18-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::GetPSFactory(REFIID riid, IPSFactoryBuffer **ppIPSF)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetPSFactory\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    RIFEntry *pRIFEntry;
    CLSID psClsid;
    HRESULT hr;

    DWORD actvflags = ACTVFLAGS_NONE;

    // Obatin the clsid of the PSFactory object
    hr = gRIFTbl.GetPSClsid(riid, &psClsid, &pRIFEntry);
    if(SUCCEEDED(hr))
    {
        // Check for COM interfaces
        if (IsEqualGUID(psClsid, CLSID_PSOlePrx32))
        {
            hr = ProxyDllGetClassObject(psClsid, IID_IPSFactoryBuffer,
                                        (void **)ppIPSF);
        }
        else
        {
            // Custom interface
            DWORD dwContext = CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL | CLSCTX_NO_CODE_DOWNLOAD;
            hr = ICoGetClassObject(psClsid, dwContext, NULL,
                                   IID_IPSFactoryBuffer, actvflags,
                                   (void **)ppIPSF, NULL);
            AssertOutPtrIface(hr, *ppIPSF);
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetPSFactory returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetIFaceEntry    private
//
//  Synopsis:   Returns an existing IFaceEntry for the given IID
//
//  History:    18-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
IFaceEntry *CStdWrapper::GetIFaceEntry(REFIID riid)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetIFaceEntry\n"));

    // IFaceEntries are destroyed only when their wrapper
    // is destroyed
    ASSERT_LOCK_DONTCARE(gComLock);

    // Look for the desired interface among the
    // existing IFaceEntries
    IFaceEntry *pEntry = _pIFaceHead;
    while(pEntry)
    {
        if(IsEqualIID(pEntry->_iid, riid))
            break;
        pEntry = pEntry->_pNext;
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetIFaceEntry returning 0x%x\n", pEntry));
    return(pEntry);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdWrapper::GetOrCreateIFaceEntry   Private
//
//  Synopsis:   Finds or creates a wrapper for the given interface.
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT CStdWrapper::GetOrCreateIFaceEntry(REFIID riid, IUnknown *pUnk,
                                           CObjectContext *pClientCtx,
                                           CPolicySet *pPS, void **ppv)
{
    HRESULT hr = S_OK;

    // Check for interfaces implemented by wrapper
    *ppv = GetImplInterface(riid);

    if (*ppv == NULL)
    {
        // Check if IFaceEntry for the desired interface
        // already exists
        hr = S_OK;
        IFaceEntry *pEntry = GetIFaceEntry(riid);

        if (pEntry == NULL)
        {
            if (pUnk != NULL)
            {
                // Does not exist, try to create an IFaceEntry for
                // the new interface
                hr = CreateIFaceEntry(riid, pUnk, &pEntry);
                if (SUCCEEDED(hr))
                {
                    // we gave away the interface reference
                    Win4Assert(pEntry);
                    pUnk->AddRef();
                }
            }
            else
            {
                // We cannot create an interface entry without a
                // instance of the interface.  One solution might be to
                // do a cross context QI here....
                hr = CO_E_OBJNOTCONNECTED;
            }
        }

        if (SUCCEEDED(hr))
        {
            // make the IFaceEntry valid in the client context.

            // Acquire lock
            LOCK(gComLock);
            ASSERT_LOCK_HELD(gComLock);

            // Validate the interface for the client context
            if (pEntry->ValidateContext(pClientCtx, pPS))
            {
                *ppv = pEntry->_pProxy;
            }

            // Release the lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::CreateIFaceEntry    private
//
//  Synopsis:   Creates an IFaceEntry for a given IID
//
//  History:    18-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::CreateIFaceEntry(REFIID riid, void *pServer,
                                      IFaceEntry **ppEntry)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::CreateIFaceEntry this:%x riid:%I\n",
                    this, riid));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity checks
    Win4Assert(!GetImplInterface(riid));
    Win4Assert(!IsNotImplInterface(riid));
    Win4Assert(GetServerContext() == GetCurrentContext());

    HRESULT hr = E_FAIL;
    IFaceEntry *pEntry = NULL;
#if DBG==1
    if (g_dwInterceptLevel & INTERCEPT_ON)
#endif

    pEntry = CreateLightPS(riid, pServer, hr);

    // If we can't create a lightweight proxy-stub then we fall back to
    // creating it through the regular proxy-stub creation mechanism
    if(FAILED(hr))
    {
        // Obtain the proxy stub class factory
        IPSFactoryBuffer *pIPSF = NULL;
        hr = GetPSFactory(riid, &pIPSF);
        if(SUCCEEDED(hr))
        {
            IRpcProxyBuffer *pRpcProxy = NULL;
            void *pProxy = NULL;
            IRpcStubBuffer *pRpcStub = NULL;
            CCtxChnl *pCtxChnl = NULL;

            // Create proxy
            hr = pIPSF->CreateProxy(GetCtrlUnk(), riid, &pRpcProxy, &pProxy);
            if(SUCCEEDED(hr))
            {
                // Create stub
                hr = pIPSF->CreateStub(riid, (IUnknown *)pServer, &pRpcStub);
                if(SUCCEEDED(hr))
                {
                    // Cache proxy reference
                    // DEVNOTE: Violating aggregation rules
                    if(pProxy)
                        InternalRelease(NULL);

                    // Assume OOM
                    hr = E_OUTOFMEMORY;

                    // Create context channel
                    LOCK(gComLock);
                    pCtxChnl = new CCtxChnl(this);
                    UNLOCK(gComLock);
                    if(pCtxChnl)
                    {
                        hr = pRpcProxy->Connect(pCtxChnl);
                        if(SUCCEEDED(hr))
                        {
                            // OLE Automation proxies do not return a valid
                            // proxy pointer till the channel is connected
                            if(pProxy == NULL)
                            {
                                hr = pRpcProxy->QueryInterface(riid, &pProxy);
                                if(SUCCEEDED(hr))
                                {
                                    // Cache proxy reference
                                    // DEVNOTE: Violating aggregation rules
                                    InternalRelease(NULL);
                                }
                                else
                                    pProxy = NULL;
                            }

                            if(pProxy)
                            {
                                // Acquire lock
                                LOCK(gComLock);

                                // Ensure that some other thread has not created
                                // the IFaceEntry for the interface
                                pEntry = GetIFaceEntry(riid);
                                if(pEntry == NULL)
                                {
                                    pEntry = new IFaceEntry(_pIFaceHead, pProxy,
                                                            pRpcProxy, pServer,
                                                            pRpcStub, riid, pCtxChnl,
                                                            NULL, NULL);
                                    if(pEntry)
                                    {
                                        _pIFaceHead = pEntry;
                                        ++_cIFaces;
                                        pCtxChnl->SetIFaceEntry(pEntry);
                                    }
                                }
                                else
                                {
                                    // Force cleanup
                                    hr = E_FAIL;
                                }

                                // Release lock
                                UNLOCK(gComLock);
                            }
                        }
                    }
                }
            }

            // Cleanup in case of errors
            if(FAILED(hr))
            {
                // Release client side pointers
                if(pProxy)
                {
                    InternalAddRef();
                    ((IUnknown *) pProxy)->Release();
                }
                if(pRpcProxy)
                {
                    pRpcProxy->Disconnect();
                    pRpcProxy->Release();
                }

                // Release server side pointers
                if(pRpcStub)
                {
                    pRpcStub->Disconnect();
                    pRpcStub->Release();
                }

                // Release channel
                if(pCtxChnl)
                    pCtxChnl->Release();
            }
        }

        if(FAILED(hr) && pEntry==NULL)
        {
            // Another thread could have created the desired IFaceEntry
            pEntry = GetIFaceEntry(riid);
        }
    }

    *ppEntry = pEntry;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
              "CStdWrapper::CreateIFaceEntry hr:%x pEntry:%x\n", hr, pEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::CreateLightPS    private
//
//  Synopsis:   This function loads the interceptor dll if required.
//              Then, it constructs an interceptor for the given server
//              and creates a channel which is registered as the sink of
//              the interceptor
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
IFaceEntry* CStdWrapper::CreateLightPS(REFIID riid, void* pServer, HRESULT &hr)
{
    ContextDebugOut((DEB_WRAPPER, "CreateLightPS\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ICallInterceptor* pInterceptor = NULL;
    IUnknown* pUnkOuter = NULL;
    IUnknown* pUnkInner = NULL;
    IFaceEntry* pEntry = NULL;
    CCtxChnl *pCtxChnl = NULL;
    HINSTANCE hCallFrameLib = NULL;
    BOOL fFree = FALSE;
    LPVOID pProxy = NULL;

#if DBG==1
    if((g_dwInterceptLevel & INTERCEPT_NOIDISP) && (riid == IID_IDispatch))
    {
        hr = E_FAIL;
        return NULL;
    }
#endif

	// Create an interceptor for the given interface
	pUnkOuter = GetCtrlUnk();
	hr = CoGetInterceptorForOle32(riid, pUnkOuter, IID_IUnknown, (void**)&pUnkInner);
	if(SUCCEEDED(hr))
	{
		// QI for the interceptor interface
		hr = pUnkInner->QueryInterface(IID_ICallInterceptor, (void**)&pInterceptor);
		if(SUCCEEDED(hr))
		{
			// Release the extra addref on the outer component, per aggregation rules
			// DEVNOTE: Violating aggregation rules
			InternalRelease(NULL);
			
			// Analyze the method signatures statically.
			// If there are any in,out interface ptrs,
			// we fail immediately
			hr = GetStaticInfo(pInterceptor);
			if(SUCCEEDED(hr))
			{
				
				// QI for the desired interface
				hr = pUnkInner->QueryInterface(riid,&pProxy);
				if(SUCCEEDED(hr))
				{
					// Cache proxy reference
					// DEVNOTE: Violating aggregation rules
					InternalRelease(NULL);
					
					// Assume OOM
					hr = E_OUTOFMEMORY;
					
					// Create context channel
					LOCK(gComLock);
					pCtxChnl = new CCtxChnl(this);
					UNLOCK(gComLock);
					if(pCtxChnl)
					{
						// Register the channel as the sink for the interceptor
						// When a method is called on the interface, the interceptor "intercepts"
						// the method call and turns around and calls CCtxChnl::OnCall
						hr = pInterceptor->RegisterSink(pCtxChnl);
						if(SUCCEEDED(hr))
						{
							// Acquire lock
							LOCK(gComLock);
							
							// Ensure that some other thread has not created
							// the IFaceEntry for the interface
							pEntry = GetIFaceEntry(riid);
							if(pEntry == NULL)
							{
								// Create a new interface entry.
								pEntry = new IFaceEntry(
												_pIFaceHead,
												pProxy,
												NULL,
												pServer,
												NULL,
												riid,
												pCtxChnl,
												pInterceptor,
												pUnkInner
												);
								if(pEntry)
								{
									_pIFaceHead = pEntry;
									++_cIFaces;
									pCtxChnl->SetIFaceEntry(pEntry);
								}
							}

							UNLOCK(gComLock);
						}
						else
						{
							// Force cleanup
							hr = E_FAIL;
						}
					}
				}
			}
		}
	}

    if(FAILED(hr))
    {
        // Cleanup resources
        if(pInterceptor)
        {
            // Remove any sinks registered with the interceptor
            pInterceptor->RegisterSink(NULL);
            InternalAddRef();
            pInterceptor->Release();
        }

        if(pProxy)
        {
            InternalAddRef();
            ((IUnknown *) pProxy)->Release();
        }

        if(pUnkInner)
            pUnkInner->Release();

        if(pCtxChnl)
            ((IUnknown *) (IRpcChannelBuffer2 *)pCtxChnl)->Release();
    }

    if(FAILED(hr) && pEntry==NULL)
    {
        // Another thread could have created the desired IFaceEntry
        LOCK(gComLock);
        pEntry = GetIFaceEntry(riid);
        UNLOCK(gComLock);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,"CStdWrapper::CreateLightPS returning 0x%x\n", pEntry));
    return(pEntry);
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetStaticInfo    private
//
//  Synopsis:   Get static type information about the methods in the interface
//              If there are any methods with [in,out] parameters, we fail
//              and use RPC proxy/stub.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::GetStaticInfo(ICallInterceptor* pInterceptor)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    ULONG cMethod = 0;
    CALLFRAMEINFO info = {0,};

    // Find out if the interface supports IDispatch
    hr = pInterceptor->GetIID(NULL,&info.fDerivesFromIDispatch,&cMethod,NULL);
    if(SUCCEEDED(hr))
    {
        ULONG cStart = 3;

        // The interface must have at least 3 methods
        // of the IUnknown interface
        Win4Assert(3 <= cMethod);

        // Sanity check
        Win4Assert(GetCurrentContext() == GetServerContext());

        if(info.fDerivesFromIDispatch)
        {
#if DBG==1
            if(g_dwInterceptLevel & INTERCEPT_NOIDISP)
            {
                return E_FAIL;
            }
#endif

            // Skip over the IDispatch methods because we know that
            // there are no [in,out] interface pointers in them
            cStart += 4;

            // Sanity check
            Win4Assert(7 <= cMethod);
        }

        // Start asking for information after the 3 methods of the IUnknown
        for(ULONG iMethod = cStart; iMethod < cMethod; iMethod++)
        {
            hr = pInterceptor->GetMethodInfo(iMethod,&info,NULL);
            if(SUCCEEDED(hr))
            {
                // Check for [in,out] interface ptrs
                if(0 != info.cInOutInterfacesMax)
                {
                    // We don't support [in,out] interface ptrs
                    // Fall back to the regular proxy stub code
                    hr = E_FAIL;
                    break;
                }
            }
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CrossCtxQIFn                Internal
//
//  Synopsis:   QIs the specified object for the desired interface
//              If object supports the interface, builds IFaceEntry
//              for it and returns it in the out parameter
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXCtxQIData
{
    const IID *pIID;
    CStdWrapper *pStdWrapper;
    IFaceEntry *pEntry;
} XCtxQIData;

HRESULT __stdcall CrossCtxQIFn(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CrossCtxQIFn\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    XCtxQIData *pXCtxQIData = (XCtxQIData *) pv;
    CStdWrapper *pWrapper;
    IUnknown *pUnk, *pServer;

    // QI the server for the desired interface
    pServer = pXCtxQIData->pStdWrapper->GetServer();
    pWrapper = pXCtxQIData->pStdWrapper;
    hr = pServer->QueryInterface(*pXCtxQIData->pIID, (void **) &pUnk);
    if(SUCCEEDED(hr))
    {
        // Create IFaceEntry for the new interface
        hr = pWrapper->CreateIFaceEntry(*pXCtxQIData->pIID, pUnk, &pXCtxQIData->pEntry);
        if(FAILED(hr))
            pUnk->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CrossCtxQIFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   PerformCallback         Internal
//
//  Synopsis:   Switches out of client context for performing callback
//              specified
//
//  History:    29-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT PerformCallback(CObjectContext *pServerCtx, PFNCTXCALLBACK pfnCallback,
                        void *pv, REFIID riid, ULONG iMethod, IUnknown *pUnk)
{
    ContextDebugOut((DEB_WRAPPER, "PerformCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    CObjectContext *pCurrentCtx;

    // Obtain current context
    pCurrentCtx = GetCurrentContext();

#if DBG==1

    if (!pfnCallback)
    {
        // Sanity checks for SWC
        // We're switching contexts, but always within the same apartment
        Win4Assert (pCurrentCtx != pServerCtx);
        Win4Assert (pCurrentCtx->GetComApartment() == pServerCtx->GetComApartment());
    }

#endif

    // Check for the need to switch context
    if(pCurrentCtx == pServerCtx)
    {
        // Call the callback function directly
        hr = pfnCallback(pv);
    }
    else
    {
        CPolicySet *pPS;
        BOOL fCreate = TRUE;

        // Obtain policy set between the current context and server context
        hr = ObtainPolicySet(pCurrentCtx, pServerCtx, PSFLAG_LOCAL,
                             &fCreate, &pPS);
        if(SUCCEEDED(hr))
        {
            // Delegate to SwitchForCallback function
            hr = SwitchForCallback(pPS, pfnCallback, pv, riid, iMethod, pUnk);

            // Release policy set
            pPS->Release();
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "PerformCallback returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   SwitchForCallback            Internal
//
//  Synopsis:   Switches out of client context for performing callback
//              specified
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT SwitchForCallback(CPolicySet *pPS, PFNCTXCALLBACK pfnCallback,
                          void *pv, REFIID riid, ULONG iMethod,
                          IUnknown *pUnk)
{
    ContextDebugOut((DEB_WRAPPER, "SwitchForCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;         // hresult for infrastructure calls
    HRESULT hrCallback = S_OK; // hresult from the actual callback
    HRESULT hrPolicy = S_OK;   // hresult set by any of the policies
    RPCOLEMESSAGE message;

    // Initialize the message
    memset(&message, 0, sizeof(RPCOLEMESSAGE));
    message.iMethod = iMethod;
    //message.Buffer = pv;

    // Create rpc call object on the stack
    CRpcCall rpcClient(pUnk, &message, riid, hrPolicy, CALLSOURCE_CROSSCTX);

    // Check if there is a client context
    if(pPS->GetClientContext())
    {
        CCtxCall* pclientCall = NULL, * pserverCall = NULL;
        BOOL bFreeClientCall = FALSE, bFreeServerCall = FALSE;
        
        // Create a client side context call object
        CCtxCall stackclientCall(CTXCALLFLAG_CLIENT, NDR_LOCAL_DATA_REPRESENTATION);
        void *pvExtent = NULL;

        if (pfnCallback)
            pclientCall = &stackclientCall;
        else
        {
            // Allocate on the heap because we need this object to last until the next
            // call to CoLeaveServiceDomain
            pclientCall = new CCtxCall (CTXCALLFLAG_CLIENT, NDR_LOCAL_DATA_REPRESENTATION);
            if (!pclientCall)
                hr = E_OUTOFMEMORY;
            else
                bFreeClientCall = TRUE;
        }

        if (SUCCEEDED (hr))
        {
            // Size the buffer as needed
            hr = pPS->GetSize(&rpcClient, CALLTYPE_SYNCCALL, pclientCall);
            if(SUCCEEDED(hr))
            {
                // Allocate memory for policies that wish to send data
                if(pclientCall->_cbExtent)
                {
                    pvExtent = PrivMemAlloc8(pclientCall->_cbExtent);
                    if (!pvExtent)
                        hr = E_OUTOFMEMORY;

                    pclientCall->_pvExtent = pvExtent;
                }

                if (SUCCEEDED (hr))
                {
                    // Deliver client side call events
                    hr = pPS->FillBuffer(&rpcClient, CALLTYPE_SYNCCALL, pclientCall);
                    // Reset state inside context call object
                    CPolicySet::ResetState(pclientCall);
                
                    if(SUCCEEDED(hr))
                    {
                        CObjectContext* pSavedCtx = NULL;
                        
                        // Create a server side context call object
                        CCtxCall stackserverCall(CTXCALLFLAG_SERVER, NDR_LOCAL_DATA_REPRESENTATION);

                        if (pfnCallback)
                            pserverCall = &stackserverCall;
                        else
                        {
                            // Allocate on the heap because we need this object to last until the next
                            // call to CoLeaveServiceDomain
                            pserverCall = new CCtxCall (CTXCALLFLAG_SERVER, NDR_LOCAL_DATA_REPRESENTATION);
                            if (!pserverCall)
                                hr = E_OUTOFMEMORY;
                            else
                                bFreeServerCall = TRUE;
                        }

                        if(SUCCEEDED(hr))
                        {
                            // Set the client extent pointer inside server context call object
                            pserverCall->_pvExtent = pvExtent;

                            // Update message
                            message.reserved1 = pserverCall;

                            // Enter server context
                            hrPolicy = EnterForCallback(&message, pPS, pfnCallback,
                                                        pv, riid, iMethod, NULL, &hrCallback, &pSavedCtx);
                        }

                        if (pfnCallback)
                        {
                            // Store the server object's hr
                            rpcClient.SetServerHR(hrCallback);
                        }
                        else if (SUCCEEDED (hr) && SUCCEEDED (hrPolicy))
                        {
                            // Push objects onto tls, so we can recover them
                            // on the next CoLeaveServiceDomain
                            ContextStackNode csnNode =
                            {
                                NULL,
                                pSavedCtx,
                                pPS->GetServerContext(),
                                pclientCall,
                                pserverCall,
                                pPS
                            };

                            // Balanced by callers of PopServiceDomainContext if Push succeeds
                            pPS->AddRef();

                            hr = PushServiceDomainContext (csnNode);
                            if (SUCCEEDED (hr))
                            {
                                // Don't free the objects right now
                                bFreeClientCall = bFreeServerCall = FALSE;
                            }
                            else
                            {
                                pPS->Release();
                            }
                        }
                    }

                    if (pfnCallback)
                        // Perform typical return actions after delivering a call
                        hr = SwitchAfterCallback (pPS, rpcClient, pclientCall, pserverCall);
                }
            }
        }
        
        // Clean up in case of errors in SWC path
        if (bFreeClientCall)
            delete pclientCall;
        if (bFreeServerCall)
            delete pserverCall;
    }
    else
    {
        CObjectContext* pSavedCtx = NULL;
        
        Win4Assert (pfnCallback && "Cannot switch apartments without a callback");
        
        // X-Apartment call
        Win4Assert(GetCurrentContext() == GetEmptyContext());

        // Update message
        COleTls Tls;
        message.reserved1 = Tls->pCallInfo->GetServerCtxCall();

        // Enter server context
        hr = EnterForCallback(&message, pPS, pfnCallback,
                              pv, riid, iMethod, NULL, &hrCallback, &pSavedCtx);
    }	

    // We return S_OK, or an error from one of the following three hresults;
    // policy-set hresults have first precedence, followed by the infrastructure 
    // errors, followed by the actual callback result
    HRESULT hrFinal;
    hrFinal = (FAILED(hrPolicy)) ? hrPolicy : 
                (FAILED(hr)) ? hr :
                  hrCallback;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "SwitchForCallback returning hr:0x%x\n", hrFinal));
    return (hrFinal);
}


//+-------------------------------------------------------------------
//
//  Function:   SwitchAfterCallback            Internal
//
//  Synopsis:   Cleans up after SwitchForCallback
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT SwitchAfterCallback (CPolicySet *pPS, CRpcCall& rpcClient, CCtxCall* pClientCall, CCtxCall* pServerCall)
{
    HRESULT hr;

    void* pvExtent = pClientCall->_pvExtent;
    
    // Set the server extent pointer inside client context call object
    pClientCall->_pvExtent = pServerCall->_pvExtent;
                            
    // Deliver client side notification events
    hr = pPS->Notify(&rpcClient, CALLTYPE_SYNCRETURN, pClientCall);

    // Free client buffer
    if(pvExtent)
        PrivMemFree8(pvExtent);

    // Free server buffer
    if(pClientCall->_pvExtent)
        PrivMemFree8(pClientCall->_pvExtent);

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   EnterServiceDomain            Internal
//
//  Synopsis:   Enters an SWC service domain
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT EnterServiceDomain (IObjContext* pObjContext)
{
    CoVrfNotifyEnterServiceDomain();

    return pObjContext->DoCallback (NULL, NULL, IID_NULL, 0xffffffff);
}


//+-------------------------------------------------------------------
//
//  Function:   LeaveServiceDomain            Internal
//
//  Synopsis:   Leaves an SWC service domain
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT LeaveServiceDomain (IObjContext** ppObjContext)
{
    HRESULT hr;

    Win4Assert (ppObjContext);
    *ppObjContext = NULL;

    ContextStackNode csnCtxNode = {0};

    CObjectContext* pServerCtx = GetCurrentContext();
    Win4Assert (pServerCtx);

    COleTls Tls (hr);
    if (FAILED (hr)) return hr;

    if (Tls->pContextStack && Tls->pContextStack->pServerContext != pServerCtx)
    {
        CoVrfNotifyExtraLeaveServiceDomain();
        return CONTEXT_E_NOCONTEXT;
    }

    CoVrfNotifyLeaveServiceDomain();

    hr = PopServiceDomainContext (&csnCtxNode);
    if (SUCCEEDED (hr))
    {
        HRESULT hrCallback = S_OK, hrRet = S_OK;

        CPolicySet* pPS = csnCtxNode.pPS;
        CCtxCall* pClientCall = csnCtxNode.pClientCall;
        CCtxCall* pServerCall = csnCtxNode.pServerCall;
        CObjectContext* pSavedCtx = csnCtxNode.pSavedContext;

        // Initialize a 'fake' message
        RPCOLEMESSAGE rpcoleMessage;
        memset (&rpcoleMessage, 0, sizeof (RPCOLEMESSAGE));
        rpcoleMessage.iMethod = 0xffffffff;

        // Initialize a fake unknown
        IUnknown* pUnk = NULL;

        // Initialize a 'fake' rpccall
        CRpcCall rpcCall (pUnk, &rpcoleMessage, IID_NULL, hrRet, CALLSOURCE_CROSSCTX);

        // Addref the context for CoLeave
        pServerCtx->AddRef();

        // Unwind the stack from the callback
        hr = EnterAfterCallback (&rpcoleMessage, pPS, &hrCallback, S_OK, rpcCall, 
                            pServerCtx, pSavedCtx, pServerCall, FALSE, FALSE);

        if (SUCCEEDED (hr))
        {
            hr = SwitchAfterCallback (pPS, rpcCall, pClientCall, pServerCall);
            if (SUCCEEDED (hr))
            {
                *ppObjContext = pServerCtx;
                pServerCtx = NULL;
            }
        }
        else
        {
            // Clean up extent data on failure
            if (pClientCall->_pvExtent)
            {
                PrivMemFree8 (pClientCall->_pvExtent);
            }

            if (pServerCall->_pvExtent && pServerCall->_pvExtent != pClientCall->_pvExtent)
            {
                PrivMemFree8 (pServerCall->_pvExtent);
            }

            pClientCall->_pvExtent = NULL;
            pServerCall->_pvExtent = NULL;
        }

        pPS->Release();

        // Release the server context if we're not returning it
        if (pServerCtx)
        {
            pServerCtx->Release();
        }

        delete pClientCall;
        delete pServerCall;
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CheckContextAfterCall            Internal
//
//  Synopsis:   Cleans up when a call is delivered and an SWC context is leaked
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
BOOL CheckContextAfterCall (COleTls& Tls, CObjectContext* pCorrectCtx)
{
    if (Tls->pCurrentCtx != pCorrectCtx)
    {
        // This should only happen when we return from a COM call
        // where the callee leaked an SWC context
        HRESULT hr = CleanupLeakedDomainStack (Tls, pCorrectCtx);
        Win4Assert (SUCCEEDED (hr));

        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:   EnterForCallback            Internal
//
//  Synopsis:   Enters server context for doing work specified
//              in the work function
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT EnterForCallback(RPCOLEMESSAGE *pMessage, CPolicySet *pPS,
                         PFNCTXCALLBACK pfnCallback, void *pv,
                         REFIID riid, ULONG iMethod, IUnknown *pUnk, HRESULT* phrCallback,
                         CObjectContext** ppSavedCtx)
{
    ContextDebugOut((DEB_WRAPPER, "EnterForCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName, sizeof(iidName)/sizeof(*iidName));

        ContextDebugOut((DEB_TRACECALLS,
                         "EnterForCallback on interface %I (%ws) method 0x%x\n",
                         &riid, iidName, iMethod));
    }
#endif

    HRESULT hr = S_OK;         // hresult set by infrastructure calls
    HRESULT hrPolicy = S_OK;   // hresult set by server side policies
    CCtxCall *pCtxCall;
    COleTls Tls;
    CObjectContext *pServerCtx, *pSavedCtx;

    // Create rpc call object on the stack
    CRpcCall rpcServer(pUnk, pMessage, riid, hrPolicy, CALLSOURCE_CROSSCTX);

    // Obtain server side context call object
    pCtxCall = (CCtxCall *) pMessage->reserved1;
    Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SERVER);

    // Initialize the data represenation field in the message
    pMessage->dataRepresentation = pCtxCall->_dataRep;

    // Obtain server object context
    pServerCtx = pPS->GetServerContext();

    // Save current context
    pSavedCtx = Tls->pCurrentCtx;

    // Switch to the server object context
    Tls->pCurrentCtx = pServerCtx;
    Tls->ContextId = pServerCtx->GetId();
    pServerCtx->InternalAddRef();
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                     pSavedCtx, pServerCtx));

    // Ensure that the thread is in the right apartment.
    BOOL fEnteredNA = FALSE;
    BOOL fExitedNA = FALSE;
    if (pServerCtx->GetComApartment() == gpNTAApartment)
    {
        // Server is in the NA.  If the thread is currently not in the
        // the NA, switch it into it now.
        
        if (!IsThreadInNTA())
        {
            Tls->dwFlags |= OLETLS_INNEUTRALAPT;
            fEnteredNA = TRUE;
        }
    }
    else if (IsThreadInNTA())
    {
        // Server is not in the NA.  Switch out of the NA now.
        
        Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
        fExitedNA = TRUE;
    }
    Win4Assert(!IsThreadInNTA() || pServerCtx->GetComApartment() == gpNTAApartment);
    Win4Assert(IsThreadInNTA() || pServerCtx->GetComApartment() != gpNTAApartment);

    // Deliver server side notification events
    hr = pPS->Notify(&rpcServer, CALLTYPE_SYNCENTER, pCtxCall);
    Win4Assert(hr != RPC_E_INVALID_HEADER);

    // Delegate to callback if we have one
    // We won't have one when we're entering 
    // a context without components (SWC)
    if (pfnCallback)
    {
        if(SUCCEEDED(hr))
        {
            *phrCallback = pfnCallback(pv);
        }

        // Note - we clobber hr from Notify because that's what the original code did...
        hr = EnterAfterCallback (pMessage, pPS, phrCallback, 
            hrPolicy, rpcServer, pServerCtx, pSavedCtx, pCtxCall, fEnteredNA, fExitedNA);
    }

    *ppSavedCtx = pSavedCtx;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "EnterForCallback returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   EnterAfterCallback            Internal
//
//  Synopsis:   Cleans up after EnterForCallback
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT EnterAfterCallback(RPCOLEMESSAGE *pMessage, CPolicySet *pPS, HRESULT* phrCallback,
                         HRESULT hrPolicy, CRpcCall& rpcServer, CObjectContext* pServerCtx, CObjectContext* pSavedCtx,
                         CCtxCall* pCtxCall, BOOL fEnteredNA, BOOL fExitedNA)
{
    COleTls Tls;
    HRESULT hr;
    
    // Make the result of the call available to server-side policies
    rpcServer.SetServerHR(*phrCallback);

    // Initailize
    pMessage->cbBuffer = 0;
    CPolicySet::ResetState(pCtxCall);

    // Obtain the buffer size needed by the server side policies
    // GetSize will fail on the server side only if no policy
    // expressed interest in sending data to the client side
    pPS->GetSize(&rpcServer, CALLTYPE_SYNCLEAVE, pCtxCall);

    // Allocate buffer if server side
    // policies wish to send buffer to the client side
    if(pCtxCall->_cbExtent)
        pCtxCall->_pvExtent = PrivMemAlloc8(pCtxCall->_cbExtent);

    // Deliver server side call events
    hr = pPS->FillBuffer(&rpcServer, CALLTYPE_SYNCLEAVE, pCtxCall);

    // Switch back to the saved context
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                     pSavedCtx, Tls->pCurrentCtx));

    // Make sure we're back on the right context
    CheckContextAfterCall (Tls, pServerCtx);

    pServerCtx->InternalRelease();

    Win4Assert(pSavedCtx);
    Tls->pCurrentCtx = pSavedCtx;
    Tls->ContextId = pSavedCtx->GetId();

    // We return either S_OK, or an error.  An error set by a policy has first
    // precedence, followed by an infrastructure error.
    HRESULT hrFinal;
    hrFinal = (FAILED(hrPolicy)) ? hrPolicy : hr;

    // If we switched the thread into or out of the NA, switch it
    // back now.
    if (fEnteredNA)
    {
        Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
    }
    else if (fExitedNA)
    {
        Tls->dwFlags |= OLETLS_INNEUTRALAPT;
    }
    Win4Assert(!IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() == gpNTAApartment);
    Win4Assert(IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() != gpNTAApartment);

    return hrFinal;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetImplInterface      private
//
//  Synopsis:   Returns the implemented inteface
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CStdWrapper::GetImplInterface(REFIID riid)
{
    void *pv;

    if(IsEqualIID(riid, IID_IStdWrapper))
        pv = this;
    else if(IsEqualIID(riid, IID_IUnknown))
        pv = (IUnknown *) this;
    else if(IsEqualIID(riid, IID_IMarshal))
        pv = (IMarshal *) this;
    else if(IsEqualIID(riid, IID_IMarshal2))
        pv = (IMarshal2 *) this;
    else
        pv = NULL;

    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::IsNotImplInterface      private
//
//  Synopsis:   Returns TRUE if it is a system interface not implemented
//              by wrapper
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
BOOL CStdWrapper::IsNotImplInterface(REFIID riid)
{
    BOOL fNotImpl = FALSE;

    if(IsEqualIID(riid, IID_IStdIdentity))
        fNotImpl = TRUE;

    return(fNotImpl);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::InternalQI      private
//
//  Synopsis:   Internal QI behavior of wrapper object
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::InternalQI(REFIID riid, void **ppv,
                                BOOL fQIServer, BOOL fValidate,
                                CtxEntry *pWrapperEntry)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::InternalQI\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;

    *ppv = GetImplInterface(riid);
    if(*ppv == NULL)
    {
        if(IsDisconnected())
        {
            hr = RPC_E_DISCONNECTED;
        }
        else
        {
            CPolicySet *pPS = pWrapperEntry ? pWrapperEntry->_pPS : NULL;
            CObjectContext *pCurrentCtx = GetCurrentContext();
            hr = E_NOINTERFACE;

            // Check for an existing existing IFaceEntry
            IFaceEntry *pEntry = GetIFaceEntry(riid);

            // Check if a matching IFaceEntry was found
            if(pEntry == NULL && fQIServer)
            {
                // Sanity checks
                Win4Assert(GetCurrentContext() != _pID->GetServerCtx());
                hr = CrossCtxQI(pPS, riid, &pEntry);
            }

            if(pEntry)
            {
                // Initialize
                *ppv = pEntry->_pProxy;

                // Validate current context for the interface
                if(fValidate)
                {
                    // Acquire lock
                    LOCK(gComLock);

                    if(!pEntry->ValidateContext(pCurrentCtx, pPS))
                    {
                        *ppv = NULL;
                        hr = E_OUTOFMEMORY;
                    }

                    // Release lock
                    UNLOCK(gComLock);
                }
            }
        }
    }

    // Check for success
    if(*ppv)
    {
        // DEVNOTE: violating aggregation rules
        if(fValidate && pWrapperEntry)
            pWrapperEntry->AddRef();
        InternalAddRef();
        hr = S_OK;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::InternalQI returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::QueryInterface     public
//
//  Synopsis:   QI behavior of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::QueryInterface(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::QueryInterface\n"));

    HRESULT hr = RPC_E_WRONG_THREAD;
    BOOL fLegal = FALSE;
    CtxEntry *pWrapperEntry = NULL;

    // Check legality of caller context for this object
    CObjectContext *pCurrentCtx = GetCurrentContext();
    if(IsDisconnected())
    {
        pWrapperEntry = NULL;
        fLegal = TRUE;
    }
    // Check if the object has been exposed to any  client contexts
    else if(_pCtxEntryHead)
    {
        // Lookup wrapper entry for the current context
        pWrapperEntry = CtxEntry::LookupEntry(_pCtxEntryHead, pCurrentCtx);
        if(pWrapperEntry)
            fLegal = TRUE;
    }

    // Delegate to internalQI
    if(fLegal)
        hr = InternalQI(riid, ppv, TRUE, TRUE, pWrapperEntry);
    else
    {
        CoVrfNotifySmuggledWrapper(IID_IUnknown, 0, this);

        ContextDebugOut((DEB_WARN, "Wrapper object was passed illegally to "
                                   "the client context 0x%x\n", pCurrentCtx));
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::QueryInterface returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::AddRef     public
//
//  Synopsis:   AddRef behavior wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdWrapper::AddRef()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::AddRef\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ULONG cRefs = 0;

    // Check legality of caller context for this object
    CObjectContext *pCurrentCtx = GetCurrentContext();
    if(IsDisconnected() || (_pID->GetServerCtx() == pCurrentCtx))
    {
        cRefs = InternalAddRef();
    }
    // Check if the object has been exposed to any client contexts
    else if(_pCtxEntryHead)
    {
        CtxEntry *pWrapperEntry;

        // Lookup wrapper entry for the current context
        pWrapperEntry = CtxEntry::LookupEntry(_pCtxEntryHead, pCurrentCtx);
        if(pWrapperEntry)
        {
            // Increment ref count for the current client context
            cRefs = pWrapperEntry->AddRef();
            InternalAddRef();
        }
    }

    if(cRefs == 0)
    {
        CoVrfNotifySmuggledWrapper(IID_IUnknown, 1, this);

        ContextDebugOut((DEB_WARN, "Wrapper object was passed illegally to "
                                   "the client context 0x%x\n", pCurrentCtx));
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Release     public
//
//  Synopsis:   Decerement refcount on the wrapper object
//              and delete the object if it drops to zero
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdWrapper::Release()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Release\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ULONG cRefs = 0;
    BOOL fLegal = FALSE;

    // Check legality of caller context for this object
    CObjectContext *pCurrentCtx = GetCurrentContext();
    if(IsDisconnected() || (_pID->GetServerCtx() == pCurrentCtx))
    {
        cRefs = InternalRelease(NULL);
        fLegal = TRUE;
    }
    // Check if the object has been exposed to any client contexts
    else if(_pCtxEntryHead)
    {
        CtxEntry *pWrapperEntry;

        // Lookup wrapper entry for the current context
        pWrapperEntry = CtxEntry::LookupEntry(_pCtxEntryHead, pCurrentCtx);
        if(pWrapperEntry)
        {
            // Decrement ref count for the current client context
            CPolicySet *pPS = ReleaseCtxEntry(pWrapperEntry);

            // Check if this is the last release for the
            // current client context
            if(pPS && _pIFaceHead)
            {
                IFaceEntry *pIFEntry = _pIFaceHead;

                // Inform IFaceEntries to invalidate current
                // context as a valid client context
                LOCK(gComLock);
                while(pIFEntry)
                {
                    pIFEntry->RemoveCtxEntry(pCurrentCtx);
                    pIFEntry = pIFEntry->_pNext;
                }
                UNLOCK(gComLock);
            }

            // The current context has a legal reference on the
            // wrapper object
            cRefs = InternalRelease(pPS);
            fLegal = TRUE;
            if(pPS)
                pPS->Release();
        }
    }

    if(!fLegal)
    {
        CoVrfNotifySmuggledWrapper(IID_IUnknown, 2, this);

        ContextDebugOut((DEB_WARN, "Wrapper object was passed illegally to "
                                   "the client context 0x%x\n", pCurrentCtx));
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::Release returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetUnmarshalClass     public
//
//  Synopsis:   Returns the unmarshaler CLSID
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::GetUnmarshalClass(REFIID riid, LPVOID pv,
                                            DWORD dwDestCtx, LPVOID pvDestCtx,
                                            DWORD mshlflags, LPCLSID pClsid)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetUnmarshalClass\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Check destination context and marshal flags
	if (CanWrapperMarshal(dwDestCtx, mshlflags))
	{
        // Return wrapper unmarshaler classid
        *pClsid = CLSID_StdWrapper;
    }
    else
    {
        // Return standard unmarshaler classid
        *pClsid = CLSID_StdMarshal;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetUnmarshalClass returning 0x%x\n", S_OK));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetMarshalSizeMax     public
//
//  Synopsis:   Returns the size of marshal data
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::GetMarshalSizeMax(REFIID riid, LPVOID pv,
                                            DWORD dwDestCtx, LPVOID pvDestCtx,
                                            DWORD mshlflags, LPDWORD pSize)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetMarshalSizeMax\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Check destination context and marshal flags
	if(CanWrapperMarshal(dwDestCtx, mshlflags))
    {
		*pSize = sizeof(XCtxMarshalData);
		hr = S_OK;
    }
    else
    {
        hr = MarshalSizeHelper(dwDestCtx, pvDestCtx, mshlflags,
                               _pID->GetServerCtx(), TRUE, pSize);
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetMarshalSizeMax returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::MarshalServer           public
//
//  Synopsis:   Marshals the specified interface.
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::MarshalServer(CPolicySet *pPS, IStream *pStm, REFIID riid,
                                   DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::MarshalServer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity checks
    Win4Assert(((dwDestCtx==MSHCTX_CROSSCTX) && !(mshlflags & MSHLFLAGS_TABLEWEAK)) || IsThreadInNTA());

    // Get Local OXID Entry
    OXIDEntry *pOXIDEntry;
    HRESULT hr = GetLocalOXIDEntry(&pOXIDEntry);

    if(pOXIDEntry)
    {
        IFaceEntry *pEntry = NULL;

        // Check for implemented interface
        void *pKnownIf = GetImplInterface(riid);
        if(pKnownIf)
        {
            pEntry = NULL;
        }
        // Check for an existing IFaceEntry
        else
        {
            pEntry = GetIFaceEntry(riid);
        }

        // Check if a matching IFaceEntry was not found
        if(pKnownIf==NULL && pEntry==NULL)
        {
            XCtxQIData xCtxQIData;

            // Initialize QIData
            xCtxQIData.pIID = &riid;
            xCtxQIData.pStdWrapper = this;
            xCtxQIData.pEntry = NULL;

            // Check for the need to switch to the server context
            if(pPS)
            {
                Win4Assert(GetCurrentContext() != GetServerContext());
                hr = SwitchForCallback(pPS, CrossCtxQIFn, &xCtxQIData,
                                       IID_IUnknown, 0, NULL);
            }
            else
            {
                Win4Assert(GetCurrentContext() == GetServerContext());
                hr = CrossCtxQIFn(&xCtxQIData);
            }

            pEntry = xCtxQIData.pEntry;
        }

        // Save the xCtxMarshalData to the stream
        if(pKnownIf || pEntry)
        {
            XCtxMarshalData xCtxMarshalData;

            xCtxMarshalData.dwSignature = CROSSCTX_SIGNATURE;
            xCtxMarshalData.iid = riid;
            xCtxMarshalData.moxid = pOXIDEntry->GetMoxid();
            xCtxMarshalData.pWrapper = this;
            xCtxMarshalData.pEntry = pEntry;
            xCtxMarshalData.pServer = _pServer;
            xCtxMarshalData.pServerCtx = _pID->GetServerCtx();
			xCtxMarshalData.dwMarshalFlags = mshlflags;
            hr = pStm->Write(&xCtxMarshalData, sizeof(xCtxMarshalData), NULL);
            if(SUCCEEDED(hr))
				InternalAddRef();
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::MarshalServer returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CrossCtxMarshalFn             private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during marshaling
//
//  History:    21-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdMarshalData
{
    CIDObject *pID;
    IUnknown *pServer;
    const IID *pIID;
    DWORD dwDestCtx;
    void *pvDestCtx;
    DWORD mshlflags;
    OBJREF *pobjref;
} StdMarshalData;

HRESULT __stdcall CrossCtxMarshalFn(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CrossCtxMarshalFn\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    StdMarshalData *pStdMarshalData = (StdMarshalData *) pv;

    // Aquire lock
    LOCK(gComLock);

    // Check if StdID has already been created for the server
    CStdIdentity *pStdID = pStdMarshalData->pID->GetStdID();

    // AddRef StdID appropriately marshal flags
    if(pStdID)
    {
        if (!(pStdMarshalData->mshlflags & MSHLFLAGS_TABLEWEAK))
            pStdID->IncStrongCnt();
        else
            pStdID->AddRef();
    }

    // Release lock
    UNLOCK(gComLock);

    // Create StdID if neccessary
    if(pStdID == NULL)
    {
        DWORD dwFlags = IDLF_CREATE;
        if(!(pStdMarshalData->mshlflags & MSHLFLAGS_TABLEWEAK))
            dwFlags |= IDLF_STRONG;
        if (pStdMarshalData->mshlflags & MSHLFLAGS_NOPING)
            dwFlags |= IDLF_NOPING;
        if (pStdMarshalData->mshlflags & MSHLFLAGS_NO_IEC)
            dwFlags |= IDLF_NOIEC;

        hr = ObtainStdIDFromUnk(pStdMarshalData->pServer,
                                pStdMarshalData->pID->GetAptID(),
                                pStdMarshalData->pID->GetServerCtx(),
                                dwFlags, &pStdID);
    }

    // Obtain Objref from the StdID
    if(SUCCEEDED(hr))
    {
        hr = pStdID->MarshalObjRef(*pStdMarshalData->pobjref,
                                   *pStdMarshalData->pIID,
                                   pStdMarshalData->mshlflags,
                                   pStdMarshalData->dwDestCtx,
                                   pStdMarshalData->pvDestCtx,
                                   NULL);


        // Fixup the refcount on StdID
        if (!(pStdMarshalData->mshlflags & MSHLFLAGS_TABLEWEAK))
        {
            BOOL fKeepAlive = (SUCCEEDED(hr)) ? TRUE : FALSE;
            pStdID->DecStrongCnt(fKeepAlive);
        }
        else
        {
            pStdID->Release();
        }
    }
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CrossCtxMarshalFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::MarshalInterface     public
//
//  Synopsis:   Marshals the specified interface
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::MarshalInterface(LPSTREAM pStm, REFIID riid,
                                           LPVOID pv, DWORD dwDestCtx,
                                           LPVOID pvDestCtx, DWORD mshlflags)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::MarshalInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    CtxEntry *pWrapperEntry;
    IFaceEntry *pEntry;
    void *pKnownIf;
    CObjectContext *pCurrentCtx;

    // Obtain current context
    pCurrentCtx = GetCurrentContext();

    // Check for disconnected state
    if(IsDisconnected())
    {
        pWrapperEntry = NULL;
        hr = RPC_E_DISCONNECTED;
    }
    else
    {
        // Lookup wrapper entry for the current context
        pWrapperEntry = LookupCtxEntry(pCurrentCtx);
        if(!pWrapperEntry)
        {
            CoVrfNotifySmuggledWrapper(IID_IMarshal, 5, this);

            hr = RPC_E_WRONG_THREAD;
        }
    }

    if(pWrapperEntry)
    {
		if (CanWrapperMarshal(dwDestCtx, mshlflags))
		{
            CObjectContext *pSavedCtx = NULL;
            BOOL fEnteredNA = FALSE;

            if (IsNAWrapper() && !IsThreadInNTA())
            {
                pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
                fEnteredNA = TRUE;
            }

            hr = MarshalServer(pWrapperEntry->_pPS, pStm, riid, dwDestCtx, pvDestCtx, mshlflags);

            if (fEnteredNA)
            {
                pSavedCtx = LeaveNTA(pSavedCtx);
                Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
            }			
		}
        else
        {
            // Create StdMarshalData on the stack
            StdMarshalData stdMarshalData;
            OBJREF objref;

            // Initialize
            stdMarshalData.pID = _pID;
            stdMarshalData.pServer = _pServer;
            stdMarshalData.pIID = &riid;
            stdMarshalData.dwDestCtx = dwDestCtx;
            stdMarshalData.pvDestCtx = pvDestCtx;
            if(_dwState & WRAPPERFLAG_NOIEC)
                mshlflags |= MSHLFLAGS_NO_IEC;
            if(_dwState & WRAPPERFLAG_NOPING)
                mshlflags |= MSHLFLAGS_NOPING;
            stdMarshalData.mshlflags = mshlflags | MSHLFLAGS_NO_IMARSHAL;
            stdMarshalData.pobjref = &objref;

            // Check for the need to switch to server context
            if(pCurrentCtx != _pID->GetServerCtx())
            {
                // Switch
                hr = SwitchForCallback(pWrapperEntry->_pPS,
                                       CrossCtxMarshalFn, &stdMarshalData,
                                       IID_IMarshal, 5, NULL);
            }
            else
            {
                hr = CrossCtxMarshalFn(&stdMarshalData);
            }

            // Check for success
            if(SUCCEEDED(hr))
            {
                // write the objref into the stream
                hr = WriteObjRef(pStm, objref, dwDestCtx);
                if (FAILED(hr))
                {
                    // undo whatever we just did, ignore error from here since
                    // the stream write error supercedes any error from here.
                    ReleaseMarshalObjRef(objref);
                }

                // free resources associated with the objref.
                FreeObjRef(objref);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::MarshalInterface returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   ObtainPolicySet           private
//
//  Synopsis:   Obtains the policy set associated with the given contexts
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT ObtainPolicySet(CObjectContext *pClientCtx, CObjectContext *pServerCtx,
                        DWORD dwState, BOOL *pfCreate, CPolicySet **ppPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::ObtainPolicySet\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    // Sanity check
    Win4Assert(pClientCtx != pServerCtx);

    // Acquire reader lock
    gPSRWLock.AcquireReaderLock();

    // Lookup the policy set between the contexts
    CPolicySet *pPS;
    BOOL fFound = FALSE;
    HRESULT hr = gPSTable.Lookup(pClientCtx, pServerCtx, &pPS);

    // Release reader lock
    WriterCookie cookie = gPSRWLock.GetWriterCookie();
    gPSRWLock.ReleaseReaderLock();

    // Check if an existing policy set was found
    if(SUCCEEDED(hr))
    {
        Win4Assert(pPS);
        fFound = TRUE;
    }
    else
    {
        if(*pfCreate)
        {
            // Compute the policy set between the contexts
            CPolicySet *pNewPS;
            hr = DeterminePolicySet(pClientCtx, pServerCtx, dwState, &pNewPS);
            if(SUCCEEDED(hr))
            {
                // Acquire writer lock and check for intermediate writes
                gPSRWLock.AcquireWriterLock();
                if(gPSRWLock.IntermediateWrites(cookie))
                {
                    gPSTable.Lookup(pClientCtx, pServerCtx, &pPS);
                }

                // Check if other threads have created the desired policy set
                if(pPS == NULL)
                {
                    // Chain the policy set in the involved contexts
                    if(pClientCtx)
                        pNewPS->SetClientContext(pClientCtx);
                    if(pServerCtx)
                        pNewPS->SetServerContext(pServerCtx);

                    // Add the new policy set to the policy set table
                    gPSTable.Add(pNewPS);
                    pPS = pNewPS;
                    pPS->AddRef();
                }
                else
                {
                    fFound = TRUE;
                }

                // Release writer lock
                gPSRWLock.ReleaseWriterLock();

                pNewPS->Release();
            }
        }
    }

    // Initialize return value
    *pfCreate = (fFound == FALSE);
    *ppPS = pPS;

    // Sanity check
    Win4Assert((SUCCEEDED(hr)) == (*ppPS!=NULL));

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "ObtainPolicySet returning 0x%x, pPS=0x%x\n", hr, *ppPS));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::ValidateContext     public
//
//  Synopsis:   Validates the context for object and interface
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CtxEntry *CStdWrapper::ValidateContext(CObjectContext *pClientCtx,
                                       IFaceEntry *pIFaceEntry)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::ValidateContext\n"));

    CPolicySet *pPS = NULL;
    CtxEntry *pIFEntry = NULL;
    BOOL fCreated = FALSE;

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Lookup wrapper entry for the current context
    CtxEntry *pWrapperEntry = LookupCtxEntry(pClientCtx);
    if (pWrapperEntry == NULL)
    {
        // Release lock
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);

        HRESULT hr;
        BOOL fCreate = TRUE;

        hr = ObtainPolicySet(pClientCtx, _pID->GetServerCtx(),
                             PSFLAG_LOCAL, &fCreate, &pPS);

        // Reacquire lock
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        // Another thread could have created the
        // wrapper entry for the current client context
        if (SUCCEEDED(hr))
            pWrapperEntry = LookupCtxEntry(pClientCtx);
    }

    // Check for the need to create wrapper entry
    if (pWrapperEntry)
    {
        pWrapperEntry->AddRef();
    }
    else if (pPS)
    {
        pWrapperEntry = AddCtxEntry(pPS);
    }

    if (pWrapperEntry && pIFaceEntry)
    {
        // Validate client context for this interface
        pIFEntry = pIFaceEntry->ValidateContext(pClientCtx,
                                                pWrapperEntry->_pPS);
    }

    // Release lock
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Cleanup on failure
    if (pIFEntry == NULL && pWrapperEntry && pIFaceEntry)
    {
        CPolicySet *pEntryPS = ReleaseCtxEntry(pWrapperEntry);
        if (pEntryPS)
            pEntryPS->Release();
    }

    // Cleanup
    if (pPS)
        pPS->Release();

    ContextDebugOut((DEB_WRAPPER,
                     "ValidateContext returning 0x%x\n", pWrapperEntry));
    return(pWrapperEntry);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::UnMarshalInterface     public
//
//  Synopsis:   Unmarshals the specified interface
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::UnmarshalInterface(LPSTREAM pStm, REFIID riid,
                                             LPVOID *ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::UnmarshalInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    IMarshal *pIM;

    // Delegate static wrapper
    HRESULT hr = GetStaticWrapper(&pIM);
    if(SUCCEEDED(hr))
        hr = pIM->UnmarshalInterface(pStm, riid, ppv);
    else
        *ppv = NULL;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::UnmarshalInterface returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::ReleaseMarshalData     public
//
//  Synopsis:   Releases the given marshaled data
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::ReleaseMarshalData(LPSTREAM pStm)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::ReleaseMarshalData\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    IMarshal *pIM;

    // Delegate static wrapper
    HRESULT hr = GetStaticWrapper(&pIM);
    if(SUCCEEDED(hr))
        hr = pIM->ReleaseMarshalData(pStm);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::ReleaseMarshalData returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::DisconnectObject     public
//
//  Synopsis:   Disconnects the server object from its clients
//
//  History:    23-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::DisconnectObject(DWORD dwReserved)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::DisconnectObject\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // This method can only be called from inside server context
    if(IsDisconnected())
        hr = S_OK;
    else if(_pID->GetServerCtx() == GetCurrentContext())
        hr = Disconnect(NULL);
    else
    {
        CoVrfNotifySmuggledWrapper(IID_IMarshal, 8, this);

        hr = RPC_E_WRONG_THREAD;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::DisconnectObject returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CrossCtxDisconnectFn             Internal
//
//  Synopsis:   Disconnects the server object
//
//  History:    23-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagIFaceSvrRefs {
    IRpcStubBuffer *pRpcStub;
    IRpcProxyBuffer *pRpcProxy;
    void *pServer;
    CCtxChnl *pCtxChnl;
} IFaceSvrRefs;

typedef struct tagXCtxDisconnectData
{
#if DBG==1
    CObjectContext *pServerCtx;
#endif
    IUnknown *pServer;
    CIDObject *pID;
    ULONG cIFaces;
    IFaceSvrRefs *pIFaceSvrRefs;
} XCtxDisconnectData;

HRESULT __stdcall CrossCtxDisconnectFn(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CrossCtxDisconnectFn\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    IFaceSvrRefs *pIFaceSvrRefs = ((XCtxDisconnectData *) pv)->pIFaceSvrRefs;
    ULONG cIFaces = ((XCtxDisconnectData *) pv)->cIFaces;
    IUnknown *pServer = ((XCtxDisconnectData *) pv)->pServer;
    CIDObject *pID = ((XCtxDisconnectData *) pv)->pID;

    // Sanity check
    Win4Assert(((XCtxDisconnectData *) pv)->pServerCtx == GetCurrentContext());

    // Release references held on the server by IFaceEntries
    for(ULONG i=0;i<cIFaces;i++)
    {
        // Check to make sure that we use the RPC p/s mechanism
        // in which case the RpcStub is not NULL. In the case of
        // lightweight p/s mechanism this is NULL and so no disconnect
        // is needed
        if(pIFaceSvrRefs[i].pRpcStub)
            pIFaceSvrRefs[i].pRpcStub->Disconnect();
        ((IUnknown *) pIFaceSvrRefs[i].pServer)->Release();
    }

    // Release IDObject
    if(pID)
    {
        pID->WrapperRelease();
        pID->Release();
    }

    // Release server object, but not before calling WrapperRelease on
    // the IDObject because WrapperRelease will cause the SetZombie
    // sequence which requires a server reference to be held
    if(pServer)
        pServer->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CrossCtxDisconnectFn returning 0x0\n"));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Disconnect        private
//
//  Synopsis:   Disconnects the server object from its clients
//              Called by DisconnectObject and process uninit code
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::Disconnect(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Disconnect\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    ULONG cIFaces = 0;
    IFaceSvrRefs *pIFaceSvrRefs =
        (IFaceSvrRefs *) _alloca(_cIFaces*sizeof(IFaceSvrRefs));
    BOOL fDisconnect = FALSE, fRelease = FALSE;
    IUnknown *pServer = NULL;
    CIDObject *pID = NULL;

    // Obtain current and server context
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx = _pID ? _pID->GetServerCtx() : pCurrentCtx;

    // Check for the need to create policy set
    if((pPS == NULL) && (pServerCtx != pCurrentCtx) && !IsDisconnected())
    {
        BOOL fCreate = TRUE;

        hr = ObtainPolicySet(pCurrentCtx, pServerCtx,
                             PSFLAG_LOCAL, &fCreate, &pPS);
        if(SUCCEEDED(hr))
            fRelease = TRUE;
    }

    // Check for failure in creating policy set
    if(SUCCEEDED(hr))
    {
        // Acquire lock
        LOCK(gComLock);

        // Check if disconnected already
        if(!IsDisconnected())
        {
            // Sanity check
            Win4Assert(_pID);

            // Remove wrapper from ID object
            if(_pID->RemoveWrapper())
                _dwState |= WRAPPERFLAG_DESTROYID;

            // Update state.
            // Do not move this line. GopalK
            _dwState |= WRAPPERFLAG_DISCONNECTED;

            // Disconnect only when there are no pending calls on the object
            if(_cCalls == 0)
            {
                // Save references held on the server by IFaceEntries
                cIFaces = _cIFaces;
                IFaceEntry *pEntry = _pIFaceHead;
                for(ULONG i=0;i<cIFaces;i++)
                {
                    // Sanity checks
                    // Assert that either the RPC p/s mechanism or lightweight p/s mechanism
                    // is being used
                    Win4Assert(pEntry->_pRpcStub || pEntry->_pUnkInner);
                    Win4Assert(pEntry->_pServer);

                    pIFaceSvrRefs[i].pRpcStub = pEntry->_pRpcStub;
                    pIFaceSvrRefs[i].pServer = pEntry->_pServer;
                    pEntry->_pServer = NULL;

                    pEntry = pEntry->_pNext;
                }

                // Save references held on the server by the wrapper
                pServer = _pServer;
                pID = _pID;
                _pServer = NULL;
                _pID = NULL;

                // Disconnect the object
                fDisconnect = TRUE;
            }
        }

        // Release lock
        UNLOCK(gComLock);
    }

    if(fDisconnect)
    {
        // Create XCtxDisconnectData on the stack
        XCtxDisconnectData xCtxDisconnectData;

        // Initialize
#if DBG==1
        xCtxDisconnectData.pServerCtx = pServerCtx;
#endif
        xCtxDisconnectData.pServer = pServer;
        xCtxDisconnectData.pID = pID;
        xCtxDisconnectData.cIFaces = cIFaces;
        xCtxDisconnectData.pIFaceSvrRefs = pIFaceSvrRefs;

        // Check for the need to switch to server context
        if(pServerCtx != pCurrentCtx)
        {
            // Switch
            hr = SwitchForCallback(pPS, CrossCtxDisconnectFn,
                                   &xCtxDisconnectData,
                                   IID_IMarshal, 6, NULL);
        }
        else
        {
            hr = CrossCtxDisconnectFn(&xCtxDisconnectData);
        }
    }

    // Release policy set if needed
    if(fRelease)
        pPS->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::Disconnect returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CStdWrapper::CrossCtxQI
//
//  Synopsis:   Perform a cross context QI.  Encapsulate CrossCtxQIFn.
//
//  History:    29-Sep-00   JohnDoty      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::CrossCtxQI(CPolicySet *pPS, REFIID riid, 
                                IFaceEntry **ppEntry)
{
    HRESULT hr;

    XCtxQIData xCtxQIData;

    // Initialize QIData
    xCtxQIData.pIID        = &riid;
    xCtxQIData.pStdWrapper = this;
    xCtxQIData.pEntry      = NULL;
    
    // Sanity checks
    Win4Assert(pPS);
    
    // Generate an IFaceEntry for the desired IID
    // Switch to the server context
    if (pPS != NULL)
    {
        hr = SwitchForCallback(pPS, CrossCtxQIFn,
                               &xCtxQIData, IID_IUnknown, 0, NULL);
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    *ppEntry = xCtxQIData.pEntry;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdWrapper::WrapInterfaceForContext
//
//  Synopsis:   Finds or creates a valid wrapper for our server object
//              in the requested context.
//
//  Arguments:  pClientContext- The client context for the IFaceEntry
//              pUnk- Really an interface pointer of type riid.  This
//                    is an optimization for CreateWrapper, and may be
//                    NULL.
//              riid- The IID of the returned wrapper
//              ppv-  Pointer to the return location
//
//  History:    29-Sep-00   JohnDoty      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::WrapInterfaceForContext(CObjectContext *pClientContext,
                                             IUnknown *pUnk,
                                             REFIID riid,
                                             void **ppv)
{
    HRESULT hr = S_OK;
    IUnknown *pItf = NULL;

    // If nobody has given us an interface pointer to use, get one
    // ourselves... this is an optimization for CreateWrapper()
    // so that it can return E_NOINTERFACE without searching for
    // us.
    if (pUnk == NULL)
    {
        IUnknown *pServer = GetServer();
        if (pServer)
        {
            hr = pServer->QueryInterface(riid, (void **)&pItf);
        }
        else
        {
            // At this point, pItf is still NULL.  This will
            // be passed into GetOrCreateIFaceEntry, and will
            // signify that we cannot create a new IFaceEntry.
        }
    }
    else
    {
        pItf = pUnk;
        pItf->AddRef();
    }

    if (SUCCEEDED(hr))
    {
        // Validate client context for the wrapper object
        hr = E_OUTOFMEMORY; // Assume OOM
        CtxEntry *pWrapperEntry = ValidateContext(pClientContext,
                                                  NULL);
        if (pWrapperEntry)
        {
            // find/create and interface wrapper
            hr = GetOrCreateIFaceEntry(riid, pItf, pClientContext, 
                                       pWrapperEntry->_pPS, ppv);
        }

        if (SUCCEEDED(hr))
        {
            // keep the wrapper we created
            hr = S_OK;
        }
        else
        {
            CPolicySet *pPS = ReleaseCtxEntry(pWrapperEntry);
            if (pPS)
                pPS->Release();
        }
    }

    if (pItf)
        pItf->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Deactivate    private
//
//  Synopsis:   Releases all the references on the server object as part
//              of deactivating the server
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Deactivate()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Deactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void           *pServer;
    } ServerRefs;

     // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(!IsDeactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIFaces cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ULONG cIFaces = _cIFaces;
    ServerRefs *pServerRefs = (ServerRefs *)_alloca(cIFaces*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Update state
    _dwState |= WRAPPERFLAG_DEACTIVATED;

    // Save the reference held on the server by the wrapper
    Win4Assert(_pServer);
    IUnknown *pServer = _pServer;
    _pServer = NULL;

    // Save references held on the server by IFaceEntries
    IFaceEntry *pEntry = _pIFaceHead;
    for (ULONG i=0; i<cIFaces; i++)
    {
        // Sanity checks
        // Assert that either the RPC p/s mechanism or lightweight p/s
        // mechanism is being used
        Win4Assert(pEntry->_pRpcStub || pEntry->_pUnkInner);
        Win4Assert(pEntry->_pServer);

        pServerRefs[i].pRpcStub = pEntry->_pRpcStub;
        pServerRefs[i].pServer  = pEntry->_pServer;
        pEntry->_pServer = NULL;

        pEntry = pEntry->_pNext;
    }

    // Release lock before calling app code
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Release reference held on the server by the wrapper
    pServer->Release();

    // Release references held on the server by IFaceEntries for
    // RPC p/s mechanism. In the lightweight p/s mechanism, there
    // is no notion of a stub
    for (i=0; i<cIFaces; i++)
    {
        if (pServerRefs[i].pRpcStub)
            pServerRefs[i].pRpcStub->Disconnect();

        ((IUnknown *) pServerRefs[i].pServer)->Release();
    }

    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Deactivate this:%x\n", this));
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Reactivate    private
//
//  Synopsis:   Acquires the the needed references on the server object
//              as part of reactivating the server
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Reactivate(IUnknown *pServer)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Reactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void          **ppServer;
        IID            *pIID;
    } ServerRefs;

    // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(IsDeactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIFaces cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ULONG cIFaces = _cIFaces;
    ServerRefs *pServerRefs = (ServerRefs *)_alloca(cIFaces*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Update state
    _dwState &= ~WRAPPERFLAG_DEACTIVATED;

    // Init the reference held on the server by the wrapper
    Win4Assert(_pServer == NULL);
    _pServer = pServer;

    // Obtain references held on the server by IFaceEntries
    IFaceEntry *pEntry = _pIFaceHead;
    for (ULONG i=0; i<cIFaces; i++)
    {
        // Sanity check
        Win4Assert(pEntry->_pServer == NULL);

        pServerRefs[i].pRpcStub = pEntry->_pRpcStub;
        pServerRefs[i].ppServer = &pEntry->_pServer;
        pServerRefs[i].pIID     = &pEntry->_iid;

        pEntry = pEntry->_pNext;
    }

    // Release lock before calling app code
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // AddRef server on behalf of wrapper
    pServer->AddRef();

    // Reconnect IFaceEntries to server
    for(i=0; i<cIFaces; i++)
    {
        pServer->QueryInterface(*pServerRefs[i].pIID, pServerRefs[i].ppServer);

        // We call Connect only when a RPC stub and server is
        // available
        if(*pServerRefs[i].ppServer && pServerRefs[i].pRpcStub)
            pServerRefs[i].pRpcStub->Connect((IUnknown *) (*pServerRefs[i].ppServer));
    }

    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Reactivate hr:%x\n", S_OK));
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::Initialize   public
//
//  Synopsis:   Initialize context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxChnl::Initialize()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Initialize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Initialize allocator
    s_allocator.Initialize(sizeof(CCtxChnl),
                           CTXCHANNELS_PER_PAGE,
                           &gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::Cleanup   public
//
//  Synopsis:   Cleanup context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxChnl::Cleanup()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(s_cChannels == 0);

    // Cleanup alloctor
    s_allocator.Cleanup();

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::CCtxChnl     public
//
//  Synopsis:   Constructor for context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxChnl::CCtxChnl(CStdWrapper *pStdWrapper)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::CCtxChnl\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Initialize
    _dwState = 0;
    _cRefs = 1;
    _pIFaceEntry = NULL;
    _pStdWrapper = pStdWrapper;

    ASSERT_LOCK_HELD(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::~CCtxChnl     public
//
//  Synopsis:   Destructor for context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxChnl::~CCtxChnl()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::CCtxChnl\n"));
    ASSERT_LOCK_DONTCARE(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::QueryInterface     public
//
//  Synopsis:   QI behavior of policy set
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IRpcChannelBuffer2 *)this;
    }
    else if(IsEqualIID(riid, IID_IStdCtxChnl))
    {
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IRpcChannelBuffer) ||
            IsEqualIID(riid, IID_IRpcChannelBuffer2))
    {
        *ppv = (IRpcChannelBuffer2 *) this;
    }
    else if(IsEqualIID(riid, IID_ICallFrameEvents))
    {
        *ppv = (ICallFrameEvents *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::AddRef     public
//
//  Synopsis:   AddRefs context channel
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxChnl::AddRef()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::AddRef\n"));

    ULONG cRefs;

    // Increment ref count
    cRefs = InterlockedIncrement((LONG *)& _cRefs);

    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::Release     public
//
//  Synopsis:   Release context channel
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxChnl::Release()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Release\n"));

    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &_cRefs);
    // Check if this is the last release
    if(cRefs == 0)
    {
        // Delete call
        LOCK(gComLock);
        delete this;
        UNLOCK(gComLock);
    }

    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Release returning 0x%x\n",
                     cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetBuffer
//
//              This method ensures that the interface has legally been
//              unmarshaled in the client context, delivers GetSize events
//              using the policy set, and saves the context call object
//              in TLS
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetBuffer(RPCOLEMESSAGE *pMsg, REFIID riid)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::GetBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName, sizeof(iidName)/sizeof(*iidName));
        char *side = (pMsg->reserved1 == NULL) ?
                     "XCtxClientGetBuffer" :
                     "XCtxServerGetBuffer";

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName, pMsg->iMethod));
    }
#endif

    HRESULT hr = S_OK, hrCall = S_OK;
    CPolicySet *pPS = NULL;
    CCtxCall *pCtxCall = NULL;

    // Obtain the current side
    BOOL fClientSide = (pMsg->reserved1 == NULL);

    // Call GetBuffer2 to do the remaining work
    // GetBuffer2 allocates the buffer on the heap
    hr = GetBuffer2(pMsg, riid, pCtxCall, fClientSide, TRUE, NULL);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::GetBuffer is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::SendReceive     public
//
//  Synopsis:   Implements IRpcChannelBuffer::SendReceive
//
//              This method identifies the right policy set, asks it
//              to obtain client buffers from the policies, switches to
//              the server context, asks the policy set to deliver the
//              buffers created by the polices on the client side,
//              invokes the call on the server object, obtains serveer
//              side buffers through policy set, switches back to the
//              client context, asks the policy set to deliver the
//              buffers created by the polices on the server side,
//              and finally returns to its caller
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::SendReceive(RPCOLEMESSAGE *pMsg,  ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::SendReceive\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(_pIFaceEntry->_iid, iidName, sizeof(iidName)/sizeof(*iidName));

        ContextDebugOut((DEB_TRACECALLS,
                         "XCtxSendReceive on interface %I (%ws) method 0x%x\n",
                         &_pIFaceEntry->_iid, iidName,
                         pMsg->iMethod));
    }
#endif

    HRESULT hr = S_OK;
    COleTls Tls;
    void *pvBuffer;

    // Obtain client side context call object
    CCtxCall *pClientCall = (CCtxCall *) pMsg->reserved1;

    // Ensure that GetBuffer was called before
    Win4Assert(pClientCall && (pClientCall->_dwFlags & CTXCALLFLAG_GBSUCCESS));

    // Save the dispatch buffer
    if(pClientCall->_pvExtent)
        pvBuffer = pClientCall->_pvExtent;
    else
        pvBuffer = pMsg->Buffer;

    // Create rpc call object on the stack
    const IUnknown *pIdentity = _pStdWrapper;
    CRpcCall rpcCall(pIdentity, pMsg, _pIFaceEntry->_iid,
                     hr, CALLSOURCE_CROSSCTX);

    // Obtain the policy set that delivers events
    CPolicySet *pPS = pClientCall->_pPS;
    Win4Assert(pPS);

    // Deliver client side call events
    hr = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCCALL, pClientCall);

    // Reset state inside context call object
    CPolicySet::ResetState(pClientCall);

    // Invoke on the server
    if(SUCCEEDED(hr))
    {
        // Create rpc call object on the stack
        CRpcCall rpcCall(_pStdWrapper->GetIdentity(),
                         pMsg, _pIFaceEntry->_iid, hr, CALLSOURCE_CROSSCTX);

        // Create server side context call object
        CCtxCall serverCall(CTXCALLFLAG_SERVER | CTXCALLFLAG_CROSSCTX,
                            pMsg->dataRepresentation);

        // Switch to the server context
        CObjectContext *pClientCtx = Tls->pCurrentCtx;
        CObjectContext *pServerCtx = pPS->GetServerContext();
        Tls->pCurrentCtx = pServerCtx;
        Tls->ContextId = pServerCtx->GetId();
        pServerCtx->InternalAddRef();
        ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                         pClientCtx, pServerCtx));

        // If the server is in the NA, make sure the thread is in the NA.
        BOOL fEnteredNA = FALSE;
        BOOL fExitedNA = FALSE;
        if (pServerCtx->GetComApartment() == gpNTAApartment)
        {
            if (!IsThreadInNTA())
            {
                Tls->dwFlags |= OLETLS_INNEUTRALAPT;
                fEnteredNA = TRUE;
            }
        }
        else
        {
            if (IsThreadInNTA())
            {
                Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
                fExitedNA = TRUE;
            }
        }
        Win4Assert(!IsThreadInNTA() || pServerCtx->GetComApartment() == gpNTAApartment);
        Win4Assert(IsThreadInNTA() || pServerCtx->GetComApartment() != gpNTAApartment);

        // Update server side context call object
        serverCall._pPS = pPS;
        if(pClientCall->_cbExtent)
            serverCall._pvExtent = pvBuffer;
        serverCall._pContext = Tls->pCurrentCtx;


        // Update message
        pMsg->reserved1 = &serverCall;
        pMsg->reserved2[0] = NULL;
        pMsg->reserved2[1] = NULL;
        pMsg->reserved2[3] = NULL;
        pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;

        // Deliver server side notification events
        hr = pPS->Notify(&rpcCall, CALLTYPE_SYNCENTER, &serverCall);

        // Check for the need to dispatch call to server object
        BOOL fDoCleanup = TRUE;
        if(SUCCEEDED(hr))
        {
            // Delegate to StubInvoke
            hr = SyncStubInvoke(pMsg, _pIFaceEntry->_iid,
                                _pStdWrapper->GetIDObject(),
                                (IRpcChannelBuffer3 *) this,
                                _pIFaceEntry->_pRpcStub, pulStatus);
            if (FAILED(hr))
            {
                // Failed to successfully deliver the call to the server
                // object.  Therefore, we don't want to try to cleanup
                // marshaled out param interface ptrs later if server-side
                // leave event deliver fails.
                fDoCleanup = TRUE;
            }

            // Make sure we're back on the right context
            CheckContextAfterCall (Tls, pServerCtx);
        }
        else
        {
            // The call was aborted during the delivery of server-side
            // notify events.  We need to release any marshaled in-param
            // interface ptrs in the marshal buffer.
            ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcStub, FALSE);
        }

        // Deliver server side leave events
        if(hr != RPC_E_INVALID_HEADER)
        {
            // Check if GetBuffer was called by the stub
            if(serverCall._dwFlags & CTXCALLFLAG_GBSUCCESS)
            {
                // Update call status to that saved in GetBuffer
                if(FAILED(serverCall._hr))
                    hr = serverCall._hr;
            }
            else if(!(serverCall._dwFlags & CTXCALLFLAG_GBFAILED))
            {
                // The call must have failed
                Win4Assert(FAILED(hr));

                // Initailize
                CPolicySet::ResetState(&serverCall);
                pMsg->cbBuffer = 0;
                pMsg->Buffer = NULL;

                // Obtain the buffer size needed by the server side policies
                // GetSize will fail on the server side only if no policy
                // expressed interest in sending data to the client side
                pPS->GetSize(&rpcCall, CALLTYPE_SYNCLEAVE, &serverCall);

                // Allocate buffer if server side  policies wish to send
                // buffer to the client side
                if(serverCall._cbExtent)
                    serverCall._pvExtent = PrivMemAlloc8(serverCall._cbExtent);
            }

            hr = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCLEAVE, &serverCall);
            if (fDoCleanup && FAILED(hr))
            {
                // The call was successfully delivered to the server object
                // but it was failed during delivery of server-side leave
                // events.  We need to release any marshaled out-param
                // interface ptrs in the marshal buffer.
                ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcStub, TRUE);
            }
        }

        // Save the return buffer
        if(serverCall._cbExtent)
            pClientCall->_pvExtent = serverCall._pvExtent;

        // Switch back to client context
        ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                         pClientCtx, pServerCtx));
        pServerCtx->InternalRelease();
        Win4Assert(Tls->pCurrentCtx == pServerCtx);
        Tls->pCurrentCtx = pClientCtx;
        Win4Assert(pClientCtx);
        Tls->ContextId = pClientCtx->GetId();

        // If we switched the thread into the NA, switch it out.
        if (fEnteredNA)
        {
            Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
        }
        else if (fExitedNA)
        {
            Tls->dwFlags |= OLETLS_INNEUTRALAPT;
        }
        Win4Assert(!IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() == gpNTAApartment);
        Win4Assert(IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() != gpNTAApartment);

        // Update message
        pMsg->reserved1 = pClientCall;
        pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;
    }
    else
    {
        // The call was failed during delivery of client-side call events.
        // Free any marshaled interface pointers in the marshal buffer.
        ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcProxy, FALSE);
    }

    // Free dispatch buffer
    PrivMemFree8(pvBuffer);

    // Deliver client side notification events
    hr = pPS->Notify(&rpcCall, CALLTYPE_SYNCRETURN, pClientCall);

    // Check for premature failure case
    if(FAILED(hr))
    {
        // The call was failed during delivery of client-side notify
        // events.  Free any marshaled interface pointers in the
        // marshal buffer.
        ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcProxy, TRUE);

        // Free the buffer
        if(pClientCall->_pvExtent)
            PrivMemFree8(pClientCall->_pvExtent);
        else if(pMsg->Buffer)
            PrivMemFree8(pMsg->Buffer);

        // Update the return code
        if(hr != RPC_E_SERVERFAULT)
        {
            *pulStatus = hr;
            hr = RPC_E_FAULT;
        }

        // Unlock the wrapper
        _pStdWrapper->Unlock(pPS);

        // Do not touch any member variables here after as
        // the wrapper  might have deleted the channel
        // due to a nested release

        // Delete client side context call object
        delete pClientCall;

        // Reset
        pMsg->Buffer = NULL;
    }
    else
        pClientCall->_dwFlags |= CTXCALLFLAG_SRSUCCESS;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::SendReceive is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::FreeBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::FreeBuffer
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::FreeBuffer(RPCOLEMESSAGE *pMsg)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::FreeBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        IID *iidCalled;
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(_pIFaceEntry->_iid, iidName, sizeof(iidName)/sizeof(*iidName));

        ContextDebugOut((DEB_TRACECALLS,
                         "FreeBuffer on interface %I (%ws) method 0x%x\n",
                         &_pIFaceEntry->_iid, iidName,
                         pMsg->iMethod));
    }
#endif

    if(pMsg->Buffer)
    {
        // This method is never called on the server side
        // Obtain the context call object
        CCtxCall *pCtxCall = (CCtxCall *) pMsg->reserved1;

        // Sanity Checks
        Win4Assert(pCtxCall);
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);

        // Free buffer
        if(pCtxCall->_pvExtent)
            PrivMemFree8(pCtxCall->_pvExtent);
        else
            PrivMemFree8(pMsg->Buffer);

        // Unlock the wrapper
        _pStdWrapper->Unlock(pCtxCall->_pPS);

        // Do not touch any member variables here after as
        // the wrapper  might have deleted the channel
        // due to a nested release

        // Delete the context call object
        delete pCtxCall;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::FreeBuffer is returning hr:0x%x\n", S_OK));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetDestCtx     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetDestCtx
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetDestCtx(DWORD *pdwDestCtx, void **ppvDestCtx)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::GetDestCtx\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Initialize return values
    if((GetWrapper())->IsNAWrapper())
    {
        //We are marshaling through a NA wrapper.  In this case we need 
        //to force the destination context to MSHCTX_INPROC so all
        //interfaces are marshaled as full proxies. COM+ 32189
        *pdwDestCtx = MSHCTX_INPROC;
    }
    else
    {
        *pdwDestCtx = MSHCTX_CROSSCTX;
    }
    if(ppvDestCtx != NULL)
        *ppvDestCtx = NULL;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::IsConnected     public
//
//  Synopsis:   Implements IRpcChannelBuffer::IsConnected
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::IsConnected()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::IsConnected\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;

    // Check if the wrapper is disconnected
    if(_pStdWrapper->IsDisconnected())
        hr = S_FALSE;

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetProtocolVersion     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetProtocolVersion
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetProtocolVersion(DWORD *pdwVersion)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::IsConnected\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Return current COMVERSION
    *pdwVersion = MAKELONG(COM_MAJOR_VERSION, COM_MINOR_VERSION);

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetBuffer2     private
//
//  Synopsis:   (1) Gets the size of the buffer needed by the policy sets
//              (2) Allocates the buffer and context call object either on the
//                  heap or the stack.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetBuffer2(RPCOLEMESSAGE *pMsg, REFIID riid, CCtxCall *pCtxCall,
                                  BOOL fClientSide, BOOL fAllocOnHeap, ULONG* pcbBuffer)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::GetBuffer2\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName, sizeof(iidName)/sizeof(*iidName));
        char *side = fClientSide ?
                     "XCtxClientGetBuffer2" :
                     "XCtxServerGetBuffer2";

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName, pMsg->iMethod));
    }
#endif

    HRESULT hr = S_OK, hrCall = S_OK;
    CPolicySet *pPS = NULL;

    // Set the out params
    if(pcbBuffer != NULL)
        *pcbBuffer = 0;

    // Ensure that the interface has legally been unmarshaled on the
    // client side
    if(fClientSide)
    {
        // Ensure that TLS is initialized
        COleTls Tls(hr);
        if(SUCCEEDED(hr))
        {
            // Obtain current context
            CObjectContext *pCurrentCtx = GetCurrentContext();

            // Lookup context entry for the current context
            CtxEntry *pEntry = _pIFaceEntry->LookupCtxEntry(pCurrentCtx);
            if(pEntry)
            {
                // Obtain the policy set between the client
                // and server contexts
                pPS = pEntry->_pPS;

                // Lock wrapper for the duration of the call
                hr = _pStdWrapper->Lock(pPS);
                if(SUCCEEDED(hr) && fAllocOnHeap)
                {
                    // Create a new context call object
                    pCtxCall = new CCtxCall(CTXCALLFLAG_CLIENT | CTXCALLFLAG_CROSSCTX,
                                            pMsg->dataRepresentation);
                    if(pCtxCall == NULL)
                        hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                CoVrfNotifySmuggledWrapper(riid, pMsg->iMethod, _pStdWrapper);

                hr = RPC_E_WRONG_THREAD;
            }
        }
    }
    else
    {
        // On the server side, use the existing context call object
        if(fAllocOnHeap)
            pCtxCall = (CCtxCall *) pMsg->reserved1;
        Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_CROSSCTX));
        CPolicySet::ResetState(pCtxCall);

        // Obtain the policy set between the client
        // and server contexts
        pPS = pCtxCall->_pPS;
    }

    if(SUCCEEDED(hr))
    {
        // Sanity check
        Win4Assert(pPS);

        // Create rpc call object on the stack
        const IUnknown *pIdentity = _pStdWrapper;
        CRpcCall rpcCall(fClientSide ? pIdentity : _pStdWrapper->GetIdentity(),
                         pMsg, riid, hrCall, CALLSOURCE_CROSSCTX);

        // Size the buffer as needed
        hr = pPS->GetSize(&rpcCall,
                          fClientSide ? CALLTYPE_SYNCCALL : CALLTYPE_SYNCLEAVE,
                          pCtxCall);

        // Allocate buffer
        if(SUCCEEDED(hr))
        {
            ULONG cbSize = pMsg->cbBuffer + pCtxCall->_cbExtent;
            if(pcbBuffer)
                *pcbBuffer = cbSize;

            if(fAllocOnHeap)
            {
                pMsg->Buffer = PrivMemAlloc8(cbSize);
                if(pMsg->Buffer)
                {
                    Win4Assert(!(((ULONG_PTR) pMsg->Buffer) & 7) &&
                               "Buffer is not 8-byte aligned");

                    // Save buffer pointer and update the message
                    if(pCtxCall->_cbExtent)
                    {
                        pCtxCall->_pvExtent = pMsg->Buffer;
                        pMsg->Buffer = (((BYTE *) pMsg->Buffer) + pCtxCall->_cbExtent);
                    }
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // Turn off the GBINIT flag, so DeliverEvents will allocate a buffer
                // before calling LeaveFillBuffer.
                pCtxCall->_dwFlags &= ~CTXCALLFLAG_GBINIT;
            }
        }
        else
        {
            // GetSize fails on the server side only if no policy
            // expressed interest in sending data to client side
            Win4Assert(pCtxCall->_cbExtent == 0);
            pMsg->Buffer = NULL;
        }
    }

    // Update state before returning to the proxy/stub
    if(SUCCEEDED(hr))
    {
        // On the clientside, save policy set inside context call
        // object for future reference
        if(fClientSide)
        {
            // Stabilize reference to policy set
            pPS->AddRef();
            pCtxCall->_pPS = pPS;

            // Save context call object inside message
            pMsg->reserved1 = pCtxCall;
        }

        // Update state inside context call object
        pCtxCall->_dwFlags |= CTXCALLFLAG_GBSUCCESS;
        pCtxCall->_hr = hrCall;
    }
    else
    {
        // Check side
        if(fClientSide)
        {
            // Unlock wrapper
            if(pPS)
                _pStdWrapper->Unlock(pPS);

            // Delete context call object
            if(pCtxCall && fAllocOnHeap)
                delete pCtxCall;

            // Reset
            pMsg->Buffer = NULL;
        }
        else
        {
            // Reset state inside context call object
            CPolicySet::ResetState(pCtxCall);
            pCtxCall->_dwFlags |= CTXCALLFLAG_GBFAILED;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::GetBuffer2 is returning hr:0x%x\n", hr));
    return(hr);

}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::SyncInvoke2     private
//
//  Synopsis:   (1) Unmarshal any [in] interface pointers.
//              (2) Invoke the method on the server object.
//              (3) Marshal the [out] interface pointers.
//              (4) Release the [in] interface pointers.
//              (5) Copy any data values back to the original frame
//              (6) If an error occurs in any of the above, cleanup properly.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::SyncInvoke2(RPCOLEMESSAGE* pMsg, DWORD* pcbBuffer,
                                   CCtxCall* pWalkerServer, CCtxCall* pWalkerClient,
                                   ICallFrame* pClientFrame, ICallFrame* pServerFrame,
                                   CALLFRAMEINFO* pInfo,
                                   HRESULT* phrCall
                                   )
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::SyncInvoke2\n"));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    BOOL fIsIDispatchInvoke = FALSE;
    ICallFrame* pInvokeFrame = (pServerFrame ? pServerFrame : pClientFrame);
    DWORD dwWalkWhat;

    // Walk the [in] interface pointers unmarshaling them
    if(0 != pInfo->cInInterfacesMax)
    {
        // Make sure that the walker used to marshal the interface ptr
        // is also used to unmarshal the interface ptr
        pWalkerClient->_dwStage = STAGE_UNMARSHAL;
        dwWalkWhat = CALLFRAME_WALK_IN;
        
        // The case of IDispatch::Invoke is special as it has some
        // [in,out] parameters
        if(pInfo->fDerivesFromIDispatch && (6 == pInfo->iMethod))
        {
            fIsIDispatchInvoke = TRUE;
            dwWalkWhat |= CALLFRAME_WALK_INOUT;
        }
        
        Win4Assert(pInvokeFrame == pServerFrame);
        hr = pServerFrame->WalkFrame(dwWalkWhat, pWalkerClient);
    }

    if(SUCCEEDED(hr))
    {
        // Sanity check - Interceptors return error for any hr != S_OK
        Win4Assert(hr == S_OK);
        
        // Invoke the method and wrap it in a try-catch block to
        // catch user-level exceptions
        _try
        {
            hr = pInvokeFrame->Invoke(_pIFaceEntry->_pServer);
            if(FAILED(hr))
            {
                // This is unexpected as someting went wrong with
                // the callframe invocation mechansim.
                Win4Assert(FALSE && "Internal failure in ICallFrame::Invoke");
            }
            // Get the HRESULT of the method call on the server object
            *phrCall = pInvokeFrame->GetReturnValue();
        }
        _except(AppInvokeExceptionFilter(GetExceptionInformation(), _pIFaceEntry->_pServer, pInfo->iid, pInfo->iMethod))
        {
        	*phrCall = RPC_E_SERVERFAULT;
            hr = RPC_E_SERVERFAULT;
        }

        // We need to free the server frame only if it has been copied
        // Note that we do free the server frame even if the call invoke
        // itself has failed in order to release the [in] interface pointers
        // and put in [out] values that the client might expect
        if(pServerFrame)
        {
            // Set the flag for the release of [in] interface ptrs during free
            // of frame.
            pWalkerClient->_dwStage = STAGE_FREE;
            
            // Set up the walkers for freeing/marshaling of interface ptrs
            ICallFrameWalker* pMarshalOut = NULL;
            ICallFrameWalker* pFreeIn = NULL;
            
            if(0 != pInfo->cOutInterfacesMax)
            {
                // First time pWalkerServer is used, it's still in STAGE_MARSHAL.
                // If this assert fires, either the walker is corrupted, or
                // it's already been used, and the Free call below isn't going to
                // do what it's supposed to.
                Win4Assert(pWalkerServer->_dwStage == STAGE_MARSHAL);
                pMarshalOut = (ICallFrameWalker *)pWalkerServer;
            }
            
            if(0 != pInfo->cInInterfacesMax)
                pFreeIn = (ICallFrameWalker *)pWalkerClient;
            
            ULONG dwFreeWhat = CALLFRAME_FREE_IN | CALLFRAME_FREE_TOP_OUT;
            
            if (fIsIDispatchInvoke)
            {
                // This will free our dispparams.
                dwFreeWhat |= CALLFRAME_FREE_TOP_INOUT;
            }

            CNullWalker nullWalker;
            hr = pServerFrame->Free(pClientFrame,         // Frame to which return values are copied
                                    &nullWalker,          // Null out source [in,out] interfaces, since we'll 
                                                          // release them later.
                                    pMarshalOut,          // Walks the [out] interface ptrs
                                                          // of the source frame, marshaling them and
                                                          // releasing them
                                    dwFreeWhat,           // Free [in] and top [out] parameters of source frame
                                    pFreeIn,              // Releases the interface pointers of
                                                          // the source frame.
                                    CALLFRAME_NULL_NONE); // Do not null out params
            if(FAILED(hr))
            {
                // Free any memory allocated during marshaling of [out]
                // interface ptrs and release the [out] interface ptrs.
                // - Since we're cleaning up the results of the marshal, we
                // do it on the Client Frame.
                // - At least for IDispatch::Invoke, we need to worry about 
                // [in,out] params here too.
                pWalkerServer->_fError = TRUE;
                pClientFrame->WalkFrame(CALLFRAME_WALK_OUT | CALLFRAME_WALK_INOUT, pWalkerServer);

                // Release the [in] interface ptrs that were not released
                // during the call to free above.  (This is on the server
                // side.)
                pWalkerClient->_fError = TRUE;
                pServerFrame->WalkFrame(CALLFRAME_WALK_IN, pWalkerClient);

                // Now free the thing again.  Shouldn't walk anything, we've 
                // already walked everything.  This will just free the memory,
                // and not release any interface pointers (since we did that 
                // with the walking).
                pServerFrame->Free(NULL,
                                   &nullWalker,
                                   &nullWalker,
                                   dwFreeWhat,
                                   &nullWalker,
                                   CALLFRAME_NULL_NONE);
            }
        }

        if(SUCCEEDED(hr))
        {
            // Get the size of the buffer that is needed by the policy sets
            hr = GetBuffer2(pMsg,_pIFaceEntry->_iid,pWalkerServer,FALSE,FALSE,pcbBuffer);
        }
    }
    else
    {
        // Unmarshaling of [in] interface pointers failed
        // Walk the frame again, releasing any memory allocated during the
        // marshaling of pointers and also releasing any extra references
        // on [in] interface ptrs
        pWalkerClient->_fError = TRUE;
        pServerFrame->WalkFrame(CALLFRAME_WALK_IN, pWalkerClient);
    }

    ContextDebugOut((DEB_CTXCHNL,"CCtxChnl::SyncInvoke2 is returning hr:0x%x\n", hr));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::SendReceive2     private
//
//  Synopsis:   (1) Allocate a buffer for client side call events on the stack
//              (2) Deliver the client call side call
//              (3) Switch to server context
//              (4) Deliver server side enter events
//              (5) Call SyncInvoke2
//              (6) Allocate buffer for server side leave events on the heap
//              (7) Deliver server side leave events
//              (8) Switch to client context
//              (9) Deliver client side return events
//              (10) If any of the above fails, then clean up properly.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::SendReceive2(RPCOLEMESSAGE *pMsg,  HRESULT *phrCall,
                                    DWORD cbBuffer, CCtxCall* pWalkerClient, CCtxCall* pWalkerServer,
                                    ICallFrame* pClientFrame, ICallFrame* pServerFrame,
                                    CALLFRAMEINFO* pInfo)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::SencReceive2\n"));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    HRESULT hrRet = S_OK;
    CObjectContext *pClientCtx = NULL;
    CObjectContext *pServerCtx = NULL;
    CPolicySet* pPS = NULL;
    LPVOID pvBuff = NULL;
    DWORD_PTR dwPtr = 0;    

    // Ensure that GetBuffer was called before
    Win4Assert(pWalkerClient && (pWalkerClient->_dwFlags & CTXCALLFLAG_GBSUCCESS));

    // Get the tls
    COleTls tls(hr);

    if(SUCCEEDED(hr))
    {
        pClientCtx = tls->pCurrentCtx;

        // Allocate the buffer size requested on the stack
        pvBuff = _alloca(cbBuffer+7);
        if(NULL == pvBuff)
            hr = E_OUTOFMEMORY;
        else
        {
            // Align to eight-byte boundary
            dwPtr = (((DWORD_PTR)pvBuff) + 7) & ~0x7;
            pMsg->Buffer = (LPVOID)dwPtr;
            pMsg->cbBuffer = cbBuffer;
            Win4Assert(!(((ULONG_PTR) pMsg->Buffer) & 7) &&
                       "Buffer is not 8-byte aligned");

            if(pInfo->fDerivesFromIDispatch)
            {
                // If the method is IDispatch::Invoke then extract
                // the dispid from the stack and put it in the buffer
                if(6 == pInfo->iMethod)
                {
                    Win4Assert(sizeof(DISPID) <= pMsg->cbBuffer);
                    LPVOID pvStack = pClientFrame->GetStackLocation();
                    CALLFRAMEPARAMINFO param = {0,};
                    // DISPID is the first parameter to the call
                    hr = pClientFrame->GetParamInfo(0,&param);
                    if(SUCCEEDED(hr))
                    {
                        *(DISPID *)(pMsg->Buffer) =
                            *(DISPID *)(((LPBYTE)pvStack) + param.stackOffset);
                    }
                }
            }
            // Save buffer pointer and update the message
            if(pWalkerClient->_cbExtent)
            {
               pWalkerClient->_pvExtent = pMsg->Buffer;
               pMsg->Buffer = (((BYTE *) pMsg->Buffer) + pWalkerClient->_cbExtent);
            }
        }


        if(SUCCEEDED(hr))
        {
            // Save the dispatch buffer because CPolicySet::ResetState
            // clears it
            if(pWalkerClient->_pvExtent)
                pvBuff = pWalkerClient->_pvExtent;
            else
                pvBuff = pMsg->Buffer;

            // Get the Policy set node set during call to GetBuffer2
            pPS = pWalkerClient->_pPS;

            // Create rpc call object on the stack
            const IUnknown *pIdentity = _pStdWrapper;
            CRpcCall rpcClient(pIdentity, pMsg, _pIFaceEntry->_iid,
                               hrRet, CALLSOURCE_CROSSCTX);

            // Deliver client side call events
            hr = pPS->FillBuffer(&rpcClient, CALLTYPE_SYNCCALL, pWalkerClient);

            // Reset state inside context call object
            CPolicySet::ResetState(pWalkerClient);
            if(SUCCEEDED(hr))
            {
                // Create rpc call object on the stack
                CRpcCall rpcServer(_pStdWrapper->GetIdentity(),
                                    pMsg, _pIFaceEntry->_iid,
                                    hrRet, CALLSOURCE_CROSSCTX);

                // Switch to the server context
                pServerCtx = pPS->GetServerContext();
                tls->pCurrentCtx = pServerCtx;
                if(pServerCtx)
                {
                    pServerCtx->InternalAddRef();
                    tls->ContextId = pServerCtx->GetId();
                }
                else
                {
                    tls->ContextId = (ULONGLONG)-1;
                }

                // If the server is in the NA, make sure the thread is in the NA.
                BOOL fEnteredNA = FALSE;
                if (pServerCtx->GetComApartment() == gpNTAApartment)                
                {
                    if (!IsThreadInNTA())
                    {
                        tls->dwFlags |= OLETLS_INNEUTRALAPT;
                        fEnteredNA = TRUE;
                    }
                }
                Win4Assert(!IsThreadInNTA() || pServerCtx->GetComApartment() == gpNTAApartment);
                Win4Assert(IsThreadInNTA() || pServerCtx->GetComApartment() != gpNTAApartment);

                // Update server side context call object
                pWalkerServer->_pPS = pPS;
                // NOTE: This variable is set in GetBuffer2
                if(pWalkerClient->_cbExtent)
                    pWalkerServer->_pvExtent = pvBuff;
                pWalkerServer->_pContext = tls->pCurrentCtx;
                ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                             pClientCtx, tls->pCurrentCtx));


                // Update message
                pMsg->reserved1 = pWalkerServer;
                pMsg->reserved2[0] = NULL;
                pMsg->reserved2[1] = NULL;
                pMsg->reserved2[3] = NULL;
                pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;

                // Deliver server side notification events
                hr = pPS->Notify(&rpcServer, CALLTYPE_SYNCENTER, pWalkerServer);

                if(SUCCEEDED(hr))
                {
                    // Unmarshal the interface ptrs, invoke the call and marshal the
                    // interface ptrs
                    hr = SyncInvoke2(pMsg, &cbBuffer, pWalkerServer, pWalkerClient,
                                    pClientFrame,pServerFrame, pInfo, phrCall);

                    // Make sure we're back on the right context
                    CheckContextAfterCall (tls, pServerCtx);
                }

                // Deliver server side leave events
                if(hr != RPC_E_INVALID_HEADER)
                {
                    // Check if GetBuffer was called by the stub
                    if(pWalkerServer->_dwFlags & CTXCALLFLAG_GBSUCCESS)
                    {
                        // Update call status to that saved in GetBuffer
                        if(FAILED(pWalkerServer->_hr))
                            hr = pWalkerServer->_hr;
                    }
                    else if(!(pWalkerServer->_dwFlags & CTXCALLFLAG_GBFAILED))
                    {
                        // The call must have failed
                        Win4Assert(FAILED(hr));

                        // Initialize
                        CPolicySet::ResetState(pWalkerServer);
                        pMsg->cbBuffer = 0;
                        pMsg->Buffer = NULL;

                        // Obtain the buffer size needed by the server side policies
                        // GetSize will fail on the server side only if no policy
                        // expressed interest in sending data to the client side
                        pPS->GetSize(&rpcServer, CALLTYPE_SYNCLEAVE, pWalkerServer);

                        // Allocate buffer if server side  policies wish to send
                        // buffer to the client side
                        if(pWalkerServer->_cbExtent)
                        {
                            pWalkerServer->_pvExtent = PrivMemAlloc8(pWalkerServer->_cbExtent);
                            if(NULL == pWalkerServer->_pvExtent)
                                hr = E_OUTOFMEMORY;
                        }
                    }

                    rpcServer.SetServerHR(*phrCall);

                    //
                    //  Deliver the (server-side) leave events.  Note that we are ignoring
                    //  the return result of this call.   This is because policies should
                    //  never fail the leave and return events;  however, the implementation
                    //  of CPolicySet::DeliverEvents ends up returning the hresult that the
                    //  the policies may have set via ICall::Nullify.    So we ignore the
                    //  return result here, and only pay attention to the server's hr and
                    //  the hr set by the policies.
                    //
                    hr = pPS->FillBuffer(&rpcServer, CALLTYPE_SYNCLEAVE, pWalkerServer);
                }

                // Save the return buffer
                if(pWalkerServer->_cbExtent)
                    pWalkerClient->_pvExtent = pWalkerServer->_pvExtent;

                // Switch back to the saved context
                ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                    pClientCtx, tls->pCurrentCtx));

                if(pServerCtx)
                {
                    pServerCtx->InternalRelease();
                    pServerCtx = NULL;
                }

                tls->pCurrentCtx = pClientCtx;
                Win4Assert(pClientCtx);
                tls->ContextId = pClientCtx->GetId();

                // If we switched the thread into the NA, switch it out.
                if (fEnteredNA)
                {
                    tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
                }
                Win4Assert(!IsThreadInNTA() || tls->pCurrentCtx->GetComApartment() == gpNTAApartment);
                Win4Assert(IsThreadInNTA() || tls->pCurrentCtx->GetComApartment() != gpNTAApartment);

                // Update message
                pMsg->reserved1 = pWalkerClient;
                pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;
            }

            // Deliver client side notification events
            rpcClient.SetServerHR(*phrCall);

            //
            //  Here again we are ignoring the return code from delivering the
            //  return events.    See the comments above where we deliver
            //  the leave events for more information.
            //
            hr = pPS->Notify(&rpcClient, CALLTYPE_SYNCRETURN, pWalkerClient);

            //
            //  If the policies (if any) did not override the server's hr, then
            //  do normal unmarshalling.   Otherwise, we need to cleanup the
            //  server's out-params, since he might think everything is okay.
            //
            if(SUCCEEDED(hrRet))
            {
                // Unmarshal the [out] interface pointers
                if(0 != pInfo->cOutInterfacesMax)
                {
                    pWalkerServer->_dwStage = STAGE_UNMARSHAL;
                    DWORD dwWalkWhat = CALLFRAME_WALK_OUT;

                    // The case of IDispatch::Invoke is special as it has some
                    // [in,out] parameters.
                    if(pInfo->fDerivesFromIDispatch && (6 == pInfo->iMethod))
                        dwWalkWhat |= CALLFRAME_WALK_INOUT;

                    hr = pClientFrame->WalkFrame(
                                                dwWalkWhat,
                                                pWalkerServer   // Walker will unmarshal
                                                                // the out parameters
                                                );
                    if(FAILED(hr))
                    {
                        // Free any memory allocated during marshaling of [out]
                        // interface ptrs and release the [out] interface ptrs
                        pWalkerServer->_fError = TRUE;
                        pClientFrame->WalkFrame(dwWalkWhat, pWalkerServer);
                    }
                }

                // Release and free the storage for any [in,out] interfaces
                // we've found.
                if (pInfo->fDerivesFromIDispatch && (6 == pInfo->iMethod))
                {
                    if (pWalkerClient->_cItfs > 0)
                        pWalkerClient->FreeBuffer();
                }
            }
            else
            {  
                // One or more policies decided to nullify the call.  This means we
                // must cleanup for the server.                
                if ((pWalkerClient->_dwStage & STAGE_MARSHAL) && (pServerFrame))
                {
                    // We're making a copy but we never got to unmarshal the 
                    // [in] params.  Cleanup now.  Don't need to clean up any
                    // of the [out] params.
                    // REVIEW: What do we do if this fails?
                    pWalkerClient->_fError = TRUE;
                    pServerFrame->WalkFrame(CALLFRAME_WALK_IN, pWalkerClient);
                }
                else
                {
                    ICallFrameWalker* pWalkerTemp = NULL;
                
                    // Use the walker to properly free/null interface parameters
                    if(0 != pInfo->cOutInterfacesMax)
                    {
                        pWalkerServer->_fError = TRUE;
                        pWalkerServer->_dwStage = STAGE_UNMARSHAL;
                        pWalkerTemp = pWalkerServer;
                    }

                    // REVIEW: What do we do if this fails?
                    pClientFrame->Free(NULL,
                                       NULL,
                                       NULL,
                                       CALLFRAME_FREE_OUT | CALLFRAME_FREE_INOUT,
                                       pWalkerTemp,
                                       CALLFRAME_NULL_OUT | CALLFRAME_NULL_INOUT);
                }
            }
        }
    }
    

    // Restore contexts in case a failure did not restore them
    if(pClientCtx)
    {
        tls->pCurrentCtx = pClientCtx;
        tls->ContextId = pClientCtx->GetId();
    }

    if(pServerCtx)
    {
        pServerCtx->InternalRelease();
        pServerCtx = NULL;
    }

    // Check for premature failure case
    if(FAILED(hrRet))
    {
        // Reset
        pMsg->Buffer = NULL;
    }
    else
        pWalkerClient->_dwFlags |= CTXCALLFLAG_SRSUCCESS;

    ContextDebugOut((DEB_CTXCHNL,"CCtxChnl::SendReceive2 is returning hr:0x%x\n", hr));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hrRet;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::OnCall     private
//
//  Synopsis:   Implements the ICallFrame::OnCall method
//              (1) Get the callframe info
//              (2) Allocate the client context and server context call objects
//              (3) Copy the frame if there are interface pointer parameters
//              (4) Call GetBuffer2 to get the buffer needed by policy sets
//              (5) Call SendReceive2
//              (6) If any of the above fails, clean up properly.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::OnCall(ICallFrame* pClientFrame)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::OnCall\n"));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);


    HRESULT hr = S_OK;
    CALLFRAMEINFO info = {0,};
    HRESULT hrCall = S_OK;
    ICallFrame* pServerFrame = NULL;
    CPolicySet* pPS = NULL;
    BOOL fLockedWrapper = FALSE;
    DWORD cbBuffer = 0;
    LPVOID pvBuff = NULL;
    DISPID dispID = 0;

    // Get the callframe information
    hr = pClientFrame->GetInfo(&info);

    if(SUCCEEDED(hr))
    {
        // Assert that there are no [in,out] interface parameters or the
        // interface derives from IDipatch or it is IDispatch itself
        Win4Assert(((0 == info.cInOutInterfacesMax)
                    || (info.fDerivesFromIDispatch)
                    || (IID_IDispatch == info.iid))
                    && "[in,out] interfaces present");


        // Null the [out] parameters in the client frame for us.
        // We do this here because the level of bookwork needed to keep
        // track of the parameters we've copied/freed/anything else
        // is too great.
        //
        // Also, the interceptor/callframe infrastructure does not have 
        // great semantics on the state of the callframe if a copy or
        // free fails in the middle, so we need both frames to be in a
        // safe state.
        //
        // REVIEW: Gee, I hope this isn't slow.  It doesn't look like it
        //         ought to be slow.
        hr = pClientFrame->Free(NULL,
                                NULL,
                                NULL,
                                CALLFRAME_FREE_NONE,
                                NULL,
                                CALLFRAME_NULL_OUT);
    }

    if(SUCCEEDED(hr))
    {        // Create an RPCOLEMESSAGE data structure on the stack
        RPCOLEMESSAGE msg = {
                            NULL,                           // reserved1
                            NDR_LOCAL_DATA_REPRESENTATION,  // dataRepresentation
                            pvBuff,                         // Buffer
                            cbBuffer,                       // cbBuffer
                            info.iMethod,                   // iMethod
                            {0,},                           // reserved2[5]
                            0,                              // rpcFlags
                            };


        // Create a client context call object
        CCtxCall walkerClient(
                            CTXCALLFLAG_CLIENT | CTXCALLFLAG_CROSSCTX,
                            msg.dataRepresentation,
                            STAGE_MARSHAL,          // Marshaling stage
                            (GetWrapper())->IsNAWrapper() ? MSHCTX_INPROC : MSHCTX_UNINITIALIZED);

        // Create a server context call object
        CCtxCall walkerServer(
                            CTXCALLFLAG_SERVER | CTXCALLFLAG_CROSSCTX,
                            msg.dataRepresentation,
                            STAGE_MARSHAL,          // Unmarshaling stage
                            (GetWrapper())->IsNAWrapper() ? MSHCTX_INPROC : MSHCTX_UNINITIALIZED);

        // Get the size of the buffer that is needed by the policy sets
        hr = GetBuffer2(&msg,_pIFaceEntry->_iid,&walkerClient,TRUE,FALSE,&cbBuffer);

        // For IDispatch::Invoke we have to provide DISPID as the first
        // value in the RPCOLEMESSAGE buffer
        if(info.fDerivesFromIDispatch && 6 == info.iMethod)
            cbBuffer += sizeof(DISPID);

        if(SUCCEEDED(hr))
        {
            // A successful call to GetBuffer2 locks the wrapper object
            fLockedWrapper = TRUE;

            // A successful call to GetBuffer2 sets the Policy Set
            pPS = walkerClient._pPS;

            if (info.fDerivesFromIDispatch && (6 == info.iMethod))
            {
                // Count [in,out] interface pointers
                // Note that our IDispatch::Invoke counts all interface 
                // pointers as [in,out] if they're BYREF.
                walkerClient._cItfs   = 0;
                walkerClient._dwStage = STAGE_COUNT;
                pClientFrame->WalkFrame(CALLFRAME_WALK_INOUT, &walkerClient);
                
                // If there were any [in,out] interface pointers, collect them
                // prior to marshaling.
                if (walkerClient._cItfs > 0)
                {
                    if (walkerClient.AllocBuffer())
                    {                    
                        walkerClient._idx = 0;
                        walkerClient._dwStage = STAGE_MARSHAL | STAGE_COLLECT;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                } else {
                    walkerClient._dwStage = STAGE_MARSHAL;
                }
            }

            if (SUCCEEDED(hr))
            {
                // Get a copy of the client frame, in the process of copying the
                // [in] and [in,out] interface parameters get marshaled
                if(0 != info.cInInterfacesMax)
                {
                    walkerClient._dwStage |= STAGE_COPY;
                    hr = pClientFrame->Copy(CALLFRAME_COPY_NESTED, &walkerClient, &pServerFrame);
                    walkerClient._dwStage &= ~STAGE_COPY;
                }
                else if(0 != info.cOutInterfacesMax)
                    hr = pClientFrame->Copy(CALLFRAME_COPY_NESTED, NULL, &pServerFrame);
            }

            // Make sure that hr is S_OK as interceptors throw for any
            // hr != S_OK. Also make sure that the copy succeeded.
            if(S_OK == hr && S_OK == walkerClient._hr)
            {
                // This will invoke the method on the object
                hr = SendReceive2(&msg,&hrCall,cbBuffer, &walkerClient,
                                    &walkerServer, pClientFrame, pServerFrame, &info);
            }
            else
            {
                // The copy of the client frame has failed
                // Walk the frame and release any memory allocated
                // during marshaling of [in] interface ptrs
                walkerClient._fError = TRUE;
                if(pServerFrame)
                    pServerFrame->WalkFrame(CALLFRAME_WALK_IN, &walkerClient);

                // Set the appropriate failure value
                if(S_OK == hr && S_OK != walkerClient._hr)
                    hr = walkerClient._hr;
            }
        }
    }

    // Set the return value because the return value is propagated to
    // the client and not the hr. Additionally, force the hr to be S_OK
    if(S_OK != hrCall)
    {
        pClientFrame->SetReturnValue(hrCall);
    }
    else
    {
        pClientFrame->SetReturnValue(hr);
    }
    hr = S_OK;

    // Release the server frame
    if(pServerFrame)
        pServerFrame->Release();

    if(fLockedWrapper)
        // Unlock the wrapper
        _pStdWrapper->Unlock(pPS);

    ContextDebugOut((DEB_CTXCHNL,"CCtxChnl::OnCall is returning hr:0x%x\n", hr));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   CoCreateObjectInContext   Public
//
//  Synopsis:   Creates a wrapper for the given object from the specified
//              context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
STDAPI CoCreateObjectInContext(IUnknown *pServer, IObjContext *pCtx,
                               REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CoCreateObjectInContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CObjectContext *pCurrentCtx;
    CObjectContext *pServerCtx;
    HRESULT hr;

    // Initialize
    *ppv = NULL;

    // Ensure that the object context is indeed CObjectContext
    hr = pCtx->QueryInterface(IID_IStdObjectContext, (void **) &pServerCtx);
    if(SUCCEEDED(hr))
    {
        // Internal code.  We want an internal ref count.
        pServerCtx->InternalAddRef();
        pServerCtx->Release();

        // Initialize channel
        hr = InitChannelIfNecessary();

        if(SUCCEEDED(hr))
        {
            // REVIEW: Ensure that there is no existing wrapper
            //         with the desired interface for perf
            ;

            // Obtain current context
            pCurrentCtx = GetCurrentContext();

            // Ensure that the contexts are different
            if(pCurrentCtx != pServerCtx)
            {
                 // Create XCtxWrapperData
                XCtxWrapperData wrapperData;

                // Initialize
                wrapperData.pIID       = &riid;
                wrapperData.pServer    = pServer;
                wrapperData.dwState    = 0;
                wrapperData.pServerCtx = pServerCtx;
                wrapperData.pClientCtx = pCurrentCtx;

                // Perform callback to create wrapper
                hr = PerformCallback(pServerCtx, CreateWrapper, &wrapperData,
                                     IID_IStdWrapper, 3, NULL);
                if(SUCCEEDED(hr))
                    *ppv = wrapperData.pv;
            }
            else
                hr = E_INVALIDARG;
        }

        // Release server context
        pServerCtx->InternalRelease();
    }
    else
        hr = E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CoCreateObjectInContext returning hr:0x%x\n", hr));
    return(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   MarshalObjectToContext   Public
//
//  Synopsis:   Creates a wrapper for the given object from the specified
//              context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT MarshalObjectToContext(CObjectContext *pClientCtx, IUnknown *pServer,
                               DWORD dwState, REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "MarshalObjectToContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity check
    Win4Assert(!CStdWrapper::IsNotImplInterface(riid));

    // Initialize
    XCtxWrapperData wrapperData;
    wrapperData.pIID       = &riid;
    wrapperData.pServer    = pServer;
    wrapperData.dwState    = dwState;
    wrapperData.pServerCtx = GetCurrentContext();
    wrapperData.pClientCtx = pClientCtx;

    // Delegate to CreateWrapper
    HRESULT hr = CreateWrapper(&wrapperData);
    *ppv = wrapperData.pv;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "MarshalObjectToContext returning hr:0x%x\n", hr));
    return(hr);
}

//---------------------------------------------------------------------------
//
//  Function:   FindOrCreateWrapper   Private
//
//  Synopsis:   Lookup/Create a wrapper for the given object
//
//  Parameters: [pUnkServer] - controlling IUnknown of the server object
//              [pServerCtx] - context in which the object lives
//              [fCreate]    - TRUE: create the IDObject if it does not exist
//              [dwFlags]    - IDLF_* flags (used only if wrapper created)
//              [ppWrapper]  - where to return the CStdWrapper ptr,
//                             InternalAddRef'd.
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT FindOrCreateWrapper(IUnknown *pUnkServer, CObjectContext *pServerCtx,
                            BOOL fCreate, DWORD dwFlags, CStdWrapper **ppWrapper)
{
    ContextDebugOut((DEB_WRAPPER, "FindOrCreateWrapper pUnkServer:%x\n", pUnkServer));

    *ppWrapper = NULL;

    // Find or create an IDObject and StdWrapper
    CIDObject *pID    = NULL;
    APTID     dwAptId = GetCurrentApartmentId();

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Lookup IDObject for the server object
    HRESULT hr = gPIDTable.FindOrCreateIDObject(pUnkServer, pServerCtx,
                                                fCreate, dwAptId, &pID);
    if (SUCCEEDED(hr))
    {
        // Sanity check
        Win4Assert(pID->GetServer() == pUnkServer);
        Win4Assert(pID->IsServer());

        // Obtain the wrapper
        hr = pID->GetOrCreateWrapper(fCreate, dwFlags, ppWrapper);
    }

    // Release lock
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (pID)
    {
        // release reference acquired above
        pID->Release();
    }

    ContextDebugOut((DEB_WRAPPER, "FindOrCreateWrapper hr:%x pWrapper:%x\n",
                    hr, *ppWrapper));
    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   CreateWrapper   Private
//
//  Synopsis:   Creates a wrapper for the given object
//
//  Parameters: [pv] - ptr to XCtxWrapperData structure
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT __stdcall CreateWrapper(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CreateWrapper\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity check
    XCtxWrapperData *pWrapperData = (XCtxWrapperData *) pv;
    Win4Assert(pWrapperData->pServerCtx == GetCurrentContext());
    Win4Assert(!CStdWrapper::IsNotImplInterface(*pWrapperData->pIID));

    // Initialize
    pWrapperData->pv = NULL;

    // make sure the server supports the requested interface.
    IUnknown *pUnk = NULL;
    HRESULT hr = pWrapperData->pServer->QueryInterface(*pWrapperData->pIID,
                                                       (void **) &pUnk);
    if (SUCCEEDED(hr))
    {
        // object supports the interface. find or create the wrapper
        CStdWrapper *pStdWrapper = NULL;
        hr = FindOrCreateWrapper(pWrapperData->pServer,
                                 pWrapperData->pServerCtx,
                                 TRUE /*fCreate*/,
                                 pWrapperData->dwState,
                                 &pStdWrapper);
        if (SUCCEEDED(hr))
        {
            hr = pStdWrapper->WrapInterfaceForContext(
                                          pWrapperData->pClientCtx,
                                          pUnk,
                                         *pWrapperData->pIID,
                                         &pWrapperData->pv);

            // WrapInterfaceForContext does not give us a new reference,
            // so we'll recycle the one from FindOrCreateWrapper() if 
            // WrapInterfaceForContext fails.
            if (FAILED(hr))
            {
                pStdWrapper->InternalRelease(NULL);
            }
        }

        pUnk->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CreateWrapper returning 0x%x\n", hr));
    return(hr);
}

//---------------------------------------------------------------------------
//
//  Function:   ObtainWrapper   Private
//
//  Synopsis:   Lookup/Create a wrapper for the given object
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CStdWrapper *ObtainWrapper(IUnknown *pServer, BOOL fCreate, DWORD mshlflags)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    CStdWrapper *pStdWrapper = NULL;

    // Get the IUnknown interface of the object.
    IUnknown *pUnkServer = NULL;
    HRESULT hr = pServer->QueryInterface(IID_IUnknown, (void **) &pUnkServer);
    if (SUCCEEDED(hr))
    {
        // Set up the creation flags based on the mshlflags passed in.
        DWORD dwFlags = 0;

        if (mshlflags & MSHLFLAGS_NO_IEC)
            dwFlags |= IDLF_NOIEC;

        if (mshlflags & MSHLFLAGS_NOPING)
            dwFlags |= IDLF_NOPING;

        hr = FindOrCreateWrapper(pUnkServer, GetCurrentContext(),
                                 fCreate, dwFlags, &pStdWrapper);

        pUnkServer->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return pStdWrapper;
}

//---------------------------------------------------------------------------
//
//  Function:   GetStaticWrapper   Private
//
//  Synopsis:   Returns the global wrapper used for unmarshaling
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT GetStaticWrapper(IMarshal **ppIM)
{
    if (gpStaticWrapper == NULL)
    {
        // not yet initialized, create a static wrapper
        CStaticWrapper *pStaticWrapper = new CStaticWrapper();
        if (!pStaticWrapper)
        {
            // could not create it, return an error
            return E_OUTOFMEMORY;
        }

        if (InterlockedCompareExchangePointer((void **)&gpStaticWrapper,
                                               pStaticWrapper,
                                               NULL) != NULL)
        {
            // another thread created it first, so just delete
            // the one we created.
            delete pStaticWrapper;
        }
    }

    *ppIM = (IMarshal *) gpStaticWrapper;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Function:   WrapperMarshalObject   Private
//
//  Synopsis:   Returns the global wrapper used for unmarshaling
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT WrapperMarshalObject(IStream *pStm, REFIID riid, IUnknown *pUnk,
                             DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    ContextDebugOut((DEB_WRAPPER, "WrapperMarshalObject pUnk:%x\n", pUnk));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Obtain the wrapper for the server object
    CStdWrapper *pStdWrapper = ObtainWrapper(pUnk, TRUE, mshlflags);
    if (pStdWrapper)
    {
        // Marshal
        hr = pStdWrapper->MarshalServer(NULL, pStm, riid, dwDestCtx, pvDestCtx, mshlflags);
        // Fixup the refcount (ObtainWrapper increments the reference count, or returns 
		// a new CStdWrapper with a refcount of 1.  MarshalServer also bumps up the refcount,
		// so we need to compensate here).
        pStdWrapper->InternalRelease(NULL);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "WrapperMarshalObject hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::QueryInterface     public
//
//  Synopsis:   QI behavior of static wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::QueryInterface(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStaticWrapper::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) this;
    }
    else if(IsEqualIID(riid, IID_IMarshal))
    {
        *ppv = (IMarshal *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // No need to AddRef the interface before returning
    ContextDebugOut((DEB_POLICYSET, "CStaticWrapper::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::AddRef     public
//
//  Synopsis:   AddRef behavior of static wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStaticWrapper::AddRef()
{
    return(1);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::Release     public
//
//  Synopsis:   Release behavior of static wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStaticWrapper::Release()
{
    return(1);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::GetUnmarshalClass     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::GetUnmarshalClass(REFIID riid, LPVOID pv,
                                               DWORD dwDestCtx, LPVOID pvDestCtx,
                                               DWORD mshlflags, LPCLSID pClsid)
{
    Win4Assert(!"CStaticWrapper::GetUnmarshalClass got called");
    return(E_UNEXPECTED);
}

//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::GetMarshalSizeMax     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::GetMarshalSizeMax(REFIID riid, LPVOID pv,
                                               DWORD dwDestCtx, LPVOID pvDestCtx,
                                               DWORD mshlflags, LPDWORD pSize)
{
    Win4Assert(!"CStaticWrapper::GetMarshalSizeMax got called");
    return(E_UNEXPECTED);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::MarshalInterface     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::MarshalInterface(LPSTREAM pStm, REFIID riid,
                                              LPVOID pv, DWORD dwDestCtx,
                                              LPVOID pvDestCtx, DWORD mshlflags)
{
    Win4Assert(!"CStaticWrapper::MarshalInterface got called");
    return(E_UNEXPECTED);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::UnMarshalInterface     public
//
//  Synopsis:   Unmarshals the specified interface on a wrapper
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::UnmarshalInterface(LPSTREAM pStm, REFIID riid,
                                                LPVOID *ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStaticWrapper::UnmarshalInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Initialize
    *ppv = NULL;

    // Read xCtxMarshalData from the stream
    XCtxMarshalData xCtxMarshalData;
    HRESULT hr = StRead(pStm, &xCtxMarshalData, sizeof(xCtxMarshalData));
    if(SUCCEEDED(hr))
    {
        // Get Local OXID Entry
        OXIDEntry *pOXIDEntry;
        hr = GetLocalOXIDEntry(&pOXIDEntry);

        // Validate the signature

        if((xCtxMarshalData.dwSignature == CROSSCTX_SIGNATURE) /*&&
           (pOXIDEntry && (pOXIDEntry->GetMoxid() == xCtxMarshalData.moxid))*/)
        {
            REFIID miid = xCtxMarshalData.iid;
            IFaceEntry *pIFaceEntry    = xCtxMarshalData.pEntry;
            CStdWrapper *pWrapper      = xCtxMarshalData.pWrapper;
            CObjectContext *pClientCtx = GetCurrentContext();
            CObjectContext *pServerCtx = xCtxMarshalData.pServerCtx;

			if (pWrapper == NULL)
			{
				// What error do we return here?
				hr = RPC_E_INVALID_OBJREF;
			}
            // Compare marshaled and requested IIDs
            else if(IsEqualIID(miid, riid) || IsEqualIID(riid, GUID_NULL))
            {
                BOOL fRelease;

                // Sanity checks
                Win4Assert(pIFaceEntry || IsEqualIID(miid, IID_IUnknown));
                Win4Assert(!pIFaceEntry || IsEqualIID(miid, pIFaceEntry->_iid));
			   
				// If the object was table marshaled, then we're giving out new
				// references to the object.... in addition to the reference we
				// put into the stream in MarshalInterface().
				Win4Assert(!(xCtxMarshalData.dwMarshalFlags & MSHLFLAGS_TABLEWEAK));
				if (pWrapper && (xCtxMarshalData.dwMarshalFlags & MSHLFLAGS_TABLESTRONG))
					pWrapper->InternalAddRef();

                // Compare contexts
                if(pClientCtx == pServerCtx)
                {
                    // Return native pointer
                    if(pIFaceEntry)
                        *ppv = pIFaceEntry->_pServer;
                    else
                        *ppv = pWrapper->GetServer();

                    // Wrapper could have been disconnected between marshaling
                    // and unmarshaling
                    if(*ppv)
                        ((IUnknown *) (*ppv))->AddRef();

                    // Fixup reference count... we're handing out a reference
					// to the real object, not our own object, so release the
					// reference to the wrapper held in the stream.
                    fRelease = TRUE;
                }
                else
                {
                    // Validate the wrapper and interface for the current context
                    if(pWrapper->ValidateContext(pClientCtx, pIFaceEntry))
                    {
                        if(pIFaceEntry)
                            *ppv = pIFaceEntry->_pProxy;
                        else
                            *ppv = pWrapper->GetImplInterface(miid);
                        fRelease = FALSE;
                    }
                    else
                    {
                        // Fixup reference count... release the reference to the wrapper
						// held in the stream.
                        fRelease = TRUE;
                        hr = E_OUTOFMEMORY;
                    }
                }

                // Release wrapper if neccessary
                if(fRelease)
                    pWrapper->InternalRelease(NULL);
            }
            else
                hr = E_INVALIDARG;
        }
        else
            hr = E_INVALIDARG;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStaticWrapper::UnmarshalInterface returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::ReleaseMarshalData     public
//
//  Synopsis:   Releases the given marshaled data
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::ReleaseMarshalData(LPSTREAM pStm)
{
    ContextDebugOut((DEB_WRAPPER, "CStaticWrapper::ReleaseMarshalData\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    XCtxMarshalData xCtxMarshalData;

    // Read xCtxMarshalData from the stream
    hr = StRead(pStm, &xCtxMarshalData, sizeof(xCtxMarshalData));
    if(SUCCEEDED(hr))
    {
        CStdWrapper *pWrapper = xCtxMarshalData.pWrapper;

		if (pWrapper)
		{
			pWrapper->InternalRelease(NULL);

			xCtxMarshalData.pWrapper = NULL;
		}
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStaticWrapper::ReleaseMarshalData returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::DisconnectObject     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::DisconnectObject(DWORD dwReserved)
{
    Win4Assert(!"CStaticWrapper::DisconnectObject got called");
    return(E_UNEXPECTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\machname.cxx ===
//+-------------------------------------------------------------------
//
//  File:       machname.cxx
//
//  Contents:   Implements classes for supporting local machine name
//              comparisons.
//
//  Classes:    CLocalMachineName
//
//  History:    02-Feb-02   jsimmons      Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <machnames.h>    // interface defn
#include "ipidtbl.hxx"
#include "machname.hxx"   // class defn
#include "resolver.hxx"


CMachineNamesHelper::CMachineNamesHelper() :
                _lRefs(1),
                _dwNumStrings(0),
                _ppszStrings(NULL)
{
}

CMachineNamesHelper::~CMachineNamesHelper()
{
    Win4Assert(_lRefs == 0);
    
    if (_ppszStrings)
    {
        Win4Assert(_dwNumStrings > 0);
        PrivMemFree(_ppszStrings);
        _ppszStrings = NULL;
    }
}

void CMachineNamesHelper::IncRefCount()
{
    InterlockedIncrement((PLONG)&_lRefs);
    return;
}

void CMachineNamesHelper::DecRefCount()
{
    DWORD dwRefs = InterlockedDecrement((PLONG)&_lRefs);
    if (dwRefs == 0)
    {
        delete this;
    }
    return;
}

DWORD CMachineNamesHelper::Count()
{
    return _dwNumStrings;
}

const WCHAR* CMachineNamesHelper::Item(DWORD dwIndex)
{
    if (dwIndex < _dwNumStrings)
    {
        Win4Assert(_ppszStrings);
        Win4Assert(_ppszStrings[dwIndex]);
        return (const WCHAR*)_ppszStrings[dwIndex];
    }
    else
    {
        // This function is for internal usage only, so this should not happen
        Win4Assert(!"Caller should not be asking for non-existent strings");
        return NULL;
    }
}

//
//  CMachineNamesHelper::Create
// 
//  Static function used by CRpcResolver to convert a CDualStringArray into a 
//  CMachineNamesHelper.
//
HRESULT CMachineNamesHelper::Create(CDualStringArray* pCDualStringArray, CMachineNamesHelper** ppHelper)
{
    Win4Assert(pCDualStringArray && ppHelper);

    *ppHelper = NULL;

    // Create the helper object
    CMachineNamesHelper* pHelper = new CMachineNamesHelper();
    if (!pHelper)
        return E_OUTOFMEMORY;

    DUALSTRINGARRAY* pdsa = pCDualStringArray->DSA();
    Win4Assert(pdsa);

    //
    // The bindings as stored in a DUALSTRINGARRAY represent some problems for us.  They
    // are not ordered in any fashion (that we can depend on), and many of the addresses
    // are stored multiple times (eg, once for TCP, once for UDP).   We want to expose a
    // set of unique names.  All of this code below is intended for the purposed of 
    // extracting the set of unique addresses from the dsa.
    //
    SBTOTAL sbtotal;
    ZeroMemory(&sbtotal, sizeof(SBTOTAL));

    // Count total number of addresses, including dupes.
    CMachineNamesHelper::ParseStringBindingsFromDSA(
                            pdsa, 
                            CMachineNamesHelper::SBCallback,
                            &sbtotal);

    // Allocate array of pointers
    if (sbtotal.dwcTotalAddrs > 0)
    {
        sbtotal.ppszAddresses = (WCHAR**)PrivMemAlloc(sizeof(WCHAR*) * sbtotal.dwcTotalAddrs);
        if (!sbtotal.ppszAddresses)
        {
            pHelper->DecRefCount();
            return E_OUTOFMEMORY;
        }

        ZeroMemory(sbtotal.ppszAddresses, sizeof(WCHAR*) * sbtotal.dwcTotalAddrs);

        // Store pointers to each address, including dupes
        CMachineNamesHelper::ParseStringBindingsFromDSA(
                                pdsa,
                                CMachineNamesHelper::SBCallback2,
                                &sbtotal);

        // Sort the address pointers
        qsort(sbtotal.ppszAddresses,
              sbtotal.dwcTotalAddrs,
              sizeof(WCHAR*),
              CMachineNamesHelper::QSortCompare);
                 
        // Go thru the addresses, counting uniques only
        UNIQUEADDRS uaddrs;
        ZeroMemory(&uaddrs, sizeof(UNIQUEADDRS));
        CMachineNamesHelper::ParseStringArrayForUniques(
                                sbtotal.dwcTotalAddrs,
                                sbtotal.ppszAddresses,
                                CMachineNamesHelper::UniqueStringCB,
                                &uaddrs);                            
        
        // Allocate single buffer to store all of the uniques and pointers to same
        DWORD dwBufSizeTotal = uaddrs.dwStringSpaceNeeded + (sizeof(WCHAR*)* uaddrs.dwcTotalUniqueAddrs);
        uaddrs.ppszAddrs = (WCHAR**)PrivMemAlloc(dwBufSizeTotal);
        if (!uaddrs.ppszAddrs)
        {
            PrivMemFree(sbtotal.ppszAddresses);
            pHelper->DecRefCount();
            return E_OUTOFMEMORY;
        }
        ZeroMemory(uaddrs.ppszAddrs, dwBufSizeTotal);
        
        uaddrs.pszNextAddrToUse = (WCHAR*)&(uaddrs.ppszAddrs[uaddrs.dwcTotalUniqueAddrs]);

        // Go thru addresses again, this time storing a copy of each
        CMachineNamesHelper::ParseStringArrayForUniques(
                                sbtotal.dwcTotalAddrs,
                                sbtotal.ppszAddresses,
                                CMachineNamesHelper::UniqueStringCB2,
                                &uaddrs);

        Win4Assert(uaddrs.dwCurrentAddr == uaddrs.dwcTotalUniqueAddrs);

        // Finally done. 
        PrivMemFree(sbtotal.ppszAddresses); // don't need anymore
        pHelper->_dwNumStrings = uaddrs.dwcTotalUniqueAddrs;
        pHelper->_ppszStrings = uaddrs.ppszAddrs;  // pHelper owns memory now
    }
    
    *ppHelper = pHelper;
    return S_OK;
}


//
//  CMachineNamesHelper::ParseStringBindingsFromDSA
// 
//  Private static helper function used to separate out the constituent 
//  STRINGBINDING's in a DUALSTRINGARRAY.
//
//  Arguments:
//        pdsa -- the dualstringarray to parse
//        pfnCallback -- the callback function
//        pv -- void arg to pass to the callback fn
//
void CMachineNamesHelper::ParseStringBindingsFromDSA(DUALSTRINGARRAY* pdsa, 
                                    PFNSTRINGBINDINGCALLBACK pfnCallback,
                                    LPVOID pv)
{
    Win4Assert(pdsa && pfnCallback && pv);

    BOOL fDone;
    DWORD dwcBinding;
    USHORT* pCurrent;
    USHORT* pStart;

    fDone = FALSE;
    dwcBinding = 0;
    pStart = pCurrent = &(pdsa->aStringArray[0]);
    while (!fDone)
    {
        while (*pCurrent != 0)
        {
            pCurrent++;
        }

        if (*(pCurrent+1) == 0)  // double zero, end of string bindings
        {
            fDone = TRUE;
        }
        
        if (pStart != pCurrent)
        {
            STRINGBINDING* psb = (STRINGBINDING*)pStart;
            pfnCallback(pv, psb, dwcBinding);
            dwcBinding++;
        }
        pCurrent++;
        pStart = pCurrent;
    }
    return;
};


//
//  CMachineNamesHelper::SBCallback
//
//  Private static helper function called once for each StringBinding in a
//  DUALSTRINGARRAY.  This one is used when we are counting the total # of
//  addresses in the DSA, including dupes.
//
void CMachineNamesHelper::SBCallback(
                    LPVOID pv,
                    STRINGBINDING* psb,
                    DWORD dwBinding)
{
    Win4Assert(pv && psb);
    
    SBTOTAL* psbtotal = (SBTOTAL*)pv;

    psbtotal->dwcTotalAddrs++;

    return;
}

//
//  CMachineNamesHelper::SBCallback2
// 
//  Private static helper function called once for each StringBinding in a 
//  DUALSTRINGARRAY.  This one is used when we are storing pointers
//
void CMachineNamesHelper::SBCallback2(
                    LPVOID pv, 
                    STRINGBINDING* psb,
                    DWORD dwBinding)
{
    Win4Assert(pv && psb);
    
    SBTOTAL* psbtotal = (SBTOTAL*)pv;
    psbtotal->ppszAddresses[dwBinding] = &(psb->aNetworkAddr);
    
    return;
}

//
//  CMachineNamesHelper::QSortCompare
//
//  Static string comparison function for use with the crt qsort function.
//
int __cdecl CMachineNamesHelper::QSortCompare(const void *arg1, const void *arg2)
{
    Win4Assert(arg1 && arg2);    
    WCHAR* pszStr1 = *(WCHAR**)arg1;
    WCHAR* pszStr2 = *(WCHAR**)arg2;
    return lstrcmpi(pszStr1, pszStr2);
}
    
//
//  CMachineNamesHelper::ParseStringArrayForUniques
// 
//  Private static helper function used to count\examine the unique
//  strings in an array of sorted string pointers.
//
void CMachineNamesHelper::ParseStringArrayForUniques(
                            DWORD dwcStrings,
                            WCHAR** ppszStrings,
                            PFNUNIQUESTRINGCALLBACK pfnCallback,
                            LPVOID pv)
{
    Win4Assert((dwcStrings > 0) && ppszStrings && ppszStrings[0]);

    WCHAR* pszLastUnique = ppszStrings[0]; // the first string is always unique

    pfnCallback(pszLastUnique, pv);
    
    for (DWORD i = 1; i < dwcStrings; i++)
    {
        if (lstrcmpi(pszLastUnique, ppszStrings[i]))
        {
            // found new unique string
            pszLastUnique = ppszStrings[i];

            pfnCallback(pszLastUnique, pv);
        }
    }

    return; 
}

//
//  CMachineNamesHelper::UniqueStringCB
// 
//  Private static callback function for when we are summing up the # of
//  unique addresses.
//
void CMachineNamesHelper::UniqueStringCB(WCHAR* pszAddress, LPVOID pv)
{
    Win4Assert(pszAddress && pv);

    UNIQUEADDRS* puaddrs = (UNIQUEADDRS*)pv;

    puaddrs->dwcTotalUniqueAddrs++;    
    puaddrs->dwStringSpaceNeeded += ((lstrlen(pszAddress) + 1) * sizeof(WCHAR));
    return;
}

//
//  CMachineNamesHelper::UniqueStringCB2
// 
//  Private static callback function for when we are storing the unique 
//  addresses in the final blob.
//
void CMachineNamesHelper::UniqueStringCB2(WCHAR* pszAddress, LPVOID pv)
{
    Win4Assert(pszAddress && pv);

    UNIQUEADDRS* puaddrs = (UNIQUEADDRS*)pv;

    Win4Assert(puaddrs->dwCurrentAddr < puaddrs->dwcTotalUniqueAddrs);
    Win4Assert(puaddrs->pszNextAddrToUse);

    // Copy the string and remember where it is
    lstrcpy(puaddrs->pszNextAddrToUse, pszAddress);
    puaddrs->ppszAddrs[puaddrs->dwCurrentAddr] = puaddrs->pszNextAddrToUse;

    // Set things up for the next address
    puaddrs->pszNextAddrToUse = (puaddrs->pszNextAddrToUse + ((lstrlen(pszAddress) + 1)));
    puaddrs->dwCurrentAddr++;

    return;
}

STDMETHODIMP CLocalMachineNames::QueryInterface(REFIID riid, void** ppv)
{
    if (!ppv)
        return E_POINTER;
    
    *ppv = NULL;
    
    if (riid == IID_IUnknown ||
        riid == IID_IEnumString ||
        riid == IID_ILocalMachineNames)
    {
        *ppv = static_cast<ILocalMachineNames*>(this);
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CLocalMachineNames::AddRef()
{
    return InterlockedIncrement((PLONG)&_lRefs);
}

STDMETHODIMP_(ULONG) CLocalMachineNames::Release()
{
    ULONG lRefs = InterlockedDecrement((PLONG)&_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }
    return lRefs;
}

CLocalMachineNames::CLocalMachineNames() :
    _lRefs(1),
    _dwCursor(0),
    _pMNHelper(NULL),
    _fNeedNewData(TRUE)
{
}

CLocalMachineNames::~CLocalMachineNames()
{
    Win4Assert(_lRefs == 0);

    if (_pMNHelper)
    {
        _pMNHelper->DecRefCount();
        _pMNHelper = NULL;
    }
}

STDMETHODIMP CLocalMachineNames::Next(ULONG ulcStrings, LPOLESTR* ppszStrings, ULONG* pulFetched)
{
    Win4Assert(_lRefs > 0);

    HRESULT hr;
    
    if (!ppszStrings)
        return E_INVALIDARG;

    hr = GetNewDataIfNeeded();
    if (FAILED(hr))
        return hr;
    
    ZeroMemory(ppszStrings, sizeof(WCHAR*) * ulcStrings);

    DWORD i;
    DWORD dwFetched = 0;

    for (i = _dwCursor; 
         (i < _pMNHelper->Count()) && (dwFetched < ulcStrings);
         i++, dwFetched++)
    {        
        ppszStrings[dwFetched] = (LPOLESTR)_pMNHelper->Item(i);
        Win4Assert(ppszStrings[dwFetched]);        
    }
    
    // Advance the cursor
    _dwCursor += dwFetched;

    // Tell how many they got, if they care
    if (pulFetched) 
        *pulFetched = dwFetched;

    return (dwFetched == ulcStrings) ? S_OK : S_FALSE;
}

STDMETHODIMP CLocalMachineNames::Skip(ULONG celt)
{
    Win4Assert(_lRefs > 0);

    HRESULT hr = GetNewDataIfNeeded();
    if (FAILED(hr))
        return hr;
    
    _dwCursor += celt;
    if (_dwCursor >= _pMNHelper->Count())
    {
        _dwCursor = _pMNHelper->Count();
        return S_FALSE;
    }

    return S_OK;
}
    
STDMETHODIMP CLocalMachineNames::Reset()
{
    _dwCursor = 0;
    return S_OK;
}
    
STDMETHODIMP CLocalMachineNames::Clone(IEnumString **ppenum)
{
    return E_NOTIMPL;
}

// RefreshNames -- get new data, and also do a Reset()
STDMETHODIMP CLocalMachineNames::RefreshNames()
{
    if (_pMNHelper)
    {
        _pMNHelper->DecRefCount();
        _pMNHelper = NULL;
    }
    Reset();
    _fNeedNewData = TRUE;
    return S_OK;
}

HRESULT CLocalMachineNames::GetNewDataIfNeeded()
{
    HRESULT hr = S_OK;
    
    if (_fNeedNewData)
    {
        Win4Assert(!_pMNHelper);
        
        hr = gResolver.GetCurrentMachineNames(&_pMNHelper);
        if (SUCCEEDED(hr))
        {
            Win4Assert(_pMNHelper);
            _fNeedNewData = FALSE;    
        }
        else
        {
            Win4Assert(!_pMNHelper);
        }
    }
    return hr;
}

 
// Function used for creating objects
HRESULT CLocalMachineNamesCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(!pUnkOuter);

    if (!ppv)
        return E_POINTER;
    
    *ppv = NULL;
    
    CLocalMachineNames* pLocal = new CLocalMachineNames();
    if (!pLocal)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pLocal->QueryInterface(riid, ppv);

    pLocal->Release();

    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\orpc_dbg.h ===
//--------------------------------------------------------------------------
// ORPC_DBG.H (tabs 4)
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
//          SEND MAIL TO SANJAYS  IF YOU MODIFY THIS FILE!
//            WE MUST KEEP OLE AND LANGUAGES IN SYNC!
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
// Created 07-Oct-1993 by Mike Morearty.  The master copy of this file
// is in the LANGAPI project owned by the Languages group.
//
// Macros and functions for OLE RPC debugging.  For a detailed explanation,
// see OLE2DBG.DOC.
//
//--------------------------------------------------------------------------


#ifndef __ORPC_DBG__
#define __ORPC_DBG__

//--------------------------------------------------------------------------
// Public:
//--------------------------------------------------------------------------

// This structure is the information packet which OLE sends the debugger
// when it is notifying it about an OLE debug event. The first field in this
// structure points to the signature which identifies the type of the debug 
// notification. The consumer of the notification can then get the relevant 
// information from the struct members. Note that for each OLE debug notification
// only a subset of the struct members are meaningful. 


typedef struct ORPC_DBG_ALL 
{
	BYTE *				pSignature;
	RPCOLEMESSAGE *		pMessage;
	const IID *	 		refiid;
	IRpcChannelBuffer *	pChannel;
	IUnknown *			pUnkProxyMgr;
	void *				pInterface;
	IUnknown *			pUnkObject;
	HRESULT				hresult;
	void *				pvBuffer;
	ULONG				cbBuffer;	
	ULONG *				lpcbBuffer; 
	void * 				reserved;
} ORPC_DBG_ALL;

typedef ORPC_DBG_ALL __RPC_FAR *LPORPC_DBG_ALL;

// Interface definition for IOrpcDebugNotify 

typedef interface IOrpcDebugNotify IOrpcDebugNotify;

typedef IOrpcDebugNotify __RPC_FAR * LPORPCDEBUGNOTIFY;

#if defined(__cplusplus) && !defined(CINTERFACE)

	interface IOrpcDebugNotify : public IUnknown
	{
	public:
		virtual VOID __stdcall ClientGetBufferSize (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ClientFillBuffer (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ClientNotify (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ServerNotify (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ServerGetBufferSize (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ServerFillBuffer (LPORPC_DBG_ALL) = 0;
	};

#else /* C style interface */

	typedef struct IOrpcDebugNotifyVtbl
	{
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOrpcDebugNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOrpcDebugNotify __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOrpcDebugNotify __RPC_FAR * This);

		VOID ( __stdcall __RPC_FAR *ClientGetBufferSize)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ClientFillBuffer)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ClientNotify)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ServerNotify)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ServerGetBufferSize)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ServerFillBuffer)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);

		} IOrpcDebugNotifyVtbl;

		interface IOrpcDebugNotify 
		{
			CONST_VTBL struct IOrpcDebugNotifyVtbl __RPC_FAR *lpVtbl;
		};

#endif

// This is the structure that is passed by the debugger to OLE when it enables ORPC 
// debugging. 
typedef struct ORPC_INIT_ARGS
{
	IOrpcDebugNotify __RPC_FAR * lpIntfOrpcDebug;
	void *	pvPSN;	// contains ptr to Process Serial No. for Mac ORPC debugging.
	DWORD	dwReserved1; // For future use, must be 0.
	DWORD	dwReserved2;
} ORPC_INIT_ARGS;

typedef ORPC_INIT_ARGS  __RPC_FAR * LPORPC_INIT_ARGS;
				
// Function pointer prototype for the "DllDebugObjectRPCHook" function.
typedef BOOL (WINAPI* ORPCHOOKPROC)(BOOL, LPORPC_INIT_ARGS); 

// The first four bytes in the debug specific packet are interpreted by the
// ORPC debug layer. The valid values are the ones defined below.

#define ORPC_DEBUG_ALWAYS					(0x00000000L)	// Notify always.
#define ORPC_DEBUG_IF_HOOK_ENABLED			(0x00000001L)	// Notify only if hook enabled.
 

// This exception code indicates that the exception is really an 
// ORPC debug notification.

#define EXCEPTION_ORPC_DEBUG (0x804f4c45)


//--------------------------------------------------------------------------------------
// Private: Declarations below this point are related to the implementation and should
// be removed from the distributable version of the header file.
//--------------------------------------------------------------------------------------


// Helper routines to set & restore the "Auto" value in the registry

BOOL WINAPI DebugORPCSetAuto(VOID);
VOID WINAPI DebugORPCRestoreAuto(VOID);

 ULONG WINAPI DebugORPCClientGetBufferSize(
	RPCOLEMESSAGE *	pMessage,
	REFIID			iid,
	void *			reserved,
	IUnknown *		pUnkProxyMgr,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCClientFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCClientNotify(
	RPCOLEMESSAGE *	pMessage,
	REFIID			iid,
	void *			reserved,
	IUnknown *		pUnkProxyMgr,
	HRESULT			hresult,
	void *			pvBuffer,
	ULONG			cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCServerNotify(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

ULONG WINAPI DebugORPCServerGetBufferSize(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCServerFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

#endif // __ORPC_DBG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\marshal.cxx ===
//+-------------------------------------------------------------------
//
//  File:       marshal.cxx
//
//  Contents:   class implementing standard COM interface marshaling
//
//  Classes:    CStdMarshal
//
//  History:    20-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <marshal.hxx>   // CStdMarshal
#include    <ipidtbl.hxx>   // CIPIDTable, COXIDTable, CMIDTable
#include    <riftbl.hxx>    // CRIFTable
#include    <resolver.hxx>  // CRpcResolver
#include    <stdid.hxx>     // CStdIdentity
#include    <ctxchnl.hxx>   // CCtxComChnl
#include    <callctrl.hxx>  // CAptRpcChnl, CSrvCallCtrl
#include    <scm.h>         // CLSCTX_PS_DLL
#include    <service.hxx>   // SASIZE
#include    <locks.hxx>     // LOCK/UNLOCK etc
#include    <thunkapi.hxx>  // GetAppCompatabilityFlags
#include    <xmit.hxx>      // CRpcXmitStream
#include    <events.hxx>    // Event logging functions
#include    <context.hxx>   // CObjectContext
#include    <crossctx.hxx>  // ObtainPolicySet
#include    <excepn.hxx>    // AppInvokeExceptionFilter

// Marker signature
#define OUTOFPROC_MARKER_SIGNATURE  (0x4E535956)
#define INPROC_MARKER_SIGNATURE  (0x5F646A67)

extern GUID gProcessGuid;

const GUID CLSID_AggStdMarshal =
    {0x00000027,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


#if DBG==1
// this flag and interface are used in debug to enable simpler testing
// of the esoteric NonNDR stub code feature.

BOOL gfFakeNonNDR    = FALSE;
const GUID IID_ICube =
    {0x00000139,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
#endif  // DBG

BOOL gEnableAgileProxies = FALSE;

extern INTERNAL ICoGetClassObject(
    REFCLSID rclsid,
    DWORD dwContext,
    COSERVERINFO * pvReserved,
    REFIID riid,
    DWORD dwActvFlags,
    void FAR* FAR* ppvClassObj,
    ActivationPropertiesIn *pActIn);

// mappings from MSHLFLAGS to STDOBJREF flags
static ULONG mapMFtoSORF[] =
{
    SORF_NULL,                  // MSHLFLAGS_NORMAL
    SORF_NULL,                  // MSHLFLAGS_TABLESTRONG
    SORF_P_TBLWEAK              // MSHLFLAGS_TABLEWEAK
};

// NULL resolver string array
DUALSTRINGARRAY saNULL = {0,0};

// out internal psclass factory implementation
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);

extern HRESULT GetAsyncCallObject(IUnknown *pSyncObj, IUnknown *pControl, REFIID IID_async,
                                  REFIID IID_Return, IUnknown **ppInner, void **ppv);

// structure used to post a delayed remote release call to ourself.
struct POSTRELRIFREF : public IMessageParam
{
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
    {
        return E_NOINTERFACE;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement(&cRefs);        
    }

    STDMETHOD_(ULONG, Release)()
    {
        LONG ret = InterlockedDecrement(&cRefs);
        if (ret == 0)
            delete this;

        return ret;
    }
    
    void *operator new(size_t cb, size_t cbExtra)
    {
        return PrivMemAlloc(cb + cbExtra);
    }

    void operator delete(void *pv)
    {
        PrivMemFree(pv);
    }

    LONG            cRefs;      // ref count
    OXIDEntry      *pOXIDEntry; // server OXIDEntry
    IRemUnknown    *pRemUnk;    // Remote unknown
    IUnknown       *pAsyncRelease; // Controlling unknown for Async
    USHORT          cRifRef;    // count of entries in arRifRef
    REMINTERFACEREF arRifRef;   // array of REMINTERFACEREFs
};


//+-------------------------------------------------------------------
// function to determine if the marshal packet represents a TABLESTRONG
// or TABLEWEAK marshal reference (vs a NORMAL marshal reference)
//+-------------------------------------------------------------------
inline BOOL IsTableObjRef(STDOBJREF *pStd)
{
    return (pStd->cPublicRefs == 0)
        ? TRUE : FALSE;
}

//+-------------------------------------------------------------------
// function to determine if the marshal packet represents a TABLEWEAK
// marshal reference.
//+-------------------------------------------------------------------
inline BOOL IsTableWeakObjRef(STDOBJREF *pStd)
{
    return (pStd->cPublicRefs == 0 && (pStd->flags & SORF_P_TBLWEAK))
        ? TRUE : FALSE;
}

//+-------------------------------------------------------------------
// function to determine if the marshal packet represents a TABLESTRONG
// marshal reference.
//+-------------------------------------------------------------------
inline BOOL IsTableStrongObjRef(STDOBJREF *pStd)
{
    return (pStd->cPublicRefs == 0 && !(pStd->flags & SORF_P_TBLWEAK))
        ? TRUE : FALSE;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::CStdMarshal/Init, public
//
//  Synopsis:   constructor/initializer of a standard marshaler
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
CStdMarshal::CStdMarshal() : _dwFlags(0), _pChnl(NULL), _fCsInitialized(FALSE)
{
    // Caller must call Init before doing anything! This just makes it
    // easier for the identity object to figure out the init parameters
    // before initializing us.
    _discHead.pNext    = &_discHead;
    _discHead.pPrev    = &_discHead;
    _discHead.pSink    = NULL;
    _discHead.pvCookie = NULL;
}

BOOL CStdMarshal::Init(IUnknown *punkObj, CStdIdentity *pStdId,
                       REFCLSID rclsidHandler, DWORD dwFlags)
{
    // may be unlocked if def handler calls CreateIdHdlr
    ASSERT_LOCK_DONTCARE(gComLock);

    BOOL fRet = FALSE;
    NTSTATUS status;
    
    // server side - we need to do the FirstMarshal work.
    // client side - assume disconnected until we connect the first IPIDEntry
    // and assume NOPING until we see any interface that needs pinging

    _dwFlags  = dwFlags;
    _dwFlags |= (ServerSide()) ? SMFLAGS_FIRSTMARSHAL
                               : SMFLAGS_DISCONNECTED | SMFLAGS_NOPING;

    _pStdId        = pStdId;
    _clsidHandler  = rclsidHandler;
    _cIPIDs        = 0;
    _pFirstIPID    = NULL;
    _pChnl         = NULL;
    _cNestedCalls  = 0;
    _cTableRefs    = 0;
    _dwMarshalTime = 0;
    _pSecureRemUnk = NULL;
    _pAsyncRelease = NULL;
    _pCtxEntryHead = NULL;
    _pCtxFreeList  = NULL;
    _pPS           = NULL;
    _pID           = NULL;
    _pRefCache     = NULL;

    status = RtlInitializeCriticalSectionAndSpinCount(&_csCtxEntry, 500);
    if (NT_SUCCESS(status))
    {
    	_fCsInitialized = TRUE;
    	fRet = TRUE;
    }

#if DBG==1
    _fNoOtherThreadInDisconnect = TRUE;
#endif

    ComDebOut((DEB_MARSHAL,"CStdMarshal %s New this:%x pStdId:%x punkObj:%x\n",
        (ClientSide()) ? "CLIENT" : "SERVER", this, pStdId, punkObj));

return fRet;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::~CStdMarshal, public
//
//  Synopsis:   destructor of a standard marshaler
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
CStdMarshal::~CStdMarshal()
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal %s Deleted this:%x\n",
                    (ClientSide()) ? "CLIENT" : "SERVER", this));

    // Due to backward compatibility, we are not allowed to release
    // interface proxies in Disconnect since the client might try to
    // reconnect later and expects the same interface pointer values.
    // Since we are going away now, we go release the proxies.

    ReleaseAllIPIDEntries();

    if (ClientSide())
    {
        // Note: dont do this assertion check in the server side case since
        // in debug the StdId list header dtor may get called after the lock
        // dtor has already been called. The list header is server side.
        ASSERT_LOCK_NOT_HELD(gComLock);

        // If we own a secure remote unknown, clean it up now.
        if (NULL != _pSecureRemUnk)
        {
            CStdIdentity* pStdId;
            HRESULT hr = _pSecureRemUnk->QueryInterface(IID_IStdIdentity, (void**)&pStdId);
            if (SUCCEEDED(hr))
            {
                pStdId->ReleaseRemUnkCopy(_pSecureRemUnk);
                pStdId->Release();
            }
        }

        ASSERT_LOCK_NOT_HELD(gComLock);
    }

    if (_pChnl)
    {
        // release the channel
        _pChnl->Release();
        ASSERT_LOCK_NOT_HELD(gComLock);
    }

    if (_fCsInitialized == TRUE)
        DeleteCriticalSection(&_csCtxEntry);
    

    // Sanity checks
    Win4Assert(_pID == NULL);
    Win4Assert(_pPS == NULL);
    Win4Assert(_pRefCache == NULL);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::GetUnmarshalClass, public
//
//  Synopsis:   returns the clsid of the standard marshaller, or
//              aggregated standard marshaler.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::GetUnmarshalClass(REFIID riid, LPVOID pv,
        DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPCLSID pClsid)
{
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if(ServerSide() && (dwDestCtx==MSHCTX_CROSSCTX) && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        *pClsid = CLSID_StdWrapper;
    }
    else if (ServerSide() && (dwDestCtx == MSHCTX_INPROC) && IsThreadInNTA() 
			 && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
		//
		// If this assert fires, this means that you've got an inproc
		// reference to an old-style stub for an object living in the NA.
		// This should never happen-- you should have a StdWrapper instead.  
		// Look at the unmarshal path and find out what you missed, or why 
		// this can happen.
		// In any case, the right thing to do in this event is to do wrapper
		// marshalling, to get back on the right foot.
		//
		Win4Assert(!"Inproc Ref to NA StdID! Shouldn't happen!");
        *pClsid = CLSID_StdWrapper;
    }
    else
    {
        if (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL)
        {
            *pClsid = CLSID_AggStdMarshal;
        }
        else
        {
            *pClsid = CLSID_StdMarshal;
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     MarshalSizeHelper,      private
//
//  Synopsis:   Helper function used for sizing marshaling buffers
//
//  History:    21-Mar-98   Gopalk      Created.
//
//--------------------------------------------------------------------
INTERNAL MarshalSizeHelper(DWORD dwDestCtx, LPVOID pvDestCtx,
                           DWORD mshlflags, CObjectContext *pServerCtx,
                           BOOL fServerSide, LPDWORD pSize)
{
    HRESULT hr = S_OK;
    CDualStringArray* pdsaLocalResolver;

    // Sanity check
    Win4Assert(gdwPsaMaxSize != 0);
	
    // Check for cross context case
    if(fServerSide &&
       (dwDestCtx == MSHCTX_CROSSCTX) &&
       !(mshlflags & MSHLFLAGS_TABLE))
    {
        *pSize = sizeof(OBJREF) + sizeof(XCtxMarshalData);
    }
    else
    {
        hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
        if (SUCCEEDED(hr))
        {
            // Fixed portion of objref
            *pSize = (DWORD) 
                (sizeof(OBJREF) + (fServerSide ? SASIZE(pdsaLocalResolver->DSA()->wNumEntries) : gdwPsaMaxSize));

            // Check for the need to send envoy data
            if((dwDestCtx != MSHCTX_INPROC) &&
                //(dwDestCtx != MSHCTX_CROSSCTX) &&
                pServerCtx != NULL)
            {
                COMVERSION destCV;
                BOOL fDownLevel = TRUE;
                
                // Decide down level interop issues
                if(pvDestCtx)
                {
                    // Sanity check
                    Win4Assert(dwDestCtx == MSHCTX_DIFFERENTMACHINE);
                    
                    // Obtain com version of destination
                    hr = ((IDestInfo *) pvDestCtx)->GetComVersion(destCV);
                    if(SUCCEEDED(hr))
                    {
                        if(destCV.MajorVersion != COM_MAJOR_VERSION)
                            hr = RPC_E_VERSION_MISMATCH;
                        else if(destCV.MinorVersion < COM_MINOR_VERSION)
                            fDownLevel = TRUE;
                        else
                            fDownLevel = FALSE;
                    }
                }
                else if(dwDestCtx == MSHCTX_DIFFERENTMACHINE)
                {
                    fDownLevel = TRUE;
                }
                else
                {
                    fDownLevel = FALSE;
                }
                
                // Check for down level interop
                if(SUCCEEDED(hr) && fDownLevel==FALSE)
                {
                    ULONG cbSize;
                    
                    // Obtain the size of envoy data
                    hr = pServerCtx->GetEnvoySizeMax(dwDestCtx, &cbSize);
                    if(SUCCEEDED(hr))
                        *pSize += cbSize;
                }
            }
            pdsaLocalResolver->Release();
        }
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::GetMarshalSizeMax, public
//
//  Synopsis:   Returns an upper bound on the amount of data for
//              a standard interface marshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::GetMarshalSizeMax(REFIID riid, LPVOID pv,
        DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPDWORD pSize)
{
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr = MarshalSizeHelper(dwDestCtx, pvDestCtx, mshlflags,
                                   GetServerCtx(), ServerSide(), pSize);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   MarshalObjRef, private
//
//  Synopsis:   Marshals interface into the objref.
//
//  Arguements: [objref]    - object reference
//              [riid]      - interface id to marshal
//              [pv]        - interface to marshal
//              [mshlflags] - marshal flags
//              [dwDestCtx] - destination context type
//              [pvDestCtx] - destination context ptr
//
//  Algorithm:  Get the correct standard identity and ask it to do
//              all the work.
//
//  History:    25-Mar-95   AlexMit     Created
//
//--------------------------------------------------------------------
INTERNAL MarshalObjRef(OBJREF &objref, REFIID riid, void *pv, DWORD mshlflags,
                       DWORD dwDestCtx, void *pvDestCtx)
{
    ComDebOut((DEB_MARSHAL, "MarshalObjRef: riid:%I pv:%x flags:%x\n",
        &riid, pv, mshlflags));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // Find or create the StdId for this object. We need to get a strong
        // reference to guard against an incoming last release on another
        // thread which would cause us to Disconnect this StdId.

        DWORD dwFlags = IDLF_CREATE | IDLF_STRONG;
        dwFlags |= (mshlflags & MSHLFLAGS_NOPING) ? IDLF_NOPING : 0;

        CStdIdentity *pStdID;
        hr = ObtainStdIDFromUnk((IUnknown *)pv, GetCurrentApartmentId(),
                                GetCurrentContext(), dwFlags, &pStdID);

        if (hr == NOERROR)
        {
            hr = pStdID->MarshalObjRef(objref, riid, mshlflags,
                                       dwDestCtx, pvDestCtx, 0);
            if (pStdID->IsClient())
                pStdID->Release();
            else
                pStdID->DecStrongCnt(TRUE); // fKeepAlive
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "MarshalObjRef: hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   MarshalInternalObjRef, private
//
//  Synopsis:   Marshals an internal interface into the objref.
//
//  Arguements: [objref]    - object reference
//              [riid]      - interface id to marshal
//              [pv]        - interface to marshal
//              [mshlflags] - marshal flags
//              [ppStdId]   - StdId to return (may be NULL)
//
//  Algorithm:  Create a StdIdentity and ask it to do the work.
//
//  Notes:      This differs from the normal MarshalObjRef in that it does
//              not look in the OID table for an already marshaled interface,
//              nor does it register the marshaled interface in the OID table.
//              This is used for internal interfaces such as the IObjServer
//              and IRemUnknown.
//
//  History:    25-Oct-95   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies and comments
//
//--------------------------------------------------------------------
INTERNAL MarshalInternalObjRef(OBJREF &objref, REFIID riid, void *pv,
                               DWORD mshlflags, void **ppStdId)
{
    ComDebOut((DEB_MARSHAL, "MarshalInternalObjRef: riid:%I pv:%x flags:%x\n",
        &riid, pv, mshlflags));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            // Find or create the StdId for this object. We need to get a strong
            // reference to guard against an incoming last release on another
            // thread which would cause us to Disconnect this StdId.

            IUnknown *pUnkId;   // ignored
            BOOL fSuccess = FALSE;
            DWORD StdIDFlags = (mshlflags & MSHLFLAGS_AGILE)
                               ? STDID_SERVER | STDID_SYSTEM | STDID_FREETHREADED
                               : STDID_SERVER | STDID_SYSTEM;
            CStdIdentity *pStdId = new CStdIdentity(StdIDFlags,
                                                    GetCurrentApartmentId(), NULL,
                                                    (IUnknown *)pv, &pUnkId, &fSuccess);

            if (pStdId && fSuccess == FALSE)
            {
            	delete pStdId;
            	pStdId = NULL;
            }
            
            if (pStdId)
            {
                
                hr = pStdId->MarshalObjRef(objref, riid, mshlflags,
                                           MSHCTX_INPROC, NULL, 0);

                if (SUCCEEDED(hr) && ppStdId)
                {
                    *ppStdId = (void *)pStdId;
                }
                else
                {
                    pStdId->Release();
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "MarshalInternalObjRef: hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::MarshalInterface, public
//
//  Synopsis:   marshals the interface into the stream.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::MarshalInterface(IStream *pStm, REFIID riid,
        LPVOID pv, DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::MarshalInterface this:%x pStm:%x riid:%I pv:%x dwCtx:%x pvCtx:%x flags:%x\n",
        this, pStm, &riid, pv, dwDestCtx, pvDestCtx, mshlflags));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // validate the parameters.
    HRESULT hr = ValidateMarshalParams(pStm, (IUnknown *)pv,
                                       dwDestCtx, pvDestCtx, mshlflags);
    if (FAILED(hr))
        return hr;

    // Check the destination context
    if (ServerSide() &&
        (dwDestCtx==MSHCTX_CROSSCTX) && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        hr = WrapperMarshalObject(pStm, riid, (IUnknown *) pv, dwDestCtx,
                                  pvDestCtx, mshlflags);
    }
    else if (ServerSide() && (dwDestCtx == MSHCTX_INPROC) && IsThreadInNTA()
             && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        hr = WrapperMarshalObject(pStm, riid, (IUnknown *) pv, dwDestCtx,
                                  pvDestCtx, mshlflags);
    }
    else
    {
        // Marshal the interface into an objref, then write the objref
        // into the provided stream.
        OBJREF  objref;
        hr = MarshalObjRef(objref, riid, mshlflags, dwDestCtx, pvDestCtx, 0);
        if (SUCCEEDED(hr))
        {
            // write the objref into the stream
            hr = WriteObjRef(pStm, objref, dwDestCtx);

            if (FAILED(hr))
            {
                // undo whatever we just did, ignore error from here since
                // the stream write error supercedes any error from here.
                ReleaseMarshalObjRef(objref);
            }

            // free resources associated with the objref.
            FreeObjRef(objref);
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,"CStdMarshal::MarshalInterface this:%x hr:%x\n",
        this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::MarshalObjRef, public
//
//  Synopsis:   marshals the interface into the objref.
//
//  History:    25-Mar-95   AlexMit     Seperated from MarshalInterface
//              04-Mar-98   Gopalk      Context changes
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::MarshalObjRef(OBJREF &objref, REFIID riid,
                                   DWORD mshlflags, DWORD dwDestCtx,
                                   void *pvDestCtx, IUnknown *pUnkUseInner)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::MarsalObjRef this:%x riid:%I flags:%x\n",
        this, &riid, mshlflags));
#if DBG==1
    // ensure we are always in the proper context
    CObjectContext *pDestCtx = ServerObjectCallable();
    Win4Assert(pDestCtx == NULL);
#endif
    AssertValid();

    // count of Refs we are handing out. In the table cases we pass out
    // zero refs because we dont know how many times it will be unmarshaled
    // (and hence how many references to count). Zero refs will cause the
    // client to call back and ask for more references if it does not already
    // have any (which has the side effect of making sure the object still
    // exists, which is required by RunningObjectTable).

    ULONG cRefs = (mshlflags & MSHLFLAGS_TABLE) ? 0 :
                  (ClientSide()) ? 1 : REM_ADDREF_CNT;

    ENTER_NA_IF_NECESSARY()

    IPIDEntry *pIPIDEntry = NULL;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    HRESULT hr = PreventDisconnect();
    if (SUCCEEDED(hr))
    {
        // The first time through we have some extra work to do so go off
        // and do that now. Next time we can just bypass all that work.

        if (_dwFlags & SMFLAGS_FIRSTMARSHAL)
        {
            hr = FirstMarshal(0, mshlflags);
        }

        if (SUCCEEDED(hr))
        {
            // Create the IPID table entry. On the server side this may
            // cause the creation of an interface stub, on the client side
            // it may just take away one of our references or it may call
            // the server to get more references for the interface being
            // marshaled.

            hr = MarshalIPID(riid, cRefs, mshlflags, &pIPIDEntry, pUnkUseInner);
        }
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (SUCCEEDED(hr))
    {
        // fill in the objref.

        // First, compute the COM Version of the destination.
        COMVERSION destCV;
        if (pvDestCtx)
        {
            hr = ((IDestInfo *) pvDestCtx)->GetComVersion(destCV);
            Win4Assert(SUCCEEDED(hr));
            Win4Assert(dwDestCtx == MSHCTX_DIFFERENTMACHINE);
        }
        else if (dwDestCtx == MSHCTX_DIFFERENTMACHINE)
        {
            // don't know where it is going, use the lowest version.
            destCV.MajorVersion = COM_MAJOR_VERSION;
            destCV.MinorVersion = COM_MINOR_VERSION_1;
        }
        else
        {
            // it's for the local machine, use the current version.
            destCV.MajorVersion = COM_MAJOR_VERSION;
            destCV.MinorVersion = COM_MINOR_VERSION;
        }

        // fill in the rest of the OBJREF
        FillObjRef(objref, cRefs, mshlflags, destCV, pIPIDEntry);
    }

    // it is now OK to allow real disconnects in.
    HRESULT hr2 = HandlePendingDisconnect(hr);
    if (FAILED(hr2) && SUCCEEDED(hr))
    {
        // a disconnect came in while marshaling. The ObjRef has a
        // reference to the OXIDEntry so go free that now.
        FreeObjRef(objref);
    }

    LEAVE_NA_IF_NECESSARY()

    if (SUCCEEDED(hr2) && LogEventIsActive())
    {
        LogEventMarshal(objref);
    }

    ComDebOut((DEB_MARSHAL, "CStdMarshal::MarshalObjRef this:%x hr:%x\n",
        this, hr2));
    return hr2;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::FillObjRef, private
//
//  Synopsis:   Fill in the fields of an OBJREF
//
//  History:    21-Sep-95   Rickhi      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::FillObjRef(OBJREF &objref, ULONG cRefs, DWORD mshlflags,
                             COMVERSION &destCV, IPIDEntry *pIPIDEntry)
{
    ComDebOut((DEB_MARSHAL, "FillObjRef pObjRef:%x\n", &objref));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    Win4Assert(pIPIDEntry);
    OXIDEntry **ppOXIDEntry;

    // first, fill in the STDOBJREF section
    STDOBJREF *pStd = &ORSTD(objref).std;
    FillSTD(pStd, cRefs, mshlflags, pIPIDEntry);

    // next fill in the rest of the OBJREF
    objref.signature = OBJREF_SIGNATURE;    // 'MEOW'
    objref.iid = pIPIDEntry->iid;           // interface iid

    if (_dwFlags & SMFLAGS_HANDLER)
    {
        // handler form, copy in the clsid
        objref.flags = OBJREF_HANDLER;
        ORHDL(objref).clsid = _clsidHandler;
        ppOXIDEntry = (OXIDEntry **) &ORHDL(objref).saResAddr;
    }
    else
    {
        CObjectContext *pServerCtx = GetServerCtx();
        if (pServerCtx && !pServerCtx->IsDefault() && (destCV.MinorVersion >= COM_MINOR_VERSION))
        {
            // write an extended OBJREF with the server context ptr.
            // make sure we are not in the empty context, in which
            // case we should be writing a standard OBJREF.
            Win4Assert(pServerCtx != GetEmptyContext());

            objref.flags = OBJREF_EXTENDED;
            pServerCtx->InternalAddRef();
            OREXT(objref).pORData = (OBJREFDATA *) pServerCtx;
            ppOXIDEntry = (OXIDEntry **) &OREXT(objref).saResAddr;
        }
        else
        {
            // write a standard OBJREF
            objref.flags = OBJREF_STANDARD;
            ppOXIDEntry = (OXIDEntry **) &ORSTD(objref).saResAddr;
        }
    }

    // TRICK: in order to keep the objref a fixed size internally,
    // we use the saResAddr.size field as a ptr to the OXIDEntry. We
    // pay attention to this in ReadObjRef, WriteObjRef, and FreeObjRef.

    *ppOXIDEntry = pIPIDEntry->pOXIDEntry;
    Win4Assert(*ppOXIDEntry != NULL);
    (*ppOXIDEntry)->IncRefCnt();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::FillSTD, public
//
//  Synopsis:   Fill in the STDOBJREF fields of an OBJREF
//
//  History:    21-Sep-95   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//              29-Mar-98   Johnstra    Agile FTM proxies
//
//+-------------------------------------------------------------------
void CStdMarshal::FillSTD(STDOBJREF *pStd, ULONG cRefs, DWORD mshlflags,
                          IPIDEntry *pIPIDEntry)
{
    // we don't care if the lock is held, only that disconnect is prevented
    AssertDisconnectPrevented();
    ASSERT_LOCK_DONTCARE(gIPIDLock);

    // fill in the STDOBJREF to return to the caller.
    pStd->flags  = mapMFtoSORF[mshlflags & MSHLFLAGS_TABLE];
    pStd->flags |= (pIPIDEntry->dwFlags & IPIDF_NOPING) ? SORF_NOPING : 0;
    pStd->flags |= (pIPIDEntry->dwFlags & IPIDF_NONNDRSTUB) ? SORF_P_NONNDR : 0;
    pStd->flags |= (_pStdId->IsFreeThreaded() || gEnableAgileProxies) ?
        SORF_FREETHREADED : 0;

    pStd->cPublicRefs = cRefs;
    pStd->ipid   = pIPIDEntry->ipid;
    OIDFromMOID(_pStdId->GetOID(), &pStd->oid);

    OXIDFromMOXID(pIPIDEntry->pOXIDEntry->GetMoxid(), &pStd->oxid);

    pStd->flags |= (_pStdId->IsFTM()) ? (SORF_FTM | SORF_FREETHREADED): 0;

    ValidateSTD(pStd);
    DbgDumpSTD(pStd);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::FirstMarshal, private
//
//  Synopsis:   Does some first-time server side marshal stuff
//
//  Parameters: [pUnk] - interface being marshalled
//              [mshlflags] - flags for marshaling
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FirstMarshal(IUnknown *pUnk, DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::FirstMarshal this:%x pUnk:%x\n", this, pUnk));
    Win4Assert(ServerSide());
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    if (mshlflags & MSHLFLAGS_NOPING)
    {
        // if the first interface is marked as NOPING, then all interfaces
        // for the object are treated as NOPING, otherwise, all interfaces
        // are marked as PING. MakeSrvIPIDEntry will look at _dwFlags to
        // determine whether to mark each IPIDEntry as NOPING or not.

        _dwFlags |= SMFLAGS_NOPING;
    }

    HRESULT hr = S_OK;

    // Another thread could have created the channel. Check before
    // actually creating the channel
    if (NULL == _pChnl)
    {
        // create a channel for this object. Note that this will release
        // the lock, so guard against that by not turning off the first
        // marshal bit until after this call returns.
        CCtxComChnl *pChnl;
        hr = CreateChannel(NULL, 0, GUID_NULL, GUID_NULL, &pChnl);
    }

    if (SUCCEEDED(hr))
    {
        // The channel should have been created by now
        Win4Assert(NULL != _pChnl);
        _dwFlags &= ~(SMFLAGS_FIRSTMARSHAL | SMFLAGS_DISCONNECTED | SMFLAGS_CLEANEDUP);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::FirstMarshal this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::MarshalIPID, private
//
//  Synopsis:   finds or creates an interface stub and IPID entry
//              for the given object interface.
//
//  Arguments:  [riid]   - interface to look for
//              [cRefs]  - count of references wanted
//              [mshlflags] - marshal flags
//              [ppIPIDEntry] - place to return IPIDEntry ptr
//              [pUnkUseInner] - ?
//
//  Returns:    S_OK if succeeded
//
//  History:    20-Feb-95   Rickhi        Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::MarshalIPID(REFIID riid, ULONG cRefs, DWORD mshlflags,
                                 IPIDEntry **ppIPIDEntry, IUnknown *pUnkUseInner)
{
    ComDebOut((DEB_MARSHAL,
            "CStdMarshal::MarshalIPID this:%x riid:%I cRefs:%x mshlflags:%x ppEntry:%x\n",
            this, &riid, cRefs, mshlflags, ppIPIDEntry));
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    // look for an existing IPIDEntry for the requested interface
    IPIDEntry *pEntry = NULL;
    HRESULT hr = FindIPIDEntryByIID(riid, &pEntry);

    if (FAILED(hr))
    {
        // no IPID entry currently exists for the interface.
        if (ServerSide())
        {
            // on the server side. try to create one. This can fail if we
            // are disconnected during a yield.
            hr = MakeSrvIPIDEntry(riid, &pEntry);
        }
        else
        {
            // on the client side we do a remote QI for the requested
            // interface.
            hr = RemQIAndUnmarshal(1, (GUID *)&riid, NULL);
            if (SUCCEEDED(hr))
            {
                hr = FindIPIDEntryByIID(riid, &pEntry);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // REFCOUNTING:
        if (ServerSide())
        {
            if (pEntry->dwFlags & IPIDF_DISCONNECTED)
            {
                // connect the IPIDEntry
                hr = ConnectSrvIPIDEntry(pEntry, pUnkUseInner);
            }

            if (SUCCEEDED(hr))
            {
                // remember the latest marshal time so we can
                // tell if the ping server has run us down too
                // early. This can happen when an existing client
                // dies and we remarshal the interface just
                // moments before the pingserver tells us the
                // first guy is gone and before the new client
                // has had time to unmarshal and ping.
                _dwMarshalTime = GetCurrentTime();

                // inc the refcnt for the IPIDEntry and optionaly
                // the stdid. Note that for TABLE marshals cRefs
                // is 0 (that's the number that gets placed in the
                // packet) but we do want a reference so we ask for
                // 1 here. ReleaseMarshalData will undo the 1.
                ULONG cRefs2 = (mshlflags & MSHLFLAGS_TABLE) ? 1 : cRefs;
                IncSrvIPIDCnt(pEntry, cRefs2, 0, NULL, mshlflags);
            }
        }
        else  // client side,
        {
            // we dont support marshaling weak refs on the client
            // side, though we do support marshaling strong from
            // a weak client by going to the server and getting
            // a strong reference.
            Win4Assert(!(mshlflags & MSHLFLAGS_WEAK));

            if (mshlflags & MSHLFLAGS_TABLESTRONG)
            {
                // TABLESTRONG marshaling of a client. Need to tell
                // the refcache to keep pinging the object.
                Win4Assert(cRefs == 0);
                // For no-ping OIDs, _pRefCache is NULL
                if(_pRefCache)
		   _pRefCache->IncTableStrongCnt();
            }
            else if (cRefs >= pEntry->cStrongRefs)
            {
                // need to get some references either from the reference
                // cache or from the remote server so we can give them to
                // the STDOBJREF.
                hr = RemoteAddRef(pEntry, pEntry->pOXIDEntry, cRefs, 0, TRUE);
            }
            else
            {
                // we have enough references to satisfy this request
                // (and still keep some for ourselves), just subtract
                // from the IPIDEntry
                pEntry->cStrongRefs -= cRefs;
            }

            // mark this object as having been client-side marshaled so
            // that we can tell the resolver whether or not it needs to
            // ping this object if we release it before the OID is registered.
            _dwFlags |= SMFLAGS_CLIENTMARSHALED;
        }

        // do some debug stuff
        ValidateIPIDEntry(pEntry);
        ComDebOut((DEB_MARSHAL, "pEntry:%x cRefs:%x cStdId:%x\n", pEntry,
                   pEntry->cStrongRefs, _pStdId->GetRC()));
    }

    *ppIPIDEntry = pEntry;

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL, "CStdMarshal::MarshalIPID hr:%x pIPIDEntry\n", hr, *ppIPIDEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::UnmarshalInterface, public
//
//  Synopsis:   Unmarshals an Interface from a stream.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::UnmarshalInterface(LPSTREAM pStm,
                                             REFIID riid, VOID **ppv)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarsalInterface this:%x pStm:%x riid:%I\n",
                    this, pStm, &riid));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // read the objref from the stream and find or create an instance
    // of CStdMarshal for its OID. Then ask that guy to do the rest of
    // the unmarshal (create the interface proxy)

    OBJREF  objref;
    HRESULT hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        // pass objref to subroutine to unmarshal the objref
        hr = ::UnmarshalObjRef(objref, ppv);

        // release the objref we read
        FreeObjRef(objref);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
        "UnmarsalInterface this:%x pv:%x hr:%x\n", this, *ppv, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   UnmarshalSwitch           private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during unmarshaling
//
//  Parameters: [pv] - void ptr to StdUnmarshalData structure
//
//  History:    03-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdUnmarshalData
{
    CStdIdentity   *pStdID;
    OBJREF         *pobjref;
    CObjectContext *pClientCtx;
    BOOL            fCreateWrapper;
    void          **ppv;
    BOOL            fLightNA;
} StdUnmarshalData;

HRESULT __stdcall UnmarshalSwitch(void *pv)
{
    ComDebOut((DEB_MARSHAL, "UnmarshalSwitch pv:%x\n", pv));
    ASSERT_LOCK_NOT_HELD(gComLock);

    StdUnmarshalData *pStdData = (StdUnmarshalData *) pv;
    void **ppv = pStdData->fCreateWrapper ? NULL : pStdData->ppv;

    // Unmarshal objref
    HRESULT hr = pStdData->pStdID->UnmarshalObjRef(*pStdData->pobjref, ppv);
    if (pStdData->fCreateWrapper)
    {
        // Initialize
        *(pStdData->ppv) = NULL;
        if (SUCCEEDED(hr))
        {
            // Ask the CStdIdentity to get the wrapper.
            hr = pStdData->pStdID->GetWrapperForContext(pStdData->pClientCtx,
                                                        pStdData->pobjref->iid,
                                                        pStdData->ppv);
        }
    }

    // Fix up the refcount
    pStdData->pStdID->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "UnmarshalSwitch hr:%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptRefToNA, private
//
//  Synopsis:   Indicates if a cross-apartment reference to an object 
//              in the NA is being unmarshaled.
//
//  Arguements: [objref]    - object reference
//
//  Algorithm:  The following conditions must be true: the server must
//              live in the NA, the current thread must not be in the 
//              NA, the OBJREF must not represent an FTM object and have
//              been marshaled by this process.
//
//  History:    23-Feb-00   JohnStra     Created
//
//--------------------------------------------------------------------
BOOL CrossAptRefToNA(OBJREF &objref)
{
    if (objref.flags & OBJREF_STANDARD) 
    {
        OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
        if (pOXIDEntry)
        {
            if (pOXIDEntry->IsInLocalProcess()    &&
                pOXIDEntry->IsNTAServer()         &&
                GetCurrentApartmentId() != NTATID &&
                !(ORSTD(objref).std.flags & SORF_FTM))
            {
                ComDebOut((DEB_MARSHAL, "UnmarshalObjRef: server lives in NA\n"));
                return TRUE;
            }
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------
//
//  Function:   UnmarshalObjRef, private
//
//  Synopsis:   UnMarshals interface from objref.
//
//  Arguements: [objref]    - object reference
//              [ppv]       - proxy
//
//  Algorithm:  Get the correct standard identity and ask it to do
//              all the work.
//
//  History:    25-Mar-95   AlexMit     Created
//              21-May-98   GopalK      Context changes
//
//--------------------------------------------------------------------
EXTERN_C IID IID_IEnterActivityWithNoLock;

INTERNAL UnmarshalObjRef(OBJREF &objref, void **ppv, BOOL fBypassActLock)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

	//
	// Find out if we've got a cross apartment reference to an object
	// in the NA.  If we do, then we want to create or find the wrapper
	// object later.  This also means that we are not necessarily searching
	// for a StdID in this apartment.
	//
	BOOL fLightNAProxy = CrossAptRefToNA(objref);

	CStdMarshal *pStdMshl;
	HRESULT hr = FindStdMarshal(objref, FALSE, &pStdMshl, fLightNAProxy);
	
	if (SUCCEEDED(hr))
	{
		// Create StdMarshalData object on the stack
		StdUnmarshalData StdData;
		
		// Initialize
		StdData.pStdID     = pStdMshl->GetStdID();
		StdData.pobjref    = &objref;
		StdData.ppv        = ppv;
		StdData.pClientCtx = GetCurrentContext();
		
		// Check for the need to switch to server context
		CObjectContext *pDestCtx = pStdMshl->ServerObjectCallable();
		if (pDestCtx)
		{
			// Switch
			StdData.fCreateWrapper = ppv ? TRUE : FALSE;

			if (fBypassActLock)
			{
				hr = PerformCallback(pDestCtx, UnmarshalSwitch, &StdData,
					IID_IEnterActivityWithNoLock, 2, NULL);
			}
			else
			{
				hr = PerformCallback(pDestCtx, UnmarshalSwitch, &StdData, IID_IMarshal, 6, NULL);
			}
		}
		else
		{
			// Call the callback function directly
			StdData.fCreateWrapper = fLightNAProxy;
			hr = UnmarshalSwitch(&StdData);
		}
	}
	else if (!IsTableObjRef(&ORSTD(objref).std))
	{
		// we could not create the indentity or handler, release the
		// marshaled objref, but only if it was not TABLESTRONG or
		// TABLEWEAK.
		ReleaseMarshalObjRef(objref);
	}

	ASSERT_LOCK_NOT_HELD(gComLock);
	return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ChkIfLocalOID, private
//
//  Synopsis:   Helper function for UnmarshalInternalObjRef & FindStdMarshal
//
//  Arguements: [objref] - object reference
//              [ppStdMshl] - CStdMarshal returned
//
//  Algorithm:  If the OXIDEntry in the objref is the same as the current one,
//              lookup the IPID and obtain the StdID from it. Note that the
//              OID is not looked up.
//
//  History:    21-May-95   MurthyS     Created.
//              26-Mar-98   Gopalk      Context changes
//              29-Mar-98   Johnstra    Agile FTM proxies
//
//--------------------------------------------------------------------
INTERNAL_(BOOL) ChkIfLocalOID(OBJREF &objref, CStdIdentity **ppStdId, BOOL fLightNA)
{
    STDOBJREF *pStd = &ORSTD(objref).std;
    BOOL flocal = FALSE;

    ComDebOut((DEB_MARSHAL, "ChkIfLocalOID (IN) poid: %x\n", &pStd->oid));
    Win4Assert((*ppStdId == NULL) && "ChkIfLocalOID: pStdId != NULL");

    // Get OXID to which the objref belongs
    OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
    OXIDEntry *pLocalEntry;
    GetLocalOXIDEntry(&pLocalEntry);

    // Is the OXID in the current apartment, or does the objref
    // represent an FTM object in the NA.
    if (pOXIDEntry == pLocalEntry ||
        (((pStd->flags & SORF_FTM) || fLightNA)   &&
          pOXIDEntry->IsNTAServer() &&
          pOXIDEntry->IsInLocalProcess()))
    {
        // The object is local, or its an FTM object in the NA,
        // lookup IPID which is faster than looking up OID. Further,
        // system objects may not have an OID

        flocal = TRUE;

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        IPIDEntry *pEntry = gIPIDTbl.LookupIPID(pStd->ipid);
        if (pEntry && !(pEntry->dwFlags & IPIDF_DISCONNECTED) && pEntry->pChnl)
        {
            // get the Identity
            *ppStdId = pEntry->pChnl->GetStdId();
            if (fLightNA)
                (*ppStdId)->SetLightNA();
            (*ppStdId)->AddRef();
        }

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    ComDebOut((DEB_MARSHAL, "ChkIfLocalOID (OUT) fLocal:%x\n", flocal));
    return flocal;
}

//+-------------------------------------------------------------------
//
//  Function:   UnmarshalInternalObjRef, private
//
//  Synopsis:   UnMarshals an internally-used interface from objref.
//
//  Arguements: [objref]    - object reference
//              [ppv]       - proxy
//
//  Algorithm:  Create a StdId and ask it to do the work.
//
//  Notes:      This differs from UnmarshalObjRef in that it does not lookup
//              or register the OID. This saves a fair amount of work and
//              avoids initializing the OID table.
//
//  History:    25-Oct-95   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL UnmarshalInternalObjRef(OBJREF &objref, void **ppv)
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    CStdIdentity *pStdId = NULL;
    HRESULT hr = S_OK;

    // Assert that the objref is a standard one
    Win4Assert(objref.flags & OBJREF_STANDARD);

    if (ChkIfLocalOID(objref, &pStdId, FALSE))
    {
        if (pStdId)
        {
            // set OID in objref to match that in returned std identity
            // CODEWORK: Why are we doing this? I do not see a scenario where
            //         system objects get unmarshaled in the server apartment
            //         let alone the case where system objects acquiring OID
            //         after they have been marshaled. GopalK
            OIDFromMOID(pStdId->GetOID(), &ORSTD(objref).std.oid);
        }
        else
        {
            hr = CO_E_OBJNOTCONNECTED;
        }
    }
    else
    {
        DWORD StdIdFlags = ((ORSTD(objref).std.flags & SORF_FREETHREADED) || gEnableAgileProxies)
                           ? STDID_CLIENT | STDID_SYSTEM | STDID_FREETHREADED
                           : STDID_CLIENT | STDID_SYSTEM;

        hr = CreateIdentityHandler(NULL, StdIdFlags, NULL, GetCurrentApartmentId(),
                                   IID_IStdIdentity, (void **)&pStdId);
    }

    if (SUCCEEDED(hr))
    {
        // pass objref to subroutine to unmarshal the objref. tell StdId not
        // to register the OID in the OID table.

        pStdId->IgnoreOID();
        hr = pStdId->UnmarshalObjRef(objref, ppv);
        CALLHOOKOBJECTCREATE(S_OK,ORHDL(objref).clsid,objref.iid,(IUnknown **)ppv);
        pStdId->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::UnmarshalObjRef, private
//
//  Synopsis:   unmarshals the objref. Called by CoUnmarshalInterface,
//              UnmarshalObjRef APIs, and UnmarshalInterface method.
//
//  History:    20-Feb-95   Rickhi      Created.
//              04-Mar-98   Gopalk      Context changes
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::UnmarshalObjRef(OBJREF &objref, void **ppv)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarsalObjRef this:%x objref:%x riid:%I\n",
        this, &objref, &objref.iid));
    AssertValid();
    Win4Assert(ServerObjectCallable() == NULL);

    ENTER_NA_IF_NECESSARY()

    STDOBJREF   *pStd = &ORSTD(objref).std;
    OXIDEntry   *pOXIDEntry = GetOXIDFromObjRef(objref);
    DbgDumpSTD(pStd);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Prevent a disconnect from occuring while unmarshaling the
    // interface since we may have to yield the lock.

    HRESULT hr = PreventPendingDisconnect();

    if (SUCCEEDED(hr))
    {
        if (objref.flags & OBJREF_HANDLER)
        {
            // handler form, extract the handler clsid and set our flags
            _dwFlags |= SMFLAGS_HANDLER;
            _clsidHandler = ORHDL(objref).clsid;
        }

        if (!_pStdId->HaveOID())
        {
            // no OID registered yet, do that now. only possible on client side
            // during reconnect.

            MOID moid;
            MOIDFromOIDAndMID(pStd->oid, pOXIDEntry->GetMid(), &moid);

            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);
            hr = _pStdId->SetOID(moid);
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }

        if (SUCCEEDED(hr))
        {
            // find or create the IPID entry for the interface. On the client
            // side this may cause the creation of an interface proxy. It will
            // also manipulate the reference counts.

            hr = UnmarshalIPID(objref.iid, pStd, pOXIDEntry, ppv);
        }
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (ClientSide() && !(_dwFlags & SMFLAGS_LIGHTNA))
    {
        if (SUCCEEDED(hr))
        {
            if (_pStdId->IsAggregated() && ppv)
            {
                // we are currently holding a proxy pointer. If aggregated,
                // the controlling unknown may want to override this pointer
                // with his own version, so issue a QI to give it that chance.
                IUnknown *pUnk = (IUnknown *)*ppv;

                hr = pUnk->QueryInterface(objref.iid, ppv);
                pUnk->Release();
            }
        }
        else if (!IsTableObjRef(&ORSTD(objref).std))
        {
            // cleanup the marshal packet on failure (only meaningful on client
            // side, since if the unmarshal failed on the server side, the
            // interface is already cleaned up). Also, only do this for NORMAL
            // packets not TABLESTRONG or TABLEWEAK packets.
            ReleaseMarshalObjRef(objref);
        }
    }

    // now let pending disconnect through. on server-side, ignore any
    // error from HPD and pay attention only to the unmarshal result, since
    // a successful unmarshal on the server side may result in a disconnect
    // if that was the last external reference to the object.


    HRESULT hr2 = HandlePendingDisconnect(hr);

    if (FAILED(hr2) && ClientSide() && !(_dwFlags & SMFLAGS_LIGHTNA))
    {
        if (SUCCEEDED(hr) && ppv)
        {
            // a disconnect came in while unmarshaling. ppv contains an
            // AddRef'd interface pointer so go Release that now.
            ((IUnknown *)*ppv)->Release();
        }
        hr = hr2;
    }

    if (SUCCEEDED(hr2) && LogEventIsActive())
    {
        LogEventUnmarshal(objref);
    }

    LEAVE_NA_IF_NECESSARY()

    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarsalObjRef this:%x hr:%x\n",
        this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::UnmarshalIPID, private
//
//  Synopsis:   finds or creates an interface proxy for the given
//              interface. may also do a remote query interface.
//
//  Arguements: [riid] - the interface to return
//              [std]  - standard objref to unmarshal from
//              [pOXIDEntry] - ptr to OXIDEntry of the server
//              [ppv]  - interface ptr of type riid returned, AddRef'd
//
//  Returns:    S_OK if succeeded
//
//  History:    20-Feb-95   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::UnmarshalIPID(REFIID riid, STDOBJREF *pStd,
                                   OXIDEntry *pOXIDEntry, void **ppv)
{
    ComDebOut((DEB_MARSHAL,
            "CStdMarshal::UnmarshalIPID this:%x riid:%I pStd:%x pOXIDEntry:%x\n",
            this, &riid, pStd, pOXIDEntry));
    DbgDumpSTD(pStd);
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    // validate input params.
    Win4Assert(!(IsEqualIID(riid, IID_NULL) || IsEqualIID(riid, IID_IMarshal)));
    Win4Assert(pStd != NULL);
    ValidateSTD(pStd, TRUE /*locked*/);
    Win4Assert(pOXIDEntry);

    // look for an existing IPIDEntry for the requested interface.
    IPIDEntry *pEntry;
    HRESULT hr = FindIPIDEntryByIID(riid, &pEntry);

    // REFCOUNTING:
    if (ClientSide() && !(_dwFlags & SMFLAGS_LIGHTNA))
    {
        if (FAILED(hr))
        {
            // no IPID Entry exists yet for the requested interface. We do
            // have a STDOBJREF.  Create the interface proxy and IPIDEntry
            // now, and connect it up. If successful, the proxy will be
            // fully connected upon return and the references taken.
            if (ppv)
                *ppv = NULL;

            hr = MakeCliIPIDEntry(riid, pStd, pOXIDEntry, &pEntry);
        }
        else if (pEntry->dwFlags & IPIDF_DISCONNECTED)
        {
            // reconnect the IPID entry to the server. this will take
            // any references present in pStd. Even though we could
            // yield, the IPIDEntry is guarenteed connected on return
            // (cause we are holding the lock on return).
            hr = ConnectCliIPIDEntry(pStd, pOXIDEntry, pEntry);
        }
        else
        {
            // IPIDEntry exists and is alread connected, just add
            // the references supplied in the packet to the
            // references in the IPIDEntry or RefCache.
            AddSuppliedRefs(pStd, pEntry);
        }
    }
    else if (SUCCEEDED(hr))
    {
        // unmarshaling in the server apartment. If the cRefs is zero,
        // then the interface was TABLE marshalled and we dont do
        // anything to the IPID RefCnts since the object must live until
        // ReleaseMarshalData is called on it.
        if (!IsTableObjRef(pStd))
        {
            // normal case, dec the ref counts from the IPID entry,
            // OLE always passed fLastReleaseCloses = FALSE on
            // Unmarshal and RMD so do the same here.

            DWORD mshlflags = (pStd->flags & SORF_P_WEAKREF)
                            ? (MSHLFLAGS_WEAK   | MSHLFLAGS_KEEPALIVE)
                            : (MSHLFLAGS_NORMAL | MSHLFLAGS_KEEPALIVE);
            DecSrvIPIDCnt(pEntry, pStd->cPublicRefs, 0, NULL, mshlflags);
        }
    }

    if (SUCCEEDED(hr) && ppv)
    {
        ValidateIPIDEntry(pEntry);

        // If the pointer to the server object is NULL then we are
        // disconnected.
        if(NULL == pEntry->pv)
        {
            hr = CO_E_OBJNOTCONNECTED;
        }
        else
        {
            // extract and AddRef the pointer to return to the caller.
            // Do this before releasing the lock (which we might do below
            // on the server-side in DecSrvIPIDCnt.

            // NOTE: we are calling App code while holding the lock,
            // but there is no way to avoid this.
            Win4Assert(IsValidInterface(pEntry->pv));
            *ppv = pEntry->pv;
            ((IUnknown *)*ppv)->AddRef();
            AssertOutPtrIface(hr, *ppv);

            if (_dwFlags & SMFLAGS_WEAKCLIENT && !(pStd->flags & SORF_P_WEAKREF))
            {
                // make the client interface weak, ignore errors.
                UNLOCK(gIPIDLock);
                ASSERT_LOCK_NOT_HELD(gIPIDLock);
                RemoteChangeRef(0,0);
                ASSERT_LOCK_NOT_HELD(gIPIDLock);
                LOCK(gIPIDLock);
            }
        }
    }

    ComDebOut((DEB_MARSHAL, "pEntry:%x cRefs:%x cStdId:%x\n", pEntry,
        (SUCCEEDED(hr)) ? pEntry->cStrongRefs : 0, _pStdId->GetRC()));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarshalIPID hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::PrivateCopyProxy, internal
//
//  Synopsis:   Creates a copy of a proxy and IPID entry.
//
//  Arguements: [pv]   - Proxy to copy
//              [ppv]  - return copy here.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::PrivateCopyProxy( IUnknown *pv, IUnknown **ppv )
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::PrivateCopyProxy this:%x pv:%x\n",
            this, pv));

    // Don't copy stubs.
    if (ServerSide() || pv == NULL || ppv == NULL)
        return E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Prevent a disconnect from occuring while unmarshaling the
    // interface since we may have to yield the ORPC lock.
    HRESULT hr = PreventPendingDisconnect();

    // Initialize
    *ppv = NULL;

    if (SUCCEEDED(hr))
    {
        // Find the proxy to copy.
        IPIDEntry *pEntry;
        hr = FindIPIDEntryByInterface(pv, &pEntry);
        if (SUCCEEDED(hr))
        {
            if (pEntry->dwFlags & IPIDF_DISCONNECTED)
            {
                // Don't copy disconnected proxies.
                hr = RPC_E_DISCONNECTED;
            }
            else if (IsEqualGUID(pEntry->iid, IID_IUnknown))
            {
                // IUnknown can't be copied.
                hr = E_INVALIDARG;
            }
            else
            {
                // make a copy of the proxy
                BOOL fNonNDRProxy;
                IRpcProxyBuffer *pProxy;
                void *pVoid;

                hr = CreateProxy(pEntry->iid, &pProxy, &pVoid, &fNonNDRProxy);
                if (SUCCEEDED(hr))
                {
                    IPIDEntry *pIpidCopy;

                    // add a disconnected IPID entry to the table.
                    hr = AddIPIDEntry(NULL, &pEntry->ipid, pEntry->iid, NULL,
                                      pProxy, pVoid, &pIpidCopy);

                    if (SUCCEEDED(hr))
                    {
                        if (pVoid)
                        {
                            // Follow the aggregation rules to cache interface
                            // pointer on the proxy by releasing the outer object
                            (_pStdId->GetCtrlUnk())->Release();
                        }

                        // mark this IPID as a copy so we dont free it during
                        // ReleaseIPIDs.
                        pIpidCopy->dwFlags |= IPIDF_COPY;

                        // connect the IPIDEntry before adding it to the table so
                        // that we dont have to worry about races between Unmarshal,
                        // Disconnect, and ReconnectProxies.

                        // Make up an objref. Mark it as NOPING since we dont
                        // really have any references and we dont really need
                        // any because if we ever try to marshal it we will
                        // find the original IPIDEntry and use that. NOPING
                        // also lets us skip this IPID in DisconnectCliIPIDs.

                        STDOBJREF std;
                        OXIDFromMOXID(pEntry->pOXIDEntry->GetMoxid(), &std.oxid);
                        std.ipid        = pEntry->ipid;
                        std.cPublicRefs = 1;
                        std.flags       = SORF_NOPING;

                        hr = ConnectCliIPIDEntry(&std, pEntry->pOXIDEntry, pIpidCopy);

                        // Add this IPID entry after the original.
                        pIpidCopy->pNextIPID = pEntry->pNextIPID;
                        pEntry->pNextIPID    = pIpidCopy;
                        _cIPIDs++;

                        // Return the interface to the client
                        if (SUCCEEDED(hr))
                        {
                            Win4Assert(pIpidCopy->pv);
                            *ppv = (IUnknown *) pIpidCopy->pv;
                            (*ppv)->AddRef();
                        }
                    }
                    else
                    {
                        // could not get an IPIDEntry, release the proxy, need to
                        // release the lock to do this.

                        UNLOCK(gIPIDLock);
                        ASSERT_LOCK_NOT_HELD(gIPIDLock);

                        // Release the interface before releasing proxy
                        if (pVoid)
                            ((IUnknown *) pVoid)->Release();
                        pProxy->Release();

                        ASSERT_LOCK_NOT_HELD(gIPIDLock);
                        LOCK(gIPIDLock);
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            ValidateIPIDEntry(pEntry);
            AssertOutPtrIface(hr, *ppv);
        }
        AssertDisconnectPrevented();
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Now let pending disconnect through.
    HRESULT hr2 = HandlePendingDisconnect(hr);
    if (FAILED(hr2) && SUCCEEDED(hr))
    {
        // a disconnect came in while creating the proxy. ppv contains
        // an AddRef'd interface pointer so go Release that now.
        (*ppv)->Release();
        *ppv = NULL;
    }

    ComDebOut((DEB_MARSHAL, "CStdMarshal::PrivateCopyProxy hr:%x\n", hr2));
    return hr2;
}

//+-------------------------------------------------------------------
//
//  Member:     MakeSrvIPIDEntry, private
//
//  Synopsis:   creates a server side IPID table entry.
//
//  Arguements: [riid] - the interface to return
//              [ppEntry] - IPIDEntry returned
//
//  History:    20-Feb-95   Rickhi       Created
//
//  Notes:      The stub is not created until connect time. The stub is
//              destroyed at disconnect, but the IPIDEntry remains around
//              until the stdmarshal object is destroyed.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::MakeSrvIPIDEntry(REFIID riid, IPIDEntry **ppEntry)
{
    Win4Assert(ServerSide());
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    IPID ipidDummy;
    IPIDEntry *pNewEntry;
    HRESULT hr = AddIPIDEntry(NULL, &ipidDummy, riid, NULL, NULL, NULL,
                              &pNewEntry);
    if (SUCCEEDED(hr))
    {
        // add IPIDEntry to chain for this object
        ChainIPIDEntry(pNewEntry);
    }

    // Initialize the return value
    *ppEntry = pNewEntry;

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ConnectSrvIPIDEntry, private
//
//  Synopsis:   connects a server-side IPIDEntry
//
//  Arguements: [pEntry] - IPIDEntry to connect
//              [pUnkUseInner] - ??
//
//  History:    20-Feb-95   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::ConnectSrvIPIDEntry(IPIDEntry *pEntry, IUnknown *pUnkUseInner)
{
    ComDebOut((DEB_MARSHAL,
        "ConnectSrvIPIDEntry this:%x pEntry:%x\n", this, pEntry));
    Win4Assert(ServerSide());
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    BOOL fNonNDRStub;
    void *pv;
    IRpcStubBuffer *pStub;
    HRESULT hr = CreateStub(pEntry->iid, &pStub, &pv, &fNonNDRStub, pUnkUseInner);

    if (SUCCEEDED(hr) && (pEntry->dwFlags & IPIDF_DISCONNECTED))
    {
        Win4Assert(pEntry->pv == NULL);
        pEntry->pStub = pStub;
        pEntry->pv    = pv;
        pEntry->pChnl = _pChnl;

        // entry is now connected
        pEntry->dwFlags &= ~IPIDF_DISCONNECTED;

        if (_dwFlags & SMFLAGS_NOPING)
        {
            // object does not need pinging, turn on NOPING
            pEntry->dwFlags |= IPIDF_NOPING;
        }

        if (fNonNDRStub)
        {
            // the stub was a custom 16bit one requested by WOW, mark the
            // IPIDEntry as holding a non-NDR stub so we know to set the
            // SORF_P_NONNDR flag in the StdObjRef when marshaling. This
            // tells local clients whether to create a MIDL generated
            // proxy or custom proxy. Functionality to support OLE
            // Automation on DCOM.

            pEntry->dwFlags |= IPIDF_NONNDRSTUB;
        }

        // increment the OXIDEntry ref count so that it stays
        // around as long as the IPIDEntry points to it. It gets
        // decremented when we disconnect the IPIDEntry.

        pEntry->pOXIDEntry = _pChnl->GetOXIDEntry();
        Win4Assert(pEntry->pOXIDEntry->GetTid() == GetCurrentApartmentId());
        pEntry->pOXIDEntry->IncRefCnt();
    }
    else if (SUCCEEDED(hr))
    {
        // while we released the lock to create the stub, some other thread
        // also created the stub, throw our stub away and use the already
        // created one.

        Win4Assert(pEntry->pv != NULL);
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        _try
        {
            ((IUnknown *) pv)->Release();
        }
        _except (AppInvokeExceptionFilter(GetExceptionInformation(), pv, IID_IUnknown, 2))
        {
            ComDebOut((DEB_MARSHAL | DEB_WARN, "Server 0x%p threw an exception\n", pv));
            hr = RPC_E_SERVERFAULT;
        }
        
        ((IRpcStubBuffer*)pStub)->Disconnect();
        pStub->Release();

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL, "ConnectSrvIPIDEntry pEntry:%x pStub:%x hr:%x\n",
        pEntry, pStub, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     MakeCliIPIDEntry, private
//
//  Synopsis:   creates a client side IPID table entry
//
//  Arguements: [riid] - the interface to return
//              [pStd]  - standard objref
//              [pOXIDEntry] - OXIDEntry of the server
//              [ppEntry] - IPIDEntry returned
//
//  History:    20-Feb-95   Rickhi       Created
//              20-Nov-96   Gopalk       Release outer unknowm for
//                                       caching interface on proxy
//--------------------------------------------------------------------
HRESULT CStdMarshal::MakeCliIPIDEntry(REFIID riid, STDOBJREF *pStd,
                                      OXIDEntry *pOXIDEntry,
                                      IPIDEntry **ppEntry)
{
    Win4Assert(ClientSide());
    AssertValid();
    AssertDisconnectPrevented();
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_HELD(gIPIDLock);

    BOOL fNonNDRProxy;
    void *pv;
    IRpcProxyBuffer *pProxy;
    HRESULT hr = CreateProxy(riid, &pProxy, &pv, &fNonNDRProxy);

    if (SUCCEEDED(hr))
    {
        // add a disconnected IPID entry to the table.
        hr = AddIPIDEntry(NULL, &pStd->ipid, riid, NULL, pProxy, pv, ppEntry);

        if (SUCCEEDED(hr))
        {
            if (pv)
            {
                // Follow the aggregation rules to cache interface pointer
                // on the proxy by releasing the outer object
                (_pStdId->GetCtrlUnk())->Release();
            }

            if (fNonNDRProxy)
            {
                // the proxy is a custom 16bit one requested by WOW, mark the
                // IPIDEntry as holding a non-NDR proxy so we know to set the
                // LOCALF_NOTNDR flag in the local header when we call on it
                // (see CRpcChannelBuffer::ClientGetBuffer). Functionality to
                // support OLE Automation on DCOM.

                (*ppEntry)->dwFlags |= IPIDF_NONNDRPROXY;
            }

            if (pStd->flags & SORF_P_NONNDR)
            {
                // need to remember this flag so we can tell other
                // unmarshalers if we remarshal it.

                (*ppEntry)->dwFlags |= IPIDF_NONNDRSTUB;
            }

            // connect the IPIDEntry before adding it to the table so
            // that we dont have to worry about races between Unmarshal,
            // Disconnect, and ReconnectProxies.

            hr = ConnectCliIPIDEntry(pStd, pOXIDEntry, *ppEntry);

            // chain the IPIDEntries for this OID together. On client side
            // always add the entry to the list regardless of whether connect
            // succeeded.
            ChainIPIDEntry(*ppEntry);
        }
        else
        {
            // could not get an IPIDEntry, release the proxy, need to
            // release the lock to do this.

            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            // Release the interface before releasing proxy
            if(pv)
                ((IUnknown *) pv)->Release();

            // CreateProxy will set pProxy to NULL if iid was IUnknown
            if (pProxy)
                pProxy->Release();

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ConnectCliIPIDEntry, private
//
//  Synopsis:   connects a client side IPID table entry to the server
//
//  Arguments:  [pStd] - standard objref
//              [pOXIDEntry] - OXIDEntry for the server
//              [pEntry] - IPIDEntry to connect, already has a proxy
//                         and the IID filled in.
//
//  Notes:      This routine is re-entrant, it may be called multiple
//              times for the same IPIDEntry, with part of the work done
//              in one call and part in another. Only if the entry is
//              fully set up will it return S_OK and mark the entry as
//              connected. DisconnectCliIPIDs handles cleanup of partial
//              connections.
//
//  History:    20-Feb-95   Rickhi       Created
//              20-Nov-96   Gopalk       Release outer unknowm for
//                                       caching interface on proxy
//--------------------------------------------------------------------
HRESULT CStdMarshal::ConnectCliIPIDEntry(STDOBJREF *pStd,
                                         OXIDEntry *pOXIDEntry,
                                         IPIDEntry *pEntry)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::ConnectCliIPIDEntry this:%x ipid:%I pOXIDEntry:%x pIPIDEntry:%x\n",
         this, &pStd->ipid, pOXIDEntry, pEntry));
    Win4Assert(ClientSide());
    AssertDisconnectPrevented();
    AssertValid();
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_HELD(gIPIDLock);
    HRESULT hr = S_OK;

    // mark the object as having attempted to connect an IPIDEntry so that
    // if we fail somewhere in this routine and dont mark the whole object
    // as connected, Disconnect will still try to clean things up.

    _dwFlags |= SMFLAGS_TRIEDTOCONNECT;

    if (!(pStd->flags & SORF_NOPING))
    {
        // this interface requires pinging, turn off NOPING for this object
        // and this IPIDEntry.
        _dwFlags        &= ~SMFLAGS_NOPING;
        pEntry->dwFlags &= ~IPIDF_NOPING;
    }

    if (!(_dwFlags & (SMFLAGS_REGISTEREDOID | SMFLAGS_NOPING)))
    {
        // register the OID with the ping server so it will get pinged
        Win4Assert(_pRefCache == NULL);
        OXID oxid;
        OXIDFromMOXID(pOXIDEntry->GetMoxid(), &oxid);
        hr = gROIDTbl.ClientRegisterOIDWithPingServer(_pStdId->GetOID(),
                                                      oxid,
                                                      pOXIDEntry->GetMid(),
                                                      &_pRefCache);
        if (FAILED(hr))
        {
            Win4Assert(_pRefCache == NULL);
            return hr;
        }

        Win4Assert(_pRefCache);
        _dwFlags |= SMFLAGS_REGISTEREDOID;
    }

    // Go get any references we need that are not already included in the
    // STDOBJREF. These references will have been added to the counts in
    // the IPIDEntry upon return. Any references in the STDOBJREF will be
    // added to the IPIDEntry count only if the connect succeeds, otherwise
    // ReleaseMarshalObjRef (which will clean up STDOBJREF references) will
    // get called by higher level code.
    if (!(pEntry->dwFlags & IPIDF_NOPING) && !(pStd->flags & SORF_P_WEAKREF))
    {
        // register this entry with the reference cache
        _pRefCache->TrackIPIDEntry(pEntry);
    }

    hr = GetNeededRefs(pStd, pOXIDEntry, pEntry);
    if (FAILED(hr))
    {
        return hr;
    }

    if (pEntry->pChnl == NULL)
    {
        // create a channel for this oxid/ipid pair. On the client side we
        // create one channel per proxy (and hence per IPID). Note that
        // this will release the lock so we need to guard against two threads
        // doing this at the same time.

        CCtxComChnl *pChnl = NULL;
        hr = CreateChannel(pOXIDEntry, pStd->flags, pStd->ipid,
                           pEntry->iid, &pChnl);

        if (SUCCEEDED(hr))
        {
            if (pEntry->pChnl == NULL)
            {
                // update this IPID table entry. must update ipid too since
                // on reconnect it differs from the old value.

                pOXIDEntry->IncRefCnt();
                pEntry->pOXIDEntry  = pOXIDEntry;
                pEntry->ipid        = pStd->ipid;
                if (pEntry->pIRCEntry)
                {
                    pEntry->pIRCEntry->ipid = pStd->ipid;
                }
                pEntry->pChnl = pChnl;
                pEntry->pChnl->SetIPIDEntry(pEntry);
            }
            else
            {
                // another thread already did the update, just release
                // the channel we created.
                pChnl->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // Release the lock while we connect the proxy. We have to do
        // this because the IDispatch proxy makes an Rpc call during
        // Connect (Yuk!), which causes the channel to assert that the
        // lock is released. The proxy MUST be able to handle multiple
        // simultaneous or nested connects to the same channel ptr, since
        // it is possible when we yield the lock for another thread to
        // come in here and try a connect.

        void *pv = NULL;
        IRpcProxyBuffer * pProxy = (IRpcProxyBuffer *)(pEntry->pStub);

        if (pProxy)
        {
            // HACKALERT: OleAutomation returns NULL pv in CreateProxy
            // in cases where they dont know whether to return an NDR
            // proxy or a custom-format proxy. So we have to go connect
            // the proxy first then Query for the real interface once that
            // is done.

            BOOL fGetpv = (pEntry->pv) ? FALSE : TRUE;

            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            hr = pProxy->Connect((IRpcChannelBuffer3 *) pEntry->pChnl);
            if (fGetpv && SUCCEEDED(hr))
            {
                hr = pProxy->QueryInterface(pEntry->iid, &pv);
                AssertOutPtrIface(hr, pv);

                if(SUCCEEDED(hr))
                {
                    // Follow the aggregation rules to cache interface pointer
                    // on the proxy by releasing the outer object
                    (_pStdId->GetCtrlUnk())->Release();
                }
            }

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }

        // Regardless of errors from Connect and QI we wont try to cleanup
        // any of the work we have done so far in this routine. The routine
        // is reentrant (by the same thread or by different threads) and
        // those calls could be using some of resources we have already
        // allocated. Instead, we rely on DisconnectCliIPIDs to cleanup
        // the partial allocation of resources.

        if (pEntry->dwFlags & IPIDF_DISCONNECTED)
        {
            // Mark the IPIDEntry as connected so we dont try to connect
            // again. Also, as long as there is one IPID connected, the
            // whole object is considered connected. This allows disconnect
            // to find the newly connected IPID and disconnect it later.
            // Infact, DisconnectCliIPIDs relies on there being at least
            // one IPID with a non-NULL OXIDEntry. It is safe to set this
            // now because Disconnects have been temporarily turned off.

            if (SUCCEEDED(hr))
            {
                if (pv)
                {
                    // assign the interface pointer
                    pEntry->pv = pv;
                }

                AssertDisconnectPrevented();
                pEntry->dwFlags &= ~IPIDF_DISCONNECTED;
                _dwFlags &= ~SMFLAGS_DISCONNECTED;
            }
        }
        else
        {
            // while the lock was released, the IPIDEntry got connected
            // by another thread (or by a nested call on this thread).
            // Ignore any errors from Connect or QI since apparently
            // things are connected now.
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // give the supplied references to the IPIDEntry or
            // to the refcache.
            AddSuppliedRefs(pStd, pEntry);
        }

        // in debug build, ensure that we did not mess up
        ValidateIPIDEntry(pEntry);
    }

    ASSERT_LOCK_HELD(gIPIDLock);

    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::ConnectCliIPIDEntry this:%x pOXIDEntry:%x pChnl:%x hr:%x\n",
         this, pEntry->pOXIDEntry, pEntry->pChnl, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     AddSuppliedRefs, private
//
//  Synopsis:   Takes the references from STDOBJREF and gives them
//              to the IPIDEntry or RefCache.
//
//  Arguments:  [pStd] - standard objref
//              [pEntry] - IPIDEntry
//
//  History:    20-Jan-99   Rickhi       Created
//
//--------------------------------------------------------------------
void CStdMarshal::AddSuppliedRefs(STDOBJREF *pStd, IPIDEntry *pEntry)
{
    // Add in any references we were given. If we were given 0 refs
    // and the interface is NOPING, then pretend like we got 1 ref.
    ULONG cRefs = ((pStd->cPublicRefs == 0) && (pStd->flags & SORF_NOPING))
                  ? 1 : pStd->cPublicRefs;

    // figure out if we have weak or strong references. To be weak
    // they must be local to this machine and the SORF flag set.
    BOOL fWeak = ((pStd->flags & SORF_P_WEAKREF) &&
                 (pEntry->pOXIDEntry->IsOnLocalMachine()));

    BOOL bWeakIPID = FALSE;
    
    if (fWeak)
        pEntry->cWeakRefs += cRefs;
    else
    {
        if (pEntry->cWeakRefs)
            bWeakIPID = TRUE;   
        pEntry->cStrongRefs += cRefs;
    }   
    if (!(pEntry->dwFlags & IPIDF_NOPING) && !(pStd->flags & SORF_P_WEAKREF) && !bWeakIPID)
    {
        // give extra references to the cache so they can be
        // shared by other apartments in this process.
        _pRefCache->GiveUpRefs(pEntry);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     GetNeededRefs, private
//
//  Synopsis:   Figures out if any references are needed and goes and gets
//              them from the server.
//
//  Arguments:  [pStd] - standard objref
//              [pOXIDEntry] - OXIDEntry for the server
//              [pEntry] - IPIDEntry to connect, already has a proxy
//                         and the IID filled in.
//
//  History:    20-Feb-95   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::GetNeededRefs(STDOBJREF *pStd, OXIDEntry *pOXIDEntry,
                                   IPIDEntry *pEntry)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    HRESULT hr  = S_OK;

    if ((pStd->flags & (SORF_NOPING | SORF_P_WEAKREF)) == 0)
    {
        // object does reference counting, go get the references we need...

        // if we dont have any and weren't given any strong refs, go get some.
        ULONG cNeedStrong = ((pEntry->cStrongRefs + pStd->cPublicRefs) == 0)
                            ? 1 : 0;

        // if we are using secure refs and we dont have any, go get some.
        ULONG cNeedSecure = ((gCapabilities & EOAC_SECURE_REFS) &&
                            (pEntry->cPrivateRefs == 0)) ? 1 : 0;

        if (cNeedStrong || cNeedSecure)
        {
            // Need to go get some references from the remote server or reference
            // cache. Note that we might yield here but we dont have to worry about
            // it because the IPIDEntry is still marked as disconnected.
            hr = RemoteAddRef(pEntry, pOXIDEntry, cNeedStrong, cNeedSecure, FALSE);
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
 }

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReconnectProxies
//
//  Synopsis:   Reconnects the proxies to a new server (functionality
//              used by the OLE default handler).
//
//  History:    20-Feb-95   Rickhi  Created.
//
//  CODEWORK:   CreateServer should just ask for all these interfaces
//              during the create.
//
//--------------------------------------------------------------------
void CStdMarshal::ReconnectProxies()
{
    ComDebOut((DEB_MARSHAL,"CStdMarshal::ReconnectProxies this:%x pFirst:%x\n",
            this, _pFirstIPID));
    AssertValid();
    Win4Assert(ClientSide());
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // must be at least 1 proxy already connected in order to be able
    // to reconnect the other proxies. We cant just ASSERT that's true
    // because we were not holding the lock on entry.

    HRESULT hr = PreventDisconnect();

    if (SUCCEEDED(hr))
    {
        // allocate a stack buffer to hold the IPIDs
        IID *pIIDsAlloc = (IID *) _alloca(_cIPIDs * sizeof(IID));
        IID    *pIIDs = pIIDsAlloc;
        USHORT  cIIDs = 0;

        IPIDEntry *pNextIPID = _pFirstIPID;
        while (pNextIPID)
        {
            if (pNextIPID->dwFlags & IPIDF_COPY)
            {
                // Don't allow reconnection for servers with
                // secure proxies (copied IPIDEntries).
                hr = E_FAIL;
                break;
            }

            if ((pNextIPID->dwFlags & IPIDF_DISCONNECTED))
            {
                // not connected, add it to the list to be connected.
                *pIIDs = pNextIPID->iid;
                pIIDs++;
                cIIDs++;
            }

            pNextIPID = pNextIPID->pNextIPID;
        }

        if (cIIDs != 0 && SUCCEEDED(hr))
        {
             // we have looped filling in the IID list, and there are
             // entries int he list. go call QI on server now and
             // unmarshal the results.

             hr = RemQIAndUnmarshal(cIIDs, pIIDsAlloc, NULL);
        }
    }

    DbgWalkIPIDs();
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // this will handle any Disconnect that came in while we were busy.
    hr = HandlePendingDisconnect(hr);

    ComDebOut((DEB_MARSHAL,"CStdMarshal::ReconnectProxies [OUT] this:%x\n", this));
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseMarshalData, public
//
//  Synopsis:   Releases the references added by MarshalInterface
//
//  Arguements: [pStm] - stream containing marsheld interface
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::ReleaseMarshalData(LPSTREAM pStm)
{
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalData this:%x pStm:%x\n", this, pStm));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gComLock);

    OBJREF  objref;
    HRESULT hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        // call worker API to do the rest of the work
        hr = ::ReleaseMarshalObjRef(objref);

        // deallocate the objref we read
        FreeObjRef(objref);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalData this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ReleaseObjRefSwitch       private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during releasing objref
//
//  Arguements: [pv] - void ptr to StdReleaseData structure
//
//  History:    03-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdReleaseData
{
    CStdMarshal *pStdMshl;
    OBJREF      *pObjRef;
} StdReleaseData;

HRESULT __stdcall ReleaseObjRefSwitch(void *pv)
{
    ComDebOut((DEB_MARSHAL, "ReleaseObjRefSwitch pv:%x\n", pv));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    OBJREF      *pObjRef  = ((StdReleaseData *) pv)->pObjRef;
    CStdMarshal *pStdMshl = ((StdReleaseData *) pv)->pStdMshl;

    // pass objref to subroutine to Release the marshaled data
    HRESULT hr = pStdMshl->ReleaseMarshalObjRef(*pObjRef);

    // Fix up the refcount
    pStdMshl->Release();

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "ReleaseObjRefSwitch hr:%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   ReleaseMarshalObjRef, private
//
//  Synopsis:   Releases the references added by MarshalObjRef
//
//  Arguements: [objref] - object reference
//
//  Algorithm:  Get the correct standard identity and ask it to do
//              a ReleaseMarshalData.
//
//  History:    19-Jun-95   Rickhi      Created
//              09-Jul-97   GopalK      Context related changes
//                                      and race fix
//
//--------------------------------------------------------------------
INTERNAL ReleaseMarshalObjRef(OBJREF &objref)
{
    ComDebOut((DEB_MARSHAL, "ReleaseMarshalObjRef objref:%x\n", &objref));
    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert(objref.flags != OBJREF_CUSTOM);

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // Lookup the identity or handler.

        // If the packet contains references, or it is a TABLESTRONG packet,
        // then create the StdMarshal if it does not already exist.
        STDOBJREF *pStd = &ORSTD(objref).std;
        BOOL fLocal = ((pStd->cPublicRefs != 0) || IsTableStrongObjRef(pStd))
                     ? FALSE : TRUE;

        BOOL fLightNAProxy = CrossAptRefToNA(objref);

        CStdMarshal *pStdMshl;
        hr = FindStdMarshal(objref, fLocal, &pStdMshl, fLightNAProxy);
        if (SUCCEEDED(hr))
        {
            // Create StdMarshalData object on the stack
            StdReleaseData StdData;

            // Initialize
            StdData.pStdMshl = pStdMshl;
            StdData.pObjRef  = &objref;

            // Check for the need to switch
            CObjectContext *pDestCtx = pStdMshl->ServerObjectCallable();
            if (pDestCtx)
            {
                // Switch
                hr = PerformCallback(pDestCtx, ReleaseObjRefSwitch, &StdData, IID_IMarshal, 7, NULL);
            }
            else
            {
                // Call the callback function directly
                hr = ReleaseObjRefSwitch(&StdData);
            }
        }
        else if (hr != CO_E_OBJNOTCONNECTED)
        {
            // Do nothing if the objref has no references.
            if (pStd->cPublicRefs != 0)
            {
                // we could not find or create an identity and the server is
                // outside this apartment, try to issue a remote release on
                // the interface
                RemoteReleaseObjRef(objref);
            }
        }
        else
        {
            // Return success if the server object has already been
            // disconnected for legacy support
            hr = S_OK;
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "ReleaseMarshalObjRef hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseMarshalObjRef, public
//
//  Synopsis:   Releases the references added by MarshalObjRef
//
//  Arguements: [objref] - object reference
//
//  History:    20-Feb-95   Rickhi      Created.
//              04-Mar-98   Gopalk      Context changes
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::ReleaseMarshalObjRef(OBJREF &objref)
{
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalObjRef this:%x objref:%x\n", this, &objref));
    AssertValid();
    Win4Assert(ServerObjectCallable() == NULL);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    STDOBJREF *pStd = &ORSTD(objref).std;
    ValidateSTD(pStd);

    ENTER_NA_IF_NECESSARY()

    // REFCOUNTING:
    if (ServerSide())
    {
        LOCK(gIPIDLock);

        // look for an existing IPIDEntry for the given IPID
        IPIDEntry *pEntry;
        hr = FindIPIDEntryByIPID(pStd->ipid, &pEntry);

        if (SUCCEEDED(hr) && !(pEntry->dwFlags & IPIDF_DISCONNECTED))
        {
            // subtract the ref count from the IPIDEntry, may Release the
            // StdId if this was the last reference for this IPIDEntry.

            // we need to figure out how it was marshalled, strong/weak etc
            // in order to set the flags and cRefs correctly to pass to
            // DecSrvIPIDCnt.

            if (IsTableObjRef(pStd))
            {
                // table case
                DWORD mshlflags = (pStd->flags & SORF_P_TBLWEAK)
                             ? MSHLFLAGS_TABLEWEAK : MSHLFLAGS_TABLESTRONG;
                DecSrvIPIDCnt(pEntry, 1, 0, NULL, mshlflags);
            }
            else
            {
                // normal or weak case
                DWORD mshlflags = (pStd->flags & SORF_P_WEAKREF)
                             ? MSHLFLAGS_WEAK : MSHLFLAGS_NORMAL;
                DecSrvIPIDCnt(pEntry, pStd->cPublicRefs, 0, NULL, mshlflags);
            }
        }

        UNLOCK(gIPIDLock);
    }
    else  // client side
    {
        if ((pStd->flags & SORF_NOPING) || IsTableWeakObjRef(pStd))
        {
            // this interface does not need pinging, or this packet
            // represents a TABLEWEAK reference, there is nothing to do.
            hr = S_OK;
        }
        else
        {
            // the packet owns some references, try to give them to
            // the reference cache or to the IPIDEntry.

            if (IsTableStrongObjRef(pStd))
            {
                // client-side table-strong packet, release a reference
                // on the refcache if it was marshaled by us.
                OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
                hr = ReleaseClientTableStrong(pOXIDEntry);
            }
            else
            {
                // normal, non-zero reference. look for an existing IPIDEntry
                // for the given IPID and try to give the refs to it.
                LOCK(gIPIDLock);

                IPIDEntry *pEntry;
                hr = FindIPIDEntryByIPID(pStd->ipid, &pEntry);
                if (SUCCEEDED(hr) && !(pEntry->dwFlags & IPIDF_DISCONNECTED))
                {
                    // add these to the cRefs of this entry, they will get freed
                    // when we do the remote release.  Saves an Rpc call now.
                    AddSuppliedRefs(pStd, pEntry);
                    UNLOCK(gIPIDLock);
                }
                else
                {
                    // client side, no matching IPIDEntry so just contact the remote
                    // server to remove the reference. ignore errors since there is
                    // nothing we can do about them anyway.
                    UNLOCK(gIPIDLock);
                    RemoteReleaseObjRef(objref);
                    hr = S_OK;
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    LEAVE_NA_IF_NECESSARY()

    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalObjRef this:%x hr:%x\n", this, hr));
    return hr;
}
//--------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseClientTableStong, private
//
//  Synposys:   release a client-side table-strong packet reference
//              on the refcache if it was marshaled by us.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::ReleaseClientTableStrong(OXIDEntry *pOXIDEntry)
{
    ComDebOut((DEB_MARSHAL,
              "CStdMarshal::ReleaseClientTableStrong this:%x\n"));

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    BOOL fFromCache = FALSE;
    CRefCache *pRefCache = _pRefCache;
    if (pRefCache == NULL)
    {
        // find the refcache, if none, then we are no longer
        // pinging this interface and there is nothing to do.
        pRefCache = gROIDTbl.LookupRefCache(_pStdId->GetOID());
        fFromCache = TRUE;
    }

    if (pRefCache)
    {
        // release the TABLESTRONG reference from the refcache.

        // The refcache might ask us to go release all remote
        // references so give it a place to put the data.
        USHORT cRifRef = 0;
        REMINTERFACEREF *pRifRefAlloc = (REMINTERFACEREF *)
            _alloca(pRefCache->NumIRCs() * 2 * sizeof(REMINTERFACEREF));
        REMINTERFACEREF *pRifRef = pRifRefAlloc;

        pRefCache->DecTableStrongCnt(_dwFlags &
                                     SMFLAGS_CLIENTMARSHALED,
                                     &pRifRef, &cRifRef);
        
        // If we got the CRefCache from the cache, we need to release the
        // reference it took on our behalf.
        if (fFromCache)
        {
            pRefCache->DecRefCnt();
        }
        
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        if (cRifRef != 0)
        {
            // need to go release the remote references
            RemoteReleaseRifRef(this, pOXIDEntry, cRifRef, pRifRefAlloc);
        }        
    }
    else
    {
        UNLOCK(gIPIDLock);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return S_OK;
}

//--------------------------------------------------------------------
//
//  Member:     CStdMarshal::PreventDisconnect, public
//
//  Synopsis:   Prevents a Disconnect from occurring until a matching
//              HandlePendingDisconnect is called.
//
//  History:    21-Sep-95   Rickhi      Created
//              15-Jun-98   GopalK      Context related changes
//
//  The ORPC LOCK is yielded at many places in order to make calls on
//  application interfaces (server-side objects, stubs, proxies,
//  handlers, remote objects, resolver, etc). In order to keep the
//  code (reasonably?) simple, disconnects are prevented from occuring
//  while in the middle of (potentially) complex operations, and while
//  there are outstanding calls on interfaces to this object.
//
//  To accomplish this, a counter (_cNestedCalls) is atomically incremented.
//  When _cNestedCalls != 0 and a Disconnect arrives, the object is flagged
//  as PendingDisconnect. When HandlePendingDisconnect is called, it
//  decrements the _cNestedCalls. If the _cNestedCalls == 0 and there is
//  a pending disconnect, the real Disconnect is done.
//
//  See also LockServer / UnlockServer and LockClient / UnlockClient.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::PreventDisconnect()
{
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(ClientSide() || (ServerObjectCallable() == NULL));

    // treat this as a nested call so that if we yield, a real
    // disconnect wont come through, instead it will be treated
    // as pending. That allows us to avoid checking our state
    // for Disconnected every time we yield the ORPC LOCK.

    InterlockedIncrement(&_cNestedCalls);
    if (_dwFlags & (SMFLAGS_DISCONNECTED | SMFLAGS_PENDINGDISCONNECT))
    {
        return CO_E_OBJNOTCONNECTED;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::PreventPendingDisconnect, public
//
//  Synopsis:   similar to PreventDisconnect but special case for use
//              in UnmarshalObjRef (since the client side starts out
//              in the Disconnected state until the first unmarshal is done).
//
//  History:    21-Sep-95   Rickhi      Created
//              15-Jun-98   GopalK      Context related changes
//
//+-------------------------------------------------------------------
HRESULT CStdMarshal::PreventPendingDisconnect()
{
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(ClientSide() || (ServerObjectCallable() == NULL));

    InterlockedIncrement(&_cNestedCalls);
    if (_dwFlags &
       (ClientSide() ? SMFLAGS_PENDINGDISCONNECT
                     : SMFLAGS_PENDINGDISCONNECT | SMFLAGS_DISCONNECTED))
     return CO_E_OBJNOTCONNECTED;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::HandlePendingDisconnect, public
//
//  Synopsis:   Reverses a call to PreventDisconnect and lets a
//              pending disconnect through.
//
//  Arguements: [hr] - return code from previous operations
//
//  History:    21-Sep-95   Rickhi      Created
//              15-Jun-98   GopalK      Context related changes
//
//+-------------------------------------------------------------------
HRESULT CStdMarshal::HandlePendingDisconnect(HRESULT hr)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    Win4Assert(ClientSide() || (ServerObjectCallable() == NULL));

    // Disconnect if needed
    if (InterlockedDecrement(&_cNestedCalls) == 0 &&
       (_dwFlags & SMFLAGS_PENDINGDISCONNECT))
    {
        DWORD dwType = GetPendingDisconnectType();

        Disconnect(dwType);
        hr = FAILED(hr) ? hr : CO_E_OBJNOTCONNECTED;
    }

    Win4Assert(_cNestedCalls != -1);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     DisconnectSwitch             private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during disconnect
//
//  Arguements: [pv] - void ptr to StdDiscData structure
//
//  History:    03-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdDiscData
{
    CStdMarshal *pStdMshl;
    DWORD        dwType;
    BOOL         fRelease;
} StdDiscData;

HRESULT __stdcall DisconnectSwitch(void *pv)
{
    ComDebOut((DEB_MARSHAL, "DisconnectSwitch pv:%x\n", pv));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CStdMarshal *pStdMshl = ((StdDiscData *) pv)->pStdMshl;

    // Disconnect
    pStdMshl->Disconnect(((StdDiscData *) pv)->dwType);

    // Fixup the refcount
    if(((StdDiscData *) pv)->fRelease)
        pStdMshl->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "DisconnectSwitch hr:%x\n", S_OK));
    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectAndRelease   public
//
//  Synopsis:   This is utility function that disconnects and release
//              the ID in the right context
//
//  Arguements: [dwType] - disconnect type (see DISCTYPE_*)
//
//  History:    15-Jun-98   Gopalk        Created
//
//--------------------------------------------------------------------
void CStdMarshal::DisconnectAndRelease(DWORD dwType)
{
    ComDebOut((DEB_MARSHAL, "IN CStdMarshal::DisconnectAndRelease\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Create StdDiscData object on the stack
    StdDiscData StdData;

    // Initialize
    StdData.dwType   = dwType;
    StdData.fRelease = TRUE;
    StdData.pStdMshl = this;

    CObjectContext *pDestCtx = ServerObjectCallable();
    if (pDestCtx)
    {
        // Switch
        PerformCallback(pDestCtx, DisconnectSwitch, &StdData, IID_IMarshal, 8, NULL);
    }
    else
    {
        // Call the callback function directly
        DisconnectSwitch(&StdData);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "OUT CStdMarshal::DisconnectAndRelease\n"));
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectObject, public
//
//  Synopsis:   part of IMarshal interface, this is legal only on the
//              server side.
//
//  History:    20-Feb-95   Rickhi      Created.
//              27-Mar-98   Johnstra    Switch to NA if FTM object
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::DisconnectObject(DWORD dwReserved)
{
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::DisconnectObject this:%x dwRes:%x\n", this, dwReserved));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // this operation is not legal from the client side (although
    // IProxyManager::Disconnect is), but we still have to return S_OK
    // in either case for backward compatibility.
    if (ServerSide())
    {
        Win4Assert(!SystemObject());

        // Disconnect the object
        Disconnect(DISCTYPE_APPLICATION);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::Disconnect, public
//
//  Synopsis:   client side - disconnects proxies from the channel.
//              server side - disconnects stubs from the server object.
//
//  Arguements: [dwType] - disconnect type (see DISCTYPE_*)
//
//  History:    20-Feb-95   Rickhi      Created.
//              04-Mar-98   Gopalk      Context changes
//              25-Nov-98   GopalK      Rewrite.
//
//--------------------------------------------------------------------
void CStdMarshal::Disconnect(DWORD dwType)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::Disconnect this:%x type:%d\n",
               this, dwType));
    AssertValid();

    // Mustn't call LogEventIsActive() inside LOCK
    BOOL fLogEventIsActive = (LogEventIsActive() && _pChnl != NULL);
    BOOL fDisconnectedNow  = FALSE;
    MIDEntry    *pMIDEntry = NULL;
    CCtxComChnl *pChnl     = NULL;

    // Acquire the lock
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Sanity checks
    Win4Assert(!SystemObject() ||
               (dwType & (DISCTYPE_SYSTEM | DISCTYPE_RELEASE | DISCTYPE_NORMAL)));
    Win4Assert((dwType != DISCTYPE_RELEASE) || ServerSide() || (_pID == NULL) ||
               (_pID->GetStdID() == NULL));

    // Check the disconnect state
    BOOL fFullyDisconnected = ((_dwFlags & SMFLAGS_DISCONNECTED) &&
                               ((_dwFlags & SMFLAGS_TRIEDTOCONNECT) == 0));

    // Avoid unneccessary work
    if (fFullyDisconnected == FALSE)
    {
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        BOOL fOkToDisconnect = (_pID) ? _pID->IsOkToDisconnect() : TRUE;

        if ((_pStdId->GetStrongCnt() || !fOkToDisconnect) && ServerSide() && dwType == DISCTYPE_NORMAL )
        {
            // This is a NORMAL disconnect (i.e. due to a RemRelease), however,
            // there are still strong references to the server, which means that
            // RemRelease is racing with Marshal, so leave the object connected
            // so that Marshal can continue.
            ComDebOut((DEB_WARN,"CStdMarshal::Disconnect [not done]:%x\n",this));

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }
        else
        {
            // Revoke the OID from the OID table. This prevents other
            // marshals/unmarshals from finding this identity that is about to
            // be disconnected. This is the ONLY state that should change when
            // work is in progress on other threads or on calls higher up
            // the stack
            BOOL fRevokeOID = (((_dwFlags & SMFLAGS_PENDINGDISCONNECT) == 0) &&
                               (ClientSide()
                                ? (dwType != DISCTYPE_RELEASE)
                                : (_pStdId->IsAggregated()
                                   ? (dwType & (DISCTYPE_UNINIT | DISCTYPE_RELEASE))
                                   : TRUE)));
            if (fRevokeOID)
            {
                _pStdId->RevokeOID();

                // Detach from IDObject
                if (_pID && (ClientSide() ? (dwType != DISCTYPE_APPLICATION) : TRUE))
                    _pID->RemoveStdID();
            }

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (_cNestedCalls != 0)
            {
#if DBG==1
                // There is a bug saying.  In case of MTA clients to
                // invoking MTA server, sometimes the server won't shut down.
                // There might be a race condition between here and
                // CStdMarshal::UnlockServer, but I can't think of how this
                // could happen in real world.  So, adding an assert (rongc)

                _fNoOtherThreadInDisconnect = FALSE;
#endif

                // We dont allow disconnect to occur inside a nested call since we
                // dont want state to vanish in the middle of a call, but we do
                // remember that we want to disconnect and will do it when the
                // stack unwinds (or other threads complete).

                Win4Assert(dwType != DISCTYPE_UNINIT);

                if (!(_dwFlags & SMFLAGS_PENDINGDISCONNECT))
                {
                    SetPendingDisconnectType(dwType);
                }

                ComDebOut((DEB_MARSHAL,"CStdMarshal::Disconnect [pending]:%x\n",this));
#if DBG==1
                _fNoOtherThreadInDisconnect = TRUE;
#endif
            }
            else
            {
                // No calls in progress and not fully disconnected, OK to really
                // disconnect now. First mark ourself as disconnected
                _dwFlags &= ~(SMFLAGS_PENDINGDISCONNECT |
                              SMFLAGS_APPDISCONNECT     |
                              SMFLAGS_SYSDISCONNECT     |
                              SMFLAGS_RUNDOWNDISCONNECT |
                              SMFLAGS_TRIEDTOCONNECT);
                _dwFlags |= SMFLAGS_DISCONNECTED;
                fDisconnectedNow = TRUE;

                // Sanity check
                Win4Assert(ServerObjectCallable() == NULL);

                if (fLogEventIsActive)
                {
                    // save the MIDEntry for logging later.
                    pMIDEntry = _pChnl->GetOXIDEntry()->GetMIDEntry();
                }

                if (ServerSide())
                {
                    // turn on the FirstMarshal flag so we execute the FirstMarshal
                    // method if we are asked to marshal again.
                    _dwFlags |= SMFLAGS_FIRSTMARSHAL;

                    if (_pStdId->IsAggregated())
                    {
                        // aggregated server side, mark as not disconnected
                        // so we are back in the original state
                        _dwFlags &= ~SMFLAGS_DISCONNECTED;
                    }

                    // Remember the channel pointer for release after we've
                    // released the lock. NULL the member variable.
                    pChnl  = _pChnl;
                    _pChnl = NULL;
                }
            }
        }

        ASSERT_LOCK_NOT_HELD(gComLock);

        if (fDisconnectedNow)
        {
            // Disconnect all IPIDs.
            // Don't hold gComLock over these calls, but do hold gIPIDLock.
            if (ServerSide())
            {
                DisconnectSrvIPIDs(dwType);
            }
            else
            {
                DisconnectCliIPIDs();
            }
        }
    }
    else
    {
        // Already fully disconnected.
        ComDebOut((DEB_MARSHAL,"CStdMarshal::Disconnect [already done]:%x\n",this));
    }

    // Cleanup rest of the state
    CtxEntry    *pCtxEntryHead = NULL;
    CPolicySet  *pPS           = NULL;
    CIDObject   *pID           = NULL;

    if (((_dwFlags & SMFLAGS_CLEANEDUP) == 0) &&
        ((dwType & (DISCTYPE_UNINIT | DISCTYPE_RELEASE)) ||
        (ServerSide() && !_pStdId->IsAggregated() &&
         (_dwFlags & SMFLAGS_DISCONNECTED))))
    {
        // Save IDObject for later release
        pID = _pID;
        _pID = NULL;

        // Sanity checks
        Win4Assert(ClientSide() || (_pCtxEntryHead == NULL));
        Win4Assert(ServerSide() || (_pPS == NULL));

        // Save policy set for later release
        pPS  = _pPS;
        _pPS = NULL;

        // Save context entries for later release
        pCtxEntryHead = _pCtxEntryHead;

        _dwFlags |= SMFLAGS_CLEANEDUP;
    }

    // Release the lock
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Release the channel if needed
    if (pChnl)
        pChnl->Release();

    // Release policy set if needed
    if (pPS)
        pPS->Release();

    // Release context entries if needed
    if (pCtxEntryHead)
        CtxEntry::PrepareCtxEntries(pCtxEntryHead, (CTXENTRYFLAG_IDENTRY | CTXENTRYFLAG_STDID));

    // Release IDObject if needed
    if (pID)
    {
        ReleaseIDObject(pID);
    }

    // dont release the real object's m_pUnkControl if the server side
    // marshaler has been aggregated into the real object
    if (fDisconnectedNow && ServerSide() && !_pStdId->IsAggregated())
    {
        // HACK - 16 and 32 bit Word 6.0 crash if you release all the objects
        // it left lying around at CoUninitialize.  Leak them.

        // If we are not uninitializing, then call the release.
        // If we are in WOW and the app is not word, then call the release.
        // If the app is not 32 bit word, then call the release.
        if((dwType != DISCTYPE_UNINIT) ||
    	    (IsWOWThread() && (g_pOleThunkWOW->GetAppCompatibilityFlags() & OACF_NO_UNINIT_CLEANUP) == 0) ||
    	    !IsTaskName(L"winword.exe"))
        {
	        // on the server side, we have to tell the stdid to release his
	        // controlling unknown of the real object.
	        _pStdId->ReleaseCtrlUnk();
        }
    }
    
    // if there are no external clients, this process should terminate
    // if its a surrogate process
    if (fDisconnectedNow && ServerSide() && !_pStdId->IsIgnoringOID())
    {
       FreeSurrogateIfNecessary();
    }

    // Notify all the people that wanted to know that we were being
    // disconnected that we're being disconnected.
    if (fDisconnectedNow)
    {
        NotifyDisconnect();
    }

    if (fLogEventIsActive && fDisconnectedNow)
    {
        REFMOID rmoid = _pStdId->GetOID();
        LogEventDisconnect(&rmoid, pMIDEntry, ServerSide());
    }
	
    if (pMIDEntry)
    {
        pMIDEntry->DecRefCnt();
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,"CStdMarshal::Disconnect [complete]:%x\n",this));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseIDObject, private
//
//  Synopsis:   If we still have an IDObject, release it.
//
//  Arguements: [pID] - IDObject to release.
//
//  History:    30-Apr-98   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::ReleaseIDObject(CIDObject *pID)
{
    // Deliver the DestoryIdentity events since we have not
    // already done so, and Release the IDObject.
    ENTER_NA_IF_NECESSARY();

    if (ServerSide())
    {
        if (!(_dwFlags & SMFLAGS_NOPING))
        {
            // return the OID to the resolver.
            FreePreRegMOID(_pStdId->GetOID());
        }
    }

    pID->StdIDRelease();
    pID->Release();
    LEAVE_NA_IF_NECESSARY();
}

//+-------------------------------------------------------------------
//
//  Method:     CStdMarshal::Deactivate    private
//
//  Synopsis:   Releases all the references on the server object as part
//              of deactivating the server
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::Deactivate()
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::Deactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void           *pServer;
    } ServerRefs;

    // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(!Deactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIPIDs cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ServerRefs *pServerRefs = (ServerRefs *) _alloca(_cIPIDs*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // mark object as deactivated.
    _dwFlags |= SMFLAGS_DEACTIVATED;

    // Save the reference held on the server by the StdId
    IUnknown *pServer = _pStdId->ResetServer();
    Win4Assert(pServer);

    // Save references held on the server by IPID entires
    ULONG cIPIDs = 0; 

    IPIDEntry *pNextIPID = _pFirstIPID;
    while (pNextIPID)
    {
        if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
        {
            // Sanity check
            Win4Assert(pNextIPID->pv);
            if (pNextIPID->pStub)
            {
                pServerRefs[cIPIDs].pRpcStub = (IRpcStubBuffer *) pNextIPID->pStub;
                pServerRefs[cIPIDs].pServer  = pNextIPID->pv;
                cIPIDs++;
            }
            else
            {
                Win4Assert(IsEqualIID(pNextIPID->iid, IID_IUnknown));
            }
        }

        // Reset interface pointer on the server object held by the IPID
        pNextIPID->pv = NULL;

        // Mark the IPID as deactivated
        pNextIPID->dwFlags |= IPIDF_DEACTIVATED;
        pNextIPID = pNextIPID->pNextIPID;
    }

    // Release lock before calling app code
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Release reference held on the server by the StdID
    pServer->Release();

    // Release references held on the server by IPID entries
    for (ULONG i=0; i<cIPIDs; i++)
    {
        if (pServerRefs[i].pRpcStub)
            pServerRefs[i].pRpcStub->Disconnect();

        if (pServerRefs[i].pServer)
            ((IUnknown *) pServerRefs[i].pServer)->Release();
    }

    ComDebOut((DEB_MARSHAL,"CStdMarshal::Deactivate this:%x hr:%x\n",
               this, S_OK));
}

//+-------------------------------------------------------------------
//
//  Method:     CStdMarshal::Reactivate    private
//
//  Synopsis:   Acquires the needed references on the server object
//              as part of reactivating the server
//
//  Arguements: [pServer] - ptr to server object to connect to.
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::Reactivate(IUnknown *pServer)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Reactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void          **ppServer;
        IID            *pIID;
    } ServerRefs;

    // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(Deactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIPIDs cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ServerRefs *pServerRefs = (ServerRefs *) _alloca(_cIPIDs*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Update state to indicate no longer deactivated.
    _dwFlags &= ~SMFLAGS_DEACTIVATED;

    // Init the reference held on the server by the StdID
    _pStdId->SetServer(pServer);

    // Obtain references held on the server by IFaceEntries
    ULONG cIPIDs = 0;
    IPIDEntry *pNextIPID = _pFirstIPID;
    while (pNextIPID)
    {
        // Sanity checks
        Win4Assert(pNextIPID->pv == NULL);
        if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
        {
            if (pNextIPID->pStub)
            {
                pServerRefs[cIPIDs].pRpcStub = (IRpcStubBuffer *) pNextIPID->pStub;
                pServerRefs[cIPIDs].ppServer = &pNextIPID->pv;
                pServerRefs[cIPIDs].pIID     = &pNextIPID->iid;
                cIPIDs++;
            }
            else
            {
                Win4Assert(IsEqualIID(pNextIPID->iid, IID_IUnknown));
                pNextIPID->pv = pServer;
            }
        }

        // Mark the IPID as reactivated
        pNextIPID->dwFlags &= ~IPIDF_DEACTIVATED;
        pNextIPID = pNextIPID->pNextIPID;
    }

    // Release lock before calling app code
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // AddRef server on behalf of StdID
    pServer->AddRef();

    // Reconnect IPID entries to server
    for (ULONG i=0; i<cIPIDs; i++)
    {
        pServer->QueryInterface(*pServerRefs[i].pIID, pServerRefs[i].ppServer);

        if (*pServerRefs[i].ppServer)
            pServerRefs[i].pRpcStub->Connect((IUnknown *) (*pServerRefs[i].ppServer));
    }

    ComDebOut((DEB_MARSHAL,"CStdMarshal::Reactivate this:%x hr:%x\n",
               this, S_OK));
}

#define IPID_RELEASE_SET_SIZE 1000

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectCliIPIDs
//
//  Synopsis:   disconnects client side IPIDs for this object.
//
//  History:    20-Feb-95   Rickhi  Created.
//              24-Jan-97   Gopalk  Follow aggregation rules for releasing
//                                  interface pointers on proxies
//                                  Also reset the connection status
//                                  maintained by StdId
//
//--------------------------------------------------------------------
void CStdMarshal::DisconnectCliIPIDs()
{
    ComDebOut((DEB_MARSHAL,"CStdMarshal::DisconnectCliIPIDs this:%x pFirst:%x\n",
               this, _pFirstIPID));
    Win4Assert(ClientSide());
    Win4Assert(_dwFlags & SMFLAGS_DISCONNECTED);

    // YIELD WARNING: Do not yield between here and the matching comment
    // below, since we are mucking with internal state that could get
    // messed up if a reconnect (or unmarshal) is done.

    ASSERT_LOCK_HELD(gIPIDLock);

    if (_dwFlags & SMFLAGS_REGISTEREDOID)
    {
        // Tell the resolver to stop pinging the OID. The OID is only
        // registered on the client side.

        Win4Assert(ClientSide());
        gROIDTbl.ClientDeRegisterOIDFromPingServer(_pRefCache,
                                                   _dwFlags & SMFLAGS_CLIENTMARSHALED);
    }

    // turn these flags off so re-connect (with new OID) will behave properly.
    _dwFlags &= ~(SMFLAGS_CLIENTMARSHALED | SMFLAGS_REGISTEREDOID |
                  SMFLAGS_NOPING);


    // on client side, we cant actually release the proxies until the
    // object goes away (backward compatibility), so we just release
    // our references to the remote guy, disconnect the proxies, and
    // delete the channels, but hold on to the IPIDEntries.

    // We must break this up into chunks because if we do it all at once,
    // we may have to make a huge allocation which could fail. Or the
    // huge alloc might succeed but blow up the stack in the server because
    // the same huge number of REMINTERFACEREFs have to get allocated on the
    // servers stack for the call to RemRelease.

    typedef struct _IPIDReleaseSet
    {
        USHORT           cRifRef;
        REMINTERFACEREF *pRifRef;
    } IPIDReleaseSet;

    // Calculate the number of IPIDs we have to disconnect and the number
    // of sets we need to break the operation up into.
    ULONG cIPIDs = (_cIPIDs + (_pRefCache ? _pRefCache->NumIRCs() : 0)) * 2;
    ULONG cSets  = cIPIDs / IPID_RELEASE_SET_SIZE + 1;

    USHORT       cOxidRefs  = 0;
    USHORT       cChnlRefs  = 0;
    OXIDEntry   *pOXIDEntry = NULL;
    CCtxComChnl *pChnl      = NULL;
    IPIDEntry   *pIPIDEntry = _pFirstIPID;
    USHORT       cRifRef    = 0;
    ULONG        cValidSets = 0;

    // Allocate an array of pointers to IPIDReleaseSets.
    IPIDReleaseSet* pSets = (IPIDReleaseSet*)PrivMemAlloc(cSets * sizeof(IPIDReleaseSet));

    // Allocate the entire array of pointers to channel objects.  This may
    // be a large allocation, but we may as well do it up front since there
    // are no inherent problems with a large array of these, and the fewer
    // times we have to go to the heap the better.
    CCtxComChnl** arChnl = (CCtxComChnl**)PrivMemAlloc(cIPIDs * sizeof(CCtxComChnl*));

    // Iterate through the sets, disconnecting IPIDs and saving necessary
    // state to do RemRelease later.
    for( ULONG SetIdx = 0; SetIdx < cSets && pIPIDEntry; SetIdx++ )
    {
        // Specify how many IPIDs in this set.
        ULONG cCurSet = (cIPIDs < IPID_RELEASE_SET_SIZE) ? cIPIDs : IPID_RELEASE_SET_SIZE;

        // Update the number of IPIDs remaining.
        cIPIDs -= cCurSet;

        // Init the pointer to the first RifRef and pointer to the
        // number of RifRefs.
        REMINTERFACEREF* pRifRef  = NULL;
        USHORT*          pcRifRef = &cRifRef;

        // If array of pointers was allocated ok, allocate a block of
        // REMINTERFACEREFs and initialize a pointer to the first one
        // in the block.
        if( pSets )
        {
            pSets[SetIdx].pRifRef = (REMINTERFACEREF*) PrivMemAlloc( cCurSet * sizeof(REMINTERFACEREF) );
            pSets[SetIdx].cRifRef = 0;

            pRifRef  =  pSets[SetIdx].pRifRef;
            pcRifRef = &pSets[SetIdx].cRifRef;

            // Increment the number of valid sets.
            ++cValidSets;
        }

        while (cCurSet-- > 0 && pIPIDEntry)
        {
            // we have to handle the case where ConnectCliIPIDEntry partially (but
            // not completely) set up the IPIDEntry, hence we cant just check
            // for the IPIDF_DISCONNECTED flag.

            ValidateIPIDEntry(pIPIDEntry);


            // NOTE: we are calling Proxy code here while holding the ORPC LOCK.
            // There is no way to get around this without introducing race
            // conditions.  We cant just disconnect the channel and leave the
            // proxy connected cause some proxies (like IDispatch) do weird stuff,
            // like keeping separate pointers to the server.

            if (pIPIDEntry->pStub)      // NULL for IUnknown IPID
            {
                ComDebOut((DEB_MARSHAL, "Disconnect pProxy:%x\n", pIPIDEntry->pStub));

                if (pIPIDEntry->pv != NULL)
                {
                    // AddRef the controling unknown and release the interface
                    // pointer of the proxy
                    _pStdId->GetCtrlUnk()->AddRef();
                    ((IUnknown *) pIPIDEntry->pv)->Release();
                    pIPIDEntry->pv = NULL;
                }

                // Disconnect the proxy from channel
                _try
                {
                    ((IRpcProxyBuffer *)pIPIDEntry->pStub)->Disconnect();
                }
                _except (AppInvokeExceptionFilter(GetExceptionInformation(), pIPIDEntry->pStub, IID_IRpcProxyBuffer, 4))
                {
                    ComDebOut((DEB_MARSHAL | DEB_WARN, "Proxy 0x%p threw an exception\n", pIPIDEntry->pStub));
                }

                // Since we've disconnected this IPID, release the registration
                // reference on the IID.                
                gRIFTbl.ReleaseInterface(pIPIDEntry->iid);
            }

            if (!(pIPIDEntry->dwFlags & IPIDF_NOPING))
            {
                // release remote references to the reference cache. If this is
                // the last reference for the cache, we may be asked to do the
                // remote release, and pRifRef will be updated to reflect that.
                if (_pRefCache)
                {
                    _pRefCache->ReleaseIPIDEntry(pIPIDEntry, &pRifRef, pcRifRef);
                }
            }

            pIPIDEntry->dwFlags |= IPIDF_DISCONNECTED | IPIDF_NOPING;

            if (pIPIDEntry->pChnl)
            {
                // Release the channel for this IPID. We dont want to release the
                // RefCnt on the channel yet cause we are holding the lock, so just
                // remember the pointer and release it below.
                if( arChnl )
                {
                    arChnl[cChnlRefs] = pIPIDEntry->pChnl;
                    cChnlRefs++;
                }
                pIPIDEntry->pChnl = NULL;
            }

            if (pIPIDEntry->pOXIDEntry)
            {
                // If we ever go to a model where different IPIDEntries on the
                // same object can point to different OXIDEntires, then we need
                // to re-write this code to batch the releases by OXID.
                Win4Assert(!pOXIDEntry || (pOXIDEntry == pIPIDEntry->pOXIDEntry));

                // we can't release the RefCnt on the OXIDEntry cause we are
                // holding the lock, so just remember we need to release one
                // more reference.
                cOxidRefs++;
                pOXIDEntry = pIPIDEntry->pOXIDEntry;
                pIPIDEntry->pOXIDEntry = NULL;
            }

            // get next IPID in chain for this object
            pIPIDEntry = pIPIDEntry->pNextIPID;
        }
    }

    // Remember the channel for release later (after we release the lock)
    // and NULL the member variable.
    pChnl = _pChnl;
    _pChnl = NULL;

    // As we could be reconnected to a different server,
    // reset connection status maintained by StdId
    _pStdId->SetConnectionStatus(S_OK);

    if (_pRefCache)
    {
        // release the RefCache entry
        _pRefCache->DecRefCnt();
        _pRefCache = NULL;
    }

    // YIELD WARNING: Up this this point we have been mucking with our
    // internal state. We cant yield before this point or a reconnect
    // proxies could get all messed up. It is OK to yield after this point
    // because all internal state changes are now complete.

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (NULL != pSets)
    {
        for (ULONG SetIdx = 0; SetIdx < cValidSets; SetIdx++)
        {
            // if the channel creation failed (memory alloc failures usually), 
            // it is possible that the OXIDEntry is not hooked up to the IPIDEntry.
            // In such a case, we have no option but to leak the references. 
            // Rundowns should take care of this.
            
            if (pSets[SetIdx].cRifRef != 0 && pOXIDEntry)
            {
                // we have looped filling in the RifRef and entries exist in the
                // array. go call the server now to release the IPIDs.

                Win4Assert(pOXIDEntry);  // must have been at least one
                Win4Assert(pSets[SetIdx].pRifRef);
                RemoteReleaseRifRef(this,
                                    pOXIDEntry,
                                    pSets[SetIdx].cRifRef,
                                    pSets[SetIdx].pRifRef);
            }
        }
    }

    while (cOxidRefs > 0)
    {
        // Now release the OXIDEntry refcnts (if any) from above
        pOXIDEntry->DecRefCnt();
        cOxidRefs--;
    }

    while (cChnlRefs > 0)
    {
        // Now release the Channel refcnts (if any) from above
        cChnlRefs--;
        arChnl[cChnlRefs]->Release();
    }

    if (pChnl)
        // release the last client side channel
        pChnl->Release();

    // Release memory we allocated.
    if ( NULL != pSets )
    {
        for( ULONG SetIdx = 0; SetIdx < cValidSets; SetIdx++ )
        {
            if( pSets[SetIdx].pRifRef )
            {
                PrivMemFree( pSets[SetIdx].pRifRef );
            }
        }
        PrivMemFree( pSets );
    }
    if ( arChnl )
        PrivMemFree( arChnl );

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    DbgWalkIPIDs();
    ComDebOut((DEB_MARSHAL, "CStdMarshal::DisconnectCliIPIDs this:%x\n",this));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectSrvIPIDs
//
//  Synopsis:   disconnects the server side IPIDs for this object.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::DisconnectSrvIPIDs(DWORD dwType)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::DisconnectSrvIPIDs this:%p pFirst:%p\n",this, _pFirstIPID));
    Win4Assert(ServerSide());

    // there should be no other threads looking at these IPIDs at this time,
    // since Marshal, Unmarshal, and Dispatch all call PreventDisconnect,
    // Disconnect checks the disconnected flag directly, RMD holds the
    // lock over it's whole execution, RemAddRef and RemRelease hold the
    // lock and check the disconnected flag of the IPIDEntry, and
    // RemQueryInterface calls PreventDisconnect.

    Win4Assert((_dwFlags & SMFLAGS_DISCONNECTED) || _pStdId->IsAggregated());
    Win4Assert(_cNestedCalls == 0);
    ASSERT_LOCK_HELD(gIPIDLock);

    if (_pFirstIPID == NULL)
    {
        // nothing to do
        return;
    }

    // allocate memory on stack to hold the stub and interface ptrs
    IPIDTmp *pTmpAlloc = (IPIDTmp *)_alloca(_cIPIDs * sizeof(IPIDTmp));
    IPIDTmp *pTmp = pTmpAlloc;
    ULONG    cTmp = 0;

    // while holding the lock, flag each IPID as disconnected so that no
    // more incoming calls are dispatched to this object. We also unchain
    // the IPIDs to ensure that no other threads are pointing at them, and
    // we save off the important fields so we can cleanup while not holding
    // the lock.

    IPIDEntry *pNextIPID = _pFirstIPID;
    while (pNextIPID)
    {
        if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
        {
            // copy fields to temp structure and zero them out in the IPIDEntry
            memcpy(pTmp, (void *)&pNextIPID->dwFlags, sizeof(IPIDTmp));
            memset((void *)&pNextIPID->dwFlags, 0, sizeof(IPIDTmp));

            pNextIPID->dwFlags |= IPIDF_DISCONNECTED | IPIDF_SERVERENTRY;
            pNextIPID->pChnl    = NULL;

            // Since we've disconnected this IPID, release the registration
            // reference on the IID.
            gRIFTbl.ReleaseInterface(pNextIPID->iid);

            pTmp++;
            cTmp++;
        }

        // move ahead to next IPIDEntry
        pNextIPID = pNextIPID->pNextIPID;
    }


    // now release the LOCK since we will be calling into app code to
    // disconnect the stubs, and to release the external connection counts.
    // There should be no other pointers to these IPIDEntries now, so it
    // is safe to muck with their fields (except the dwFlags which is looked
    // at by Dispatch and was already set above).

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    pTmp = pTmpAlloc;
    while (cTmp > 0)
    {
        if (pTmp->dwFlags & IPIDF_NOTIFYACT)
        {
            // the activation code asked to be notified when the refcnt
            // on this interface reaches zero.
            NotifyActivation(FALSE, (IUnknown *)(pTmp->pv));
        }

        if (pTmp->pStub)           // pStub is NULL for IUnknown IPID
        {
            // disconnect the stub
            ComDebOut((DEB_MARSHAL, "Disconnect pStub:%p\n", pTmp->pStub));
            if (pTmp->pv)
            {
                _try
                {
                    ((IUnknown *)pTmp->pv)->Release();
                }
                _except (AppInvokeExceptionFilter(GetExceptionInformation(), pTmp->pv, IID_IUnknown, 2))
                {
                    // Just ignore it and move on...
                    ComDebOut((DEB_MARSHAL | DEB_WARN, "The server at 0x%p threw an exception\n", pTmp->pv));
                }
                
                ((IRpcStubBuffer *)pTmp->pStub)->Disconnect();
            }
            else
            {
                Win4Assert(pTmp->dwFlags & IPIDF_DEACTIVATED);
            }
            pTmp->pStub->Release();
        }

        if (pTmp->cWeakRefs > 0)
        {
            // Release weak references on the StdId.
            _pStdId->DecWeakCnt(TRUE);      // fKeepAlive
        }

        if (pTmp->cStrongRefs > 0)
        {
            // Release strong references on the StdId.
            // 16bit OLE always passed fLastReleaseCloses = FALSE in DisconnectObject. We
            // do the same here. For Rundowns, we pass fLastReleaseCloses = TRUE because we
            // want the object to go away.

            _pStdId->DecStrongCnt(dwType != DISCTYPE_RUNDOWN);    // fKeepAlive
        }

        if (pTmp->cPrivateRefs > 0)
        {
            // Release private references on the StdId.
            // 16bit OLE always passed fLastReleaseCloses = FALSE in DisconnectObject. We
            // do the same here. For Rundowns, we pass fLastReleaseCloses = TRUE because we
            // want the object to go away.

            _pStdId->DecStrongCnt(dwType != DISCTYPE_RUNDOWN);    // fKeepAlive
        }

        if (pTmp->pOXIDEntry)
        {
            // release the refcnt on the OXIDEntry and NULL it
            // This could be NULL here on a failure during the first
            // marshal so we checked that first.
            pTmp->pOXIDEntry->DecRefCnt();
        }

        // move ahead to next temp entry
        pTmp++;
        cTmp--;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    DbgWalkIPIDs();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::DisconnectSrvIPIDs [OUT] this:%p\n",this));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::InstantiatedProxy, public
//
//  Synopsis:   return requested interfaces to the caller if instantiated
//
//  Arguements: [riid]  - interface IID we are looking for
//              [ppv]   - where to return the proxy if found
//              [phr]   - return code
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
BOOL CStdMarshal::InstantiatedProxy(REFIID riid, void **ppv, HRESULT *phr)
{
    ComDebOut((DEB_MARSHAL,
           "CStdMarshal::InstantiatedProxy this:%x riid:%I ppv:%x\n",
            this, &riid, ppv));
    AssertValid();
    Win4Assert(ClientSide());
    Win4Assert(*ppv == NULL);
    Win4Assert(*phr == S_OK);

    BOOL fRet = FALSE;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // look for an existing IPIDEntry for the requested interface
    IPIDEntry *pEntry;
    HRESULT hr = FindIPIDEntryByIID(riid, &pEntry);

    if (SUCCEEDED(hr) && pEntry->pv)
    {
        // found the ipid entry, now extract the interface
        // pointer to return to the caller.

        Win4Assert(IsValidInterface(pEntry->pv));
        *ppv = pEntry->pv;
        fRet = TRUE;
    }
    else if (_cIPIDs == 0)
    {
        // no IPIDEntry for the requested interface, and we have never
        // been connected to the server. Return E_NOINTERFACE in this
        // case. This is different from having been connected then
        // disconnected, where we return CO_E_OBJNOTCONNECTED.

        *phr = E_NOINTERFACE;
        Win4Assert(fRet == FALSE);
    }
    else if (_dwFlags & SMFLAGS_PENDINGDISCONNECT)
    {
        // no IPIDEntry for the requested interface and disconnect is
        // pending, so return an error.

        *phr = CO_E_OBJNOTCONNECTED;
        Win4Assert(fRet == FALSE);
    }
    else
    {
        // no IPIDEntry, we are not disconnected, and we do have other
        // instantiated proxies. QueryMultipleInterfaces expects
        // *phr == S_OK and FALSE returned.

        Win4Assert(*phr == S_OK);
        Win4Assert(fRet == FALSE);
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
      "CStdMarshal::InstantiatedProxy hr:%x pv:%x fRet:%x\n", *phr, *ppv, fRet));
    return fRet;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::QueryRemoteInterfaces, public
//
//  Synopsis:   return requested interfaces to the caller if supported
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::QueryRemoteInterfaces(USHORT cIIDs, IID *pIIDs, SQIResult *pQIRes)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::QueryRemoteInterfaces IN "
               "cIIDs:%d, pIIDs:%I, pQIRes:0x%x\n", cIIDs, pIIDs, pQIRes));

    QICONTEXT *pQIC = (QICONTEXT *) _alloca(QICONTEXT::SIZE(this, cIIDs));
    pQIC->Init(cIIDs);

    Begin_QueryRemoteInterfaces(cIIDs, pIIDs, pQIC);
    HRESULT hr =  Finish_QueryRemoteInterfaces(pQIRes, pQIC);

    ComDebOut((DEB_CHANNEL, "CStdMarshal::QueryRemoteInterfaces OUT hr:0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Begin_QueryRemoteInterfaces
//
//  Synopsis:      Set up for an async remote QI.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
void CStdMarshal::Begin_QueryRemoteInterfaces(USHORT cIIDs, IID *pIIDs, QICONTEXT *pQIC)
{
    ComDebOut((DEB_MARSHAL,
           "CStdMarshal::QueryRemoteInterfaces this:%x pIIDs:%x pQIC:%x\n",
            this, pIIDs, pQIC));
    AssertValid();
    Win4Assert(ClientSide());
    Win4Assert(cIIDs > 0);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    HRESULT hr = PreventDisconnect();

    if (SUCCEEDED(hr))
    {
        // call QI on the remote guy and unmarshal the results
        // NOTE: this will return with the lock released
        ASSERT_LOCK_HELD(gIPIDLock);
        Begin_RemQIAndUnmarshal(cIIDs, pIIDs, pQIC);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }
    else
    {
        // already disconnected
        ASSERT_LOCK_HELD(gIPIDLock);
        UNLOCK(gIPIDLock);
        pQIC->dwFlags |= QIC_DISCONNECTED;
        pQIC->hr = hr;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
 }

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_QueryRemoteInterfaces
//
//  Synopsis:      Complete async remote qi.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_QueryRemoteInterfaces(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    HRESULT hr = S_OK;
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pQIC->dwFlags & QIC_DISCONNECTED)
    {
        // cant call out because we're disconnected so return error for
        // each requested interface.
        for (USHORT i=0; i<pQIC->cIIDs; i++, pQIRes++)
        {
            pQIRes->hr = pQIC->hr;
        }
    }
    else
    {
        // NOTE: this rotine should be entered without a lock and will
        // leave with the lock taken.
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        hr = Finish_RemQIAndUnmarshal(pQIRes, pQIC);
        ASSERT_LOCK_HELD(gIPIDLock);
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // if the object was disconnected while in the middle of the call,
    // then we still return SUCCESS for any interfaces we acquired. The
    // reason is that we do have the proxies, and this matches the
    // behaviour of a QI for an instantiated proxy on a disconnected
    // object.

    hr = HandlePendingDisconnect(hr);

    ComDebOut((DEB_MARSHAL,
       "CStdMarshal::QueryRemoteInterfaces this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::RemQIAndUnmarshal, private
//
//  Synopsis:   call QI on remote guy, then unmarshal the STDOBJREF
//              to create the IPID, and return the interface ptr.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      Caller must guarantee at least one IPIDEntry is connected.
//              This function does a sparse fill of the result array.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemQIAndUnmarshal(USHORT cIIDs, IID *pIIDs, SQIResult *pQIRes)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::RemQIAndUnmarshal IN cIIDs:%d, pIIDs:%I, pQIRes:0x%x\n",
                cIIDs, pIIDs, pQIRes));

    QICONTEXT *pQIC = (QICONTEXT *) PrivMemAlloc(QICONTEXT::SIZE(this, cIIDs));
    pQIC->Init(cIIDs);

    ASSERT_LOCK_HELD(gIPIDLock);
    Begin_RemQIAndUnmarshal(cIIDs, pIIDs, pQIC);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    HRESULT hr = Finish_RemQIAndUnmarshal(pQIRes, pQIC);
    ASSERT_LOCK_HELD(gIPIDLock);

    PrivMemFree(pQIC);

    ComDebOut((DEB_CHANNEL, "CStdMarshal::RemQIAndUnmarshal OUT hr:0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Begin_RemQIAndUnmarshal
//
//  Synopsis:      Dispatch to correct fuction based on aggregation
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
void CStdMarshal::Begin_RemQIAndUnmarshal(USHORT cIIDs, IID *pIIDs, QICONTEXT *pQIC)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    if (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL)
    {
        // remote object uses IRemUnknown2.
        Begin_RemQIAndUnmarshal2(cIIDs, pIIDs, pQIC);
    }
    else
    {
        // remote object uses IRemUnknown
        Begin_RemQIAndUnmarshal1(cIIDs, pIIDs, pQIC);
    }
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_RemQIAndUnmarshal
//
//  Synopsis:      Dispatch to correct fuction based on aggregation
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_RemQIAndUnmarshal(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    if (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL)
    {
        // remote object uses IRemUnknown2.
        hr =  Finish_RemQIAndUnmarshal2(pQIRes, pQIC);
    }
    else
    {
        // remote object uses IRemUnknown.
        hr =  Finish_RemQIAndUnmarshal1(pQIRes, pQIC);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::Begin_RemQIAndUnmarshal1, private
//
//  Synopsis:   call QI on remote guy
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      Caller must guarantee at least one IPIDEntry is connected.
//              This function does a sparse fill of the result array.
//
//              This routine leaves the lock released as a side effect
//
//--------------------------------------------------------------------
void CStdMarshal::Begin_RemQIAndUnmarshal1(USHORT cIIDs, IID *pIIDs, QICONTEXT* pQIC)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::RemQIAndUnmarshal1 this:%x cIIDs:%x pIIDs:%x pQIC:%x\n",
            this, cIIDs, pIIDs, pQIC));
    AssertDisconnectPrevented();
    AssertValid();
    Win4Assert(_pFirstIPID);    // must be at least 1 IPIDEntry
    ASSERT_LOCK_HELD(gIPIDLock);

    // we need an IPID to call RemoteQueryInterface with, any one will
    // do so long as it is connected (in the reconnect case there may be
    // only one connected IPID) so we pick the first one in the chain that
    // is connected.

    IPIDEntry *pIPIDEntry = GetConnectedIPID();
    IPID ipid = pIPIDEntry->ipid;

    // remember what type of reference to get since we yield the lock
    // and cant rely on _dwFlags later.
    BOOL fWeakClient = (_dwFlags & SMFLAGS_WEAKCLIENT);

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // set the IPID according to whether we want strong or weak
    // references. It will only be weak if we are an OLE container
    // and are talking to an embedding running on the same machine.

    if (fWeakClient)
    {
        ipid.Data1    |= IPIDFLAG_WEAKREF;
        pQIC->dwFlags |= QIC_WEAKCLIENT;
    }

    pQIC->pIIDs = pIIDs;
    pQIC->pIPIDEntry = pIPIDEntry;

    // call the remote guy

    IRemUnknown *pRemUnk;
    HRESULT hr = GetSecureRemUnk( &pRemUnk, pIPIDEntry->pOXIDEntry );
    if (SUCCEEDED(hr))
    {
        Win4Assert(pIPIDEntry->pOXIDEntry);     // must have a resolved oxid

        if (pQIC->dwFlags & QIC_ASYNC)
        {
            // call is to be made asyncrounously
            // make the async call out
            hr = pQIC->pARU->Begin_RemQueryInterface(ipid, REM_ADDREF_CNT, cIIDs, pIIDs);
            pQIC->dwFlags |= QIC_BEGINCALLED;
        }
        else
        {
            // call is synchronous
            hr = pRemUnk->RemQueryInterface(ipid, REM_ADDREF_CNT,cIIDs, pIIDs, &(pQIC->pRemQiRes));
        }
    }

    pQIC->hr = hr;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_CHANNEL, "CStdMarshal::Begin_RemQIAndUnmarshal1 OUT hr:0x%x\n", hr));
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_RemQIAndUnmarshal1
//
//  Synopsis:      unmarshal the STDOBJREF to create the IPID, and return
//                 the interface ptr.
//
//  History:       23-Jan-98  MattSmit  Created
//
//  Notes:         This routine leaves the lock taken as a side effect
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_RemQIAndUnmarshal1(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::Finish_RemQIAndUnmarshal1 IN "
               "pQIRes:0x%x, pQIC:0x%x\n", pQIRes, pQIC));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    USHORT cIIDs = pQIC->cIIDs;
    if (pQIC->dwFlags & QIC_STATICMARSHAL)
    {
        if (pQIRes)
        {
            for (USHORT i=0; i<cIIDs; i++)
            {
                pQIRes[i].pv = NULL;
                pQIRes[i].hr = E_PENDING;   // Not E_NOINTERFACE
            }
        }

        LOCK(gIPIDLock);
        return E_PENDING;
    }

    HRESULT hr;

    if ((pQIC->dwFlags & QIC_ASYNC) && (pQIC->dwFlags & QIC_BEGINCALLED))
    {
        // complete async call
        hr = pQIC->pARU->Finish_RemQueryInterface(&(pQIC->pRemQiRes));
        pQIC->pARU = NULL;
    }
    else
    {
        // get results of sync call
        hr = pQIC->hr;
    }


    // need to remember the result ptr so we can free it.
    REMQIRESULT *pRemQiResNext = pQIC->pRemQiRes;

    // unmarshal each STDOBJREF returned. Note that while we did the
    // RemoteQI we could have yielded (or nested) and did another
    // RemoteQI for the same interfaces, so we have to call UnmarshalIPID
    // which will find any existing IPIDEntry and bump its refcnt.

    HRESULT   hr2 = hr;
    HRESULT  *phr = &hr2;
    void     *pv  = NULL;
    void     **ppv = &pv;
    IID      *pIIDs = pQIC->pIIDs;

    for (USHORT i=0; i<cIIDs; i++)
    {
        if (pQIRes)
        {
            // caller wants the pointers returned, set ppv and phr.
            ppv = &pQIRes->pv;
            phr = &pQIRes->hr;
            pQIRes++;
        }

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(pRemQiResNext->hResult))
            {
                if (pQIC->dwFlags & QIC_WEAKCLIENT)
                {
                    // mark the std objref with the weak reference flag so
                    // that UnmarshalIPID adds the references to the correct
                    // count.
                    pRemQiResNext->std.flags |= SORF_P_WEAKREF;
                }

                *ppv = NULL;

                LOCK(gIPIDLock);
                ASSERT_LOCK_HELD(gIPIDLock);

                *phr = UnmarshalIPID(*pIIDs, &pRemQiResNext->std,
                                     pQIC->pIPIDEntry->pOXIDEntry,
                                     (pQIRes) ? ppv : NULL);

                UNLOCK(gIPIDLock);
                ASSERT_LOCK_NOT_HELD(gIPIDLock);

                if (FAILED(*phr))
                {
                    // could not unmarshal, release the resources with the
                    // server.
                    RemoteReleaseStdObjRef(&pRemQiResNext->std,
                                           pQIC->pIPIDEntry->pOXIDEntry);
                }
            }
            else
            {
                // the requested interface was not returned so set the
                // return code and interface ptr.
                *phr = pRemQiResNext->hResult;
                *ppv = NULL;
            }

            pIIDs++;
            pRemQiResNext++;
        }
        else
        {
            // the whole call failed so return the error for each
            // requested interface.
            *phr = hr;
            *ppv = NULL;
        }

        // make sure the ptr value is NULL on failure. It may be NULL or
        // non-NULL on success. (ReconnectProxies wants NULL).
        Win4Assert(SUCCEEDED(*phr) || *ppv == NULL);
    }

    // free the result buffer
    CoTaskMemFree(pQIC->pRemQiRes);

    LOCK(gIPIDLock);
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
               "CStdMarshal::Finish_RemQIAndUnmarshal1 this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::Begin_RemQIAndUnmarshal2, private
//
//  Synopsis:   call QI on remote guy
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      Caller must guarantee at least one IPIDEntry is connected.
//              This function does a sparse fill of the result array.
//
//              This routine leaves the lock released as a side effect
//
//--------------------------------------------------------------------
void CStdMarshal::Begin_RemQIAndUnmarshal2(USHORT cIIDs, IID *pIIDs, QICONTEXT *pQIC)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::RemQIAndUnmarshal2 this:%x cIIDs:%x pIIDs:%x pQIC:%x\n",
            this, cIIDs, pIIDs, pQIC));
    AssertValid();
    AssertDisconnectPrevented();
    Win4Assert(_pFirstIPID);    // must be at least 1 IPIDEntry
    ASSERT_LOCK_HELD(gIPIDLock);

    // we need an IPID to call RemoteQueryInterface with, any one will
    // do so long as it is connected (in the reconnect case there may be
    // only one connected IPID) so we pick the first one in the chain that
    // is connected.

    IPIDEntry *pIPIDEntry = GetConnectedIPID();
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // CODEWORK: we should just replace the IRemUnknown proxy in the
    // OXIDEntry with an IRemUnknown2 proxy, instead of getting a new
    // one for each client object.
    IRemUnknown2 *pRemUnk2;
    HRESULT  hr = GetSecureRemUnk((IRemUnknown **)&pRemUnk2,
                                   pIPIDEntry->pOXIDEntry);

    // we need an IMarshal interface to call UnmarshalInterface on. This
    // must be the outer object's (ie handler's) IMarshal interface.
    IMarshal *pIM = NULL;
    if (SUCCEEDED(hr))
    {
        hr = _pStdId->GetCtrlUnk()->QueryInterface(IID_IMarshal, (void **)&(pQIC->pIM));
    }

    // call the remote guy. Note that we do not worry about or'ing on the
    // weak client bit if we are weak. This would be hard to do for this
    // interface, and it will be taken care of automatically by the calls
    // to UnmarshalInterface, though it will be somewhat less efficient. This
    // should not be a problem though since weakclient is local-only and rare.

    if (SUCCEEDED(hr))
    {
        Win4Assert(pIPIDEntry->pOXIDEntry);     // must have a resolved oxid
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        pQIC->pIIDs = pIIDs;
        pQIC->pIPIDEntry = pIPIDEntry;

        IPID ipid = pIPIDEntry->ipid;
        if (pQIC->dwFlags & QIC_ASYNC)
        {
            // the call is to be made async, so create an async
            // call object for IRemUnkown2
            hr = pQIC->pARU->Begin_RemQueryInterface2(ipid, cIIDs, pIIDs);
            pQIC->dwFlags |= QIC_BEGINCALLED;
        }
        else
        {
            // call is syncrounous
            memset(pQIC->phr, 0, (pQIC->cIIDs * sizeof(HRESULT)));
            memset(pQIC->ppMIFs, 0, (pQIC->cIIDs * sizeof(MInterfacePointer *)));

            hr = pRemUnk2->RemQueryInterface2(ipid, cIIDs, pIIDs, pQIC->phr, pQIC->ppMIFs);
        }
    }

    ComDebOut((DEB_CHANNEL, "CStdMarshal::Begin_RemQIAndUnmarshal2 OUT hr:0x%x\n", hr));
    pQIC->hr = hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_RemQIAndUnmarshal2
//
//  Synopsis:      unmarshal the marshaled interface pointer to create the
//                 IPID, and return the interface ptr.
//
//  History:       23-Jan-98  MattSmit  Created
//
//  Notes:         This routine leaves the lock taken as a side effect
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_RemQIAndUnmarshal2(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::Finish_RemQIAndUnmarshal2 IN "
                "pQIRes:0x%x, pQIC:0x%x\n", pQIRes, pQIC));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    if (pQIC->dwFlags & QIC_ASYNC)
    {
        // complete async call
        memset(pQIC->phr, 0, (pQIC->cIIDs * sizeof(HRESULT)));
        memset(pQIC->ppMIFs, 0, (pQIC->cIIDs * sizeof(MInterfacePointer *)));
        hr = pQIC->pARU->Finish_RemQueryInterface2(pQIC->phr, pQIC->ppMIFs);
        pQIC->pARU = NULL;
    }
    else
    {
        // retreive results of sync call
        hr = pQIC->hr;
    }

    // unmarshal each interface returned. Note that while we did the
    // RemoteQI we could have yielded (or nested) and did another
    // RemoteQI for the same interfaces, so UnmarshalInterface has to
    // deal with duplicates.

    HRESULT   hr2;
    HRESULT  *phr = &hr2;
    void     *pv;
    void     **ppv = &pv;

    for (USHORT i=0; i<pQIC->cIIDs; i++)
    {
        if (pQIRes)
        {
            // caller wants the pointers returned, set ppv and phr.
            ppv = &pQIRes->pv;
            phr = &pQIRes->hr;
            pQIRes++;
        }

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(pQIC->phr[i]))
            {
                // make a stream over the marshaled interface data
                CXmitRpcStream Stm((InterfaceData *)pQIC->ppMIFs[i]);

                // Unmarshal the marshaled interface data.
                *phr = pQIC->pIM->UnmarshalInterface(&Stm, pQIC->pIIDs[i], ppv);

                // free the marshaled interface data
                CoTaskMemFree(pQIC->ppMIFs[i]);

                if (_pStdId->IsAggregated() && SUCCEEDED(*phr))
                {
                    // aggregated by a handler. We need to get the inner interface
                    // (the proxy) since UnmarshalInterface always returns the outer
                    // interface implemented by the handler.
                    void *pv = NULL;
                    InstantiatedProxy(pQIC->pIIDs[i], &pv, phr);
                    Win4Assert(SUCCEEDED(*phr));
                    if (pv != *ppv)
                    {
                        // keep the proxy and release the handler interface
                        ((IUnknown *)pv)->AddRef();
                        ((IUnknown *)*ppv)->Release();
                        *ppv = pv;
                    }
                }
            }
            else if (pQIRes)
            {
                // the requested interface was not returned so set the
                // return code and interface ptr.
                *phr = pQIC->phr[i];
                *ppv = NULL;
            }
        }
        else
        {
            // the whole call failed so return the error for each
            // requested interface.
            *phr = hr;
            *ppv = NULL;
        }

        // make sure the ptr value is NULL on failure. It may be NULL or
        // non-NULL on success. (ReconnectProxies wants NULL).
        Win4Assert(SUCCEEDED(*phr) || *ppv == NULL);
    }

    if (pQIC->pIM)
    {
        // release the IMarshal interface used for unmarshaling
        pQIC->pIM->Release();
    }

    LOCK(gIPIDLock);
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::Finish_RemQIAndUnmarshal2 this:%x hr:%x\n", this, hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::GetAsyncRemUnknown
//
//  Synopsis:      Creates an async RemUnkonwn object for this proxy
//
//  History:       23-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT  CStdMarshal::GetAsyncRemUnknown(IUnknown *pUnkCtl, AsyncIRemUnknown2 **ppARU,
                                         IUnknown **ppUnkInternal)
{
    ComDebOut((DEB_CHANNEL, "CStdMarhsl::GetAsyncRemUnknown IN pUnk:0x%x, ppARU:0x%x, ppUnkInternal:0x%x\n",
               pUnkCtl, ppARU, ppUnkInternal));

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
    IPIDEntry *pIPIDEntry = GetConnectedIPID();
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    IRemUnknown2 *pRemUnk2;
    HRESULT hr = GetSecureRemUnk((IRemUnknown **)&pRemUnk2,
                                 pIPIDEntry->pOXIDEntry);

    if (SUCCEEDED(hr))
    {
        REFIID riid = (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL) ?
                          IID_AsyncIRemUnknown2 :
                          IID_AsyncIRemUnknown;

        hr = GetAsyncCallObject(pRemUnk2, pUnkCtl,
                                riid, riid,
                                ppUnkInternal, (void **)ppARU);
    }

    ComDebOut((DEB_CHANNEL, "GetAsyncRemUnknown OUT hr:0x%x\n", hr));
    return  hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::RemIsConnected, private
//
//  Synopsis:   Returns TRUE if most likely connected, FALSE if definitely
//              not connected or pending disconnect.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
BOOL CStdMarshal::RemIsConnected(void)
{
    AssertValid();
    Assert(ClientSide());

    // the default link depends on us returning FALSE if we are either
    // disconnected or just pending disconnect, in order that they avoid
    // running their cleanup code twice.

    BOOL fRes = (_dwFlags & (SMFLAGS_DISCONNECTED | SMFLAGS_PENDINGDISCONNECT))
                ? FALSE : TRUE;

    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::RemIsConnected this:%x fResult:%x\n", this, fRes));
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Member:     CreateChannel, private
//
//  Synopsis:   Creates an instance of the Rpc Channel.
//
//  History:    20-Feb-95   Rickhi        Created
//              26-Mar-98   GopalK      Agile proxies
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::CreateChannel(OXIDEntry *pOXIDEntry, DWORD dwFlags,
                REFIPID ripid, REFIID riid, CCtxComChnl **ppChnl)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::CreateChannel this:%x\n",this));

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr = S_OK;

    if (pOXIDEntry == NULL)
    {
        // No OXIDEntry supplied, get our local OXID.
        hr = GetLocalOXIDEntry(&pOXIDEntry);
    }

    if (_pChnl == NULL && SUCCEEDED(hr))
    {
        // channel is still NULL, make one...
        DWORD cState = ServerSide() ? server_cs : client_cs;
        cState |= (_pStdId->IsFreeThreaded() || gEnableAgileProxies)
                  ? freethreaded_cs : 0;

        CCtxComChnl *pChnl = new CCtxComChnl(_pStdId, pOXIDEntry, cState);

        if (pChnl)
        {
            if (InterlockedCompareExchangePointer((void**)&_pChnl, pChnl, NULL) != NULL)
            {
                // another thread already did this, just release the channel
                // we created and continue onwards...
                pChnl->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) && ClientSide())
    {
        *ppChnl = _pChnl->Copy(pOXIDEntry, ripid, riid);
        if (*ppChnl == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppChnl = _pChnl;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "CStdMarshal::CreateChannel this:%x hr:%x\n",this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     GetPSFactory, private
//
//  Synopsis:   loads the proxy/stub factory for given IID
//
//  History:    20-Feb-95   Rickhi        Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::GetPSFactory(
    REFIID riid, 
    IUnknown *pUnkWow,
    RIFEntry **ppRIFEntry, 
    IPSFactoryBuffer **ppIPSF, 
    BOOL *pfNonNDR)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::GetPSFactory this:%x riid:%I pUnkWow:%x\n",
         this, &riid, pUnkWow));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // map iid to classid
    CLSID clsid;
    HRESULT hr = gRIFTbl.GetPSClsid(riid, &clsid, ppRIFEntry);
    DWORD actvflags = ACTVFLAGS_NONE;

    if (SUCCEEDED(hr))
    {
        BOOL fWow = FALSE;

        if (IsWOWThread())
        {
            // figure out if this is a custom interface from a 16bit
            // app, since we have to load the 16bit proxy code if so.

            IThunkManager *pThkMgr;
            g_pOleThunkWOW->GetThunkManager(&pThkMgr);
            Win4Assert(pThkMgr && "pUnk in WOW does not support IThunkManager.");

            if (pUnkWow)
                fWow = pThkMgr->IsCustom3216Proxy(pUnkWow, riid);
            else
                fWow = pThkMgr->IsIIDRequested(riid);

            pThkMgr->Release();
        }

        // if we are loading a 16bit custom proxy then mark it as non NDR
        *pfNonNDR = (fWow) ? TRUE : FALSE;

        if (IsEqualGUID(clsid, CLSID_PSOlePrx32))
        {
            // its our internal CLSID so go straight to our class factory.
            hr = ProxyDllGetClassObject(clsid, IID_IPSFactoryBuffer,
                                        (void **)ppIPSF);
        }
        else
        {
            DWORD dwContext = fWow ? CLSCTX_INPROC_SERVER16 : CLSCTX_INPROC_SERVER
                              | CLSCTX_PS_DLL;

            // load the dll and get the PS class object
            hr = ICoGetClassObject(clsid,
                                   dwContext | CLSCTX_NO_CODE_DOWNLOAD,
                                   NULL, IID_IPSFactoryBuffer, actvflags,
                                   (void **)ppIPSF, NULL);
            AssertOutPtrIface(hr, *ppIPSF);
        }
    }

#if DBG==1
    // if the fake NonNDR flag is set and its the test interface, then
    // trick the code into thinking this is a nonNDR proxy. This is to
    // enable simpler testing of an esoteric feature.

    if (gfFakeNonNDR && IsEqualIID(riid, IID_ICube))
    {
        *pfNonNDR = TRUE;
    }
#endif

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
               "CStdMarshal::GetPSFactory this:%x pIPSF:%x fNonNDR:%x hr:%x\n",
               this, *ppIPSF, *pfNonNDR, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CreateProxy, private
//
//  Synopsis:   creates an interface proxy for the given interface
//
//  Returns:    [ppv] - interface of type riid, AddRef'd
//
//  History:    20-Feb-95   Rickhi        Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::CreateProxy(REFIID riid, IRpcProxyBuffer **ppProxy,
                                 void **ppv, BOOL *pfNonNDR)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::CreateProxy this:%x riid:%I\n", this, &riid));
    AssertValid();
    Win4Assert(ClientSide());
    Win4Assert(ppProxy != NULL);
    ASSERT_LOCK_HELD(gIPIDLock);

    // get the controlling IUnknown of this object
    IUnknown *punkCtrl = _pStdId->GetCtrlUnk();
    Win4Assert(punkCtrl != NULL);


    if (InlineIsEqualGUID(riid, IID_IUnknown))
    {
        // there is no proxy for IUnknown so we handle that case here
        punkCtrl->AddRef();
        *ppv      = (void **)punkCtrl;
        *ppProxy  = NULL;
        *pfNonNDR = FALSE;
        return S_OK;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // now construct the proxy for the interface
    IPSFactoryBuffer *pIPSF = NULL;

    RIFEntry *pRIFEntry;
    HRESULT hr = GetPSFactory(riid, NULL, &pRIFEntry, &pIPSF, pfNonNDR);
    if (SUCCEEDED(hr))
    {
        hr = pIPSF->CreateProxy(punkCtrl, riid, ppProxy, ppv);
        AssertOutPtrIface(hr, *ppProxy);
        
        // got the class factory, now create an instance
        if (SUCCEEDED(hr))
        {
            // For proxies, we may as well register the interface now-Sajia
            hr = gRIFTbl.RegisterInterface(riid, FALSE, NULL, pRIFEntry);
        }

        pIPSF->Release();
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::CreateProxy this:%x pProxy:%x pv:%x fNonNDR:%x hr:%x\n",
         this, *ppProxy, *ppv, *pfNonNDR, hr));
    return  hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CreateStub, private
//
//  Synopsis:   creates an interface stub and adds it to the IPID table
//
//  History:    20-Feb-95   Rickhi      Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::CreateStub(REFIID riid, IRpcStubBuffer **ppStub,
                                void **ppv, BOOL *pfNonNDR,
                                IUnknown *pUnkUseInner)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::CreateStub this:%x riid:%I\n", this, &riid));
    AssertValid();
    Win4Assert(ServerSide());
    Win4Assert(ppStub != NULL);
    ASSERT_LOCK_HELD(gIPIDLock);

    // get the IUnknown of the object
    IUnknown *punkObj;
    if (pUnkUseInner)
    {
        // The static marshaller passes its inner unknown if
        // the interface is IMultiQI.  This eliminates the need
        // for the aggregating object expose it.
        punkObj = pUnkUseInner;
    }
    else
    {
        punkObj = _pStdId->GetServer();
    }

    Win4Assert(punkObj != NULL);

    if (InlineIsEqualGUID(riid, IID_IUnknown))
    {
        // there is no stub for IUnknown so we handle that here
        *ppv      = (void *)punkObj;
        *ppStub   = NULL;
        *pfNonNDR = FALSE;
        return S_OK;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // make sure the object supports the given interface, so we dont
    // waste a bunch of effort creating a stub if the interface is
    // not supported.
    IUnknown *pUnkIf = NULL;
    HRESULT hr = punkObj->QueryInterface(riid, (void **)&pUnkIf);
    AssertOutPtrIface(hr, pUnkIf);

    if (SUCCEEDED(hr))
    {
        // now construct the stub for the interface
        IPSFactoryBuffer *pIPSF = NULL;
        RIFEntry *pRIFEntry;
        hr = GetPSFactory(riid, pUnkIf, &pRIFEntry, &pIPSF, pfNonNDR);
        if (SUCCEEDED(hr))
        {
	        // For stubs, create the stub and then register it - Sajia
	        // got the class factory, now create an instance
            //
	        _try
            {
                hr = pIPSF->CreateStub(riid, punkObj, ppStub);
	        }
            _except (AppInvokeExceptionFilter(GetExceptionInformation(), pIPSF, IID_IPSFactoryBuffer, 4))
            {
                ComDebOut((DEB_MARSHAL | DEB_WARN, "CreateStub on 0x%p threw an exception\n", pIPSF));
                hr = RPC_E_SERVERFAULT;
            }

            AssertOutPtrIface(hr, *ppStub);
            pIPSF->Release();
            
            if (SUCCEEDED (hr))
            {
	            hr = gRIFTbl.RegisterInterface(riid, TRUE, *ppStub, pRIFEntry);
            }
        }

        if (SUCCEEDED(hr))
        {
            // remember the interface pointer
            *ppv = (void *)pUnkIf;
        }
        else
        {
            // error, release the interface and return NULL
            pUnkIf->Release();
            *ppv = NULL;
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    ComDebOut((DEB_MARSHAL,
               "CStdMarshal::CreateStub this:%x pStub:%x pv:%x fNonNDR:%x hr:%x\n",
               this, *ppStub, *ppv, *pfNonNDR, hr));

    return  hr;
}

//+-------------------------------------------------------------------
//
//  Member:     FindIPIDEntryByIID, private
//
//  Synopsis:   Finds an IPIDEntry, chained off this object, with the
//              given riid.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FindIPIDEntryByIID(REFIID riid, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_OXID,"CStdMarshal::FindIPIDEntryByIID ppEntry:%x riid:%I\n",
        ppEntry, &riid));
    ASSERT_LOCK_HELD(gIPIDLock);

    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        if (InlineIsEqualGUID(riid, pEntry->iid))
        {
            *ppEntry = pEntry;
            return S_OK;
        }

        pEntry = pEntry->pNextIPID;      // get next entry in object chain
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     FindIPIDEntryByIPID, private
//
//  Synopsis:   returns the IPIDEntry ptr for the given IPID
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FindIPIDEntryByIPID(REFIPID ripid, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_OXID,"CStdMarshal::FindIPIDEntryByIPID ppEntry:%x ripid:%I\n",
        ppEntry, &ripid));
    ASSERT_LOCK_HELD(gIPIDLock);

    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        if (InlineIsEqualGUID(pEntry->ipid, ripid))
        {
            *ppEntry = pEntry;
            return S_OK;
        }

        pEntry = pEntry->pNextIPID;      // get next entry in object chain
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     FindIPIDEntryByInterface, internal
//
//  Synopsis:   returns the IPIDEntry ptr for the given proxy
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FindIPIDEntryByInterface(void *pProxy, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_OXID,"CStdMarshal::FindIPIDEntryByInterface ppEntry:%x pProxy:%x\n",
              ppEntry, pProxy));
    ASSERT_LOCK_HELD(gIPIDLock);

    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        if (pEntry->pv == pProxy)
        {
            *ppEntry = pEntry;
            return S_OK;
        }

        pEntry = pEntry->pNextIPID;     // get next entry in object chain
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     IncSrvIPIDCnt, protected
//
//  Synopsis:   increments the refcnt on the IPID entry, and optionally
//              AddRefs the StdId.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::IncSrvIPIDCnt(IPIDEntry *pEntry, ULONG cRefs,
                                   ULONG cPrivateRefs, SECURITYBINDING *pName,
                                   DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL, "IncSrvIPIDCnt this:%x pIPID:%x cRefs:%x cPrivateRefs:%x\n",
        this, pEntry, cRefs, cPrivateRefs));
    Win4Assert(ServerSide());
    Win4Assert(pEntry);
    Win4Assert(cRefs > 0 || cPrivateRefs > 0);
    ASSERT_LOCK_HELD(gIPIDLock);

    HRESULT hr = S_OK;

    if (cPrivateRefs != 0)
    {
        // Add a reference.
        hr = gSRFTbl.IncRef( cPrivateRefs, pEntry->ipid, pName );

        if (SUCCEEDED(hr))
        {
            BOOL fNotify = (pEntry->cPrivateRefs == 0) ? TRUE : FALSE;
            pEntry->cPrivateRefs += cPrivateRefs;
            if (fNotify)
            {
                // this inc causes the count to go from zero to non-zero, so we
                // inc the strong count on the stdid to hold it alive until this
                // IPID is released.
                IncStrongAndNotifyAct(pEntry, mshlflags);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (mshlflags & MSHLFLAGS_TABLE)
        {
            // Table Marshal Case: inc the number of table marshals.
            IncTableCnt();
        }

        if (mshlflags & (MSHLFLAGS_WEAK | MSHLFLAGS_TABLEWEAK))
        {
            if (pEntry->cWeakRefs == 0)
            {
                // this inc causes the count to go from zero to non-zero, so we
                // AddRef the stdid to hold it alive until this IPID is released.
                _pStdId->IncWeakCnt();
            }
            pEntry->cWeakRefs += cRefs;
        }
        else
        {
            BOOL fNotify = (pEntry->cStrongRefs == 0) ? TRUE : FALSE;
            pEntry->cStrongRefs += cRefs;
            if (fNotify)
            {
                // this inc causes the count to go from zero to non-zero, so we
                // inc the strong count on the stdid to hold it alive until this
                // IPID is released.
                IncStrongAndNotifyAct(pEntry, mshlflags);
            }
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     IncTableCnt, public
//
//  Synopsis:   increments the count of table marshals
//
//  History:    9-Oct-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::IncTableCnt(void)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // If something was marshaled for a table, we have to ignore
    // rundowns until a subsequent RMD is called for it, at which
    // time we start paying attention to rundowns again. Since there
    // can be any number of table marshals, we have to refcnt them.

    _cTableRefs++;
    _dwFlags |= SMFLAGS_IGNORERUNDOWN;
}

//+-------------------------------------------------------------------
//
//  Member:     IncStrongAndNotifyAct, private
//
//  Synopsis:   notifies the activation code when this interface refcnt
//              goes from 0 to non-zero and the activation code asked to be
//              notified, and also increments the strong refcnt.
//
//  History:    21-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::IncStrongAndNotifyAct(IPIDEntry *pEntry, DWORD mshlflags)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // inc the strong count on the stdid to hold it alive until this
    // IPIDEntry is released.

    _pStdId->IncStrongCnt();
    if (mshlflags & MSHLFLAGS_NOTIFYACTIVATION &&
        !(pEntry->dwFlags & IPIDF_NOTIFYACT))
    {
        // the activation code asked to be notified when the refcnt
        // on this interface goes positive, and when it reaches
        // zero again. Set a flag so we remember to notify
        // activation when the strong reference reference count
        // goes back down to zero.
        pEntry->dwFlags |= IPIDF_NOTIFYACT;

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        BOOL fOK = NotifyActivation(TRUE, (IUnknown *)(pEntry->pv));
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        if (!fOK)
        {
            // call failed, so dont bother notifying
            pEntry->dwFlags &= ~IPIDF_NOTIFYACT;
        }
    }
}

//+-------------------------------------------------------------------
//
//  Member:     DecSrvIPIDCnt, protected
//
//  Synopsis:   decrements the refcnt on the IPID entry, and optionally
//              Releases the StdId.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::DecSrvIPIDCnt(IPIDEntry *pEntry, ULONG cRefs,
                                ULONG cPrivateRefs, SECURITYBINDING *pName,
                                DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL, "DecSrvIPIDCnt this:%x pIPID:%x cRefs:%x cPrivateRefs:%x\n",
        this, pEntry, cRefs, cPrivateRefs));
    Win4Assert(ServerSide());
    Win4Assert(pEntry);
    Win4Assert(cRefs > 0 || cPrivateRefs > 0);
    ASSERT_LOCK_HELD(gIPIDLock);

    // Note: we dont care about holding the LOCK over the Release call since
    // the guy who called us is holding a ref to the StdId, so this Release
    // wont cause us to go away.

    if (mshlflags & MSHLFLAGS_TABLE)
    {
        // Table Marshal Case: dec the number of table marshals.
        DecTableCnt();
    }

    if (mshlflags & (MSHLFLAGS_WEAK | MSHLFLAGS_TABLEWEAK))
    {
        Win4Assert(pEntry->cWeakRefs >= cRefs);
        pEntry->cWeakRefs -= cRefs;

        if (pEntry->cWeakRefs == 0)
        {
            // this dec caused the count to go from non-zero to zero, so we
            // Release the stdid since this IPID is no longer holding it alive.
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            _pStdId->DecWeakCnt(TRUE);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }
    }
    else
    {
        // Adjust the strong reference count.  Don't let the caller release
        // too many times.

        if (pEntry->cStrongRefs < cRefs)
        {
            ComDebOut((DEB_WARN,"DecSrvIPIDCnt too many releases. IPID entry: 0x%x   Extra releases: 0x%x",
                       pEntry, cRefs-pEntry->cStrongRefs));
            cRefs = pEntry->cStrongRefs;
        }
        pEntry->cStrongRefs -= cRefs;

        if (pEntry->cStrongRefs == 0 && cRefs != 0)
        {
            // this dec caused the count to go from non-zero to zero, so we
            // dec the strong count on the stdid since the public references
            // on this IPID is no longer hold it alive.

            DecStrongAndNotifyAct(pEntry, mshlflags);
        }

        // Adjust the secure reference count.  Don't let the caller release
        // too many times.

        if (pName != NULL)
        {
            cPrivateRefs = gSRFTbl.DecRef(cPrivateRefs, pEntry->ipid, pName);
        }
        else
        {
            cPrivateRefs = 0;
        }

        Win4Assert( pEntry->cPrivateRefs >= cPrivateRefs );
        pEntry->cPrivateRefs -= cPrivateRefs;

        if (pEntry->cPrivateRefs == 0 && cPrivateRefs != 0)
        {
            // this dec caused the count to go from non-zero to zero, so we
            // dec the strong count on the stdid since the private references
            // on this IPID is no longer hold it alive.

            DecStrongAndNotifyAct(pEntry, mshlflags);
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     DecTableCnt, public
//
//  Synopsis:   decrements the count of table marshals
//
//  History:    9-Oct-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::DecTableCnt(void)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // If something was marshaled for a table, we have to ignore
    // rundowns until a subsequent RMD is called for it, at which
    // time we start paying attention to rundowns again. Since there
    // can be any number of table marshals, we have to refcnt them.
    // This is also used by CoLockObjectExternal.

    if (--_cTableRefs == 0)
    {
        // this was the last table marshal, so now we have to pay
        // attention to rundown from normal clients, so that if all
        // clients go away we cleanup.
        _dwFlags &= ~SMFLAGS_IGNORERUNDOWN;
        
        // Notify the identity object that we are now unpinned
        if (ServerSide())
        {
            CIDObject* pID = GetIDObject();
            
            // Sometimes we do not have an identity object (eg, when
            // we are an internal apt activator).  So don't assume
            // that there is one.
            if (pID)
                pID->NotifyOIDIsUnpinned();
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CStdMarshal::CanRunDown
//
//  Synopsis:   determines if it is OK to rundown this object, based on
//              the current time and the marshaled state of the object.
//
//  Returns:    A value from the OID_RUNDOWN_STATUS enumeration.
//
//  History:    24-Aug-95   Rickhi     Created
//              19-Mar-01   Jsimmons   Modified to return an OID_RUNDOWN_STATUS
//                                     value instead of True\False.
//
//-------------------------------------------------------------------------

// time period of one ping, used to determine if OK to rundown OID
extern DWORD giPingPeriod;

BYTE CStdMarshal::CanRunDown(DWORD iNow)
{
    ASSERT_LOCK_HELD(gComLock);

    if (_dwFlags & SMFLAGS_IGNORERUNDOWN)
    {
        // Stub is currently locked.  Return status code to inform
        // resolver of that.  Notify ID object that we are now pinned.
        Win4Assert(GetIDObject());
        GetIDObject()->NotifyOIDIsPinned();

        return ORS_OID_PINNED;
    }

    // Make sure the interface hasn't been marshalled since it
    // was last pinged. This calculation handles the wrap case.

    // REVIEW:  is it really possible for the resolver to be trying to
    //   run us down while the SMFLAGS_NOPING flag is set?  Should we
    //   assert in that case?
    if (!(_dwFlags & SMFLAGS_NOPING) &&
         (iNow - _dwMarshalTime >= giPingPeriod))
    {
        Win4Assert(_cTableRefs == 0);
        ComDebOut((DEB_MARSHAL, "Running Down Object this:%x\n", this));
        return ORS_OK_TO_RUNDOWN;
    }

    return ORS_DONTRUNDOWN;
}


//+-------------------------------------------------------------------
//
//  Member:     DecStrongAndNotifyAct, private
//
//  Synopsis:   notifies the activation code if this interface has
//              been released and the activation code asked to be
//              notified, and also decrements the strong refcnt.
//
//  History:    21-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::DecStrongAndNotifyAct(IPIDEntry *pEntry, DWORD mshlflags)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    BOOL fNotifyAct = FALSE;

    if ((pEntry->dwFlags & IPIDF_NOTIFYACT) &&
         pEntry->cStrongRefs == 0  &&
         pEntry->cPrivateRefs == 0)
    {
        // the activation code asked to be notified when the refcnt
        // on this interface reaches zero. Turn the flag off so we
        // don't call twice.
        pEntry->dwFlags &= ~IPIDF_NOTIFYACT;
        fNotifyAct = TRUE;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (fNotifyAct)
    {
        NotifyActivation(FALSE, (IUnknown *)(pEntry->pv));
    }

    _pStdId->DecStrongCnt(mshlflags & MSHLFLAGS_KEEPALIVE);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     AddIPIDEntry, private
//
//  Synopsis:   Allocates and fills in an entry in the IPID table.
//              The returned entry is not yet in the IPID chain.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::AddIPIDEntry(OXIDEntry *pOXIDEntry, IPID *pipid,
               REFIID riid, CCtxComChnl *pChnl, IUnknown *pUnkStub,
               void *pv, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_MARSHAL,"AddIPIDEntry this:%x pOXID:%x iid:%I pStub:%x pv:%x\n",
        this, pOXIDEntry, &riid, pUnkStub, pv));
    ASSERT_LOCK_HELD(gIPIDLock);

    // CODEWORK: while we released the lock to create the proxy or stub,
    // the same interface could have been marshaled/unmarshaled. We should
    // go check for duplicates now. This is just an optimization, not a
    // requirement.    

    // get a new entry in the IPID table.
    IPIDEntry *pEntryNew = gIPIDTbl.FirstFree();

    if (pEntryNew == NULL)
    {
        // no free slots and could not allocate more memory to grow
        return E_OUTOFMEMORY;
    }

    if (ServerSide())
    {
        // create an IPID for this entry
        
        // Older methods of generating IPID's were unsecure (could be guessed at 
        // easily).  Now we simply generate a new GUID and overwrite specific 
        // parts with the page entry index.   Because there are only IPIDS_PER_PAGE
        // IPIDEntry's per page there is extra space in the lower word of the index.   
        // So we can keep that extra space (currently 10 bits) filled with randomness 
        // to keep folks guessing just a little bit more.   The second 32 bits are still used
        // to store the pid/tid, since this is too useful for debuggging to get rid of.   This 
        // leaves the lower 64 bits as completely random, plus the 10 random bits in the
        // middle of the page entry index.
        UuidCreate((UUID*)pipid);

        // zero out the bits used by the page entry index
        pipid->Data1  &= ~IPID_PG_INDEX_MASK;

        // store the page entry index
        pipid->Data1 |= gIPIDTbl.GetEntryIndex(pEntryNew);   // IPID table index

        // If the PID or TID would overflow the 16bits we have available to store them we
        // just store USHRT_MAX instead so folks doing debugging don't beat their heads in
        // looking for non-existent processes/threads
        DWORD dwPID = GetCurrentProcessId();
        DWORD dwTID = GetCurrentApartmentId();
        
        pipid->Data2 = (USHORT) (dwPID > USHRT_MAX ? USHRT_MAX : (USHORT)dwPID);
        pipid->Data3 = (USHORT) (dwTID > USHRT_MAX ? USHRT_MAX : (USHORT)dwTID); 
    }

    *ppEntry = pEntryNew;

    pEntryNew->pNextIPID = NULL;
    pEntryNew->pOIDFLink = NULL;
    pEntryNew->pOIDBLink = NULL;
    
    pEntryNew->ipid     = *pipid;
    pEntryNew->iid      = riid;
    pEntryNew->pChnl    = pChnl;
    pEntryNew->pStub    = pUnkStub;
    pEntryNew->pv       = pv;
    pEntryNew->dwFlags  = ServerSide() ? IPIDF_DISCONNECTED | IPIDF_SERVERENTRY
                                       : IPIDF_DISCONNECTED | IPIDF_NOPING;
    pEntryNew->cStrongRefs = 0;
    pEntryNew->cWeakRefs = 0;
    pEntryNew->cPrivateRefs = 0;
    pEntryNew->pOXIDEntry = pOXIDEntry;
    pEntryNew->pIRCEntry = NULL;

    ASSERT_LOCK_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,"AddIPIDEntry this:%x pIPIDEntry:%x ipid:%I\n",
        this, pEntryNew, &pEntryNew->ipid));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     ReleaseAllIPIDEntries, private
//
//  Synopsis:   walks the IPIDEntry list releasing the proxy/stub entries
//              and returning the IPIDEntries to the available pool.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::ReleaseAllIPIDEntries(void)
{
    // Note: we dont need a LOCK around this cause we're in the destructor
    // of this object anyway. There should not be any other pointers to any
    // of these IPIDs, so it is OK to muck with their state.

    // Walk the chain of IPID Entries releasing the proxy/stub pointers.
    // Then, return the chain of IPIDs to the IPIDTable and release all
    // the context entries.

    IPIDEntry *pLastIPID = NULL;
    IPIDEntry *pEntry = _pFirstIPID;

    while (pEntry)
    {
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        // mark the entry as vacant and disconnected. Note we dont put
        // it back in the FreeList yet. We leave it chained to the other
        // IPIDs in the list, and add the whole chain to the FreeList at
        // the end.

        pEntry->dwFlags |= IPIDF_VACANT | IPIDF_DISCONNECTED;

        if (pEntry->pStub)
        {
            // if there is some pStub, then we should be client side, since
            // all the server side stubs are released in DisconnectSrvIPIDs.
            Win4Assert(ClientSide());

            ComDebOut((DEB_MARSHAL,"ReleaseProxy pProxy:%x\n", pEntry->pStub));
            pEntry->pStub->Release();
            pEntry->pStub = NULL;
        }

        pLastIPID = pEntry;
        pEntry = pEntry->pNextIPID;
    }

    if (_pFirstIPID)
    {
        // now take the LOCK and release all the IPIDEntries back into
        // the IPIDTable in one fell swoop.

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        UnchainIPIDEntries(pLastIPID);

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    if (_pCtxEntryHead)
    {
        // release the CtxEntries
        //LOCK(gComLock);
        EnterCriticalSection(&_csCtxEntry);
        CtxEntry::DeleteCtxEntries(_pCtxEntryHead, CTXENTRYFLAG_PRIVLOCKED);
        //UNLOCK(gComLock);
        LeaveCriticalSection(&_csCtxEntry);
        	
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     ReleaseUnusedIPIDEntries, private
//
//  Synopsis:   This routine is called when an OXIDEntry is placed on
//              the expired list.  We release all of the IPIDs except
//              the one representing the primary remote unknown.
//
//  History:    02-Sep-99   Johnstra  Created
//
//--------------------------------------------------------------------
void CStdMarshal::ReleaseUnusedIPIDEntries(void)
{
    ComDebOut((DEB_MARSHAL,"ReleaseCopiedIPIDEntries this:%p\n", this));
    ASSERT_LOCK_HELD(gOXIDLock);

    IPIDEntry* pNextEntry;
    IPIDEntry* pPrevEntry  = NULL;
    IPIDEntry* pEntry      = _pFirstIPID;
    ULONG      cIPIDs      = _cIPIDs;
    ULONG      cReleased   = 0;
    ULONG      cChannels   = 0;

    // Allocate memory to hold arrays of interface pointers so we can Release
    // them after we have released the IPID lock.
    IUnknown** ppEntries = (IUnknown**)PrivMemAlloc(cIPIDs * sizeof(IUnknown*));
    if (NULL == ppEntries)
    {
    	UNLOCK(gOXIDLock);
    	ASSERT_LOCK_NOT_HELD(gOXIDLock);
        return;
    }

    CCtxComChnl** ppChnls = (CCtxComChnl**)PrivMemAlloc(cIPIDs * sizeof(CCtxComChnl*));
    if (NULL == ppChnls)
    {
    	UNLOCK(gOXIDLock);
    	ASSERT_LOCK_NOT_HELD(gOXIDLock);
        PrivMemFree(ppEntries);
        return;
    }


    ComDebOut((DEB_MARSHAL, "   cIPIDs:%x\n", cIPIDs));

    while (pEntry)
    {
        ComDebOut((DEB_MARSHAL,"   pEntry:%p pEntry->iid.Data1:%08X\n", pEntry, pEntry->iid.Data1));

        // Get pointer to the next IPID before we unlink this one.
        pNextEntry = pEntry->pNextIPID;

        if ( !(pEntry->dwFlags & IPIDF_COPY) &&
              (pEntry->iid == IID_IRundown     ||
               pEntry->iid == IID_IRemUnknown  ||
               pEntry->iid == IID_IRemUnknown2 ||
               pEntry->iid == IID_IRemUnknownN))
        {
            // This is the primary remote unknown.  Don't remove it.
            ComDebOut((DEB_MARSHAL,"   Not Releasing pEntry:%p\n", pEntry));
            pPrevEntry = pEntry;
        }
        else
        {
            // Safe to remove this proxy; it's not the primary remote unknown.
            ComDebOut((DEB_MARSHAL,"   Releasing pEntry:%p\n", pEntry));

            // mark the entry as vacant and disconnected.
            pEntry->dwFlags |= IPIDF_VACANT | IPIDF_DISCONNECTED;

            if (pEntry->pStub)
            {
                // if there is a pStub, then we should be client side, since
                // all the server side stubs are released in DisconnectSrvIPIDs.
                Win4Assert(ClientSide());

                if (NULL != pEntry->pv)
                {
                    // AddRef the controlling unknown and release the interface
                    // pointer of the proxy
                    _pStdId->GetCtrlUnk()->AddRef();
                    ((IUnknown *) pEntry->pv)->Release();
                    pEntry->pv = NULL;
                }

                // Disconnect the proxy from channel
                ((IRpcProxyBuffer *)pEntry->pStub)->Disconnect();

                // Save the pointer to the proxy so we can release it after we
                // release the lock.
                ppEntries[cReleased++] = pEntry->pStub;
                pEntry->pStub = NULL;
            }

            if (pEntry->pChnl)
            {
                ppChnls[cChannels++] = pEntry->pChnl;
                pEntry->pChnl = NULL;
            }

            // Unlink the IPIDEntry from the chain.
            if (NULL == pPrevEntry)
                _pFirstIPID = pNextEntry;
            else
                pPrevEntry->pNextIPID = pNextEntry;

            // These IPIDs do not hold a reference to the OXID.  Just
            // NULL the field.
            pEntry->pOXIDEntry = NULL;

            // Release the IPIDEntry back to the IPID table.
            // We should not be releasing the first IPID.
            Win4Assert(pEntry != _pFirstIPID);

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
            gIPIDTbl.ReleaseEntry(pEntry);
            UNLOCK(gIPIDLock);
        }

        // Advance to the next IPIDEntry.
        pEntry = pNextEntry;
    }

    // Adjust the number of IPIDs remaining.
    _cIPIDs -= cReleased;

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // Call Release on all the proxies and channels.
    ULONG i;
    for (i = 0; i < cReleased; i++)
        ppEntries[i]->Release();

    for (i = 0; i < cChannels; i++)
        ppChnls[i]->Release();

    // Delete the memory we allocated.
    PrivMemFree(ppEntries);
    PrivMemFree(ppChnls);
}


void CStdMarshal::ReleaseRemUnkCopy(IRemUnknown* pSecureRemUnk)
{
    ComDebOut((DEB_MARSHAL,"ReleaseRemUnkCopy this:%p pSecureRemUnk:%p\n", this, pSecureRemUnk));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    IPIDEntry*   pEntry      = _pFirstIPID;
    IPIDEntry*   pPrevEntry  = NULL;
    IUnknown*    pProxy      = NULL;
    CCtxComChnl* pChnl       = NULL;

    // Scan list for the IPIDEntry for the supplied remote unknown copy.
    while (pEntry && pEntry->pv != pSecureRemUnk)
    {
        pPrevEntry = pEntry;
        pEntry = pEntry->pNextIPID;
    }

    // If we found the IPIDEntry, release it.
    if (pEntry)
    {
        ComDebOut((DEB_MARSHAL,"   found pSecureRemUnk:%p... removing it\n", pSecureRemUnk));
        Win4Assert((pEntry->dwFlags & IPIDF_COPY) == IPIDF_COPY);

        // mark the entry as vacant and disconnected.
        pEntry->dwFlags |= IPIDF_VACANT | IPIDF_DISCONNECTED;

        if (pEntry->pStub)
        {
            if (NULL != pEntry->pv)
            {
                _try
                {
                    ((IUnknown *) pEntry->pv)->Release();
                }
                _except (AppInvokeExceptionFilter(GetExceptionInformation(), pEntry->pv, IID_IUnknown, 2))
                {
                    // Just ignore it and move on...
                    ComDebOut((DEB_MARSHAL | DEB_WARN, "Server 0x%p threw an exception\n", pEntry->pv));
                }
                pEntry->pv = NULL;
            }

            // Disconnect the proxy from channel
            ((IRpcProxyBuffer *)pEntry->pStub)->Disconnect();

            // Save the proxy so we can release it after we release
            // the lock.
            pProxy = pEntry->pStub;
            pEntry->pStub = NULL;
        }

        // Save the channel so we can release it after we release
        // the lock.
        if (pEntry->pChnl)
        {
            pChnl = pEntry->pChnl;
            pEntry->pChnl = NULL;
        }

        // Unlink the IPIDEntry from the chain.
        if (NULL == pPrevEntry)
            _pFirstIPID = pEntry->pNextIPID;
        else
            pPrevEntry->pNextIPID = pEntry->pNextIPID;

        // This IPID does not hold a reference to the OXID.  Just
        // NULL the field.
        pEntry->pOXIDEntry = NULL;

        // Remove this IPID from the table.
        gIPIDTbl.ReleaseEntry(pEntry);

        // Adjust the number of IPIDs remaining.
        _cIPIDs--;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Call Release on all the proxy and channel.
    if (NULL != pProxy)
        pProxy->Release();

    if (NULL != pChnl)
        pChnl->Release();
}


//+------------------------------------------------------------------------
//
//  Member:     CStdMarshal::LockClient/UnLockClient
//
//  Synopsis:   Locks the client side object during outgoing calls in order
//              to prevent the object going away in a nested disconnect.
//
//  Notes:      UnLockClient is not safe in the freethreaded model.
//              Fortunately pending disconnect can only be set in the
//              apartment model on the client side.
//
//              See als PreventDisconnect / HandlePendingDisconnect.
//
//  History:    12-Jun-95   Rickhi  Created
//
//-------------------------------------------------------------------------
ULONG CStdMarshal::LockClient(void)
{
    Win4Assert(ClientSide());
    InterlockedIncrement(&_cNestedCalls);
    return (_pStdId->GetCtrlUnk())->AddRef();
}

ULONG CStdMarshal::UnlockClient(void)
{
    Win4Assert(ClientSide());
    if ((InterlockedDecrement(&_cNestedCalls) == 0) &&
        (_dwFlags & SMFLAGS_PENDINGDISCONNECT))
    {
        // Decide the type of disconnect
        DWORD dwType = GetPendingDisconnectType();

        // Disconnect from the server object
        Disconnect(dwType);
    }
    Win4Assert(_cNestedCalls != -1);
    return (_pStdId->GetCtrlUnk())->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::GetSecureRemUnk, public
//
//  Synopsis:   If the marshaller has its own remote unknown, use it.
//              Otherwise use the OXID's remote unknown.
//
//  History:    2-Apr-96   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::GetSecureRemUnk( IRemUnknown **ppSecureRemUnk,
                                      OXIDEntry *pOXIDEntry )
{
    ComDebOut((DEB_OXID, "CStdMarshal::GetSecureRemUnk ppRemUnk:%x\n",
               ppSecureRemUnk));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    HRESULT hr = S_OK;

    if (_pSecureRemUnk != NULL)
    {
        // use existing private RemUnknown
        *ppSecureRemUnk = _pSecureRemUnk;
    }
    else
    {
        // go get one from the oxidentry
        hr = pOXIDEntry->GetRemUnk(ppSecureRemUnk);
    }

    return hr;
}

#if DBG==1

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DbgWalkIPIDs
//
//  Synopsis:   Validates that the state of all the IPIDs is consistent.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::DbgWalkIPIDs(void)
{
    LONG       cIPIDs = 0;
    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        ValidateIPIDEntry(pEntry);
        pEntry = pEntry->pNextIPID;
        cIPIDs++;
    }

    Win4Assert( cIPIDs == _cIPIDs );
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::AssertValid
//
//  Synopsis:   Validates that the state of the object is consistent.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::AssertValid()
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gIPIDLock);

    Win4Assert((_dwFlags & ~SMFLAGS_ALL) == 0);
    Win4Assert(_pStdId  != NULL);
    Win4Assert(IsValidInterface(_pStdId));

    if (_pChnl != NULL)
    {
        Win4Assert(IsValidInterface(_pChnl));
        _pChnl->AssertValid(FALSE, FALSE);
    }

    DbgWalkIPIDs();

    UNLOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::AssertDisconnectPrevented, private
//
//  Synopsis:   Just ensures that no disconnects can/have arrived.
//
//  History:    21-Sep-95   Rickhi      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::AssertDisconnectPrevented()
{
    ASSERT_LOCK_DONTCARE(gIPIDLock);
    if (ServerSide())
        Win4Assert(!(_dwFlags & SMFLAGS_DISCONNECTED));
    Win4Assert(_cNestedCalls > 0);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ValidateSTD
//
//  Synopsis:   Ensures that the STDOBJREF is valid
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::ValidateSTD(STDOBJREF *pStd, BOOL fLockHeld)
{
    if (fLockHeld)
        ASSERT_LOCK_HELD(gIPIDLock);
    else
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // validate the flags field
    Win4Assert((pStd->flags & SORF_RSRVD_MBZ) == 0);

    // validate the OID
    OID oid;
    OIDFromMOID(_pStdId->GetOID(), &oid);
    Win4Assert(pStd->oid == oid);

    if (!FTMObject())
    {
        OXIDEntry *pOXIDEntry = NULL;
        if (ServerSide())
        {
            if (fLockHeld)
                UNLOCK(gIPIDLock);

            GetLocalOXIDEntry(&pOXIDEntry);

            if (fLockHeld)
                LOCK(gIPIDLock);
        }
        else if (_pChnl)
        {
            pOXIDEntry = _pChnl->GetOXIDEntry();
        }

        if (pOXIDEntry)
        {
            // validate the OXID
            OXID oxid;
            OXIDFromMOXID(pOXIDEntry->GetMoxid(), &oxid);
            Win4Assert(pStd->oxid == oxid);
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   DbgDumpSTD
//
//  Synopsis:   dumps a formated STDOBJREF to the debugger
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void DbgDumpSTD(STDOBJREF *pStd)
{
    ULARGE_INTEGER *puintOxid = (ULARGE_INTEGER *)&pStd->oxid;
    ULARGE_INTEGER *puintOid  = (ULARGE_INTEGER *)&pStd->oid;

    ComDebOut((DEB_MARSHAL,
        "\n\tpStd:%x   flags:%08x   cPublicRefs:%08x\n\toxid: %08x %08x\n\t oid: %08x %08x\n\tipid:%I\n",
        pStd, pStd->flags, pStd->cPublicRefs, puintOxid->HighPart, puintOxid->LowPart,
        puintOid->HighPart, puintOid->LowPart, &pStd->ipid));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ValidateIPIDEntry
//
//  Synopsis:   Ensures that the IPIDEntry is valid
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::ValidateIPIDEntry(IPIDEntry *pEntry)
{
    // ask the table to validate the IPID entry
    gIPIDTbl.ValidateIPIDEntry(pEntry, ServerSide(), _pChnl);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DbgDumpInterfaceList
//
//  Synopsis:   Prints the list of Interfaces on the object.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::DbgDumpInterfaceList(void)
{
    ComDebOut((DEB_ERROR, "\tInterfaces left on object (0x%x) are:\n", this));
    LOCK(gIPIDLock);

    // walk the IPID list printing the friendly name of each interface
    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        WCHAR wszName[MAX_PATH];
        GetInterfaceName(pEntry->iid, wszName, sizeof(wszName)/sizeof(*wszName));
        ComDebOut((DEB_ERROR,"\t\t %ws\t ipid:%I, cStrongRefs:%x, cWeakRefs:%x\n ",
              wszName, &pEntry->ipid, pEntry->cStrongRefs, pEntry->cWeakRefs));
        pEntry = pEntry->pNextIPID;
    }

    UNLOCK(gIPIDLock);
}
#endif // DBG == 1


//+-------------------------------------------------------------------
//
//  Function:   CStdMarshal::RemoteAddRef, private
//
//  Synopsis:   gets needed references either from the global reference
//              cache or by calling the remote server to AddRef one of
//              its interfaces
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemoteAddRef(IPIDEntry *pIPIDEntry, OXIDEntry *pOXIDEntry,
                                  ULONG cStrongNeed, ULONG cSecureNeed,
                                  BOOL fGiveToCaller)
{
    ComDebOut((DEB_MARSHAL,  "RemoteAddRef this:%x cRefs:%x cSecure:%x ipid:%I\n",
        this, cStrongNeed, cSecureNeed, &pIPIDEntry->ipid));
    ASSERT_LOCK_HELD(gIPIDLock);

    ULONG cStrongRequest = cStrongNeed;
    HRESULT hr = S_OK;

    // if the object does not require pinging, it is also ignoring
    // reference counts, so there is no need to go get more, just
    // pretend like we did.
    if (!(pIPIDEntry->dwFlags & IPIDF_NOPING))
    {
        hr = E_FAIL;
        if (cSecureNeed == 0 && _pRefCache)
        {
            // The caller doesn't want any secure references (which we don't cache)
            // so go ask the Reference cache if it can fullfill our request.
            if (fGiveToCaller)
            {
                // ask for one more ref, we'll give this back below. This ensures
                // that we never give away all of our cached references.
                cStrongRequest += 1;
            }

            hr = _pRefCache->GetSharedRefs(pIPIDEntry, cStrongRequest);
        }

        if (FAILED(hr))
        {
            // could not get the references from the refcache so go ask
            // the remote server.
            cStrongRequest = cStrongNeed;
            if ((cStrongNeed == 1) && !(_dwFlags & SMFLAGS_WEAKCLIENT))
            {
                // may as well get a few extra references than we actually
                // need so we can share them and save some round-trips. Don't
                // do this for weak clients since we don't want a weak client
                // to have any strong references.
                cStrongRequest = REM_ADDREF_CNT;
            }

            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            // get the IRemUnknown for the remote server
            IRemUnknown *pRemUnk;
            hr = GetRemUnk(&pRemUnk, pOXIDEntry);

            if (SUCCEEDED(hr))
            {
                // call RemAddRef on the interface
                REMINTERFACEREF rifRef;
                rifRef.ipid         = pIPIDEntry->ipid;
                rifRef.cPublicRefs  = cStrongRequest;
                rifRef.cPrivateRefs = cSecureNeed;

                HRESULT ignore;
                hr = pRemUnk->RemAddRef(1, &rifRef, &ignore);
            }

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }
    }

    if (SUCCEEDED(hr))
    {
        // store the references in the IPIDEntry
        pIPIDEntry->cPrivateRefs += cSecureNeed;

        if (fGiveToCaller)
            pIPIDEntry->cStrongRefs  += cStrongRequest - cStrongNeed;
        else
            pIPIDEntry->cStrongRefs  += cStrongRequest;

        if (_pRefCache)
        {
            // give any extra references we acquired to the reference
            // cache so they can be used by other apartments in this process.
            _pRefCache->GiveUpRefs(pIPIDEntry);
        }
    }

    ComDebOut((DEB_MARSHAL, "RemoteAddRef hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseRifRef
//
//  Synopsis:   Uses the remote unknown with the correct security
//              blanket and handles release inside async calls.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT RemoteReleaseRifRef(CStdMarshal *pMarshal, OXIDEntry *pOXIDEntry,
                            USHORT cRifRef, REMINTERFACEREF *pRifRef)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "RemoteReleaseRifRef pOXID:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pOXIDEntry, cRifRef, pRifRef, pRifRef->cPublicRefs, &pRifRef->ipid));
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // ensure TLS is intialized on this thread.
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        // get the IRemUnknown for the remote server
        IRemUnknown *pRemUnk;
        if (pMarshal == NULL || (gCapabilities & EOAC_SECURE_REFS))
        {
            hr = pOXIDEntry->GetRemUnk(&pRemUnk);
        }
        else
        {
            hr = pMarshal->GetRemUnk(&pRemUnk, pOXIDEntry);
        }

        if (SUCCEEDED(hr))
        {
            IUnknown *pAsyncRelease = pMarshal ? pMarshal->GetAsyncRelease() : NULL;
            hr = RemoteReleaseRifRefHelper(pRemUnk, pOXIDEntry, cRifRef,
                                           pRifRef, pAsyncRelease);
            if (SUCCEEDED(hr) && pAsyncRelease)
            {
                // zap the object to let the async call object
                // know it doesn't need to call Signal
                pMarshal->SetAsyncRelease(NULL);
            }
        }
    }

    ComDebOut((DEB_MARSHAL, "RemoteReleaseRifRef hr:%x\n", hr));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseRifRefHelper
//
//  Synopsis:   calls the remote server to release some IPIDs
//
//  History:    10-Jul-97    AlexArm      Broke out of RemoteReleaseRifRef.
//
//--------------------------------------------------------------------
HRESULT RemoteReleaseRifRefHelper(IRemUnknown *pRemUnk, OXIDEntry *pOXIDEntry,
                                  USHORT cRifRef, REMINTERFACEREF *pRifRef,
                                  IUnknown *pAsyncRelease)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "RemoteReleaseRifRefHelper pRemUnk:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pRemUnk, cRifRef, pRifRef, pRifRef->cPublicRefs, &pRifRef->ipid));
    Win4Assert(pRemUnk);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    HRESULT hr;

#if DBG==1
    // Each interface ref should have some references to release.
    for (DWORD i = 0; i < cRifRef; i++)
        Win4Assert( pRifRef[i].cPublicRefs+pRifRef[i].cPrivateRefs > 0 );
#endif

    if (IsSTAThread() &&
        FAILED(CanMakeOutCall(CALLCAT_SYNCHRONOUS, IID_IRundown, NULL)))
    {
        // the call control will not let this apartment model thread make
        // the outgoing release call (cause we're inside an InputSync call)
        // so we post ourselves a message to do it later.

        hr = PostReleaseRifRef(pRemUnk, pOXIDEntry, cRifRef, pRifRef, pAsyncRelease);
    }
    else
    {
        if (pAsyncRelease)
        {
            // this call is to be made async, so create an async call object
            AsyncIRemUnknown *pARU;

            hr = pAsyncRelease->QueryInterface(IID_AsyncIRemUnknown, (void **) &pARU);

            if (SUCCEEDED(hr))
            {
                pARU->Begin_RemRelease(cRifRef, pRifRef);
                pARU->Release();
            }
        }
        else
        {
            // call is sync
            hr = pRemUnk->RemRelease(cRifRef, pRifRef);
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "RemoteReleaseRifRefHelper hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   PostReleaseRifRef
//
//  Synopsis:   Post a message to ourself to call RemoteReleaseRifRef later.
//              This is used to make a synchronous remote Release call when
//              a Release is done inside of an InputSync call. The call is
//              delayed until we are out of the InputSync call, since the
//              call control wont allow a synch call inside an inputsync call.
//
//  History:    05-Apr-96   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL PostReleaseRifRef(IRemUnknown *pRemUnk, OXIDEntry *pOXIDEntry,
                           USHORT cRifRef, REMINTERFACEREF *pRifRef,
                           IUnknown *pAsyncRelease)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "PostReleaseRifRef pOXID:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pOXIDEntry, cRifRef, pRifRef, pRifRef->cPublicRefs, &pRifRef->ipid));
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    OXIDEntry *pLocalOXIDEntry = NULL;
    HRESULT hr = GetLocalOXIDEntry(&pLocalOXIDEntry);

    if (SUCCEEDED(hr))
    {
        // allocate a structure to hold the data and copy in the RifRef
        // list, OXIDEntry, and count of entries. Inc the OXID RefCnt to
        // ensure it stays alive until the posted message is processed.

        hr = E_OUTOFMEMORY;
        ULONG cbRifRef = cRifRef * sizeof(REMINTERFACEREF);
        POSTRELRIFREF *pRelRifRef = new(cbRifRef) POSTRELRIFREF;

        if (pRelRifRef)
        {
            pRelRifRef->cRefs = 1;

            hr = S_OK;
            pRemUnk->AddRef();
            if (pAsyncRelease)
            {
                pAsyncRelease->AddRef();
            }
            pOXIDEntry->IncRefCnt();    // keep alive
            pRelRifRef->pOXIDEntry      = pOXIDEntry;
            pRelRifRef->cRifRef         = cRifRef;
            pRelRifRef->pRemUnk         = pRemUnk;
            pRelRifRef->pAsyncRelease   = pAsyncRelease;
            memcpy(&pRelRifRef->arRifRef, pRifRef, cbRifRef);
            
            CComApartment *pTargetApt = pLocalOXIDEntry->GetParentApt();
            hr = pTargetApt->QueueMessage(WM_OLE_ORPC_RELRIFREF, pRelRifRef);
            Win4Assert(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                if (!PostMessage(pLocalOXIDEntry->GetServerHwnd(),
                                 WM_OLE_ORPC_RELRIFREF,
                                 WMSG_MAGIC_VALUE,
                                 (LPARAM)((IMessageParam *)pRelRifRef)))
                {
                    // Post failed, free the structure and report an error.
                    pRemUnk->Release();
                    if (pAsyncRelease)
                    {
                        pAsyncRelease->Release();
                    }
                                        
                    pOXIDEntry->DecRefCnt();
                    hr = RPC_E_SYS_CALL_FAILED;

                    HRESULT hr2 = pTargetApt->RemoveMessage(WM_OLE_ORPC_RELRIFREF, pRelRifRef);
                    if (SUCCEEDED(hr))
                        pRelRifRef->Release();
                }
            }

            pRelRifRef->Release();
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "PostReleaseRifRef hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   HandlePostReleaseRifRef
//
//  Synopsis:   Handles the ReleaseRifRef message that was posted to the
//              current thread (by the current thread) in order to do a
//              delayed remote release call. See PostReleaseRifRef above.
//
//  History:    05-Apr-96   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL HandlePostReleaseRifRef(LPARAM param)
{
    Win4Assert(param);
    ComDebOut((DEB_MARSHAL, "HandlePostReleaseRifRef pRifRef:%x\n", param));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    POSTRELRIFREF *pRelRifRef = (POSTRELRIFREF *)(param);

    // simply make the real remote release call now, then release the
    // reference we have on the OXIDEntry, and free the message buffer.
    // If this call fails, dont try again, otherwise we could spin busy
    // waiting. Instead, just let Rundown clean up the server.        
    RemoteReleaseRifRefHelper(pRelRifRef->pRemUnk,
                              pRelRifRef->pOXIDEntry,
                              pRelRifRef->cRifRef,
                              &pRelRifRef->arRifRef,
                              pRelRifRef->pAsyncRelease);
    
    pRelRifRef->pRemUnk->Release();
    if (pRelRifRef->pAsyncRelease)
    {
        pRelRifRef->pAsyncRelease->Release();
    }
    pRelRifRef->pOXIDEntry->DecRefCnt();    

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "HandlePostReleaseRifRef hr:%x\n", S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     RemoteChangeRef
//
//  Synopsis:   calls the remote server to convert interface refereces
//              from strong to weak or vise versa. This behaviour is
//              required to support silent updates in the OLE container /
//              link / embedding scenarios.
//
//  Notes:      This functionality is not exposed in FreeThreaded apps
//              or in remote apps. The implication being that the container
//              must be on the same machine as the embedding.
//
//  History:    20-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemoteChangeRef(BOOL fLock, BOOL fLastUnlockReleases)
{
    ComDebOut((DEB_MARSHAL, "RemoteChangeRef \n"));
    Win4Assert(ClientSide());
    Win4Assert(IsSTAThread()); // not allowed in MTA Apartment

    // must be at least 1 proxy already connected in order to be able
    // to do this. We cant just ASSERT that's true because we were not
    // holding the lock on entry.

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
    HRESULT hr = PreventDisconnect();

    // A previous version of OLE set the object to weak even it it was
    // currently disconnected, and it remembered that it was weak and set
    // any new interfaces that it later accquired to weak. I emulate that
    // behaviour here.

    if (fLock)
        _dwFlags &= ~SMFLAGS_WEAKCLIENT;
    else
        _dwFlags |= SMFLAGS_WEAKCLIENT;

    if (SUCCEEDED(hr))
    {
        // allocate space to track references to convert
        REMINTERFACEREF *pRifRefAlloc = (REMINTERFACEREF *)
                _alloca(_cIPIDs * sizeof(REMINTERFACEREF) * 2);
        REMINTERFACEREF *pRifRef = pRifRefAlloc;

        // allocate space to track references to release
        USHORT cRelRifRef = 0;
        REMINTERFACEREF *pRelRifRefAlloc = (REMINTERFACEREF *)
                _alloca(_pRefCache->NumIRCs() * 2 * sizeof(REMINTERFACEREF));
        REMINTERFACEREF *pRelRifRef = pRelRifRefAlloc;


        USHORT     cIIDs      = 0;
        DWORD      cSecure    = gCapabilities & EOAC_SECURE_REFS ? 1 : 0;
        OXIDEntry *pOXIDEntry = NULL;
        IPIDEntry *pNextIPID  = _pFirstIPID;

        while (pNextIPID)
        {
            if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
            {
                if (pOXIDEntry == NULL)
                {
                    // This is the first connected IPID we encountered.
                    // Get its OXID entry and make sure it is for a server
                    // process on the current machine.
                    if (!(pNextIPID->pOXIDEntry->IsOnLocalMachine()))
                    {
                        // OXID is for a remote process. Abandon this call.
                        Win4Assert(cIIDs == 0);         // skip call below
                        Win4Assert(pOXIDEntry == NULL); // dont dec below
                        Win4Assert(hr == S_OK);         // report success
                        break;                          // exit while loop
                    }

                    // Remember the OXID and AddRef it to keep it alive
                    // over the duration of the call.
                    pOXIDEntry = pNextIPID->pOXIDEntry;
                    pOXIDEntry->IncRefCnt();
                }

                // save off the data...
                pRifRef->ipid = pNextIPID->ipid;

                if (!fLock)
                {
                    // convert strong refs to weak refs
                    if ((pNextIPID->cStrongRefs == 0) &&
                        (pNextIPID->dwFlags & IPIDF_STRONGREFCACHE))
                    {
                        // we gave all our strong references to the refcache, go
                        // get one of those back now so we can use it to convert
                        // it to weak.
                        if (SUCCEEDED(_pRefCache->GetSharedRefs(pNextIPID, 1)))
                            pNextIPID->cStrongRefs += 1;
                    }

                    if (pNextIPID->cStrongRefs > 0)
                    {
                        pRifRef->cPublicRefs    = pNextIPID->cStrongRefs;
                        pRifRef->cPrivateRefs   = pNextIPID->cPrivateRefs;
                        pNextIPID->cWeakRefs   += pNextIPID->cStrongRefs;
                        pNextIPID->cStrongRefs  = 0;
                        pNextIPID->cPrivateRefs = 0;

                        pRifRef++;
                        cIIDs++;
                    }
                }
                else
                {
                    // convert weak refs to strong refs
                    if (pNextIPID->cStrongRefs == 0)
                    {
                        pRifRef->cPublicRefs    = pNextIPID->cWeakRefs;
                        pRifRef->cPrivateRefs   = cSecure;
                        pNextIPID->cStrongRefs += pNextIPID->cWeakRefs;
                        pNextIPID->cWeakRefs    = 0;
                        pNextIPID->cPrivateRefs = cSecure;

                        pRifRef++;
                        cIIDs++;
                    }
                }

                if (_pRefCache)
                {
                    // get any cached references so we can Release them too
                    _pRefCache->ChangeRef(pNextIPID, fLock, &pRifRef, &cIIDs,
                                          &pRelRifRef, &cRelRifRef);
                }
            }

            // get next IPIDentry for this object
            pNextIPID = pNextIPID->pNextIPID;
        }

        DbgWalkIPIDs();

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        if (cIIDs != 0)
        {
            // we have looped filling in the IPID list, and there are
            // entries in the list. go call the server now.

            if (cRelRifRef)
            {
                // release references the cache was holding on this object
                // that are not being changed
                RemoteReleaseRifRef(this, pOXIDEntry, cRelRifRef, pRelRifRefAlloc);
            }

            // determine the calling flags
            DWORD dwFlags = (fLock) ? IRUF_CONVERTTOSTRONG : IRUF_CONVERTTOWEAK;
            if (fLastUnlockReleases)
                dwFlags |= IRUF_DISCONNECTIFLASTSTRONG;

            // change the references that this client owned
            hr = RemoteChangeRifRef(pOXIDEntry, dwFlags, cIIDs, pRifRefAlloc);
        }

        if (pOXIDEntry)
        {
            // release the OXIDEntry
            pOXIDEntry->DecRefCnt();
        }
    }
    else
    {
        // A previous implementation of OLE returned S_OK if the object was
        // disconnected. I emulate that behaviour here.

        hr = S_OK;
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    // this will handle any Disconnect that came in while we were busy.
    hr = HandlePendingDisconnect(hr);

    ComDebOut((DEB_MARSHAL, "RemoteChangeRef hr:%x\n", hr));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CStdMarshal::RemoteChangeRifRef
//
//  Synopsis:   calls the remote server to release some IPIDs
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemoteChangeRifRef(OXIDEntry *pOXIDEntry, DWORD dwFlags,
                                        USHORT cRifRef, REMINTERFACEREF *pRifRef)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "RemoteChangeRifRef pOXID:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pOXIDEntry, cRifRef, pRifRef, pRifRef->cPublicRefs, &(pRifRef->ipid)));
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // get the IRemUnknown for the remote server
    IRemUnknown *pRemUnk;
    HRESULT hr = GetRemUnk(&pRemUnk, pOXIDEntry);

    if (SUCCEEDED(hr))
    {
        hr = ((IRemUnknownN *)pRemUnk)->RemChangeRef(dwFlags, cRifRef, pRifRef);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "RemoteChangeRifRef hr:%x\n", hr));
    return hr;
}
//+-------------------------------------------------------------------
//
//  Function:   NullOXIDReferencesInIPIDEntries
//
//  Synopsis:   IPIDEntries in _pSecureRemUnk do not reference the OXIDEntry
//              When the OXIDEntry is done with this identity, call this 
//              function to NULL the references in the IPID entries (see 
//              OXIDEntry::ExpireEntry)    
//
//  History:    01-Aug-01   Sajia       Created.
//
//--------------------------------------------------------------------

void CStdMarshal::NullOXIDReferencesInIPIDEntries()
{
   ASSERT_LOCK_NOT_HELD(gIPIDLock);
   LOCK(gIPIDLock);
   
   IPIDEntry*   pEntry = _pFirstIPID;
   while (pEntry)
   {
       pEntry->pOXIDEntry = NULL;
       pEntry = pEntry->pNextIPID;
   }
   UNLOCK(gIPIDLock);
   ASSERT_LOCK_NOT_HELD(gIPIDLock);
}


//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseStdObjRef
//
//  Synopsis:   calls the remote server to release an ObjRef
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL RemoteReleaseStdObjRef(STDOBJREF *pStd, OXIDEntry *pOXIDEntry)
{
    ComDebOut((DEB_MARSHAL, "RemoteReleaseStdObjRef pStd:%x\n pOXIDEntry:%x",
              pStd, pOXIDEntry));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    REMINTERFACEREF rifRef;
    rifRef.ipid         = pStd->ipid;
    rifRef.cPublicRefs  = pStd->cPublicRefs;
    rifRef.cPrivateRefs = 0;

    // incase we get disconnected while in the RemRelease call
    // we need to extract the OXIDEntry and AddRef it.

    pOXIDEntry->IncRefCnt();
    RemoteReleaseRifRef(NULL, pOXIDEntry, 1, &rifRef);
    pOXIDEntry->DecRefCnt();

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "RemoteReleaseStdObjRef hr:%x\n", S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseObjRef
//
//  Synopsis:   calls the remote server to release an ObjRef
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL RemoteReleaseObjRef(OBJREF &objref)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return RemoteReleaseStdObjRef(&ORSTD(objref).std, GetOXIDFromObjRef(objref));
}

//+-------------------------------------------------------------------
//
//  Function:   GetOXIDFromObjRef, private
//
//  Synopsis:   extracts the OXID from the OBJREF.
//
//  History:    09-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
OXIDEntry *GetOXIDFromObjRef(OBJREF &objref)
{
    // TRICK: Internally we use the saResAddr.size field as the ptr
    // to the OXIDEntry. See ReadObjRef and FillObjRef.

    OXIDEntry *pOXIDEntry = (objref.flags & OBJREF_STANDARD)
                          ? *(OXIDEntry **)&ORSTD(objref).saResAddr
                          : (objref.flags & OBJREF_HANDLER)
                            ? *(OXIDEntry **)&ORHDL(objref).saResAddr
                            : *(OXIDEntry **)&OREXT(objref).saResAddr;

    Win4Assert(pOXIDEntry);
    return pOXIDEntry;
}

//+-------------------------------------------------------------------
//
//  Function:   IsValidObjRefHeader, private
//
//  Synopsis:   Ensures the OBJREF is at least semi-valid
//
//  History:    20-Apr-98  Rickhi       Created.
//
//--------------------------------------------------------------------
INTERNAL IsValidObjRefHeader(OBJREF &objref)
{
    if ((objref.signature != OBJREF_SIGNATURE) ||
        (objref.flags & OBJREF_RSRVD_MBZ)      ||
        (objref.flags == 0))
    {
        // the objref signature is bad, or one of the reserved
        // bits in the flags is set, or none of the required bits
        // in the flags is set. the objref cant be interpreted so
        // fail the call.

        return RPC_E_INVALID_OBJREF;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   WriteObjRef, private
//
//  Synopsis:   Writes the objref into the stream
//
//  History:    20-Feb-95  Rickhi       Created.
//
//--------------------------------------------------------------------
INTERNAL WriteObjRef(IStream *pStm, OBJREF &objref, DWORD dwDestCtx)
{
    DUALSTRINGARRAY *psa = NULL;
    MIDEntry *pMIDEntry = NULL;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // The objref types are exclusive.
    // Make sure we detect anybody passing in a bad set of flags.

    DWORD dwTestFlags = objref.flags & (OBJREF_STANDARD | OBJREF_HANDLER | OBJREF_CUSTOM | OBJREF_EXTENDED);
    if (((dwTestFlags & OBJREF_STANDARD) && (dwTestFlags & ~OBJREF_STANDARD)) ||
        ((dwTestFlags & OBJREF_HANDLER)  && (dwTestFlags & ~OBJREF_HANDLER))  ||
        ((dwTestFlags & OBJREF_CUSTOM)   && (dwTestFlags & ~OBJREF_CUSTOM))   ||
        ((dwTestFlags & OBJREF_EXTENDED) && (dwTestFlags & ~OBJREF_EXTENDED)))
    {
        Win4Assert(!"WriteObjRef called with invalid objref flags!");
        return RPC_E_INVALID_OBJREF;
    }

    CObjectContext *pServerCtx = NULL;
    ULONG cbToWrite = (2*sizeof(ULONG)) + sizeof(IID) + sizeof(STDOBJREF);
    if(objref.flags & OBJREF_HANDLER)
    {
        cbToWrite += sizeof(CLSID);
    }

    // write the fixed-sized part of the OBJREF into the stream
    HRESULT hr = pStm->Write(&objref, cbToWrite, NULL);
    if (FAILED (hr)) goto Cleanup;

    if(objref.flags & OBJREF_EXTENDED)
    {
        // There was a slight security hole here, on both 32 and 64 bit,
        // because we could deference arbitrary pointers if we read them
        // out of a malicious objref.
        //
        // For the in-proc marshal case, we'll solve this by writing out the 
        // in-proc marker signature, followed by the process' secret guid 
        // as 'authentication', followed by the actual CObjectContext pointer,
        //
        // -mfeingol 2/28/2002

        pServerCtx = (CObjectContext *) OREXT(objref).pORData;
        Win4Assert(pServerCtx);

        if (dwDestCtx != MSHCTX_INPROC)
        {
            // Write the out of proc signature
            DWORD dwSignature = OUTOFPROC_MARKER_SIGNATURE;
            hr = pStm->Write(&dwSignature, sizeof (DWORD), NULL);
            if (FAILED (hr)) goto Cleanup;
        }
        else
        {
            // Write the inproc signature
            DWORD dwSignature = INPROC_MARKER_SIGNATURE;
            hr = pStm->Write(&dwSignature, sizeof (DWORD), NULL);
            if (FAILED (hr)) goto Cleanup;
           
            // Write the secret process guid
            Win4Assert (gProcessGuid != GUID_NULL);
            hr = pStm->Write(&gProcessGuid, sizeof (gProcessGuid), NULL);
            if (FAILED (hr)) goto Cleanup;

            // Write the pointer
            hr = pStm->Write(&pServerCtx, sizeof (pServerCtx), NULL);
            if (FAILED (hr)) goto Cleanup;
        }
    }


    // write the resolver address into the stream.
    // TRICK: Internally we use the saResAddr.size field as the ptr
    // to the OXIDEntry. See ReadObjRef and FillObjRef.
    
    OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);

    if (!(pOXIDEntry->IsOnLocalMachine()) ||
        dwDestCtx == MSHCTX_DIFFERENTMACHINE)
    {
        // the interface is for a remote server, or it is going to a
        // remote client, therefore, marshal the resolver strings.
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        pMIDEntry = pOXIDEntry->GetMIDEntry();
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        Win4Assert(pMIDEntry);

        if (pMIDEntry)
        {
            // Getpsa returns a raw pointer to a dualstringarray, but it
            // is owned by the midentry which we are keeping alive via
            // the refcount we got from pOXIDEntry->GetMIDEntry above.
            psa = pMIDEntry->Getpsa();
        }

        // PREFix Bug: 
        if (psa == NULL)
            psa = &saNULL;
        else
            Win4Assert(psa->wNumEntries != 0);
    }
    else
    {
        // the interface is for an OXID local to this machine and
        // the interface is not going to a remote client, marshal an
        // empty string (we pay attention to this in ReadObjRef)
        psa = &saNULL;
    }

    // These string bindings always come from the object exporter
    // who has already padded the size to 8 bytes.
    hr = pStm->Write(psa, SASIZE(psa->wNumEntries), NULL);
    if (FAILED (hr)) goto Cleanup;

    // All done with psa.
    psa = NULL;

    ComDebOut((DEB_MARSHAL,"WriteObjRef psa:%x\n", psa));

    if(objref.flags & OBJREF_EXTENDED)
    {
        if((dwDestCtx == MSHCTX_INPROC))// || (dwDestCtx == MSHCTX_CROSSCTX))
        {
            // Addref the server context
            if(OREXT(objref).std.cPublicRefs)
                pServerCtx->InternalAddRef();
        }
        else
        {
            DATAELEMENT *pCtxData = NULL;
            DWORD buffer[2];

            // Obtain context data from server context
            hr = pServerCtx->GetEnvoyData(&pCtxData);

            // Initialize
            buffer[0] = 1;
            if(pCtxData)
                buffer[1] = OUTOFPROC_MARKER_SIGNATURE;
            else
                buffer[1] = NULL;

            // Write objref data
            hr = pStm->Write(buffer, 2*sizeof(DWORD), NULL);
            if (FAILED (hr)) goto Cleanup;

            // Write data elements
            const ULONG ulHdrSize = sizeof(GUID) + 2*sizeof(ULONG);
            if(pCtxData)
            {
                // Write element header
                hr = pStm->Write(pCtxData, ulHdrSize, NULL);
                if (FAILED (hr)) goto Cleanup;
                
                // Write element data
                hr = pStm->Write(pCtxData->Data, pCtxData->cbSize, NULL);
                if (FAILED (hr)) goto Cleanup;
            }
        }

        Win4Assert(pServerCtx);
        OREXT(objref).pORData = (OBJREFDATA *) pServerCtx;
    }

Cleanup:

    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Release the mid entry
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    if (pMIDEntry)
        pMIDEntry->DecRefCnt();
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
	
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ReadObjRefExtension, private
//
//  Synopsis:   Reads the extended objref extension from the stream
//
//  History:    18-Jan-99  Rickhi       Pulled from ReadObjRef.
//
//--------------------------------------------------------------------
INTERNAL ReadObjRefExtension(IStream *pStm, OBJREF &objref)
{
    HRESULT hr = S_OK;

    if (OREXT(objref).pORData == (OBJREFDATA *) OUTOFPROC_MARKER_SIGNATURE)
    {
        // objref has extra data, go get it
        DATAELEMENT dataHdr, *pCtxData;
        ULONG nElms;
        CObjectContext *pServerCtx = NULL;

        // Read number of data elements
        hr = StRead(pStm, &nElms, sizeof(DWORD));
        if(SUCCEEDED(hr) && nElms>0)
        {
            // Allocate space for buffer on the stack
            DWORD *buffer = (DWORD *) _alloca(nElms*sizeof(DWORD));
            Win4Assert(buffer);

            // Read markers
            hr = StRead(pStm, buffer, nElms*sizeof(DWORD));
            if (SUCCEEDED(hr))
            {
                ULONG actualElms = 0;
                for (ULONG i=0; i<nElms; i++)
                {
                    if (buffer[i] == (DWORD) OUTOFPROC_MARKER_SIGNATURE)
                        ++actualElms;
                }

                // Initialize
                Win4Assert(actualElms < 2);
                nElms = actualElms;

                // Allocate buffer to hold element header
                const ULONG ulHdrSize = sizeof(GUID) + 2*sizeof(ULONG);

                // Read data elements
                for (i=0; i<nElms; i++)
                {
                    // Read element header
                    hr = StRead(pStm, &dataHdr, ulHdrSize);
                    if(SUCCEEDED(hr))
                    {
                        // Allocate context data
                        pCtxData = (DATAELEMENT *) PrivMemAlloc(sizeof(DWORD) +
                                                                ulHdrSize +
                                                                dataHdr.cbRounded);
                        if(pCtxData)
                        {
                            // Initialize element header
                            pCtxData = (DATAELEMENT *) (((DWORD *) pCtxData) + 1);
                            pCtxData->dataID = dataHdr.dataID;
                            pCtxData->cbSize = dataHdr.cbSize;
                            pCtxData->cbRounded = dataHdr.cbRounded;

                            // Read element data
                            hr = StRead(pStm, pCtxData->Data, pCtxData->cbSize);
                            if (SUCCEEDED(hr))
                            {
                                // Ignore failures to create server context
                                pServerCtx = CObjectContext::CreateObjectContext(pCtxData,
                                                                                 CONTEXTFLAGS_ENVOYCONTEXT);
                                if (pServerCtx == NULL)
                                    hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }

                    if (FAILED(hr))
                        break;
                }
            }
        }

        // Initialize objref
        OREXT(objref).pORData = (OBJREFDATA *) pServerCtx;
    }
    else if (OREXT(objref).std.cPublicRefs == 0)
    {
        // objref has pointer to a context
        ((CObjectContext *) OREXT(objref).pORData)->InternalAddRef();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ReadObjRef, private
//
//  Synopsis:   Reads the objref from the stream
//
//  History:    20-Feb-95  Rickhi       Created.
//
//--------------------------------------------------------------------
INTERNAL ReadObjRef(IStream *pStm, OBJREF &objref)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // read the signature, flags, and iid fields of the objref so we know
    // what kind of objref we are dealing with and how big it is.

    HRESULT hr = StRead(pStm, &objref, 2*sizeof(ULONG) + sizeof(IID));

    if (SUCCEEDED(hr))
    {
        hr = IsValidObjRefHeader(objref);
        if (FAILED(hr))
        {
            // the OBJREF signature or flags is invalid.
            Win4Assert(!"Invalid ObjRef");
            return hr;
        }

        // compute the size of the remainder of the objref and
        // include the size fields for the resolver string array

        STDOBJREF       *pStd = &ORSTD(objref).std;
        DUALSTRINGARRAY *psa;
        ULONG           cbToRead;

        if (objref.flags & OBJREF_STANDARD)
        {
            cbToRead = sizeof(STDOBJREF) + sizeof(ULONG);
            psa = &ORSTD(objref).saResAddr;
        }
        else if (objref.flags & OBJREF_HANDLER)
        {
            cbToRead = sizeof(STDOBJREF) + sizeof(CLSID) + sizeof(ULONG);
            psa = &ORHDL(objref).saResAddr;
        }
        else if (objref.flags & OBJREF_CUSTOM)
        {
            cbToRead = sizeof(CLSID) + 2*sizeof(DWORD);  // clsid + cbExtension + size
            psa = NULL;
        }
        else if (objref.flags & OBJREF_EXTENDED)
        {
            // We only want to read the STDOBJREF
            cbToRead = sizeof(STDOBJREF);
            psa = &OREXT(objref).saResAddr;
        }
        else
        {
            Win4Assert(!"Invalid Objref");
            return RPC_E_INVALID_OBJREF;
        }

        // read the rest of the fixed sized objref from the stream
        hr = StRead(pStm, pStd, cbToRead);

        // Extended objrefs can have embedded pointers if they come from
        // the same process.  We proceed with caution here...
        if (SUCCEEDED (hr) && (objref.flags & OBJREF_EXTENDED))
        {
            // Read the signature into a DWORD
            DWORD dwSignature;
            hr = StRead(pStm, &dwSignature, sizeof (dwSignature));
            if (SUCCEEDED(hr))
            {
                if (dwSignature == OUTOFPROC_MARKER_SIGNATURE)
                {
                    // Out-of-proc case: turn the pointer into a signature. It won't be used anyway
                    OREXT(objref).pORData = (OBJREFDATA*) OUTOFPROC_MARKER_SIGNATURE;
                }
                else if (dwSignature == INPROC_MARKER_SIGNATURE)
                {
                    // In-proc case: read the process guid, verify it, then read the pointer
                    GUID guidGuess = GUID_NULL;
                    hr = StRead(pStm, &guidGuess, sizeof (guidGuess));
                    if (SUCCEEDED (hr))
                    {
                        Win4Assert (gProcessGuid != GUID_NULL);
                        if (guidGuess == gProcessGuid)
                        {
                            // Read the real pointer
                            hr = StRead(pStm, &OREXT(objref).pORData, sizeof (OREXT(objref).pORData));
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                }

                else
                    hr = E_UNEXPECTED;

                if (SUCCEEDED(hr))
                {
                    // Read in the two USHORT's from the saResAddr that the 32 bit case
                    // has already read into the right place in the struct
                    hr = StRead(pStm, &OREXT(objref).saResAddr, 2*sizeof (USHORT));
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            if (psa != NULL)
            {
                // Non custom interface. Make sure the resolver string array
                // has some sensible values.
                if (psa->wNumEntries != 0 &&
                    psa->wSecurityOffset >= psa->wNumEntries)
                {
                    hr = RPC_E_INVALID_OBJREF;
                }
            }
            else
            {
                // custom marshaled interface
                if (ORCST(objref).cbExtension != 0)
                {
                    // skip past the extensions since we currently dont
                    // know about any extension types.
                    LARGE_INTEGER dlibMove;
                    dlibMove.LowPart = ORCST(objref).cbExtension;
                    dlibMove.HighPart = 0;
                    hr = pStm->Seek(dlibMove, STREAM_SEEK_CUR, NULL);
                }
            }
        }

        if (SUCCEEDED(hr) && psa)
        {
            // Non custom interface. The data that follows is a variable
            // sized string array. Allocate memory for it and then read it.

            DbgDumpSTD(pStd);
            DUALSTRINGARRAY *psaNew = NULL;
            CDualStringArray* pdsaLocalResolver = NULL;

            cbToRead = psa->wNumEntries * sizeof(WCHAR);
            if (cbToRead == 0)
            {
                // server must be local to this machine, just get the local
                // resolver strings and use them to resolve the OXID
                hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
                if (SUCCEEDED(hr))
                    psaNew = pdsaLocalResolver->DSA();
            }
            else
            {
                // allocate space to read the strings
                psaNew = (DUALSTRINGARRAY *) _alloca(cbToRead + sizeof(ULONG));
                if (psaNew != NULL)
                {
                    // update the size fields and read in the rest of the data
                    psaNew->wSecurityOffset = psa->wSecurityOffset;
                    psaNew->wNumEntries = psa->wNumEntries;

                    hr = StRead(pStm, psaNew->aStringArray, cbToRead);
                }
                else
                {
                    psa->wNumEntries     = 0;
                    psa->wSecurityOffset = 0;
                    hr = E_OUTOFMEMORY;

                    // seek the stream past what we should have read, ignore
                    // seek errors, since the OOM takes precedence.

                    LARGE_INTEGER libMove;
                    libMove.LowPart = cbToRead;
                    libMove.HighPart = 0;
                    pStm->Seek(libMove, STREAM_SEEK_CUR, 0);
                }
            }

            // TRICK: internally we want to keep the ObjRef a fixed size
            // structure, even though we have variable sized data. To do
            // this i use the saResAddr.size field of the ObjRef as a ptr
            // to the OXIDEntry. We pay attention to this in FillObjRef,
            // WriteObjRef and FreeObjRef.

            if (SUCCEEDED(hr))
            {
                // resolve the OXID.
                OXIDEntry *pOXIDEntry = NULL;
                hr = gOXIDTbl.ClientResolveOXID(pStd->oxid, psaNew, &pOXIDEntry);
                *((void **) psa) = pOXIDEntry;
            }
            else
            {
                *((void **) psa) = NULL;
            }

            if (pdsaLocalResolver) pdsaLocalResolver->Release();
        }

        if (SUCCEEDED(hr) && (objref.flags & OBJREF_EXTENDED))
        {
            // Read extended objref data
            hr = ReadObjRefExtension(pStm, objref);
            if (FAILED(hr))
            {
                // release the resources already placed in the OBJREF
                // ie the RefCnt on the OXIDEntry.
                FreeObjRef(objref);
            }
        }
    }

    ComDebOut((DEB_MARSHAL,"ReadObjRef hr:%x objref:%x\n", hr, &objref));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FreeObjRef, private
//
//  Synopsis:   Releases an objref that was read in from a stream via
//              ReadObjRef.
//
//  History:    20-Feb-95  Rickhi       Created.
//
//  Notes:      Anybody who calls ReadObjRef should call this guy to
//              free the objref. This decrements the refcnt on the
//              embedded pointer to the OXIDEntry.
//
//--------------------------------------------------------------------
INTERNAL_(void) FreeObjRef(OBJREF &objref)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (objref.flags & (OBJREF_STANDARD | OBJREF_HANDLER | OBJREF_EXTENDED))
    {
        // TRICK: Internally we use the saResAddr.size field as the ptr to
        // the OXIDEntry. See ReadObjRef, WriteObjRef and FillObjRef.

        OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
        Win4Assert(pOXIDEntry);
        pOXIDEntry->DecRefCnt();

        if (objref.flags & OBJREF_EXTENDED)
        {
            // Obtain the server context from objref
            CObjectContext *pServerCtx;
            pServerCtx = (CObjectContext *) OREXT(objref).pORData;
            if (pServerCtx)
                pServerCtx->InternalRelease();
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   MakeFakeObjRef, private
//
//  Synopsis:   Invents an OBJREF that can be unmarshaled in this process.
//              The objref is partially fact (the OXIDEntry) and partially
//              fiction (the OID).
//
//  History:    16-Jan-96   Rickhi      Created.
//
//  Notes:      This is used by MakeSCMProxy and GetRemUnk. Note that
//              the pOXIDEntry is not AddRef'd here because the OBJREF
//              created is only short-lived the callers guarantee it's
//              lifetime, so FreeObjRef need not be called.
//
//--------------------------------------------------------------------
INTERNAL MakeFakeObjRef(OBJREF &objref, OXIDEntry *pOXIDEntry,
                        REFIPID ripid, REFIID riid)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // first, invent an OID since this could fail.
    STDOBJREF *pStd = &ORSTD(objref).std;
    HRESULT hr = gResolver.ServerGetReservedID(&pStd->oid);

    if (SUCCEEDED(hr))
    {
        pStd->flags           = SORF_NOPING | SORF_FREETHREADED ;
        pStd->cPublicRefs     = 1;
        pStd->ipid            = ripid;
        OXIDFromMOXID(pOXIDEntry->GetMoxid(), &pStd->oxid);

        // TRICK: Internally we use the saResAddr.size field as the ptr to
        // the OXIDEntry. See ReadObjRef, WriteObjRef and FillObjRef.

        OXIDEntry **ppOXIDEntry = (OXIDEntry **) &ORSTD(objref).saResAddr;
        *ppOXIDEntry = pOXIDEntry;

        objref.signature = OBJREF_SIGNATURE;
        objref.flags     = OBJREF_STANDARD;
        objref.iid       = riid;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   CompleteObjRef, public
//
//  Synopsis:   Fills in the missing fields of an OBJREF from a STDOBJREF
//              and resolves the OXID. Also sets fLocal to TRUE if the
//              object was marshaled in this apartment.
//
//  History:    22-Jan-96   Rickhi  Created
//
//-------------------------------------------------------------------------
HRESULT CompleteObjRef(OBJREF &objref, OXID_INFO &oxidInfo, REFIID riid, BOOL *pfLocal)
{
    ComDebOut((DEB_MARSHAL, "CompleteObjRef objref:%x oxidInfo:%x\n", &objref, &oxidInfo));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    // tweak the objref so we can call ReleaseMarshalObjRef or UnmarshalObjRef
    objref.signature = OBJREF_SIGNATURE;
    objref.flags     = OBJREF_STANDARD;
    objref.iid       = riid;

    CDualStringArray* pdsaLocalResolver;
    OXIDEntry *pLocalOXIDEntry;
    GetLocalOXIDEntry(&pLocalOXIDEntry);
    MIDEntry *pMIDEntry = pLocalOXIDEntry->GetMIDEntry();
    Win4Assert(pMIDEntry);
    
    hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
    if (SUCCEEDED(hr))
    {
        OXIDEntry *pOXIDEntry = NULL;
        hr = gOXIDTbl.FindOrCreateOXIDEntry(ORSTD(objref).std.oxid,
                                   oxidInfo,
                                   FOCOXID_NOREF,
                                   pdsaLocalResolver->DSA(),
                                   gLocalMid,
                                   pMIDEntry,
                                   0,
                                   NULL,
                                   RPC_C_AUTHN_DEFAULT,  // default is okay since this is a server-side objref
                                   &pOXIDEntry);
        if (SUCCEEDED(hr))
        {
            OXIDEntry **ppOXIDEntry = (OXIDEntry **) &ORSTD(objref).saResAddr;
            *ppOXIDEntry = pOXIDEntry;
            *pfLocal = (pOXIDEntry == pLocalOXIDEntry);
        }
        pdsaLocalResolver->Release();
    }
	
    pMIDEntry->DecRefCnt();

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FindAggStdMarshal, private
//
//  Synopsis:   Finds the CStdMarshal for the OID read from the stream
//
//  Arguements: [objref] - object reference
//              [ppStdMshl] - CStdMarshal returned, AddRef'd
//
//  Algorithm:  Read the objref, get the OID. If we already have an identity
//              for this OID, use that, otherwise either create an identity
//              object, or create a handler (which in turn will create the
//              identity).  The identity inherits CStdMarshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL FindAggStdMarshal(IStream *pStm, IMarshal **ppIM)
{
    ComDebOut((DEB_MARSHAL,
        "FindAggStdMarshal pStm:%x ppIM:%x\n", pStm, ppIM));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    *ppIM = NULL;       // NULL in case of error

    // remember the current stream seek ptr
    ULARGE_INTEGER lSeekCurr;
    LARGE_INTEGER  lSeekStart;
    lSeekStart.LowPart  = 0;
    lSeekStart.HighPart = 0;

    HRESULT hr = pStm->Seek(lSeekStart, STREAM_SEEK_CUR, &lSeekCurr);

    if (SUCCEEDED(hr))
    {
        // read the std objref for the handler
        OBJREF objref;
        hr = ReadObjRef(pStm, objref);

        if (SUCCEEDED(hr))
        {
            // find or create the handler aggregated with the std marshal
            CStdMarshal *pStdMarshal;
            hr = FindStdMarshal(objref, FALSE, &pStdMarshal, FALSE);

            if (SUCCEEDED(hr))
            {
                // tell the std marshaler that it is really an instance of
                // CLSID_AggStdMarshal
                pStdMarshal->SetAggStdMarshal();

                // find the outer object's IMarshal
                hr = pStdMarshal->QueryInterface(IID_IMarshal, (void **)ppIM);
                pStdMarshal->Release();
            }

            // release the objref we read
            FreeObjRef(objref);
        }

        // restore the stream seek ptr
        lSeekStart.LowPart = lSeekCurr.LowPart;
        pStm->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
        "FindAggStdMarshal hr:%x *ppIM:%x\n", hr, *ppIM));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   FindStdMarshal, private
//
//  Synopsis:   Finds the CStdMarshal for the OID read from the stream
//
//  Arguements: [objref] - object reference
//              [fLocal] - TRUE -> should be a local OID so if you don't
//                         find it, then don't bother creating the StdId.
//              [ppStdMshl] - CStdMarshal returned, AddRef'd
//
//  Algorithm:  Read the objref, get the OID. If we already have an identity
//              for this OID, use that, otherwise either create an identity
//              object, or create a handler (which in turn will create the
//              identity).  The identity inherits CStdMarshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//              12-Nov-98   GopalK      Contexts related changes
//
//--------------------------------------------------------------------
INTERNAL FindStdMarshal(OBJREF &objref, BOOL fLocal, CStdMarshal **ppStdMshl, BOOL fLightNA)
{
    ComDebOut((DEB_MARSHAL,
        "FindStdMarshal objref:%x fLocal:%x ppStdMshl:%x\n", &objref, fLocal, ppStdMshl));

    HRESULT hr = IsValidObjRefHeader(objref);
    if (FAILED(hr))
    {
        // OBJREF is garbage
        *ppStdMshl = NULL;
        return hr;
    }

    // Assume not found
    CStdIdentity *pStdId = NULL;
    if (ChkIfLocalOID(objref, &pStdId, fLightNA))
    {
        // Server is in the current apartment
        if (pStdId)
        {
            hr = S_OK;
        }
        else
        {
            hr = CO_E_OBJNOTCONNECTED;
        }
    }
    else if (fLocal == FALSE)
    {
        // Server is in some other apartment.
        STDOBJREF *pStd = &ORSTD(objref).std;
        ComDebOut((DEB_MARSHAL, "poid: %x\n", &pStd->oid));

        OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
        MOID moid;
        MOIDFromOIDAndMID(pStd->oid, pOXIDEntry->GetMid(), &moid);

        CObjectContext *pCurrentCtx = GetCurrentContext();
        CObjectContext *pClientCtx  = NULL;
        CObjectContext *pServerCtx  = NULL;
        CPolicySet     *pPS         = NULL;

        // Eliminate the handler case
        hr = S_OK;
        if(!(objref.flags & OBJREF_HANDLER))
        {
            // Obtain client and server contexts
            if(objref.flags & OBJREF_EXTENDED)
            {
                // Cannot be an FTM aggregated server
                Win4Assert((pStd->flags & SORF_FTM) == 0);

                // Obtain server context from objref
                pServerCtx = (CObjectContext *) OREXT(objref).pORData;
                Win4Assert(pServerCtx);
                pClientCtx = pCurrentCtx;
            }
            else if(pCurrentCtx != GetEmptyContext())
            {
                // Current context is not the empty context
                pClientCtx = pCurrentCtx;
            }

            // Check for non empty client and server contexts
            if(pClientCtx || pServerCtx)
            {
                BOOL fCreate = TRUE;

                // Obtain the policy set between the client context
                // and server context
                hr = ObtainPolicySet(GetCurrentContext(), pServerCtx,
                                     PSFLAG_PROXYSIDE, &fCreate, &pPS);
            }
        }
        else
        {
            // Cannot be an FTM aggregated server
            Win4Assert((pStd->flags & SORF_FTM) == 0);
        }

        // Lookup the identity table for an existing proxy
        if(SUCCEEDED(hr))
        {
            DWORD dwAptId = (pStd->flags & SORF_FTM) ? NTATID : GetCurrentApartmentId();

            // Acquire the lock
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            hr = ObtainStdIDFromOID(moid, dwAptId, TRUE, &pStdId);

            UNLOCK(gComLock);
            if(FAILED(hr))
            {
				if (objref.flags & (OBJREF_STANDARD | OBJREF_EXTENDED))
				{
                    // Create an instance of the identity for this OID. We want
                    // to be holding the lock while we do this since it wont
                    // exercise any app code.
                    DWORD StdIdFlags = ((pStd->flags & SORF_FREETHREADED) || gEnableAgileProxies)
                                     ? STDID_CLIENT | STDID_FREETHREADED
                                     : STDID_CLIENT;

                    StdIdFlags |= (pStd->flags & SORF_FTM) ? STDID_FTM : 0;

                    hr = CreateIdentityHandler(NULL, StdIdFlags, pServerCtx, dwAptId,
                                               IID_IStdIdentity, (void **)&pStdId);
                    AssertOutPtrIface(hr, pStdId);

					if(SUCCEEDED(hr))
					{
						// Now that we've created it, get the lock and either set our new 
						// CStdIdentity in the OID table, or if another thread beat us to it, then
						// use theirs.
						
		                LOCK(gComLock);
		                CStdIdentity *pTempId = NULL;
		                HRESULT hrTemp = ObtainStdIDFromOID(moid, dwAptId, TRUE, &pTempId);
		                if(FAILED(hrTemp))
		                {
							// We are going to use ours, go ahead and set it, and then we are
							// done with the lock.
		                	hr = pStdId->SetOID(moid);
		                	UNLOCK(gComLock);
		                }
		                else
		                {
							// Be sure to release the lock before invoking the CStdIdentity destructor
		                	UNLOCK(gComLock);
		                	pStdId->Release();
		                	pStdId = pTempId;
		                }
					}
                }
                else
                {
                    Win4Assert(objref.flags & OBJREF_HANDLER);
                    Win4Assert(!(ORHDL(objref).std.flags & SORF_FREETHREADED));

                    // create an instance of the handler. the handler will
                    // aggregate in the identity.

                    hr = CreateClientHandler(ORHDL(objref).clsid, moid, dwAptId, &pStdId);
                }

            }

            ASSERT_LOCK_NOT_HELD(gComLock);
        }

        if(SUCCEEDED(hr))
        {
            // COM+ 30306
            // This assertion used to fire in scenarios where we expected an extended objref
            // but we received a standard one.  This can happen with .NET interop (which uses
            // CoMarshalInterface to generate objrefs - without a destctx argument, this will
            // always generate a standard objref) or with down-level interop cases in which
            // non-context-aware DCOM implementations will not generate extended objrefs.
            //
            // Consequently, this assertion was deemed to be overactive
            //
            // Win4Assert(pServerCtx == pStdId->GetServerCtx());

            // Set the policy set
            if (pPS)
                hr = pStdId->SetClientPolicySet(pPS);
        }

        // Cleanup
        if (FAILED(hr))
        {
            if (pStdId)
                pStdId->Release();
            pStdId = NULL;
        }
        if (pPS)
            pPS->Release();
    }
    else
        hr = CO_E_OBJNOTCONNECTED;

    *ppStdMshl = (CStdMarshal *)pStdId;
    AssertOutPtrIface(hr, *ppStdMshl);

    ComDebOut((DEB_MARSHAL,
        "FindStdMarshal pStdMshl:%x hr:%x\n", *ppStdMshl, hr));
    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   StdMarshalObject   Private
//
//  Synopsis:   Standard marshals the specified interface on the given object
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
INTERNAL StdMarshalObject(IStream *pStm, REFIID riid, IUnknown *pUnk,
                          CObjectContext *pServerCtx, DWORD dwDestCtx,
                          void *pvDestCtx, DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL,
               "StdMarshalObject pStm:%x riid:%I pUnk:%x dwDest:%x "
               "pvDest:%x flags:%x\n",
               pStm, &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Figure out what flags to pass.
    DWORD dwFlags = IDLF_CREATE;
    if (!(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        // HACKALERT:
        // If marshaling TABLEWEAK, don't add-then-remove a strong
        // connection, since many objects have a bogus implementation
        // of IExternalConnection that shuts down the object when the
        // last strong count goes to zero regardless of the value of
        // fLastReleaseCloses flag passed in.
        dwFlags |= IDLF_STRONG;
    }

    if (mshlflags & MSHLFLAGS_NOPING)
    {
        // turn off pinging to prevent rundown.
        dwFlags |= IDLF_NOPING;
    }

    if (mshlflags & MSHLFLAGS_AGILE)
    {
        // object is agile
        dwFlags |= IDLF_FTM;
    }

    if (mshlflags & MSHLFLAGS_NO_IEC)
    {
        // don't ask for IExternalConnection
        dwFlags |= IDLF_NOIEC;
    }

    CStdIdentity *pStdId;
    HRESULT hr = ObtainStdIDFromUnk(pUnk, GetCurrentApartmentId(),
                                    pServerCtx, dwFlags, &pStdId);

    if (SUCCEEDED(hr))
    {
        hr = pStdId->MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                      pvDestCtx, mshlflags);

        if (!(mshlflags & MSHLFLAGS_TABLEWEAK))
        {
            // If marshaling succeeded, removing the last strong connection
            // should keep the object alive. If marshaling failed,
            // removing the last strong connection should shut it down.

            BOOL fKeepAlive = (SUCCEEDED(hr)) ? TRUE : FALSE;
            pStdId->DecStrongCnt(fKeepAlive);
        }
        else
        {
            pStdId->Release();
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "StdMarshalObject hr:%x\n", hr));
    return(hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::ServerObjectCallable   Private
//
//  Synopsis:   Computes the need to switch the context to call server object
//              Returns NULL if the object can be called in the current
//              context, otherwise it returns the context of the server.
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CObjectContext *CStdMarshal::ServerObjectCallable()
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::ServerObjectCallable this:%x\n", this));

    // Compute the need to switch
    CObjectContext *pDestCtx = NULL;
    if (ServerSide() && !SystemObject() && !FTMObject() && _pID)
    {
        CObjectContext *pCurrentCtx = GetCurrentContext();
        CObjectContext *pServerCtx  = _pID->GetServerCtx();

        // Compare contexts
        if (pServerCtx != pCurrentCtx)
            pDestCtx = pServerCtx;
    }

    ComDebOut((DEB_MARSHAL, "CStdMarshal::ServerObjectCallable returning 0x%x\n",
               pDestCtx));
    return(pDestCtx);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::SetClientPolicySet   Private
//
//  Synopsis:   Sets the client side policy set.  Basically, add the policy
//              set to our private list of policy sets that can be accessed
//              without taking a global lock.
//
//  History:    24-Feb-98   Gopalk      Created
//              17-Oct-00   JohnDoty    Made bounded, locked
//
//---------------------------------------------------------------------------
HRESULT CStdMarshal::SetClientPolicySet(CPolicySet *pPS)
{
    Win4Assert(ClientSide());
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Enter lock...
    EnterCriticalSection(&_csCtxEntry);

    // Lookup an existing context entry...
    CtxEntry *pEntry = NULL;
    if (_pCtxEntryHead)
    {
        // This will also garbage collect the list and remove dead entries.
        pEntry = CtxEntry::LookupEntry(_pCtxEntryHead, 
                                       pPS->GetClientContext(),
                                       &_pCtxFreeList, 
                                       CTXENTRYFLAG_IDENTRY | CTXENTRYFLAG_PRIVLOCKED);
    }

    // Create a context entry if not found
    if (pEntry == NULL)
    {
        // No entry, add a new one...
        pEntry = CtxEntry::GetFreeEntry(&_pCtxFreeList, CTXENTRYFLAG_PRIVLOCKED);
        if (pEntry == NULL)
        {
            pEntry = new CtxEntry();
            
            if (pEntry)
            {
                pEntry->_pNext = _pCtxEntryHead;
                _pCtxEntryHead = pEntry;
            }
        }
        
        if (pEntry)
        {
            pEntry->_pFree     = NULL;
            pEntry->_cRefs     = 0;
            pEntry->_pPS       = pPS;
            pPS->AddRef();
            
            pEntry->_pLife     = pPS->GetClientContext()->GetLife();
        }
    }

    // Leave lock...
    LeaveCriticalSection(&_csCtxEntry);

    return(pEntry ? S_OK : E_OUTOFMEMORY);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::GetClientPolicySet   Private
//
//  Synopsis:   Gets the client side policy set for the current context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CPolicySet *CStdMarshal::GetClientPolicySet()
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    CPolicySet *pPS = NULL;

    if (_dwFlags & SMFLAGS_CLIENTPOLICYSET)
    {
        COleTls Tls;
        pPS = Tls->pPS;
    }
    else if (_pCtxEntryHead)
    {
        // Try to find the entry in our list... protected by our lock...
        EnterCriticalSection(&_csCtxEntry);
        
        CtxEntry *pEntry = CtxEntry::LookupEntry(_pCtxEntryHead, GetCurrentContext());

        LeaveCriticalSection(&_csCtxEntry);

        // Found it, return it...
        if (pEntry)
            pPS = pEntry->_pPS;
    }

    return(pPS);
}



//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::AllowForegroundTransfer Public
//
//  Synopsis:   Calls AllowSetForegroundWindow for the server PID
//              if it is on the local machine.
//
//  History:    02-Feb-99   MPrabhu     Created
//
//---------------------------------------------------------------------------
HRESULT CStdMarshal::AllowForegroundTransfer(void *lpvReserved)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr=S_OK;

    if (ClientSide())
    {
        LOCK(gIPIDLock);
        IPIDEntry *pIPID = GetConnectedIPID();
        UNLOCK(gIPIDLock);
        if (pIPID)
        {
            if (pIPID->pOXIDEntry->IsOnLocalMachine())
            {
                if (!AllowSetForegroundWindow(pIPID->pOXIDEntry->GetPid()))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = CO_E_OBJNOTCONNECTED;
        }

    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::RegisterForDisconnect Public
//
//  Synopsis:   Adds the provided interface to our list of objects to notify
//              when we get disconnected.
//
//  History:    08-Mar-02   JohnDoty    Created
//
//---------------------------------------------------------------------------
HRESULT CStdMarshal::RegisterForDisconnect(IDisconnectSink *pSink,
                                           void *pvSinkCookie,
                                           void **ppvRegCookie)
{   
    Win4Assert(ServerSide());
    if (!ServerSide()) // Only supported for stubs, not for proxies!
        return E_UNEXPECTED;

    Win4Assert(!NotConnected());
    if (NotConnected()) // We aren't connected now, so why are you asking?
        return E_UNEXPECTED;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr = E_OUTOFMEMORY;
    DiscSinkNode *pNewNode = new DiscSinkNode;
    if (pNewNode != NULL)
    {
        pNewNode->pvCookie = pvSinkCookie;
        pNewNode->pSink    = pSink;
        pSink->AddRef();

        LOCK(gIPIDLock);
        pNewNode->pNext = _discHead.pNext;
        pNewNode->pNext->pPrev = pNewNode;

        _discHead.pNext = pNewNode;
        pNewNode->pPrev = &_discHead;

        UNLOCK(gIPIDLock);

        *ppvRegCookie = pNewNode;
        
        hr = S_OK;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::UnregisterForDisconnect Private
//
//  Synopsis:   Remove a previously registered notification for disconnect.
//
//  History:    09-Mar-02   JohnDoty    Created
//
//---------------------------------------------------------------------------
HRESULT CStdMarshal::UnregisterForDisconnect(void *pvDiscCookie)
{
    DiscSinkNode *pNode = (DiscSinkNode *)pvDiscCookie;
    if (pNode == NULL)
        return E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Unlink the node.  Nobody can find us now.
    pNode->pNext->pPrev = pNode->pPrev;
    pNode->pPrev->pNext = pNode->pNext;

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Now, if we actually have a reference to somebody,
    // then release it.
    if (pNode->pSink)
        pNode->pSink->Release();

    // And now we can free the node.
    delete pNode;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::NotifyDisconnect Private
//
//  Synopsis:   Notify everybody who cares that we've been disconnected.  
//              This also unregisters them.
//
//  History:    08-Mar-02   JohnDoty    Created
//
//---------------------------------------------------------------------------
void CStdMarshal::NotifyDisconnect()
{   
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Iterate the list....
    DiscSinkNode *pNode = _discHead.pNext;    
    while (pNode != &_discHead)
    {
        // Unlink the node...
        pNode->pNext->pPrev = pNode->pPrev;
        pNode->pPrev->pNext = pNode->pNext;

        pNode->pNext = pNode;
        pNode->pPrev = pNode;
        
        // Grab and null the other fields...
        IDisconnectSink *pSink = pNode->pSink;
        void *pvSinkCookie     = pNode->pvCookie;
                
        pNode->pSink  = NULL;

        // Release the lock and notify the person who cares.
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        pSink->OnDisconnect(pvSinkCookie);
        pSink->Release();

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);
        
        // Since anything might have happened while we released
        // the lock, we need to get the next pointer straight
        // from the head of the list.
        pNode = _discHead.pNext;
    }
   
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
}

//---------------------------------------------------------------------------
//
//  Function:   CoRegisterDisconnectCallback
//
//  Synopsis:   Register for a notification, when the stub for punk is 
//              disconnected.
//
//  History:    09-Mar-02   JohnDoty    Created
//
//---------------------------------------------------------------------------
HRESULT CoRegisterDisconnectCallback(IUnknown *punk, 
                                     DWORD dwMarshalFlags,
                                     IDisconnectSink *pSink,
                                     void *pvSinkCookie,
                                     void **ppvRegisterCookie)
{
    // Step 1: Find the StdMarshal for this unk.

    IMarshal *pMarshal;
    HRESULT hr = CoGetStandardMarshal(IID_IUnknown, 
                                      punk,                                       
                                      MSHCTX_NOSHAREDMEM, // Marshal context doesn't matter, does it?
                                      NULL,
                                      dwMarshalFlags,
                                      &pMarshal);
    if (SUCCEEDED(hr))
    {
        // Great.  Step 2: Get a CStdIdentity.
        CStdIdentity *pStdId;
        hr = pMarshal->QueryInterface(IID_IStdIdentity, (void **)&pStdId);
        if (SUCCEEDED(hr))
        {
            // Groovy.  Step 3: Register the callback.
            hr = pStdId->RegisterForDisconnect(pSink, pvSinkCookie, ppvRegisterCookie);
            pStdId->Release();
        }
     
        pMarshal->Release();
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   CoUnregisterDisconnectCallback
//
//  Synopsis:   Unregister for a disconnect notification.
//
//  History:    09-Mar-02   JohnDoty    Created
//
//---------------------------------------------------------------------------
HRESULT CoUnregisterDisconnectCallback(void *pvDiscCookie)
{
    return CStdMarshal::UnregisterForDisconnect(pvDiscCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\orpc_dbg.c ===
//--------------------------------------------------------------------------
// ORPC_DBG.C (tabs 4)
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
//          SEND MAIL TO SANJAYS  IF YOU MODIFY THIS FILE!
//            WE MUST KEEP OLE AND LANGUAGES IN SYNC!
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
// Created 08-Oct-1993 by Mike Morearty.  The master copy of this file
// is in the LANGAPI project owned by the Languages group.
//
// Helper functions for OLE RPC debugging.
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>

#include "orpc_dbg.h"

static TCHAR tszAeDebugName[] = TEXT("AeDebug");
static TCHAR tszAutoName[] = TEXT("Auto");
static TCHAR tszOldAutoName[] = TEXT("OldAuto");
static TCHAR tszDebugObjectRpcEnabledName[] =
	TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\DebugObjectRPCEnabled");

// Emit the ORPC signature into the bytestream of the function
#define ORPC_EMIT_SIGNATURE()	'M', 'A', 'R', 'B',

// Emit a LONG into the bytestream
#define ORPC_EMIT_LONG(l)	\
	((l >>  0) & 0xFF),		\
	((l >>  8) & 0xFF),		\
	((l >> 16) & 0xFF),		\
	((l >> 24) & 0xFF),

// Emit a WORD into the bytestream
#define ORPC_EMIT_WORD(w)	\
	((w >> 0) & 0xFF),		\
	((w >> 8) & 0xFF),

// Emit a BYTE into the bytestream
#define ORPC_EMIT_BYTE(b)	\
	b,

// Emit a GUID into the bytestream
#define ORPC_EMIT_GUID(l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)	\
	ORPC_EMIT_LONG(l)												\
	ORPC_EMIT_WORD(w1) ORPC_EMIT_WORD(w2)							\
	ORPC_EMIT_BYTE(b1) ORPC_EMIT_BYTE(b2)							\
	ORPC_EMIT_BYTE(b3) ORPC_EMIT_BYTE(b4)							\
	ORPC_EMIT_BYTE(b5) ORPC_EMIT_BYTE(b6)							\
	ORPC_EMIT_BYTE(b7) ORPC_EMIT_BYTE(b8)

BYTE rgbClientGetBufferSizeSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x9ED14F80, 0x9673, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbClientFillBufferSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0xDA45F3E0, 0x9673, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbClientNotifySignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x4F60E540, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbServerNotifySignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x1084FA00, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbServerGetBufferSizeSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x22080240, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbServerFillBufferSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x2FC09500, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

// Macro to deal with assigning refiid for both C and C++.
#if defined(__cplusplus)
#define ASSIGN_REFIID(orpc_all, iid)	((orpc_all).refiid = &iid)
#else
#define ASSIGN_REFIID(orpc_all, iid)	((orpc_all).refiid = iid)
#endif

#pragma code_seg(".orpc")

//--------------------------------------------------------------------------
// SzSubStr()
//
// Find str2 in str2
//--------------------------------------------------------------------------

static LPTSTR SzSubStr(LPTSTR str1, LPTSTR str2)
{
	CharLower(str1);

	return _tcsstr(str1, str2);
}

//--------------------------------------------------------------------------
// DebugORPCSetAuto()
//
// Sets the "Auto" value in the "AeDebug" key to "1", and saves info
// necessary to restore the previous value later.
//--------------------------------------------------------------------------

BOOL WINAPI DebugORPCSetAuto(VOID)
{
	HKEY	hkey;
	TCHAR	rgtchDebugger[256];	// 256 is the length NT itself uses for this
	TCHAR	rgtchAuto[256];
	TCHAR	rgtchOldAuto[2];	// don't need to get the whole thing

	// If the "DebugObjectRPCEnabled" key does not exist, then do not
	// cause any notifications
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, tszDebugObjectRpcEnabledName, 0, KEY_READ, &hkey))
		return FALSE;
	RegCloseKey(hkey);

	// If the AeDebug debugger string does not exist, or if it contains
	// "drwtsn32" anywhere in it, then don't cause any notifications,
	// because Dr. Watson is not capable of fielding OLE notifications.
	if (!GetProfileString(tszAeDebugName, TEXT("Debugger"), TEXT(""),
			rgtchDebugger, sizeof(rgtchDebugger) / sizeof(TCHAR)) ||
		SzSubStr(rgtchDebugger, TEXT("drwtsn32")) != NULL)
	{
		return FALSE;
	}

	// Must ensure that the "Auto" value in the AeDebug registry key
	// is set to "1", so that the embedded INT 3 below will cause the
	// debugger to be automatically spawned if it doesn't already
	// exist.

	// Get old "Auto" value
	GetProfileString(tszAeDebugName, tszAutoName, TEXT(""),
		rgtchAuto, sizeof(rgtchAuto) / sizeof(TCHAR));

    //
    // NT bug 467513: Power users can run debuggers but don't have 
    // rights to write to the aedebug key -- this blocks them from 
    // doing ole-rpc (cross-process) debugging in Visual Studio.  To 
    // workaround this, we tolerate access-denied errors.   Things 
    // will work as expected if the Auto key is already set to "1", if 
    // not the user will get an exception dialog on which they can then
    // hit cancel to bring up the server debugger.   (VS team said 
    // this was preferrable to it not working at all).
    //
    // If we don't have rights to write to the key, then we won't have
    // rights to restore it either in DebugORPCRestoreAuto -- I left that
    // code alone though.
    //

    // If "OldAuto" already existed, then it's probably left over from
    // a previous invocation of the debugger, so don't overwrite it.
    // Otherwise, copy "Auto" value to "OldAuto"
    if (!GetProfileString(tszAeDebugName, tszOldAutoName, TEXT(""),
        rgtchOldAuto, sizeof(rgtchOldAuto) / sizeof(TCHAR)))
    {
        if (!WriteProfileString(tszAeDebugName, tszOldAutoName, rgtchAuto))
        {
            if (ERROR_ACCESS_DENIED == GetLastError())
            {
                return TRUE;
            }
            return FALSE;
        }
    }

    // Change "Auto" value to "1"
    if (!WriteProfileString(tszAeDebugName, tszAutoName, TEXT("1")))
    {
        if (ERROR_ACCESS_DENIED == GetLas