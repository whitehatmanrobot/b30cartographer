AR* plWidth, LONG FAR* plHeight)
{
    VDATEHEAP();

    #define HIMET_PER_METER     100000L  // number of HIMETRIC units / meter

    if (!(lpbmi->biXPelsPerMeter && lpbmi->biYPelsPerMeter))
    {
	HDC hdc;
	hdc = GetDC(NULL);
	
	if(!hdc)
	{
		*plWidth = 0;
		*plHeight = 0;
		return;
	}

	lpbmi->biXPelsPerMeter = MulDiv(GetDeviceCaps(hdc, LOGPIXELSX),
			10000, 254);
	lpbmi->biYPelsPerMeter = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY),
			10000, 254);

	ReleaseDC(NULL, hdc);
    }

    *plWidth = (lpbmi->biWidth * HIMET_PER_METER / lpbmi->biXPelsPerMeter);
    *plHeight= (lpbmi->biHeight * HIMET_PER_METER / lpbmi->biYPelsPerMeter);

    // no longer need this
    #undef HIMET_PER_METER
    
}


#pragma SEG(UtGetClassID)
FARINTERNAL_(BOOL) UtGetClassID(LPUNKNOWN lpUnk, CLSID FAR* lpClsid)
{
	VDATEHEAP();

	LPOLEOBJECT lpOleObj; // IOleObject pointer
	LPPERSIST lpPersist; // IPersist pointer

	// try to ask it as an object
	if (lpUnk->QueryInterface(IID_IOleObject,
			(LPLPVOID)&lpOleObj) == NOERROR)
	{
		lpOleObj->GetUserClassID(lpClsid);
		lpOleObj->Release();
		return(TRUE);
	}       
	
	// try to ask it as a persistent object
	if (lpUnk->QueryInterface(IID_IPersist,
			(LPLPVOID)&lpPersist) == NOERROR)
	{
		lpPersist->GetClassID(lpClsid);
		lpPersist->Release();
		return(TRUE);
	}
	
	*lpClsid = CLSID_NULL;
	return(FALSE);
}


#pragma SEG(UtGetIconData)
FARINTERNAL UtGetIconData(LPDATAOBJECT lpSrcDataObj, REFCLSID rclsid,
		LPFORMATETC lpforetc, LPSTGMEDIUM lpstgmed)
{
	VDATEHEAP();

	CLSID clsid = rclsid;
	
	lpstgmed->tymed = TYMED_NULL;
	lpstgmed->pUnkForRelease = NULL;
	lpstgmed->hGlobal = NULL;
		
	if (lpSrcDataObj)
	{
	    if (lpSrcDataObj->GetData(lpforetc, lpstgmed) == NOERROR)
		    return NOERROR;
	    
	    if (IsEqualCLSID(clsid, CLSID_NULL))
		    UtGetClassID(lpSrcDataObj, &clsid);
	}
	
	// get data from registration database
	lpstgmed->hGlobal = OleGetIconOfClass(clsid, NULL, TRUE);
		
	if (lpstgmed->hGlobal == NULL)
	    return ResultFromScode(E_OUTOFMEMORY);
	else
	    lpstgmed->tymed = TYMED_MFPICT;

	return NOERROR;
}               



// Performs operation like COPY, MOVE, REMOVE etc.. on src, dst storages. The
// caller can specifiy which streams to be operated upon through
// grfAllowedStreams parameter.

STDAPI UtDoStreamOperation(LPSTORAGE pstgSrc, LPSTORAGE pstgDst, int iOpCode,
		DWORD grfAllowedStmTypes)
{
	VDATEHEAP();

	HRESULT error; // error status so far
	IEnumSTATSTG FAR* penumStg; // used to enumerate the storage elements
	ULONG celtFetched; // how many storage elements were fetched
	STATSTG statstg;
		
	// get an enumerator over the source storage
	if (error = pstgSrc->EnumElements(NULL, NULL, NULL, &penumStg))
		return error;
	
	// repeat for every storage
	while(penumStg->Next(1, &statstg, &celtFetched) == NOERROR)
	{
		
		// operate on streams that we're interested in
		if (statstg.type == STGTY_STREAM)
		{
			DWORD stmType;
			
			// find the type of the stream
			// REVIEW, we must have constants for these name
			// prefixes!!!
			switch (statstg.pwcsName[0])
			{
			case '\1':
				stmType = STREAMTYPE_CONTROL;
				break;
				
			case '\2':
				stmType = STREAMTYPE_CACHE;
				break;
				
			case '\3':
				stmType = STREAMTYPE_CONTAINER;
				break;
				
			default:
				stmType = (DWORD)STREAMTYPE_OTHER;
			}
			

			// check whether it should be operated upon
			if (stmType & grfAllowedStmTypes)
			{
				switch(iOpCode)
				{
#ifdef LATER                                    
				case OPCODE_COPY:
					pstgDst->DestroyElement(
							statstg.pwcsName);
					error = pstgSrc->MoveElementTo(
							statstg.pwcsName,
							pstgDst,
							statstg.pwcsName,
							STGMOVE_COPY);
					break;

				case OPCODE_MOVE:
					pstgDst->DestroyElement(
							statstg.pwcsName);
					error = pstgSrc->MoveElementTo(
							statstg.pwcsName,
							pstgDst,
							statstg.pwcsName,
							STGMOVE_MOVE);
					break;

				case OPCODE_EXCLUDEFROMCOPY:
					AssertSz(FALSE, "Not yet implemented");
					break;
					
#endif // LATER
				case OPCODE_REMOVE:
					error = pstgSrc->DestroyElement(
							statstg.pwcsName);
					break;
				
				default:
					AssertSz(FALSE, "Invalid opcode");
					break;
				}
			}
		}
		
		// if the enumerator allocated a new name string, get rid of it
		if (statstg.pwcsName)
			PubMemFree(statstg.pwcsName);

		// quit the enumeration loop if we've hit an error
		if (error != NOERROR)
			break;
	}

	// release the enumerator
	penumStg->Release();

	// return the error state
	return error;
}


FARINTERNAL_(void) UtGetPresStreamName(LPOLESTR lpszName, int iStreamNum)
{
	VDATEHEAP();
	int i; // counts down the digits of iStreamNum

	// count down the last three '0' characters of OLE_PRESENTATION_STREAM
	// the -2 backs us up to the last character (remember the NULL
	// terminator!)
	for(lpszName += sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR) - 2,
			i = 3; i; --lpszName, --i)
	{
		*lpszName = OLESTR("0123456789")[iStreamNum % 10];
		if( iStreamNum > 0 )
		{
			iStreamNum /= 10;
		}
	}
}


FARINTERNAL_(void) UtRemoveExtraOlePresStreams(LPSTORAGE pstg, int iStart)
{
	VDATEHEAP();

	HRESULT hr; // error code from stream deletion
	OLECHAR szName[sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR)];
		// space for the stream names

	// if the stream number is invalid, do nothing
	if ((iStart < 0)  || (iStart >= OLE_MAX_PRES_STREAMS))
		return;
	
	// create presentation stream name
	_xstrcpy(szName, OLE_PRESENTATION_STREAM);
	UtGetPresStreamName(szName, iStart);
	
	// for each of these streams that exists, get rid of it
	while((hr = pstg->DestroyElement(szName)) == NOERROR)
	{
		// if we've gotten to the end of the possible streams, quit
		if (++iStart >= OLE_MAX_PRES_STREAMS)
			break;
		
		// Get the next presentation stream name
		UtGetPresStreamName(szName, iStart);
	}       

	// since the only reason these streams should be open, the first
	// failure had better be that the file was not found, and not
	// anything else (such as STG_E_ACCESSDENIED)
	AssertSz(hr == STG_E_FILENOTFOUND,
			"UtRemoveExtraOlePresStreams failure");
}

//+-------------------------------------------------------------------------
//
//  Function:   ConvertPixelsToHIMETRIC
//
//  Synopsis:   Converts a pixel dimension to HIMETRIC units
//
//  Effects:
//
//  Arguments:  [hdcRef]        -- the reference DC
//              [ulPels]        -- dimension in pixel measurement
//              [pulHIMETRIC]   -- OUT param of converted HIMETRIC result
//              [tDimension]    -- indicates XDIMENSION or YDIMENSION of input
//
//  Returns:    S_OK, E_FAIL
//
//  Algorithm:  screen_mm * input_pels        HIMETRICS/
//              ----------------------    *           /    == HIMETRICS
//                    screen_pels                    /mm 
//
//  History:    dd-mmm-yy Author    Comment
//              04-Aug-94 Davepl    Created
//
//  Notes:      We need to know whether the input size is in the X or
//              Y dimension, since the aspect ratio could vary
//
//--------------------------------------------------------------------------

FARINTERNAL ConvertPixelsToHIMETRIC (HDC   hdcRef,
				     ULONG lPels, 
				     ULONG * pulHIMETRIC,
				     DIMENSION tDimension)
{
    VDATEHEAP();
    VDATEPTROUT(pulHIMETRIC, ULONG *);

    // Clear OUT parameter in case of error

    *pulHIMETRIC = 0;
		
    ULONG scrmm  = 0;
    ULONG scrpel = 0;

    const ULONG HIMETRIC_PER_MM = 100;

    // If we weren't given a reference DC, use the screen as a default
    
    BOOL fLocalDC = FALSE;
    if (NULL == hdcRef)
    {
	hdcRef = GetDC(NULL);
	if (hdcRef)
	{
	     fLocalDC = TRUE;
	}
    }
	
    if (hdcRef)
    {
	Assert(tDimension == XDIMENSION || tDimension == YDIMENSION);

	// Get the count of pixels and millimeters for the screen

	if (tDimension == XDIMENSION)
	{
	    scrmm   = GetDeviceCaps(hdcRef, HORZSIZE);
	    scrpel  = GetDeviceCaps(hdcRef, HORZRES);
	}
	else
	{
	    scrmm   = GetDeviceCaps(hdcRef, VERTSIZE);
	    scrpel  = GetDeviceCaps(hdcRef, VERTRES); 
	}
	
	// If we had to create a temporary DC, it can be released now

	if (TRUE == fLocalDC)
	{
	    ReleaseDC(NULL, hdcRef);
	}
    }

    // If we successfully obtained the DC's size and resolution,
    // we can compute the HIMETRIC value.

    if (scrmm && scrpel)
    {
	*pulHIMETRIC = (scrmm * lPels * HIMETRIC_PER_MM) / scrpel;
	
	return S_OK;
    }

    return E_FAIL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\bufio.h ===
/****************************************************************************
                       Unit Bufio; Interface
*****************************************************************************

 Bufio implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.

 This interface will also shield the calling application from knowledge of 
 the source format (file vs. memory).

   Module Prefix: IO

*****************************************************************************/


/*********************** Exported Function Definitions **********************/

void IOGetByte( Byte far * );
/* Retrieves an 8-bit unsigned char from the input stream */

void IOSkipBytes( LongInt byteCount );
/* Skip the designated number of bytes */

void IOAlignToWordOffset( void );
/* Align next memory read to Word boundary. */

void IOSetFileName( StringLPtr pictFileName );
/* Interface routine to set the source filename */

void IOSetFileHandleAndSize( Integer pictFileHandle, LongInt pictFileSize );
/* Interface routine to set the source file Handle */

void IOSetMemoryHandle( HANDLE pictMemoryHandle );
/* Interface routine to set the source file Handle */

void IOSetReadOffset( LongInt readOffset );
/* Set the beginning offset to seek to when the file is opened */

void IOOpenPicture( Handle dialog );
/* Open the input stream set by a previous IOSet___ interface routine. */

void IOClosePicture( void );
/* Close the source input stream */

void IOUpdateStatus( void );
/* Update the status bar dialog to reflect current progress */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\api.c ===
/****************************************************************************
                   QuickDraw Import Filter; Implementation
*****************************************************************************

   This file contains the source for a dynamically loaded graphics
   import filters that read QuickDraw PICT images.  The entry points
   support both Aldus version 1 style interface, embedded extensions,
   and a parameterized input control.

****************************************************************************/

#include <headers.c>
#pragma hdrstop

#include "api.h"        /* Own interface */

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

#define  GraphicsImport    2
#define  PICTHeaderOffset  512

#define  USEDIALOG         TRUE
#define  NODIALOG          FALSE

private  USERPREFS   upgradePrefs;
private  USERPREFS   defaultPrefs =
{
   { 'Q','D','2','G','D','I' },  // signature
   2,                            // version = 2
   sizeof( USERPREFS ),          // size of structure
   NULL,                         // no sourceFilename, yet
   NULL,                         // no sourceHandle, yet
   NULL,                         // no destinationFilename, yet
   3,                            // penPatternAction = blend fore and background
   5,                            // nonSquarePenAction = use max dimension
   1,                            // penModeAction = use srcCopy
   1,                            // textModeAction = use srcCopy
   1,                            // nonRectRegionAction = create masks
   0,                            // optimize PowerPoint = false
   0,                            // noRLE = false
   0,                            // reservedByte
   { 0, 0, 0, 0, 0 }             // reserved initialized
};

private Handle       instanceHandle;


/*********************** Private Function Definitions ***********************/

LPUSERPREFS VerifyPrefBlock( LPUSERPREFS lpPrefs );
/* Perform cursory verification of the parameter block header */

private void ConvertPICT( LPUSERPREFS lpPrefs, PICTINFO far * lpPict,
                          Boolean doDialog );
/* perform conversion and return results once environment is set up */

/*********************** Function Implementation ****************************/
#ifdef WIN32
int WINAPI GetFilterInfo( short PM_Version, LPSTR lpIni,
                          HANDLE FAR * lphPrefMem,
                          HANDLE FAR * lphFileTypes )
/*=====================*/
#else
int FAR PASCAL GetFilterInfo( short PM_Version, LPSTR lpIni,
                              HANDLE FAR * lphPrefMem,
                              HANDLE FAR * lphFileTypes )
/*=========================*/
#endif
/* Returns information about this filter.
   Input parameters are PM_Version which is the filter interface version#
         and lpIni which is a copy of the win.ini entry
   Output parameters are lphPrefMem which is a handle to moveable global
         memory which will be allocated and initialized.
         lphFileTypes is a structure that contains the file types
         that this filter can import. (For MAC only)
   This routine should be called once, just before the filter is to be used
   the first time. */
{
   LPUSERPREFS    lpPrefs;

   /* allocate the global memory block */
   *lphPrefMem = GlobalAlloc( GHND, Sizeof( USERPREFS ) );

   /* if allocation is unsuccessful, set global error */
   if (*lphPrefMem == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      /* lock down the memory and assign the default values */
      lpPrefs = (LPUSERPREFS)GlobalLock( *lphPrefMem );
      *lpPrefs = defaultPrefs;

      /* unlock the memory */
      GlobalUnlock( *lphPrefMem );
   }

   /* Indicate handles graphics import */
   return( GraphicsImport );

   UnReferenced( PM_Version );
   UnReferenced( lpIni );
   UnReferenced( lphFileTypes );

} /* GetFilterInfo */


#ifdef WIN32
void WINAPI GetFilterPref( HANDLE hInst, HANDLE hWnd,
                           HANDLE hPrefMem, WORD wFlags )
/*======================*/
#else
void FAR PASCAL GetFilterPref( HANDLE hInst, HANDLE hWnd,
                               HANDLE hPrefMem, WORD wFlags )
/*==========================*/
#endif
/* Input parameters are hInst (in order to access resources), hWnd (to
   allow the DLL to display a dialog box), and hPrefMem (memory allocated
   in the GetFilterInfo() entry point).  WFlags is currently unused, but
   should be set to 1 for Aldus' compatability */
{
   return;

   UnReferenced( hInst );
   UnReferenced( hWnd );
   UnReferenced( hPrefMem );
   UnReferenced( wFlags );

}  /* GetFilterPref */


#ifndef _OLECNV32_

#ifdef WIN32
short WINAPI ImportGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                       PICTINFO FAR * lpPict, HANDLE hPrefMem )
/*==================*/
#else
short FAR PASCAL ImportGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                           PICTINFO FAR * lpPict, HANDLE hPrefMem )
/*======================*/
#endif
/* Import the metafile in the file indicated by the lpFileSpec. The
   metafile generated will be returned in lpPict. */
{
   LPUSERPREFS    lpPrefs;

   /* Check for any errors from GetFilterInfo() or GetFilterPref() */
   if (ErGetGlobalError() != NOERR)
   {
      return ErInternalErrorToAldus();
   }

   /* Lock the preference memory and verify correct header */
   lpPrefs = (LPUSERPREFS)GlobalLock( hPrefMem );
   lpPrefs = VerifyPrefBlock( lpPrefs );

   /* if there is no error from the header verification, proceed */
   if (ErGetGlobalError() == NOERR)
   {
      /* provide IO module with source file name and read begin offset */
      IOSetFileName( (StringLPtr) lpFileSpec->fullName );
      IOSetReadOffset( PICTHeaderOffset );

      /* save the source filename for the status dialog box */
      lpPrefs->sourceFilename = lpFileSpec->fullName;

      /* Tell Gdi module to create a memory-based metafile */
      lpPrefs->destinationFilename = NULL;

      /* convert the image, provide status update */
      ConvertPICT( lpPrefs, lpPict, USEDIALOG );
   }

   /* Unlock preference memory */
   GlobalUnlock( hPrefMem );

   /* return the translated error code (if any problems encoutered) */
   return ErInternalErrorToAldus();

   UnReferenced( hdcPrint );
   UnReferenced( hPrefMem );

} /* ImportGR */

#ifdef WIN32
short WINAPI ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                               PICTINFO FAR * lpPict, HANDLE hPrefMem,
                               DWORD dwSize, LPSTR lpMetafileName )
/*==========================*/
#else
short FAR PASCAL ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                                   PICTINFO FAR * lpPict, HANDLE hPrefMem,
                                   DWORD dwSize, LPSTR lpMetafileName )
/*==============================*/
#endif
/* Import the metafile in using the previously opened file handle in
   the structure field lpFileSpec->handle. Reading begins at offset
   lpFileSpect->filePos, and the convertor will NOT expect to find the
   512 byte PICT header.  The metafile generated will be returned in
   lpPict and can be specified via lpMetafileName (NIL = memory metafile,
   otherwise, fully qualified filename. */
{
   LPUSERPREFS    lpPrefs;

   /* Check for any errors from GetFilterInfo() or GetFilterPref() */
   if (ErGetGlobalError() != NOERR)
   {
      return ErInternalErrorToAldus();
   }

   /* Lock the preference memory and verify correct header */
   lpPrefs = (LPUSERPREFS)GlobalLock( hPrefMem );
   lpPrefs = VerifyPrefBlock( lpPrefs );

   /* if there is no error from the header verification, proceed */
   if (ErGetGlobalError() == NOERR)
   {
      /* provide IO module with source file handle and read begin offset */
      IOSetFileHandleAndSize( lpFileSpec->handle, dwSize );
      IOSetReadOffset( lpFileSpec->filePos );

      /* save the source filename for the status dialog box */
      lpPrefs->sourceFilename = lpFileSpec->fullName;

      /* Tell Gdi module to create metafile passed as parameter */
      lpPrefs->destinationFilename = lpMetafileName;

      /* convert the image, provide status update */
      ConvertPICT( lpPrefs, lpPict, USEDIALOG );
   }

   /* Unlock preference memory */
   GlobalUnlock( hPrefMem );

   /* return the translated error code (if any problems encoutered) */
   return ErInternalErrorToAldus();

   UnReferenced( hdcPrint );
   UnReferenced( hPrefMem );

}  /* ImportEmbeddedGr */

#endif  // !_OLECNV32_


#ifdef WIN32
short WINAPI QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict )
/*================*/
#else
short FAR PASCAL QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict )
/*====================*/
#endif
/* Import the metafile as specified using the parameters supplied in the
   lpPrefMem.  The metafile will be returned in lpPict. */
{
   /* verify correct header, and return if something is wrong */
   lpPrefMem = VerifyPrefBlock( lpPrefMem );

   /* if there is no error from the header verification, proceed */
   if (ErGetGlobalError() == NOERR)
   {
#ifndef _OLECNV32_
      /* Determine if there is a fully-qualified source file name */
      if (lpPrefMem->sourceFilename != NIL)
      {
         /* Set the filename and read offset */
         IOSetFileName( (StringLPtr) lpPrefMem->sourceFilename );
         IOSetReadOffset( 0 );

      }
      /* otherwise, we are performing memory read from a global memory block */
      else
#endif  // !_OLECNV32_
           if (lpPrefMem->sourceHandle != NIL)
      {
         /* Set the memory handle and read offset */
         IOSetMemoryHandle( (HANDLE) lpPrefMem->sourceHandle );
         IOSetReadOffset( 0 );
      }
      else
      {
         /* Problem with input parameter block */
         ErSetGlobalError( ErNoSourceFormat );
#ifdef _OLECNV32_
         return((short) ErGetGlobalError());
#else
         return ErInternalErrorToAldus();
#endif
      }

      /* convert the image - no status updates */
      ConvertPICT( lpPrefMem, lpPict, NODIALOG );
   }

   /* return the translated error code (if any problems encoutered) */
#ifdef _OLECNV32_
   return((short) ErGetGlobalError());
#else
   return ErInternalErrorToAldus();
#endif

}  /* QD2GDI */


#ifdef WIN32
BOOL LibMain( HINSTANCE hInst, DWORD fdwReason, LPVOID lpReserved)
/*=========*/
#else
int FAR PASCAL LibMain( HANDLE hInst, WORD wDataSeg, WORD cbHeap,
                        LPSTR lpszCmdline )
/*===================*/
#endif
/* Needed to get an instance handle */
{
   instanceHandle = hInst;

   /* default return value */
   return( 1 );

#ifndef WIN32
   UnReferenced( wDataSeg );
   UnReferenced( cbHeap );
   UnReferenced( lpszCmdline );
#endif

} /* LibMain */

#ifdef WIN32
int WINAPI WEP( int nParameter )
/*===========*/
#else
int FAR PASCAL WEP( int nParameter )
/*===============*/
#endif
{
   /* default return value */
   return( 1 );

   UnReferenced( nParameter );

} /* WEP */



/******************************* Private Routines ***************************/


LPUSERPREFS VerifyPrefBlock( LPUSERPREFS lpPrefs )
/*-------------------------*/
/* Perform cursory verification of the parameter block header */
{
   Byte           i;
   Byte far *     prefs = (Byte far *)lpPrefs;
   Byte far *     check = (Byte far *)&defaultPrefs;

   /* loop through chars of signature verifying it */
   for (i = 0; i < sizeof( lpPrefs->signature); i++)
   {
      /* if any of the byte miscompare ... */
      if (*prefs++ != *check++)
      {
         /* ... set a global flag and return */
         ErSetGlobalError( ErInvalidPrefsHeader );
         return lpPrefs; // Sundown - According to callers, ErGetGlobalError() is used to check any error.
      }
   }

   /* check if this is a version 1 structure */
   if (lpPrefs->version == 1)
   {
      USERPREFS_V1   v1Prefs = *((LPUSERPREFS_V1)lpPrefs);

      /* convert the version 1 fields to version 2 fields */
      upgradePrefs                     = defaultPrefs;
      upgradePrefs.sourceFilename      = v1Prefs.sourceFilename;
      upgradePrefs.sourceHandle        = v1Prefs.sourceHandle;
      upgradePrefs.destinationFilename = v1Prefs.destinationFilename;
      upgradePrefs.nonSquarePenAction  = v1Prefs.nonSquarePenAction;
      upgradePrefs.penModeAction       = v1Prefs.penModeAction;
      upgradePrefs.textModeAction      = v1Prefs.textModeAction;
      upgradePrefs.optimizePP          = v1Prefs.optimizePP;

      /* since new functionality was added to the patterned pens and region
         records, upgrade to highest image fidelity setting if they didn't
         request omit or import abort actions. */
      upgradePrefs.penPatternAction    = (v1Prefs.penPatternAction == 1) ?
                                          (Byte)3 :
                                          v1Prefs.penPatternAction;
      upgradePrefs.nonRectRegionAction = (v1Prefs.nonRectRegionAction == 0) ?
                                          (Byte)1 :
                                          v1Prefs.nonRectRegionAction;

      /* return address of the converted fields data structure */
      return &upgradePrefs;
   }
   else if( lpPrefs->version <= 3 )
   {
      if( lpPrefs->version==2 )
      {  /* noRLE wasn't supported in version 2, so zero it */
         lpPrefs->noRLE = 0;
      }

      /* return address that was passed in */
      return lpPrefs;
   }
   else /* version > 3 is an error */  {
      ErSetGlobalError( ErInvalidPrefsHeader );
      return lpPrefs; // Sundown - According to callers, ErGetGlobalError() is used to check any error.
  }
}


private void ConvertPICT( LPUSERPREFS lpPrefs, PICTINFO far * lpPict,
                          Boolean doDialog )
/*----------------------*/
/* perform conversion and return results once environment is set up */
{
#ifndef _OLECNV32_
   FARPROC        dialogBoxProcedure;
   StatusParam    statusParams;
#endif

   /* Set conversion preferences */
   /* This is somewhat bogus in that it passes ptr to middle of USERPREFS
      to a function that wants a ptr to ConvPrefs (a trailing subset) */
   GdiSetConversionPrefs( (ConvPrefsLPtr)&lpPrefs->destinationFilename );

#ifndef _OLECNV32_
   if (doDialog)
   {
      /* save data in structure to be passed to dialog window */
      statusParams.sourceFilename = lpPrefs->sourceFilename;
      statusParams.instance = instanceHandle;

      /* make a callable address for status dialog */
      dialogBoxProcedure = MakeProcInstance( StatusProc, instanceHandle );

      /* make sure that the procedure address was obtained */
      if (dialogBoxProcedure == NULL)
      {
         /* set error if unable to proceed */
         ErSetGlobalError( ErNoDialogBox );
         return;
      }
      else
      {
         /* AR: GetActiveWindow() may be bad, since the ability to update
            !!! links may be performed in the background, shutting out
                any process which then becomes the active window */

         /* dialog module calls quickdraw entry point to convert image */
         DialogBoxParam( instanceHandle, MAKEINTRESOURCE( RS_STATUS ),
                         GetActiveWindow(), dialogBoxProcedure,
                         (DWORD)((StatusParamLPtr)&statusParams) );

         /* release the procedure instance */
         FreeProcInstance( dialogBoxProcedure );
      }
   }
   else
#endif  // !_OLECNV32_
   {
      /* convert image, NULL parameter means no status updates */
      QDConvertPicture( NULL );
   }

   /* Get conversion results in parameter block */
   GdiGetConversionResults( lpPict );

#ifdef DEBUG
   if (ErGetGlobalError() == ErNoError)
   {
      HANDLE          hPICT;
      LPMETAFILEPICT  lpPICT;

      OpenClipboard( GetActiveWindow() );

      hPICT = GlobalAlloc( GHND, sizeof( METAFILEPICT ) );

      if (hPICT)
      {
         lpPICT = (LPMETAFILEPICT)GlobalLock( hPICT );
         lpPICT->mm = MM_ANISOTROPIC;
         lpPICT->xExt = Width( lpPict->bbox );
         lpPICT->yExt = Height( lpPict->bbox );
         lpPICT->hMF  = CopyMetaFile( lpPict->hmf, NULL );
         GlobalUnlock( hPICT );

         SetClipboardData( CF_METAFILEPICT, hPICT );
         CloseClipboard();
      }
   }
#endif

}  /* ConvertPICT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\utils.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		utils.cpp
//
//	Contents:
//		general OLE internal utility routines
//
//	Classes:
//
//	Functions:
//
//	History:
//              23-Jan-95 t-ScottH  -added Dump method to CSafeRefCount and
//                                   CThreadCheck class
//                                  -added DumpCSafeRefCount API
//		28-Jul-94 alexgo    added object stabilization classes
//              06-May-94 AlexT     Add DVTARGET conversion routines
//		25-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocations.
//		01/11/94 - alexgo  - added VDATEHEAP macros to every function
//		12/15/93 - ChrisWe - UtDupString has to scale length by
//			sizeof(OLECHAR)
//		12/08/93 - ChrisWe - added necessary casts to GlobalLock() calls
//			resulting from removing bogus GlobalLock() macros in
//			le2int.h
//		11/28/93 - ChrisWe - removed unreferenced define for MAX_STR,
//			formatted UtDupGlobal, UtDupString
//		03/02/92 - SriniK - created
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(utils)

#include <memory.h>

#ifdef _DEBUG
#include "dbgdump.h"
#endif // _DEBUG

NAME_SEG(Utils)
ASSERTDATA


#pragma SEG(UtDupGlobal)
FARINTERNAL_(HANDLE) UtDupGlobal(HANDLE hsrc, UINT uiFlags)
{
	VDATEHEAP();

	HANDLE hdst = NULL; // the newly create Handle DeSTination
	DWORD dwSize; // the size of the global
#ifndef _MAC
	void FAR *lpsrc; // a pointer to the source memory
	void FAR *lpdst; // a pointer to the destination memory
#endif

	// if no source, nothing to duplicate
	if (!hsrc)
		return(NULL);

#ifdef _MAC
	if (!(hdst = NewHandle(dwSize = GetHandleSize(hsrc))))
		return(NULL);
	BlockMove(*hsrc, *hdst, dwSize);
	return(hdst);
#else
	// if there's no content, do nothing
	if (!(lpsrc = GlobalLock(hsrc)))
		goto errRtn;

	// allocate a new global
	hdst = GlobalAlloc(uiFlags, (dwSize = (ULONG) GlobalSize(hsrc)));

	// if the allocation failed, get out
	if ((hdst == NULL) || ((lpdst = GlobalLock(hdst)) == NULL))
		goto errRtn;

	// copy the content
	_xmemcpy(lpdst, lpsrc, dwSize);

	// unlock the handles
	GlobalUnlock(hsrc);
	GlobalUnlock(hdst);
	return(hdst);

errRtn:
	// unlock the source handle
	GlobalUnlock(hsrc);

	// if we allocated a destination handle, free it
	if (hdst)
		GlobalFree(hdst);

	return(NULL);
#endif // _MAC
}


#pragma SEG(UtDupString)

// copies string using the TASK allocator; returns NULL on out of memory

// often when calling UtDupString, the caller knows the string length.
// a good speed boost would be to call UtDupPtr instead

// lpvIn must be non null
// note: we do an alloc even if dw == 0
FARINTERNAL_(LPVOID) UtDupPtr(LPVOID lpvIn, DWORD dw)
{
    VDATEHEAP();
    LPVOID lpvOut; // the newly allocated ptr

    Assert(lpvIn);	// internal fcn, lpvIn must be non-null
    if ((lpvOut = PubMemAlloc(dw)) != NULL) {
	memcpy(lpvOut, lpvIn, dw);
    }

    return lpvOut;
}

FARINTERNAL_(LPOLESTR) UtDupString(LPCOLESTR lpszIn)
{
    return (LPOLESTR) UtDupPtr( (LPVOID) lpszIn, 
		     (_xstrlen(lpszIn)+1) * sizeof(OLECHAR) );
}



//+-------------------------------------------------------------------------
//
//  Function: 	UtDupStringA
//
//  Synopsis: 	Duplicates an ANSI string using the TASK allocator
//
//  Effects:
//
//  Arguments:	[pszAnsi]	-- the string to duplicate
//
//  Requires:
//
//  Returns:	the newly allocated string duplicate or NULL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

LPSTR UtDupStringA( LPCSTR pszAnsi )
{
    return (LPSTR) UtDupPtr( (LPVOID) pszAnsi, 
		     (ULONG) strlen(pszAnsi) + 1 );
}

	

#pragma SEG(UtCopyTargetDevice)
FARINTERNAL_(DVTARGETDEVICE FAR*) UtCopyTargetDevice(DVTARGETDEVICE FAR* ptd)
{
    // if nothing to copy, return
    if (ptd == NULL)
	return(NULL);

    return (DVTARGETDEVICE FAR*) UtDupPtr((LPVOID) ptd, ptd->tdSize);
}


#pragma SEG(UtCopyFormatEtc)
FARINTERNAL_(BOOL) UtCopyFormatEtc(FORMATETC FAR* pFetcIn,
		FORMATETC FAR* pFetcCopy)
{
	VDATEHEAP();

	// copy structures
	*pFetcCopy = *pFetcIn;

	if (pFetcIn->ptd == NULL) {
	    // all done, return true because the copy succeeded
	    return TRUE;
	}

	// create a copy of the td descriptor, which is allocated
	pFetcCopy->ptd = UtCopyTargetDevice(pFetcIn->ptd);

	// return TRUE if we copied the data if we were supposed to
	return(pFetcCopy->ptd != NULL);
}


#pragma SEG(UtCompareFormatEtc)
FARINTERNAL_(int) UtCompareFormatEtc(FORMATETC FAR* pFetcLeft,
		FORMATETC FAR* pFetcRight)
{
	VDATEHEAP();

	int iResult; // indicates whether the match is exact or partial

	// if the clipboard formats are different, there is no match
	if (pFetcLeft->cfFormat != pFetcRight->cfFormat)
		return(UTCMPFETC_NEQ);

	// if the target devices don't match, there is no match
	if (!UtCompareTargetDevice(pFetcLeft->ptd, pFetcRight->ptd))
		return(UTCMPFETC_NEQ);

	// compare the aspects for the two formats
	if (pFetcLeft->dwAspect == pFetcRight->dwAspect)
	{
		// the match is exact
		iResult = UTCMPFETC_EQ;
	}
	else if ((pFetcLeft->dwAspect & ~pFetcRight->dwAspect) != 0)
	{
		// left not subset of aspects of right; not equal
		return(UTCMPFETC_NEQ);
	}
	else
	{
		// left aspects are a subset of the right aspects
		iResult = UTCMPFETC_PARTIAL;
	}

	// if we get here, iResult is set to one of UPCMPFETC_EQ or _PARTIAL

	// compare the media for the two formats
	if (pFetcLeft->tymed == pFetcRight->tymed)
	{
		// same medium flags; do not change value of iResult
		;
	}
	else if ((pFetcLeft->tymed & ~pFetcRight->tymed) != 0)
	{
		// left not subset of medium flags of right; not equal
		return(UTCMPFETC_NEQ);
	}
	else
	{
		// left subset of right
		iResult = UTCMPFETC_PARTIAL;
	}

	return(iResult);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtCompareTargetDevice
//
//  Synopsis:   Compare two DVTARGETDEVICEs
//
//  Arguments:  [ptdLeft] -- comparand
//              [ptdRight] -- comparee
//
//  Returns:    TRUE iff the two target devices are equivalent
//
//  Algorithm:
//
//  History:    09-May-94 AlexT     Rewrote to do more than just a binary
//                                  compare
//
//  Notes:
//
//--------------------------------------------------------------------------

#define UT_DM_COMPARISON_FIELDS (DM_ORIENTATION  |  \
                                 DM_PAPERSIZE    |  \
                                 DM_PAPERLENGTH  |  \
                                 DM_PAPERWIDTH   |  \
                                 DM_SCALE        |  \
                                 DM_PRINTQUALITY |  \
                                 DM_COLOR)

#pragma SEG(UtCompareTargetDevice)
FARINTERNAL_(BOOL) UtCompareTargetDevice(DVTARGETDEVICE FAR* ptdLeft,
                                         DVTARGETDEVICE FAR* ptdRight)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtCompareTargetDevice (%p, %p)\n",
		NULL, ptdLeft, ptdRight));

    VDATEHEAP();

    BOOL bRet = FALSE;  //  More often than not we return FALSE

    //  We use a do-while(FALSE) loop so that we can break out to common
    //  return code at the end (the joys of tracing)
    do
    {
        // if the addresses of the two target device descriptors are the same,
        // then they must be the same.  Note this handles the two NULL case.
        if (ptdLeft == ptdRight)
        {
            bRet = TRUE;
            break;
        }

        // if either td is NULL, can't compare them
        if ((ptdRight == NULL) || (ptdLeft == NULL))
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        // we ignore device name (My Printer vs. Your Printer doesn't matter)

        // check driver name
        if (ptdLeft->tdDriverNameOffset != 0)
        {
            if (ptdRight->tdDriverNameOffset == 0)
            {
                //  Left driver exists, but no right driver
                AssertSz(bRet == FALSE, "bRet not set correctly");
                break;
            }

            //  Both drivers exist
            if (_xstrcmp((LPOLESTR)((BYTE*)ptdLeft +
                                    ptdLeft->tdDriverNameOffset),
                         (LPOLESTR)((BYTE*)ptdRight +
                                    ptdRight->tdDriverNameOffset)) != 0)
            {
                //  Driver names don't match
                AssertSz(bRet == FALSE, "bRet not set correctly");
                break;
            }
        }
        else if (ptdRight->tdDriverNameOffset != 0)
        {
            //  Left driver doesn't exist, but right driver does
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        // we ignore port name

        if (0 == ptdLeft->tdExtDevmodeOffset)
        {
            if (0 == ptdRight->tdExtDevmodeOffset)
            {
                //  Nothing left to compare
                bRet = TRUE;
                break;
            }
            else
            {
                //  Only one Devmode
                AssertSz(bRet == FALSE, "bRet not set correctly");
                break;
            }
        }
        else if (0 == ptdRight->tdExtDevmodeOffset)
        {
            //  Only one Devmode exists
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        //  Both TDs have Devmodes
        DEVMODEW *pdmLeft, *pdmRight;

        pdmLeft = (DEVMODEW *)((BYTE*)ptdLeft +
                    ptdLeft->tdExtDevmodeOffset);
        pdmRight = (DEVMODEW *)((BYTE*)ptdRight +
                     ptdRight->tdExtDevmodeOffset);

        //  Check driver version
        if (pdmLeft->dmDriverVersion != pdmRight->dmDriverVersion)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        //  For a successful match, both device mode must specify the same
        //  values for each of the following:
        //    DM_ORIENTATION, DM_PAPERSIZE, DM_PAPERLENGTH.
        //    DM_PAPERWIDTH, DM_SCALE, DM_PRINTQUALITY, DM_COLOR

        if ((pdmLeft->dmFields & UT_DM_COMPARISON_FIELDS) ^
            (pdmRight->dmFields & UT_DM_COMPARISON_FIELDS))
        {
            //  Only one of pdmLeft and pdmRight specify at least one
            //  of the comparison fields
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_ORIENTATION) &&
            pdmLeft->dmOrientation != pdmRight->dmOrientation)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PAPERSIZE) &&
            pdmLeft->dmPaperSize != pdmRight->dmPaperSize)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PAPERLENGTH) &&
            pdmLeft->dmPaperLength != pdmRight->dmPaperLength)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PAPERWIDTH) &&
            pdmLeft->dmPaperWidth != pdmRight->dmPaperWidth)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_SCALE) &&
            pdmLeft->dmScale != pdmRight->dmScale)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PRINTQUALITY) &&
            pdmLeft->dmPrintQuality != pdmRight->dmPrintQuality)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_COLOR) &&
            pdmLeft->dmColor != pdmRight->dmColor)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        bRet = TRUE;
    } while (FALSE);

    LEDebugOut((DEB_ITRACE, "%p OUT UtCompareTargetDevice (%d)\n",
		NULL, bRet));

    return(bRet);
}

#pragma SEG(UtCopyStatData)
FARINTERNAL_(BOOL) UtCopyStatData(STATDATA FAR* pSDIn, STATDATA FAR* pSDCopy)
{
	VDATEHEAP();

	// copy structures
	*pSDCopy = *pSDIn;

	// create copy of target device description (which is allocated)
	pSDCopy->formatetc.ptd = UtCopyTargetDevice(pSDIn->formatetc.ptd);

	// if there is an advise sink, account for the copy/reference
	if (pSDCopy->pAdvSink != NULL)
		pSDCopy->pAdvSink->AddRef();

	// return TRUE if the copy was done if it was required
	return((pSDCopy->formatetc.ptd != NULL) ==
			(pSDIn->formatetc.ptd != NULL));
}

//+-------------------------------------------------------------------------
//
//  Function: 	UtReleaseStatData
//
//  Synopsis: 	nulls && releases members of the given stat data structure
//
//  Effects:
//
//  Arguments:	pStatData
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	We copy the data first and NULL out the stat data
//		because the Release on the Advise sink could cause us
//		to be re-entered.
//
//  History:    dd-mmm-yy Author    Comment
// 		20-Jul-94 alexgo    made safe for OLE sytle re-entrancy
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL_(void) UtReleaseStatData(STATDATA FAR* pStatData)
{
	STATDATA	sd;

	VDATEHEAP();

	sd = *pStatData;

	// zero out the original before doing any work

	_xmemset(pStatData, 0, sizeof(STATDATA));

	// if there's a target device description, free it
	if (sd.formatetc.ptd != NULL)
	{
		PubMemFree(sd.formatetc.ptd);
	}

	if( sd.pAdvSink )
	{
		sd.pAdvSink->Release();
	}
}

//+-------------------------------------------------------------------------
//
//  Function:	UtCreateStorageOnHGlobal
//
//  Synopsis:	creates a storage on top of an HGlobal
//
//  Effects:
//
//  Arguments: 	[hGlobal]	-- the memory on which to create the
//				   storage
//		[fDeleteOnRelease]	-- if TRUE, then delete the hglobal
//					   once the storage is released.
//		[ppStg]		-- where to put the storage interface
//		[ppILockBytes]	-- where to put the underlying ILockBytes,
//				   maybe NULL.  The ILB must be released.

//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	create an ILockBytes on HGLOBAL and then create the docfile
//		on top of the ILockBytes
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT UtCreateStorageOnHGlobal( HGLOBAL hGlobal, BOOL fDeleteOnRelease,
		IStorage **ppStg, ILockBytes **ppILockBytes )
{
	HRESULT		hresult;
	ILockBytes *	pLockBytes;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtCreateStorageOnHGlobal ( %lx , %p )"
		"\n", NULL, hGlobal, ppStg));

	hresult = CreateILockBytesOnHGlobal(hGlobal, fDeleteOnRelease,
			&pLockBytes);

	if( hresult == NOERROR )
	{
		hresult = StgCreateDocfileOnILockBytes( pLockBytes,
				 STGM_CREATE | STGM_SALL, 0, ppStg);

		// no matter what the result of StgCreate is, we want
		// to release the LockBytes.  If hresult == NOERROR, then
		// the final release to the LockBytes will come when the
		// created storage is released.
	}

	if( ppILockBytes )
	{
		*ppILockBytes = pLockBytes;
	}
	else if (pLockBytes)
	{
		// we release here so the final release of the storage
		// will be the final release of the lockbytes
		pLockBytes->Release();
	}


	LEDebugOut((DEB_ITRACE, "%p OUT UtCreateStorageOnHGlobal ( %lx ) "
		"[ %p ]\n", NULL, hresult, *ppStg));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	UtGetTempFileName
//
//  Synopsis:	retrieves a temporary filename (for use in GetData, TYMED_FILE
//		and temporary docfiles)
//
//  Effects:
//
//  Arguments: 	[pszPrefix]	-- prefix of the temp filename
//		[pszTempName]	-- buffer that will receive the temp path.
//				   must be MAX_PATH or greater.
//
//  Requires:
//
//  Returns:	HRESULT;
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tries to get a file in the temp directory, failing that, in
//		the windows directory
//
//  History:    dd-mmm-yy Author    Comment
// 		07-Apr-94 alexgo    author
//
//  Notes: 	OPTIMIZATION: The storage code has a similar peice of code
//		for generating temporary docfiles.  We may want to use this
//		routine there as well.
//
//--------------------------------------------------------------------------

HRESULT	UtGetTempFileName( LPOLESTR pszPrefix, LPOLESTR pszTempName )
{
	HRESULT		hresult = NOERROR;
	OLECHAR		szPath[MAX_PATH + 1];
        DWORD           dwRet = 0;
	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtGetTempFilename ( \"%ws\" , "
		"\"%ws\")\n", NULL, pszPrefix, pszTempName));

	if( (dwRet = GetTempPath(MAX_PATH, szPath)) == 0)
	{
		UINT uiRet = 0;
                LEDebugOut((DEB_WARN, "WARNING: GetTempPath failed!\n"));
		if( (uiRet=GetWindowsDirectory(szPath, MAX_PATH)) == 0 )
		{
			LEDebugOut((DEB_WARN, "WARNING: GetWindowsDirectory"
				" failed!!\n"));
			hresult = ResultFromScode(E_FAIL);
			goto errRtn;
		}
                else if (uiRet > MAX_PATH) 
                {
                   LEDebugOut((DEB_WARN, "WARNING: WindowsDir longer than MAX_PATH!\n"));
                   hresult = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                   goto errRtn;
                }
                
	}
        else if (dwRet > MAX_PATH) 
        {
           LEDebugOut((DEB_WARN, "WARNING: TempDir longer than MAX_PATH!\n"));
           hresult = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
           goto errRtn;
        }
        

	if( !GetTempFileName( szPath, pszPrefix, 0, pszTempName ) )
	{
		LEDebugOut((DEB_WARN, "WARNING: GetTempFileName failed!!\n"));
		hresult = ResultFromScode(E_FAIL);
	}

errRtn:
	LEDebugOut((DEB_ITRACE, "%p OUT UtGetTempFilename ( %lx ) "
		"[ \"%ws\" ]\n", NULL, hresult, pszTempName));

	return hresult;
}


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHGLOBALtoStm, internal
//
//	Synopsis:
//		Write the contents of an HGLOBAL to a stream
//
//	Arguments:
//		[hdata] -- handle to the data to write out
//		[dwSize] -- size of the data to write out
//		[pstm] -- stream to write the data out to;  on exit, the
//			stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		04/10/94 - AlexGo  - added call tracing, moved from convert.cpp
//				     to utils.cpp, misc improvements.
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

HRESULT UtHGLOBALtoStm(HGLOBAL hGlobalSrc, DWORD dwSize, LPSTREAM pstm)
{
	HRESULT 	hresult = NOERROR;
	void *		lpdata;
	ULONG		cbWritten;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoStm ( %lx , %lu , %p )\n",
		NULL, hGlobalSrc, dwSize, pstm));
	
	lpdata = GlobalLock(hGlobalSrc);
	
	if (lpdata)
	{
		hresult = pstm->Write(lpdata, dwSize, &cbWritten);

		// if we didn't write enough data, then it's an error
		// condition for us.

		if( hresult == NOERROR && cbWritten != dwSize )
		{
			hresult = ResultFromScode(E_FAIL);
		}

		if( hresult == NOERROR )
		{
			// this call isn't strictly necessary, but may
			// be useful for compacting the size of presentations
			// stored on disk (when called by the presentation
			// code)
			hresult = StSetSize(pstm, 0, TRUE);
		}

		GlobalUnlock(hGlobalSrc);
	}


	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoStm ( %lx )\n", NULL,
		hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoHGLOBAL, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target HGLOBAL
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[hGlobalTgt] 	-- the target HGLOBAL
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the target hglobal is not large
//		enough
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoHGLOBAL( HGLOBAL hGlobalSrc, DWORD dwSize,
		HGLOBAL hGlobalTgt)
{
	DWORD	cbTarget;
	void *	pvSrc;
	void * 	pvTgt;
	HRESULT	hresult = ResultFromScode(E_OUTOFMEMORY);

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoHGLOBAL ( %lx , %lu , "
		"%lx )\n", NULL, hGlobalSrc, dwSize, hGlobalTgt));

	cbTarget = (ULONG) GlobalSize(hGlobalTgt);

	if( cbTarget == 0 || cbTarget < dwSize )
	{
		hresult = ResultFromScode(E_FAIL);
		goto errRtn;
	}

	pvSrc = GlobalLock(hGlobalSrc);

	if( pvSrc )
	{
 		pvTgt = GlobalLock(hGlobalTgt);

		if( pvTgt )
		{
			_xmemcpy( pvTgt, pvSrc, dwSize);

			GlobalUnlock(hGlobalTgt);
			hresult = NOERROR;
		}

		GlobalUnlock(hGlobalSrc);
	}

errRtn:
	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoHGLOBAL ( %lx )\n",
		NULL, hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoStorage, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target storage
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[pStgTgt] 	-- the target storage
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the source HGLOBAL did not
//		originally have a storage layered on top of it.
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoStorage( HGLOBAL hGlobalSrc, IStorage *pStgTgt)
{
	HRESULT		hresult;
	ILockBytes *	pLockBytes = NULL;
	IStorage *	pStgSrc;
	ULONG		cRefs;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoStroage ( %lx , %p )"
		"\n", NULL, hGlobalSrc, pStgTgt));

	hresult = CreateILockBytesOnHGlobal(hGlobalSrc,
			FALSE /*fDeleteOnRelease*/, &pLockBytes);

	if( hresult != NOERROR )
	{
		goto errRtn;
	}

	// now we make sure that the hglobal really has a storage
	// in it

	if( StgIsStorageILockBytes(pLockBytes) != NOERROR )
	{
		hresult = ResultFromScode(E_FAIL);
		goto errRtn;
	}

	hresult = StgOpenStorageOnILockBytes( pLockBytes, NULL,
			 STGM_SALL, NULL, 0, &pStgSrc);

	if( hresult == NOERROR )
	{
		hresult = pStgSrc->CopyTo( 0, NULL, NULL, pStgTgt);

		// no matter what the result, we want to free the
		// source storage

		pStgSrc->Release();
	}

errRtn:

	if( pLockBytes )
	{
		cRefs = pLockBytes->Release();
		Assert(cRefs == 0);
	}
		
	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoStorage ( %lx ) "
		"[ %p ]\n", NULL, hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoFile, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target file
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[pszFileName] 	-- the target file
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:	if the file already exists, we simply append to it
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoFile( HGLOBAL hGlobalSrc, DWORD dwSize,
		LPCOLESTR pszFileName)
{
	HRESULT		hresult;
	HANDLE		hFile;
	void *		pvSrc;
	DWORD		cbWritten;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoFile ( %lx , %lu , "
		"\"%ws\" )\n", NULL, hGlobalSrc, dwSize, pszFileName));


	hresult = ResultFromScode(E_NOTIMPL);
	(void)hFile;
	(void)pvSrc;
	(void)cbWritten;
	

// this doesn't compile for chicago [, but we don't need this anyway]
#ifdef LATER
	pvSrc = GlobalLock(hGlobalSrc);

	if( !pvSrc )
	{
		hresult = ResultFromScode(E_OUTOFMEMORY);
		goto errRtn;
	}

	// open the file for append, creating if it doesn't already exist.

	hFile = CreateFile( pszFileName, GENERIC_WRITE, 0, NULL,
			OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

	if( hFile != INVALID_HANDLE_VALUE )
	{
		if( !WriteFile( hFile, pvSrc, dwSize, &cbWritten, NULL) )
		{
			LEDebugOut((DEB_WARN, "WARNING: WriteFile failed!\n"));
			hresult = HRESULT_FROM_WIN32(GetLastError());
		}

		if( cbWritten != dwSize && hresult == NOERROR )
		{
			// still an error if we didn't write all the bytes
			// we wanted
			hresult = ResultFromScode(E_FAIL);
		}

		if( !CloseHandle(hFile) )
		{
			AssertSz(0, "CloseFile failed! Should not happen!");

			// if there's no error yet, set the error
			if( hresult == NOERROR )
			{
				hresult = HRESULT_FROM_WIN32(GetLastError());
			}
		}
	}
	else
	{
		LEDebugOut((DEB_WARN, "WARNING: CreateFile failed!!\n"));
		hresult = HRESULT_FROM_WIN32(GetLastError());
	}

	GlobalUnlock(hGlobalSrc);

errRtn:

#endif // LATER


	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoFile ( %lx )\n", NULL,
		hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetDvtd16Info
//
//  Synopsis:   Fills in pdvdtInfo
//
//  Arguments:  [pdvtd16] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtdInfo
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//              10-Jul-94 AlexT     Make sure DEVMODE ends up DWORD aligned
//
//  Notes:      Do we need to do any error checking on the strings?
//
//--------------------------------------------------------------------------

//  We can't use sizeof(DV_TARGETDEVICE) because MIDL keeps flipping back
//  and forth over whether to make the embedded array size 0 or size 1

#define UT_DVTARGETDEVICE_SIZE  (sizeof(DWORD) + sizeof(WORD) * 4)

//                      tdSize           td...Offset's
#define DVTD_MINSIZE    (sizeof(DWORD) + 4 * sizeof(WORD))

extern "C" HRESULT UtGetDvtd16Info(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                   PDVTDINFO pdvtdInfo)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtGetDvtd16Info (%p, %p)\n",
		NULL, pdvtd16, pdvtdInfo));

    DEVMODEA UNALIGNED *pdm16;

    //  Let's do some sanity checking on the incoming DVTARGETDEVICE
    if (pdvtd16->tdSize < DVTD_MINSIZE)
    {
        LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdSize\n"));
        return(E_INVALIDARG);
    }

    //  We need at least a DVTARGETDEVICE
    pdvtdInfo->cbConvertSize = UT_DVTARGETDEVICE_SIZE;

    //  Compute required size for Drv, Device, Port names
    if (pdvtd16->tdDriverNameOffset != 0)
    {
        if (pdvtd16->tdDriverNameOffset > pdvtd16->tdSize ||
            pdvtd16->tdDriverNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdDriverNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDrvName = (UINT) strlen((char *)pdvtd16 +
                                       pdvtd16->tdDriverNameOffset) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDrvName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDrvName = 0;
    }

    if (pdvtd16->tdDeviceNameOffset != 0)
    {
        if (pdvtd16->tdDeviceNameOffset > pdvtd16->tdSize ||
            pdvtd16->tdDeviceNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdDeviceNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDevName = (UINT) strlen((char *)pdvtd16 +
                                       pdvtd16->tdDeviceNameOffset) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDevName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDevName = 0;
    }

    if (pdvtd16->tdPortNameOffset != 0)
    {
        if (pdvtd16->tdPortNameOffset > pdvtd16->tdSize ||
            pdvtd16->tdPortNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdPortNameOffset\n"));
            return(E_INVALIDARG);
        }


        pdvtdInfo->cchPortName = (UINT) strlen((char *)pdvtd16 +
                                        pdvtd16->tdPortNameOffset) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchPortName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchPortName = 0;
    }

    if (pdvtd16->tdExtDevmodeOffset != 0)
    {
        if (pdvtd16->tdExtDevmodeOffset > pdvtd16->tdSize ||
            pdvtd16->tdExtDevmodeOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdExtDevmodeOffset\n"));
            return(E_INVALIDARG);
        }

        //  The DEVMODEW structure needs to be DWORD aligned, so here we make
        //  sure cbConvertSize (which will be the beginning of DEVMODEW) is
        //  DWORD aligned
        pdvtdInfo->cbConvertSize += (sizeof(DWORD) - 1);
        pdvtdInfo->cbConvertSize &= ~(sizeof(DWORD) - 1);

        //  Now compute the space needed for the DEVMODE
        pdm16 = (DEVMODEA *)((BYTE *)pdvtd16 + pdvtd16->tdExtDevmodeOffset);

        //  We start with a basic DEVMODEW
        pdvtdInfo->cbConvertSize += sizeof(DEVMODEW);

        if (pdm16->dmSize > sizeof(DEVMODEA))
        {
            //  The input DEVMODEA is larger than a standard DEVMODEA, so
            //  add space for the extra amount
            pdvtdInfo->cbConvertSize += pdm16->dmSize - sizeof(DEVMODEA);
        }

        //  Finally we account for the extra driver data
        pdvtdInfo->cbConvertSize += pdm16->dmDriverExtra;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT UtGetDvtd16Info (%lx) [%ld]\n",
		NULL, S_OK, pdvtdInfo->cbConvertSize));

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtConvertDvtd16toDvtd32
//
//  Synopsis:   Fills in a 32-bit DVTARGETDEVICE based on a 16-bit
//              DVTARGETDEVICE
//
//  Arguments:  [pdvtd16] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//              [pdvtd32] -- pointer to UNICODE DVTARGETDEVICE
//
//  Requires:   pdvtdInfo must have been filled in by a previous call to
//              UtGetDvtd16Info
//
//              pdvtd32 must be at least pdvtdInfo->cbConvertSize bytes long
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtd32
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//              10-Jul-94 AlexT     Make sure DEVMODEW is DWORD aligned
//
//  Notes:      Do we need to do any error checking on the strings?
//
//--------------------------------------------------------------------------

extern "C" HRESULT UtConvertDvtd16toDvtd32(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE *pdvtd32)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtConvertDvtd16toDvtd32 (%p, %p, %p)\n",
		NULL, pdvtd16, pdvtdInfo, pdvtd32));

#if DBG==1
    {
        //  Verify the passed in pdvtdInfo is what we expect
        DVTDINFO dbgDvtdInfo;
        Assert(UtGetDvtd16Info(pdvtd16, &dbgDvtdInfo) == S_OK);
        Assert(0 == memcmp(&dbgDvtdInfo, pdvtdInfo, sizeof(DVTDINFO)));
    }
#endif

    HRESULT hr = S_OK;
    USHORT cbOffset;
    int cchWritten;
    DEVMODEA UNALIGNED *pdm16;
    DEVMODEW *pdm32;
	UINT	nCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    memset(pdvtd32, 0, pdvtdInfo->cbConvertSize);

    cbOffset = UT_DVTARGETDEVICE_SIZE;

    if (pdvtdInfo->cchDrvName != 0)
    {
        pdvtd32->tdDriverNameOffset = cbOffset;
        cchWritten = MultiByteToWideChar(
                        CP_ACP, 0,
                        (char *)pdvtd16+pdvtd16->tdDriverNameOffset,
                        pdvtdInfo->cchDrvName,
                        (LPOLESTR)((BYTE *)pdvtd32 +
                            pdvtd32->tdDriverNameOffset),
                        pdvtdInfo->cchDrvName);
        if (0 == cchWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset = cbOffset + (USHORT)(cchWritten * sizeof(WCHAR));
    }

    if (pdvtdInfo->cchDevName != 0)
    {
        pdvtd32->tdDeviceNameOffset = cbOffset;
        cchWritten = MultiByteToWideChar(
                        nCodePage, 0,
                        (char *)pdvtd16 + pdvtd16->tdDeviceNameOffset,
                        pdvtdInfo->cchDevName,
                        (LPOLESTR)((BYTE *)pdvtd32 +
                            pdvtd32->tdDeviceNameOffset),
                        pdvtdInfo->cchDevName);

        if (0 == cchWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset = cbOffset + (USHORT)(cchWritten * sizeof(WCHAR));
    }

    if (pdvtdInfo->cchPortName != 0)
    {
        pdvtd32->tdPortNameOffset = cbOffset;
        cchWritten = MultiByteToWideChar(
                        nCodePage, 0,
                        (char *)pdvtd16 + pdvtd16->tdPortNameOffset,
                        pdvtdInfo->cchPortName,
                        (LPOLESTR)((BYTE *)pdvtd32 +
                            pdvtd32->tdPortNameOffset),
                        pdvtdInfo->cchPortName);
        if (0 == cchWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }

        cbOffset = cbOffset + (USHORT)(cchWritten * sizeof(WCHAR));
    }

    if (pdvtd16->tdExtDevmodeOffset != 0)
    {
        //  Make sure DEVMODEW will be DWORD aligned
        cbOffset += (sizeof(DWORD) - 1);
        cbOffset &= ~(sizeof(DWORD) - 1);

        pdvtd32->tdExtDevmodeOffset = cbOffset;
        pdm32 = (DEVMODEW *)((BYTE *)pdvtd32+pdvtd32->tdExtDevmodeOffset);

        pdm16 = (DEVMODEA *)((BYTE *)pdvtd16+pdvtd16->tdExtDevmodeOffset);

        //  The incoming DEVMODEA can have one of the following two forms:
        //
        //  1)  32 chars for dmDeviceName
        //      m bytes worth of fixed size data (where m <= 38)
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 32+m
        //
        //  2)  32 chars for dmDeviceName
        //      38 bytes worth of fixed size data
        //      32 chars for dmFormName
        //      m additional bytes of fixed size data
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 32 + 38 + 32 + m
        //
        //  We have to be careful to translate the dmFormName string, if it
        //  exists

        //  First, translate the dmDeviceName
        if (MultiByteToWideChar(nCodePage, 0, (char *)pdm16->dmDeviceName,
                                CCHDEVICENAME,
                                pdm32->dmDeviceName, CCHDEVICENAME) == 0)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }


        //  Now check to see if we have a dmFormName to translate
        if (pdm16->dmSize <= FIELD_OFFSET(DEVMODEA, dmFormName))
        {
            //  No dmFormName, just copy the remaining m bytes
            memcpy(&pdm32->dmSpecVersion, &pdm16->dmSpecVersion,
                   pdm16->dmSize - CCHDEVICENAME);
        }
        else
        {
            //  There is a dmFormName;  copy the bytes between the names first
            memcpy(&pdm32->dmSpecVersion, &pdm16->dmSpecVersion,
                   FIELD_OFFSET(DEVMODEA, dmFormName) -
                    FIELD_OFFSET(DEVMODEA, dmSpecVersion));

            //  Now translate the dmFormName
            if (MultiByteToWideChar(CP_ACP, 0, (char *)pdm16->dmFormName,
                                    CCHFORMNAME,
                                    pdm32->dmFormName, CCHFORMNAME) == 0)
            {
                hr = E_UNEXPECTED;
                goto ErrRtn;
            }

            //  Now copy the remaining m bytes

            if (pdm16->dmSize > FIELD_OFFSET(DEVMODEA, dmLogPixels))
            {
                memcpy(&pdm32->dmLogPixels, &pdm16->dmLogPixels,
                       pdm16->dmSize - FIELD_OFFSET(DEVMODEA, dmLogPixels));
            }
        }

        pdm32->dmSize = sizeof(DEVMODEW);
        if (pdm16->dmSize > sizeof(DEVMODEA))
        {
            pdm32->dmSize += pdm16->dmSize - sizeof(DEVMODEA);
        }

        //  Copy the extra driver bytes
        memcpy(((BYTE*)pdm32) + pdm32->dmSize, ((BYTE*)pdm16) + pdm16->dmSize,
               pdm16->dmDriverExtra);

        cbOffset += pdm32->dmSize + pdm32->dmDriverExtra;
    }

    //  Finally, set pdvtd32's size
    pdvtd32->tdSize = cbOffset;


ErrRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT UtConvertDvtd16toDvtd32 (%lx)\n",
                            NULL, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetDvtd32Info
//
//  Synopsis:   Fills in pdvdtInfo
//
//  Arguments:  [pdvtd32] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtdInfo
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//
//  Notes:      Do we need to do any error checking on the strings?
//
//--------------------------------------------------------------------------

extern "C" HRESULT UtGetDvtd32Info(DVTARGETDEVICE const *pdvtd32, PDVTDINFO pdvtdInfo)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtGetDvtd32Info (%p, %p)\n",
		NULL, pdvtd32, pdvtdInfo));

    DEVMODEW *pdm32;

    //  Let's do some sanity checking on the incoming DVTARGETDEVICE
    if (pdvtd32->tdSize < DVTD_MINSIZE)
    {
        LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdSize\n"));
        return(E_INVALIDARG);
    }

    pdvtdInfo->cbConvertSize = UT_DVTARGETDEVICE_SIZE;

    //  Compute required size for Drv, Device, Port names
    if (pdvtd32->tdDriverNameOffset != 0)
    {
        if (pdvtd32->tdDriverNameOffset > pdvtd32->tdSize ||
            pdvtd32->tdDriverNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdDriverNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDrvName = lstrlenW((WCHAR *)((BYTE *)pdvtd32 +
                                       pdvtd32->tdDriverNameOffset)) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDrvName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDrvName = 0;
    }

    if (pdvtd32->tdDeviceNameOffset != 0)
    {
        if (pdvtd32->tdDeviceNameOffset > pdvtd32->tdSize ||
            pdvtd32->tdDeviceNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdDeviceNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDevName = lstrlenW((WCHAR *)((BYTE *)pdvtd32 +
                                       pdvtd32->tdDeviceNameOffset)) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDevName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDevName = 0;
    }

    if (pdvtd32->tdPortNameOffset != 0)
    {
        if (pdvtd32->tdPortNameOffset > pdvtd32->tdSize ||
            pdvtd32->tdPortNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdPortNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchPortName = lstrlenW((WCHAR *)((BYTE *)pdvtd32 +
                                        pdvtd32->tdPortNameOffset)) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchPortName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchPortName = 0;
    }

    //  Now compute the space needed for the DEVMODE
    if (pdvtd32->tdExtDevmodeOffset != 0)
    {
        if (pdvtd32->tdExtDevmodeOffset > pdvtd32->tdSize ||
            pdvtd32->tdExtDevmodeOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdExtDevmodeOffset\n"));
            return(E_INVALIDARG);
        }

        //  The DEVMODEA structure needs to be DWORD aligned, so here we make
        //  sure cbConvertSize (which will be the beginning of DEVMODEA) is
        //  DWORD aligned
        pdvtdInfo->cbConvertSize += (sizeof(DWORD) - 1);
        pdvtdInfo->cbConvertSize &= ~(sizeof(DWORD) - 1);

        pdm32 = (DEVMODEW *)((BYTE *)pdvtd32+pdvtd32->tdExtDevmodeOffset);

        //  We start with a basic DEVMODEA
        pdvtdInfo->cbConvertSize += sizeof(DEVMODEA);

        if (pdm32->dmSize > sizeof(DEVMODEW))
        {
            //  The input DEVMODEW is larger than a standard DEVMODEW, so
            //  add space for the extra amount
            pdvtdInfo->cbConvertSize += pdm32->dmSize - sizeof(DEVMODEW);
        }

        //  Finally we account for the extra driver data
        pdvtdInfo->cbConvertSize += pdm32->dmDriverExtra;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT UtGetDvtd32Info (%lx) [%ld]\n",
		NULL, S_OK, pdvtdInfo->cbConvertSize));

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtConvertDvtd32toDvtd16
//
//  Synopsis:   Fills in a 32-bit DVTARGETDEVICE based on a 16-bit
//              DVTARGETDEVICE
//
//  Arguments:  [pdvtd32] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//              [pdvtd16] -- pointer to UNICODE DVTARGETDEVICE
//
//  Requires:   pdvtdInfo must have been filled in by a previous call to
//              UtGetDvtd32Info
//
//              pdvtd16 must be at least pdvtdInfo->cbSizeConvert bytes long
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtd16
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//
//  Notes:      Do we need to do any error checking on the strings?
//
//              On Chicago we'll have to provide helper code to do this
//              translation
//
//--------------------------------------------------------------------------

extern "C" HRESULT UtConvertDvtd32toDvtd16(DVTARGETDEVICE const *pdvtd32,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE UNALIGNED *pdvtd16)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtConvertDvtd32toDvtd16 (%p, %p, %p)\n",
		NULL, pdvtd32, pdvtdInfo, pdvtd16));

#if DBG==1
    {
        //  Verify the passed in pdvtdInfo is what we expect
        DVTDINFO dbgDvtdInfo;
        Assert(UtGetDvtd32Info(pdvtd32, &dbgDvtdInfo) == S_OK);
        Assert(0 == memcmp(&dbgDvtdInfo, pdvtdInfo, sizeof(DVTDINFO)));
    }
#endif

    HRESULT hr = S_OK;
    USHORT cbOffset;
    int cbWritten;
    DEVMODEA UNALIGNED *pdm16;
    DEVMODEW *pdm32;
	UINT	nCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    memset(pdvtd16, 0, pdvtdInfo->cbConvertSize);

    cbOffset = UT_DVTARGETDEVICE_SIZE;

    if (pdvtdInfo->cchDrvName != 0)
    {
        pdvtd16->tdDriverNameOffset = cbOffset;
        cbWritten = WideCharToMultiByte(CP_ACP, 0,
                                (WCHAR *)((BYTE *)pdvtd32 +
                                    pdvtd32->tdDriverNameOffset),
                                pdvtdInfo->cchDrvName,
                                (char *)pdvtd16 + pdvtd16->tdDriverNameOffset,
                                pdvtdInfo->cchDrvName * sizeof(WCHAR),
                                NULL, NULL);

        if (0 == cbWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset = cbOffset + (USHORT) cbWritten;
    }

    if (pdvtdInfo->cchDevName != 0)
    {
        pdvtd16->tdDeviceNameOffset = cbOffset;
        cbWritten = WideCharToMultiByte(
                                nCodePage, 0,
                                (WCHAR *)((BYTE *)pdvtd32 +
                                    pdvtd32->tdDeviceNameOffset),
                                pdvtdInfo->cchDevName,
                                (char *)pdvtd16 + pdvtd16->tdDeviceNameOffset,
                                pdvtdInfo->cchDevName * sizeof(WCHAR),
                                NULL, NULL);

        if (0 == cbWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset = cbOffset + (USHORT) cbWritten;
    }

    if (pdvtdInfo->cchPortName != 0)
    {
        pdvtd16->tdPortNameOffset = cbOffset;
        cbWritten = WideCharToMultiByte(nCodePage, 0,
                                (WCHAR *)((BYTE *)pdvtd32 +
                                    pdvtd32->tdPortNameOffset),
                                pdvtdInfo->cchPortName,
                                (char *)pdvtd16 + pdvtd16->tdPortNameOffset,
                                pdvtdInfo->cchPortName * sizeof(WCHAR),
                                NULL, NULL);
        if (0 == cbWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset = cbOffset + (USHORT) cbWritten;
    }

    if (pdvtd32->tdExtDevmodeOffset != 0)
    {
        //  Make sure DEVMODEA will be DWORD aligned
        cbOffset += (sizeof(DWORD) - 1);
        cbOffset &= ~(sizeof(DWORD) - 1);

        pdvtd16->tdExtDevmodeOffset = cbOffset;
        pdm16 = (DEVMODEA *)((BYTE *)pdvtd16+pdvtd16->tdExtDevmodeOffset);

        pdm32 = (DEVMODEW *)((BYTE *)pdvtd32+pdvtd32->tdExtDevmodeOffset);

        //  The incoming DEVMODEW can have one of the following two forms:
        //
        //  1)  32 WCHARs for dmDeviceName
        //      m bytes worth of fixed size data (where m <= 38)
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 64+m
        //
        //  2)  32 WCHARs for dmDeviceName
        //      38 bytes worth of fixed size data
        //      32 WCHARs for dmFormName
        //      m additional bytes of fixed size data
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 64 + 38 + 64 + m
        //
        //  We have to be careful to translate the dmFormName string, if it
        //  exists


		// Need to attempt to copy the entire buffer since old UI lib does a memcmp to verify if ptd's are equal

        if (WideCharToMultiByte(nCodePage, 0, pdm32->dmDeviceName,CCHDEVICENAME,
                                (char *)pdm16->dmDeviceName, CCHDEVICENAME,
                                NULL, NULL) == 0)
        {
     		 
			 // in DBCS case we can run out of pdm16->dmDeviceName buffer space
			 // Current Implementation of WideCharToMultiByte copies in what fit before error 
			 // but in case this behavior changes copy again up to NULL char if error out above

       	 	if (WideCharToMultiByte(nCodePage, 0, pdm32->dmDeviceName,-1,
                                (char *)pdm16->dmDeviceName, CCHDEVICENAME,
                                NULL, NULL) == 0)
			{
		    	hr = E_UNEXPECTED;
				goto ErrRtn;
		  	}
        }

        //  Now check to see if we have a dmFormName to translate
        if (pdm32->dmSize <= FIELD_OFFSET(DEVMODEW, dmFormName))
        {
            //  No dmFormName, just copy the remaining m bytes
            memcpy(&pdm16->dmSpecVersion, &pdm32->dmSpecVersion,
                   pdm32->dmSize - FIELD_OFFSET(DEVMODEW, dmSpecVersion));
        }
        else
        {
            //  There is a dmFormName;  copy the bytes between the names first
            memcpy(&pdm16->dmSpecVersion, &pdm32->dmSpecVersion,
                   FIELD_OFFSET(DEVMODEW, dmFormName) -
                     FIELD_OFFSET(DEVMODEW, dmSpecVersion));

            //  Now translate the dmFormName
            if (WideCharToMultiByte(CP_ACP, 0,
                                    pdm32->dmFormName, CCHFORMNAME,
                                    (char *) pdm16->dmFormName, CCHFORMNAME,
                                    NULL, NULL) == 0)
            {

	            if (WideCharToMultiByte(CP_ACP, 0,
	                                    pdm32->dmFormName, -1,
	                                    (char *) pdm16->dmFormName, CCHFORMNAME,
	                                    NULL, NULL) == 0)
				{
			    	hr = E_UNEXPECTED;
					goto ErrRtn;
			  	}
            }

            //  Now copy the remaining m bytes

            if (pdm32->dmSize > FIELD_OFFSET(DEVMODEW, dmLogPixels))
            {
                memcpy(&pdm16->dmLogPixels, &pdm32->dmLogPixels,
                       pdm32->dmSize - FIELD_OFFSET(DEVMODEW, dmLogPixels));
            }
        }

        pdm16->dmSize = sizeof(DEVMODEA);
        if (pdm32->dmSize > sizeof(DEVMODEW))
        {
            pdm16->dmSize += pdm32->dmSize - sizeof(DEVMODEW);
        }

        //  Copy the extra driver bytes
        memcpy(((BYTE*)pdm16) + pdm16->dmSize, ((BYTE*)pdm32) + pdm32->dmSize,
               pdm32->dmDriverExtra);

        cbOffset += pdm16->dmSize + pdm16->dmDriverExtra;
    }

    //  Finally, set pdvtd16's size
    pdvtd16->tdSize = cbOffset;

ErrRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT UtConvertDvtd32toDvtd16 (%lx)\n",
                            NULL, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given a string length, and two pointers (one ANSI, one
//              OLESTR), returns the UNICODE version of whichever string
//              is valid.
//
//  Effects:    Memory is allocated on the caller's pointer for new OLESTR
//
//  Arguments:  [ulLength]      -- length of string in CHARACTERS (not bytes)
//                                 (including terminator)
//              [szANSI]        -- candidate ANSI string
//              [szOLESTR]      -- candidate OLESTR string
//              [pstr]          -- OLESTR OUT parameter
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//              E_ANSITOUNICODE      if ANSI cannot be converted to UNICODE
//
//  Algorithm:  If szOLESTR is available, a simple copy is performed
//              If szOLESTR is not available, szANSI is converted to UNICODE
//              and the result is copied.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//  Notes:      Only one of the two input strings (ANSI or UNICODE) should
//              be set on entry.
//
//--------------------------------------------------------------------------

INTERNAL UtGetUNICODEData
    ( ULONG      ulLength,
      LPSTR      szANSI,
      LPOLESTR   szOLESTR,
      LPOLESTR * pstr )
{
    VDATEHEAP();

    // This fn is only called when one of the input strings
    // has valid data... assert the impossible.

    Win4Assert(pstr);		    // must have an out string
    Win4Assert(ulLength);	    // must have a non-zero length
    Win4Assert(szANSI || szOLESTR); // must have at least one source string

    // If neither the ANSI nor the OLESTR version has data,
    // there is nothing to return.

    if (!(szANSI || szOLESTR))
    {
        *pstr = NULL;
    }

    // Allocate memory for the UNICODE return string

    *pstr = (LPOLESTR) PubMemAlloc((ulLength+1) * sizeof(OLECHAR));
    if (NULL == *pstr)
    {
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Trivial case: we already have UNICODE, just copy it
    if (szOLESTR)
    {
        _xstrcpy(*pstr, szOLESTR);
        return(NOERROR);
    }

    // Otherwise, we have to convert the ANSI string to UNICODE
    // and return that.

    else
    {
        if (FALSE == MultiByteToWideChar(CP_ACP,    // Code page ANSI
                                              0,    // Flags (none)
                                         szANSI,    // Source ANSI str
                                       ulLength,    // length of string
                                          *pstr,    // Dest UNICODE buffer
                                       ulLength  )) // size of UNICODE buffer
        {
            PubMemFree(*pstr);
            *pstr = NULL;
            return ResultFromScode(E_UNSPEC);
        }
    }
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtPutUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given an OLESTR and two possible buffer pointer, one ANSI
//              and the other OLESTR, this fn tries to convert the string
//              down to ANSI.  If it succeeds, it allocates memory on the
//              ANSI ptr for the result.  If it fails, it allocates memory
//              on the UNICODE ptr and copies the input string over.  The
//              length of the final result (ANSI or UNICODE) is returned
//              in dwResultLen.
//
//  Arguments:  [ulLength]      -- input length of OLESTR str
//				   NB!!!! this value must include the
//				   null terminator character.
//              [str]           -- the OLESTR to store
//              [pszANSI]       -- candidate ANSI str ptr
//              [pszOLESTR]     -- candidate OLESTR str ptr.  May be NULL,
//				   in which case no copy is made of the
//				   original string if the ANSI conversion
//				   fails.
//              [pdwResultLen]  -- where to store the length of result.  This
//				   length includes the terminating NULL.
//				   Length is in CHARACTERS.
//
//  Returns:    NOERROR            on success
//              E_OUTOFMEMORY      on allocation failure
//		E_FAIL		   can't convert ANSI string and no
//				   pszOLESTR is NULL
//
//  History:    dd-mmm-yy Author    Comment
//		10-Jun-94 alexgo    allow pszOLESTR to be NULL
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

// this function is poorly coded. But, it looks like it only gets called when a 1.0 
// clip format is needed.  That is not very often!

INTERNAL UtPutUNICODEData
    ( ULONG        ulLength,
      LPOLESTR     str,
      LPSTR      * pszANSI,
      LPOLESTR   * pszOLESTR,
      DWORD      * pdwResultLen )
{
    VDATEHEAP();

    Win4Assert(pszANSI);
    Win4Assert(str);
    Win4Assert(pdwResultLen);
    Win4Assert(ulLength);

    // Free any strings currently attached to these pointers; if we wind
    // up setting one here, we can't leave the other valid.

    if (*pszANSI)
    {
        PubMemFree(*pszANSI);
        *pszANSI = NULL;
    }
    if (pszOLESTR && *pszOLESTR)
    {
        PubMemFree(*pszOLESTR);
        *pszOLESTR = NULL;
    }

    // Create a working buffer for UNICODE->ANSI conversion
    LPSTR szANSITEMP = (LPSTR) PubMemAlloc((ulLength+1) * 2);
    if (NULL == szANSITEMP)
    {
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Try to convert the UNICODE down to ANSI.  If it succeeds,
    // we just copy the result to the ANSI dest.  If it fails,
    // we copy the UNICODE version direct to the UNICODE dest.

    LPCSTR pDefault = "?";
    BOOL   fUseDef  = 0;

    if (FALSE == WideCharToMultiByte (CP_ACP,
                                           0,
                                         str,
                                    ulLength,
                                  szANSITEMP,
                          (ulLength + 1) * 2,
                                    pDefault,
                                     &fUseDef) || fUseDef )
    {
        // UNICODE->ANSI failed!

        // Won't be needing the ANSI buffer anymore...
        PubMemFree(szANSITEMP);

	if( pszOLESTR )
	{
	    *pszANSI = NULL;
	    *pszOLESTR = (LPOLESTR) PubMemAlloc((ulLength + 1) * sizeof(OLECHAR));
	    if (NULL == *pszOLESTR)
	    {
		*pdwResultLen = 0;
		return ResultFromScode(E_OUTOFMEMORY);
	    }
	    // Move the UNICODE source to UNICODE dest
	    _xstrcpy(*pszOLESTR, str);
	    *pdwResultLen = _xstrlen(str) + 1;

	    // That's it... return success
	    return(NOERROR);
	}
	else
	{
            return ResultFromScode(E_FAIL);
	}
    }

    // This code path is taken when the conversion to ANSI was
    // successful.  We copy the ANSI result to the ANSI dest.

    if( pszOLESTR )
    {
	*pszOLESTR = NULL;
    }

    *pdwResultLen = (DWORD) strlen(szANSITEMP) + 1;
    *pszANSI = (LPSTR) PubMemAlloc(*pdwResultLen);
    if (NULL == *pszANSI)
    {
        *pdwResultLen = 0;
        return ResultFromScode(E_OUTOFMEMORY);
    }
    strcpy(*pszANSI, szANSITEMP);

    PubMemFree(szANSITEMP);

    return(NOERROR);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSafeRefCount::SafeRefCount()
//
//  Purpose:    CSafeRefCount implements reference counting rules for objects.
//              It keeps track of reference count and zombie state.
//              It helps object manage their liveness properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Rewritten to handle aggregation
//
//--------------------------------------------------------------------------
ULONG CSafeRefCount::SafeRelease()
{
    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &m_cRefs);        
    // Check if this is the last release
    if(cRefs == 0) {
        // As this function is reentrant on the current
        // thread, gaurd against double destruction
        if(!m_fInDelete) {
            // There are no race conditions here
            // Mark object as in destructor
            m_fInDelete = TRUE;
            
            // Here is the need for the destructor to be virtual
            delete this;
        }
    }

    return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRefExportCount::SafeRelease
//
//  Purpose:    CRefExportCount implements reference counting rules for server
//              objects that export their nested objects on behalf of their
//              clients like DEFHANDLER abd CACHE. It keeps track of 
//              reference count, export count, zombie state, etc.
//              It helps object manage their shutdown logic properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Creation
//
//--------------------------------------------------------------------------
ULONG CRefExportCount::SafeRelease()
{
    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &m_cRefs);
    // Check if ref count has become zero
    if(cRefs == 0) {
        // As this function is reentrant on the current
        // thread, gaurd against double destruction
        if(!m_IsZombie) {
            // There are no race conditions here
            // Mark object as a zombie
            m_IsZombie = TRUE;
            
            // Call cleanup function while destruction is not allowed
            CleanupFn();

            // Allow destruction
            InterlockedExchange((LONG *) &m_Status, KILL);

            // Check for any exported objects
            if(m_cExportCount == 0) {
                // Gaurd against double destruction
                if(InterlockedExchange((LONG *) &m_Status, DEAD) == KILL) {
                    // Here is the need for the destructor to be virtual
                    delete this;
                }
            }
        }
    }

    return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRefExportCount::DecrementExportCount
//
//  Purpose:    CRefExportCount implements reference counting rules for server
//              objects that export their nested objects on behalf of their
//              clients like DEFHANDLER abd CACHE. It keeps track of 
//              reference count, export count, zombie state, etc.
//              It helps object manage their shutdown logic properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Creation
//
//--------------------------------------------------------------------------
ULONG CRefExportCount::DecrementExportCount()
{
    ULONG cExportCount;

    // Decrement export count 
    cExportCount = InterlockedDecrement((LONG *) &m_cExportCount);
    // Check if the export count has become zero
    if(cExportCount == 0) {
        // Check if destruction is allowed
        if(m_Status == KILL) {
            // Gaurd against double destruction
            if(InterlockedExchange((LONG *) &m_Status, DEAD) == KILL) {
                // Here is the need for the destructor to be virtual
                delete this;
            }
        }
    }

    return cExportCount;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CThreadCheck::VerifyThreadId
//
//  Synopsis: 	makes sure that the calling thread is the same as the thread
//		the object was created on if the threading model is *not*
//		free threading.
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns:  	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CThreadCheck::VerifyThreadId( void )
{
    if( m_tid == GetCurrentThreadId() )
    {
	return TRUE;
    }
    else
    {
	LEDebugOut((DEB_ERROR, "ERROR!: Called on thread %lx, should be"
	    " %lx \n", GetCurrentThreadId(), m_tid));
	return FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CThreadCheck::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
#ifdef _DEBUG

HRESULT CThreadCheck::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Thread ID = "  << m_tid << endl;

    // clean up and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif //_DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCThreadCheck, public (_DEBUG only)
//
//  Synopsis:   calls the CThreadCheck::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pTC]           - pointer to CThreadCheck
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCThreadCheck(CThreadCheck *pTC, ULONG ulFlag, int nIndentLevel)
{
    char *pszDump;
    HRESULT hresult;

    if (pTC == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pTC->Dump( &pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\api.h ===
/****************************************************************************
                   Metafile Import Filter; Interface
*****************************************************************************

   This file contains the interface for the QuickDraw import filter 
   that reads Mac pictures from disk and/or memory.  In addition to the
   Aldus filter interface, it also supports a parameterized interface
   for Microsoft applications to control some conversion results.

****************************************************************************/

/*--- Aldus-defined file access block ---*/

typedef DWORD FILETYPE;

typedef struct 
{
   unsigned slippery : 1;  /* TRUE if file may disappear. */
   unsigned write : 1;     /* TRUE if open for write. */
   unsigned unnamed : 1;   /* TRUE if unnamed. */
   unsigned linked : 1;    /* Linked to an FS FCB. */
   unsigned mark : 1;      /* Generic mark bit. */
   FILETYPE fType;         /* The file type. */
#define IBMFNSIZE 124
   short    handle;        /* MS-DOS open file handle. */
   char     fullName[IBMFNSIZE]; /* Device, path, file names. */
   DWORD    filePos;    /* Our current file posn. */
} FILESPEC, FAR *LPFILESPEC;


/*--- Preferences memory block ---*/

typedef struct                   // "old" version 1 USERPREFS
{
   char     signature[6];
   WORD     version;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     charLock;
   BYTE     nonRectRegionAction;
   BOOL     PICTinComment;
   BOOL     optimizePP;
   WORD     lineClipWidthThreshold;
   WORD     reserved[6];   
} USERPREFS_V1, FAR *LPUSERPREFS_V1;


typedef struct                   // current version 3 USERPREFS
{
   char     signature[6];
   WORD     version;
   WORD     size;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     nonRectRegionAction;
   BOOL     optimizePP;
   BYTE     noRLE;         // new (split out from reserved[0] of version 2)
   BYTE     reservedByte;  // rest of first reserved word
   WORD     reserved[5];

} USERPREFS, FAR * LPUSERPREFS;


/*********************** Exported Function Definitions **********************/

#ifdef WIN32
int WINAPI GetFilterInfo( short PM_Version, LPSTR lpIni, 
                          HANDLE FAR * lphPrefMem, 
                          HANDLE FAR * lphFileTypes );
#else
int FAR PASCAL GetFilterInfo( short PM_Version, LPSTR lpIni, 
                              HANDLE FAR * lphPrefMem, 
                              HANDLE FAR * lphFileTypes );
#endif
/* Returns information about this filter. 
   Input parameters are PM_Version which is the filter interface version#
         and lpIni which is a copy of the win.ini entry
   Output parameters are lphPrefMem which is a handle to moveable global
         memory which will be allocated and initialized.
         lphFileTypes is a structure that contains the file types
         that this filter can import. (For MAC only)
   This routine should be called once, just before the filter is to be used
   the first time. */


#ifdef WIN32
void WINAPI GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#else
void FAR PASCAL GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#endif
/* Input parameters are hInst (in order to access resources), hWnd (to
   allow the DLL to display a dialog box), and hPrefMem (memory allocated
   in the GetFilterInfo() entry point).  WFlags is currently unused, but
   should be set to 1 for Aldus' compatability */


#ifdef WIN32
short WINAPI ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                       PICTINFO FAR * lpPict, HANDLE hPrefMem );
#else
short FAR PASCAL ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                           PICTINFO FAR * lpPict, HANDLE hPrefMem );
#endif
/* Import the metafile in the file indicated by the lpFileSpec. The 
   metafile generated will be returned in lpPict. */


#ifdef WIN32
short WINAPI ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                               PICTINFO FAR * lpPict, HANDLE hPrefMem,
                               DWORD dwSize, LPSTR lpMetafileName );
#else
short FAR PASCAL ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                                   PICTINFO FAR * lpPict, HANDLE hPrefMem,
                                   DWORD dwSize, LPSTR lpMetafileName );
#endif
/* Import the metafile in using the previously opened file handle in
   the structure field lpFileSpec->handle. Reading begins at offset
   lpFileSpect->filePos, and the convertor will NOT expect to find the
   512 byte PICT header.  The metafile generated will be returned in
   lpPict and can be specified via lpMetafileName (NIL = memory metafile,
   otherwise, fully qualified filename. */

#ifdef WIN32
short WINAPI QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#else
short FAR PASCAL QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#endif
/* Import the metafile as specified using the parameters supplied in the
   lpPrefMem.  The metafile will be returned in lpPict. */

#ifdef WIN32
BOOL LibMain( HINSTANCE hInst, DWORD fdwReason, LPVOID lpvReserved);
#else
int FAR PASCAL LibMain( HANDLE hInst, WORD wDataSeg, WORD cbHeap,
                        LPSTR lpszCmdline );
#endif
/* Needed to get an instance handle */

#ifdef WIN32
int WINAPI WEP( int nParameter );
#else
int FAR PASCAL WEP( int nParameter );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\utstream.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		utstream.cpp
//
//	Contents:
//		Ole stream utilities
//
//	Classes:
//
//	Functions:
//
//	History:
//		10-May-94 KevinRo   Added ansi versions of StringStream stuff
//		25-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocations.
//		01/11/94 - alexgo  - added VDATEHEAP macros to every function
//		12/07/93 - ChrisWe - file inspection and cleanup; fixed
//			String reading and writing to cope with OLESTR, and
//			with differing alignment requirements
//		06/23/93 - SriniK - moved ReadStringStream(),
//			WriteStringStream(), and OpenOrCreateStream() here
//			from api.cpp and ole2.cpp
//		03/14/92 - SriniK - created
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(utstream)

#include <reterr.h>
#include <limits.h>

NAME_SEG(UtStream)
ASSERTDATA

// this constant is used to size string buffers when we attempt to write out
// a string and its length in one write call
#define UTSTRINGBUF_SIZE 100

// REVIEW, I thought that OpenStream already had an option to do this.  If
// so, this function shouldn't be used in our code.  But we can't remove it
// because it is exported to the outside.
// this is exported to the outside
#pragma SEG(OpenOrCreateStream)
STDAPI OpenOrCreateStream(IStorage FAR * pstg, LPCOLESTR pwcsName,
		IStream FAR* FAR* ppstm)
{
	VDATEHEAP();

	HRESULT error;

	error = pstg->CreateStream(pwcsName, STGM_SALL | STGM_FAILIFTHERE,
			0, 0, ppstm);
	if (GetScode(error) == STG_E_FILEALREADYEXISTS)
		error = pstg->OpenStream(pwcsName, NULL, STGM_SALL, 0, ppstm);

	return(error);
}

// returns S_OK when string read and allocated (even if zero length)
STDAPI ReadStringStream(CStmBufRead & StmRead, LPOLESTR FAR * ppsz)
{
	VDATEHEAP();

	ULONG cb; // the length of the string in *bytes* (NOT CHARACTERS)
	HRESULT hresult;
	
	// initialize the the string pointer for error returns
	*ppsz = NULL;

        if ((hresult = StmRead.Read((void FAR *)&cb, sizeof(ULONG))) != NOERROR)
		return hresult;

	// is string empty?
	if (cb == 0)
		return(NOERROR);

	// allocate memory to hold the string
	if (!(*ppsz = (LPOLESTR)PubMemAlloc(cb)))
		return(ReportResult(0, E_OUTOFMEMORY, 0, 0));

	// read the string; this includes a trailing NULL
        if ((hresult = StmRead.Read((void FAR *)(*ppsz), cb)) != NOERROR)
		goto errRtn;
	
	return(NOERROR);

errRtn:	
	// delete the string, and return without one
	PubMemFree(*ppsz);
	*ppsz = NULL;
	return(hresult);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadStringStreamA
//
//  Synopsis:   Read a ANSI stream from the stream
//
//  Effects:
//
//  Arguments:  [pstm] -- Stream to read from
//		[ppsz] -- Output pointer
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//              2-20-95   KentCe    Converted to buffer stream reads.
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadStringStreamA(CStmBufRead & StmRead, LPSTR FAR * ppsz)
{
	VDATEHEAP();

	ULONG cb; // the length of the string in *bytes* (NOT CHARACTERS)
	HRESULT hresult;
	
	// initialize the the string pointer for error returns
	*ppsz = NULL;

        if ((hresult = StmRead.Read((void FAR *)&cb, sizeof(ULONG))) != NOERROR)
		return hresult;

	// is string empty?
	if (cb == 0)
		return(NOERROR);

	// allocate memory to hold the string
	if (!(*ppsz = (LPSTR)PubMemAlloc(cb)))
		return(ReportResult(0, E_OUTOFMEMORY, 0, 0));

	// read the string; this includes a trailing NULL
        if ((hresult = StmRead.Read((void FAR *)(*ppsz), cb)) != NOERROR)
		goto errRtn;
	
	return(NOERROR);

errRtn:	
	// delete the string, and return without one
	PubMemFree(*ppsz);
	*ppsz = NULL;
	return(hresult);
}


// this is exported to the outside
STDAPI WriteStringStream(CStmBufWrite & StmWrite, LPCOLESTR psz)
{
	VDATEHEAP();

	HRESULT error;
	ULONG cb; // the count of bytes (NOT CHARACTERS) to write to the stream

	// if the string pointer is NULL, use zero length
	if (!psz)
		cb = 0;
	else
	{
		// count is length of string, plus terminating null
		cb = (1 + _xstrlen(psz))*sizeof(OLECHAR);

		// if possible, do a single write instead of two
		
		if (cb <= UTSTRINGBUF_SIZE)
		{
			BYTE bBuf[sizeof(ULONG)+
					UTSTRINGBUF_SIZE*sizeof(OLECHAR)];
					// buffer for count and string
		
			// we have to use _xmemcpy to copy the length into
			// the buffer to avoid potential boundary faults,
			// since bBuf might not be aligned strictly enough
			// to do *((ULONG FAR *)bBuf) = cb;
			_xmemcpy((void FAR *)bBuf, (const void FAR *)&cb,
					sizeof(cb));
			_xmemcpy((void FAR *)(bBuf+sizeof(cb)),
					(const void FAR *)psz, cb);
			
			// write contents of buffer all at once
                        return( StmWrite.Write((VOID FAR *)bBuf,
                                        cb+sizeof(ULONG)));
		}
	}

	// if we got here, our buffer isn't large enough, so we do two writes
	// first, write the length
        if (error = StmWrite.Write((VOID FAR *)&cb, sizeof(ULONG)))
		return error;
	
	// are we are done writing the string?
	if (psz == NULL)
		return NOERROR;
		
	// write the string
        return(StmWrite.Write((VOID FAR *)psz, cb));
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteStringStreamA
//
//  Synopsis:   Writes an ANSI string to a stream in a length prefixed format.
//
//  Effects:
//
//  Arguments:  [pstm] -- Stream
//		[psz] -- Ansi string to write
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//              2-20-95   KentCe    Converted to buffer stream writes.
//
//  Notes:
//
//----------------------------------------------------------------------------
FARINTERNAL_(HRESULT) WriteStringStreamA(CStmBufWrite & StmWrite, LPCSTR psz)
{
	VDATEHEAP();

	HRESULT error;
	ULONG cb; // the count of bytes (NOT CHARACTERS) to write to the stream

	// if the string pointer is NULL, use zero length
	if (!psz)
		cb = 0;
	else
	{
		// count is length of string, plus terminating null
		cb = (ULONG) (1 + strlen(psz));

		// if possible, do a single write instead of two
		
		if (cb <= UTSTRINGBUF_SIZE)
		{
			BYTE bBuf[sizeof(ULONG)+
					UTSTRINGBUF_SIZE];
					// buffer for count and string
		
			// we have to use _xmemcpy to copy the length into
			// the buffer to avoid potential boundary faults,
			// since bBuf might not be aligned strictly enough
			// to do *((ULONG FAR *)bBuf) = cb;
			_xmemcpy((void FAR *)bBuf, (const void FAR *)&cb,
					sizeof(cb));
			_xmemcpy((void FAR *)(bBuf+sizeof(cb)),
					(const void FAR *)psz, cb);
			
			// write contents of buffer all at once
                        return(StmWrite.Write((VOID FAR *)bBuf,
                                        cb+sizeof(ULONG)));
		}
	}

	// if we got here, our buffer isn't large enough, so we do two writes
	// first, write the length
        if (error = StmWrite.Write((VOID FAR *)&cb, sizeof(ULONG)))
		return error;
	
	// are we are done writing the string?
	if (psz == NULL)
		return NOERROR;
		
	// write the string
        return(StmWrite.Write((VOID FAR *)psz, cb));
}

//+-------------------------------------------------------------------------
//
//  Function:   StRead
//
//  Synopsis:   Stream read that only succeeds if all requested bytes read
//
//  Arguments:  [pStm]     -- source stream
//              [pvBuffer] -- destination buffer
//              [ulcb]     -- bytes to read
//
//  Returns:    S_OK if successful, else error code
//
//  Algorithm:
//
//  History:    18-May-94 AlexT     Added header block, fixed S_FALSE case
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(StRead)
FARINTERNAL_(HRESULT) StRead(IStream FAR * pStm, LPVOID pvBuffer, ULONG ulcb)
{
	VDATEHEAP();

	HRESULT hr;
	ULONG cbRead;

	hr = pStm->Read(pvBuffer, ulcb, &cbRead);
        if (FAILED(hr))
        {
            return(hr);
        }

        if (ulcb == cbRead)
        {
            return(S_OK);
        }

        //  We got a success code but not enough bytes - turn it into an error

        return(STG_E_READFAULT);
}


// if fRelative is FALSE then dwSize is the size of the stream
// if it is TRUE then find the current seek position and add dwSize to that
// and then set it as the stream size.
FARINTERNAL StSetSize(LPSTREAM pstm, DWORD dwSize, BOOL fRelative)
{
	VDATEHEAP();

	LARGE_INTEGER large_int; // indicates where to seek to
	ULARGE_INTEGER ularge_int; // indicates absolute position
	ULARGE_INTEGER ularge_integer; // the size we will set for the stream
	HRESULT error;
	
	LISet32(large_int, 0);
	ULISet32(ularge_integer, dwSize);
	
	if (fRelative)
	{
		if (error = pstm->Seek(large_int, STREAM_SEEK_CUR, &ularge_int))
			return(error);
		
		// REVIEW: is there a routine to do 64 bit addition ???
		ularge_integer.LowPart += ularge_int.LowPart;
	}

	return(pstm->SetSize(ularge_integer));
}	


// REVIEW, is this actually used?
#pragma SEG(StSave10NativeData)
FARINTERNAL_(HRESULT) StSave10NativeData(IStorage FAR* pstgSave,
		HANDLE hNative, BOOL fIsOle1Interop)
{
	VDATEHEAP();

	DWORD dwSize;
	HRESULT error;

	if (!hNative)
		return ReportResult(0, E_UNSPEC, 0, 0);

	if (!(dwSize = (ULONG) GlobalSize (hNative)))
		return ReportResult(0, E_OUTOFMEMORY, 0, 0);

#ifdef OLE1INTEROP
	if ( fIsOle1Interop )
    {
		LPLOCKBYTES plkbyt;
		LPSTORAGE   pstgNative= NULL;
		const DWORD grfStg = STGM_READWRITE | STGM_SHARE_EXCLUSIVE
									| STGM_DIRECT ;

		if ((error = CreateILockBytesOnHGlobal (hNative, FALSE, &plkbyt))!=NOERROR)
			goto errRtn;

		if ((error = StgOpenStorageOnILockBytes (plkbyt, (LPSTORAGE)NULL, grfStg,
									(SNB)NULL, 0, &pstgNative)) != NOERROR){
			error = ReportResult(0, E_OUTOFMEMORY, 0, 0);
			plkbyt->Release();
            goto errRtn;
		}

		pstgNative->CopyTo (0, NULL, 0, pstgSave);
		plkbyt->Release();
		pstgNative->Release();
	}
	else
#endif
	{
		LPSTREAM   	lpstream = NULL;

		if (error = OpenOrCreateStream(pstgSave, OLE10_NATIVE_STREAM, &lpstream))
			goto errRtn;

		if (error = StWrite(lpstream, &dwSize, sizeof(DWORD))) {
			lpstream->Release();
			goto errRtn;
		}
	
		error = UtHGLOBALtoStm(hNative, dwSize, lpstream);
		
		lpstream->Release();
	}

errRtn:
	return error;
}



#pragma SEG(StSave10ItemName)
FARINTERNAL StSave10ItemName
	(IStorage FAR* pstg,
	LPCSTR szItemNameAnsi)
{
	VDATEHEAP();

        CStmBufWrite StmWrite;
        HRESULT      hresult;


        if ((hresult = StmWrite.OpenOrCreateStream(pstg, OLE10_ITEMNAME_STREAM))
		!= NOERROR)
	{
		return hresult;
	}

        hresult = WriteStringStreamA(StmWrite, szItemNameAnsi);
        if (FAILED(hresult))
        {
            goto errRtn;
        }

        hresult = StmWrite.Flush();

errRtn:
        StmWrite.Release();

	return hresult;
}


#pragma SEG(StRead10NativeData)
FARINTERNAL StRead10NativeData
	(IStorage FAR*  pstg,
	HANDLE FAR* 	phNative)
{
DWORD		dwSize;
LPSTREAM   	pstream = NULL;
HRESULT		hresult;
HANDLE hBits = NULL;
void FAR *lpBits = NULL;

    
    VDATEHEAP();


    *phNative = NULL;
    
    RetErr (pstg->OpenStream (OLE10_NATIVE_STREAM, NULL, STGM_SALL, 0, &pstream));
    ErrRtnH (StRead (pstream, &dwSize, sizeof (DWORD)));

    // initialize this for error return cases
    // allocate a new handle
    if (!(hBits = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize)) // going to pass this to DDE.
		    || !(lpBits = (BYTE *)GlobalLock(hBits)))
    {
	hresult = ResultFromScode(E_OUTOFMEMORY);
	goto errRtn;
    }
    
    // read the stream into the allocated memory
    if (hresult = StRead(pstream, lpBits, dwSize))
	    goto errRtn;
    
    // if we got this far, return new handle
    *phNative = hBits;

errRtn:
    // unlock the handle, if it was successfully locked
    if (lpBits)
	    GlobalUnlock(hBits);

    // free the handle if there was an error
    if ((hresult != NOERROR) && hBits)
	    GlobalFree(hBits);

    if (pstream)
	    pstream->Release();

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBuf::CStmBuf, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CStmBuf::CStmBuf(void)
{
    m_pStm = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBuf::~CStmBuf, public
//
//  Synopsis:   Destructor.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CStmBuf::~CStmBuf(void)
{
    //
    //  Verify that the programmer released the stream interface.
    //
    Assert(m_pStm == NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Init, public
//
//  Synopsis:   Define the stream interface to read from.
//
//  Arguments:  [pstm] -- Pointer to stream to read.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
void CStmBufRead::Init(IStream * pstm)
{
    Assert(m_pStm == NULL);

    m_pStm = pstm;

    m_pStm->AddRef();

    Reset();
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::OpenStream, public
//
//  Synopsis:   Open a stream for reading.
//
//  Arguments:  [pstg]     -- Pointer to storage that contains stream to open.
//              [pwcsName] -- Name of stream to open.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
HRESULT CStmBufRead::OpenStream(IStorage * pstg, const OLECHAR * pwcsName)
{
    VDATEHEAP();
    HRESULT hr;


    Assert(m_pStm == NULL);

    hr = pstg->OpenStream(pwcsName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, 0,
            &m_pStm);

    Reset();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Read, public
//
//  Synopsis:   Read data from the stream.
//
//  Arguments:  [pBuf] - Address to store read bytes in.
//              [cBuf] - Maximum number of bytes to read.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufRead::Read(PVOID pBuf, ULONG cBuf)
{
    ULONG   cnt;
    HRESULT hr;


    //
    //  While more bytes to read.
    //
    while (cBuf)
    {
        //
        //  If our buffer is empty, read more data.
        //
        if (m_cBuffer == 0)
        {
           hr = m_pStm->Read(m_aBuffer, sizeof(m_aBuffer), &m_cBuffer);
           if (FAILED(hr))
              return hr;

           if (m_cBuffer == 0)
              return STG_E_READFAULT;

           m_pBuffer = m_aBuffer;
        }

        //
        //  Determine number of bytes to read.
        //
        cnt = min(m_cBuffer, cBuf);

        //
        //  Copy the input from the input buffer, update variables.
        //
        memcpy(pBuf, m_pBuffer, cnt);
        pBuf = (PBYTE)pBuf + cnt;
        cBuf   -= cnt;
        m_pBuffer += cnt;
        m_cBuffer -= cnt;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::ReadLong, public
//
//  Synopsis:   Read a long value from the stream.
//
//  Arguments:  [plValue] - Address of long to fill.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufRead::ReadLong(LONG * plValue)
{
    return Read(plValue, sizeof(LONG));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Reset
//
//  Synopsis:   Reset buffer variables.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufRead::Reset(void)
{
    m_pBuffer = m_aBuffer;
    m_cBuffer = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Release, public
//
//  Synopsis:   Release read stream interface.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufRead::Release()
{
    if (m_pStm)
    {
       m_pStm->Release();
       m_pStm = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Init, public
//
//  Synopsis:   Define the stream interface to write to.
//
//  Arguments:  [pstm] -- Pointer to stream to write.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
void CStmBufWrite::Init(IStream * pstm)
{
    Assert(m_pStm == NULL);

    m_pStm = pstm;

    m_pStm->AddRef();

    Reset();
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::OpenOrCreateStream, public
//
//  Synopsis:   Open/Create a stream for writing.
//
//  Arguments:  [pstg]     -- Pointer to storage that contains stream to open.
//              [pwcsName] -- Name of stream to open.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::OpenOrCreateStream(IStorage * pstg,
        const OLECHAR * pwcsName)
{
    VDATEHEAP();
    HRESULT hr;


    hr = pstg->CreateStream(pwcsName, STGM_SALL | STGM_FAILIFTHERE, 0, 0,
            &m_pStm);

    if (hr == STG_E_FILEALREADYEXISTS)
    {
        hr = pstg->OpenStream(pwcsName, NULL, STGM_SALL, 0, &m_pStm);
    }

    Reset();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::CreateStream, public
//
//  Synopsis:   Create a stream for writing.
//
//  Arguments:  [pstg]     -- Pointer storage that contains stream to create.
//              [pwcsName] -- Name of stream to create.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::CreateStream(IStorage * pstg, const OLECHAR * pwcsName)
{
    VDATEHEAP();

    HRESULT hr;


    hr = pstg->CreateStream(pwcsName, STGM_CREATE | STGM_READWRITE |
            STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStm);

    Reset();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Write, public
//
//  Synopsis:   Write data to the stream.
//
//  Arguments:  [pBuf] - Address to store write bytes to.
//              [cBuf] - Maximum number of bytes to write.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::Write(void const * pBuf, ULONG cBuf)
{
    ULONG   cnt;
    HRESULT hr;


    //
    //  Keep writing until the caller's buffer is empty.
    //
    while (cBuf)
    {
        //
        //  Compute the number of bytes to copy.
        //
        cnt = min(m_cBuffer, cBuf);

        //
        //  Copy to the internal write buffer and update variables.
        //
        memcpy(m_pBuffer, pBuf, cnt);
        pBuf = (PBYTE)pBuf + cnt;
        cBuf   -= cnt;
        m_pBuffer += cnt;
        m_cBuffer -= cnt;

        //
        //  On full internal buffer, flush.
        //
        if (m_cBuffer == 0)
        {
            LEDebugOut((DEB_WARN, "WARNING: Multiple buffer flushes.\n"));

            hr = Flush();
            if (FAILED(hr))
            {
                return hr;
            }
        }
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::WriteLong, public
//
//  Synopsis:   Write long value to the stream.
//
//  Arguments:  [lValue] - Long value to write.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::WriteLong(LONG lValue)
{
    return Write(&lValue, sizeof(LONG));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Flush, public
//
//  Synopsis:   Flush write buffer to the system.
//
//  Arguments:  None.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Performs a write of the stream buffer to the system, does not
//              force a flush to disk.
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::Flush(void)
{
    ULONG   cnt;
    HRESULT hr;


    //
    //  This might be an overactive assert, but shouldn't happen.
    //
    Assert(m_cBuffer != sizeof(m_aBuffer));

    hr = m_pStm->Write(m_aBuffer, sizeof(m_aBuffer) - m_cBuffer, &cnt);
    if (FAILED(hr))
    {
        return hr;
    }

    if (cnt != sizeof(m_aBuffer) - m_cBuffer)
    {
        return STG_E_MEDIUMFULL;
    }

    Reset();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Reset, public
//
//  Synopsis:   Reset buffer variables.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufWrite::Reset(void)
{
    m_pBuffer = m_aBuffer;
    m_cBuffer = sizeof(m_aBuffer);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Release, public
//
//  Synopsis:   Release write stream interface.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufWrite::Release()
{
    if (m_pStm)
    {
       //
       //  Verify that flush was called.
       //
       Assert(m_cBuffer == sizeof(m_aBuffer));

       m_pStm->Release();
       m_pStm = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\bufio.c ===
/****************************************************************************
                       Unit Bufio; Implementation
*****************************************************************************

 Bufio implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.

 This interface will also shield the calling application from knowledge of
 the source format (file vs. memory).

   Module Prefix: IO

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  "filesys.h"

#ifndef _OLECNV32_
//#include  "status.h"
#endif  // _OLECNV32_

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

#define  UNKNOWN     0
#define  FILE        1
#define  MEMORY      2
#define  RTF         3

#define  BUFFERSIZE  1024

private  LongInt     numBytesRead;
private  LongInt     pictureSize;
private  LongInt     beginOffset;

private  LongInt     bufferCount;
private  Byte        buffer[BUFFERSIZE];
private  Byte *      nextCharPtr;
private  Byte huge * nextCharHPtr;

private  Byte        sourceType = UNKNOWN;
private  Integer     fileHandle = (Integer)0;
private  Str255      fileName;
private  Boolean     openFile;

private  Byte huge * memoryHPtr;
private  Handle      memoryHandle;

private  Handle      dialogHandle;

/*********************** Private Function Definitions ***********************/

private void ReadNextBuffer( void );
/* Replenish the i/o buffer with the next set of characters */

/* Memory operations - check return values on usage */
#define MDisposHandle( h )      ((void) GlobalFree( h ))
#define MLock( h )              ((LPtr) GlobalLock( h ))
#define MUnlock( h )            ((void) GlobalUnlock( h ))
#define MDR( h )                ((LPtr) GlobalLock( h ))
#define MUR( h )                ((void) GlobalUnlock( h ))
#define MNewHandle( s )         GlobalAlloc( GMEM_MOVEABLE, s )

/*********************** Function Implementation ****************************/

void IOGetByte( Byte far * byteLPtr )
/*============*/
/* Read a byte from the input stream.  If the buffer is empty, then
   it is replenished. */
{
   /* Make sure that no global error code has been set before read */
   if (ErGetGlobalError() != NOERR )
   {
      *byteLPtr = 0;
      return;
   }

   /* Check for an attempt to read past the EOF or memory block.  This
      would indicate that the opcode parsing was thrown off somewhere. */
   if (numBytesRead >= pictureSize)
   {
      ErSetGlobalError( ErReadPastEOF );
      *byteLPtr = 0;
      return;
   }

   /* Check to see if we need to replenish the read buffer */
   if (bufferCount <= 0)
   {
      ReadNextBuffer();
   }

   /* Decrement the count of characters in the buffer, increment the total
      number of bytes read from the file, and return the next character. */
   bufferCount--;
   numBytesRead++;

   /* determine where to read the next byte from - use short or huge ptrs */
   *byteLPtr = (sourceType == FILE) ? *nextCharPtr++ : *nextCharHPtr++;

}  /* IOGetByte */



void IOSkipBytes( LongInt byteCount )
/*==============*/
/* Skip the designated number of bytes */
{
   /* make sure we are skipping a valid number of bytes */
   if (byteCount <= 0)
   {
      return;
   }

   /* Check for an attempt to read past the EOF or memory block.  This
      would indicate that the opcode parsing was thrown off somewhere. */
   if (numBytesRead + byteCount >= pictureSize)
   {
      ErSetGlobalError( ErReadPastEOF );
   }
   else
   {
      /* determine if there are sufficient bytes remaining in the buffer */
      if (bufferCount >= byteCount)
      {
         /* decrement # bytes remaining, increment # bytes read and pointer */
         bufferCount  -= byteCount;
         numBytesRead += byteCount;

         /* increment the appropriate pointer based on media type */
         if (sourceType == FILE)
         {
            /* increment near pointer to data segment buffer */
            nextCharPtr += byteCount;
         }
         else
         {
            /* increment huge pointer to global memory block */
            nextCharHPtr += byteCount;
         }
      }
      else /* sourceType == FILE and buffer needs to be replenished */
      {
         Byte     unusedByte;

         /* continue calling IOGetByte() until desired number are skipped */
         while (byteCount--)
         {
            /* call IOGetByte to make sure the cache is replenished */
            IOGetByte( &unusedByte );
         }
      }
   }

}  /* IOSkipBytes */



void IOAlignToWordOffset( void )
/*======================*/
/* Align next memory read to Word boundary. */
{
   /* check to see if we have read an odd number of bytes so far.  Skip
      the ensuing byte if necessary to align. */
   if (numBytesRead & 0x0001)
   {
      IOSkipBytes( 1 );
   }

}  /* IOAlignToWordOffset */


#ifndef _OLECNV32_
void IOSetFileName( StringLPtr pictFileName )
/*================*/
/* Interface routine to set the source filename */
{
   lstrcpy( fileName, pictFileName );
   sourceType = FILE;
   openFile = TRUE;

}  /* IOSetFileName */

void IOSetFileHandleAndSize( Integer pictFileHandle, LongInt pictFileSize )
/*=========================*/
/* Interface routine to set the source file Handle */
{
   fileHandle = pictFileHandle;
   pictureSize = pictFileSize;
   sourceType = FILE;
   openFile = FALSE;

}  /* IOSetFIleHandle */
#endif  // !_OLECNV32_



void IOSetMemoryHandle( HANDLE pictMemoryHandle )
/*==================*/
/* Interface routine to set the source file Handle */
{
   memoryHandle = ( Handle ) pictMemoryHandle;
   sourceType = MEMORY;

}  /* IOSetMemoryHandle */



void IOSetReadOffset( LongInt readOffset )
/*==================*/
/* Set the beginning offset to seek to when the file is opened */
{
   beginOffset = readOffset;
}



void IOOpenPicture( Handle dialog )
/*================*/
/* Open the input stream depending on the source type set by a previous
   IOSet___ interface routine.  Determine the size of the picture image. */
{
#ifndef _OLECNV32_
   OSErr    openError;
#endif  // !_OLECNV32_

   /* if the type isn't set, return error */
   if (sourceType == UNKNOWN)
   {
      ErSetGlobalError( ErNoSourceFormat );
      return;
   }

   /* initialize the various reader variables */
   numBytesRead = 0;
   bufferCount = 0;

   /* determine how to open the soure data stream */
#ifndef _OLECNV32_
   if (sourceType == FILE)
   {
      /* if we are openning and converting an entire file */
      if (openFile)
      {
         /* open the file */
         openError = FSOpen( (StringLPtr)fileName, OF_READ | OF_SHARE_DENY_WRITE, &fileHandle );
         if (openError)
         {
            ErSetGlobalError( ErOpenFail);
         }
         else
         {
            /* and determine the file length */
            FSSetFPos( fileHandle, FSFROMLEOF, 0L );
            FSGetFPos( fileHandle, &pictureSize );
         }
      }

      /* set position to the designated start position */
      FSSetFPos( fileHandle, FSFROMSTART, beginOffset );
      numBytesRead = beginOffset;
   }
   else /* if (sourceType == MEMORY) */
#endif  // !_OLECNV32_
   {
      /* lock the memory block */
      memoryHPtr = (Byte huge *) MLock( memoryHandle );
      if (memoryHPtr == NULL)
      {
         ErSetGlobalError( ErMemoryFail );
         return;
      }
      else
      {
         /* and determine the overall memory block size */
         pictureSize = (ULONG) GlobalSize( memoryHandle );
      }

      /* set the huge character read pointer, bytes read, and buffer count */
      nextCharHPtr = memoryHPtr  + beginOffset;
      bufferCount  = pictureSize - beginOffset;
      numBytesRead = beginOffset;
   }

#ifndef _OLECNV32_
   /* make sure that a dialog handle was supplied for update */
   if (dialog)
   {
      /* save off the dialog box handle */
      dialogHandle = dialog;

      /* calculate the interval to update the status dialog */
      SendMessage( dialogHandle, SM_SETRANGE, 0, pictureSize );
   }
#endif  // !OLECNV32

}  /* IOOpenPicture */



void IOClosePicture( void )
/*=================*/
/* Close the source input stream */
{
   /* if this is a file-based metafile */
#ifndef _OLECNV32_
   if (sourceType == FILE)
   {
      /* make sure this isn't the ImportEmbeddedGr() entry point */
      if (openFile)
      {
         /* close the file if necessary */
         FSCloseFile( fileHandle );
         fileHandle = ( Integer ) 0;
      }
   }
   else
#endif  // !_OLECNV32_
   {
      /* unlock the global memory block */
      MUnlock( memoryHandle );
      memoryHandle = NULL;
   }

   /* de-initialize the module variables */
   sourceType = UNKNOWN;
   dialogHandle = NULL;

}  /* IOClosePicture */



void IOUpdateStatus( void )
/*=================*/
/* Update the status bar dialog to reflect current progress */
{
#ifndef _OLECNV32_
   /* update only if a dialog box was created */
   if (dialogHandle)
   {
      /* calculate the interval to update the status dialog */
      SendMessage( dialogHandle, SM_SETPOSITION, 0, numBytesRead );
   }
#endif  // !_OLECNV32_

}  /* IOUpdateStatus */



/******************************* Private Routines ***************************/


private void ReadNextBuffer( void )
/*-------------------------*/
/* Replenish the i/o buffer with the next set of characters.  This should
   only be called if performing buffered I/O - not with MEMORY-based file */
{
#ifndef _OLECNV32_
   OSErr    fileError;

   /* Read the required number of bytes from the file.  Check the error
      code return and set the global status error if the read failed. */

   if (sourceType == FILE)
   {
      /* Calculate the number of bytes that should be read into the buffer.
         This needs to be done, since this may be a memory source picture,
         in which an invalid read could produce a GP violation */
      if (numBytesRead + BUFFERSIZE > pictureSize)
         bufferCount = pictureSize - numBytesRead;
      else
         bufferCount = BUFFERSIZE;

      /* read the bytes from the file */
      fileError = FSRead( fileHandle, &bufferCount, &buffer);

      /* if there is any error, notify the error module */
      if (fileError != 0)
      {
         ErSetGlobalError( ErReadFail );
         return;
      }

      /* reset the character read pointer to the beginning of the buffer */
      nextCharPtr = buffer;
   }
#endif  // _OLECNV32_

}  /* ReadNextBuffer */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\cache.c ===
/****************************************************************************
                       Unit Cache; Implementation
*****************************************************************************

   Module Prefix: Ca

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  "cache.h"        /* own interface */

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

/*--- Gdi cache ---*/

typedef struct
{
   HPEN            handle;
   LOGPEN          logPen;
   Boolean         stockObject;

} Pen, far * PenLPtr;


typedef struct
{
   HBRUSH          handle;
   LOGBRUSH        logBrush;
   Boolean         stockObject;

} Brush, far * BrushLPtr;


typedef struct
{
   Handle          metafile;           // metafile handle

   Rect            prevClipRect;       // last cliprect before SaveDC()
   Rect            curClipRect;        // last clipping rectangle
   Boolean         forceNewClipRect;   // always emit new clipping rectangle?

   HPEN            nulPen;             // frequently used pens
   HPEN            whitePen;
   HPEN            blackPen;

   HBRUSH          nulBrush;           // frequently used brushes
   HBRUSH          whiteBrush;
   HBRUSH          blackBrush;

   Boolean         stockFont;          // current font selection
   HFONT           curFont;
   LOGFONT         curLogFont;

   Brush           curBrush;           // current pen and brush selections
   Pen             curPen;
   Pen             nextPen;            // cached frame(pen)

   CaPrimitive     nextPrim;           // cached primitive
   Boolean         samePrim;
   Handle          polyHandle;
   Integer         numPoints;
   Integer         maxPoints;
   Point far *     pointList;

   Word            iniROP2;            // initial value for ROP2 mode
   Word            iniTextAlign;       // initial value for text alignment
   Word            iniBkMode;
   RGBColor        iniTxColor;
   RGBColor        iniBkColor;

   Word            curROP2;            // current ROP codes setting
   Word            curBkMode;          // current background mode
   RGBColor        curBkColor;         // current background color
   Word            curStretchMode;     // current stretchblt mode

   RGBColor        curTextColor;       // last text color
   Word            curTextAlign;       // last text alignment value
   short           curCharExtra;       // last char extra value
   Fixed           spExtra;            // last space extra value
   Point           txNumer;            // last text scaling
   Point           txDenom;            // factors

   Boolean         restorePen;         // do any attribs need to be re-issued
   Boolean         restoreBrush;       // after RestoreDC() call?
   Boolean         restoreFont;
   Boolean         restoreCharExtra;
   Boolean         restoreStretchMode;

} GdiCache;

private  GdiCache  gdiCache;

/*********************** Private Function Definitions ***********************/

#define /* void */ NewPolygon( /* void */ )                          \
/* start a new polygon definition */                                 \
gdiCache.numPoints = 0


private void AddPolyPt( Point pt );
/* Add a point to the polygon buffer */


private void SelectCachedPen( void );
/* select the currently cached Pen into the metafile */


/*********************** Function Implementation ****************************/


void CaInit( Handle metafile )
/*=========*/
/* initialize the gdi cache module */
{
   /* save off the metafile handle into global structure */
   gdiCache.metafile = metafile;

   /* make sure that text and background colors will be set */
   gdiCache.curTextColor =
   gdiCache.curBkColor = RGB( 12, 34, 56 );

   /* get handles to some stock pen objects */
   gdiCache.nulPen = GetStockObject( NULL_PEN );
   gdiCache.whitePen = CreatePen( PS_INSIDEFRAME, 1, RGB( 255, 255, 255 ) );
   gdiCache.blackPen = CreatePen( PS_INSIDEFRAME, 1, RGB( 0, 0, 0 ) );

   /* get handles to some stock brush objects */
   gdiCache.nulBrush = GetStockObject( NULL_BRUSH );
   gdiCache.whiteBrush = GetStockObject( WHITE_BRUSH );
   gdiCache.blackBrush = GetStockObject( BLACK_BRUSH );

   /* allocate space for the polygon buffer */
   gdiCache.numPoints = 0;
   gdiCache.maxPoints = 16;
   gdiCache.polyHandle = GlobalAlloc( GHND, gdiCache.maxPoints * sizeof( Point ) );
   if (gdiCache.polyHandle == NULL)
   {
      ErSetGlobalError( ErMemoryFull);
   }
   else
   {
      /* get a pointer address for the memory block */
      gdiCache.pointList = (Point far *)GlobalLock( gdiCache.polyHandle );
   }

   /* mark the primitive cache as empty */
   gdiCache.nextPrim.type = CaEmpty;

   /* the current primitive isn't being repeated */
   gdiCache.samePrim = FALSE;

   /* turn off forcing of a new clipping rectangle */
   gdiCache.forceNewClipRect = FALSE;

}  /* CaInit */



void CaFini( void )
/*=========*/
/* close down the cache module */
{
   /* delete the current font selection if non-NULL and non-stock */
   if ((gdiCache.curFont != NULL) && !gdiCache.stockFont)
   {
      /* free the font object */
      DeleteObject( gdiCache.curFont );
   }

   /* remove the current brush selection if non-NULL and not a stock brush */
   if ((gdiCache.curBrush.handle != NULL) && !gdiCache.curBrush.stockObject)
   {
      /* see if the current brush has a DIB - if so, delete it */
      if (gdiCache.curBrush.logBrush.lbStyle == BS_DIBPATTERN)
      {
         /* free the DIB memory used for brush */
         GlobalFree( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );
      }

      /* delte the brush object */
      DeleteObject( gdiCache.curBrush.handle );
   }

   /* remove the current pen selection if non-NULL and not a stock pen */
   if ((gdiCache.curPen.handle != NULL) && !gdiCache.curPen.stockObject)
   {
      DeleteObject( gdiCache.curPen.handle );
   }

   /* Remove other pens created at initialization time */
   DeleteObject( gdiCache.whitePen );
   DeleteObject( gdiCache.blackPen );

   /* deallocate the polygon buffer */
   GlobalUnlock( gdiCache.polyHandle );
   GlobalFree( gdiCache.polyHandle );

}  /* CaFini */



void CaSetMetafileDefaults( void )
/*========================*/
/* Set up any defaults that will be used throughout the metafile context */
{
   /* set up some metafile defaults */
   gdiCache.iniTextAlign = TA_LEFT | TA_BASELINE | TA_NOUPDATECP;
   gdiCache.iniROP2 = R2_COPYPEN;
   gdiCache.iniBkMode = TRANSPARENT;
   gdiCache.iniTxColor = RGB( 0, 0, 0 );
   gdiCache.iniBkColor = RGB( 255, 255, 255 );

   /* Put the records into the metafile */
   CaSetROP2( gdiCache.iniROP2 );
   CaSetTextAlign( gdiCache.iniTextAlign );
   CaSetBkMode( gdiCache.iniBkMode );
   CaSetTextColor( gdiCache.iniTxColor );
   CaSetBkColor( gdiCache.iniBkColor );

}  /* CaSetMetafileDefaults */



void CaSamePrimitive( Boolean same )
/*==================*/
/* indicate whether next primitive is the same or new */
{
   gdiCache.samePrim = same;

}  /* CaSamePrimitive */



void CaMergePen( Word verb )
/*=============*/
/* indicate that next pen should be merged with previous logical pen */
{
   if (gdiCache.nextPen.handle != NULL)
   {
      /* check to see if this is a NULL pen - the merge can happen */
      if (gdiCache.samePrim && verb == GdiFrame &&
          gdiCache.nextPen.handle == gdiCache.nulPen)
      {
         /* remove the cached pen - don't delte the pen object */
         gdiCache.nextPen.handle = NULL;
      }
      else
     {
         /* if not removing a null pen, then flush the cache.  This will most
            often result in a line segment being flushed. */
         CaFlushCache();
      }
   }

}  /* CaMergePen */



Word CaGetCachedPrimitive( void )
/*=======================*/
/* return the current cached primitive type */
{
   return gdiCache.nextPrim.type;

}  /* CaGetCachedPrimitive */



void CaCachePrimitive( CaPrimitiveLPtr primLPtr )
/*===================*/
/* Cache the primitive passed down.  This includes the current pen and brush. */
{
   /* not another line segment and/or not continuous - flush cache */
   CaFlushCache();

   /* save off the new primitive */
   gdiCache.nextPrim = *primLPtr;

   /* check if we need to copy over the polygon list, also */
   if ((gdiCache.nextPrim.type == CaPolygon) ||
       (gdiCache.nextPrim.type == CaPolyLine))
   {
      /* create new polygon */
      NewPolygon();

      /* add the polygon to the polygon buffer */
      while (gdiCache.nextPrim.a.poly.numPoints--)
      {
         AddPolyPt( *gdiCache.nextPrim.a.poly.pointList++);
      }
   }

}  /* CaCachePrimitive */



void CaFlushCache( void )
/*===============*/
/* Flush the current primitive stored in the cache */
{
   /* if the cache is empty, then just return - nothing to do */
   if (gdiCache.nextPrim.type == CaEmpty)
   {
      return;
   }

   /* select all cached attributes */
   CaFlushAttributes();

   /* emit any cached primitive, if necessary */
   switch (gdiCache.nextPrim.type)
   {
      case CaLine:
      {
         Rect        clip;
         Point       delta;
         Point       offset;

         /* determine the length in both directions */
         delta.x = gdiCache.nextPrim.a.line.end.x - gdiCache.nextPrim.a.line.start.x;
         delta.y = gdiCache.nextPrim.a.line.end.y - gdiCache.nextPrim.a.line.start.y;

         /* set clipRect extents based upon current point position */
         clip.left   = min( gdiCache.nextPrim.a.line.start.x, gdiCache.nextPrim.a.line.end.x );
         clip.top    = min( gdiCache.nextPrim.a.line.start.y, gdiCache.nextPrim.a.line.end.y );
         clip.right  = max( gdiCache.nextPrim.a.line.start.x, gdiCache.nextPrim.a.line.end.x );
         clip.bottom = max( gdiCache.nextPrim.a.line.start.y, gdiCache.nextPrim.a.line.end.y );

         /* extend clip rectangle for down-right pen stylus hang */
         clip.right  += gdiCache.nextPrim.a.line.pnSize.x;
         clip.bottom += gdiCache.nextPrim.a.line.pnSize.y;

         /* determine the new starting and ending points */
         gdiCache.nextPrim.a.line.start.x -= delta.x;
         gdiCache.nextPrim.a.line.start.y -= delta.y;
         gdiCache.nextPrim.a.line.end.x   += delta.x;
         gdiCache.nextPrim.a.line.end.y   += delta.y;

         /* ajust the clipping rect for vertical line penSize roundoff? */
         if (delta.x == 0)
         {
            /* vertical line - expand clip in x dimension */
            clip.left--;
         }
         /* are we are adjusting pen by 1/2 metafile unit - roundoff error? */
         else if (gdiCache.nextPrim.a.line.pnSize.x & 0x01)
         {
            /* adjust clipping rectangle to clip the rounding error */
            clip.right--;
         }

         /* ajust the clipping rect for horizontal line penSize roundoff? */
         if (delta.y == 0)
         {
            /* horizontal line - extend clip in y dimension */
            clip.top--;
         }
         /* are we are adjusting pen by 1/2 metafile unit - roundoff error? */
         else if (gdiCache.nextPrim.a.line.pnSize.y & 0x01)
         {
            /* adjust clipping rectangle to clip the rounding error */
            clip.bottom--;
         }

         /* cut the size of the pen dimensions in half for offsets */
         offset.x = gdiCache.nextPrim.a.line.pnSize.x / 2;
         offset.y = gdiCache.nextPrim.a.line.pnSize.y / 2;

         /* set the new clipping rectangle */
         SaveDC( gdiCache.metafile );
         IntersectClipRect( gdiCache.metafile,
                            clip.left,  clip.top, clip.right, clip.bottom );

         /* move to the first point and draw to second (with padding) */

// MoveTo is replaced by MoveToEx in win32
#ifdef WIN32
         MoveToEx( gdiCache.metafile,
                   gdiCache.nextPrim.a.line.start.x + offset.x,
                   gdiCache.nextPrim.a.line.start.y + offset.y, NULL );
#else
         MoveTo( gdiCache.metafile,
                 gdiCache.nextPrim.a.line.start.x + offset.x,
                 gdiCache.nextPrim.a.line.start.y + offset.y );
#endif

         LineTo( gdiCache.metafile,
                 gdiCache.nextPrim.a.line.end.x + offset.x,
                 gdiCache.nextPrim.a.line.end.y + offset.y );

         /* restore the previous clipping rectangle */
         RestoreDC( gdiCache.metafile, -1 );
         break;
      }

      case CaRectangle:
      {
         if (gdiCache.curPen.handle == gdiCache.nulPen)
         {
            Point    poly[5];

            /* set up the bounding coodinates */
            poly[0].x = poly[3].x = gdiCache.nextPrim.a.rect.bbox.left;
            poly[0].y = poly[1].y = gdiCache.nextPrim.a.rect.bbox.top;
            poly[1].x = poly[2].x = gdiCache.nextPrim.a.rect.bbox.right;
            poly[2].y = poly[3].y = gdiCache.nextPrim.a.rect.bbox.bottom;
            poly[4]   = poly[0];

            /* perform call to render rectangle */
            Polygon( gdiCache.metafile, poly, 5 );
         }
         else
         {
            Rectangle( gdiCache.metafile,
                       gdiCache.nextPrim.a.rect.bbox.left,  gdiCache.nextPrim.a.rect.bbox.top,
                       gdiCache.nextPrim.a.rect.bbox.right, gdiCache.nextPrim.a.rect.bbox.bottom );
         }
         break;
      }

      case CaRoundRect:
      {
         RoundRect( gdiCache.metafile,
                    gdiCache.nextPrim.a.rect.bbox.left,  gdiCache.nextPrim.a.rect.bbox.top,
                    gdiCache.nextPrim.a.rect.bbox.right, gdiCache.nextPrim.a.rect.bbox.bottom,
                    gdiCache.nextPrim.a.rect.oval.x,     gdiCache.nextPrim.a.rect.oval.y );
         break;
      }

      case CaEllipse:
      {
         Ellipse( gdiCache.metafile,
                  gdiCache.nextPrim.a.rect.bbox.left,  gdiCache.nextPrim.a.rect.bbox.top,
                  gdiCache.nextPrim.a.rect.bbox.right, gdiCache.nextPrim.a.rect.bbox.bottom );
         break;
      }

      case CaArc:
      {
         Arc( gdiCache.metafile,
              gdiCache.nextPrim.a.arc.bbox.left,  gdiCache.nextPrim.a.arc.bbox.top,
              gdiCache.nextPrim.a.arc.bbox.right, gdiCache.nextPrim.a.arc.bbox.bottom,
              gdiCache.nextPrim.a.arc.start.x,    gdiCache.nextPrim.a.arc.start.y,
              gdiCache.nextPrim.a.arc.end.x,      gdiCache.nextPrim.a.arc.end.y );
         break;
      }

      case CaPie:
      {
         Pie( gdiCache.metafile,
              gdiCache.nextPrim.a.arc.bbox.left,  gdiCache.nextPrim.a.arc.bbox.top,
              gdiCache.nextPrim.a.arc.bbox.right, gdiCache.nextPrim.a.arc.bbox.bottom,
              gdiCache.nextPrim.a.arc.start.x,    gdiCache.nextPrim.a.arc.start.y,
              gdiCache.nextPrim.a.arc.end.x,      gdiCache.nextPrim.a.arc.end.y );
         break;
      }

      case CaPolygon:
      case CaPolyLine:
      {
         Point       offset;
         Integer     i;

         /* see if centering of the pen is required  */
         if (gdiCache.curPen.handle == gdiCache.nulPen)
         {
            /* no - just filling the object without frame */
            offset.x = offset.y = 0;
         }
         else
         {
            /* transform all points to correct for down-right pen
               rendering in QuickDraw and make for a GDI centered pen */
            offset.x = gdiCache.nextPrim.a.poly.pnSize.x / 2;
            offset.y = gdiCache.nextPrim.a.poly.pnSize.y / 2;
         }

         /* transform end point for all points in the polygon */
         for (i = 0; i < gdiCache.numPoints; i++)
         {
            /* increment each coordinate pair off half of the pen size */
            gdiCache.pointList[i].x += offset.x;
            gdiCache.pointList[i].y += offset.y;
         }

         /* call the appropriate GDI routine based upon the type */
         if (gdiCache.nextPrim.type == CaPolygon)
         {
            Polygon( gdiCache.metafile,
                     gdiCache.pointList,
                     gdiCache.numPoints );
         }
         else
         {
            Polyline( gdiCache.metafile,
                      gdiCache.pointList,
                      gdiCache.numPoints );
         }
         break;
      }
   }

   /* mark the primitive cache as empty */
   gdiCache.nextPrim.type = CaEmpty;

}  /* CaFlushCache */



void CaFlushAttributes( void )
/*====================*/
/* flush any pending attribute elements */
{
   /* select the cached pen - the routine will determine if one exits */
   SelectCachedPen();

}  /* CaFlushAttributes */



void CaCreatePenIndirect( LOGPEN far * newLogPen )
/*======================*/
/* create a new pen */
{
   PenLPtr     compare;
   Boolean     different;

   /* determine which pen to compare against */
   compare = (gdiCache.nextPen.handle != NULL) ? &gdiCache.nextPen :
                                                 &gdiCache.curPen;

   /* compare the two pens */
   different = ((newLogPen->lopnStyle   != compare->logPen.lopnStyle) ||
                (newLogPen->lopnColor   != compare->logPen.lopnColor) ||
                (newLogPen->lopnWidth.x != compare->logPen.lopnWidth.x));

   /* if the pens are different ... */
   if (different)
   {
      /* if there is a cached pen ... */
      if (gdiCache.nextPen.handle != NULL)
      {
         /* flush the cached primitive - there is a change of pens */
         CaFlushCache();

         /* check to see if the new pen is changed by next selection */
         different = ((newLogPen->lopnStyle   != gdiCache.curPen.logPen.lopnStyle) ||
                      (newLogPen->lopnColor   != gdiCache.curPen.logPen.lopnColor) ||
                      (newLogPen->lopnWidth.x != gdiCache.curPen.logPen.lopnWidth.x));
      }
   }

   /* if the pen has changed from the current setting, cache the next pen */
   if (different || gdiCache.curPen.handle == NULL)
   {
      /* if there is a pending line or polyline, the flush the cache */
      if (gdiCache.nextPrim.type == CaLine || gdiCache.nextPrim.type == CaPolyLine)
      {
         CaFlushCache();
      }

      /* assign the new pen attributes */
      gdiCache.nextPen.logPen = *newLogPen;

      /* currently not using a stock pen object */
      gdiCache.nextPen.stockObject = FALSE;

      /* check for any pre-defined pen objects */
      if (gdiCache.nextPen.logPen.lopnStyle == PS_NULL)
      {
         /* and use them if possible */
         gdiCache.nextPen.handle = gdiCache.nulPen;
         gdiCache.nextPen.stockObject = TRUE;
      }
      else if (gdiCache.nextPen.logPen.lopnWidth.x == 1)
      {
         if (newLogPen->lopnColor == RGB( 0, 0, 0 ))
         {
            gdiCache.nextPen.handle = gdiCache.blackPen;
            gdiCache.nextPen.stockObject = TRUE;
         }
         else if (gdiCache.nextPen.logPen.lopnColor == RGB( 255, 255, 255 ))
         {
            gdiCache.nextPen.handle = gdiCache.whitePen;
            gdiCache.nextPen.stockObject = TRUE;
         }
      }

      if (!gdiCache.nextPen.stockObject)
      {
         /* otherwise, create a new pen */
         gdiCache.nextPen.handle = CreatePenIndirect( &gdiCache.nextPen.logPen );
      }
   }
   else
   {
      /* copy the current setting back into the next pen setting */
      gdiCache.nextPen = gdiCache.curPen;
   }

   /* check if cache was invalidated */
   if (gdiCache.restorePen && (gdiCache.curPen.handle != NULL))
   {
      /* if pen was invalidated by RestoreDC(), reselect it */
      SelectObject( gdiCache.metafile, gdiCache.curPen.handle );
   }

   /* all is ok with cache now */
   gdiCache.restorePen = FALSE;

}  /* CaCreatePenIndirect */



void CaCreateBrushIndirect( LOGBRUSH far * newLogBrush )
/*========================*/
/* Create a new logical brush using structure passed in */
{
   /* assume that the DIB patterns are different */
   Boolean  differentDIB = TRUE;

   /* check if we are comparing two DIB patterned brushes */
   if ((newLogBrush->lbStyle == BS_DIBPATTERN) &&
       (gdiCache.curBrush.logBrush.lbStyle == BS_DIBPATTERN))
   {
      Word  nextSize = (Word)GlobalSize( (HANDLE) newLogBrush->lbHatch ) / 2;
      Word  currSize = (Word)GlobalSize( (HANDLE) gdiCache.curBrush.logBrush.lbHatch ) / 2;

      /* make sure that the sizes are the same */
      if (nextSize == currSize)
      {
         Word far *  nextDIBPattern = (Word far *)GlobalLock( (HANDLE) newLogBrush->lbHatch );
         Word far *  currDIBPattern = (Word far *)GlobalLock( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );

         /* assume that the DIBs are the same so far */
         differentDIB = FALSE;

         /* compare all the bytes in the two brush patterns */
         while (currSize--)
         {
            /* are they the same ? */
            if (*nextDIBPattern++ != *currDIBPattern++)
            {
               /* if not, flag the difference and break from the loop */
               differentDIB = TRUE;
               break;
            }
         }

         /* Unlock the data blocks */
         GlobalUnlock( (HANDLE) newLogBrush->lbHatch );
         GlobalUnlock( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );

         /* see if these did compare exactly */
         if (!differentDIB)
         {
            /* if so, free the new DIB brush - it's no longer needed */
            GlobalFree( (HANDLE) newLogBrush->lbHatch );
         }
      }
   }

   /* see if we are requesting a new brush */
   if (differentDIB &&
      (newLogBrush->lbStyle != gdiCache.curBrush.logBrush.lbStyle ||
       newLogBrush->lbColor != gdiCache.curBrush.logBrush.lbColor ||
       newLogBrush->lbHatch != gdiCache.curBrush.logBrush.lbHatch ||
       gdiCache.curBrush.handle == NULL))
   {
      HBRUSH   brushHandle = NULL;
      Boolean  stockBrush;

      /* flush the primitive cache if changing brush selection */
      CaFlushCache();

      /* if current brush has a DIB, make sure to free memory */
      if (gdiCache.curBrush.logBrush.lbStyle == BS_DIBPATTERN)
      {
         /* free the memory */
         GlobalFree( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );
      }

      /* copy over the new structure */
      gdiCache.curBrush.logBrush = *newLogBrush;

      /* We currently aren't using a stock brush */
      stockBrush = FALSE;

      /* use stock objects if possible */
      if (gdiCache.curBrush.logBrush.lbStyle == BS_HOLLOW)
      {
         /* use null (hollow) brush */
         brushHandle = gdiCache.nulBrush;
         stockBrush = TRUE;
      }
      /* check for some standard solid colored brushes */
      else if (gdiCache.curBrush.logBrush.lbStyle == BS_SOLID)
      {
         if (gdiCache.curBrush.logBrush.lbColor == RGB( 0, 0, 0) )
         {
            /* use solid black brush */
            brushHandle = gdiCache.blackBrush;
            stockBrush = TRUE;
         }
         else if (gdiCache.curBrush.logBrush.lbColor == RGB( 255, 255, 255 ))
         {
            /* use solid white brush */
            brushHandle = gdiCache.whiteBrush;
            stockBrush = TRUE;
         }
      }

      /* if unable to find a stock brush, then create a new one */
      if (!stockBrush)
      {
         /* otherwise, create new brush using logbrush structure */
         brushHandle = CreateBrushIndirect( &gdiCache.curBrush.logBrush );
      }

      /* select the new brush */
      SelectObject( gdiCache.metafile, brushHandle );

      /* if this isn't the first brush selection and not a stock brush */
      if (gdiCache.curBrush.handle != NULL && !gdiCache.curBrush.stockObject)
      {
         /* delete the previous brush object */
         DeleteObject( gdiCache.curBrush.handle );
      }

      /* save brush handle in current cache variable */
      gdiCache.curBrush.handle = brushHandle;
      gdiCache.curBrush.stockObject = stockBrush;
   }
   else if (gdiCache.restoreBrush)
   {
      /* if brush was invalidated by RestoreDC(), reselect it */
      SelectObject( gdiCache.metafile, gdiCache.curBrush.handle );
   }

   /* all is ok with cache now */
   gdiCache.restoreBrush = FALSE;

}  /* CaCreateBrushIndirect */



void CaCreateFontIndirect( LOGFONT far * newLogFont )
/*=======================*/
/* create the logical font passed as paramter */
{
   /* make sure we are requesting a new font */
   if (newLogFont->lfHeight != gdiCache.curLogFont.lfHeight ||
       newLogFont->lfWeight != gdiCache.curLogFont.lfWeight ||
       newLogFont->lfEscapement  != gdiCache.curLogFont.lfEscapement ||
       newLogFont->lfOrientation != gdiCache.curLogFont.lfOrientation ||
       newLogFont->lfItalic != gdiCache.curLogFont.lfItalic ||
       newLogFont->lfUnderline != gdiCache.curLogFont.lfUnderline ||
       newLogFont->lfPitchAndFamily != gdiCache.curLogFont.lfPitchAndFamily ||
       lstrcmp( newLogFont->lfFaceName, gdiCache.curLogFont.lfFaceName ) != 0 ||
       gdiCache.curFont == NULL)
   {
      HFONT       fontHandle;
      Boolean     stockFont;

      /* flush the primitive cache if changing font attributes */
      CaFlushCache();

      /* assign the new pen attributes */
      gdiCache.curLogFont = *newLogFont;

      /* currently not using a stock font object */
      stockFont = FALSE;

      /* check for any pre-defined pen objects */
      if (newLogFont->lfFaceName == NULL)
      {
         fontHandle = GetStockObject( SYSTEM_FONT );
         stockFont = TRUE;
      }
      else
      {
         /* otherwise, create a new pen */
         fontHandle = CreateFontIndirect( &gdiCache.curLogFont );
      }

      /* select the new font */
      SelectObject( gdiCache.metafile, fontHandle );

      /* if this isn't the first font selection and not a stock font */
      if (gdiCache.curFont != NULL && !gdiCache.stockFont)
      {
         /* delete the previous font object */
         DeleteObject( gdiCache.curFont );
      }

      /* save font handle in current cache variable */
      gdiCache.curFont = fontHandle;
      gdiCache.stockFont = stockFont;
   }
   else if (gdiCache.restoreFont)
   {
      /* if pen was invalidated by RestoreDC(), reselect it */
      SelectObject( gdiCache.metafile, gdiCache.curFont );
   }

   /* all is ok with cache now */
   gdiCache.restoreFont = FALSE;

}  /* CaCreateFontIndirect */



void CaSetBkMode( Word mode )
/*==============*/
/* set the backgound transfer mode */
{
   if (gdiCache.curBkMode != mode)
   {
      /* flush the primitive cache if changing mode */
      CaFlushCache();

      /* set the background mode and save in global cache */
      SetBkMode( gdiCache.metafile, mode );
      gdiCache.curBkMode = mode;
   }

   /* no need to worry about restoring BkMode, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetBkMode */



void CaSetROP2( Word ROP2Code )
/*============*/
/* set the transfer ROP mode according to ROP2Code */
{
   /* check for change in ROP code */
   if (gdiCache.curROP2 != ROP2Code)
   {
      /* flush the primitive cache if changing ROP mode */
      CaFlushCache();

      /* set the ROP code and save in global cache variable */
      SetROP2( gdiCache.metafile, ROP2Code );
      gdiCache.curROP2 = ROP2Code;
   }

   /* no need to worry about restoring ROP code, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetROP2 */



void CaSetStretchBltMode( Word mode )
/*======================*/
/* stretch blt mode - how to preserve scanlines using StretchDIBits() */
{
   if (gdiCache.curStretchMode != mode)
   {
      /* flush the primitive cache if changing mode */
      CaFlushCache();

      /* set the stretch blt mode and save in global cache variable */
      SetStretchBltMode( gdiCache.metafile, mode );
      gdiCache.curStretchMode = mode;
   }
   else if (gdiCache.restoreStretchMode)
   {
      /* if stretch blt mode was invalidated by RestoreDC(), re-issue */
      SetStretchBltMode( gdiCache.metafile, gdiCache.curStretchMode );
   }

   /* all is ok with cache now */
   gdiCache.restoreStretchMode = FALSE;

}  /* CaSetStretchBltMode */



void CaSetTextAlign( Word txtAlign )
/*=================*/
/* set text alignment according to parameter */
{
   if (gdiCache.curTextAlign != txtAlign)
   {
      /* flush the primitive cache if changing text alignment */
      CaFlushCache();

      /* Set the text color and save in cache */
      SetTextAlign( gdiCache.metafile, txtAlign );
      gdiCache.curTextAlign = txtAlign;
   }

   /* no need to worry about restoring text align, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetTextAlign */


void CaSetTextColor( RGBColor txtColor )
/*=================*/
/* set the text color if different from current setting */
{
   if (gdiCache.curTextColor != txtColor)
   {
      /* flush the primitive cache if changing text color */
      CaFlushCache();

      /* Set the text color and save in cache */
      SetTextColor( gdiCache.metafile, txtColor );
      gdiCache.curTextColor = txtColor;
   }

   /* no need to worry about restoring text color, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetTextColor */


void CaSetTextCharacterExtra( Integer chExtra )
/*==========================*/
/* set the character extra spacing */
{
   if (gdiCache.curCharExtra != chExtra)
   {
      /* flush the primitive cache if changing text char extra */
      CaFlushCache();

      /* set the char extra and same state in the cache */
      SetTextCharacterExtra( gdiCache.metafile, chExtra );
      gdiCache.curCharExtra = (WORD) chExtra;

   }
   else if (gdiCache.restoreCharExtra)
   {
      /* if text char extra was invalidated by RestoreDC(), re-issue */
      SetTextCharacterExtra( gdiCache.metafile, gdiCache.curCharExtra );
   }

   /* all is ok with cache now */
   gdiCache.restoreCharExtra = FALSE;

}  /* CaSetTextCharacterExtra */


void CaSetBkColor( RGBColor bkColor )
/*===============*/
/* set background color if different from current setting */
{
   if (gdiCache.curBkColor != bkColor)
   {
      /* flush the primitive cache if changing background color */
      CaFlushCache();

      /* Set the background color and save in cache */
      SetBkColor( gdiCache.metafile, bkColor );
      gdiCache.curBkColor = bkColor;
   }

   /* no need to worry about restoring background color, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetBkColor */


Boolean CaIntersectClipRect( Rect rect )
/*=========================*/
/* Create new clipping rectangle - return FALSE if drawing is disabled */
{
   Rect     combinedRect;

   /* See if the clipping rectangle is empty, indicating that no drawing
      should occur into the metafile */
   if (Height( rect ) == 0 || Width( rect ) == 0)
   {
      /* indicate that drawing is disabled */
      return FALSE;
   }

   /* don't do anything if rectangle hasn't changed */
   if (!EqualRect( &rect, &gdiCache.curClipRect ) || gdiCache.forceNewClipRect)
   {
      /* flush the primitive cache if changing clip region */
      CaFlushCache();

      /* is new clip rect is completely enclosed by current cliprect? */
      IntersectRect( &combinedRect, &rect, &gdiCache.curClipRect );

      /* check for equality of intersection and new cliprect */
      if (!EqualRect( &combinedRect, &rect ) || gdiCache.forceNewClipRect)
      {
         /* must be called just to be able to change clipping rectangle */
         CaRestoreDC();
         CaSaveDC();
      }

      /* set the new clipping rectangle */
      IntersectClipRect( gdiCache.metafile,
                         rect.left, rect.top, rect.right, rect.bottom );

      /* save the current clip rectangle, since it has changed */
      gdiCache.curClipRect = rect;

      /* turn off forcing of the clipping rectangle */
      gdiCache.forceNewClipRect = FALSE;
   }

   /* return TRUE - drawing is enabled */
   return TRUE;

}  /* GdiIntersectClipRect */


void CaSetClipRect( Rect rect )
/*================*/
/* set the current cliprectangle to be equal to rect */
{
   gdiCache.curClipRect = rect;

}  /* CaSetClipRect */


Rect far * CaGetClipRect( void )
/*=====================*/
/* get the current cliprectangle */
{
   return &gdiCache.curClipRect;

}  /* CaGetClipRect */


void CaNonRectangularClip( void )
/*=======================*/
/* notify cache that a non-rectangular clipping region was set */
{
   gdiCache.forceNewClipRect = TRUE;

}  /* CaNonRectangularClip */


void CaSaveDC( void )
/*===========*/
/* save the current device context - used to set up clipping rects */
{
   /* the previous clipping rectangle is saved off */
   gdiCache.prevClipRect = gdiCache.curClipRect;

   /* issue call to GDI */
   SaveDC( gdiCache.metafile );
}


void CaRestoreDC( void )
/*==============*/
/* restore the device context and invalidate cached attributes */
{
   /* restore previous clipping rectangle */
   gdiCache.curClipRect = gdiCache.prevClipRect;

   /* invalidate all of the cached attributes and objects */
   gdiCache.restorePen =
   gdiCache.restoreBrush =
   gdiCache.restoreFont =
   gdiCache.restoreCharExtra = TRUE;

   /* reset metafile defaults */
   gdiCache.curROP2 = gdiCache.iniROP2;
   gdiCache.curTextAlign = gdiCache.iniTextAlign;
   gdiCache.curBkMode = gdiCache.iniBkMode;
   gdiCache.curTextColor = gdiCache.iniTxColor;
   gdiCache.curBkColor = gdiCache.iniBkColor;

   /* issue call to GDI */
   RestoreDC( gdiCache.metafile, -1 );
}

/******************************* Private Routines ***************************/


private void AddPolyPt( Point pt )
/*--------------------*/
/* Add a point to the polygon buffer */
{
   HANDLE tmpHandle;
	
   /* make sure that we haven't reached maximum size */
   if ((gdiCache.numPoints + 1) >= gdiCache.maxPoints)
   {
      /* expand the number of points that can be cached by 10 */
      gdiCache.maxPoints += 16;

      /* unlock to prepare for re-allocation */
      GlobalUnlock( gdiCache.polyHandle);

      /* re-allocate the memory handle by the given amount */
      /* save current ptr so it can be freed if GlobalReAlloc fails */
      tmpHandle = GlobalReAlloc(
            gdiCache.polyHandle,
            gdiCache.maxPoints * sizeof( Point ),
            GMEM_MOVEABLE);

      /* make sure that the re-allocation succeeded */
      if (tmpHandle == NULL)
      {
         /* if not, free the old memory, flag global error and exit from here */
         GlobalFree(gdiCache.polyHandle);
         gdiCache.polyHandle = NULL;
         ErSetGlobalError( ErMemoryFull );
         return;
      }
      
      gdiCache.polyHandle = tmpHandle;

      /* lock the memory handle to get a pointer address */
      gdiCache.pointList = (Point far *)GlobalLock( gdiCache.polyHandle );
   }

   /* insert the new point and increment the number of points in the buffer */
   gdiCache.pointList[gdiCache.numPoints++] = pt;

}  /* AddPolyPt */



private void SelectCachedPen( void )
/*--------------------------*/
/* select the currently cached Pen into the metafile */
{
   /* make sure that there is some new pen to select */
   if (gdiCache.nextPen.handle != NULL)
   {
      /* make sure that the pens are different */
      if (gdiCache.nextPen.handle != gdiCache.curPen.handle)
      {
        /* select the new pen */
         SelectObject( gdiCache.metafile, gdiCache.nextPen.handle);

         /* if this isn't the first pen selection and not a stock pen */
         if (gdiCache.curPen.handle != NULL && !gdiCache.curPen.stockObject)
         {
            /* delete the previous pen selection */
            DeleteObject( gdiCache.curPen.handle );
         }

         /* save pen handle in current cache variable */
         gdiCache.curPen = gdiCache.nextPen;
      }

      /* reset the cache pen to indicate no pre-existing cached pen */
      gdiCache.nextPen.handle = NULL;
   }

}  /* SelectCachedPen */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\cache.h ===
/****************************************************************************
                       Unit Cache; Interface
*****************************************************************************

   Module Prefix: Ca

*****************************************************************************/


#define     CaEmpty        0
#define     CaLine         1
#define     CaRectangle    2
#define     CaRoundRect    3
#define     CaEllipse      4
#define     CaArc          5
#define     CaPie          6
#define     CaPolygon      7
#define     CaPolyLine     8

typedef struct
{
   Word        type;
   Word        verb;
   union
   {
      struct
      {
         Point       start;
         Point       end;
         Point       pnSize;
      } line;

      struct
      {
         Rect        bbox;
         Point       oval;
      } rect;

      struct
      {
         Rect        bbox;
         Point       start;
         Point       end;
      } arc;

      struct
      {
         Integer     numPoints;
         Point far * pointList;
         Point       pnSize;
      } poly;

   } a;

} CaPrimitive, far * CaPrimitiveLPtr;


/*********************** Exported Function Definitions **********************/

void CaInit( Handle metafile );
/* initialize the gdi cache module */


void CaFini( void );
/* close down the cache module */


void CaSetMetafileDefaults( void );
/* Set up any defaults that will be used throughout the metafile context */


Word CaGetCachedPrimitive( void );
/* return the current cached primitive type */


void CaSamePrimitive( Boolean same );
/* indicate whether next primitive is the same or new */


void CaMergePen( Word verb );
/* indicate that next pen should be merged with previous logical pen */


void CaCachePrimitive( CaPrimitiveLPtr primLPtr );
/* Cache the primitive passed down.  This includes the current pen and brush. */


void CaFlushCache( void );
/* Flush the current primitive stored in the cache */
 

void CaFlushAttributes( void );
/* flush any pending attribute elements */


void CaCreatePenIndirect( LOGPEN far * newLogPen );
/* create a new pen */

   
void CaCreateBrushIndirect( LOGBRUSH far * newLogBrush );
/* Create a new logical brush using structure passed in */


void CaCreateFontIndirect( LOGFONT far * newLogFont );
/* create the logical font passed as paramter */


void CaSetBkMode( Word mode );
/* set the backgound transfer mode */


void CaSetROP2( Word ROP2Code );
/* set the transfer ROP mode according to ROP2Code */


void CaSetStretchBltMode( Word mode );
/* stretch blt mode - how to preserve scanlines using StretchDIBits() */


void CaSetTextAlign( Word txtAlign );
/* set text alignment according to parameter */


void CaSetTextColor( RGBColor txtColor );
/* set the text color if different from current setting */


void CaSetTextCharacterExtra( Integer chExtra );
/* set the character extra spacing */


void CaSetBkColor( RGBColor bkColor );
/* set background color if different from current setting */


Boolean CaIntersectClipRect( Rect rect );
/* Create new clipping rectangle - return FALSE if drawing is disabled */


void CaSetClipRect( Rect rect );
/* set the current cliprectangle to be equal to rect */

Rect far * CaGetClipRect( void );
/* return the current cached clip rectangle */

void CaNonRectangularClip( void );
/* notify cache that a non-rectangular clipping region was set */

void CaSaveDC( void );
/* save the current device context - used to set up clipping rects */


void CaRestoreDC( void );
/* restore the device context and invalidate cached attributes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\error.c ===
/****************************************************************************
                       Unit Bufio; Implementation
*****************************************************************************

 Error handles all the interpretation, metafile creation, or read failures
 that may occur during the course of the translation.

 Currently it only supports saving a single error into a global variable.

   Module Prefix: Er

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#ifndef _OLECNV32_
#define IMPDEFS
#include "errdefs.h"       /* Aldus error return codes */
#endif

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

OSErr       globalError;         /* not declared private for macro calls */

/*********************** Private Function Definitions ***********************/


/*********************** Function Implementation ****************************/

#ifndef _OLECNV32_

OSErr ErInternalErrorToAldus( void )
/*==========================*/
/* returns the appropriate Aldus error code given the current global error */
{
   switch (globalError)
   {
      case ErNoError             : return NOERR;

      case ErInvalidVersion      :
      case ErInvalidVersionID    :
      case ErBadHeaderSequence   : return IE_NOT_MY_FILE;

      case ErCreateMetafileFail  :
      case ErCloseMetafileFail   :
      case ErMemoryFull          : return IE_MEM_FULL;

      case ErMemoryFail          : return IE_MEM_FAIL;

      case ErNullBoundingRect    :
      case ErReadPastEOF         : return IE_BAD_FILE_DATA;

      case ErEmptyPicture        : return IE_NOPICTURES;

      case Er32KBoundingRect     : return IE_TOO_BIG;

      case ErNoDialogBox         :
      case ErOpenFail            :
      case ErReadFail            : return IE_IMPORT_ABORT;

      case ErNoSourceFormat      :
      case ErNonSquarePen        :
      case ErInvalidXferMode     :
      case ErNonRectRegion       : return IE_UNSUPP_VERSION;

      default                    : return IE_IMPORT_ABORT;
   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\error.h ===
/****************************************************************************
                       Unit Error; Interface
*****************************************************************************

 Error handles all the interpretation, metafile creation, or read failures
 that may occur during the course of the translation.

   Module Prefix: Er

*****************************************************************************/


/********************* Exported Data ***************************************/

#define  ErNoError            NOERR
#define  ErInvalidVersion     1        /* file is not version 1 or 2       */
#define  ErInvalidVersionID   2        /* PICT 2 version ID invalid        */
#define  ErBadHeaderSequence  3        /* PICT 2 HeaderOp not found        */
#define  ErInvalidPrefsHeader 4        /* Preferences header invalid       */
#define  ErNoSourceFormat     5        /* no source filename/handle given  */

#define  ErMemoryFull         10       /* GlobalAlloc() fail               */
#define  ErMemoryFail         11       /* GlobalLock() fail                */
#define  ErCreateMetafileFail 12       /* CreateMetafile() fail            */
#define  ErCloseMetafileFail  13       /* CloseMetafile() fail             */

#define  ErEmptyPicture       20       /* no primitives found in file      */

#define  ErNullBoundingRect   30       /* BBox defines NULL area           */
#define  Er32KBoundingRect    31       /* BBox extents exceed 32K          */

#define  ErReadPastEOF        40       /* Attempt to read past end of file */
#define  ErOpenFail           41       /* OpenFile() failed                */
#define  ErReadFail           42       /* read from disk failed            */

#define  ErNonSquarePen       50       /* non-square pen & user pref abort */
#define  ErPatternedPen       51       /* patterned pen & user pref abort  */
#define  ErInvalidXferMode    52       /* invalid transfer mode & abort    */
#define  ErNonRectRegion      53       /* non-rectangular region abort     */

#define  ErNoDialogBox        60       /* unable to run status dialog box  */

extern   OSErr    globalError;

/*********************** Exported Function Definitions **********************/

#define  ErSetGlobalError( /* OSErr */ error ) \
/* callback function that allows any routine to set a global error state */ \
globalError = error

#define ErGetGlobalError( /* void */ ) \
/* callback function that allows any routine to get global error state */ \
globalError

OSErr ErInternalErrorToAldus( void );
/* returns the appropriate Aldus error code given the current global error */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\filesys.h ===
/****************************************************************************
                       Unit FileSys; Interface
*****************************************************************************

 FileSys implements the DOS file system calls used by the Presenter and BFile.
 The interface is preserved to be mostly the same as the MAC OS interface.
 All filenames and directories passed as arguments are assumned to be in Ansi,
 and all filenames and directories returned will be in Ansi.

   Module prefix: FS

****************************************************************************/


/********************* Exported Data ***************************************/

#define  FSFROMSTART    0     /* From Start of file */
#define  FSFROMMARK     1     /* From current file marker */
#define  FSFROMLEOF     2     /* From End of File */

/* File System errors */

#define  FSERROR       -1     /* failure flage for file I/O       */
#define  FUNCERR        1     /* invalid function */
#define  FNFERR         2     /* DOS file not found */
#define  DIRNFERR       3     /* Path not found */
#define  DUPFNERR       4     /* DOS too many files opened */
#define  TMFOERR        4
#define  OPWRERR        5     /* DOS Access denied error */
#define  FNOPNERR       6     /* DOS invalid handle */
#define  MEMFULLERR     8     /* Insufficient memory */
#define  IOERR         13     /* DOS invalid data */
#define  VOLOFFLINERR  15     /* DOS Drive not ready */
#define  WPRERR        19     /* DOS disk write-protected */
#define  POSERR        25     /* Invalid Seek */
#define  PERMERR       32     /* DOS sharing violation */
#define  VLCKDERR      33     /* DOS lock violation */
#define  WRPERMERR     65     /* Network Write Permission Error: access denied */
#define  DIRFULERR     82     /* DOS cannot make directory entry */
#define  ABORTERR      83     /* Fail DOS int24 critical handler */

#define  DSKFULERR    -34     /* MAC Disk full error */
#define  EOFERR       -39     /* MAC end-of-file error */
#define  FBSYERR      -47     /* MAC file busy error */
#define  FLCKDERR     -49     /* MAC file is locked error */

/* Scrap Manager errors */
#define  NOSCRAPERR   -100    /* MAC Desk scrap isn't initialized */
#define  NOFORMATERR  -101    /* MAC No data of the requested format */
#define  SPOPENERR    -102    /* PP Couldn't open the scrap */
#define  SPDATAERR    -103    /* PP the scrap had invalid data */

#define  MAXBLERR     - 2     /* Block too large error */

/* File attribute constants */
#define FS_NORMAL    0x00     /* Normal file - No read/write restrictions */
#define FS_RDONLY    0x01     /* Read only file */
#define FS_HIDDEN    0x02     /* Hidden file */
#define FS_SYSTEM    0x04     /* System file */
#define FS_VOLID     0x08     /* Volume ID file */
#define FS_SUBDIR    0x10     /* Subdirectory */
#define FS_ARCH      0x20     /* Archive file */


/********************* Exported Operations *********************************/

OSErr FSRead( Integer fileRef, LongInt far * lbytes, LPtr des);
/* Read lbytes long from file fileRef to buffer des. 'Lbytes' is updated to
   indicate the number of bytes actually read.  Error is returned by function
   if !FALSE. */

OSErr FSGetFPos( Integer fileRef, LongInt far * markPos );
/* Get the current mark position in fileRef. Return that position
   in markPos. Function returns error code if !NOERR. */

OSErr FSSetFPos(Integer fileRef, Word postype, LongInt Offset);
/* Move the fileRef file pointer to the new position Offset */

OSErr FSOpen( StringLPtr filename, Word mode, Integer far* fileRef);
/* Open filename with DOS OPEN 'mode' and return a valid 'fileRef' if NOERR.
   Create an entry in the internal file table and initialize it. The DOS
   handle is left opened (for performance reasons) until
   FSTempClose(fileRef) is called. Return the appropriate error
   if failed. */

OSErr FSCloseFile(Integer fileRef);
/* Close the file given its 'fileRef'. Also remove its file table entry. */



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\getdata.c ===
/****************************************************************************
                       Unit GetData; Implementation
*****************************************************************************

 GetData implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.

   Module Prefix: Get

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  <math.h>         /* for abs() function */

#include  "getdata.h"      /* own module interface */

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

/*--- octochrome color tables --- */

#define  blackColor     33
#define  whiteColor     30
#define  redColor       205
#define  greenColor     341
#define  blueColor      409
#define  cyanColor      273
#define  magentaColor   137
#define  yellowColor    69

typedef struct
{
   LongInt     octochromeColor;
   RGBColor    rgbColor;
} colorEntry, * colorEntryPtr;

private  colorEntry octochromeLookup[8] =
{
   { blackColor,   RGB( 0x00, 0x00, 0x00 ) },
   { whiteColor,   RGB( 0xFF, 0xFF, 0xFF ) },
   { redColor,     RGB( 0xDD, 0x08, 0x06 ) },
   { greenColor,   RGB( 0x00, 0x80, 0x11 ) },
   { blueColor,    RGB( 0x00, 0x00, 0xD4 ) },
   { cyanColor,    RGB( 0x02, 0xAB, 0xEA ) },
   { magentaColor, RGB( 0xF2, 0x08, 0x84 ) },
   { yellowColor,  RGB( 0xFC, 0xF3, 0x05 ) }
};

/*********************** Private Function Definitions ***********************/


/*********************** Function Implementation ****************************/


void GetWord( Word far * wordLPtr )
/*==========*/
/* Retrieves an 16-bit unsigned integer from the input stream */
{
   Byte far * byteLPtr = (Byte far *)wordLPtr;

   /* this initialization should be here for win32 */
   *wordLPtr = 0;

   /* Assign high-order byte first, followed by low-order byte. */
   GetByte( byteLPtr + 1);
   GetByte( byteLPtr );
}  /* GetWord */


void GetDWord( DWord far * dwordLPtr )
/*===========*/
/* Retrieves a 32-bit unsigned long from the input stream */
{
   Byte far * byteLPtr = (Byte far *)dwordLPtr;

   * dwordLPtr = 0;
   GetByte( byteLPtr + 3);
   GetByte( byteLPtr + 2);
   GetByte( byteLPtr + 1);
   GetByte( byteLPtr );
}  /* GetDWord */

#ifdef WIN32
void GetPoint( Point * pointLPtr )
/*===========*/
/* Retrieves 2 2-byte words from the input stream and assign them
   to a POINT structure */
{
   Word * wordLPtr = (Word *)pointLPtr;

   GetWord( wordLPtr + 1 );
   // This is done to extend the sign bit
   *( wordLPtr + 1 ) = (short)(*( wordLPtr + 1 ));

   GetWord( wordLPtr );
   *( wordLPtr     ) = (short)(*( wordLPtr     ));
}  /* GetPoint */
#endif

#ifdef WIN32
void GetCoordinate( Point * pointLPtr )
/*===========*/
/* Retrieves 2 2-byte words from the input stream and assign them
   to a POINT structure. Currently, there is no difference between
   this function and GetPoint. GetCoordinate is provided to provide for
   future modifications. */
{
   Word * wordLPtr = (Word *)pointLPtr;

   GetWord( wordLPtr + 1 );
   // This is done to extend the sign bit
   *( wordLPtr + 1 ) = (short)(*( wordLPtr + 1 ));

   GetWord( wordLPtr );
   *( wordLPtr     ) = (short)(*( wordLPtr     ));
}  /* GetCoordinate */
#endif

void GetBoolean( Boolean far * bool )
/*=============*/
/* Retrieves an 8-bit Mac boolean and coverts to 16-bit Windows Boolean */
{
   /* make sure that the high-order byte is zeroed out */
   *bool = 0;

   /* read low-order byte */
   GetByte( (Byte far *)bool );

}  /* GetBoolean */


void GetRect( Rect far * rect)
/*==========*/
/* Returns a RECT structure consisting of upper left and lower right
   coordinate pair */
{
   Integer     temp;
   Point far * pointLPtr = (Point far *)rect;

   /* Get the bounding coordinates */
   GetCoordinate( pointLPtr++ );
   GetCoordinate( pointLPtr );

   /* Make sure that the rectangle coords are upper-left and lower-right */
   if (rect->left > rect->right)
   {
      temp = rect->right;
      rect->right = rect->left;
      rect->left = temp;
   }

   if (rect->top > rect->bottom)
   {
      temp = rect->bottom;
      rect->bottom = rect->top;
      rect->top = temp;
   }

}  /* GetRect */


void GetString( StringLPtr stringLPtr )
/*============*/
/* Retrieves a Pascal-style string and formats it C-style.  If the input
   parameter is NIL, then the ensuing data is simply skipped */
{
   Byte           dataLen;
   Byte           unusedByte;
   Byte           increment;
   StringLPtr     destLPtr;

   /* Determine if we should be savin the text string or whether it simply
      ends up in the bit bucket. Set the correct destination pointer and
      increment value. */
   if (stringLPtr == NIL)
   {
      destLPtr = &unusedByte;
      increment = 0;
   }
   else
   {
      destLPtr = stringLPtr;
      increment = 1;
   }

   /* Determine exactly how many bytes should be read. */
   GetByte( &dataLen );

   /* continue reading bytes as determined by length. */
   while (dataLen--)
   {
      GetByte( destLPtr );
      destLPtr += increment;
   }

   /* terminate string with NUL byte */
   *destLPtr = 0;

}  /* GetString */


void GetRGBColor( RGBColor far * rgbLPtr )
/*==============*/
/* Returns an RGB color */
{
   Word     red;
   Word     green;
   Word     blue;

   /* read successive components from the stream */
   GetWord( &red );
   GetWord( &green );
   GetWord( &blue );

   /* use RGB macro to create an RGBColor */
   *rgbLPtr = RGB( red>>8, green>>8 , blue>>8 );

}  /* GetRGBColor */


void GetOctochromeColor( RGBColor far * rgbLPtr )
/*=====================*/
/* Returns an RGB color - this will be converted from a PICT octochrome
   color if this is a version 1 picture */
{
   LongInt        color;
   colorEntryPtr  entry;

   /* read in the LongInt octochrome color from the I/O stream */
   GetDWord( &color );

   /* search through the table, looking for the matching entry */
   entry = octochromeLookup;
   while (entry->octochromeColor != color)
   {
      entry++;
   }
   *rgbLPtr = entry->rgbColor;
}


Boolean GetPolygon( Handle far * polyHandleLPtr, Boolean check4Same )
/*================*/
/* Retrieves a polygon definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated.
   If check4Same is TRUE, then the routine will compare the point list
   against the previous polygon definition, checking for equality.  If
   pointlists match, then the routine returns TRUE, otherwise, it will
   always return FALSE.  Use this to merge fill and frame operations. */
{
   Handle      newPolyH;
   Word        polySize;
   Word  far * polySizeLPtr;
   Point far * polyPointsLPtr;
   Boolean     sameCoordinates;

   /* the polygon coordinates are assumed to be different */
   sameCoordinates = FALSE;

   /* determine how large the polygon buffer should be. */
   GetWord( &polySize );

   /* allocate the necessary size for the polygon. */
#ifdef WIN32
   {
      DWord dwSizeToAllocate;
      Word  uNumPoints;

      uNumPoints = (polySize - sizeofMacWord) / sizeofMacPoint;
      // a Word is needed to store polySize then POINT * uNumPoints
      dwSizeToAllocate = sizeof( Word ) +
          ( uNumPoints * sizeof ( Point ));

      newPolyH = GlobalAlloc( GHND, (DWord)dwSizeToAllocate );
   }
#else
   newPolyH = GlobalAlloc( GHND, (DWord)polySize );
#endif

   /* check to make sure that the allocation succeeded. */
   if (newPolyH == NIL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      Boolean     check4Closure;
      Point far * firstPtLPtr;

      /* Lock the memory handle and make sure it succeeds */
      polySizeLPtr = (Word far *)GlobalLock( newPolyH );

      /* save the size parameter and adjust the counter variables */
      *polySizeLPtr = polySize;
      polySize -= ( sizeofMacWord );
      polyPointsLPtr = (Point far *)(polySizeLPtr + 1);

      /* determine if we should check adjust first point to match last
         point if they are within 1 metafile unit of oneanother. */
      check4Closure = (polySize / sizeofMacPoint >= 6);
      firstPtLPtr = polyPointsLPtr + 2;

      /* continue reading points until the buffer is completely filled. */
      while (polySize)
      {
         GetCoordinate( polyPointsLPtr++ );
         polySize -= sizeofMacPoint;
      }

      /* should we check adjust for start, end points off by 1 unit? */
      if (check4Closure)
      {
         Point    first;
         Point    last;

         /* get the first and last points */
         first = *firstPtLPtr;
         last = *(--polyPointsLPtr);

         /* compare x and y components - see if delta in x or y < 1 */
         if ((abs( first.x - last.x ) <= 1) &&
             (abs( first.y - last.y ) <= 1))
         {
            /* if small delta, set last point equal to first point */
            *polyPointsLPtr = first;
         }
      }

      /* find out if the first and last point are within one metafile unit
         of oneanother - close the polygon in this case */


      /* determine if we should check against previous coordinates */
      if (*polyHandleLPtr != NIL && check4Same)
      {
         Word  far * checkSizeLPtr;
         DWord far * checkDWordLPtr;
         DWord far * polyDWordLPtr;

         /* go back and see if the same set of coordinates was specified -
            first check to see if the sizes are the same */
         checkSizeLPtr = (Word far *)GlobalLock( *polyHandleLPtr );
         if (*checkSizeLPtr == *polySizeLPtr)
         {
            /* reset the coordinate pointers to beginning of lists */
            polyDWordLPtr = (DWord far *)(polySizeLPtr + 1);
            checkDWordLPtr= (DWord far *)(checkSizeLPtr + 1);
            polySize = *checkSizeLPtr - sizeofMacWord;

            /* assume at this point that they are the same pointList */
            sameCoordinates = TRUE;

            /* continue check for equality until pointlist is exhausted */
            while (polySize)
            {
               /* compare the two coordinate pairs */
               if (*polyDWordLPtr++ != *checkDWordLPtr++)
               {
                  /* if one of the coordinates mis-compares, bail */
                  sameCoordinates = FALSE;
                  break;
               }
               else
               {
                  /* otherwise, decrement the count and continue */
                  polySize -= sizeofMacDWord;
               }
            }
         }

         /* unlock the previous polygon handle */
         GlobalUnlock( *polyHandleLPtr );
      }

      /* unlock the handle before returning */
      GlobalUnlock( newPolyH );
   }

   /* de-allocate the previous handle before continuing */
   if (*polyHandleLPtr != NIL)
   {
      GlobalFree( *polyHandleLPtr );
   }

   /* assign the new polygon handle */
   *polyHandleLPtr = newPolyH;

   /* return whether coordinates were same or not */
   return sameCoordinates;

}  /* GetPolygon */


void GetRegion( Handle far * rgnHandleLPtr )
/*=============*/
/* Retrieves a region definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated. */
{
   Word        rgnSize;
   Word far *  rgnDataLPtr;
   Word far *  rgnSizeLPtr;

   /* de-allocate the previous handle before continuing */
   if (*rgnHandleLPtr != NIL)
   {
      GlobalFree( *rgnHandleLPtr );
   }

   // buffer should have enough room for a RECT and a series of Word's
   /* determine how large the region buffer should be. */
   GetWord( &rgnSize );

#ifdef WIN32
   /* allocate the necessary size for the region. */
   {
      Word uSizeToAllocate;

      uSizeToAllocate = (((rgnSize - sizeofMacRect) / sizeofMacWord)
          * sizeof ( Word ))
         + sizeof ( RECT );

      *rgnHandleLPtr = GlobalAlloc( GHND, (DWord)uSizeToAllocate );
   }
#else
   /* allocate the necessary size for the polygon. */
   *rgnHandleLPtr = GlobalAlloc( GHND, (DWord)rgnSize );
#endif

   /* check to make sure that the allocation succeeded. */
   if (*rgnHandleLPtr == NIL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      /* Lock the memory handle and make sure it succeeds */
      rgnSizeLPtr = (Word far *)GlobalLock( *rgnHandleLPtr );
      if (rgnSizeLPtr == NIL)
      {
         ErSetGlobalError( ErMemoryFail );
         GlobalFree( *rgnHandleLPtr );
      }
      else
      {
         /* save the size parameter and adjust the counter variables */
         *rgnSizeLPtr++ = rgnSize;
         rgnSize -= sizeofMacWord;
         rgnDataLPtr = (Word far *)rgnSizeLPtr;

         /* read out the bounding box */
         GetRect( (Rect far *)rgnDataLPtr );
         rgnDataLPtr += sizeofMacRect / sizeofMacWord;
         rgnSize -= sizeofMacRect;

         /* continue reading Data until the buffer is completely filled. */
         while (rgnSize)
         {
            /* read the next value from the source file */
            GetWord( rgnDataLPtr++ );
            rgnSize -= sizeofMacWord;
         }

         /* unlock the handle before returning */
         GlobalUnlock( *rgnHandleLPtr );
      }
   }

}  /* GetRegion */


void GetPattern( Pattern far * patLPtr )
/*=============*/
/* Returns a Pattern structure */
{
   Byte        i;
   Byte far *  byteLPtr = (Byte far *)patLPtr;

   for (i = 0; i < sizeof( Pattern); i++)
   {
      GetByte( byteLPtr++ );
   }

}  /* GetPattern */



void GetColorTable( Handle far * colorHandleLPtr )
/*================*/
{
   ColorTable        cTab;
   LongInt           bytesNeeded;
   ColorTable far *  colorHeaderLPtr;
   RGBColor far *    colorEntryLPtr;

   /* read in the header information */
   GetDWord( (DWord far *)&cTab.ctSeed );
   GetWord( (Word far *)&cTab.ctFlags );
   GetWord( (Word far *)&cTab.ctSize );

   /* calculate the number of bytes needed for the color table */
   bytesNeeded = sizeof( ColorTable ) + cTab.ctSize * sizeof( RGBColor );

   /* adjust the size of the color table size by 1 */
   cTab.ctSize++;

   /* allocate the data block */
   *colorHandleLPtr = GlobalAlloc( GHND, bytesNeeded );

   /* flag global error if memory is not available */
   if (*colorHandleLPtr == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      /* lock the memory */
      colorHeaderLPtr = (ColorTable far *)GlobalLock( *colorHandleLPtr );

      /* copy over the color handle header */
      *colorHeaderLPtr = cTab;

      /* convert the pointer to a RGBQUAD pointer */
      colorEntryLPtr = (RGBColor far *)colorHeaderLPtr->ctColors;

      /* read in the color table entries */
      while (cTab.ctSize--)
      {
         Word        unusedValue;

         /* read the value field */
         GetWord( &unusedValue );

         /* read the ensuing RGB color */
         GetRGBColor( colorEntryLPtr++ );
      }

      /* Unlock the data once finished */
      GlobalUnlock( *colorHandleLPtr );
   }

}  /* GetColorTable */



void GetPixPattern( PixPatLPtr pixPatLPtr )
/*================*/
/* Retrieves a Pixel Pattern structure. */
{
   /* release the memory from the patData field before continuing */
   if (pixPatLPtr->patData != NULL)
   {
      GlobalFree( pixPatLPtr->patMap.pmTable );
      GlobalFree( pixPatLPtr->patData );
      pixPatLPtr->patData = NULL;
   }

   /* read the pattern type to determine how the data is organized */
   GetWord( &pixPatLPtr->patType );
   GetPattern( &pixPatLPtr->pat1Data );

   /* read the additional data depending on the pattern type */
   if (pixPatLPtr->patType == QDDitherPat)
   {
      /* if this is a rare dither pattern, save off the desired color */
      GetRGBColor( &pixPatLPtr->patMap.pmReserved );
   }
   else /* (patType == newPat) */
   {
      /* read in the pixMap header and create a pixmap bitmap */
      GetPixMap( &pixPatLPtr->patMap, TRUE );
      GetColorTable( &pixPatLPtr->patMap.pmTable );
      GetPixData( &pixPatLPtr->patMap, &pixPatLPtr->patData );
   }

}  /* GetPixPattern */



void GetPixMap( PixMapLPtr pixMapLPtr, Boolean forcePixMap )
/*============*/
/* Retrieves a Pixel Map from input stream */
{
   Boolean     readPixelMap;

   /* Read the rowBytes number and check the high-order bit.  If set, it
      is a pixel map containing multiple bits per pixel; if not, it is
      a bitmap containing one bit per pixel */
   GetWord( (Word far *)&pixMapLPtr->rowBytes );
   readPixelMap = forcePixMap || ((pixMapLPtr->rowBytes & PixelMapBit) != 0);

   /* read the bitmap's bounding rectangle */
   GetRect( (Rect far *)&pixMapLPtr->bounds );

   if (readPixelMap)
   {
      /* read the different data fields into the record structure */
      GetWord(   (Word far *)&pixMapLPtr->pmVersion );
      GetWord(   (Word far *)&pixMapLPtr->packType );
      GetDWord( (DWord far *)&pixMapLPtr->packSize );
      GetFixed( (Fixed far *)&pixMapLPtr->hRes );
      GetFixed( (Fixed far *)&pixMapLPtr->vRes );
      GetWord(   (Word far *)&pixMapLPtr->pixelType );
      GetWord(   (Word far *)&pixMapLPtr->pixelSize );
      GetWord(   (Word far *)&pixMapLPtr->cmpCount );
      GetWord(   (Word far *)&pixMapLPtr->cmpSize );
      GetDWord( (DWord far *)&pixMapLPtr->planeBytes );
      GetDWord( (DWord far *)&pixMapLPtr->pmTable );
      GetDWord( (DWord far *)&pixMapLPtr->pmReserved );
   }
   else
   {
      LongInt           bytesNeeded;
      ColorTable far *  colorHeaderLPtr;

      /* if this is a bitmap, then we assign the various fields.  */
      pixMapLPtr->pmVersion = 0;
      pixMapLPtr->packType = 0;
      pixMapLPtr->packSize = 0;
      pixMapLPtr->hRes = 0x00480000;
      pixMapLPtr->vRes = 0x00480000;
      pixMapLPtr->pixelType = 0;
      pixMapLPtr->pixelSize = 1;
      pixMapLPtr->cmpCount = 1;
      pixMapLPtr->cmpSize = 1;
      pixMapLPtr->planeBytes = 0;
      pixMapLPtr->pmTable = 0;
      pixMapLPtr->pmReserved = 0;

      /* calculate the number of bytes needed for the color table */
      bytesNeeded = sizeof( ColorTable ) + sizeof( RGBColor );

      /* allocate the data block */
      pixMapLPtr->pmTable = GlobalAlloc( GHND, bytesNeeded );

      /* make sure that the allocation was successfull */
      if (pixMapLPtr->pmTable == NULL)
      {
         ErSetGlobalError( ErMemoryFull );
      }
      else
      {
         CGrafPortLPtr     port;

         /* Get the QuickDraw port for foreground and bkground colors */
         QDGetPort( &port );

         /* lock the memory handle and prepare to assign color table */
         colorHeaderLPtr = (ColorTable far *)GlobalLock( pixMapLPtr->pmTable );

         /* 2 colors are present - black and white */
         colorHeaderLPtr->ctSize = 2;
         colorHeaderLPtr->ctColors[0] = port->rgbFgColor;
         colorHeaderLPtr->ctColors[1] = port->rgbBkColor;

         /* unlock the memory */
         GlobalUnlock( pixMapLPtr->pmTable );
      }
   }

}  /* GetPixMap */



void GetPixData( PixMapLPtr pixMapLPtr, Handle far * pixDataHandle )
/*=============*/
/* Read a pixel map from the data stream */
{
   Integer        rowBytes;
   Integer        linesToRead;
   LongInt        bitmapBytes;
   Integer        bytesPerLine;

   /* determine the number of lines in the pixel map */
   linesToRead = Height( pixMapLPtr->bounds );

   /* make sure to turn off high-order bit - used to signify pixel map */
   rowBytes = pixMapLPtr->rowBytes & RowBytesMask;

   /* determine number of bytes to read for each line */
   if (pixMapLPtr->pixelSize <= 16)
   {
      /* use the masked rowBytes value (adjusted for pixel maps) */
      bytesPerLine = rowBytes;
   }
   else  /* if (pixMapLPtr->pixelSize == 24) */
   {
      /* adjust for 32-bit pixel images that don't contain high-order byte */
      bytesPerLine = rowBytes * 3 / 4;
   }

   /* calculate the size of the bitmap that will be created */
   bitmapBytes = (LongInt)linesToRead * (LongInt)bytesPerLine;

   /* allocate the necessary memory */
   *pixDataHandle = GlobalAlloc( GHND, bitmapBytes );

   /* flag global error if memory is not available */
   if (*pixDataHandle == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      Boolean        compressed;
      Boolean        invertBits;
      Boolean        doubleByte;
      Byte huge *    rowHPtr;
      Byte huge *    insertHPtr;

      /* lock the memory handle and get a pointer to the first byte */
      rowHPtr = (Byte huge *)GlobalLock( *pixDataHandle );

      /* determine if the bitmap is compressed or not */
      compressed = !((rowBytes < 8)  ||
                     (pixMapLPtr->packType == 1) ||
                     (pixMapLPtr->packType == 2));

      /* determine if we should read 2 bytes at a time (16-bit pixelmap) */
      doubleByte = (pixMapLPtr->packType == 3);

      /* determine if bits should be inverted (monochrome bitmap) */
      /* must test for high bit of Mac word set, sign is not propagated
    when a Mac word is read into a 32-bit Windows int */
      invertBits = ((short)pixMapLPtr->rowBytes > 0 );

      /* decompress the bitmap into the global memory block */
      while (linesToRead-- && (ErGetGlobalError() == NOERR))
      {
         Integer        runLength;
         Integer        bytesRead;
         Integer        bytesToSkip;

         /* see if we need to read the scanline runlength */
         if (compressed)
         {
            /* get the run length - depends on the rowbytes field */
            if (rowBytes > 250)
            {
               GetWord( (Word far *)&runLength );
            }
            else
            {
               runLength = 0;
               GetByte( (Byte far *)&runLength );
            }
         }
         else
         {
            /* if not compressed, runLength is equal to rowBytes */
            runLength = bytesPerLine;
         }

         /* set the next insertion point to the beginning of the scan line */
         insertHPtr = rowHPtr;

         /* if this is a 24-bit image that contains 32-bits of information,
            then we must skip the high-order byte component.  This byte was
            originally spec'ed by Apple as a luminosity component, but is
            unused in Windows 24-bit DIBs. */
         bytesToSkip = (pixMapLPtr->cmpCount == 4) ? (rowBytes / 4) : 0;

         /* continue decompressing until run-length is exhausted */
         for (bytesRead = 0; bytesRead < runLength;  )
         {
            SignedByte     tempRepeatCount = 0;
            Integer        repeatCount;

            /* check on how the data should be read */
            if (compressed)
            {
               /* if compressed, get the repeat count byte */
              GetByte( (Byte far *)&tempRepeatCount );
              bytesRead++;
            }
            else
            {
               /* if no compression, fake the count of bytes to follow */
               tempRepeatCount = 0;
            }

            /* make sure that we didn't read a byte used to word-align */
            if (bytesRead == runLength)
            {
               /* this should force the read loop to be exited */
               continue;
            }

            /* if less than 0, indicates repeat count of following byte */
            if (tempRepeatCount < 0)
            {
               /* check for a flag-counter value of -128 (0x80) - QuickDraw
                  will never create this, but another application that packs
                  bits may.  As noted in the January 1992 release of TechNote
                  #171, we need to ignore this value and use the next byte
                  as the flag-counter byte. */
               if (tempRepeatCount != -128)
               {
                  Byte        repeatByte1;
                  Byte        repeatByte2 = 0;

                  /* calculate the repeat count and retrieve repeat byte */
                  repeatCount = 1 - (Integer)tempRepeatCount;
                  GetByte( &repeatByte1 );

                  /* increment the number of bytes read */
                  bytesRead++;

                  /* check for special handling cases */
                  if (invertBits)
                  {
                     /* if this is a monochrome bitmap, then invert bits */
                     repeatByte1 ^= (Byte)0xFF;
                  }
                  else if (doubleByte)
                  {
                     /* 16-bit images (pixel chunks) - read second byte */
                     GetByte( &repeatByte2 );

                     /* and increment byte count */
                     bytesRead++;
                  }

                  /* continue stuffing byte until repeat count exhausted */
                  while (repeatCount--)
                  {
                     /* check if we are skipping the luminosity byte for
                        32-bit images (this isn't used in Windows DIBs) */
                     if (bytesToSkip)
                     {
                        bytesToSkip--;
                     }
                     else
                     {
                        /* insert new Byte */
                        *insertHPtr++ = repeatByte1;
                     }

                     /* check if second repeat byte needs to be inserted */
                     if (doubleByte)
                     {
                        *insertHPtr++ = repeatByte2;
                     }
                  }
               }
            }
            else  /* if (tempRepeatCount >= 0) */
            {
               /* adjust the number of bytes that will be transferred */
               if (compressed)
               {
                  /* if greater than 0, is number of bytes that follow */
                  repeatCount = 1 + (Integer)tempRepeatCount;

                  /* double the number of bytes if 16-bit pixelmap */
                  if (doubleByte)
                  {
                     repeatCount *= 2;
                  }
               }
               else
               {
                  /* the number of bytes to read = bytesPerLine */
                  repeatCount = bytesPerLine;
               }

               /* increment the number of bytes read */
               bytesRead += repeatCount;

               /* check if iversion is required */
               if (invertBits)
               {
                  /* if this is a monochrome bitmap, then invert bits */
                  while (repeatCount--)
                  {
                     GetByte( insertHPtr );
                     *insertHPtr++ ^= (Byte)0xFF;
                  }
               }
               else
               {
                  /* continue reading bytes into the insert point */
                  while (repeatCount--)
                  {
                     /* check if we are skipping the luminosity byte for
                        32-bit images (this isn't used in Windows DIBs) */
                     if (bytesToSkip)
                     {
                        /* pass the current insertion pointer, but don't
                           increment (overwritten in ensuing read). */
                        bytesToSkip--;
                        GetByte( insertHPtr );
                     }
                     else
                     {
                        GetByte( insertHPtr++ );
                     }
                  }
               }
            }
         }

         /* increment the line pointer to the next scan line */
         rowHPtr += bytesPerLine;

         /* call IO module to update current read position */
         IOUpdateStatus();
      }

      /* Unlock the data block */
      GlobalUnlock( *pixDataHandle );

      /* if an error occured, make sure to remove the data block */
      if (ErGetGlobalError() != NOERR)
      {
         GlobalFree( *pixDataHandle );
	 *pixDataHandle = NULL;
      }
   }

}  /* GetPixData */


/******************************* Private Routines ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\gdiprim.c ===
/****************************************************************************
                       Unit GdiPrim; Implementation
*****************************************************************************

 The Gdi module is called directly by the QuickDraw (QD) module in order
 to emit metafile primitives.  It is responsible for accessing the current
 CGrafPort structure in order to access the individual attribute settings.

 It also supports the caching and redundant elimination of duplicate
 elements when writing to the metafile.

   Module Prefix: Gdi

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  "math.h"         /* for floating-point (sin, cos) calculations */
#include  "qdcoment.i"     /* for interpretation of picture comments */
#include  "cache.h"        /* for all drawing to metafile context */

/*********************** Exported Data **************************************/

/*********************** Private Data ***************************************/

/*--- mixture of grey values ---*/

#define  NOMIX       FALSE
#define  MIXGREY     TRUE

/*--- Gdi environment ---*/

typedef struct{
   Handle          metafile;              // metafile handle

   LOGBRUSH        newLogBrush;
   LOGFONT         newLogFont;
   LOGPEN          newLogPen;

   Rect            clipRect;              // current clip rectangle

   Boolean         drawingEnabled;        // is drawing currently enabled?
   Boolean         sameObject;            // same primitive being drawn?
   Boolean         useGdiFont;            // override font search w/Gdi name?

   Integer         hatchIndex;            // hatch pattern for fills

   Pattern         lastPattern;           // patterns used for the current
   Integer         lastPatType;           // brush selection
   RGBColor        lastFgColor;           // fore- and background colors
   RGBColor        lastBkColor;           // used to create selected brush

   HDC             infoContext;           // information context for fonts
   FONTENUMPROC    fontFunction;          // used to access font information

   Byte            state[GdiNumAttrib];   // have various attributes changed

} GdiEnv;

private  GdiEnv         gdiEnv;
private  ConvPrefsLPtr  gdiPrefsLPtr;
private  PICTINFO       gdiPict;


/*--- Font face translation ---*/

#define  FntSystemFont     0
#define  FntApplFont       1
#define  FntNewYork        2
#define  FntGeneva         3
#define  FntMonaco         4
#define  FntVenice         5
#define  FntLondon         6
#define  FntAthens         7
#define  FntSanFran        8
#define  FntToronto        9
#define  FntCairo          11
#define  FntLosAngeles     12
#define  FntZapfDingbats   13
#define  FntBookman        14
#define  FntHelvNarrow     15
#define  FntPalatino       16
#define  FntZapfChancery   18
#define  FntTimes          20
#define  FntHelvetica      21
#define  FntCourier        22
#define  FntSymbol         23
#define  FntMobile         24
#define  FntAvantGarde     33
#define  FntNewCentury     34
#define  FntMTExtra        2515
#define  FntUnknown        -1

#define  MaxFntName        LF_FACESIZE
#define  NumFntEntries     27
#define  NumTTSubs         12
#define  TTSubStart        11
#define  FntFromGdi        (NumFntEntries - 1)
#define  FntNoMatch        (NumFntEntries - 2)
#define  FntDefault        2

#define  MTEXTRA_CHARSET   160
#define  FENCES_CHARSET    161

typedef struct
{
   Integer     fontNum;
   Byte        macName[MaxFntName];
   Byte        gdiName[MaxFntName];
   Byte        family;
   Byte        charset;
} FontEntry, far * FontEntryLPtr;

private  FontEntry   fontTable[NumFntEntries] =
{
   { FntSystemFont,   "Chicago",            "Chicago",          FF_ROMAN,      ANSI_CHARSET },
   { FntNewYork,      "New York",           "New York",         FF_ROMAN,      ANSI_CHARSET },
   { FntGeneva,       "Geneva",             "Geneva",           FF_SWISS,      ANSI_CHARSET },
   { FntMonaco,       "Monaco",             "Monaco",           FF_MODERN,     ANSI_CHARSET },
   { FntVenice,       "Venice",             "Venice",           FF_ROMAN,      ANSI_CHARSET },
   { FntLondon,       "London",             "London",           FF_ROMAN,      ANSI_CHARSET },
   { FntAthens,       "Athens",             "Athens",           FF_ROMAN,      ANSI_CHARSET },
   { FntSanFran,      "San Francisco",      "San Francisco",    FF_SWISS,      ANSI_CHARSET },
   { FntToronto,      "Toronto",            "Toronto",          FF_SWISS,      ANSI_CHARSET },
   { FntCairo,        "Cairo",              "Cairo",            FF_DECORATIVE, SYMBOL_CHARSET },
   { FntLosAngeles,   "Los Angeles",        "Los Angeles",      FF_SWISS,      ANSI_CHARSET },
   { FntZapfDingbats, "Zapf Dingbats",      "ZapfDingbats",     FF_DECORATIVE, SYMBOL_CHARSET },
   { FntBookman,      "Bookman",            "Bookman",          FF_ROMAN,      ANSI_CHARSET },
   { FntHelvNarrow,   "N Helvetica Narrow", "Helvetica-Narrow", FF_SWISS,      ANSI_CHARSET },
   { FntPalatino,     "Palatino",           "Palatino",         FF_ROMAN,      ANSI_CHARSET },
   { FntZapfChancery, "Zapf Chancery",      "ZapfChancery",     FF_ROMAN,      ANSI_CHARSET },
   { FntTimes,        "Times",              "Times",            FF_ROMAN,      ANSI_CHARSET },
   { FntHelvetica,    "Helvetica",          "Helvetica",        FF_SWISS,      ANSI_CHARSET },
   { FntCourier,      "Courier",            "Courier",          FF_MODERN,     ANSI_CHARSET },
   { FntSymbol,       "Symbol",             "Symbol",           FF_DECORATIVE, SYMBOL_CHARSET },
   { FntMobile,       "Mobile",             "Mobile",           FF_DECORATIVE, SYMBOL_CHARSET },
   { FntAvantGarde,   "Avant Garde",        "AvantGarde",       FF_SWISS,      ANSI_CHARSET },
   { FntNewCentury,   "New Century Schlbk", "NewCenturySchlbk", FF_ROMAN,      ANSI_CHARSET },
   { FntMTExtra,      "MT Extra",           "MT Extra",         FF_DECORATIVE, MTEXTRA_CHARSET },
   { FntUnknown,      "Fences",             "Fences",           FF_DECORATIVE, FENCES_CHARSET },
   { FntUnknown,      "",                   "",                 FF_ROMAN,      ANSI_CHARSET },
   { FntUnknown,      "",                   "",                 FF_ROMAN,      ANSI_CHARSET }
};

private Byte trueTypeSub[NumTTSubs][MaxFntName] =
{
   "Monotype Sorts",
   "Bookman Old Style",
   "Arial Narrow",
   "Book Antiqua",
   "Monotype Corsiva",
   "Times New Roman",
   "Arial",
   "Courier New",
   "Symbol",
   "Mobile",
   "Century Gothic",
   "Century Schoolbook"
};

private Byte MacToAnsiTable[128] =
{
   0xC4, /* 80 -- upper case A with diaeresis or umlaut mark */
   0xC5, /* 81 -- upper case A with ring */
   0xC7, /* 82 -- upper case C with cedilla */
   0xC9, /* 83 -- upper case E with accute accent */
   0xD1, /* 84 -- upper case N with tilde */
   0xD6, /* 85 -- upper case O with diaeresis or umlaut mark */
   0xDC, /* 86 -- upper case U with diaeresis or umlaut mark */
   0xE1, /* 87 -- lower case a with accute accent */
   0xE0, /* 88 -- lower case a with grave accent */
   0xE2, /* 89 -- lower case a with circumflex accent */
   0xE4, /* 8A -- lower case a with diaeresis or umlaut mark */
   0xE3, /* 8B -- lower case a with tilde */
   0xE5, /* 8C -- lower case a with ring */
   0xE7, /* 8D -- lower case c with cedilla */
   0xE9, /* 8E -- lower case e with accute accent */
   0xE8, /* 8F -- lower case e with grave accent */
   0xEA, /* 90 -- lower case e with circumflex accent */
   0xEB, /* 91 -- lower case e with diaeresis or umlaut mark */
   0xED, /* 92 -- lower case i with accute accent */
   0xEC, /* 93 -- lower case i with grave accent */
   0xEE, /* 94 -- lower case i with circumflex accent */
   0xEF, /* 95 -- lower case i with diaeresis or umlaut mark */
   0xF1, /* 96 -- lower case n with tilde */
   0xF3, /* 97 -- lower case o with accute accent */
   0xF2, /* 98 -- lower case o with grave accent */
   0xF4, /* 99 -- lower case o with circumflex accent */
   0xF6, /* 9A -- lower case o with diaeresis or umlaut mark */
   0xF5, /* 9B -- lower case o with tilde */
   0xFA, /* 9C -- lower case u with accute accent */
   0xF9, /* 9D -- lower case u with grave accent */
   0xFB, /* 9E -- lower case u with circumflex accent */
   0xFC, /* 9F -- lower case u with diaeresis or umlaut mark */
   0x86, /* A0 -- UNS -  MAC A0 <new> */
   0xB0, /* A1 -- degrees */
   0xA2, /* A2 -- cent currency symbol */
   0xA3, /* A3 -- pound currency  */
   0xA7, /* A4 -- section separator */
   0x95, /* A5 -- bullet <changed from B7> */
   0xB6, /* A6 -- paragraph (cp > 0x80) */
   0xDF, /* A7 -- beta */
   0xAE, /* A8 -- registered */
   0xA9, /* A9 -- copyright */
   0x99, /* AA -- trade mark <new> */
   0xB4, /* AB -- apostrophe */
   0xA8, /* AC -- space with diaeresis or umlaut mark */
   0xB0, /* AD -- not equal <unused1> */
   0xC6, /* AE -- UPPER CASE AE */
   0xD8, /* AF -- UNS - ANSI D8 */
   0x81, /* B0 -- infinity <unused2> */
   0xB1, /* B1 -- plus minus */
   0x8A, /* B2 -- <= <unused3> */
   0x8D, /* B3 -- >= <unused4> */
   0xA5, /* B4 -- yen currency symbol */
   0xB5, /* B5 -- UNS - ANSI B5 */
   0x8E, /* B6 -- lower case Delta <unused5> */
   0x8F, /* B7 -- Sigma <unused6> */
   0x90, /* B8 -- upper case Pi <unused7> */
   0x9A, /* B9 -- lower case  pi <unused8> */
   0x9D, /* BA -- upper integral <unused9> */
   0xAA, /* BB -- super script a w/underscore */
   0xBA, /* BC -- UNS - ANSI BA */
   0x9E, /* BD -- Omega <unused10> */
   0xE6, /* BE -- lower case ae */
   0xF8, /* BF -- UNS - ANSI F8 */
   0xBF, /* C0 -- upside down ? */
   0xA1, /* C1 -- upside down < */
   0xAC, /* C2 -- UNS - ANSI AC */
   0xA6, /* C3 -- square root <unused11> */
   0x83, /* C4 -- function (f) <new> */
   0xAD, /* C5 -- UNS - 437 F7 <unused12> */
   0xB2, /* C6 -- upper case delta <unused13> */
   0xAB, /* C7 -- << */
   0xBB, /* C8 -- >> */
   0x85, /* C9 -- elipsis <new> */
   0xA0, /* CA -- non breaking space <new> */
   0xC0, /* CB -- upper case A with grave accent */
   0xC3, /* CC -- upper case A with tilde */
   0xD5, /* CD -- upper case O with tilde */
   0x8C, /* CE -- upper case CE <new> */
   0x9C, /* CF -- lower case CE <new> */
   0x96, /* D0 -- dash <changed from AD> */
   0x97, /* D1 -- m dash <changed from 96> */
   0x93, /* D2 -- double open quote */
   0x94, /* D3 -- double close quote */
   0x91, /* D4 -- single open quote */
   0x92, /* D5 -- single close quote */
   0xF7, /* D6 -- divide <new> */
   0xB3, /* D7 -- open diamond <unused14> */
   0xFF, /* D8 -- lower case y with diaeresis or umlaut mark */
   0x9F, /* D9 -- Undefined <new upper case y with diaeresis or umlaut mark> */
   0xB9, /* DA -- Undefined <new forward slash> */
   0xA4, /* DB -- UNS - ANSI A4. */
   0x8B, /* DC -- Undefined <new less than sign> */
   0x9B, /* DD -- Undefined <new greater than sign> */
   0xBC, /* DE -- Undefined <unused15 connected fi> */
   0xBD, /* DF -- Undefined <unused16 connected fl> */
   0x87, /* E0 -- Undefined <new double cross> */
   0xB7, /* E1 -- Undefined <new bullet character> */
   0x82, /* E2 -- Undefined <new single lower smart quote> */
   0x84, /* E3 -- Undefined <new double lower smart quote> */
   0x89, /* E4 -- Undefined <new weird percent sign> */
   0xC2, /* E5 -- upper case A with circumflex accent. */
   0xCA, /* E6 -- upper case E with circumflex accent. */
   0xC1, /* E7 -- upper case A with accute accent. */
   0xCB, /* E8 -- upper case E with diaeresis or umlaut mark. */
   0xC8, /* E9 -- upper case E with grave accent. */
   0xCD, /* EA -- upper case I with accute accent. */
   0xCE, /* EB -- upper case I with circumflex accent. */
   0xCF, /* EC -- upper case I with diaeresis or umlaut mark. */
   0xCC, /* ED -- upper case I with grave accent. */
   0xD3, /* EE -- upper case O with accute accent. */
   0xD4, /* EF -- upper case O with circumflex accent. */
   0xBE, /* F0 -- Undefined <unused17 apple character> */
   0xD2, /* F1 -- upper case O with grave accent. */
   0xDA, /* F2 -- upper case U with accute accent. */
   0xDB, /* F3 -- upper case U with circumflex accent. */
   0xD9, /* F4 -- upper case U with grave accent. */
   0xD0, /* F5 -- Undefined <unsused18 i with no dot> */
   0x88, /* F6 -- Undefined <new hat ligature> */
   0x98, /* F7 -- Undefined <new tilde ligature> */
   0xAF, /* F8 -- Undefined <new bar ligature> */
   0xD7, /* F9 -- Undefined <unused18 upside-down bow ligature> */
   0xDD, /* FA -- Undefined <unused19 dot ligature> */
   0xDE, /* FB -- Undefined <unused20 open dot ligature> */
   0xB8, /* FC -- space with cedilla. */
   0xF0, /* FD -- Undefined <unused21 double upper smart quote> */
   0xFD, /* FE -- Undefined <unused22 lower right bow ligature> */
   0xFE  /* FF -- Undefined <unused23 upside-down hat ligature> */
};

/*--- Default logical structures ---*/

typedef struct
{
   BITMAPINFOHEADER     bmiHeader;
   RGBQUAD              bmiColors[2];
   DWORD                pattern[8];

} PatBrush, far * PatBrushLPtr;

private  PatBrush patBrushSkel =
{
   {
      sizeof( BITMAPINFOHEADER ),      // size of header structure
      8,                               // width = 8
      8,                               // height = 8
      1,                               // planes = 1
      1,                               // number of bits/pixel = 1
      BI_RGB,                          // non-compressed bitmap
      8,                               // image size (in bytes)
      (DWORD)(72 * 39.37),             // XPelsPerMeter = 72 dpi * mm/inch
      (DWORD)(72 * 39.37),             // YPelsPerMeter = 72 dpi * mm/inch
      0,                               // all 2 colors used
      0                                // all colors important
   },
   {
      { 0, 0, 0, 0 },                  // background color
      { 0, 0, 0, 0 }                   // foreground (text) color
   },
   { 0, 0, 0, 0, 0, 0, 0, 0 }          // uninitialized pattern data
};


private  LOGFONT logFontSkel =
{
   0,                                  // height - will be set
   0,                                  // width = match aspect ratio
   0,                                  // escapement = no rotation
   0,                                  // orientation = no rotation
   FW_NORMAL,                          // weight = normal
   0,                                  // italics = no
   0,                                  // underline = no
   0,                                  // strikeout = no
   ANSI_CHARSET,                       // charset = ANSI
   OUT_DEFAULT_PRECIS,                 // default output precision
   CLIP_DEFAULT_PRECIS,                // default clipping precision
   DEFAULT_QUALITY,                    // default output quality
   DEFAULT_PITCH | FF_DONTCARE,        // default pitch and family
   cNULL                               // no face name - will be set
};


/*********************** Private Function Definitions ***********************/

private Boolean IsArithmeticMode( Integer mode );
/* return TRUE if this is an arithmetic transfer mode */


#define /* Boolean */ IsHiddenPenMode( /* Integer */ mode )             \
/* return TRUE if this is a hidden pen transfer mode */                 \
(mode == QDHidePen)


private void CalculatePenSize( Point startPt, Point endPt, Point penSize );
/* calcuate the pen width to produce equivalent QuickDraw stroke */


private Boolean SetAttributes( GrafVerb verb );
/* set up pen and brush elements according to GrafVerb */


private Boolean SetPenAttributes( GrafVerb verb );
/* make sure that pen attributes are OK according to preferences */


private Boolean SetBrushAttributes( GrafVerb verb );
/* set up the correct brush (fill) for the ensuing primitive */


private void MakePatternBrush( PixPatLPtr pixPatLPtr );
/* Make a new pattern brush using pixelPat passed in */


private Boolean IsSolidPattern( PixPatLPtr pixPatLPtr,
                                RGBColor far * rgbColor,
                                Boolean mixColors );
/* return true if pattern is solid, false if not.  If mixColors is TRUE, then
   mixtures of 25%, 50%, and 75% grey are mixed into a solid color */


private Boolean FrameMatchesFill( Word primType );
/* return TRUE if the fill pattern (current brush ) matches frame pattern */


private Boolean SetTextAttributes( void );
/* set up text attributes - set mapChars to TRUE if should map to ANSI */


private Integer FindGdiFont( void );
/* return an index to the current font selection */


private void MacToAnsi( StringLPtr string );
/* convert extended characters from Mac to ANSI equivalent */


private void MakeDIB( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                      Handle far * headerHandleLPtr,
                      Handle far * bitsHandleLPtr,
                      Boolean packDIB );
/* Create a Windows device-independant bitmap */


void GdiEPSData(PSBuf far* psbuf);
/* Output PostScript data as GDI POSTSCRIPT_DATA Escape */


private Boolean MakeMask( Handle mask, Boolean patBlt );
/* Create a mask that will be used in the ensuing StretchDIBits call
   Return TRUE if region was created, FALSE if rectangular region */


void InvertBits( Byte far * byteLPtr, Integer start, Integer count );
/* invert all bits in byteLPtr from bit offset start for count bits */


void hmemcpy( Byte huge * src, Byte huge * dst, Integer count );
/* copy count bytes from source to destination - assumes even count */


void hexpcpy( Byte huge * src, Byte huge * dst, Integer count, Integer bits );
/* copy count bytes to destination, expand each 2 bits to nibble of if
   16-bit image, expand to 24 bits */


void hmrgcpy( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr, Integer dibWidth );
/* if the is a 24-bit image, then the components are separated into scanlines
   of red, green and blue.  Merge into single scanline of 24-bit RGB pixels */


void hrlecpy256( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr,
                 Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB );
/* 256 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */


void hrlecpy16( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr,
                 Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB );
/* 16 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */


#define /* void */ GdiMarkAsCurrent( /* Integer */ attribCode )         \
/* indicate that the current attribute is current */                    \
gdiEnv.state[attribCode] = Current


#define /* void */ GdiAttribHasChanged( /* Integer */ attribCode )      \
/* return TRUE if the attribute has changed */                          \
(gdiEnv.state[attribCode] == Changed)


#define /* Boolean */ EmptyRect( /* Rect */ r )                         \
/* TRUE if a given rectangle has a zero delta in X or Y direction */    \
(((r.right) - (r.left) == 0) || ((r.bottom) - (r.top) == 0))


#define /* Boolean */ odd( /* Integer */ i )                            \
/* return TRUE if given integer is odd, FALSE if even */                \
((i) & 0x0001)


#define /* Integer */ RValue( /* RGBColor */ color )                    \
/* coerce the value of Byte color component to Integer */               \
((Integer)(GetRValue( color )))


#define /* Integer */ GValue( /* RGBColor */ color )                    \
/* coerce the value of Byte color component to Integer */               \
((Integer)(GetGValue( color )))


#define /* Integer */ BValue( /* RGBColor */ color )                    \
/* coerce the value of Byte color component to Integer */               \
((Integer)(GetBValue( color )))


/*********************** Function Implementation ****************************/

void GdiOffsetOrigin( Point delta )
/*=================*/
/* offset the current window origin and picture bounding box */
{
   /* flush the cache */
   CaFlushCache();

   /* make sure to make this permanent change that won't be affected by
      changes in clipping rectangles that are otherwise changed between
      SaveDC/RestoreDC pair. */
   CaRestoreDC();

   /* offset the picture bounding box and cached clipping rectangles */
   OffsetRect( &gdiPict.bbox,   delta.x, delta.y );
   OffsetRect( CaGetClipRect(), delta.x, delta.y );

   /* call GDI to reset the origin */
#ifdef WIN32
   SetWindowOrgEx( gdiEnv.metafile, gdiPict.bbox.left, gdiPict.bbox.top, NULL );
#else
   SetWindowOrg( gdiEnv.metafile, gdiPict.bbox.left, gdiPict.bbox.top );
#endif


   /* set up the next clipping frame */
   CaSaveDC();

   /* determine if we need to resend the clipping rectangle */
   if (!EqualRect( CaGetClipRect(), &gdiPict.bbox ))
   {
      /* retrieve the current clipping rectangle */
      Rect rect = *CaGetClipRect();

      /* newly offset clipping rectangle */
      IntersectClipRect( gdiEnv.metafile,
                         rect.left, rect.top, rect.right, rect.bottom );
   }
}



void GdiLineTo( Point newPt )
/*============*/
/* Emit line primitive with square endcaps */
{
   CGrafPort far *   port;
   CaPrimitive       prim;

   /* get port for updated pen location and pen size */
   QDGetPort( &port );

   /* check if the pen has been turned off */
   if (gdiEnv.drawingEnabled &&
      (port->pnSize.x != 0)  && (port->pnSize.y != 0))
   {
      RGBColor       solidRGB;

      /* determine if we are trying to draw with a patterned pen */
      if (!IsSolidPattern( &port->pnPixPat, &solidRGB, NOMIX ))
      {
         if (SetAttributes( GdiPaint))
         {
            Point       delta;

            /* determine if the dimensions in both directions */
            delta.x = newPt.x - port->pnLoc.x;
            delta.y = newPt.y - port->pnLoc.y;

            /* determine if we can simulate using a rectangle primitive */
            if (delta.x == 0 || delta.y == 0)
            {
               /* assign the structures into the cache type */
               prim.type = CaRectangle;
               prim.verb = GdiPaint;

               /* make a rectangle with upper-left, lower-right coords */
               prim.a.rect.bbox.left   = min( port->pnLoc.x, newPt.x );
               prim.a.rect.bbox.top    = min( port->pnLoc.y, newPt.y );
               prim.a.rect.bbox.right  = max( port->pnLoc.x, newPt.x ) + port->pnSize.x;
               prim.a.rect.bbox.bottom = max( port->pnLoc.y, newPt.y ) + port->pnSize.y;
            }
            else
            {
               Point    start;
               Point    end;
               Point    poly[7];
               Point    pnSize = port->pnSize;

               /* make sure that the points follow left->right x direction */
               if (delta.x > 0)
               {
                  start = port->pnLoc;
                  end   = newPt;
               }
               else
               {
                  start = newPt;
                  end   = port->pnLoc;
                  delta.y = - delta.y;
               }

               /* create the simulation of the outline */
               poly[0].x = start.x;
               poly[0].y = start.y;
               poly[1].x = (delta.y > 0) ? start.x + pnSize.x : end.x;
               poly[1].y = (delta.y > 0) ? start.y : end.y;
               poly[2].x = end.x + pnSize.x;
               poly[2].y = end.y;
               poly[3].x = end.x  + pnSize.x;
               poly[3].y = end.y + pnSize.y;
               poly[4].x = (delta.y > 0) ? end.x : start.x + pnSize.x;
               poly[4].y = (delta.y > 0) ? end.y + pnSize.y : start.y + pnSize.y;
               poly[5].x = start.x;
               poly[5].y = start.y + pnSize.y;
               poly[6] = poly[0];

               /* package the polygon for the cache module */
               prim.type = CaPolygon;
               prim.verb = GdiPaint;
               prim.a.poly.numPoints = 7;
               prim.a.poly.pointList = poly;
               prim.a.poly.pnSize.x = 0;
               prim.a.poly.pnSize.y = 0;
            }

            /* cache the primitive */
            CaCachePrimitive( &prim );
         }
      }
      /* eliminate OR'ing of white pen with display surface */
      else if (port->pnMode != QDPatOr || solidRGB != RGB( 255, 255, 255))
      {
         /* set the correct pen size before calling SetPenAttributes() */
         CalculatePenSize( port->pnLoc, newPt, port->pnSize );

         /* setup the correct line color and check whether to continue */
         if (SetPenAttributes( GdiFrame ))
         {
            /* package for the cache module */
            prim.verb = GdiFrame;
            prim.type = CaLine;
            prim.a.line.start = port->pnLoc;
            prim.a.line.end = newPt;
            prim.a.line.pnSize = port->pnSize;

            /* cache the primitive */
            CaCachePrimitive( &prim );
         }
      }
   }

}  /* GdiLineTo */



void GdiRectangle( GrafVerb verb, Rect rect )
/*===============*/
/* Emit rectangle primitive using action and dimensions parameters */
{
   CGrafPort far *   port;
   CaPrimitive       prim;

   /* get port for pen size */
   QDGetPort( &port );

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ))
   {
      RGBColor    solidRGB;

      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaRectangle ))
      {
         /* just flush the cache and return */
         CaFlushCache();
      }
      /* determine if we are trying to draw with a patterned pen */
      else if (verb == GdiFrame && !IsSolidPattern( &port->pnPixPat, &solidRGB, NOMIX ))
      {
         /* flush any pending graphics operations */
         CaFlushCache();

         /* set up the correct attributes for a simulated frameRect */
         if (SetAttributes( GdiPaint))
         {
            Point    poly[10];
            Integer  polyCount[2];
            Point    pnSize = port->pnSize;

            /* make sure that the rectangle outline will fill properly */
            if (Width( rect) < 2 * pnSize.x)
            {
               pnSize.x = Width( rect ) / 2;
            }
            if (Height( rect ) < 2 * pnSize.y)
            {
               pnSize.y = Height( rect ) / 2;
            }

            /* create the simulation of the outline */
            poly[0].x = poly[3].x = rect.left;
            poly[0].y = poly[1].y = rect.top;
            poly[1].x = poly[2].x = rect.right;
            poly[2].y = poly[3].y = rect.bottom;
            poly[4]   = poly[0];

            poly[5].x = poly[8].x = rect.left + pnSize.x;
            poly[5].y = poly[6].y = rect.top + pnSize.y;
            poly[6].x = poly[7].x = rect.right - pnSize.x;
            poly[7].y = poly[8].y = rect.bottom - pnSize.y;
            poly[9]   = poly[5];

            /* set the poly point count for the subpolygons */
            polyCount[0] = polyCount[1] = 5;

            /* flush the cache attributes to set the pen and brush style */
            CaFlushAttributes();

            /* call GDI to render the polypolygon */
            PolyPolygon( gdiEnv.metafile, poly, polyCount, 2);
         }
      }
      /* setup the correct line and fill attribs, check to continue */
      else if (SetAttributes( verb ))
      {
         /* package for the cache module */
         prim.verb = verb;
         prim.type = CaRectangle;
         prim.a.rect.bbox = rect;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiRectangle */



void GdiRoundRect( GrafVerb verb, Rect rect, Point oval )
/*===============*/
/* Emit rounded rectangle primitive */
{
   CaPrimitive    prim;

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ))
   {
      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaRoundRect ))
      {
         /* just flush the cache and return */
         CaFlushCache();
      }
      /* setup the correct line and fill attribs, check to continue */
      else if (SetAttributes( verb ))
      {
         /* package for the cache module */
         prim.verb = verb;
         prim.type = CaRoundRect;
         prim.a.rect.bbox = rect;
         prim.a.rect.oval = oval;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiRRectProc */



void GdiOval( GrafVerb verb, Rect rect )
/*==========*/
/* Emit an oval primitive */
{
   CaPrimitive    prim;

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ))
   {
      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaEllipse ))
      {
         /* just flush the cache and return */
         CaFlushCache();
      }
      /* setup the correct line and fill attribs, check to continue */
      else if (SetAttributes( verb ))
      {
         /* package for the cache module */
         prim.verb = verb;
         prim.type = CaEllipse;
         prim.a.rect.bbox = rect;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiOvalProc */



void GdiArc( GrafVerb verb, Rect rect, Integer startAngle, Integer arcAngle )
/*=========*/
/* Emit an arc primitive */
{
   Boolean        allOk;
   Point          center;
   Point          startPoint;
   Point          endPoint;
   Integer        hypotenuse;
   Integer        rectWidth;
   Integer        rectHeight;
   Real           startRadian;
   Real           arcRadian;
   Real           scaleFactor;
   Boolean        scaleVertically;
   CaPrimitive    prim;

   /* make sure that drawing is enabled and non-empty rectangle and sweep */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ) && (arcAngle != 0 ))
   {
      /* see what type of primitive will be created */
      prim.type = (verb == GdiFrame) ? CaArc : CaPie;

      /* if drawing an arc, only the pen attributes need be set */
      if (prim.type == CaArc)
      {
         /* set same object state to FALSE if framing - Gdi will render the
            entire outline of the pie, whereas in QuickDraw, only the outer
            edge of the pie is drawn. */
         gdiEnv.sameObject = FALSE;

         /* notify the cache module that this isn't the same object */
         CaSamePrimitive( FALSE );

         /* set up only the pen attributes */
         allOk = SetPenAttributes( verb );
      }
      else
      {
         /* otherwise, set pen and brush attributes */
         allOk = SetAttributes( verb );
      }

      /* check whether attributes were set up correctly and to proceed */
      if (allOk)
      {
         /* Calculate width and height of source rectangle. */
         rectWidth  = Width( rect );
         rectHeight = Height( rect );

         /* Determine size of smallest enclosing square and set hypotenuse
            to 1/2 width of resulting square */
         if (rectWidth > rectHeight)
         {
            hypotenuse = rectWidth / 2;
            scaleVertically = TRUE;
            scaleFactor = (Real)rectHeight / (Real)rectWidth;
         }
         else
         {
            hypotenuse = rectHeight / 2;
            scaleVertically = FALSE;
            scaleFactor = (Real)rectWidth / (Real)rectHeight;
         }

         /* adjust hypotenuse size if possible GDI divide by zero possible */
         if (hypotenuse < 100)
         {
            /* note that start and end points don't have to lie on arc */
            hypotenuse = 100;
         }

         /* find the center point of bounding rectangle */
         center.x = rect.left + rectWidth / 2;
         center.y = rect.top  + rectHeight /2;

         /* check if the arc is drawn in a counter-clockwise direction */
         if (arcAngle < 0)
         {
            Integer     tempArcAngle;

            /* if rendering counter-clockwise, then swap the start and end
               points so the rendering will occur in clockwise direction */
            tempArcAngle = arcAngle;
            arcAngle = startAngle;
            startAngle += tempArcAngle;
         }
         else
         {
            /* clockwise rendering - just add the arc angle to start angle */
            arcAngle += startAngle;
         }

         /* Determine the start and arc angles in radians */
         startRadian = ((Real)startAngle / 360.0) * TwoPi;
         arcRadian = ((Real)arcAngle / 360.0) * TwoPi;

         /* calculate the start and endpoints.  Note negation of y coordinate since
            the positive direction is downward.  Also note that the start and
            end points are being swapped, since QuickDraw renders in clock-
            wise direction and GDI renders in counter-clockwise direction */
         endPoint.x = (Integer)(sin( startRadian ) * hypotenuse);
         endPoint.y = (Integer)(-cos( startRadian ) * hypotenuse);

         startPoint.x = (Integer)(sin( arcRadian ) * hypotenuse);
         startPoint.y = (Integer)(-cos( arcRadian ) * hypotenuse);

         /* scale the resulting points in the vertical or horizontal direction
            depending on the setting of scaleVertically boolean */
         if (scaleVertically)
         {
            endPoint.y = (Integer)(endPoint.y * scaleFactor);
            startPoint.y = (Integer)(startPoint.y * scaleFactor);
         }
         else
         {
            endPoint.x = (Integer)(endPoint.x * scaleFactor);
            startPoint.x = (Integer)(startPoint.x * scaleFactor);
         }

         /* using the transformed points, use centerPoint to determine the correct
            starting and ending points */
         startPoint.x += center.x;
         startPoint.y += center.y;

         endPoint.x += center.x;
         endPoint.y += center.y;

         /* package for the cache module.  The type was set at beginning */
         prim.verb = verb;
         prim.a.arc.bbox = rect;
         prim.a.arc.start = startPoint;
         prim.a.arc.end = endPoint;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiArc */



void GdiPolygon( GrafVerb verb, Handle poly )
/*=============*/
/* Emit polygon primitive */
{
   Integer           numPoints;
   Integer           lastPoint;
   Point far *       pointList;
   Integer far *     polyCountLPtr;
   Boolean           closed;
   Boolean           allOk;
   CGrafPort far *   port;
   CaPrimitive       prim;

   /* get port for updated pen location and pen size */
   QDGetPort( &port );

   /* make sure that drawing is enabled */
   if (gdiEnv.drawingEnabled)
   {
      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaPolygon ) &&
         (port->pnSize.x == 1 && port->pnSize.y == 1))
      {
         /* just flush the cache and return */
         CaFlushCache();
         return;
      }

      /* lock the polygon handle to access individual fields */
      polyCountLPtr = (Integer far *)GlobalLock( poly );
      pointList = (Point far *)(polyCountLPtr +
                  (PolyHeaderSize / sizeofMacWord));

      /* determine number of points based on first word = length field */
      numPoints = (*polyCountLPtr - PolyHeaderSize) / sizeofMacPoint;

      /* determine if this is a closed polygon */
      lastPoint = numPoints - 1;
      closed = ((pointList->x == (pointList + lastPoint)->x) &&
                (pointList->y == (pointList + lastPoint)->y));

      /* determine what type of primitive to render */
      prim.type = (verb == GdiFrame && !closed) ? CaPolyLine : CaPolygon;

      /* if drawing a polyline, only the pen attributes need be set */
      if (prim.type == CaPolyLine)
      {
         /* set same object state to FALSE if drawing a polyline */
         gdiEnv.sameObject = FALSE;

         /* notify the cache module that this isn't the same object */
         CaSamePrimitive( FALSE );

         /* set up only the pen attributes */
         allOk = SetPenAttributes( verb );
      }
      else
      {
         /* otherwise, set pen and brush attributes */
         allOk = SetAttributes( verb );
      }

      /* check whether attribute setup succeeded - continue or not */
      if (allOk)
      {
         /* package for the cache module - type was set above */
         prim.verb = verb;
         prim.a.poly.numPoints = numPoints;
         prim.a.poly.pointList = pointList;
         prim.a.poly.pnSize    = port->pnSize;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }

      /* Unlock the data */
      GlobalUnlock( poly );
   }

}  /* GdiPoly */



void GdiRegion( GrafVerb verb, Handle rgn )
/*=============*/
/* Emit region primitive */
{
   Integer far *     rgnCountLPtr;
   Integer           numPoints;
   Rect              rgnBBox;
   CGrafPort far *   port;

   /* get port for updated pen location and pen size */
   QDGetPort( &port );

   /* lock the region handle to access individual fields */
   rgnCountLPtr = (Integer far *)GlobalLock( rgn );

   /* determine the bounding box of the region */
   rgnBBox = *((Rect far *)(rgnCountLPtr + 1));

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rgnBBox ))
   {
      /* determine number of points based on first word = length field */
      numPoints = (*rgnCountLPtr - RgnHeaderSize) / sizeofMacPoint;

      /* determine if we should just be drawing a rectangle */
      if (numPoints == 0 )
      {
         /* simulate region using rectangle primitive */
         GdiRectangle( verb, *((Rect far *)(rgnCountLPtr + 1)) );
      }
      else
      {
         /* determine if we are filling using a pre-set brush */
         switch (verb)
         {
            /* can simulate the region using a brush and mask */
            case GdiPaint:
            case GdiFill:
            case GdiErase:
            {
               /* set up the brush attributes for the ensuing StretchBlt */
               SetBrushAttributes( verb );

               /* call to MakeMask() will generate the bitblt operations */
               MakeMask( rgn, TRUE );
               break;
            }

            /* otherwise, just ignore the opcode */
            default:
               break;
         }
      }
   }

   /* Unlock the data */
   GlobalUnlock( rgn );

}  /* GdiRegion */



void GdiTextOut( StringLPtr string, Point location )
/*=============*/
/* draw the text at the location specified. */
{
   CGrafPort far *   port;

   /* get port for updated pen location */
   QDGetPort( &port );

   /* make sure that drawing is enabled */
   if (gdiEnv.drawingEnabled)
   {
      /* flush any cached primitive elements */
      CaFlushCache();

      /* set up the correct text attributes before continuing */
      if (SetTextAttributes())
      {
         Integer  strLen;

         /* determine the number of characters in the string */
         strLen = lstrlen( string );

         /* convert the individual characters from Mac to ANSI char set */
         MacToAnsi( string );

         /* call textout to display the characters */
         TextOut( gdiEnv.metafile, location.x, location.y,
                  string, strLen );
      }
   }

}  /* GdiTextOut */



void GdiStretchDIBits( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                       Rect src, Rect dst, Word mode, Handle mask )
/*===================*/
/* Draw a Windows device-independant bitmap */
{
   Handle            bitsInfoHandle;
   Handle            bitsHandle;
   LPBITMAPINFO      bitsInfoLPtr;
   Byte far *        bitsLPtr;
   Boolean           bitmapMask;
   Boolean           patternBlt;
   Boolean           clipRectSet;

   /* for now, assume no rectangular clip rectangle is set up */
   clipRectSet = FALSE;

   /* if a mask is present, call MakeDIB to create it */
   if (mask)
   {
      /* if a region mask is present, then call create the mask.  This will
         result in a recursive call to this routine.  If the routine returns
         FALSE, no region was created - this is a rectangular clip. */
      clipRectSet = !MakeMask( mask, FALSE );

      /* free the data block */
      GlobalFree( mask );

      if (clipRectSet)
      {
         /* if no mask was created, set mask to NULL to get SRCCOPY ROP */
         mask = NULL;
      }
   }

   /* make sure that drawing is enabled and non-empty source and/or
      destination rectangles in the bitmap record */
   if (gdiEnv.drawingEnabled && !EmptyRect( src ) && !EmptyRect( dst ))
   {
      /* determine if we are rendering the monochrome bitmap mask */
      bitmapMask = (mode == -1 || mode == -2);
      patternBlt = (mode == -2);

      /* if this is the mask, change the mode to the correct setting */
      if (bitmapMask)
      {
         /* yes, bitmap mask - change the mode to source copy */
         mode = QDSrcCopy;
      }

      /* flush the cache before proceeding */
      CaFlushCache();

      /* Create a DIB using the information passed in */
      MakeDIB( pixMapLPtr, pixDataHandle, &bitsInfoHandle, &bitsHandle, FALSE );

      /* make sure that everything went OK */
      if (ErGetGlobalError() == NOERR)
      {
         DWord       ropCode;
         RGBQUAD     secondFgColor = {0};
         Byte        pass;
         Byte        numPasses;
         Boolean     twoColorDIB;

         /* determine if we are working with a 2 color DIB */
         twoColorDIB = pixMapLPtr->pixelSize == 1;

         if (mask)
         {
            /* if mask is already rendered, then AND in the remaining bits
               to cover the areas that have been turned to white */
            ropCode = SRCAND;
         }
         else if (patternBlt)
         {
            /* drawing a white on black bitmap - we want all the areas that
               are black to leave the destination untouched, and where white
               to draw with the currently selected brush.  Check Petzold
               "Programming Windows v3", pages 622-623. DSPDxax operation */
            ropCode = 0x00E20746;
         }
         else if (bitmapMask)
         {
            /* drawing the mask bitmap - OR in all bits to create white mask
               that will be overlaid in the ensuing operation with color */
            ropCode = SRCPAINT;
         }
         else if (!twoColorDIB &&
                 (mode == QDSrcOr || mode == QDAdMin || mode == QDTransparent))
         {
            /* check for the special case found in Illustrator EPS images,
               where a monochrome bitmap is used to clear an area, followed
               by a multi-color DIB drawn in QDSrcOr mode - we don't want to
               convert this to a SRCCOPY mode.  Instead, this simulated
               transparecy is done in a fashion similar to region masks. */
            ropCode = SRCAND;
         }
         else
         {
            /* otherwise, use a "normal" transfer mode.  This entails that
               there is no transparency present in the bitmap rendering */
            ropCode = SRCCOPY;
         }

         /* Lock the data to obtain pointers for call to StretchDIBits */
         bitsLPtr = (Byte far *)GlobalLock( bitsHandle );
         bitsInfoLPtr = (LPBITMAPINFO)GlobalLock( bitsInfoHandle );

         /* assume that only one pass is required */
         numPasses = 1;

         /* some special handling of two-color DIBs for transparency */
         if (twoColorDIB && (mode == QDSrcOr || mode == QDSrcBic))
         {
            RGBQUAD  bmiWhite = { 255, 255, 255, 0 };
            RGBQUAD  bmiBlack = {   0,   0,   0, 0 };

            /* determine if we should use the PowerPoint optimizations */
            if (gdiPrefsLPtr->optimizePP)
            {
               /* use the specialized SRCPAINT rop code - flag transparency */
               ropCode = SRCPAINT;

               /* if trying to clear all bits... */
               if (mode == QDSrcBic)
               {
                  /* ... swap foreground with background color -
                     the background is set to white in ensuing operation */
                  bitsInfoLPtr->bmiColors[0] = bitsInfoLPtr->bmiColors[1];
               }
            }
            else
            {
               /* save the foreground color for the second iteration ... */
               secondFgColor = (mode == QDSrcOr) ? bitsInfoLPtr->bmiColors[0] :
                                                   bitsInfoLPtr->bmiColors[1] ;

               /* assume two passes required - 1 for mask, 2 for color blt */
               numPasses = 2;

               /* check if all the RGB components are the same */
               if ((mode == QDSrcOr) && (secondFgColor.rgbRed == 0) &&
                   (secondFgColor.rgbRed == secondFgColor.rgbGreen) &&
                   (secondFgColor.rgbRed == secondFgColor.rgbBlue))
               {
                  /* if black or white, only one pass will be required */
                  numPasses = 1;
               }

               /* will draw a black transparent bitmap first, followed
                  on 2nd iteration is SRCPAINT - or'ing operation to color */
               ropCode = SRCAND;

               /* set the foreground to black */
               bitsInfoLPtr->bmiColors[0] = bmiBlack;
            }

            /* set the background color to white */
            bitsInfoLPtr->bmiColors[1] = bmiWhite;
         }

         /* call StretchDIBits once (PowerPoint) or twice (some others) */
         for (pass = 0; pass < numPasses; pass++)
         {
            /* set up the text and background color for the metafile */
            if (twoColorDIB)
            {
               RGBColor    fgColor;
               RGBColor    bkColor;
               RGBColor    black = RGB( 0, 0, 0 );

               /* determine fore- and background color in the DIB header */
               fgColor = RGB( bitsInfoLPtr->bmiColors[0].rgbRed,
                              bitsInfoLPtr->bmiColors[0].rgbGreen,
                              bitsInfoLPtr->bmiColors[0].rgbBlue );
               bkColor = RGB( bitsInfoLPtr->bmiColors[1].rgbRed,
                              bitsInfoLPtr->bmiColors[1].rgbGreen,
                              bitsInfoLPtr->bmiColors[1].rgbBlue );

               /* don't change text and background colors if performing a
                  pattern blt.  Otherwise, change to the DIB palette colors */
               if (!patternBlt)
               {
                  CaSetTextColor( fgColor );
                  CaSetBkColor( bkColor );
               }

               /* set the stretch mode to correct setting */
               CaSetStretchBltMode( (fgColor == black) ? BLACKONWHITE :
                                                         WHITEONBLACK );
            }
            else
            {
               /* if drawing a color bitmap, set the stretch mode accordingly */
               CaSetStretchBltMode( COLORONCOLOR );
            }

            /* call Gdi routine to draw bitmap */
            StretchDIBits( gdiEnv.metafile,
                           dst.left, dst.top, Width( dst ), Height( dst ),
                           src.left - pixMapLPtr->bounds.left,
                           src.top  - pixMapLPtr->bounds.top,
                           Width( src ), Height( src ),
                           bitsLPtr, bitsInfoLPtr, DIB_RGB_COLORS, ropCode );

            /* if this is the first pass, and a second is required ... */
            if (pass == 0 && numPasses == 2)
            {
               /*  set the new ROP code */
               ropCode = SRCPAINT;

               /* set the new background (black) and foreground colors */
               bitsInfoLPtr->bmiColors[1] = bitsInfoLPtr->bmiColors[0];
               bitsInfoLPtr->bmiColors[0] = secondFgColor;
            }
         }

         /* unlock the data and de-allocate it */
         GlobalUnlock( bitsHandle );
         GlobalUnlock( bitsInfoHandle );

         GlobalFree( bitsHandle );
         GlobalFree( bitsInfoHandle );
      }
   }

   /* De-allocate memory used for the pixel data */
   GlobalFree( pixDataHandle );

   /* if a rectangular clipping region was set up, restore original clip */
   if (clipRectSet)
   {
      /* Call Gdi module to change the clipping rectangle back to the
         previous settting before bitblt operation */
      gdiEnv.drawingEnabled = CaIntersectClipRect( gdiEnv.clipRect );
   }

}  /* GdiStretchDIBits */



void GdiSelectClipRegion( RgnHandle rgn )
/*======================*/
/* Create a clipping rectangle or region using handle passed */
{
   Integer far *  sizeLPtr;
   Boolean        arbitraryClipRgn;
   Comment        gdiComment;

   /* lock down the handle and emit rectangular clip region */
   sizeLPtr = (Integer far *)GlobalLock( rgn );

   /* Save the Gdi clip rectangle (used for EPS translation) */
   gdiEnv.clipRect = *((Rect far *)(sizeLPtr + 1));

   /* determine if this is a non-rectangular clipping region */
   arbitraryClipRgn = (*sizeLPtr > RgnHeaderSize);

   /* flag the clipping region if this is non-rectangular */
   if (arbitraryClipRgn)
   {
      /* check preference memory to see what action to take */
      if (gdiPrefsLPtr->nonRectRegionAction == GdiPrefAbort)
      {
         /* set global error if user request abort */
         ErSetGlobalError( ErNonRectRegion );
         return;
      }
      /* creating clipping region - emit comment to flag construct */
      else
      {
         /* put this in as a private comment */
         gdiComment.signature = POWERPOINT;
         gdiComment.function = PP_BEGINCLIPREGION;
         gdiComment.size = 0;

         /* write the comment to the metafile */
         GdiShortComment( &gdiComment );
      }
   }
   /* make sure that the clipping rectangle is confined to the bounding
      box of the image.  This is a workaround go MacDraft images that
      may contain clipping rectangles of (-32000, -32000),(32000, 32000) */
   IntersectRect( &gdiEnv.clipRect, &gdiEnv.clipRect, &gdiPict.bbox );

   /* Call Gdi module to change the clipping rectangle */
   gdiEnv.drawingEnabled = CaIntersectClipRect( gdiEnv.clipRect );

   /* determine if this is a non-rectangular clip region */
   if (arbitraryClipRgn)
   {
      Integer        excludeSeg[100];
      Integer        yStart[50];
      Integer        yBottom;
      Integer        numSegs;
      Integer far *  rgnLPtr;

      /* notify cache that a non-rectangular clipping region is being set */
      CaNonRectangularClip();

      /* save off the current y offset and first excluded segment */
      yStart[0]     = gdiEnv.clipRect.top;
      excludeSeg[0] = gdiEnv.clipRect.left;
      excludeSeg[1] = gdiEnv.clipRect.right;
      numSegs = 2;

      /* get the beginning of the region data */
      rgnLPtr = sizeLPtr + (RgnHeaderSize / sizeofMacWord);

      /* loop until the end-of-region record is encountered */
      while (*rgnLPtr != 0x7FFF)
      {
         /* copy the new y coordinate to merge */
         yBottom = *rgnLPtr++;

         /* continue looping until end of line marker encountered */
         while (*rgnLPtr != 0x7FFF)
         {
            Integer     start;
            Integer     end;
            Integer     s;
            Integer     e;
            Boolean     sEqual;
            Boolean     eEqual;
            Integer     yTop;
            Integer     left;

            /* determine the start and end point of segment to exclude */
            start = *rgnLPtr++;
            end   = *rgnLPtr++;

            /* find where the insertion point should be */
            for (s = 0; (s < numSegs) && (start > excludeSeg[s]); s++) ;
            for (e = s; (e < numSegs) && (end   > excludeSeg[e]); e++) ;

            /* determine if start and end points == segment ends */
            sEqual = ((s < numSegs) && (start == excludeSeg[s]));
            eEqual = ((e < numSegs) && (end   == excludeSeg[e]));

            /* make sure that this isn't the first scanline, and that
               a valid exclude segment will be referenced in the array.*/
            if ((yBottom != gdiEnv.clipRect.top) && (s != numSegs))
            {
               /* ensure the excluded excludeSeg starts on even offset */
               yTop = s / 2;
               left = yTop * 2;

               /* put the excluded rectangle record into the metafile */
               ExcludeClipRect( gdiEnv.metafile,
                                excludeSeg[left], yStart[yTop],
                                excludeSeg[left + 1], yBottom);

               /* reset the new y coordinate for the excludeSeg */
               yStart[yTop] = yBottom;

               /* determine if 2 segments are affected in merge */
               if (((e - left >= 2 && eEqual && sEqual) ||
                    (e - left >= 2 && eEqual) ||
                    (e - left == 3 && sEqual)))
               {
                  /* if so, put put eliminated cliprect in also */
                  ExcludeClipRect( gdiEnv.metafile,
                                   excludeSeg[left + 2], yStart[yTop + 1],
                                   excludeSeg[left + 3], yBottom);

                  /* reset the y coordinate for this new segment */
                  yStart[yTop + 1] = yBottom;
               }
            }

            /* if start and end fall on existing excludeSegs */
            if (sEqual && eEqual)
            {
               /* segment count reduced by 2 */
               numSegs -= 2;

               /* if two segments are involved in merge

                   0 *---------* 1         2 *--------* 3
                   s *+++++++++++++++++++++++* e
                             0 *======================* 1
               */
               if (e - s == 2)
               {
                  /* move down the end point of the first segment */
                  excludeSeg[s] = excludeSeg[s + 1];
                  yStart[s / 2 + 1] = yStart[s / 2];

                  /* increment the start point for the segment shift */
                  s++;
               }

               /* handle case where a single segment is affected

                   0 *---------* 1         2 *--------* 3
                             s *+++++++++++++* e
                   0 *================================* 1
               */
               /* move all the flats two points to the left */
               for ( ; s < numSegs; s += 2)
               {
                  excludeSeg[s] = excludeSeg[s + 2];
                  excludeSeg[s + 1] = excludeSeg[s + 3];
                  yStart[s / 2] = yStart[s / 2 + 1];
               }
            }
            /* if just the starting point is identical */
            else if (sEqual)
            {
               /* if segment boundary was crossed - 2 segs affected

                   0 *---------* 1    2 *-------------* 3
                             s *++++++++++++++++* e
                   0 *==================* 1   2 *=====* 3
               */
               if ((excludeSeg[s + 1] < end) && (s + 1 < numSegs))
               {
                  /* toggle the start/end points and insert end */
                  excludeSeg[s] = excludeSeg[s + 1];
                  excludeSeg[s + 1] = end;
               }
               /* otherwise, a simple extension of the segment is done

                   0 *---------* 1
                             s *++++++++++++++++++++++* e
                   0 *================================* 1
               */
               else
               {
                  /* assign a new ending point for the excludeSeg */
                  excludeSeg[s] = end;
               }
            }
            /* if just the ending point is identical */
            else if (eEqual)
            {
               /* if segment boundary was crossed - 2 segs affected

                   0 *------------* 1        2 *------* 3
                        s *++++++++++++++++++++* e
                   0 *====* 1   2 *===================* 3
               */
               if ((excludeSeg[e - 1] > start) && (e - 1 > 0))
               {
                  /* toggle the start/end points and insert start */
                  excludeSeg[s + 1] = excludeSeg[s];
                  excludeSeg[s] = start;
               }
               /* otherwise, a simple extension of the segment is done

                                          0 *---------* 1
                   s *++++++++++++++++++++++* e
                   0 *================================* 1
               */
               else
               {
                  /* assign a new starting point for the excludeSeg */
                  excludeSeg[e] = start;
               }
            }
            /* if an entirely new excludeSeg is being created */
            else
            {
               Integer  idx;

               /* create an new set of points */
               numSegs += 2;

               /* move all the flats two points to the right */
               for (idx = numSegs - 1; idx > s; idx -= 2)
               {
                  excludeSeg[idx] = excludeSeg[idx - 2];
                  excludeSeg[idx + 1] = excludeSeg[idx - 1];
                  yStart[idx / 2] = yStart[idx / 2 - 1];
               }

               /* start and endpoints are identical, insert new seg

                   0 *--------------------------------------* 1
                             s *++++++++++++++++* e
                   0 *=========* 1            2 *===========* 3
               */
               if (s == e)
               {
                  /* and insert the new excludeSeg */
                  excludeSeg[s] = start;
                  excludeSeg[s + 1] = end;
                  yStart[s / 2] = yBottom;
               }
               /* otherwise, need to shift in the new points

                   0 *---------------------* 1
                             s *++++++++++++++++++++++++++++* e
                   0 *=========* 1       2 *================* 3
               */
               else
               {
                  excludeSeg[s] = start;
                  excludeSeg[s + 1] = excludeSeg[s + 2];
                  excludeSeg[s + 2] = end;
                  yStart[s / 2] = yBottom;
                  yStart[s / 2 + 1] = yBottom;
               }
            }
         }

         /* increment past the end of line flag */
         rgnLPtr++;
      }

      /* place the end of clip region comment into metafile */
      gdiComment.function = PP_ENDCLIPREGION;
      GdiShortComment( &gdiComment );
   }

   /* unlock the memory handle */
   GlobalUnlock( rgn );

}  /* GdiSelectClipRegion */



void GdiHatchPattern( Integer hatchIndex )
/*==================*/
/* Use the hatch pattern index passed down to perform all ensuing fill
   operations - 0-6 for a hatch value, -1 turns off the substitution */
{
   gdiEnv.hatchIndex = hatchIndex;

}  /* GdiHatchPattern */



void GdiFontName( Byte fontFamily, Byte charSet, StringLPtr fontName )
/*==============*/
/* Set font characteristics based upno metafile comment from GDI2QD */
{
   /* copy the passed values into the font table */
   fontTable[FntFromGdi].family = fontFamily;
   fontTable[FntFromGdi].charset = charSet;
   lstrcpy( fontTable[FntFromGdi].gdiName, fontName );

   /* indicate that the font name should be used - no table lookup */
   gdiEnv.useGdiFont = TRUE;

}  /* GdiFontName */



void GdiShortComment( CommentLPtr cmtLPtr )
/*==================*/
/* Write public or private comment with no associated data */
{
   /* write the comment into the metafile */
   GdiEscape( MFCOMMENT, sizeof( Comment ), (StringLPtr)cmtLPtr );

}  /* GdiComment */



void GdiEscape( Integer function, Integer count, StringLPtr data)
/*============*/
/* Write out a GDI Escape structure with no returned data */
{
   /* Flush the cache before emitting the new metafile record */
   CaFlushCache();

   /* write the comment into the metafile */
   Escape( gdiEnv.metafile, function, count, data, NULL );

}  /* GdiEscape */



void GdiSetConversionPrefs( ConvPrefsLPtr convPrefs)
/*=====================*/
/* Provide conversion preferences via global data block */
{
   /* Save the metafile prefs Open() is issued */
   gdiPrefsLPtr = convPrefs;

}  /* GdiSetConversionPrefs */


void GdiOpenMetafile( void )
/*==================*/
/* Open metafile passed by GdiSetMetafileName() and perform any
   initialization of the graphics state */
{
   /* save metafile handle in global memory structure */
   gdiEnv.metafile = CreateMetaFile( gdiPrefsLPtr->metafileName );
   if (gdiEnv.metafile == NULL)
   {
      ErSetGlobalError( ErCreateMetafileFail );
   }
   else
   {
      /* get a handle to an information context for text metrics */
      gdiEnv.infoContext  = CreateIC( "DISPLAY", NULL, NULL, NULL );
#ifdef _OLECNV32_
      gdiEnv.fontFunction = EnumFontFunc;
#else
      gdiEnv.fontFunction = GetProcAddress( GetModuleHandle( "PICTIMP" ), "EnumFontFunc" );
#endif

      /* initialize the cache module */
      CaInit( gdiEnv.metafile );

      /* set up default logical font structures */
      gdiEnv.newLogFont = logFontSkel;

      /* enable drawing to metafile */
      gdiEnv.drawingEnabled = TRUE;

      /* don't override font table search until font comment is found */
      gdiEnv.useGdiFont = FALSE;

      /* don't use a hatch pattern substitution */
      gdiEnv.hatchIndex = -1;

      /* set the sameObject flag to FALSE and notify cache module */
      gdiEnv.sameObject = FALSE;
      CaSamePrimitive( FALSE );

      /* determine if running on Windows 3.1 or higher */
      if (LOBYTE( GetVersion() ) >= 3 && HIBYTE( GetVersion() ) >= 10 )
      {
         Byte  i;

         /* change the font substitution name to TrueType fonts */
         for (i = 0; i < NumTTSubs; i++)
         {
            lstrcpy( fontTable[TTSubStart + i].gdiName, trueTypeSub[i] );
         }

         /* change the font family for "Symbol" to FF_ROMAN */
         fontTable[FntSymbol].family = FF_ROMAN;

         /* loop through all entries, changing FF_DECORATIVE to FF_DONTCARE */
         for (i = 0; i < FntNoMatch; i++)
         {
            /* check for the family that needs to be changed */
            if (fontTable[i].family == FF_DECORATIVE)
            {
               /* change to FF_DONTCARE */
               fontTable[i].family = FF_DONTCARE;
            }
         }
      }
   }

}  /* GdiOpenMetafile */


void GdiSetBoundingBox( Rect bbox, Integer resolution )
/*====================*/
/* Set the overall picture size and picture resoulution in dpi */
{
   /* make sure this isn't an empty bounding rectangle */
   if (EmptyRect( bbox ))
   {
      /* if an error, then bail out */
      ErSetGlobalError( ErNullBoundingRect );
   }
   /* check if either dimension exceeds 32K - this would be flagged by a
      negative dimension signifying integer overflow condition */
   else if ((Width( bbox ) < 0) || (Height( bbox ) < 0))
   {
      /* indicate that the 32K limit was exceeded */
      ErSetGlobalError( Er32KBoundingRect );
   }
   else
   {
      /* Set up the Window origin in metafile and shadow DC */

#ifdef WIN32
      SetWindowOrgEx( gdiEnv.metafile, bbox.left, bbox.top, NULL );
#else
      SetWindowOrg( gdiEnv.metafile, bbox.left, bbox.top );
#endif

      /* Set window extent in metafile and shadow DC */

#ifdef WIN32
      SetWindowExtEx( gdiEnv.metafile, Width( bbox), Height( bbox ), NULL );
#else
      SetWindowExt( gdiEnv.metafile, Width( bbox), Height( bbox ) );
#endif

      /* Notify cache of the new clipping rectangle */
      CaSetClipRect( bbox );

      /* Notify cache that it should issue metafile defaults before SaveDC() */
      CaSetMetafileDefaults();

      /* Save display context, just in case clipping rect changes */
      CaSaveDC();

      /* Save overall dimensions and resolution in picture results structure */
      gdiPict.bbox = bbox;
      gdiPict.inch = (WORD) resolution;

      /* save the bounding box in the environment as the clipping rectangle */
      gdiEnv.clipRect = bbox;
   }

}  /* GdiSetBoundingBox */


void GdiCloseMetafile( void )
/*===================*/
/* Close the metafile handle and end picture generation */
{
   /* flush the cache before proceeding */
   CaFlushCache();

   /* Balance CaSaveDC() issued at beginning of the metafile */
   CaRestoreDC();

   /* and close the metafile */
   gdiPict.hmf = CloseMetaFile( gdiEnv.metafile );

   /* check the return value from the closemetafile - may be out of memory? */
   if (gdiPict.hmf == NULL)
   {
      ErSetGlobalError( ErCloseMetafileFail );
   }

   /* release the information context */
   DeleteDC( gdiEnv.infoContext );

   /* Close down the cache module */
   CaFini();

   /* if global error occurred, then remove metafile */
   if (ErGetGlobalError() != NOERR)
   {
      DeleteMetaFile( gdiPict.hmf );
      gdiPict.hmf = NULL;
   }

}  /* GdiCloseMetafile */



void GdiGetConversionResults( PictInfoLPtr  pictInfoLPtr )
/*==========================*/
/* return results of the conversion */
{
   /* just assign the saved values into the pointer passed in */
   *pictInfoLPtr = gdiPict;

}  /* GdiGetConversionResults */



void GdiMarkAsChanged( Integer attribCode )
/*===================*/
/* indicate that the attribute passed in has changed */
{
   gdiEnv.state[attribCode] = Changed;

}  /* GdiMarkAsChanged */


void GdiSamePrimitive( Boolean same )
/*===================*/
/* indicate whether next primitive is the same or new */
{
   /* save the state for merging of fill and frame operation */
   gdiEnv.sameObject = (same && (CaGetCachedPrimitive() != CaEmpty));

   CaSamePrimitive( same );

}  /* GdiSamePrimitive */


#ifdef WIN32
int WINAPI EnumFontFunc( CONST LOGFONT *logFontLPtr, CONST TEXTMETRIC *tmLPtr,
                         DWORD fontType, LPARAM dataLPtr )
/*====================*/
#else
int FAR PASCAL EnumFontFunc( LPLOGFONT logFontLPtr, LPTEXTMETRIC tmLPtr,
                             short fontType, LPSTR dataLPtr )
/*========================*/
#endif
/* Callback function used to determine if a given font is available */
{
   /* copy the passed values into the font table */
   fontTable[FntNoMatch].family  = logFontLPtr->lfPitchAndFamily;
   fontTable[FntNoMatch].charset = logFontLPtr->lfCharSet;

   /* this return value will be ignored */
   return TRUE;

   UnReferenced( tmLPtr );
   UnReferenced( fontType );
   UnReferenced( dataLPtr );

}  /* EnumFontFunc */



/******************************* Private Routines ***************************/


private Boolean IsArithmeticMode( Integer mode )
/*------------------------------*/
/* return TRUE if this is an arithmetic transfer mode */
{
   switch (mode)
   {
      case QDBlend:
      case QDAddPin:
      case QDAddOver:
      case QDSubPin:
      case QDAdMax:
      case QDSubOver:
      case QDAdMin:
      {
         return TRUE;
      }

      default:
      {
         return FALSE;
      }
   }

}  /* IsArithmeticMode */


private void CalculatePenSize( Point startPt, Point endPt, Point penSize )
/*---------------------------*/
/* calcuate the pen width to produce equivalent QuickDraw stroke */
{
   Point    delta;
   Real     lineLen;

   /* calcuate x and y delta of line segment */
   delta.x = abs( endPt.x - startPt.x );
   delta.y = abs( endPt.y - startPt.y );

   /* see if we have a vertical or horizontal line.  Otherwise, calculate
      the resulting line length on diagonal line. */
   if (delta.x == 0)
   {
      gdiEnv.newLogPen.lopnWidth.x = penSize.x;
   }
   else if (delta.y == 0)
   {
      gdiEnv.newLogPen.lopnWidth.x = penSize.y;
   }
   /* check if the pen size is 1 in each direction */
   else if ((penSize.x == 1) && (penSize.y == 1))
   {
      /* in this case, it should always be pen width of 1 */
      gdiEnv.newLogPen.lopnWidth.x = 1;
   }
   else
   {
      /* calculate the line length using Pythagorean theorem */
      lineLen = sqrt( ((Real)delta.x * (Real)delta.x) +
                      ((Real)delta.y * (Real)delta.y) );

      /* calculate the correct line diameter */
      gdiEnv.newLogPen.lopnWidth.x = (Integer)((penSize.y * delta.x +
                                                penSize.x * delta.y) / lineLen);
   }

   /* make sure that SetPenAttributes() doesn't change pen width */
   GdiMarkAsCurrent( GdiPnSize );

}  /* CalculatePenSize */



private Boolean SetAttributes( GrafVerb verb )
/*---------------------------*/
/* set up pen and brush elements according to GrafVerb */
{
   Boolean     allOK;

   /* if call to SetPenAttributes() fails, then return false */
   allOK = FALSE;

   /* set up pen attributes */
   if (SetPenAttributes( verb ))
   {
      /* set up brush attributes */
      allOK = SetBrushAttributes( verb );
   }

   /* return continue or stop status */
   return allOK;

}  /* SetAttributes */



private Boolean SetPenAttributes( GrafVerb verb )
/*-----------------------------*/
/* make sure that pen attributes are OK according to preferences */
{
   CGrafPortLPtr     port;

   /* Get the QuickDraw port in order to check pen settings */
   QDGetPort( &port );

   /* see if we are drawing with a NULL pen and can skip all the checks */
   if (verb == GdiFrame)
   {
      /* check for hidden pen mode - don't draw if invalid */
      if (IsHiddenPenMode( port->pnMode ))
      {
         return FALSE;
      }
      /* check for zero-size pen width = don't draw anything */
      else if (port->pnSize.x == 0 || port->pnSize.y == 0)
      {
         return FALSE;
      }

      /* use inside frame to best approximate the QD drawing model */
      gdiEnv.newLogPen.lopnStyle = PS_INSIDEFRAME;
   }
   else
   {
      /* if paint, erase, invert, or fill, then there is no perimeter */
      gdiEnv.newLogPen.lopnStyle = PS_NULL;
   }

   /* if NULL pen, then all the other fields don't change and don't matter */
   if (gdiEnv.newLogPen.lopnStyle != PS_NULL)
   {
      /* make sure that we are changing the pen size */
      if (GdiAttribHasChanged( GdiPnSize ))
      {
         /* check for non-square pen */
         if (port->pnSize.x == port->pnSize.y)
         {
            /* use x dimensions as the pen size if square pen */
            gdiEnv.newLogPen.lopnWidth.x = port->pnSize.x;
         }
         else
         {
            /* if non-square, do what the user requests */
            switch (gdiPrefsLPtr->nonSquarePenAction)
            {
               case GdiPrefOmit:          // omit line entirely
                  return FALSE;
                  break;

               case 1:                    // use width
                  gdiEnv.newLogPen.lopnWidth.x = port->pnSize.x;
                  break;

               case GdiPrefAbort:         // abort conversion completely
                  ErSetGlobalError( ErNonSquarePen );
                  return FALSE;
                  break;

               case 3:                    // use height
                  gdiEnv.newLogPen.lopnWidth.x = port->pnSize.y;
                  break;

               case 4:                    // use minimum dimension
                  gdiEnv.newLogPen.lopnWidth.x = min( port->pnSize.x, port->pnSize.y );
                  break;

               case 5:                    // use maximum dimension
                  gdiEnv.newLogPen.lopnWidth.x = max( port->pnSize.x, port->pnSize.y );
                  break;
            }
         }

         /* indicate that the pen size is current */
         GdiMarkAsCurrent( GdiPnSize );
      }

      /* get the correct pen color that we should draw with */
      if (!IsSolidPattern( &port->pnPixPat, &gdiEnv.newLogPen.lopnColor, MIXGREY ) )
      {
         /* check what to do with patterned pen */
         switch (gdiPrefsLPtr->penPatternAction)
         {
            case GdiPrefOmit:    // omit line entirely
               return FALSE;
               break;

            case 1:              // use foreground color
               gdiEnv.newLogPen.lopnColor = port->rgbFgColor;
               break;

            case GdiPrefAbort:   // abort conversion completely
               ErSetGlobalError( ErPatternedPen );
               return FALSE;
               break;
         }
      }

      /* make sure that we are changing the pen size */
      if (GdiAttribHasChanged( GdiPnMode ))
      {
         /* finally, check the transfer mode */
         if (IsArithmeticMode( port->pnMode ))
         {
            switch (gdiPrefsLPtr->penModeAction)
            {
               case GdiPrefOmit:    // omit line entirely
                  return FALSE;
                  break;

               case 1:              // use srcCopy
                  CaSetROP2( R2_COPYPEN );
                  break;

               case GdiPrefAbort:   // abort conversion completely
                  ErSetGlobalError( ErInvalidXferMode );
                  return FALSE;
                  break;
            }
         }

         /* indicate that the pen pattern is current */
         GdiMarkAsCurrent( GdiPnMode );
      }
   }

   /* notify cache that it should attempt to merge fill and frame */
   CaMergePen( verb );

   /* call cache module to create new pen */
   CaCreatePenIndirect( &gdiEnv.newLogPen );

   /* check if we are framing a previously filled object */
   if (gdiEnv.sameObject && verb == GdiFrame)
   {
      /* if so, flush the cache and indicate that nothing more to do */
      CaFlushCache();
      return FALSE;
   }
   else
   {
      /* return all systems go */
      return TRUE;
   }


}  /* SetPenAttributes */





private Boolean SetBrushAttributes( GrafVerb verb )
/*--------------------------------*/
/* set up the correct brush (fill) for the ensuing primitive */
{
   CGrafPortLPtr  port;
   PixPatLPtr     pixPatLPtr = {0};

   /* get the Quickdraw port to access brush patterns */
   QDGetPort( &port );

   /* Determine the brush pattern that should be used */
   switch (verb)
   {
      /* fill with HOLLOW brush */
      case GdiFrame:
         gdiEnv.newLogBrush.lbStyle = BS_HOLLOW;
         break;

      /* fill using current pen pattern */
      case GdiPaint:
         pixPatLPtr = &port->pnPixPat;
         gdiEnv.newLogBrush.lbStyle = BS_DIBPATTERN;
         break;

      /* fill using current fill pattern */
      case GdiFill:
         if (gdiEnv.hatchIndex == -1)
         {
            pixPatLPtr = &port->fillPixPat;
            gdiEnv.newLogBrush.lbStyle = BS_DIBPATTERN;
         }
         else
         {
            /* override pattern with a hatch pattern index */
            gdiEnv.newLogBrush.lbStyle = BS_HATCHED;
            gdiEnv.newLogBrush.lbColor = port->rgbFgColor;
            gdiEnv.newLogBrush.lbHatch = gdiEnv.hatchIndex;

            /* set the background color and make the hatch opaque */
            CaSetBkColor( port->rgbBkColor );
            CaSetBkMode( OPAQUE );
         }
         break;

      /* erase to current background pattern */
      case GdiErase:
         pixPatLPtr = &port->bkPixPat;
         gdiEnv.newLogBrush.lbStyle = BS_DIBPATTERN;
         break;

      /* invert all bits using black brush */
      case GdiInvert:
         gdiEnv.newLogBrush.lbStyle = BS_SOLID;
         gdiEnv.newLogBrush.lbColor = RGB( 0, 0, 0 );
         break;
   }

   /* if this is a DIB pattern, check to see if we are using a solid brush */
   if (gdiEnv.newLogBrush.lbStyle == BS_DIBPATTERN)
   {
      /* first check if this is a dithered pixmap pattern */
      if (pixPatLPtr->patType == QDDitherPat)
      {
         /* read the color from the secret reserved field */
         gdiEnv.newLogBrush.lbColor = pixPatLPtr->patMap.pmReserved;
         gdiEnv.newLogBrush.lbStyle = BS_SOLID;

      }
      else
      {
         /* if this is a solid pattern, assign new solid pattern color. */
         if (IsSolidPattern( pixPatLPtr, &gdiEnv.newLogBrush.lbColor, NOMIX ))
         {
            /* if this is a solid brush, change the logBrush desired attribs */
            gdiEnv.newLogBrush.lbStyle = BS_SOLID;

            /* make sure that the pen color is correct for Erase grafVerb */
            if (verb == GdiErase)
            {
               /* check the new color setting */
               if (gdiEnv.newLogBrush.lbColor == port->rgbFgColor)
               {
                  gdiEnv.newLogBrush.lbColor = port->rgbBkColor;
               }
               else
               {
                  gdiEnv.newLogBrush.lbColor = port->rgbFgColor;
               }
            }
         }
         else
         {
            /* save the type of pattern DIB that is being created */
            gdiEnv.lastPatType = pixPatLPtr->patType;

            /* set the color field to indicate that we are using RGB palette */
            gdiEnv.newLogBrush.lbColor = DIB_RGB_COLORS;

            /* create DIB pattern based upon pattern type */
            switch (pixPatLPtr->patType)
            {
               /* create a simple 2-color pattern DIB brush */
               case QDOldPat:
               {
                  MakePatternBrush( pixPatLPtr );
                  break;
               }

               /* create full-scale pattern DIB brush */
               case QDNewPat:
               {
                  MakeDIB( &pixPatLPtr->patMap, pixPatLPtr->patData,
                           (Handle far *)&gdiEnv.newLogBrush.lbHatch,
                           (Handle far *)NULL,
                           TRUE );
                  break;
               }
            }
         }
      }
   }

   /* call cache module to create brush and select it into metafile */
   CaCreateBrushIndirect( &gdiEnv.newLogBrush );

   /* all OK */
   return TRUE;

}  /* SetBrushAttributes */


private void MakePatternBrush( PixPatLPtr pixPatLPtr )
/*---------------------------*/
/* Make a new pattern brush using pixelPat passed in */
{
   CGrafPort far *   port;
   PatBrush far *    patLPtr;
   Byte              i;
   DWORD far *       gdiPattern;
   Byte far *        qdPattern;
   Byte far *        savePattern;

   /* allocate the new structure */
   gdiEnv.newLogBrush.lbHatch = (ULONG_PTR) GlobalAlloc( GHND, sizeof( PatBrush ) );

   /* make sure that the memory could be allocated */
   if (gdiEnv.newLogBrush.lbHatch == (ULONG_PTR) NULL)
   {
      ErSetGlobalError( ErMemoryFull );
      return;
   }

   /* Get QuickDraw port address to access fore and background colors */
   QDGetPort( &port );

   /* set the corresponding text and background colors for metafile */
   CaSetBkColor( port->rgbBkColor );
   CaSetTextColor( port->rgbFgColor );

   /* lock down the data to access the individual elements */
   patLPtr = (PatBrushLPtr)GlobalLock( (HANDLE) gdiEnv.newLogBrush.lbHatch );

   /* copy over skelton brush structure */
   *patLPtr = patBrushSkel;

   /* save the fore- and background colors for later compares */
   gdiEnv.lastFgColor = port->rgbFgColor;
   gdiEnv.lastBkColor = port->rgbBkColor;

   /* convert the current background color to RGBQUAD structure */
   patLPtr->bmiColors[0].rgbRed = GetRValue( port->rgbFgColor );
   patLPtr->bmiColors[0].rgbBlue = GetBValue( port->rgbFgColor );
   patLPtr->bmiColors[0].rgbGreen = GetGValue( port->rgbFgColor );
   patLPtr->bmiColors[0].rgbReserved = 0;

   /* convert the current foreground color to RGBQUAD structure */
   patLPtr->bmiColors[1].rgbRed = GetRValue( port->rgbBkColor );
   patLPtr->bmiColors[1].rgbBlue = GetBValue( port->rgbBkColor );
   patLPtr->bmiColors[1].rgbGreen = GetGValue( port->rgbBkColor );
   patLPtr->bmiColors[1].rgbReserved = 0;

   /* set up pointers to patterns in preparation for copy */
   savePattern = (Byte far *)&gdiEnv.lastPattern[7];
   qdPattern   = (Byte far *)&pixPatLPtr->pat1Data[7];
   gdiPattern  = (DWORD far *)&patLPtr->pattern[0];

   /* Copy the bitmap bits into the individual scanlines.  Note that
      we need to XOR the bits, since they are opposite to Windows GDI */
   for (i = 0; i < sizeof( Pattern ); i++)
   {
      /* save off the pattern into the GDI environment for later compares */
      *savePattern-- = *qdPattern;

      /* note that scanlines are padded to a DWORD boundary */
      *gdiPattern++ = (DWord)(*qdPattern-- ^ 0xFF);
   }

   /* Unlock the data for call to CreateBrushIndirect() */
   GlobalUnlock( (HANDLE) gdiEnv.newLogBrush.lbHatch );

}  /* MakePatternBrush */




private Boolean IsSolidPattern( PixPatLPtr pixPatLPtr,
                                RGBColor far * rgbColor,
                                Boolean mixColors )
/*----------------------------*/
/* return true if pattern is solid, false if not.  If mixColors is TRUE, then
   mixtures of 25%, 50%, and 75% grey are mixed into a solid color */
{
   Boolean           solidPattern;
   DWord             repeatPattern;
   DWord far *       penBitsLPtr;
   CGrafPort far *   port;

   /* get access to foreground and background colors */
   QDGetPort( &port );

   /* assume that the pattern isn't solid for now */
   solidPattern = FALSE;

   /* check whether to use old monochrome bitmap or new pixmap patterns */
   if (pixPatLPtr->patType == QDOldPat)
   {
      /* check for patterned brush in 8x8 monochrome bitmap */
      penBitsLPtr = (DWord far *)&pixPatLPtr->pat1Data;

      /* save off the first DWord, and compare for matching scanlines */
      repeatPattern = *penBitsLPtr;

      /* check if either solid white (all 0's) or solid black (all 1's) */
      if ((repeatPattern != 0x00000000) && (repeatPattern != 0xFFFFFFFF))
      {
         ;  /* not solid black or white - just skip ensuing checks */
      }
      /* next, check if first block same as second block of bits */
      else if (repeatPattern != penBitsLPtr[1])
      {
         ;  /* first DWord doesn't match second - skip remaining checks */
      }
      /* so far, either a black or white pattern - check for black, first */
      else if (repeatPattern == 0xFFFFFFFF)
      {
         /* solid black - use the port's foreground color */
         *rgbColor = port->rgbFgColor;
         solidPattern = TRUE;
      }
      /* finally, this must be a solid white pattern */
      else /* if (repeatPattern == 0x00000000) */
      {
         /* solid white - use the background color in the QuickDraw port */
         *rgbColor = port->rgbBkColor;
         solidPattern = TRUE;
      }

      /* if this isn't a solid pattern, but we want to mix colors */
      if (!solidPattern && mixColors)
      {
         Byte        i;
         Byte        blackBits;
         Byte        whiteBits;

         /* set solid to TRUE, since we will be using a blend of the colors */
         solidPattern = TRUE;

         /* count the number of 1 bits in the pattern */
         for (i = 0, blackBits = 0; i < sizeof( DWord ) * 8; i++)
         {
            /* bitwise AND for the addition, then shift one bit to right */
            blackBits = blackBits + (Byte)(repeatPattern & 1);
            repeatPattern /= 2;
         }

         /* perform the same calculation using the second DWord */
         for (i = 0, repeatPattern = penBitsLPtr[1]; i < sizeof( DWord ) * 8; i++)
         {
            /* bitwise AND for the addition, then shift one bit to right */
            blackBits = blackBits + (Byte)(repeatPattern & 1);
            repeatPattern /= 2;
         }

         /* calculate white bit count, since black + white bits == 64 */
         whiteBits = (Byte)64 - blackBits;

         /* using the 1 bit count, calculate weighted average of fore- and
            background colors in the QuickDraw port */
         *rgbColor = RGB( (Byte)((blackBits * RValue( port->rgbFgColor ) + whiteBits * RValue( port->rgbBkColor )) / 64),
                          (Byte)((blackBits * GValue( port->rgbFgColor ) + whiteBits * GValue( port->rgbBkColor )) / 64),
                          (Byte)((blackBits * BValue( port->rgbFgColor ) + whiteBits * BValue( port->rgbBkColor )) / 64) );
      }
   }

   /* return results of compare */
   return solidPattern;

}  /* IsSolidPattern */



private Boolean FrameMatchesFill( Word primType )
/*------------------------------*/
/* return TRUE if the fill pattern (current brush ) matches frame pattern */
{
   CGrafPortLPtr     port;

   /* get the Quickdraw port to access brush patterns */
   QDGetPort( &port );

   /* make sure this is the parameters and same primitive type */
   if (!gdiEnv.sameObject || (CaGetCachedPrimitive() != primType))
   {
      return FALSE;
   }
   /* check whether we are using an old (8 byte) pattern brush */
   else if (port->pnPixPat.patType != QDOldPat || gdiEnv.lastPatType != QDOldPat)
   {
      return FALSE;
   }
   /* we are only interested in comparing DIB pattern brushes */
   else if (gdiEnv.newLogBrush.lbStyle != BS_DIBPATTERN)
   {
      return FALSE;
   }
   /* compare the fore- and background colors first */
   else if ((port->rgbFgColor != gdiEnv.lastFgColor) ||
            (port->rgbBkColor != gdiEnv.lastBkColor) )
   {
      return FALSE;
   }
   else
   {
      Byte     i;

      /* Compare each of the pattern bits to determine if same. */
      for (i = 0; i < sizeof( Pattern ); i++)
      {
         /* if patterns don't match, return FALSE and exit loop */
         if (port->pnPixPat.pat1Data[i] != gdiEnv.lastPattern[i])
         {
            return FALSE;
         }
      }
   }

   /* all the compares indicate that the fill matches the frame */
   return TRUE;

}  /* FrameMatchesFill */



private Boolean SetTextAttributes( void )
/*-------------------------------*/
/* set up text attributes - set mapChars to TRUE if should map to ANSI */
{
   CGrafPortLPtr     port;

   /* Get the QuickDraw port in order to check font settings */
   QDGetPort( &port );

   /* set the text alignment to be baseline */
   CaSetTextAlign( TA_LEFT | TA_BASELINE | TA_NOUPDATECP );

   /* set the correct foreground and background colors */
   switch (port->txMode)
   {
      case QDSrcCopy:
         CaSetTextColor( port->rgbFgColor );
         CaSetBkColor( port->rgbBkColor );
         break;

      case QDSrcBic:
         CaSetTextColor( port->rgbBkColor );
         break;

      case QDSrcXor:
         CaSetTextColor( RGB( 0, 0, 0 ) );
         break;

      case QDSrcOr:
      default:
         CaSetTextColor( port->rgbFgColor );
         break;
   }

   /* set the background cell transparency mode */
   CaSetBkMode( (port->txMode == QDSrcCopy) ? OPAQUE : TRANSPARENT );

   /* check the character extra field */
   if (GdiAttribHasChanged( GdiChExtra ))
   {
      /* call the cache to set charextra in metafile */
      CaSetTextCharacterExtra( port->chExtra );

      /* update the status */
      GdiMarkAsCurrent( GdiChExtra );
   }

   /* convert the QuickDraw clockwise rotation to GDI counter-clockwise */
   gdiEnv.newLogFont.lfEscapement = (port->txRotation == 0) ?
                                     0 :
                                     10 * (360 - port->txRotation);

   /* make sure text flipping is taken into consiseration */
   gdiEnv.newLogFont.lfOrientation = (port->txFlip == QDFlipNone) ?
                                     gdiEnv.newLogFont.lfEscapement :
                                     ((gdiEnv.newLogFont.lfEscapement > 1800) ?
                                       gdiEnv.newLogFont.lfEscapement - 1800 :
                                       1800 - gdiEnv.newLogFont.lfEscapement);

   /* make sure that we are changing the text font name */
   if (GdiAttribHasChanged( GdiTxFont ))
   {
      Integer  newFont;

      /* call the routine to find a matching GDI font face name */
      newFont = FindGdiFont();

      /* fill in information from the font lookup table */
      gdiEnv.newLogFont.lfPitchAndFamily = fontTable[newFont].family | (Byte)DEFAULT_PITCH;

      /* copy the correct font character set */
      gdiEnv.newLogFont.lfCharSet = fontTable[newFont].charset;

      /* copy over the new font face name */
      lstrcpy( gdiEnv.newLogFont.lfFaceName, fontTable[newFont].gdiName );

      /* indicate that the pen size is current */
      GdiMarkAsCurrent( GdiTxFont );
   }

   /* make sure that we are changing the text attributes */
   if (GdiAttribHasChanged( GdiTxFace ))
   {
      /* note that attributes QDTxShadow, QDTxCondense, and QDTxExtend
         are not handled by GDI and will be removed permanently - SBT.
         Set italic, underline and bold attributes as needed */
      gdiEnv.newLogFont.lfItalic    = (Byte)(port->txFace & QDTxItalic);
      gdiEnv.newLogFont.lfUnderline = (Byte)(port->txFace & QDTxUnderline);
      gdiEnv.newLogFont.lfWeight    = (port->txFace & QDTxBold ) ?
                                       FW_BOLD : FW_NORMAL;

      /* indicate that the font attributes are current */
      GdiMarkAsCurrent( GdiTxFace );
   }

   /* check the new font size */
   if (GdiAttribHasChanged( GdiTxSize) || GdiAttribHasChanged( GdiTxRatio))
   {
      /* check for any text rescaling factor in vertical direction */
      if (port->txNumerator.y == port->txDenominator.y)
      {
         /* note that we negate the font size in order to specify the
            character height = cell height - internal leading */
         gdiEnv.newLogFont.lfHeight = -port->txSize;
      }
      else
      {
         Integer  txHeight;

         /* scale the font size by numerator/denominator - use LongInts to
            avoid possibility of overflowing Integer multiplication */
         txHeight = (Integer)(((LongInt)port->txSize *
                               (LongInt)port->txNumerator.y +
                               (LongInt)(port->txDenominator.y / 2)) /
                               (LongInt)port->txDenominator.y);

         gdiEnv.newLogFont.lfHeight = -txHeight;
      }

      /* indicate that the font size and scaling is current */
      GdiMarkAsCurrent( GdiTxSize );
      GdiMarkAsCurrent( GdiTxRatio );
   }

   /* call cache module to create the font and select it */
   CaCreateFontIndirect( &gdiEnv.newLogFont );

   /* everything a-ok */
   return TRUE;

}  /* SetTextAttributes */



private Integer FindGdiFont( void )
/*-------------------------*/
/* return an index to the current font selection */
{
   CGrafPortLPtr     port;
   Boolean           findName;
   Byte              i;

   /* check if the search is overridden by a font name comment */
   if (gdiEnv.useGdiFont)
   {
      /* return the table index that the name was copied into */
      return FntFromGdi;
   }

   /* Get the QuickDraw port in order to check font settings */
   QDGetPort( &port );

   /* see if lookup should be done on face name */
   findName = (port->txFontName[0] != cNULL);

   /* search through all font table entries to find a match */
   for (i = 0; i < FntNoMatch; i++)
   {
      /* if looking up the font name, compare the macName field */
      if (findName)
      {
         /* look for an exact string compare - equivalent strings */
         if (lstrcmpi( fontTable[i].macName, port->txFontName ) == 0)
         {
            break;
         }
      }
      else
      {
         /* otherwise, compare the font numbers */
         if (fontTable[i].fontNum == port->txFont)
         {
            break;
         }
      }
   }

   /* see if there was no match found in the table */
   if (i == FntNoMatch)
   {
      /* see if if we are comparing font names, and no match was found */
      if (findName)
      {
         /* copy the Mac name over into the font table */
         lstrcpy( fontTable[FntNoMatch].gdiName, port->txFontName );

         /* assign default values for the charSet and family if not found */
         fontTable[FntNoMatch].family  = FF_ROMAN;
         fontTable[FntNoMatch].charset = ANSI_CHARSET;

         /* call Windows to enumerate any fonts that have the facename */
#ifdef WIN32
         EnumFonts( gdiEnv.infoContext, port->txFontName, gdiEnv.fontFunction, ( LPARAM ) NULL );
#else
         EnumFonts( gdiEnv.infoContext, port->txFontName, gdiEnv.fontFunction, NULL );
#endif
         /* return the font index of the new entry */
         return FntNoMatch;
      }
      else
      {
         /* otherwise, use the default Helvetica font */
         return FntDefault;
      }
   }
   else
   {
      /* a match was found - return the table index */
      return i;
   }

}  /* FindGdiFont */



private void MacToAnsi( StringLPtr string )
/*--------------------*/
/* convert extended characters from Mac to ANSI equivalent */
{
   /* determine if there should be character translations on the chars */
   if (gdiEnv.newLogFont.lfCharSet == ANSI_CHARSET)
   {
      /* continue until we hit the NULL end of string marker */
      while (*string)
      {
         /* if translating an extended character */
         if ((Byte)*string >= (Byte)128)
         {
            /* perform character table lookup */
            *string = MacToAnsiTable[(Byte)*string - (Byte)128];
         }

         /* if we encounter a non-printable character, convert to space */
         if ((Byte)*string < (Byte)0x20)
         {
            *string = ' ';
         }

         /* increment the string pointer */
         string++;
      }
   }
}

#if( REMAPCOLORS )

private void RemapColors( PixMapLPtr pixMapLPtr, Handle pixDataHandle )
/*------------------*/
/* Remap colors for black and white in 16- or 256-color DIB */
{
   Byte              remapTable[256];
   Integer           blackIndex = 0;
   Integer           whiteIndex = 0;
   Integer           index;

   ColorTableLPtr    colorTabLPtr;
   Integer           numColors;
   RGBColor far *    curColorLPtr;

   /* lock the color table before copying over the color table */
   colorTabLPtr = (ColorTableLPtr)GlobalLock( pixMapLPtr->pmTable );

   /* set up the color entry pointers */
   curColorLPtr = colorTabLPtr->ctColors;

   /* determine number of colors in DIB */
   numColors = colorTabLPtr->ctSize;

   /* copy over all the color entries */
   for (index = 0; index < numColors; index++ )
   {
      /* copy color to local variable */
      RGBColor color = *curColorLPtr;

      /* is this the black entry? */
      if( color == RGB( 0, 0, 0 ) )
         blackIndex = index;
      if( color == RGB( 255, 255, 255 ) )
         whiteIndex = index;

      /* just copy over the current assignment to the remap table */
      remapTable[index] = (Byte)index;

      /* increment the pointers */
      curColorLPtr++;
   }

   if( blackIndex != 0 || whiteIndex != numColors - 1 )
   {
      if( whiteIndex == 0 )
      {
         // Direct swap of black and white colors.
         remapTable[0] = (Byte)blackIndex;
         remapTable[blackIndex] = (Byte)whiteIndex;

         // Remap the colors in the palette, also
         colorTabLPtr->ctColors[0] = colorTabLPtr->ctColors[blackIndex];
         colorTabLPtr->ctColors[blackIndex] = colorTabLPtr->ctColors[whiteIndex];
      }
      else
      {
         Boolean  doBlack;

         for (index = 1, doBlack = TRUE; index < numColors; index++)
         {
            if( whiteIndex != index && blackIndex != index )
            {
               if( doBlack )
               {
                  remapTable[index]      = (Byte)blackIndex;
                  remapTable[blackIndex] = (Byte)index;
                  doBlack = FALSE;
               }
               else
               {
                  remapTable[index]      = (Byte)whiteIndex;
                  remapTable[whiteIndex] = (Byte)index;
                  break;
               }
            }
         }
      }
   }

   /* unlock color table and free associated memory */
   GlobalUnlock( pixMapLPtr->pmTable );
}

#endif

private void MakeDIB( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                      Handle far * headerHandleLPtr,
                      Handle far * bitsHandleLPtr,
                      Boolean packDIB )
/*------------------*/
/* Create a Windows device-independant bitmap */
{
   Integer           pixelSize;
   LongInt           bitsInfoSize;
   Boolean           expandBits;
   Boolean           mergeRGB;
   Boolean           rleCompress;
   DWord             dibCompression;
   Integer           totalColors;
   DWord             dibWidth;
   DWord             dibHeight;
   DWord             totalBytes;
   Integer           rowBytes;
   Integer           bytesPerLine;
   DWord             rleByteCount = 0;

   /* determine the bitcount which will yield the size of the color table */
   pixelSize = pixMapLPtr->pixelSize;

#if( REMAPCOLORS )
   /* if this is an 16 or 256 color DIB, we need to remap color indicies */
   if( pixelSize == 4 || pixelSize == 8 )
   {
      RemapColors( pixMapLPtr, pixDataHandle );
   }
#endif

   /* determine if RLE compression should be used in resulting DIB */
   /* Use RLE for 4- & 8-bits/pixel, but not if calling app said no RLE */
   if ((pixelSize == 4 || pixelSize == 8) && gdiPrefsLPtr->noRLE == 0)
   {
      /* use compression and set the correct bmiHeader compression */
      rleCompress = TRUE;
      dibCompression = (pixelSize == 4) ? BI_RLE4 : BI_RLE8;
   }
   else
   {
      /* no compression - the bytes are rgb palette indicies */
      rleCompress = FALSE;
      dibCompression = BI_RGB;
   }

   /* assume that no expansion will be required */
   expandBits = FALSE;

   /* round to 16-entry color table if this is a 4-entry pixel map  or
      to a 24-bit image if this is a 16-bit image */
   if (pixelSize == 2 || pixelSize == 16)
   {
      expandBits = TRUE;
      pixelSize = (pixelSize == 2) ? 4 : 24;
   }
   else if (pixelSize == 32)
   {
      /* change pixel size to 24 bits if this is a 32-bit pixMap */
      pixelSize = 24;
   }

   /* if not creating a 24-bit DIB ... */
   if (pixelSize <= 8)
   {
      /* calculate total number of colors used in resulting Windows DIB */
      totalColors = 1 << pixelSize;
   }
   else
   {
      /* otherwise, we don't allocate for color table */
      totalColors = 0;
   }

   /* calculate width and height - these are used frequently */
   dibWidth  = Width( pixMapLPtr->bounds );
   dibHeight = Height( pixMapLPtr->bounds );

   /* determine if the RGB components need to be merged in 24-bit image */
   mergeRGB = (pixMapLPtr->packType == 4);

   /* calculate the amount of memory required for header structure */
   bitsInfoSize = sizeof( BITMAPINFOHEADER ) + totalColors * sizeof( RGBQUAD );

   /* calculate the number of bytes per line - round to DWORD boundary */
   bytesPerLine = (Word)((dibWidth * (LongInt)pixelSize + 31) / 32) * 4;

   /* save off rowBytes size for later calculations */
   rowBytes = pixMapLPtr->rowBytes & RowBytesMask;

   /* calculate total amount of memory needed for bits */
   totalBytes = dibHeight * bytesPerLine;

   /* perform a pre-flight of compression to see if larger */
   if (rleCompress)
   {
      DWord       tempDibHeight = dibHeight;
      Byte huge * srcLineHPtr;

      /* lock source pixel bits, set pointer to last line in source bitmap */
      srcLineHPtr = (Byte huge *)GlobalLock( pixDataHandle );
      srcLineHPtr = srcLineHPtr + ((LongInt)rowBytes * ((LongInt)dibHeight - 1));

      /* initialize rle byte count */
      rleByteCount = 0;

      /* continue looping while bytes remain */
      while (tempDibHeight--)
      {
         /* if this is a 16 or 256 color DIB, then use RLE compression.
            The rleByteCount is incremented inside the routine */
         if (dibCompression == BI_RLE4)
         {
            hrlecpy16( srcLineHPtr, NULL, (Integer)dibWidth,
                       &rleByteCount, FALSE );
         }
         else
         {
            hrlecpy256( srcLineHPtr, NULL, (Integer)dibWidth,
                        &rleByteCount, FALSE );
         }

         /* move the source pointer */
         srcLineHPtr -= rowBytes;
      }

      /* add in the end of bitmap record - increment total bytes */
      rleByteCount += 2;

      /* unlock the source pixel map */
      GlobalUnlock( pixDataHandle );

      /* check if the compression results in smaller DIB */
      if (rleByteCount < totalBytes)
      {
         /* if smaller, adjust the total size to allocate */
         totalBytes = rleByteCount;

         /* re-initialize the byte count */
         rleByteCount = 0;
      }
      else
      {
         /* larger - adjust compression technique */
         rleCompress = FALSE;
         dibCompression = BI_RGB;
      }
   }

   /* if we are creating a packed DIB, then allocate only one data block */
   if (packDIB)
   {
      *headerHandleLPtr = GlobalAlloc( GHND, (bitsInfoSize + totalBytes) );
   }
   else
   {
      /* allocate separate handles for header and bits */
      *headerHandleLPtr = GlobalAlloc( GHND, bitsInfoSize );
      *bitsHandleLPtr   = GlobalAlloc( GHND, totalBytes );
   }

   /* check the results of the allocation for out-of-memory conditions */
   if (*headerHandleLPtr == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else if (!packDIB)
   {
      if (*bitsHandleLPtr == NULL)
      {
         ErSetGlobalError( ErMemoryFull );
      }
   }

   if (ErGetGlobalError() == NOERR)
   {
      BITMAPINFO far *  bitsInfoLPtr;
      Byte huge *       srcLineHPtr;
      Byte huge *       dstLineHPtr;

      /* lock the info header */
      bitsInfoLPtr = (BITMAPINFO far *)GlobalLock( *headerHandleLPtr );

      /* copy over all the header fields from the QuickDraw pixmap */
      bitsInfoLPtr->bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
      bitsInfoLPtr->bmiHeader.biWidth = dibWidth;
      bitsInfoLPtr->bmiHeader.biHeight = dibHeight;
      bitsInfoLPtr->bmiHeader.biPlanes = 1;
      bitsInfoLPtr->bmiHeader.biBitCount = (WORD) pixelSize;
      bitsInfoLPtr->bmiHeader.biCompression = dibCompression;
      bitsInfoLPtr->bmiHeader.biSizeImage = (rleCompress ? totalBytes : 0);
      bitsInfoLPtr->bmiHeader.biXPelsPerMeter = (DWord)(72 * 39.37);
      bitsInfoLPtr->bmiHeader.biYPelsPerMeter = (DWord)(72 * 39.37);
      bitsInfoLPtr->bmiHeader.biClrUsed = 0;
      bitsInfoLPtr->bmiHeader.biClrImportant = 0;

      /* make sure that there are colors to copy over */
      if (totalColors)
      {
         ColorTableLPtr    colorTabLPtr;
         Integer           numColors;
         RGBQUAD far *     curQuadLPtr;
         RGBColor far *    curColorLPtr;

         /* lock the color table before copying over the color table */
         colorTabLPtr = (ColorTableLPtr)GlobalLock( pixMapLPtr->pmTable );


         /* set up the color entry pointers */
         curColorLPtr = colorTabLPtr->ctColors;
         curQuadLPtr  = bitsInfoLPtr->bmiColors;

         /* copy over all the color entries */
         for (numColors = colorTabLPtr->ctSize; numColors; numColors-- )
         {
            RGBColor    color;

            /* copy color to local variable */
            color = *curColorLPtr;

            /* convert the color from COLORREF to RGBQUAD structure */
            curQuadLPtr->rgbRed   = GetRValue( color );
            curQuadLPtr->rgbGreen = GetGValue( color );
            curQuadLPtr->rgbBlue  = GetBValue( color );
            curQuadLPtr->rgbReserved = 0;

            /* increment the pointers */
            curQuadLPtr++;
            curColorLPtr++;
         }

         /* fill in any empty color entries */
         for (numColors = totalColors - colorTabLPtr->ctSize; numColors; numColors--)
         {
            /* put in a black color entry (unused) */
            curQuadLPtr->rgbRed   =
            curQuadLPtr->rgbGreen =
            curQuadLPtr->rgbBlue  =
            curQuadLPtr->rgbReserved = 0;

            /* increment the pointers */
            curQuadLPtr++;
         }

         /* unlock color table and free associated memory */
         GlobalUnlock( pixMapLPtr->pmTable );

         /* free the color table only if this isn't a pixel pattern */
         if (!packDIB)
         {
            GlobalFree( pixMapLPtr->pmTable );
         }
      }

      /* adjust for 24-bit images that have dropped high-order byte.  Make
         sure not to adjust for 16-bit images that will expand to 24-bit */
      if (pixelSize == 24 && !expandBits)
      {
         rowBytes = rowBytes * 3 / 4;
      }

      /* determine where the data should be placed for the bitmap */
      if (packDIB)
      {
         /* set the destination pointer to the end of the color table */
         dstLineHPtr = (Byte huge *)((Byte far *)bitsInfoLPtr) + bitsInfoSize;
      }
      else
      {
         /* lock the data block handle if creating a normal DIB */
         dstLineHPtr = (Byte huge *)GlobalLock( *bitsHandleLPtr );
      }

      /* lock source pixel bits, set pointer to last line in source bitmap */
      srcLineHPtr = (Byte huge *)GlobalLock( pixDataHandle );
      srcLineHPtr = srcLineHPtr + ((LongInt)rowBytes * ((LongInt)dibHeight - 1));

      /* continue looping while bytes remain */
      while (dibHeight--)
      {
         if (expandBits)
         {
            /* if expanding, expand each 2 bits to full nibble or if this
               is a 16-bit image, expand to 24 bits */
            hexpcpy( srcLineHPtr, dstLineHPtr, rowBytes, pixelSize );
         }
         else if (mergeRGB)
         {
            /* if the is a 24-bit image, then the components are separated
               into scanlines of red, green and blue.  Merge these into
               a single RGB component for the entire line */
            hmrgcpy( srcLineHPtr, dstLineHPtr, rowBytes / 3 );
         }
         else if (rleCompress)
         {
            /* if this is a 16 or 256 color DIB, then use RLE compression.
               The rleByteCount is incremented inside the routine */
            if (dibCompression == BI_RLE4)
            {
                hrlecpy16( srcLineHPtr, dstLineHPtr + rleByteCount,
                           (Integer)dibWidth, &rleByteCount, TRUE );
            }
            else
            {
                hrlecpy256( srcLineHPtr, dstLineHPtr + rleByteCount,
                            (Integer)dibWidth, &rleByteCount, TRUE );
            }
         }
         else
         {
            /* if no expansion required, then this is a simple copy */
            hmemcpy( srcLineHPtr, dstLineHPtr, rowBytes );
         }

         /* move the source pointer and destination if not compressed */
         srcLineHPtr -= rowBytes;
         if (!rleCompress)
         {
            dstLineHPtr += bytesPerLine;
         }
      }

      /* if RLE compression was used, modify size field in the bmiHeader */
      if (rleCompress)
      {
         /* add in the end of bitmap record - increment total bytes */
         dstLineHPtr[rleByteCount++] = 0;
         dstLineHPtr[rleByteCount++] = 1;
      }

      /* unlock the source pixel map */
      GlobalUnlock( pixDataHandle );

      /* unlock the destination header info handle */
      GlobalUnlock( *headerHandleLPtr );

      /* if this isn't packed, unlock the data pointer, also */
      if (!packDIB)
      {
         GlobalUnlock( *bitsHandleLPtr );
      }
   }

}  /* MakeDIB */



private Boolean MakeMask( Handle mask, Boolean patBlt)
/*----------------------*/
/* Create a mask that will be used in the ensuing StretchDIBits call.
   Return TRUE if region was created, FALSE if rectangular region */
{
   PixMap            pixMap;
   Integer far *     sizeLPtr;
   LongInt           bytesNeeded;
   Boolean           solidPatBlt;
   Word              mode;

   /* determine if a solid pattern blt is being rendered - this can be
      altered to render a "simple" StretchBlt that DOESN'T involve a brush */
   solidPatBlt = patBlt && (gdiEnv.newLogBrush.lbStyle == BS_SOLID);

   if (patBlt)
      mode = (solidPatBlt) ? QDSrcOr : -2;
   else
      mode = (Word) -1;

   /* Lock the region handle and retrieve the bounding box */
   sizeLPtr = (Integer far *)GlobalLock( mask );

   /* determine if we are just requesting a rectangular bitmap mask */
   if (*sizeLPtr == RgnHeaderSize)
   {
      Rect  clipRect;

      /* determine the appropriate clipping rectangle */
      clipRect = *((Rect far *)(sizeLPtr + 1));

      /* Call Gdi module to change the clipping rectangle */
      gdiEnv.drawingEnabled = CaIntersectClipRect( clipRect );

      /* just unlock the mask and return to the calling routine */
      GlobalUnlock( mask );

      /* indicate that no region mask was created */
      return FALSE;
   }

   /* determine bounding rectangle and rowBytes (rounded to word bondary) */
   pixMap.bounds = *((Rect far *)(sizeLPtr + 1));

   pixMap.rowBytes = ((Width( pixMap.bounds ) + 15) / 16) * sizeofMacWord;

   /* if this is a bitmap, then we assign the various fields.  */
   pixMap.pmVersion = 0;
   pixMap.packType = 0;
   pixMap.packSize = 0;
   pixMap.hRes = 0x00480000;
   pixMap.vRes = 0x00480000;
   pixMap.pixelType = 0;
   pixMap.pixelSize = 1;
   pixMap.cmpCount = 1;
   pixMap.cmpSize = 1;
   pixMap.planeBytes = 0;
   pixMap.pmTable = 0;
   pixMap.pmReserved = 0;

   /* calculate the number of bytes needed for the color table */
   bytesNeeded = sizeof( ColorTable ) + sizeof( RGBColor );

   /* allocate the data block */
   pixMap.pmTable = GlobalAlloc( GHND, bytesNeeded );

   /* make sure that the allocation was successfull */
   if (pixMap.pmTable == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
      
      /* Unlock the mask region */
      GlobalUnlock( mask );
      return FALSE;
   }
   else
   {
      ColorTable far *  colorHeaderLPtr;
      Handle            maskBitmap;

      /* lock the memory handle and prepare to assign color table */
      colorHeaderLPtr = (ColorTable far *)GlobalLock( pixMap.pmTable );

      /* 2 colors are present - black and white */
      colorHeaderLPtr->ctSize = 2;
      if (solidPatBlt)
      {
         colorHeaderLPtr->ctColors[0] = gdiEnv.newLogBrush.lbColor;
         colorHeaderLPtr->ctColors[1] = RGB( 255, 255, 255 );
      }
      else
      {
         colorHeaderLPtr->ctColors[0] = RGB( 255, 255, 255 );
         colorHeaderLPtr->ctColors[1] = RGB( 0, 0, 0 );
      }

      /* unlock the memory */
      GlobalUnlock( pixMap.pmTable );

      /* Create the correct bitmap from the mask region */
      bytesNeeded  = (LongInt)pixMap.rowBytes * (LongInt)(Height( pixMap.bounds ));

      /* allocate the memory */
      maskBitmap = GlobalAlloc( GHND, bytesNeeded );

      /* make sure the allocation succeeded */
      if (maskBitmap == NULL)
      {
         ErSetGlobalError( ErMemoryFull );
      }
      else
      {
         Integer far *     maskLPtr;
         Byte far *        rowLPtr;
         Integer           curRow;

         /* lock the memory for creation of the bitmap mask */
         rowLPtr = GlobalLock( maskBitmap );

         /* set the mask pointer to beginning of region information */
         maskLPtr = sizeLPtr + 5;

         /* loop until all rows have been traversed */
         for (curRow = pixMap.bounds.top;
              curRow < pixMap.bounds.bottom;
              curRow++, rowLPtr += pixMap.rowBytes)
         {
            /* if this is the first row being created ... */
            if (curRow == pixMap.bounds.top)
            {
               Integer     i;

               /* make all the bits the background color */
               for (i = 0; i < pixMap.rowBytes; i++)
                  *(rowLPtr + i) = (Byte)0xFF;
            }
            else
            {
               /* copy over the information from the previous row */
               hmemcpy( rowLPtr - pixMap.rowBytes, rowLPtr, pixMap.rowBytes );
            }

            /* determine if the desired mask line was reached */
            if (*maskLPtr == curRow)
            {
               Integer     start;
               Integer     end;

               /* increment the mask pointer to get to the start/end values */
               maskLPtr++;

               /* continue looping until end of line marker encountered */
               while (*maskLPtr != 0x7FFF)
               {
                  /* determine the start and end point of bits to invert */
                  start = *maskLPtr++;
                  end   = *maskLPtr++;

                  /* if reached, invert the desired bits in the mask */
                  InvertBits( rowLPtr, start - pixMap.bounds.left, end - start);
               }

               /* increment past the end of line flag */
               maskLPtr++;
            }
         }

         /* unlock the bitmap memory block */
         GlobalUnlock( maskBitmap );

         /* call the GdiStretchDIB() entry point to create the bitmap */
         GdiStretchDIBits( &pixMap, maskBitmap,
                           pixMap.bounds, pixMap.bounds,
                           mode, NULL );

      }

      /* Unlock the mask region */
      GlobalUnlock( mask );

      /* indicate that a mask was created */
      return TRUE;
   }

}  /* MakeMask */



void InvertBits( Byte far * byteLPtr, Integer start, Integer count )
/*-------------*/
/* invert all bits in byteLPtr from bit offset start for count bits */
{
   Byte        byteMask;
   Integer     partialCount;

   /* set the beginning byte index */
   byteLPtr += start / 8;

   /* determine the beginning mask offset = start % 8 */
   partialCount = start & 0x0007;

   /* set up the byte mask and decrement by number of bits processed */
   byteMask = (Byte)(0xFF >> partialCount);
   count -= 8 - partialCount;

   /* continue looping while bits remain ... */
   while (count >= 0)
   {
      /* invert all the mask bits */
      *byteLPtr++ ^= byteMask;

      /* set up the new byte mask - assume all bits will be set */
      byteMask = 0xFF;

      /* decrement the count */
      count -= 8;
   }

   /* if a bitmask stilll remains */
   if (count > -8 && count < 0)
   {
      /* the negative count indicates number of bits to be inverted */
      count = -count;

      /* shift right, then left to clear remaining bits */
      byteMask = (Byte)((byteMask >> count) << count);

      /* and XOR with current bits */
      *byteLPtr ^= byteMask;
   }

}  /* InvertBits */



void hmemcpy( Byte huge * src, Byte huge * dst, Integer count )
/*----------*/
/* copy count bytes from source to destination - assumes even count */
{
   short huge * wSrc = (short far *)src;
   short huge * wDst = (short far *)dst;
   Integer     wCount = count / sizeof ( short );

   /* while words remain, copy to destination from source */
   while (wCount--)
   {
      *wDst++ = *wSrc++;
   }

}  /* hmemcpy */



void hexpcpy( Byte huge * src, Byte huge * dst, Integer count, Integer bits )
/*----------*/
/* copy count bytes to destination, expand each 2 bits to nibble of if
   16-bit image, expand to 24 bits */
{
   /* check if expanding from 2 to 4 bits */
   if (bits == 4)
   {
      Byte  tempByte;
      Byte  result;

      /* while bytes remain, copy to destination from source */
      while (count--)
      {
         /* expand high nibble to full byte */
         tempByte = *src;
         result  = (Byte)((tempByte >> 2) & (Byte)0x30);
         result |= (Byte)((tempByte >> 6));
         *dst++  = result;

         /* expand low nibble to full byte */
         tempByte = *src++;
         result  = (Byte)((tempByte & (Byte)0x0C) << 2);
         result |= (Byte)((tempByte & (Byte)0x03));
         *dst++  = result;
      }
   }
   else /* if (bits == 24) */
   {
      Word  tempWord;

      /* while words remain, copy to destination from source */
      while (count)
      {
         /* read the next two bytes into a full word, swapping bytes */
         tempWord  = (Word)(*src++ << 8);
         tempWord |= (Word)(*src++);

         /* 2 full bytes were read - decrement */
         count -= 2;

         /* expand each 5 bits to full byte */
         *dst++ = (Byte)((tempWord & 0x001F) << 3);
         *dst++ = (Byte)((tempWord & 0x03E0) >> 2);
         *dst++ = (Byte)((tempWord & 0x7C00) >> 7);
      }
   }

}  /* hexpcpy */



void hmrgcpy( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr, Integer dibWidth )
/*----------*/
/* if the is a 24-bit image, then the components are separated into scanlines
   of red, green and blue.  Merge into single scanline of 24-bit RGB pixels */
{
   Integer        component;
   Byte huge *    insert;
   Integer        offset;

   /* for each red, green, and blue component ... */
   for (component = 2; component >= 0; component--)
   {
      /* adjust the insertion point */
      insert = dstLineHPtr + component;

      /* for each component byte in the scanline ... */
      for (offset = 0; offset < dibWidth; offset++)
      {
         /* copy the component to the correct destination insertion point */
         *insert = *srcLineHPtr++;

         /* increment to the next insertion point */
         insert += 3;
      }
   }


}  /* hmrgcpy */


void hrlecpy256( Byte huge * srcHPtr, Byte huge * dstHPtr,
                 Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB )
/*----------*/
/* 256 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */
{
   DWord       rleCount;
   Integer     bytesLeft;
   Byte        compareByte;
   Byte        runLength;
   Byte huge * startRun;

   /* initialize rleCount */
   rleCount = 0;

   /* all bytes remain to be processed */
   bytesLeft = dibWidth;

   /* continue compressing until all bytes are processed */
   while (bytesLeft)
   {
      /* save off the start of the run length */
      startRun = srcHPtr;

      /* read the first byte from the scanline */
      compareByte = *srcHPtr++;
      bytesLeft--;

      /* initialize the runLength */
      runLength = 1;

      /* continue comparing bytes until no match results */
      while (bytesLeft && (compareByte == *srcHPtr) && (runLength < 0xFF))
      {
         /* if a match was made, increment runLength and source pointer */
         runLength++;
         srcHPtr++;
         bytesLeft--;
      }

      /* check if only two more bytes remain in scanline */
      if ((runLength == 1) && (bytesLeft == 1))
      {
         if (writeDIB)
         {
            /* in this case, we have reached then end of the line with 2
               non-repeating bytes - have to write out to runlengths of 1 */
            *dstHPtr++ = 1;
            *dstHPtr++ = compareByte;
            *dstHPtr++ = 1;
            *dstHPtr++ = *srcHPtr;
         }

         /* decrement the byte counter so that the main loop ends */
         bytesLeft--;

         /* byte count incremented by 4 bytes */
         rleCount += 4;
      }
      /* check if we have a run length of 3 or more - also check bytesLeft
         to make sure that we don't attempt to read past memory block */
      else if ((runLength == 1) && (bytesLeft > 2) &&
              (*srcHPtr != *(srcHPtr + 1)))
      {
         Boolean     oddCount;

         /* set the correct run length, and reset the source pointer */
         srcHPtr += 2;
         runLength = 3;
         bytesLeft -= 2;

         /* continue comparing until some bytes match up */
         while (bytesLeft && (runLength < 0xFF))
         {
            /* make sure we don't try to read past end of scanline &&
               compare to see if the bytes are the same */
            if ((bytesLeft == 1) || (*srcHPtr != *(srcHPtr + 1)))
            {
               /* we will run past the end of scanline, add the byte */
               /* if byte pair doesn't match, increment pointer and count */
               srcHPtr++;
               runLength++;
               bytesLeft--;
            }
            else
            {
               /* if not at scanline end, or bytes match, bail */
               break;
            }
         }

         /* determine if there is an odd number of bytes to move */
         oddCount = runLength & (Byte)0x01;

         /* increment to total RLE byte count */
         rleCount += 2 + runLength + (Byte)oddCount;

         if (writeDIB)
         {
            /* write out the number of unique bytes */
            *dstHPtr++ = 0;
            *dstHPtr++ = runLength;

            /* write out the individual bytes until runLength is exhausted */
            while (runLength--)
            {
               /* copy to the destination from the starting point */
               *dstHPtr++ = *startRun++;
            }

            /* add a null pad byte to align to word boundary */
            if (oddCount)
            {
               *dstHPtr++ = 0;
            }
         }
      }
      else
      {
         if (writeDIB)
         {
            /* successful run length found - write to destination */
            *dstHPtr++ = runLength;
            *dstHPtr++ = compareByte;
         }

         /* increment the byte count */
         rleCount += 2;
      }
   }

   if (writeDIB)
   {
      /* write out an end of line marker */
      *dstHPtr++ = 0;
      *dstHPtr   = 0;
   }

   /* increment total number of bytes */
   rleCount += 2;

   /* assign the value into the address provided */
   *rleByteCount += rleCount;

}  /* hrlecpy256 */




void hrlecpy16( Byte huge * srcHPtr, Byte huge * dstHPtr,
                Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB )
/*----------*/
/* 16 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */
{
   DWord       rleCount;
   Integer     pixelsLeft;
   Boolean     oddStart;
   Boolean     look4Same;
   Byte        compareByte;
   Byte        runLength;
   Byte huge * startRun;

   /* initialize rleCount */
   rleCount = 0;

   /* all pixels left to process */
   pixelsLeft = dibWidth;

   /* continue compressing until all pixels are processed */
   while (pixelsLeft)
   {
      /* save off the start of the run length */
      startRun = srcHPtr;
      oddStart = odd( pixelsLeft + dibWidth );

      /* assume that we are comparing for equality, right now */
      look4Same = TRUE;

      /* read the next set of 2 pixels from the scanline */
      if (oddStart)
      {
         /* odd offset: swap high and low pixels for byte-aligned compares */
         compareByte  = *srcHPtr++ & (Byte)0x0F;

         /* make sure we can access the next byte - count > 1 */
         if (pixelsLeft > 1)
         {
            compareByte |= *srcHPtr << 4;
         }
      }
      else
      {
         /* otherwise, just save off the next full byte */
         compareByte = *srcHPtr++;
      }

      /* check if we have 2 or less pixels remaining in the scanline */
      if (pixelsLeft <= 2)
      {
         /* if only one pixel left ... */
         if (pixelsLeft == 1)
         {
            /* zero out low-order nibble and set runLength */
            compareByte &= (Byte)0xF0;
            runLength = 1;
         }
         else
         {
            /* otherwize, just set the runLength */
            runLength = 2;
         }

         /* no more pixels left */
         pixelsLeft = 0;
      }
      /* otherwise, proceed with the normal comparison loop */
      else
      {
         /* we have runLength of 2 pixels, so far */
         runLength = 2;
         pixelsLeft -= 2;

         /* continue comparing bytes until no match results */
         do
         {
            /* if comparing for equality ... */
            if (look4Same)
            {
               Byte     match;

               /* XOR compare byte and the source pointer byte */
               match = compareByte ^ *srcHPtr;

               /* was there a full 2 pixel compare? */
               if (match == 0)
               {
                  /* is this the last pixel in the scanline, runlength
                     maximum reached, or nibbles swapped and begin of
                     pattern matching */
                  if ((pixelsLeft == 1) || (runLength + 1) == 0xFF ||
                      (oddStart && runLength == 2))
                  {
                     /* if this is the begin of pattern matching following an
                        odd start, then increment the source pointer */
                     if (oddStart && runLength == 2)
                     {
                        srcHPtr++;
                     }

                     /* only one pixel handled in this case */
                     runLength++;
                     pixelsLeft--;
                  }
                  else
                  {
                     /* otherwise, a full byte compared correctly - 2 nibbles */
                     runLength  += 2;
                     pixelsLeft -= 2;
                     srcHPtr++;
                  }
               }
               /* if no full byte compare, determine if patial match */
               else if ((runLength != 2) && ((match & (Byte)0xF0) == 0))
               {
                  /* only high-order nibble matched - increment counts */
                  runLength++;
                  pixelsLeft--;

                  /* exit the loop */
                  break;
               }
               else if (runLength == 2)
               {
                  /* no match on first compare - look for non-matches */
                  look4Same = FALSE;

                  /* increment source pointer - sets up byte alignment */
                  srcHPtr++;

                  /* setup for the runLength of differing pixels */
                  if (oddStart || (pixelsLeft == 1))
                  {
                     /* increment runLength and decrement pixels left */
                     runLength++;
                     pixelsLeft--;
                  }
                  else
                  {
                     /* there are at least 4 non-exact pixels in a row */
                     runLength = 4;
                     pixelsLeft -= 2;
                  }
               }
               else
               {
                  /* really the end of the line - exit main loop */
                  break;
               }
            }
            else  /* if (look4Same == FALSE) */
            {
               /* make sure we don't try to read past end of scanline */
               if ((pixelsLeft == 1) || ((runLength + 1) == 0xFF))
               {
                  /* if running past end, then add this single nibble */
                  pixelsLeft--;
                  runLength++;
               }
               /* compare the next two bytes */
               else if (pixelsLeft == 2 || (*srcHPtr != *(srcHPtr + 1)))
               {
                  /* if byte pair doesn't match, increment pointer and count */
                  srcHPtr++;
                  runLength  += 2;
                  pixelsLeft -= 2;
               }
               else
               {
                  /* if not at scanline end, or bytes match, bail */
                  break;
               }
            }

         /* continue while pixels are left and max runLength not exceeded */
         } while (pixelsLeft && (runLength < 0xFF));
      }

      /* check what the runLength consists of - same or different pixels */
      if (look4Same)
      {
         /* increment the rle compression count */
         rleCount += 2;

         if (writeDIB)
         {
            /* successful run length found - write to destination */
            *dstHPtr++ = runLength;
            *dstHPtr++ = compareByte;
         }
      }
      else  /* if (look4Same == FALSE) */
      {
         Boolean     oddCount;

         /* determine if there is an odd number of bytes to move */
         oddCount = (((runLength & (Byte)0x03) == 1) ||
                     ((runLength & (Byte)0x03) == 2));

         /* RLE byte count = 2 (setup) + word aligned BYTE count */
         rleCount += 2 + ((runLength + 1) / 2) + (Byte)oddCount;

         if (writeDIB)
         {
            /* write out the number of unique bytes */
            *dstHPtr++ = 0;
            *dstHPtr++ = runLength;

            /* write out the individual bytes until runLength is exhausted */
            while (runLength)
            {
               /* check if reading nibble at a time or byte */
               if (oddStart)
               {
                  /* have to read nibbles and create byte alignment */
                  *dstHPtr = (Byte)(*startRun++ << 4);
                  *dstHPtr++ |= (Byte)(*startRun >> 4);
               }
               else
               {
                  /* byte alignment already set up */
                  *dstHPtr++ = *startRun++;
               }

               /* check if this is the last byte written */
               if (runLength == 1)
               {
                  /* if so, zero low-order nibble and prepare for loop exit */
                  *(dstHPtr - 1) &= (Byte)0xF0;
                  runLength--;
               }
               else
               {
                  /* otherwise, 2 or more bytes remain, decrement counter */
                  runLength -= 2;
               }
            }

            /* add a null pad byte to align to word boundary */
            if (oddCount)
            {
               *dstHPtr++ = 0;
            }
         }
      }
   }

   /* increment total number of bytes */
   rleCount += 2;

   if (writeDIB)
   {
      /* write out an end of line marker */
      *dstHPtr++ = 0;
      *dstHPtr   = 0;
   }

   /* assign the value into the address provided */
   *rleByteCount += rleCount;

}  /* hrlecpy16 */



/****
 *
 * GdiEPSPreamble(PSBuf far* psbuf, Rect far *ps_bbox)
 * Parse the EPS bounding box and output the GDI PostScript preamble.
 * Assuming BBOX_LEFT, BBOX_TOP, BBOX_RIGHT and BBOX_BOTTOM are
 * the corners of the EPS bounding box parsed from the input string,
 * the GDI EPS preamble looks like:
 *
 *   POSTSCRIPT_DATA
 *      /pp_save save def ...
 *      /pp_bx1 ps_bbox->left def /pp_by1 ps_bbox->top def
 *      /pp_bx2 ps_bbox->right def /pp_by2 ps_bbox->bottom def
 *      ...
 *   POSTSCRIPT_IGNORE FALSE
 *   SaveDC
 *   CreateBrush NULL_BRUSH
 *   SelectObject
 *   CreatePen PS_SOLID 0 (255,255,254)
 *   SelectObject
 *   SetROP1(R2_NOP)
 *   Rectangle( qd_bbox )
 *   DeleteObject
 *   RestoreDC
 *   POSTSCRIPT_IGNORE TRUE
 *
 *   POSTSCRIPT_DATA
 *      pp_cx pp_cy moveto ...
 *      pp_tx pp_ty translate
 *      pp_sx pp_sy scale end
 *
 * The input buffer contains the length in bytes of the PostScript
 * data in the first word followed by the data itself.
 * The GDI clip region has already been set to the frame of the
 * PostScript image in QuickDraw coordinates.
 *
 ****/
static char gdi_ps1[] =
       "%%MSEPS Preamble %d %d %d %d %d %d %d %d\r/pp_save save def\r\
        /showpage {} def\r\
        40 dict begin /pp_clip false def /pp_bbox false def\r\
        /F { pop } def /S {} def\r\
        /B { { /pp_dy1 exch def /pp_dx1 exch def\r\
                   /pp_dy2 exch def /pp_dx2 exch def }\r\
                stopped not { /pp_bbox true def } if } def\r\
        /CB { { /pp_cy exch def /pp_cx exch def\r\
                    /pp_cht exch def /pp_cwd exch def }\r\
                stopped not { /pp_clip true def } if } def\n\
        /pp_bx1 %d def /pp_by1 %d def /pp_bx2 %d def /pp_by2 %d def\n";

static char gdi_ps2[] =
      "pp_clip\r\
        { pp_cx pp_cy moveto pp_cwd 0 rlineto 0 pp_cht rlineto\r\
          pp_cwd neg 0 rlineto clip newpath } if\r\
        pp_bbox {\r\
        /pp_dy2 pp_dy2 pp_dy1 add def\r\
        /pp_dx2 pp_dx2 pp_dx1 add def\r\
        /pp_sx pp_dx2 pp_dx1 sub pp_bx2 pp_bx1 sub div def\r\
        /pp_sy pp_dy2 pp_dy1 sub pp_by1 pp_by2 sub div def\r\
        /pp_tx pp_dx1 pp_sx pp_bx1 mul sub def\r\
        /pp_ty pp_dy1 pp_sy pp_by2 mul sub def\r\
        pp_tx pp_ty translate pp_sx pp_sy scale } if\r\
        end\r";

/*
 * Note: these structures must be kept compatible with
 * what the POSTSCRIPT_DATA Escape needs as input.
 */
static struct { Word length; char data[32]; } gdi_ps3 =
        { 31, "%MSEPS Trailer\rpp_save restore\r" };

void GdiEPSPreamble(Rect far* ps_bbox)
{
Word    false = 0;
Word    true = 1;
HPEN    pen;
Handle  h;
Word    len;
PSBuf far *tmpbuf;
Rect far *qd_bbox = &gdiEnv.clipRect;

   len = sizeof(gdi_ps1) + 100;                 // allow for expansion of %d
   len = max(len, sizeof(gdi_ps2));             // find longest string
   if ((h = GlobalAlloc(GHND, (DWORD) len + sizeof(PSBuf))) == 0)
     {
      ErSetGlobalError(ErMemoryFull);           // allocation error
      return;
     }
   tmpbuf = (PSBuf far *) GlobalLock(h);
   wsprintf(tmpbuf->data, (LPSTR) gdi_ps1,
                ps_bbox->left, ps_bbox->top, ps_bbox->right, ps_bbox->bottom,
                qd_bbox->left, qd_bbox->top, qd_bbox->right, qd_bbox->bottom,
                ps_bbox->left, ps_bbox->top, ps_bbox->right, ps_bbox->bottom);
   tmpbuf->length = lstrlen(tmpbuf->data);      // length of first string
   GdiEPSData(tmpbuf);                          // output begin preamble
   GdiEscape(POSTSCRIPT_IGNORE, sizeof(WORD), (StringLPtr) &false);
   SaveDC(gdiEnv.metafile);                     // output GDI transform code
   SelectObject(gdiEnv.metafile, GetStockObject(NULL_BRUSH));
   pen = CreatePen(PS_SOLID, 0, RGB(255, 255, 254));
   // Bug 45991
   if (pen) 
   {
      SelectObject(gdiEnv.metafile, pen);
      SetROP2(gdiEnv.metafile, R2_NOP);
      Rectangle(gdiEnv.metafile, qd_bbox->left, qd_bbox->top,
		qd_bbox->right, qd_bbox->bottom);
      DeleteObject(pen);
   }
   else
   {
      ErSetGlobalError(ErMemoryFull);           // allocation error
   }
   RestoreDC(gdiEnv.metafile, -1);
   GdiEscape(POSTSCRIPT_IGNORE, sizeof(WORD), (StringLPtr) &true);
   tmpbuf->length = sizeof(gdi_ps2) - 1;
   lstrcpy(tmpbuf->data, gdi_ps2);
   GdiEPSData(tmpbuf);                          // output transform preamble
   GlobalUnlock(h);                             // clean up
   GlobalFree(h);
}

void GdiEPSTrailer()
{
   Word  false = 0;

   GdiEscape(POSTSCRIPT_IGNORE, sizeof(WORD), (StringLPtr) &false);
   GdiEPSData((PSBuf far *) &gdi_ps3);
}

/****
 *
 * GdiEPSData(PSBuf far* psbuf)
 * Output PostScript data to GDI as POSTSCRIPT_DATA Escape
 *
 * notes:
 * Currently, this routine does not do any buffering. It just outputs
 * a separate POSTSCRIPT_DATA Escape each time it is called.
 *
 ****/
void GdiEPSData(PSBuf far* psbuf)
{
   GdiEscape(POSTSCRIPT_DATA, psbuf->length + sizeof(WORD), (StringLPtr) psbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\getdata.h ===
/****************************************************************************
                       Unit GetData; Interface
*****************************************************************************

 GetData implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.  It will also perform some data validation and
 perform limited coordinate transformations on the input data.

   Module Prefix: Get

*****************************************************************************/

/*********************** Exported Function Definitions **********************/

#define /* void */ GetByte( /* Byte far * */ byteLPtr )           \
/* Retrieves an 8-bit unsigned byte from the input stream */      \
IOGetByte( byteLPtr )


void GetWord( Word far * wordLPtr );
/* Clears destination then retrieves an 16-bit unsigned integer from the input 
   stream */


void GetDWord( DWord far * dwordLPtr );
/* Retrieves a 32-bit unsigned long from the input stream */


void GetBoolean( Boolean far * bool );
/* Retrieves an 8-bit Mac boolean and coverts to 16-bit Windows Boolean */


#define /* void */ GetFixed( /* Fixed far * */ fixedLPtr )        \
/* Retrieved a fixed point number consisting of 16-bit whole      \
   and 16-bit fraction */                                         \
GetDWord( (DWord far *)fixedLPtr )

/* Retrieves POINT structure without coordinate transforms */  
#ifdef WIN32
void GetPoint( Point * pointLPtr );
#else
#define /* void */ GetPoint( /* Point far * */ pointLPtr )        \
/* Retrieves POINT structure without coordinate transforms */     \
GetDWord( (DWord far *)pointLPtr )
#endif

#ifdef WIN32
void GetCoordinate( Point * pointLPtr );
#else
#define /* void */ GetCoordinate( /* Point far * */ pointLPtr )   \
/* Retrieves POINT structure without coordinte transforms */      \
GetDWord( (DWord far *)pointLPtr )
#endif


void GetRect( Rect far * rect);
/* Returns a RECT structure consisting of upper left and lower right
   coordinate pair */


void GetString( StringLPtr stringLPtr );
/* Retrieves a Pascal-style string and formats it C-style.  If the input
   parameter is NIL, then the ensuing data is simply skipped */


void GetRGBColor( RGBColor far * rgbLPtr );
/* Returns an RGB color */


void GetOctochromeColor( RGBColor far * rgbLPtr );
/* Returns an RGB color - this will be converted from a PICT octochrome
   color if this is a version 1 picture */


Boolean GetPolygon( Handle far * polyHandleLPtr, Boolean check4Same );
/* Retrieves a polygon definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated.
   If check4Same is TRUE, then the routine will compare the point list
   against the previous polygon definition, checking for equality.  If
   pointlists match, then the routine returns TRUE, otherwise, it will
   always return FALSE.  Use this to merge fill and frame operations. */


void GetRegion( Handle far * rgnHandleLPtr );
/* Retrieves a region definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated. */

   
void GetPattern( Pattern far * patLPtr );
/* Returns a Pattern structure */


void GetColorTable( Handle far * colorHandleLPtr );


void GetPixPattern( PixPatLPtr pixPatLPtr );
/* Retrieves a Pixel Pattern structure. */


void GetPixMap( PixMapLPtr pixMapLPtr, Boolean forcePixMap );
/* Retrieves a Pixel Map from input stream */


void GetPixData( PixMapLPtr pixMapLPtr, Handle far * pixDataHandle );
/* Read a pixel map from the data stream */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\gdiprim.h ===
/****************************************************************************
                       Unit GdiPrim; Interface
*****************************************************************************

 The Gdi module is called directly by the QuickDraw (QD) module in order
 to emit metafile primitives.  It is responsible for accessing the current
 CGrafPort structure in order to access the individual attribute settings.

 It also supports the caching and redundant elimination of duplicate
 elements when writing to the metafile.

   Module Prefix: Gdi

*****************************************************************************/

/*--- states ---*/

#define  Changed            0
#define  Current            1

/*--- state table offsets ---*/

#define  GdiPnPat             0x0001        /* fill patterns */
#define  GdiBkPat             0x0002
#define  GdiFillPat           0x0003
#define  GdiPnSize            0x0004        /* pen attribs */
#define  GdiPnMode            0x0005
#define  GdiFgColor           0x0006        /* foreground, background */
#define  GdiBkColor           0x0007
#define  GdiPnFgColor         0x000A
#define  GdiBkFgColor         0x000B
#define  GdiFillFgColor       0x000C
#define  GdiPnBkColor         0x000D
#define  GdiBkBkColor         0x000E
#define  GdiFillBkColor       0x000F
#define  GdiTxFont            0x0010        /* text attribs */
#define  GdiTxFace            0x0011
#define  GdiTxSize            0x0012
#define  GdiTxMode            0x0013
#define  GdiTxRatio           0x0014
#define  GdiChExtra           0x0015
#define  GdiSpExtra           0x0016
#define  GdiLineJustify       0x0017
#define  GdiNumAttrib         0x0018


/*--- Action verbs ---*/

typedef  Integer     GrafVerb;

#define  GdiFrame             0
#define  GdiPaint             1
#define  GdiErase             2
#define  GdiInvert            3
#define  GdiFill              4


/*--- metafile comment ---*/

#define  PUBLIC                  0xFFFFFFFF     /* '....' public */
#define  POWERPOINT_OLD          0x5050FE54     /* 'PP.T' PowerPoint 2.0 */
#define  POWERPOINT              0x50504E54     /* 'PPNT' PowerPoint 3.0 */
#define  PRIVATE                 0x512D3E47     /* 'Q->G' QD2GDI */
#define  SUPERPAINT              0x53504E54     /* 'SPNT' SuperPaint */

#define  PC_REGISTERED           0x8000         /* PowerPoint callback flag */

#define  QG_SIGNATURE            "QuickDraw -> GDI"

#define  BEGIN_GROUP             0              /* public comments */
#define  END_GROUP               1
#define  CREATOR                 4
#define  BEGIN_BANDING           6
#define  END_BANDING             7

#define  PP_VERSION              0x00           /* PowerPoint comments */
#define  PP_BFILEBLOCK           0x01
#define  PP_BEGINPICTURE         0x02
#define  PP_ENDPICTURE           0x03
#define  PP_DEVINFO              0x04
#define  PP_BEGINHYPEROBJ        0x05
#define  PP_ENDHYPEROBJ          0x06
#define  PP_BEGINFADE            0x07
#define  PP_ENDFADE              0x08

#define  PP_FONTNAME             0x11           /* GDI2QD round-trip */
#define  PP_HATCHPATTERN         0x12

#define  PP_BEGINCLIPREGION      0x40           /* clip regions from QD2GDI */
#define  PP_ENDCLIPREGION        0x41
#define  PP_BEGINTRANSPARENCY    0x42
#define  PP_ENDTRANSPARENCY      0x43
#define  PP_MASK                 0x44
#define  PP_TRANSPARENTOBJ       0x45

#define  PP_MACPP2COLOR          0x80
#define  PP_WINGRAPH             0xAB


typedef struct
{
   DWord       signature;
   Word        function;
   DWord       size;

}  Comment, far * CommentLPtr;


/*--- PostScript data buffer (POSTSCRIPT_DATA Escape) ---*/

typedef struct psbuf
{
   Word     length;
   char     data[1];
} PSBuf;


/*--- Conversion preferences ---*/

#define  GdiPrefOmit    0
#define  GdiPrefAbort   2

typedef struct
{
   StringLPtr  metafileName;
   Byte        penPatternAction;
   Byte        nonSquarePenAction;
   Byte        penModeAction;
   Byte        textModeAction;
   Byte        nonRectRegionAction;
   Boolean     optimizePP;
   Byte        noRLE;
} ConvPrefs, far * ConvPrefsLPtr;


/*--- Conversion results ---*/

typedef struct
{
   HANDLE   hmf;        /* Global memory handle to the metafile */
   RECT     bbox;       /* Tightly bounding rectangle in metafile units */
   short    inch;       /* Length of an inch in metafile units */
} PICTINFO, FAR * PictInfoLPtr;



/*********************** Exported Function Definitions **********************/

void GdiOffsetOrigin( Point delta );
/* offset the current window origin and picture bounding box */


void GdiLineTo( Point newPt );
/* Emit line primitive with square endcaps */


void GdiRectangle( GrafVerb verb, Rect rect );
/* Emit rectangle primitive using action and dimensions parameters */


void GdiRoundRect( GrafVerb verb, Rect rect, Point oval );
/* Emit rounded rectangle primitive */


void GdiOval( GrafVerb verb, Rect rect );
/* Emit an oval primitive */


void GdiArc( GrafVerb verb, Rect rect, Integer startAngle, Integer arcAngle );
/* Emit an arc primitive */


void GdiPolygon( GrafVerb verb, Handle poly );
/* Emit polygon primitive */


void GdiRegion( GrafVerb verb, Handle rgn );
/* Emit region primitive */


void GdiTextOut( StringLPtr string, Point location );
/* draw the text at the location specified by location parameter. */


void GdiStretchDIBits( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                       Rect src, Rect dst, Word mode, Handle mask );
/* Draw a Windows device-independant bitmap */


void GdiSelectClipRegion( RgnHandle rgn );
/* Create a clipping rectangle or region using handle passed */


void GdiHatchPattern( Integer hatchIndex );
/* Use the hatch pattern index passed down to perform all ensuing fill
   operations - 0-6 for a hatch value, -1 turns off the substitution */


void GdiFontName( Byte fontFamily, Byte charSet, StringLPtr fontName );
/* Set font characteristics based upno metafile comment from GDI2QD */


void GdiShortComment( CommentLPtr cmt );
/* Write public or private comment with no associated data */


void GdiEscape( Integer function, Integer count, StringLPtr data);
/* Write out a GDI Escape structure with no returned data */


void GdiSetConversionPrefs( ConvPrefsLPtr convPrefs);
/* Provide conversion preferences via global data block */


void GdiOpenMetafile( void );
/* Open metafile passed by GdiSetMetafileName() and perform any
   initialization of the graphics state */


void GdiSetBoundingBox( Rect bbox, Integer resolution );
/* Set the overall picture size and picture resoulution in dpi */


void GdiCloseMetafile( void );
/* Close the metafile handle and end picture generation */


void GdiGetConversionResults( PictInfoLPtr  pictInfoLPtr );
/* return results of the conversion */


void GdiMarkAsChanged( Integer attribCode );
/* indicate that the attribute passed in has changed */


#ifdef WIN32
int WINAPI EnumFontFunc( CONST LOGFONT *logFontLPtr, CONST TEXTMETRIC *tmLPtr,
                         DWORD fontType, LPARAM dataLPtr );
#else
int FAR PASCAL EnumFontFunc( LPLOGFONT logFontLPtr, LPTEXTMETRIC tmLPtr,
                             short fontType, LPSTR dataLPtr );
#endif
/* Callback function used to determine if a given font is available */

void GdiSamePrimitive( Boolean same );
/* indicate whether next primitive is the same or new */

void GdiEPSPreamble(Rect far *);
/* output GDI EPS filter PostScript preamble */

void GdiEPSTrailer( void );
/* output GDI EPS filter PostScript trailer */

void GdiEPSData(PSBuf far*);
/* output EPS PostScript data as GDI POSTSCRIPT_DATA Escape */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\headers.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1994.
//
//  File:       headers.c
//
//  Contents:   Precompiled header for olecnv32.dll
//
//  History:    28-Mar-94 AlexT     Created
//
//--------------------------------------------------------------------------

#undef UNICODE
#undef _UNICODE


#include "toolbox.h"    /* the underlying toolbox environment */
#include "error.h"      /* for error codes */
#include "quickdrw.h"   /* for some typedefs */
#include "bufio.h"
#include "gdiprim.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\quickdrw.h ===
/****************************************************************************
                            Module Quickdrw; Interface
*****************************************************************************

 This is the main module interface to the data stream interpreter.  As such,
 it will read individual opcode elements and the appropriate data 
 parameters associated with that opocode.  These are either placed into
 the CGrafPort structure or calls are made to the Gdi module to issue
 the correct metafile function.

   Module prefix:  QD

****************************************************************************/

/*--- Source transfer modes ---*/

#define  QDSrcCopy         0
#define  QDSrcOr           1
#define  QDSrcXor          2
#define  QDSrcBic          3
#define  QDNotSrcCopy      4
#define  QDNotSrcOr        5
#define  QDNotSrcXor       6
#define  QDNotSrcBic       7

/*--- Pattern transfer modes ---*/

#define  QDPatCopy         8
#define  QDPatOr           9
#define  QDPatXor          10
#define  QDPatBic          11
#define  QDNotPatCopy      12
#define  QDNotPatOr        13
#define  QDNotPatXor       14
#define  QDNotPatBic       15

/*--- Arithmetic transfer modes ---*/

#define  QDBlend           32
#define  QDAddPin          33
#define  QDAddOver         34
#define  QDSubPin          35
#define  QDTransparent     36
#define  QDAdMax           37
#define  QDSubOver         38
#define  QDAdMin           39

/*--- Undocumented hidden transfer mode ---*/

#define  QDHidePen         23


/*--- Font styles ---*/

#define  QDTxBold          0x01
#define  QDTxItalic        0x02
#define  QDTxUnderline     0x04
#define  QDTxOutline       0x08
#define  QDTxShadow        0x10
#define  QDTxCondense      0x20
#define  QDTxExtend        0x40


/*--- LaserWriter Text attributes ---*/

#define  QDAlignNone       0x00
#define  QDAlignLeft       0x01
#define  QDAlignCenter     0x02
#define  QDAlignRight      0x03
#define  QDAlignJustified  0x04

#define  QDFlipNone        0x00
#define  QDFlipHorizontal  0x01
#define  QDFlipVertical    0x02


/*--- Polygon and Region structure sizes ---*/

#define  PolyHeaderSize (sizeofMacWord + sizeofMacRect)
#define  RgnHeaderSize  (sizeofMacWord + sizeofMacRect)

/*--- PixelMap structure ---*/

#define  PixelMapBit       0x8000
#define  RowBytesMask      0x7FFF

typedef struct
{
   Integer        rowBytes;
   Rect           bounds;
   Integer        pmVersion;
   Word           packType;
   LongInt        packSize;
   Fixed          hRes;
   Fixed          vRes;
   Integer        pixelType;
   Integer        pixelSize;
   Integer        cmpCount;
   Integer        cmpSize;
   LongInt        planeBytes;
   Handle         pmTable;
   Word           pmTableSlop;
   LongInt        pmReserved;
} PixMap, far * PixMapLPtr;


/*--- Pixel Pattern structure ---*/

#define  QDOldPat      0
#define  QDNewPat      1
#define  QDDitherPat   2

typedef  Byte  Pattern[8];

typedef struct
{
   Integer        patType;
   PixMap         patMap;
   Handle         patData;
   Pattern        pat1Data;
} PixPat, far * PixPatLPtr;


/*--- Miscellaneous type declarations ---*/

#define  RgnHandle      Handle
#define  PixPatHandle   Handle
#define  RGBColor       COLORREF


/*--- Color Table structure ---*/

typedef struct
{
   LongInt        ctSeed;
   Word           ctFlags;
   Word           ctSize;
   RGBColor       ctColors[1];

} ColorTable, far * ColorTableLPtr;


/*--- QuickDraw grafPort simulation ---*/

typedef struct
{
   Integer        portVersion;
   Integer        chExtra;
   Integer        pnLocHFrac;
   Rect           portRect;
   RgnHandle      clipRgn;
   PixPat         bkPixPat;
   RGBColor       rgbFgColor;
   RGBColor       rgbBkColor;
   Point          pnLoc;
   Point          pnSize;
   Integer        pnMode;
   PixPat         pnPixPat;
   PixPat         fillPixPat;
   Integer        pnVis;
   Integer        txFont;
   Byte           txFace;
   Integer        txMode;
   Integer        txSize;
   Fixed          spExtra;
   Handle         rgnSave;
   Handle         polySave;
   Byte           txFontName[32];
   Point          txLoc;
   Point          txNumerator;
   Point          txDenominator;
   Integer        txRotation;
   Byte           txFlip;

} CGrafPort, far * CGrafPortLPtr;


/**************************** Exported Operations ***************************/

void QDConvertPicture( Handle dialogHandle );
/* create a Windows metafile using the previously set parameters, returning
   the converted picture information in the pictResult structure. */


void QDGetPort( CGrafPort far * far * port );
/* return handle to grafPort structure */


void QDCopyBytes( Byte far * src, Byte far * dest, Integer numBytes );
/* copy a data from source to destination */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\qd2gdi.h ===
/****************************************************************************

                   QuickDraw PICT Import Filter

*****************************************************************************

   This file contains the interface for the QuickDraw import filter 
   that reads Mac pictures from disk and/or memory.  In addition to the
   Aldus filter interface, it also supports a parameterized interface
   for Microsoft applications to control some conversion results.

****************************************************************************/

/*--- Possible Aldus-defined error code returns ---*/

#define NOERR              0     // Conversion succeeded

#define IE_NOT_MY_FILE     5301  // Invalid version (not version 1 or 2 PICT)
                                 // Invalid QD2GDI structure version (greater than 2)
                                 // Ill-formed PICT header record sequence

#define  IE_TOO_BIG        5302  // Image extents exceed 32K

#define IE_BAD_FILE_DATA   5309  // Image bounding box is empty
                                 // Attempt to read past end of picture
                                 // Corrupted input file
                                 // Zero-length record

#define  IE_IMPORT_ABORT   5310  // Opening of source image failed
                                 // Read failure (network failure, floppy popped)
                                 // Most I/O errors

#define IE_MEM_FULL        5311  // CreateMetaFile() failure
                                 // CloseMetaFile() failure
                                 // Unable to allocate memory (out of memory)

#define IE_MEM_FAIL        5315  // Handle lock failure

#define IE_NOPICTURES      5317  // Empty bounding rectangle or nothing drawn

#define IE_UNSUPP_VERSION  5342  // User-defined abort performed


/*--- Aldus-defined file access block ---*/

typedef DWORD FILETYPE;

typedef struct 
{
   unsigned slippery : 1;  /* TRUE if file may disappear. */
   unsigned write : 1;     /* TRUE if open for write. */
   unsigned unnamed : 1;   /* TRUE if unnamed. */
   unsigned linked : 1;    /* Linked to an FS FCB. */
   unsigned mark : 1;      /* Generic mark bit. */
   FILETYPE fType;         /* The file type. */
#define IBMFNSIZE 124
   short    handle;        /* MS-DOS open file handle. */
   char     fullName[IBMFNSIZE]; /* Device, path, file names. */
   DWORD    filePos;    /* Our current file posn. */
} FILESPEC, FAR *LPFILESPEC;


/*--- Aldus-defined picture info structure ---*/

typedef struct {
   HANDLE   hmf;           /* Global memory handle to the metafile */
   RECT     bbox;          /* Tightly bounding rectangle in metafile units */
   DC       inch;          /* Length of an inch in metafile units */
} PICTINFO;

/*--- Preferences memory block ---*/

typedef struct                   /* "old" version 1 USERPREFS */
{
   char     signature[6];
   WORD     version;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     charLock;
   BYTE     nonRectRegionAction;
   BOOL     PICTinComment;
   BOOL     optimizePP;
   WORD     lineClipWidthThreshold;
   WORD     reserved[6];   
} USERPREFS_V1, FAR *LPUSERPREFS_V1;


typedef struct                   /* current version 3 USERPREFS */
{
   char     signature[6];
   WORD     version;
   WORD     size;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     nonRectRegionAction;
   BOOL     optimizePP;
   BYTE     noRLE;         // new (split out from reserved[0] in version 3)
   BYTE     reservedByte;  // rest of first reserved word
   WORD     reserved[5];

} USERPREFS, FAR * LPUSERPREFS;


/*********************** Exported Function Definitions **********************/

#ifdef WIN32
int WINAPI GetFilterInfo( short PM_Version, LPSTR lpIni, 
                          HANDLE FAR * lphPrefMem, 
                          HANDLE FAR * lphFileTypes );
#else
int FAR PASCAL GetFilterInfo( short PM_Version, LPSTR lpIni, 
                              HANDLE FAR * lphPrefMem, 
                              HANDLE FAR * lphFileTypes );
#endif
/* Returns information about this filter. 
   Input parameters are PM_Version which is the filter interface version#
         and lpIni which is a copy of the win.ini entry
   Output parameters are lphPrefMem which is a handle to moveable global
         memory which will be allocated and initialized.
         lphFileTypes is a structure that contains the file types
         that this filter can import. (For MAC only)
   This routine should be called once, just before the filter is to be used
   the first time. */


#ifdef WIN32
void WINAPI GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#else
void FAR PASCAL GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#endif
/* Input parameters are hInst (in order to access resources), hWnd (to
   allow the DLL to display a dialog box), and hPrefMem (memory allocated
   in the GetFilterInfo() entry point).  WFlags is currently unused, but
   should be set to 1 for Aldus' compatability */


#ifdef WIN32
short WINAPI ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                       PICTINFO FAR * lpPict, HANDLE hPrefMem );
#else
short FAR PASCAL ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                           PICTINFO FAR * lpPict, HANDLE hPrefMem );
#endif
/* Import the metafile in the file indicated by the lpFileSpec. The 
   metafile generated will be returned in lpPict. */


#ifdef WIN32
short WINAPI ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                               PICTINFO FAR * lpPict, HANDLE hPrefMem,
                               DWORD dwSize, LPSTR lpMetafileName );
#else
short FAR PASCAL ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                                   PICTINFO FAR * lpPict, HANDLE hPrefMem,
                                   DWORD dwSize, LPSTR lpMetafileName );
#endif
/* Import the metafile in using the previously opened file handle in
   the structure field lpFileSpec->handle. Reading begins at offset
   lpFileSpect->filePos, and the convertor will NOT expect to find the
   512 byte PICT header.  The metafile generated will be returned in
   lpPict and can be specified via lpMetafileName (NIL = memory metafile,
   otherwise, fully qualified filename. */

#ifdef WIN32
short WINAPI QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#else
short FAR PASCAL QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#endif
/* Import the metafile as specified using the parameters supplied in the
   lpPrefMem.  The metafile will be returned in lpPict. */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\quickdrw.c ===
/****************************************************************************
                     Module Quickdrw: Implementation
*****************************************************************************

 This is the interpreter engine for the picture convertor.  It uses a
 modified CGrafPort structure to hold the intermediate results of a
 translation that can later be accessed from the Gdi module.  As such,
 it provides an input cache for all attributes, with calls made
 directly to the Gdi module for primitives.

 It is called by the API module and will call the Get module in order
 to read individual data or record elements from the data stream.

   Module prefix:  QD

****************************************************************************/

#include "headers.c"
#pragma hdrstop

/* C libraries */
#include "string.h"
#include <ctype.h>

/* quickdrw's own interface */
#include "qdopcode.i"
#include "qdcoment.i"

/* imported modules */
#include <math.h>
#include "filesys.h"
#include "getdata.h"

/*********************** Exported Data Initialization ***********************/


/******************************* Private Data *******************************/

/*--- QuickDraw grafPort simulation --- */

#define  Version1ID     0x1101
#define  Version2ID     0x02FF


/*--- QuickDraw opcode fields --- */

/* -1 is casted to Word to prevent warning in WIN32 compilation */
#define  Reserved       (Word) -1

#define  Variable       -1
#define  CommentSize    -2
#define  RgnOrPolyLen   -3
#define  WordDataLen    -4
#define  DWordDataLen   -5
#define  HiByteLen      -6

typedef struct
{
   Word     function;
   Integer  length;
} opcodeEntry, far * opcodeEntryLPtr;

/* The following opcode table was taken from "Inside Macintosh, Volume V" on
   pages V-97 to V-102 and supplemented by System 7 opcodes from "Inside
   Macintosh, Volume VI", page 17-20. */

#define  LookupTableSize      0xA2

private  opcodeEntry opcodeLookup[LookupTableSize] =
{
   /* 0x00 */ { NOP,                 0 },
   /* 0x01 */ { Clip,                RgnOrPolyLen },
   /* 0x02 */ { BkPat,               8 },
   /* 0x03 */ { TxFont,              2 },
   /* 0x04 */ { TxFace,              1 },
   /* 0x05 */ { TxMode,              2 },
   /* 0x06 */ { SpExtra,             4 },
   /* 0x07 */ { PnSize,              4 },
   /* 0x08 */ { PnMode,              2 },
   /* 0x09 */ { PnPat,               8 },
   /* 0x0A */ { FillPat,             8 },
   /* 0x0B */ { OvSize,              4 },
   /* 0x0C */ { Origin,              4 },
   /* 0x0D */ { TxSize,              2 },
   /* 0x0E */ { FgColor,             4 },
   /* 0x0F */ { BkColor,             4 },
   /* 0x10 */ { TxRatio,             8 },
   /* 0x11 */ { Version,             1 },
   /* 0x12 */ { BkPixPat,            Variable },
   /* 0x13 */ { PnPixPat,            Variable },
   /* 0x14 */ { FillPixPat,          Variable },
   /* 0x15 */ { PnLocHFrac,          2 },
   /* 0x16 */ { ChExtra,             2 },
   /* 0x17 */ { Reserved,            0 },
   /* 0x18 */ { Reserved,            0 },
   /* 0x19 */ { Reserved,            0 },
   /* 0x1A */ { RGBFgCol,            6 },
   /* 0x1B */ { RGBBkCol,            6 },
   /* 0x1C */ { HiliteMode,          0 },
   /* 0x1D */ { HiliteColor,         6 },
   /* 0x1E */ { DefHilite,           0 },
   /* 0x1F */ { OpColor,             6 },
   /* 0x20 */ { Line,                8 },
   /* 0x21 */ { LineFrom,            4 },
   /* 0x22 */ { ShortLine,           6 },
   /* 0x23 */ { ShortLineFrom,       2 },
   /* 0x24 */ { Reserved,            WordDataLen },
   /* 0x25 */ { Reserved,            WordDataLen },
   /* 0x26 */ { Reserved,            WordDataLen },
   /* 0x27 */ { Reserved,            WordDataLen },
   /* 0x28 */ { LongText,            Variable },
   /* 0x29 */ { DHText,              Variable },
   /* 0x2A */ { DVText,              Variable },
   /* 0x2B */ { DHDVText,            Variable },
   /* 0x2C */ { FontName,            WordDataLen },
   /* 0x2D */ { LineJustify,         WordDataLen },
   /* 0x2E */ { Reserved,            WordDataLen },
   /* 0x2F */ { Reserved,            WordDataLen },
   /* 0x30 */ { frameRect,           8 },
   /* 0x31 */ { paintRect,           8 },
   /* 0x32 */ { eraseRect,           8 },
   /* 0x33 */ { invertRect,          8 },
   /* 0x34 */ { fillRect,            8 },
   /* 0x35 */ { Reserved,            8 },
   /* 0x36 */ { Reserved,            8 },
   /* 0x37 */ { Reserved,            8 },
   /* 0x38 */ { frameSameRect,       0 },
   /* 0x39 */ { paintSameRect,       0 },
   /* 0x3A */ { eraseSameRect,       0 },
   /* 0x3B */ { invertSameRect,      0 },
   /* 0x3C */ { fillSameRect,        0 },
   /* 0x3D */ { Reserved,            0 },
   /* 0x3E */ { Reserved,            0 },
   /* 0x3F */ { Reserved,            0 },
   /* 0x40 */ { frameRRect,          8 },
   /* 0x41 */ { paintRRect,          8 },
   /* 0x42 */ { eraseRRect,          8 },
   /* 0x43 */ { invertRRect,         8 },
   /* 0x44 */ { fillRRect,           8 },
   /* 0x45 */ { Reserved,            8 },
   /* 0x46 */ { Reserved,            8 },
   /* 0x47 */ { Reserved,            8 },
   /* 0x48 */ { frameSameRRect,      0 },
   /* 0x49 */ { paintSameRRect,      0 },
   /* 0x4A */ { eraseSameRRect,      0 },
   /* 0x4B */ { invertSameRRect,     0 },
   /* 0x4C */ { fillSameRRect,       0 },
   /* 0x4D */ { Reserved,            0 },
   /* 0x4E */ { Reserved,            0 },
   /* 0x4F */ { Reserved,            0 },
   /* 0x50 */ { frameOval,           8 },
   /* 0x51 */ { paintOval,           8 },
   /* 0x52 */ { eraseOval,           8 },
   /* 0x53 */ { invertOval,          8 },
   /* 0x54 */ { fillOval,            8 },
   /* 0x55 */ { Reserved,            8 },
   /* 0x56 */ { Reserved,            8 },
   /* 0x57 */ { Reserved,            8 },
   /* 0x58 */ { frameSameOval,       0 },
   /* 0x59 */ { paintSameOval,       0 },
   /* 0x5A */ { eraseSameOval,       0 },
   /* 0x5B */ { invertSameOval,      0 },
   /* 0x5C */ { fillSameOval,        0 },
   /* 0x5D */ { Reserved,            0 },
   /* 0x5E */ { Reserved,            0 },
   /* 0x5F */ { Reserved,            0 },
   /* 0x60 */ { frameArc,            12 },
   /* 0x61 */ { paintArc,            12 },
   /* 0x62 */ { eraseArc,            12 },
   /* 0x63 */ { invertArc,           12 },
   /* 0x64 */ { fillArc,             12 },
   /* 0x65 */ { Reserved,            12 },
   /* 0x66 */ { Reserved,            12 },
   /* 0x67 */ { Reserved,            12 },
   /* 0x68 */ { frameSameArc,        4 },
   /* 0x69 */ { paintSameArc,        4 },
   /* 0x6A */ { eraseSameArc,        4 },
   /* 0x6B */ { invertSameArc,       4 },
   /* 0x6C */ { fillSameArc,         4 },
   /* 0x6D */ { Reserved,            4 },
   /* 0x6E */ { Reserved,            4 },
   /* 0x6F */ { Reserved,            4 },
   /* 0x70 */ { framePoly,           RgnOrPolyLen },
   /* 0x71 */ { paintPoly,           RgnOrPolyLen },
   /* 0x72 */ { erasePoly,           RgnOrPolyLen },
   /* 0x73 */ { invertPoly,          RgnOrPolyLen },
   /* 0x74 */ { fillPoly,            RgnOrPolyLen },
   /* 0x75 */ { Reserved,            RgnOrPolyLen },
   /* 0x76 */ { Reserved,            RgnOrPolyLen },
   /* 0x77 */ { Reserved,            RgnOrPolyLen },
   /* 0x78 */ { frameSamePoly,       0 },
   /* 0x79 */ { paintSamePoly,       0 },
   /* 0x7A */ { eraseSamePoly,       0 },
   /* 0x7B */ { invertSamePoly,      0 },
   /* 0x7C */ { fillSamePoly,        0 },
   /* 0x7D */ { Reserved,            0 },
   /* 0x7E */ { Reserved,            0 },
   /* 0x7F */ { Reserved,            0 },
   /* 0x80 */ { frameRgn,            RgnOrPolyLen },
   /* 0x81 */ { paintRgn,            RgnOrPolyLen },
   /* 0x82 */ { eraseRgn,            RgnOrPolyLen },
   /* 0x83 */ { invertRgn,           RgnOrPolyLen },
   /* 0x84 */ { fillRgn,             RgnOrPolyLen },
   /* 0x85 */ { Reserved,            RgnOrPolyLen },
   /* 0x86 */ { Reserved,            RgnOrPolyLen },
   /* 0x87 */ { Reserved,            RgnOrPolyLen },
   /* 0x88 */ { frameSameRgn,        0 },
   /* 0x89 */ { paintSameRgn,        0 },
   /* 0x8A */ { eraseSameRgn,        0 },
   /* 0x8B */ { invertSameRgn,       0 },
   /* 0x8C */ { fillSameRgn,         0 },
   /* 0x8D */ { Reserved,            0 },
   /* 0x8E */ { Reserved,            0 },
   /* 0x8F */ { Reserved,            0 },
   /* 0x90 */ { BitsRect,            Variable },
   /* 0x91 */ { BitsRgn,             Variable },
   /* 0x92 */ { Reserved,            WordDataLen },
   /* 0x93 */ { Reserved,            WordDataLen },
   /* 0x94 */ { Reserved,            WordDataLen },
   /* 0x95 */ { Reserved,            WordDataLen },
   /* 0x96 */ { Reserved,            WordDataLen },
   /* 0x97 */ { Reserved,            WordDataLen },
   /* 0x98 */ { PackBitsRect,        Variable },
   /* 0x99 */ { PackBitsRgn,         Variable },
   /* 0x9A */ { DirectBitsRect,      WordDataLen },
   /* 0x9B */ { DirectBitsRgn,       WordDataLen },
   /* 0x9C */ { Reserved,            WordDataLen },
   /* 0x9D */ { Reserved,            WordDataLen },
   /* 0x9E */ { Reserved,            WordDataLen },
   /* 0x9F */ { Reserved,            WordDataLen },
   /* 0xA0 */ { ShortComment,        2 },
   /* 0xA1 */ { LongComment,         CommentSize }
};

#define  RangeTableSize    7

private  opcodeEntry opcodeRange[RangeTableSize] =
{
   /* 0x00A2 - 0x00AF */ { 0x00AF,   WordDataLen },
   /* 0x00B0 - 0x00CF */ { 0x00CF,   0 },
   /* 0x00D0 - 0x00FE */ { 0x00FE,   DWordDataLen },
   /* 0x00FF - 0x00FF */ { opEndPic, 0 },
   /* 0x0100 - 0x07FF */ { 0x8000,   HiByteLen },
   /* 0x8000 - 0x80FF */ { 0x80FF,   0 },
   /* 0x8100 - 0xFFFF */ { 0xFFFF,   DWordDataLen }
};

/*--- EPS Filter PostScript Strings ---*/

#define   MAC_PS_TRAILER  "pse\rpsb\r"
#define   MAC_PS_PREAMBLE "pse\rcurrentpoint\r/picTop exch def\r/picLeft exch def\rpsb\r"

#define   SUPERPAINT_TEXTSTARTJUNK "P2_b ["
#define   SUPERPAINT_TEXTSTOPJUNK  "] sb end\r"

/*--- GrafPort allocation ---*/

#define  PARSEPOLY      1
#define  SKIPALTPOLY    2
#define  USEALTPOLY     3

#define  MASKPOLYBITS   0x07
#define  FRAMEPOLY      0x01
#define  FILLPOLY       0x02
#define  CLOSEPOLY      0x04
#define  FILLREQUIRED   0x08
#define  CHECK4SPLINE   0x10

#define  POLYLIST       ((sizeof( Integer ) + sizeof( Rect )) / sizeof( Integer ))
#define  BBOX           1

private  CGrafPort      grafPort;
private  Integer        resolution;
private  Boolean        skipFontID;
private  Integer        maxPoints;
private  Integer        numPoints;
private  Integer far *  numPointsLPtr;
private  Rect           polyBBox;
private  Point far *    polyListLPtr;
private  Handle         polyHandle;
private  Byte           polyMode;
private  Byte           polyParams;
private  RGBColor       polyFgColor;
private  RGBColor       polyBkColor;
private  Boolean        zeroDeltaExpected;

private  Boolean        textMode;
private  Boolean        newTextCenter;
private  Point          textCenter;
private  Boolean        textClipCheck;
private  Real           degCos;
private  Real           degSin;

private  Boolean        shadedObjectStarted;
private  Boolean        superPaintFile;
private  Boolean        badSuperPaintText;

/*--- last Primitive sent ---*/

private  Rect     saveRect;
private  Rect     saveRRect;
private  Rect     saveOval;
private  Point    saveOvalSize;
private  Rect     saveArc;
private  Integer  saveStartAngle;
private  Integer  saveArcAngle;

/*--- Global allocated contstants ---*/

private Pattern  SolidPattern = { 0xFF, 0xFF, 0xFF, 0xFF,
                                  0xFF, 0xFF, 0xFF, 0xFF };


/*********************** Private Routine Declarations ***********************/

private void ReadHeaderInfo( void );
/* read the fixed size PICT header from the file.  This provides information
   about the file size (however, it may be invalid and is ignored) and the
   picture bounding box, followed by the PICT version information. */

private void ReadPictVersion( void );
/* Read the PICT version number from the data file.  If this isn't a
   version 1 or 2 file, the routine returns IE_UNSUPP_VERSION error. */

private void ReadOpcode( opcodeEntry far * nextOpcode );
/* Reads the next opcode from the stream, depending on the PICT version */

private void TranslateOpcode( opcodeEntry far * currOpcodeLPtr );
/* read in the remaining data from the stream, based upon the opcode function
   and then call the appropriate routine in Gdi module */

private void SkipData( opcodeEntry far * currOpcodeLPtr );
/* skip the data - the opcode won't be translated and Gdi module won't be
   called to create anything in the metafile */

private void   OpenPort( void );
/* initialize the grafPort */

private void   ClosePort( void );
/* close grafPort and de-allocate any memory blocks */

private void NewPolygon( void );
/* initialize the state of the polygon buffer - flush any previous data */

private void AddPolySegment( Point start, Point end );
/* Add the line segment to the polygon buffer */

private void DrawPolyBuffer( void );
/* Draw the polygon definition if the points were read without errors */

private void AdjustTextRotation( Point far * newPt );
/* This will calculate the correct text position if text is rotated */

private Integer EPSComment(Word comment);
/* parse EPS Comment */

private Integer EPSData(Integer state);
/* process EPS Data */

private Boolean EPSBbox(PSBuf far *, Rect far *);
/* parse EPS bounding box description */

private char far* parse_number(char far* ptr, Integer far *iptr);
/* parse numeric string (local to EPSBbox) */

#define IsCharDigit(c) (IsCharAlphaNumeric(c) && !IsCharAlpha(c))

/**************************** Function Implementation ***********************/

void QDConvertPicture( Handle dialogHandle )
/*====================*/
/* create a Windows metafile using the previously set parameters, returning
   the converted picture information in the pictResult structure. */

{
   opcodeEntry    currOpcode;

   /* Open the file - if an error occured, return to main */
   IOOpenPicture( dialogHandle );

   /* Tell Gdi module to open the metafile */
   GdiOpenMetafile();

   /* initialize the grafPort */
   OpenPort();

   /* read and validate size, bounding box, and PICT version */
   ReadHeaderInfo();

   do
   {
      /* read the next opcode from the data stream */
      ReadOpcode( &currOpcode );

      /* read the ensuing data and call Gdi module entry points */
      TranslateOpcode( &currOpcode );

      /* align next memory read to Word boundary in the case of PICT 2 */
      if (grafPort.portVersion == 2)
      {
         IOAlignToWordOffset();
      }

      /* update the status dialog with current progress */
      IOUpdateStatus();

      /* break out of loop if end picture opcode is encountered */
   } while (currOpcode.function != opEndPic);

   /* close grafPort and de-allocate any used memory blocks */
   ClosePort();

   /* Tell Gdi module that picture is ending - perform wrapup */
   GdiCloseMetafile();

   /* Close the file */
   IOClosePicture();

} /* ReFileToPicture */


void QDGetPort( CGrafPort far * far * port )
/*============*/
/* return handle to grafPort structure */
{
   *port = &grafPort;
}


void QDCopyBytes( Byte far * src, Byte far * dest, Integer numBytes )
/*==============*/
/* copy a data from source to destination */
{
   /* loop through entire data length */
   while (numBytes--)
   {
      *dest++ = *src++;
   }

}  /* CopyBytes */


/******************************* Private Routines ***************************/


private void ReadHeaderInfo( void )
/*-------------------------*/
/* read the fixed size PICT header from the file.  This provides information
   about the file size (however, it may be invalid and is ignored) and the
   picture bounding box, followed by the PICT version information. */
{
   Word        unusedSize;

   /* read file size - this value is ignored since it may be totally bogus */
   GetWord( &unusedSize );

   /* the next rectangle contains the picture bounding box */
   GetRect( &grafPort.portRect );

   /* Read the next record that indicates a PICT1 or PICT2 version picture */
   ReadPictVersion();

   /* Call Gdi module and provide bounding box coordinates.  Note that these
      may have been altered from rectangle specified above if a spatial
      resolution other than 72 dpi is used in the picture. */
   GdiSetBoundingBox( grafPort.portRect, resolution );

}  /* ReadHeaderInfo */


private void ReadPictVersion( void )
/*--------------------------*/
/* Read the PICT version number from the data file.  If this isn't a
   version 1 or 2 file, the routine returns IE_UNSUPP_VERSION error. */
{
   opcodeEntry    versionOpcode;
   Word           versionCheck = 0;
   Word           opcodeCheck  = 0;

   /* The following loop was added in order to read PixelPaint files
      successfully.  Although technically an invalid PICT image, these files
      contain a series of NOP opcodes, followed by the version opcode.  In
      this case, we continue reading until the version opcode (non-zero
      value) is encountered, after which the checking continues. */
   do
   {
      /* read the first two bytes from the data stream - for PICT 1 this is
         both the opcode and version; for PICT 2 this is the opcode only. */
      GetWord( &versionCheck );

   } while ((versionCheck == NOP) && (ErGetGlobalError() == ErNoError));

   /* determine if a valid version opcode was encountered */
   if (versionCheck == Version1ID )
   {
      /* version 1 == 0x1101 */
      grafPort.portVersion = 1;
   }
   /* check for version 2 opcode which is a Word in length */
   else if (versionCheck == Version)
   {
      /* Since we have only read the opcode, read the next word which should
         contain the identifier for PICT 2 data. */
      GetWord( &versionCheck );
      if (versionCheck == Version2ID)
      {
         grafPort.portVersion = 2;

         /* make sure that the next record is a header opcode. */
         GetWord( &opcodeCheck );
         if (opcodeCheck == HeaderOp)
         {
            /* set up a record structure for call to TranslateOpcode(). */
            versionOpcode.function = HeaderOp;
            versionOpcode.length = 24;
            TranslateOpcode( &versionOpcode );
         }
         else
         {
            /* Header wasn't followed by correct Header opcode - error. */
            ErSetGlobalError( ErBadHeaderSequence );
         }
      }
      else
      {
         /* if version 2 identifier is invalid, return error state. */
         ErSetGlobalError( ErInvalidVersionID );
      }
   }
   else
   {
      /* if check for version 1 and 2 fails, return error state. */
      ErSetGlobalError( ErInvalidVersion );
   }

}  /* ReadPictVersion */




private void ReadOpcode( opcodeEntry far * nextOpcode )
/*---------------------*/
/* Reads the next opcode from the stream, depending on the PICT version */
{
   opcodeEntryLPtr   checkEntry;

   /* Initialize the function, since we may be reading a version 1 opcode
      that is only 1 byte in length. */
   nextOpcode->function = 0;

   /* Depending on the PICT version, we will read either a single byte
      or word for the opcode. */
   if (grafPort.portVersion == 1)
   {
      GetByte( (Byte far *)&nextOpcode->function );
   }
   else
   {
      GetWord( &nextOpcode->function );
   }

   /* check the current error code and force an exit from read loop if
      something went wrong. */
   if (ErGetGlobalError() != NOERR)
   {
      nextOpcode->function = opEndPic;
      nextOpcode->length = 0;
      return;
   }

   /* Check the opcode function number to determine if we can perform
      a direct lookup, or if the opcode is part of the range table. */
   if (nextOpcode->function < LookupTableSize )
   {
      nextOpcode->length = opcodeLookup[nextOpcode->function].length;
   }
   else
   {
      /* Walk through the range table to determine the data length of the
         ensuing information past the opcode. */
      for (checkEntry = opcodeRange;
           checkEntry->function < nextOpcode->function;
           checkEntry++) ;

      nextOpcode->length = checkEntry->length;
   }

}  /* ReadOpcode */


private void TranslateOpcode( opcodeEntry far * currOpcodeLPtr )
/*--------------------------*/
/* read in the remaining data from the stream, based upon the opcode function
   and then call the appropriate routine in Gdi module */
{
   Word  function = currOpcodeLPtr->function;

   /* perform appropriate action based on function code */
   switch (function)
   {
      case NOP:
         /* no data follows */
         break;

      case Clip:
      {
         Boolean  doClip = FALSE;

         /* read in clip region into grafPort */
         GetRegion( &grafPort.clipRgn );

         /* if in textmode, we need avoid clip regions, since they are used
            to draw Postscript encoded text *or* bitmap representations.
            We allow a clipping region to pass through only if it is being
            set to the bounds of the picture image (fix for MacDraw, Canvas,
            and SuperPaint images containing rotated text.) */
         if (textMode && textClipCheck)
         {
            Word far *  sizeLPtr;

            /* the most common case is a sequence of : null clip, text,
               non-null clip, bitmap.  If first clip == portRect, then
               we actually want to set the clip - doClip is set to TRUE. */
            sizeLPtr = (Word far *)GlobalLock( grafPort.clipRgn );
            doClip   = *sizeLPtr == RgnHeaderSize &&
                       EqualRect( (Rect far *)(sizeLPtr + 1), &grafPort.portRect );
            GlobalUnlock( grafPort.clipRgn );

            /* perform this check only once after initial picTextBegin */
            textClipCheck = FALSE;
         }

         /* issue the clip only if not in text mode, or a sanctioned clip */
         if (!textMode || doClip)
         {
            /* Call Gdi to set the new clip region */
            GdiSelectClipRegion( grafPort.clipRgn );
         }
         break;
      }

      case BkPat:
         /* flag the pixel map type a Foreground/Background pixel pattern */
         /* and read pattern into old data position */
         grafPort.bkPixPat.patType = QDOldPat;
         GetPattern( &grafPort.bkPixPat.pat1Data );

         /* Notify Gdi that background color may have changed */
         GdiMarkAsChanged( GdiBkPat );
         break;

      case TxFont:
         /* read text font index */
         GetWord( (Word far *)&grafPort.txFont );

         /* check if the font name was provided in previous opcode */
         if (!skipFontID)
         {
            /* Make sure that the font name is a null string */
            grafPort.txFontName[0] = cNULL;
         }

         /* Notify Gdi that text font index may have changed */
         GdiMarkAsChanged( GdiTxFont );
         break;

      case TxFace:
         /* read font attributes */
         GetByte( (Byte far *)&grafPort.txFace );

         /* Notify Gdi that text style elements may have changed */
         GdiMarkAsChanged( GdiTxFace );
         break;

      case TxMode:
         /* read text transfer mode */
         GetWord( (Word far *)&grafPort.txMode );

         /* Notify Gdi that text transfer mode may have changed */
         GdiMarkAsChanged( GdiTxMode );
         break;

      case SpExtra:
         /* read text space extra */
         GetFixed( (Fixed far *)&grafPort.spExtra );

         /* Notify Gdi that space extra may have changed */
         GdiMarkAsChanged( GdiSpExtra );
         break;

      case PnSize:
         /* read x and y components of pen size */
         GetPoint( (Point far *)&grafPort.pnSize );

         /* Notify Gdi that pen size may have changed */
         GdiMarkAsChanged( GdiPnSize );
         break;

      case PnMode:
         /* read pen transfer mode */
         GetWord( (Word far *)&grafPort.pnMode );

         /* Notify Gdi that transferm mode may have changed */
         GdiMarkAsChanged( GdiPnMode );
         break;

      case PnPat:
         /* flag the pixel map type a Foreground/Background pixel pattern */
         /* and read pattern into old data position */
         grafPort.pnPixPat.patType = QDOldPat;
         GetPattern( &grafPort.pnPixPat.pat1Data );

         /* Notify Gdi that pen pattern may have changed */
         GdiMarkAsChanged( GdiPnPat );
         break;

      case FillPat:
         /* flag the pixel map type a Foreground/Background pixel pattern */
         /* and read pattern into old data position */
         grafPort.fillPixPat.patType = QDOldPat;
         GetPattern( &grafPort.fillPixPat.pat1Data );

         /* Notify Gdi that fill pattern may have changed */
         GdiMarkAsChanged( GdiFillPat );
         break;

      case OvSize:
         /* save point in new grafPort field */
         GetPoint( &saveOvalSize );
         break;

      case Origin:
      {
         Point    offset;

         /* read the new origin in to the upper-left coordinate space */
         GetWord( (Word far *)&offset.x );
         GetWord( (Word far *)&offset.y );

         /* call gdi module to reset the origin */
         GdiOffsetOrigin( offset );
         break;
      }

      case TxSize:
         GetWord( (Word far *)&grafPort.txSize );

         /* Notify Gdi that text size may have changed */
         GdiMarkAsChanged( GdiTxSize );
         break;

      case FgColor:
         GetOctochromeColor( &grafPort.rgbFgColor );

         /* Notify Gdi that foreground color may have changed */
         GdiMarkAsChanged( GdiFgColor );
         break;

      case BkColor:
         GetOctochromeColor( &grafPort.rgbBkColor );

         /* Notify Gdi that background color may have changed */
         GdiMarkAsChanged( GdiBkColor );
         break;

      case TxRatio:
         /* save the numerator and denominator in the grafPort */
         GetPoint( &grafPort.txNumerator );
         GetPoint( &grafPort.txDenominator );

         /* Notify Gdi that text ratio may have changed */
         GdiMarkAsChanged( GdiTxRatio );
         break;

      case Version:
         /* just skip over the version information */
         IOSkipBytes( currOpcodeLPtr->length );
         break;

      case BkPixPat:
         GetPixPattern( &grafPort.bkPixPat );

         /* Notify Gdi that background pattern may have changed */
         GdiMarkAsChanged( GdiBkPat );
         break;

      case PnPixPat:
         GetPixPattern( &grafPort.pnPixPat );

         /* Notify Gdi that pen pattern may have changed */
         GdiMarkAsChanged( GdiPnPat );
         break;

      case FillPixPat:
         GetPixPattern( &grafPort.fillPixPat );

         /* Notify Gdi that fill pattern may have changed */
         GdiMarkAsChanged( GdiFillPat );
         break;

      case PnLocHFrac:
         GetWord( (Word far *)&grafPort.pnLocHFrac );
         break;

      case ChExtra:
         GetWord( (Word far *)&grafPort.chExtra );

         /* Notify Gdi that text character extra may have changed */
         GdiMarkAsChanged( GdiChExtra );
         break;

      case RGBFgCol:
         GetRGBColor( &grafPort.rgbFgColor );

         /* Notify Gdi that foregroudn color may have changed */
         GdiMarkAsChanged( GdiFgColor );
         break;

      case RGBBkCol:
         GetRGBColor( &grafPort.rgbBkColor );

         /* Notify Gdi that background color may have changed */
         GdiMarkAsChanged( GdiBkColor );
         break;

      case HiliteMode:
         /* don't do anything for hilite mode */
         break;

      case HiliteColor:
      {
         RGBColor    rgbUnused;

         GetRGBColor( &rgbUnused );
         break;

      }

      case DefHilite:
         /* don't do anything for hilite */
         break;

      case OpColor:
      {
         RGBColor    rgbUnused;

         GetRGBColor( &rgbUnused );
         break;
      }

      case Line:
      case LineFrom:
      case ShortLine:
      case ShortLineFrom:
      {
         Point          newPt;
         SignedByte     deltaX;
         SignedByte     deltaY;

         /* see if we need to read the updated pen location first */
         if (function == ShortLine || function == Line)
         {
            /* read in the new pen location */
            GetCoordinate( &grafPort.pnLoc );
         }

         /* determine what the next data record contains */
         if (function == Line || function == LineFrom)
         {
            /* get the new coordinate to draw to */
            GetCoordinate( &newPt );
         }
         else /* if (function == ShortLine || function == ShortLineFrom) */
         {
            /* the the new x and y deltas */
            GetByte( &deltaX );
            GetByte( &deltaY );

            /* calculate the endpoint for call to gdi */
            newPt.x = grafPort.pnLoc.x + (Integer)deltaX;
            newPt.y = grafPort.pnLoc.y + (Integer)deltaY;
         }

         /* check if buffering line segments (polygon mode != FALSE) */
         if (polyMode)
         {
            /* add the line segment to the polygon buffer */
            AddPolySegment( grafPort.pnLoc, newPt );
         }
         else
         {
            /* Call Gdi to draw line */
            GdiLineTo( newPt );
         }

         /* update the new pen location in the grafPort */
         grafPort.pnLoc = newPt;
         break;
      }

      case LongText:
      {
         Str255   txString;
         Point    location;

         /* read the new pen (baseline) location */
         GetCoordinate( &grafPort.txLoc );
         GetString( (StringLPtr)txString );

         /* adjust for any text rotation that may be set */
         location = grafPort.txLoc;
         AdjustTextRotation( &location );

         /* call Gdi to print the text at current pen location */
         GdiTextOut( txString, location );
         break;
      }

      case DHText:
      case DVText:
      case DHDVText:
      {
         Byte     deltaX = 0;
         Byte     deltaY = 0;
         Str255   txString;
         Point    location;

         /* if command is DHText or DHDVText, read horizontal offset */
         if (function != DVText)
         {
            GetByte( &deltaX );
         }

         /* if command is DVText or DHDVText, then read the vertical offset */
         if (function != DHText)
         {
            GetByte( &deltaY );
         }

         /* update the current pen postion */
         grafPort.txLoc.x += deltaX;
         grafPort.txLoc.y += deltaY;

         /* now read in the string */
         GetString( (StringLPtr)txString );

         /* adjust for any text rotation that may be set */
         location = grafPort.txLoc;
         AdjustTextRotation( &location );

         /* call Gdi to print the text at current pen location */
         GdiTextOut( txString, location );
         break;
      }

      case FontName:
      {
         Word           dataLen;

         GetWord( (Word far *)&dataLen );
         GetWord( (Word far *)&grafPort.txFont );
         GetString( grafPort.txFontName );

         /* Notify Gdi that font name may have changed */
         GdiMarkAsChanged( GdiTxFont );
         break;
      }

      case LineJustify:
      {
         Word           dataLen;
         Fixed          interCharSpacing;
         Fixed          textExtra;

         GetWord( (Word far *)&dataLen );
         GetFixed( &interCharSpacing );      // !!! where to put this ?
         GetFixed( &textExtra );

         /* Notify Gdi that line justification may have changed */
         GdiMarkAsChanged( GdiLineJustify );
         break;
      }


      case frameRect:
      case paintRect:
      case eraseRect:
      case invertRect:
      case fillRect:
      {
         /* read in the rectangle */
         GetRect( &saveRect );

         /* call the correct GDI routine */
         GdiRectangle( function - frameRect, saveRect );
         break;
      }

      case frameSameRect:
      case paintSameRect:
      case eraseSameRect:
      case invertSameRect:
      case fillSameRect:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call the correct gdi routine using last rectangle coords */
         GdiRectangle( function - frameSameRect, saveRect );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameRRect:
      case paintRRect:
      case eraseRRect:
      case invertRRect:
      case fillRRect:
      {
         /* save the rectangle */
         GetRect( &saveRRect );

         /* call the correct gdi routine using last rectangle coords */
         GdiRoundRect( function - frameRRect, saveRRect, saveOvalSize );
         break;
      }

      case frameSameRRect:
      case paintSameRRect:
      case eraseSameRRect:
      case invertSameRRect:
      case fillSameRRect:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call the correct gdi routine using last rectangle coords */
         GdiRoundRect( function - frameSameRRect, saveRRect, saveOvalSize );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameOval:
      case paintOval:
      case eraseOval:
      case invertOval:
      case fillOval:
      {
         /* save off bounding rectangle */
         GetRect( &saveOval );

         /* call the correct gdi routine using last oval coords */
         GdiOval( function - frameOval, saveOval );
         break;
      }

      case frameSameOval:
      case paintSameOval:
      case eraseSameOval:
      case invertSameOval:
      case fillSameOval:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call the correct gdi routine using last oval coords */
         GdiOval( function - frameSameOval, saveOval );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameArc:
      case paintArc:
      case eraseArc:
      case invertArc:
      case fillArc:
      {
         /* read rect into the save variables, new start and arc angles */
         GetRect( &saveArc );
         GetWord( (Word far *)&saveStartAngle );
         GetWord( (Word far *)&saveArcAngle );
#ifdef WIN32
         /* have to extend the sign because GetWord doesn't */
         saveStartAngle = (short)saveStartAngle;
         saveArcAngle = (short)saveArcAngle;
#endif
         /* call the correct gdi routine using last arc angles */
         GdiArc( function - frameArc, saveArc, saveStartAngle, saveArcAngle );
         break;
      }

      case frameSameArc:
      case paintSameArc:
      case eraseSameArc:
      case invertSameArc:
      case fillSameArc:
      {
         Integer     startAngle;
         Integer     arcAngle;

         /* read new start and arc angles */
         GetWord( (Word far *)&startAngle );
         GetWord( (Word far *)&arcAngle );
#ifdef WIN32
         /* have to extend the sign because GetWord doesn't */
         startAngle = (short)startAngle;
         arcAngle = (short)arcAngle;
#endif

         /* notify gdi that this is the may be the same primitive */
         GdiSamePrimitive( (startAngle == saveStartAngle) &&
                           (arcAngle   == saveArcAngle) );

         /* save off the start and arc angles */
         saveStartAngle = startAngle;
         saveArcAngle   = arcAngle;

         /* call the correct gdi routine using last rect and arc angles */
         GdiArc( function - frameSameArc, saveArc, startAngle, arcAngle );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case framePoly:
      case paintPoly:
      case erasePoly:
      case invertPoly:
      case fillPoly:
      {
         /* save the polygon in the grafPort */
         GdiSamePrimitive( GetPolygon( &grafPort.polySave, (function == framePoly) ) );

         /* call gdi routine to draw polygon */
         if (grafPort.polySave) 
	 {
	    GdiPolygon( function - framePoly, grafPort.polySave );
	    
	    /* turn off filling while in polygon mode */
	    polyParams &= ~FILLREQUIRED;
   
	    /* notify gdi that this is no longer the same primitive */
	    GdiSamePrimitive( FALSE );
	 }

         break;
      }

      case frameSamePoly:
      case paintSamePoly:
      case eraseSamePoly:
      case invertSamePoly:
      case fillSamePoly:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call gdi routine to draw polygon */
         GdiPolygon( function - frameSamePoly, grafPort.polySave );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameRgn:
      case paintRgn:
      case eraseRgn:
      case invertRgn:
      case fillRgn:
      {
         /* save the region in the grafPort */
         GetRegion( &grafPort.rgnSave );

         /* check for memory failure; GetRegion will set ErGetGlobalError */
         if (!grafPort.rgnSave)
             break;

         /* if in polygon mode and a fillRgn is encountered, this indicates
            that the polygon should be filled once parsing is completed */
         if (polyMode == PARSEPOLY)
         {
            /* make sure that a PaintPoly() hasn't been handled already */
            if (!(polyParams & (FILLPOLY | FILLREQUIRED)))
            {
               /* set flags to fill polygon once polygon buffer is filled */
               polyParams |= FILLPOLY | FILLREQUIRED;
            }
         }
         else if (polyMode == FALSE ||
                ((polyMode == USEALTPOLY) && !(polyParams & FRAMEPOLY)))
         {
            /* call gdi routine to draw polygon */
            GdiRegion( function - frameRgn, grafPort.rgnSave );

            /* make sure that the polygon isn't filled when the simulation
               buffer is drawn at the end of the polygon definition */
            polyParams &= ~FILLREQUIRED;
         }

         /* save off the current fore- and background colors for
            polygon simulation routine to ensure correct fill colors */
         if (polyMode && (grafPort.fillPixPat.patType == QDOldPat))
         {
            polyFgColor = grafPort.rgbFgColor;
            polyBkColor = grafPort.rgbBkColor;
         }

         break;
      }

      case frameSameRgn:
      case paintSameRgn:
      case eraseSameRgn:
      case invertSameRgn:
      case fillSameRgn:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call gdi routine to draw polygon */
         GdiRegion( function - frameSameRgn, grafPort.rgnSave );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case BitsRect:
      case BitsRgn:
      case PackBitsRect:
      case PackBitsRgn:
      case DirectBitsRect:
      case DirectBitsRgn:
      {
         Boolean     has24bits;
         Boolean     hasRegion;
         Rect        srcRect;
         Rect        dstRect;
         Word        mode;
         PixMap      pixMap;
         Handle      pixData;
         DWord       unusedBaseAddr;
         RgnHandle   rgn;

         /* determine which type of bitmap we are reading */
         has24bits = (function == DirectBitsRect ||
                      function == DirectBitsRgn);
         hasRegion = (function == DirectBitsRgn ||
                      function == BitsRgn ||
                      function == PackBitsRgn);

         /* currently there is no region created */
         rgn = NULL;

         /* if 24-bit, read in the base address which should == 0x000000FF */
         if (has24bits)
         {
            GetDWord( &unusedBaseAddr );
         }

         /* read in the header structure */
         GetPixMap( &pixMap, FALSE );

         /* if this isn't an 24-bit RGB bitmap, read in the color table.
            Also check the rowBytes field to signify bitmap w/2 colors */
         if (!has24bits && (pixMap.rowBytes & PixelMapBit))
         {
            GetColorTable( &pixMap.pmTable );
         }

         /* call io module to update status indicator */
         IOUpdateStatus();

         /* read source and destination rects from stream */
         GetRect( &srcRect );
         GetRect( &dstRect );
         GetWord( &mode );

         /* if there is a region included, read this also */
         if (hasRegion)
         {
            /* read in the region */
            GetRegion( &rgn );
         }

         /* read the pixel bit data */
         GetPixData( &pixMap, &pixData );

         if (ErGetGlobalError() == NOERR && !textMode)
         {
            /* Call Gdi to render the bitmap and de-allocate the memory */
            GdiStretchDIBits( &pixMap, pixData, srcRect, dstRect, mode, rgn );
         }
         else
         {
            /* deallocate any memory that may be allocated */
            if (pixMap.pmTable != NULL)
            {
               GlobalFree( pixMap.pmTable );
            }
            if (hasRegion && (rgn != NULL))
            {
               GlobalFree( rgn );
            }
            if (pixData != NULL)
            {
               GlobalFree( pixData );
            }
         }
         break;
      }

      case ShortComment:
      {
         Word           comment;
         Boolean        doComment;
         Comment        gdiComment;

         /* get the comment word */
         GetWord( &comment );

         /* assume that we won't be generating an metafile comment */
         doComment = FALSE;

         /* determine the corresponding GDI comment for the comment */
         switch (comment)
         {
            case picPostScriptBegin:
            case picPostScriptEnd:
               EPSComment(comment);
               break;

            case picLParen:
            case picGrpBeg:
               doComment = TRUE;
               gdiComment.function = BEGIN_GROUP;
               break;

            case picRParen:
            case picGrpEnd:
               doComment = TRUE;
               gdiComment.function = END_GROUP;
               break;

            case picBitBeg:
               doComment = TRUE;
               gdiComment.function = BEGIN_BANDING;
               break;

            case picBitEnd:
               doComment = TRUE;
               gdiComment.function = END_BANDING;
               break;

            case picPolyBegin:
               /* indicate that we are in polygon mode, and reset buffer */
               polyMode = PARSEPOLY;
               polyParams = FRAMEPOLY;
               NewPolygon();
               break;

            case picPolyEnd:
               /* flush the polygon buffer and exit polygon mode */
               DrawPolyBuffer();
               polyMode = FALSE;
               break;

            case picPolyIgnore:
               /* see if we should reset the polygon buffer */
               if (polyMode == USEALTPOLY)
               {
                  /* use the alternate polygon definition to draw */
                  NewPolygon();
               }
               else
               {
                  /* otherwise, just use the current saved polygon buffer */
                  polyMode = SKIPALTPOLY;
               }
               break;

            case picTextEnd:
               /* set the global flag indicating we are exiting text mode */
               grafPort.txRotation = 0;
               grafPort.txFlip = QDFlipNone;
               textMode = FALSE;
               break;

            default:
               break;
         }

         /* if there is some comment to emit, then call GDI module */
         if (doComment)
         {
            /* make this a public comment */
            gdiComment.signature = PUBLIC;
            gdiComment.size = 0;

            /* call the gdi entry point */
            GdiShortComment( &gdiComment );
         }

         break;
      }

      case LongComment:
      {
         Word           comment;
         Integer        length;

         /* get the comment function */
         GetWord(&comment);

         /* determine what should be done with the comment */
         switch (comment)
         {
            case picPostScriptBegin:
            case picPostScriptEnd:
            case picPostScriptHandle:
            {
               if (EPSComment(comment) == 0)      /* not EPS? */
               {
                  GetWord( &length );             /* skip it */
               }
               else
               {
                  length = 0;                     /* EPS was already read */
               }
               break;
            }

            case picPolySmooth:
            {
               /* read the total length of comment */
               GetWord( &length );

               /* read polygon parameter mask and set flag bits */
               GetByte( &polyParams );
               polyParams &= MASKPOLYBITS;
               polyParams |= CHECK4SPLINE;
               length--;

               /* if we are to fill the polygon, indicate that fill required
                  just in case a PaintPoly() record appears before picPolyEnd */
               if (polyParams & FILLPOLY)
               {
                  /* or in the fill required bit */
                  polyParams |= FILLREQUIRED;
               }
               break;
            }

            case picTextBegin:
            {
               Byte  unusedAlignment;

               /* read the comment length */
               GetWord( &length );

               /* read in only relevant parameters - align, flip, rotation */
               GetByte( &unusedAlignment );
               GetByte( &grafPort.txFlip );
               GetWord( &grafPort.txRotation );
               length -= 4;

               /* set the global flag indicating we are in text mode.  The
                  only case this isn't true if for badly mangled SuperPaint
                  files that have invalid rotation and pt size information. */
               if( !(superPaintFile && badSuperPaintText) )
               {
                  textMode = TRUE;
                  textClipCheck = TRUE;
               }
               break;
            }

            case picTextCenter:
            {
               Fixed    textCenterX;
               Fixed    textCenterY;

               /* read the comment length */
               GetWord( &length );

               /* read y and x offsets to center of text rotation */
               GetFixed( &textCenterY );
               GetFixed( &textCenterX );
               length -= 8;

               /* copy only the highword of the fixed value to textCenter */
               textCenter.x = (short) (HIWORD( textCenterX ));
               textCenter.y = (short) (HIWORD( textCenterY ));

               /* make sure that the center is rounded, not truncated */
               if (LOWORD( textCenterX) & 0x8000)
                  textCenter.x++;

               if (LOWORD( textCenterY) & 0x8000)
                  textCenter.y++;

               /* indicate that text center needs to be re-computed */
               newTextCenter = TRUE;
               break;
            }

            case picAppComment:
            {
               DWord    signature;
               Word     function;
               Word     realFunc;

               /* read total comment length */
               GetWord( &length );

               /* make sure that there's enough space to read signature */
               if (length < sizeofMacDWord )
               {
                  /* if insufficient, just skip remaining data */
                  break;
               }

               /* read the signature of the application */
               GetDWord( &signature );
               length -= sizeofMacDWord ;

               /* is this PowerPoint 'PPNT' signature and function size enough? */
               if ((signature != POWERPOINT && signature != POWERPOINT_OLD) ||
                   (length < sizeofMacWord ))
               {
                  /* if SuperPaint signature matches, flag for text checks */
                  if (signature == SUPERPAINT)
                     superPaintFile = TRUE;

                  /* if wrong signature, or insufficient space, bail */
                  break;
               }

               /* read the application function ID */
               GetWord( &function );
               length -= sizeofMacWord ;

               /* mask out high-order bit to get "real" opcode */
               realFunc = function & ~PC_REGISTERED;

               /* determine what to do with the function specified */
               switch (realFunc)
               {
                  case PP_FONTNAME:
                  {
                     Byte     fontFamily;
                     Byte     charSet;
                     Byte     fontName[32];

                     /* font name from GDI2QD - read the LOGFONT info */
                     GetByte( &fontFamily );
                     GetByte( &charSet );
                     GetString( fontName );
                     length = 0;

                     /* call Gdi module to override font selection */
                     GdiFontName( fontFamily, charSet, fontName );
                     break;
                  }

                  case PP_HATCHPATTERN:
                  {
                     Integer  hatchIndex;

                     /* hatch pattern from GDI2QD - read hatch index value */
                     GetWord( (Word far *)&hatchIndex );
                     length = 0;

                     /* notify Gdi module of hatch to override fill pattern */
                     GdiHatchPattern( hatchIndex );
                     break;
                  }

                  case PP_BEGINFADE:
                  case PP_BEGINPICTURE:
                  case PP_DEVINFO:
                  {
                     DWord    cmntSize;
                     Boolean  doComment;

                     struct
                     {
                        Comment  gdiComment;
                        union
                        {
                           struct
                           {
                              Byte     version;
                              Boolean  isShape;
                              Integer  shapeIndex;
                              Integer  shapeParam1;
                              Boolean  olpNIL;
                              Rect     orectDR;
                              Rect     orect;
                              Word     shape;
                              Integer  shapeParam2;
                              Rect     location;
                              Integer  gradient;
                              Boolean  fromBackground;
                              Boolean  darker;
                              Integer  arcStart;
                              Integer  arcSweep;
                              Word     backR;
                              Word     backG;
                              Word     backB;
                              Rect     rSImage;
                           } fade;

                           Word        entity;

                           Point       unitsPerPixel;

                        } parm;

                     } cmnt;

#ifdef WIN32
                     memset( &cmnt, 0, sizeof( cmnt ));
#endif

                     /* so far, we won't be writting the Escape comment */
                     doComment = FALSE;

                     /* can we read the comment size? */
                     if (length < sizeofMacDWord )
                     {
                        /* couldn't read the size - just exit */
                        break;
                     }

                     /* read in a size field and validate */
                     GetDWord( &cmntSize );
                     length -= sizeofMacDWord ;

                     /* is this is an invalid PP3 size field (Word len) */
                     if (HIWORD( cmntSize ) != 0)
                     {
                        /* yes - just skip the remaining data */
                        break;
                     }

                     /* a valid comment was found - fill in header struct */
                     cmnt.gdiComment.signature = POWERPOINT;
                     cmnt.gdiComment.function = function;
                     cmnt.gdiComment.size = 0;

                     /* check if this is a zero-length comment */
                     if (cmntSize == 0)
                     {
                        /* make sure that the comment gets written */
                        doComment = TRUE;
                     }
                     /* process the begin fade comment */
                     else if (realFunc == PP_BEGINFADE)
                     {
                        /* can we read the version field? */
                        if (length < sizeof( Byte ))
                        {
                           /* can't read version - just bail */
                           break;
                        }

                        /* read the version field */
                        GetByte( &cmnt.parm.fade.version );
                        length -= sizeof( Byte );

                        /* if this is version 1 or 2, copy the bytes */
                        if (cmnt.parm.fade.version == 1 || cmnt.parm.fade.version == 2)
                        {
                           Handle         cmntHandle;
                           Comment far *  cmntLPtr;
                           Byte far *     cmntDataLPtr;
                           DWord          escapeSize;
                           Word           i;

                           /* determine size and allocate the required buffer */
                           escapeSize = cmntSize + sizeof( Comment );
                           cmntHandle = GlobalAlloc( GHND, escapeSize );

                           /* make sure allocation succeeded */
                           if (cmntHandle == NULL)
                           {
                              ErSetGlobalError( ErMemoryFull );
                              break;
                           }

                           /* lock the buffer and assign the comment header */
                           cmntLPtr = (Comment far *)GlobalLock( cmntHandle );

                           /* set the correct signature and parameters */
                           cmntLPtr->signature = POWERPOINT;
                           cmntLPtr->function = function;
                           cmntLPtr->size = cmntSize;

                           /* get pointer to the data and assign the version */
                           cmntDataLPtr = ((Byte far *)cmntLPtr) + sizeof( Comment );
                           *cmntDataLPtr++ = cmnt.parm.fade.version;

                           /* copy the byte over - start at 1 for version read */
                           for (i = 1; i < (Word)cmntSize; i++)
                           {
                              /* copy over byte and increment pointer */
                              GetByte( cmntDataLPtr++ );
                           }

                           /* put the comment into the metafile */
                           GdiEscape( MFCOMMENT, (Word)escapeSize, (StringLPtr)cmntLPtr );

                           /* release the memory allocated for the structure */
                           GlobalUnlock( cmntHandle );
                           GlobalFree( cmntHandle );
                        }
                        /* otherwise, perform swapping for PP3 fade */
                        else if (cmnt.parm.fade.version == 3)
                        {
                           Word     unusedWord;

                           if (length < ( 1 + (11 * sizeofMacWord) +
                                              ( 4 * sizeofMacRect) + 4
                                        ))
                           /* The above magic numbers come from:
                              GetByte
                              GetWord GetWord GetWord GetWord GetWord GetWord
                              GetWord GetWord GetWord GetWord GetWord
                              GetRect GetRect GetRect GetRect
                              GetBoolean GetBoolean GetBoolean GetBoolean
                              This is to make sure enough input left for
                              parameters - note that the Mac size is one less
                              than the GDI fade */
                           {
                              /* no - just bail */
                              break;
                           }

                           /* read in all remaining parameters */
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.isShape) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shapeIndex) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shapeParam1) );
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.olpNIL) );
                           GetByte( (Byte far *)(&unusedWord) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.orectDR) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.orect) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shape) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shapeParam2) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.location) );
                           GetWord( (Word far *)(&cmnt.parm.fade.gradient) );
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.fromBackground) );
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.darker ) );
                           GetWord( (Word far *)(&cmnt.parm.fade.arcStart) );
                           GetWord( (Word far *)(&cmnt.parm.fade.arcSweep) );
                           GetWord( (Word far *)(&unusedWord) );
                           GetWord( (Word far *)(&cmnt.parm.fade.backR) );
                           GetWord( (Word far *)(&cmnt.parm.fade.backG) );
                           GetWord( (Word far *)(&cmnt.parm.fade.backB) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.rSImage) );

                           /* determine the comment size */
                           cmnt.gdiComment.size = sizeof( cmnt.parm.fade );

                           /* make sure comment gets written */
                           doComment = TRUE;
                        }

                        /* no more bytes to read, flag that faded object started */
                        length = 0;
                        shadedObjectStarted = TRUE;
                     }
                     else if (realFunc == PP_BEGINPICTURE)
                     {
                        /* can we read the entity reference? */
                        if (length < sizeofMacWord )
                        {
                           /* no - just bail */
                           break;
                        }

                        /* read the entity reference */
                        GetWord( &cmnt.parm.entity );
                        length -= sizeofMacWord;

                        /* assign the correct comment size */
                        cmnt.gdiComment.size = sizeof( cmnt.parm.entity );

                        /* make sure comment gets written */
                        doComment = TRUE;
                     }
                     else if (realFunc == PP_DEVINFO)
                     {
                        /* can we read the units per pixel? */
                        if (length < sizeofMacPoint)
                        {
                           /* no - just bail */
                           break;
                        }

                        /* read the units per pixel */
                        GetPoint( (Point far *)&cmnt.parm.unitsPerPixel );
                        length -= sizeofMacPoint;

                        /* assign the size field */
                        cmnt.gdiComment.size = sizeof( cmnt.parm.unitsPerPixel );

                        /* make sure comment gets written */
                        doComment = TRUE;
                     }

                     /* write out the Gdi Escape comment */
                     if (doComment)
                     {
                        /* call the gdi entry point */
                        GdiEscape( MFCOMMENT, sizeof( Comment ) + (Word)cmnt.gdiComment.size, (StringLPtr)&cmnt );
                     }
                     break;
                  }

                  case PP_ENDFADE:
                  {
                     /* make sure that the BEGINFADE was put into metafile */
                     if (!shadedObjectStarted)
                     {
                        /* if not, then bail out */
                        break;
                     }
                     /* otherwise, just drop into the next case statement */
                  }

                  case PP_ENDPICTURE:
                  {
                     Comment     gdiComment;

                     /* make this a private PowerPoint comment */
                     gdiComment.signature = POWERPOINT;
                     gdiComment.function = function;
                     gdiComment.size = 0;

                     /* call the gdi entry point */
                     GdiShortComment( &gdiComment );

                     /* if this is the end of fade, mask out flag check */
                     if (realFunc == PP_ENDFADE)
                     {
                        /* end fade was processed successfully */
                        shadedObjectStarted = FALSE;
                     }
                     break;
                  }

                  default:
                     break;
               }
               break;
            }

            default:
            {
               /* any other comment is just skipped */
               GetWord( &length );
               break;
            }
         }

         /* skip any remaining bytes to be read */
         IOSkipBytes( length );
         break;
      }

      case opEndPic:
         /* do nothing - picture is closing */
         break;

      case HeaderOp:
      {
         Integer     version;
         Word        unusedReserved1;
         Fixed       hRes;
         Fixed       vRes;
         Rect        unusedRect;
         DWord       unusedReserved2;

         /* read in the the version to determine if OpenCPort() was used
            to open the picture, thus containing spatial resoultion info. */
         GetWord( (Word far *)&version );

         /* read any other parameters - will check later if they are valid.
            If version == -1, we are reading over the bounding rectangle. */
         GetWord( &unusedReserved1 );
         GetFixed( &hRes );
         GetFixed( &vRes );

         /* check if bounding rect and spatial resolution are changed */
         if (version == -2)
         {
            /* read in the optimal source rectangle */
            GetRect( &grafPort.portRect );

            /* use the integer portion of hRes for the resolution dpi */
            resolution = HIWORD( hRes );
         }
         else
         {
            /* otherwise, read an unused rectangle coordinate pair */
            GetRect( &unusedRect );
         }

         /* read the trailing unused reserved LongInt */
         GetDWord( &unusedReserved2 );

         break;
      }

      default:
         SkipData( currOpcodeLPtr );
         break;
   }

   /* set flag to skip ensuing font index if font name was provided */
   skipFontID = (currOpcodeLPtr->function == FontName);

   /* if global error, set opcode to opEndPic to exit main loop */
   if (ErGetGlobalError() != NOERR)
   {
      currOpcodeLPtr->function = opEndPic;
      currOpcodeLPtr->length = 0;
   }

}  /* TranslateOpcode */



private void SkipData( opcodeEntry far * currOpcodeLPtr )
/*-------------------*/
/* skip the data - the opcode won't be translated and Gdi module won't be
   called to create anything in the metafile */
{
   LongInt     readLength = 0;

   if (currOpcodeLPtr->length >= 0)
   {
      IOSkipBytes( currOpcodeLPtr->length );
   }
   else
   {
      readLength = 0;

      switch (currOpcodeLPtr->length)
      {
         case CommentSize:
         {
            Word  unusedFunction;

            GetWord( (Word far *)&unusedFunction );
            GetWord( (Word far *)&readLength );
            break;
         }

         case RgnOrPolyLen:
         {
            GetWord( (Word far *)&readLength );
            readLength -= 2;
            break;
         }

         case WordDataLen:
         {
            GetWord( (Word far *)&readLength );
            break;
         }

         case DWordDataLen:
         {
            GetDWord( (DWord far *)&readLength );
            break;
         }

         case HiByteLen:
         {
            readLength = (currOpcodeLPtr->function >> 8) * 2;
            break;
         }

      }  /* switch () */

      IOSkipBytes( readLength );

   }  /* else */

}  /* SkipData */



void OpenPort( void )
/*-----------*/
/* initialize the grafPort */
{
   /* set port version to unintialized state */
   grafPort.portVersion = 0;

   /* no polygons or regions saved yet */
   grafPort.clipRgn  = NIL;
   grafPort.rgnSave  = NIL;
   grafPort.polySave = NIL;

   /* initialize all patterns to old-style patterns */
   grafPort.bkPixPat.patType   = QDOldPat;
   grafPort.pnPixPat.patType   = QDOldPat;
   grafPort.fillPixPat.patType = QDOldPat;

   /* make patterns all solid */
   QDCopyBytes( (Byte far *)&SolidPattern,
                (Byte far *)&grafPort.bkPixPat.pat1Data, sizeof( Pattern ) );
   QDCopyBytes( (Byte far *)&SolidPattern,
                (Byte far *)&grafPort.pnPixPat.pat1Data, sizeof( Pattern ) );
   QDCopyBytes( (Byte far *)&SolidPattern,
                (Byte far *)&grafPort.fillPixPat.pat1Data, sizeof( Pattern ) );

   /* foreground/background set to black on white */
   grafPort.rgbFgColor  = RGB( 0x00, 0x00, 0x00 );    /* black */
   grafPort.rgbBkColor  = RGB( 0xFF, 0xFF, 0xFF );    /* white */

   /* various pen attributes */
   grafPort.pnLoc.x     = 0;                 /* pen location (0,0) */
   grafPort.pnLoc.y     = 0;
   grafPort.pnSize.x    = 1;                 /* pen size (1,1) */
   grafPort.pnSize.y    = 1;
   grafPort.pnVis       = 0;                 /* pen is visible */
   grafPort.pnMode      = QDPatCopy;         /* copy ROP */
   grafPort.pnLocHFrac  = 0x00008000;        /* 1/2 */

   /* font attributes */
   grafPort.txFont      = 0;                 /* system font */
   grafPort.txFace      = 0;                 /* plain style */
   grafPort.txMode      = QDSrcOr;
   grafPort.txSize      = 0;                 /* system font size */
   grafPort.spExtra     = 0;
   grafPort.chExtra     = 0;
   grafPort.txNumerator.x =                  /* text scaling ratio */
   grafPort.txNumerator.y =
   grafPort.txDenominator.x =
   grafPort.txDenominator.y = 1;
   grafPort.txRotation = 0;                  /* no rotation or flipping */
   grafPort.txFlip     = QDFlipNone;

   /* assume 72 dpi - this may be overridden in HeaderOp opcode */
   resolution = 72;

   /* private global initialization */
   polyMode = FALSE;
   textMode = FALSE;
   shadedObjectStarted = FALSE;
   superPaintFile = FALSE;

   /* text rotation variables */
   newTextCenter = FALSE;
   textCenter.x = textCenter.y = 0;

   /* allocate space for the polygon buffer */
   maxPoints = 16;
   polyHandle = GlobalAlloc( GHND, (maxPoints + 3) * sizeof( Point ) );
   if (polyHandle == NULL)
   {
      ErSetGlobalError( ErMemoryFull);
   }
   else
   {
      /* get pointer address and address for the polygon coordinate list */
      numPointsLPtr = (Integer far *)GlobalLock( polyHandle );
      polyListLPtr = (Point far *)(numPointsLPtr + POLYLIST);
   }

}  /* OpenPort */


private void ClosePort( void )
/*--------------------*/
/* close grafPort and de-allocate any memory blocks */
{
   if (grafPort.clipRgn != NULL)
   {
      GlobalFree( grafPort.clipRgn );
      grafPort.clipRgn = NULL;
   }

   if (grafPort.rgnSave != NULL)
   {
      GlobalFree( grafPort.rgnSave );
      grafPort.rgnSave = NULL;
   }

   if (grafPort.polySave != NULL)
   {
      GlobalFree( grafPort.polySave );
      grafPort.polySave = NULL;
   }

   /* make sure that all the possible pixel pattern bitmaps are freed */
   if (grafPort.bkPixPat.patData != NULL)
   {
      GlobalFree( grafPort.bkPixPat.patMap.pmTable );
      GlobalFree( grafPort.bkPixPat.patData );
      grafPort.bkPixPat.patData = NULL;
   }

   if (grafPort.pnPixPat.patData != NULL)
   {
      GlobalFree( grafPort.pnPixPat.patMap.pmTable );
      GlobalFree( grafPort.pnPixPat.patData );
      grafPort.pnPixPat.patData = NULL;
   }

   if (grafPort.fillPixPat.patData != NULL)
   {
      GlobalFree( grafPort.fillPixPat.patMap.pmTable );
      GlobalFree( grafPort.fillPixPat.patData );
      grafPort.fillPixPat.patData = NULL;
   }

   /* deallocate the polygon buffer */
   GlobalUnlock( polyHandle );
   GlobalFree( polyHandle );

}  /* ClosePort */


private void NewPolygon( void )
/*---------------------*/
/* initialize the state of the polygon buffer - flush any previous data */
{
   /* initialize number of points and bounding box */
   numPoints = 0;
   polyBBox.left  = polyBBox.top    =  MAXINT;
   polyBBox.right = polyBBox.bottom = -MAXINT;

}  /* NewPolygon */


private void AddPolySegment( Point start, Point end )
/*-------------------------*/
/* Add the line segment to the polygon buffer */
{
	HANDLE tmpHandle;
	
   /* make sure that we are in polygon mode before adding vertex */
   if (polyMode == PARSEPOLY || polyMode == USEALTPOLY)
   {
      Point    pt;
      Byte     i;

      /* loop through both points ... */
      for (i = 0; i < 2; i++)
      {
         /* determine which point to process */
         pt = (i == 0) ? start : end;

         /* determine if we should expect a zero delta increment in both
            dimensions, implying that the quadratic B-spline definition will
            actually be rendered as a straight-edged polygon */
         if ((numPoints <= 1) || (polyMode == USEALTPOLY))
         {
            zeroDeltaExpected = FALSE;
         }

         /* check if we are expecting a zero delta from last point */
         if (zeroDeltaExpected && (polyParams & CHECK4SPLINE))
         {
            /* make sure we are adding a zero-length line segment */
            if ((start.x == end.x) && (start.y == end.y))
            {
               /* just skip including this in the polygon buffer */
               zeroDeltaExpected = FALSE;
               break;
            }
            else
            {
               /* MacDraw is rendering a smoothed (quadratic B-spline) - flag
                  the fact that we should use the polygon simulation */
               polyMode = USEALTPOLY;
            }
         }
         else
         {
            /* make sure the point is different from last point */
            if (numPoints == 0 ||
                polyListLPtr[numPoints - 1].x != pt.x ||
                polyListLPtr[numPoints - 1].y != pt.y)
            {
               /* make sure that we haven't reached maximum size */
               if ((numPoints + 1) >= maxPoints)
               {
                  /* expand the number of points that can be cached by 10 */
                  maxPoints += 16;

                  /* unlock to prepare for re-allocation */
                  GlobalUnlock( polyHandle);

                  /* re-allocate the memory handle by the given amount */
                  tmpHandle = GlobalReAlloc(
                        polyHandle,
                        (maxPoints + 3) * sizeof( Point ),
                        GMEM_MOVEABLE);

                  /* make sure that the re-allocation succeeded */
                  if (tmpHandle == NULL)
                  {
                     /* if not, flag global error and exit from here */
                     GlobalFree(polyHandle);
                     polyHandle = NULL;
                     ErSetGlobalError( ErMemoryFull );
                     return;
                  }
                  
                  polyHandle = tmpHandle;
               

                  /* get new pointer addresses the polygon coordinate list */
                  numPointsLPtr = (Integer far *)GlobalLock( polyHandle );
                  polyListLPtr = (Point far *)(numPointsLPtr + POLYLIST);
               }

               /* insert the new point and increment number of points */
               polyListLPtr[numPoints++] = pt;

               /* union new point with polygon bounding box */
               polyBBox.left   = min( polyBBox.left,   pt.x );
               polyBBox.top    = min( polyBBox.top,    pt.y );
               polyBBox.right  = max( polyBBox.right,  pt.x );
               polyBBox.bottom = max( polyBBox.bottom, pt.y );

               /* toggle the state of zeroDeltaExpected - expect same point next time */
               zeroDeltaExpected = TRUE;
            }
         }
      }
   }

}  /* AddPolyPt */



private void DrawPolyBuffer( void )
/*-------------------------*/
/* Draw the polygon definition if the points were read without errors */
{
   /* copy the point count and bounding box into the memory block */
   *numPointsLPtr = sizeofMacWord + sizeofMacRect + (numPoints * sizeofMacPoint);
   *((Rect far *)(numPointsLPtr + BBOX)) = polyBBox;

   /* lock the polygon handle before rendering */
   GlobalUnlock( polyHandle );

   /* check if we should fill the polygon or if already done */
   if ((polyParams & FILLPOLY) && (polyParams & FILLREQUIRED))
   {
      Boolean  resetFg;
      Boolean  resetBk;
      RGBColor saveFg = 0;
      RGBColor saveBk = 0;

      /* set up fore- and background colors if they have changed */
      resetFg = (polyFgColor != grafPort.rgbFgColor);
      resetBk = (polyBkColor != grafPort.rgbBkColor);

      if (resetFg)
      {
         /* change the foreground color and notify Gdi of change */
         saveFg = grafPort.rgbFgColor;
         grafPort.rgbFgColor = polyFgColor;
         GdiMarkAsChanged( GdiFgColor );
      }
      if (resetBk)
      {
         /* change the background color and notify Gdi of change */
         saveBk = grafPort.rgbBkColor;
         grafPort.rgbBkColor = polyBkColor;
         GdiMarkAsChanged( GdiBkColor );
      }

      /* call gdi routine to draw polygon */
      GdiPolygon( GdiFill, polyHandle );

      if (resetFg)
      {
         /* change the foreground color and notify Gdi of change */
         grafPort.rgbFgColor = saveFg;
         GdiMarkAsChanged( GdiFgColor );
      }
      if (resetBk)
      {
         /* change the background color and notify Gdi of change */
         grafPort.rgbBkColor = saveBk;
         GdiMarkAsChanged( GdiBkColor );
      }

   }

   /* should the polygon be framed? */
   if ((polyParams & FRAMEPOLY) &&
       (grafPort.pnSize.x != 0) && (grafPort.pnSize.y != 0))
   {
      /* notify gdi that this is the same primitive */
      GdiSamePrimitive( polyParams & FILLPOLY );

      GdiPolygon( GdiFrame, polyHandle );

      /* notify gdi that this is no longer the same primitive */
      GdiSamePrimitive( FALSE );
   }

   /* get pointer address and address for the polygon coordinate list */
   numPointsLPtr = (Integer far *)GlobalLock( polyHandle );
   polyListLPtr  = (Point far *)(numPointsLPtr + POLYLIST);

}  /* DrawPolyBuffer */



private void AdjustTextRotation( Point far * newPt )
/*-----------------------------*/
/* This will calculate the correct text position if text is rotated */
{
   if (textMode && (grafPort.txRotation != 0) &&
      ((textCenter.x != 0) || (textCenter.y != 0)))
   {
      Point    location;
      Point    center;

      /* copy the new location to local variable */
      location = *newPt;

      /* ensure that a new text rotation was specified - recompute center */
      if (newTextCenter)
      {
         Real     degRadian;

         /* calculate the new center of rotation */
         center.x = textCenter.x + location.x;
         center.y = textCenter.y + location.y;

         /* calculate the sin() and cos() of the specified angle of rotation */
         degRadian = ((Real)grafPort.txRotation * TwoPi) / 360.0;
         degCos = cos( degRadian );
         degSin = sin( degRadian );

         /* use transformation matrix to compute offset to text center */
         textCenter.x = (Integer)((center.x * (1.0 - degCos)) +
                                  (center.y * degSin));

         textCenter.y = (Integer)((center.y * (1.0 - degCos)) -
                                  (center.x * degSin));

         /* indicate that the new text center was computed */
         newTextCenter = FALSE;
      }

      /* use transformation matrix to compute the new text basline location */
      newPt->x = (Integer)((location.x * degCos) -
                           (location.y * degSin) + textCenter.x);
      newPt->y = (Integer)((location.x * degSin) +
                           (location.y * degCos) + textCenter.y);
   }

}  /* AdjustTextRotation */



/****
 *
 * EPSComment(comment)
 * Encapsulated PostScript Handler which translates Mac EPS to GDI EPS.
 * This routine has intimate knowledge of the implementation of both
 * Mac and GDI EPS filters. It processes Mac PostScript comments.
 *
 * returns:
 *   >0      successfully parsed EPS data
 *    0      not EPS comment
 *   <0      error
 *
 * How the EPS filter works:
 * The Mac EPS filter uses special features in the LaserWriter driver
 * to send the PICT bounding box to the printer whre it is examined
 * by PostScript code. The filter outputs a preamble which is a
 * combination of QuickDraw and PostScript. This preamble is sent
 * before the PostScript date from the EPS file. It sets the pen
 * position for opposing corners of the PICT bounding box using
 * QuickDraw and reads the pen position back in PostScript. Any
 * transformations which have been set up in QuickDraw by the
 * application to position or scale the picture will be applied
 * to the coordinates of the bounding box sent by the preamble.
 * PostScript code determines the transformation necessary to map the
 * EPS bounding box onto the physical bounding box read from
 * QuickDraw. These transformations are then applied to the PostScript
 * picture when it is displayed.
 *
 * Operation of the GDI EPS filter is very similar except that it
 * outputs a combination of GDI and PostScript.
 *
 * Implementation:
 * The code can be in one of several states. Recognition of specific
 * PostScript strings causes transition between states.
 * PS_NONE     Initial state, indicates no PostScript has been seen yet
 *             In this state, QuickDraw to GDI translation proceeds
 *             normally but PostScript data is examined.
 *             When a PostScript record is found with the string
 *             "pse\rpsb\r", the start of the PostScript preamble
 *             has been found and the program goes into state PS_PREAMBLE.
 * PS_PREAMBLE All PostScript encountered in this state is ignored
 *             PostScript record starting with the string "[" is found.
 *             This is the PostScript bounding box specification.
 *             As soon as we see the bounding box, we have enough
 *             information to output the GDI EPS preamble and we go
 *             to state PS_BBOX.
 * PS_BBOX     PostScript is still ignored until a record beginning
 *             with "%!PS" is found, putting us into state PS_DATA.
 * PS_DATA     In this state, PostScript records are not ignored because
 *             PostScript seen now is from the EPS file. These records
 *             are translated to GDI POSTSCRIPT_DATA escapes.
 *             If the PostScript trailer "pse\rpsb\r" is encountered,
 *             it is ignored. If a PostScriptEnd comment is found
 *             it signals the end of the EPS data. We output the
 *             GDI PostScript trailer and we go back to state PS_NONE.
 *
 * Comment PostScriptHandle:
 *   if state == PS_NONE & data == "pse\rpsb\r"
 *      state = PS_PREAMBLE
 *   else if state == PS_PREAMBLE & data == "[ %d %d %d %d ]"
 *      state = PS_BBOX; output GDI EPS preamble
 *   else if state == PS_BBOX & data begins with "%!PS"
 *      state = PS_DATA
 *   else if state == PS_DATA
 *      if data == "pse\rpsb\r" ignore (is Mac PS trailer)
 *      else output PostScript data to GDI
 *
 * Comment PostScriptEnd:
 *      if state == PS_DATA
 *         state = PS_NONE; output GDI EPS trailer; exit
 *
 * QuickDraw primitives:
 *      translate QuickDraw to GDI normally
 *
 ****/
#define   PS_ERROR   (-1)
#define   PS_NONE      0
#define   PS_PREAMBLE  1
#define   PS_BBOX      2
#define   PS_DATA      3
#define   PS_ENDWAIT   4

private Integer EPSComment(Word comment)
{
static Integer state = PS_NONE;

   switch (comment)
     {
      case picPostScriptBegin:
      break;

      case picPostScriptEnd:
      if (state == PS_DATA)
        {
         GdiEPSTrailer();                  // output GDI trailer
         state = PS_NONE;                  // end, successful translation
        }
      break;

      case picPostScriptHandle:
      if ((state = EPSData(state)) < 0)    // process EPS data
         return (-1);                      // error during processing
       break;

       default:                           // not a PostScript comment
       return (0);
      }
   return (1);
}

/****
 *
 * Integer EPSData(Integer state)
 * Process EPS Data found in the PostScriptHandle comment.
 * What we do with the EPS data depends on the current state
 * we are in and what the PostScript data looks like.
 *
 * State        PS Data         Action
 * ----------------------------------------------------------------
 * PS_NONE      PS preamble string   state = PS_BEGIN
 * PS_PREAMBLE  [ ... ]              state = PS_BBOX, output GDI preamble
 * PS_BBOX      %!PS                 state = PS_DATA
 * PS_DATA      PS preamble string   ignore, is Mac PS trailer
 * PS_DATA      PS data              output as GDI PS data
 *
 * The Mac PostScript preamble string indicates that the PostScript
 * data was from the Mac EPS filter. It puts us into PS_PREAMBLE state
 * where we look for the bounding box specification (which begins
 * with "["). When this is found, we go to state PS_BBOX and output
 * the GDI EPS preamble using the bounding box.   From PS_BBOX we can
 * go into state PS_DATA when we find the record beginning with !PS
 * which designates the start of the read EPS data.
 *
 * Once in state PS_DATA, PostScript data is buffered up into GDI
 * printer escapes and output to the GDI stream. These are the only
 * PostScript records that are translated - all others are ignored.
 *
 ****/
private Integer EPSData(Integer state)
{
GLOBALHANDLE  h;
PSBuf far*    psbuf;
char far*     ptr;
Word          len = 0;
Rect          ps_bbox;

/*
 * Allocate a buffer for the PostScript data. The first WORD
 * of the buffer gives the number of bytes of PostScript data.
 * The actual data follows. This is the format needed for
 * the GDI Escape call.
 */
   GetWord(&len);                       // length of EPS comment
   if ((h = GlobalAlloc(GHND, (DWORD) len + sizeof(PSBuf))) == 0)
     {
      ErSetGlobalError(ErMemoryFull);   // memory allocation error
      return (-1);
     }
   psbuf = (PSBuf far *) GlobalLock(h);
   psbuf->length = len;                 // save byte length
   ptr = (char far *) &psbuf->data;     // -> PostScript data
   while (len-- != 0) GetByte(ptr++);   // read PS data into buffer
   *ptr = 0                ;            // null terminate it
   ptr = (char far *) &psbuf->data;     // -> PostScript data

   /* If this is a superPaint file, and postscript is being processed,
      check if this is a situation where text could be mangled beyond
      belief and requires adjustment in the parsing process. */
   if (superPaintFile && state == PS_NONE)
   {
      char save;
      Word start = lstrlen( SUPERPAINT_TEXTSTARTJUNK );
      Word stop  = lstrlen( SUPERPAINT_TEXTSTOPJUNK );

      /* Assume that this text is OK for now */
      badSuperPaintText = FALSE;

      /* If this buffer is long enough to hold the begin and end of the bogus
         test Postcript commands (dealing with rotation and shearin)... */
      if (psbuf->length > (start + stop))
      {
         /* Create a string and compare for the beginning sequence and ending
            sequences.  Restore the null "C" terminator after finished. */
         save = *(ptr + start);
         *(ptr + start) = 0;
         badSuperPaintText = (lstrcmp(ptr, SUPERPAINT_TEXTSTARTJUNK) == 0 &&
                              lstrcmp(ptr + psbuf->length - stop, SUPERPAINT_TEXTSTOPJUNK) == 0);
         *(ptr + start) = save;
      }
   }

/*
 * If PostScript preamble is found in state PS_NONE we can advance to
 * state PS_PREAMBLE. If it is found again before state PS_DATA,
 * we have an incorrect sequence and should not translate this EPS.
 * On the MAC, the preamble is the same as the trailer and, if found
 * during state PS_ENDWAIT, it signals the end of EPS processing.
 */
   if (lstrcmp(ptr, MAC_PS_PREAMBLE) == 0)
      switch (state)
     {
      case PS_NONE:                    // waiting for preamble
      state = PS_PREAMBLE;
      break;

      case PS_DATA:                    // ignore Mac trailer
      break;

      default:                        // error if found in other states
      state = PS_NONE;                // abort EPS processing
      break;
     }
/*
 * PostScript date was not MAC EPS preamble. Process other states
 */
   else switch (state)
     {
      case PS_PREAMBLE:               // waiting for bbox
      if (EPSBbox(psbuf, &ps_bbox))
        {
         GdiEPSPreamble(&ps_bbox);
         state = PS_BBOX;             // parsed bbox, wait for EPS data
        }
      break;

      case PS_BBOX:                   // waiting for !PS
      if ((ptr[0] == '%') &&
          (ptr[1] == '!') &&
          (ptr[2] == 'P') &&
          (ptr[3] == 'S'))
         state = PS_DATA;             // found start of EPS data
      else break;

      case PS_DATA:                   // output EPS data to GDI
      if (lstrcmp(ptr, MAC_PS_TRAILER) != 0)
        GdiEPSData(psbuf);            // but ignore PS trailer
      state = PS_DATA;
      break;
     }
   GlobalUnlock(h);
   GlobalFree(h);                     // free PostScript buffer
   return (state);
}

/****
 *
 * Boolean EPSBbox(PSBuf, Rect far *)
 * Parse EPS bounding box string [ %d %d %d %d ] and store corners
 * of bounding box in given rectangle.
 *
 * returns:
 *   0 = cannot parse bounding box descriptor
 *   1 = bounding box successfully parsed
 *
 ****/
private Boolean EPSBbox(PSBuf far *psbuf, Rect far *bbox)
{
char   far*   ptr = psbuf->data;

   while ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\n'))
      ++ptr;
   if (*ptr++ != '[') return (0);
   if (!(ptr = parse_number(ptr, &bbox->left))) return (0);
   if (!(ptr = parse_number(ptr, &bbox->top))) return (0);
   if (!(ptr = parse_number(ptr, &bbox->right))) return (0);
   if (!(ptr = parse_number(ptr, &bbox->bottom))) return (0);
   if (*ptr != ']') return(0);
   return(1);
}

private char far* parse_number(char far* ptr, Integer far *iptr)
{
Boolean   isneg = 0;         // assume positive
Integer   n = 0;

   while ((*ptr == ' ') || (*ptr == '\t'))
      ++ptr;                           // skip whitespace
   if (*ptr == '-')                    // number is negative?
     {
      isneg = 1;
      ++ptr;
     }
   if (!IsCharDigit(*ptr)) return(0);     // digit must follow
   do n = n * 10 + (*ptr++ - '0');
   while (IsCharDigit(*ptr));
   if (*ptr == '.')                   // skip any digits following decimal pt
   {
      do ++ptr;
      while (IsCharDigit(*ptr));
   }
   while ((*ptr == ' ') || (*ptr == '\t'))
      ++ptr;                          // skip whitespace
   if (isneg) n = -n;                 // remember the sign
   *iptr = n;
   return (ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\daytona\makefile.inc ===
obj\$(TARGET_DIRECTORY)\olecnv32.def: olecnv32.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oledbg\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oledbg\oledbg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:
//
// Contents:
//
//
// History:
//
//------------------------------------------------------------------------

#include <ntsdexts.h>


extern "C" PNTSD_EXTENSION_APIS    pExtApis;
extern "C" HANDLE                  hDbgThread;
extern "C" HANDLE                  hDbgProcess;
extern "C" char			  *pszToken;
extern "C" char			  *pszTokenNext;


#define ntsdPrintf      (pExtApis->lpOutputRoutine)
#define ntsdGetSymbol       (pExtApis->lpGetSymbolRoutine)
#define ntsdGetExpr         (pExtApis->lpGetExpressionRoutine)
#define ntsdCheckC          (pExtApis->lpCheckControlCRoutine)

#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

extern void InitTokenStr(LPSTR lpzString);
extern DWORD ReadMemory( PVOID pvAddress, ULONG cbMemory, PVOID pvLocalMemory);
extern DWORD WriteMemory(PVOID pvLocalMemory, ULONG cbMemory, PVOID pvAddress);
extern void ShowBinaryData(PBYTE   pData,DWORD   cbData);
extern BOOL IsDebug_olethk32();
extern BOOL IsDebug_ole32();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olecnv32\toolbox.h ===
/************** ToolBox.h ***************************************************

  The purpose of ToolBox is to isolate all the Windows vs Mac Toolbox
  DIFFERENCES THAT WE CARE TO ISOLATE AT ALL.  Always include this module
  instead of including Windows.h or "using" MemTypes.P, etc.

*****************************************************************************/

#ifdef WIN32
#define huge
#endif

/************** Includes ****************************************************/

#define   NOHELP        /* No help engine stuff */
#define   NOSOUND       /* No sound stuff */
#define   NODRAWFRAME   /* No DrawFrame stuff */
#define   NOCOMM        /* Disable Windows communications interface */
#define   NOKANJI       /* Disable Windows Kanji support */
#define   OEMRESOURCE   /* Enable access to OEM resources (checkmark, etc.) */

#include "windows.h"

#define sizeofMacDWord     4
#define sizeofMacPoint     4
#define sizeofMacRect      8
#define sizeofMacWord      2

/************** Public Data *************************************************/

#define Far far                 /* for use with function parameters only! */
#define Pascal                  /* default set with compiler options */

#define NA         0L           /* use for 'Not Applicable' parms */
#define NIL        NULL         /* alternate name for empty pointer */
#define cNULL      '\0'         /* alternate name for null char     */
#define sNULL      ""           /* alternate name for null string   */
#define NOERR      0            /* success flag */


typedef unsigned   Char;        /* MPW unsigned char */
typedef char       SignedByte;  /* MPW signed char */
typedef int        Integer;     /* MPW Pascal integer. Hide int type of compiler*/
typedef long       LongInt;     /* MPW Pascal name */
typedef double     Real;        /* MPW Pascal name */
typedef BYTE       Byte;        /* MPW Byte.  Hide Win/PM unsigned char type */
typedef unsigned   Word;        /* MPW Word.  Hide Win/PM unsigned int  type */
typedef DWORD      DWord;       /* Hide Win/PM unsigned long */
typedef LongInt    Fixed;       /* MPW fixed point number */
typedef LongInt    Fract;       /* MPW fraction point number [-2,2) */
typedef void *     Ptr;         /* MPW opaque pointer */
typedef void far * LPtr;        /* Opaque far pointer */
typedef HANDLE     Handle;      /* MPW opaque handle */
typedef char       Str255[256]; /* MPW string type.  255 characters + null */
typedef char       String[];    /* Indeterminate length string */
typedef char       StringRef;   /* AR: String reference type? */
typedef NPSTR      StringPtr;   /* MPW string type. Hide Win/PM string pointer*/
typedef LPSTR      StringLPtr;  /* Hide Win/PM string far pointer type */
typedef HANDLE     StringHandle;/* MPW string handle */
typedef BOOL       Boolean;     /* MPW Pascal name */
typedef unsigned   BitBoolean;  /* Boolean type that can be used as a bitfield */
typedef RECT       Rect;        /* MPW rectangle structure */
typedef POINT      Point;       /* MPW point structure */
typedef DWORD      Size;        /* MPW size.  AR: size_t if included stddef.h */
typedef WORD       Param1;      /* Hide Windows/PM message param differences */
typedef LONG       Param2;      /* Hide Windows/PM message param differences */
typedef unsigned   Style;       /* MPW text style */
typedef Integer    Interval;    /* Array/RunArray/Text intervals */
typedef Integer    OSErr;       /* OS Error */

typedef union
{  Handle handle;
   Ptr    ptr;
   LPtr   lptr;
   Word   word;
   DWord  dword;
}  LongOpaque;                  /* A 4-byte quantity whose type is unknown */

#define INDETERMINATE 1

#define  TwoPi          (2.0*3.141592)    /* math constant */

/* The following macro defeats the compiler warning for unreferenced vars.
   Use it only where a statement would be permitted in C. */
#define UnReferenced( v )  if(v)

#define private   static                /* alternate (understandable) name */

/* largest Integer value, expressed in an implementation-independent way */
#define MAXINT    ((Integer) (((Word) -1) >> 1))

/* MAXLONG is defined in winnt.h as 0x7FFFFFFF */
#ifndef WIN32
#define MAXLONG   ((LongInt) (((DWord) -1) >> 1))
#endif

Rect        NULLRECT;      /* empty rectangle */
Rect        UNIRECT;       /* rectangle encompassing the universe */
Point       ZEROPT;        /* zero (0,0) point */
Point       UNITPT;        /* unit (1,1) point */

void PASCAL BreakPoint( void );
/* Execute a software breakpoint to the debugger if it is loaded, otherwise
   continue execution. */

/* private */ void AssertionFailed( String file, Integer line, String expression );
/* Print the fact that 'expression' was not true at 'line' in 'file' to the
   'logFile', then execute a software breakpoint.  Treat this function as
   private to ToolBox; it is only exported because Assert() is a macro. */

#define /* void */ Assert( /* Boolean */ expression )                        \
/*=====================*/                                                    \
/* Provides an Assert function for use with Windows.  Note that the          \
   expression in the Assert should NOT be a function/procedure call which    \
   MUST be called, since Asserts may be disabled, disabling the function or  \
   procedure call.  Also note that Asserts expand inline, therefore to       \
   minimize code size in cases where several Asserts are done at once, you   \
   can code the Assert as                                                    \
                                \
   Assert( assertion1 && assertion2 ... );                              \
                                \
   This has the drawback of possibly not fitting on a source line or         \
   localizing an assertion failure accurately enough.   */                   \
{                                                                            \
   if( !( expression ) )                                                     \
      AssertionFailed( _FILE_, __LINE__, #expression );                    \
}  /* Assert */

#define /* Size */ Sizeof( expression )                                      \
/*======================*/                                                   \
/* Return the Size of the 'expression' */                                    \
((Size) sizeof( expression ))

#define /* Word */ ToWord( /*DWord*/ d )                                     \
/*=====================*/                                                    \
( LOWORD( d ))

#define /* Integer */ ToInteger( /* LongInt */ l )                           \
/*===========================*/                                              \
((Integer) (LOWORD( l )))


#define /* Boolean */ RectEqual( /* Rect */ a, /* Rect */ b )                \
/*===========================*/                                              \
/* Return TRUE iff Rect 'a' is identical to Rect 'b'. */                     \
(Boolean) EqualRect( &(a), &(b) )

/* HGET(pointer, field, structure name, type)
 * Accesses a field from a structure without using the "->"
 * construct. This is because "->" has a bug and does not work
 * correctly with huge pointers. Instead we use "+" and obtain
 * the offset of the structure field by casting 0 to be a
 * pointer to the structure. The last argument is the type of
 * the structure field.
 */
#define HGET( p, f, s, t ) ( *(( t huge * ) ((( char huge * )p ) + (( WORD ) &((( s * )0 )->f )))))

#define /* Integer */ Width( /* Rect */ r )                                  \
/*=======================*/                                                  \
/* Return width of the rectangle 'r'. */                                     \
((r).right - (r).left)

#define /* Integer */ Height( /* Rect */ r)                                  \
/*========================*/                                                 \
/* Return height of the rectangle 'r'. */                                    \
((r).bottom - (r).top)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\idl\daytona\makefile.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Greg Jensenworth


!ENDIF


SDKINC=$(_NTDRIVE)$(_NTROOT)\public\sdk\inc
DCOMIDL=$(_NTDRIVE)$(_NTROOT)\private\dcomidl

unknwn.idl : $(SDKINC)\unknwn.idl
    -erase proxy\unknwn_p.c
    copy $(SDKINC)\unknwn.idl .

objidl.idl : $(SDKINC)\objidl.idl
    -erase proxy\objidl_p.c
    copy $(SDKINC)\objidl.idl .

oleidl.idl : $(SDKINC)\oleidl.idl
    -erase proxy\oleidl_p.c
    copy $(SDKINC)\oleidl.idl .

oaidl.idl : $(SDKINC)\oaidl.idl
    -erase proxy\oaidl_p.c
    copy $(SDKINC)\oaidl.idl .


remunk.idl : $(DCOMIDL)\remunk.idl
    -erase proxy\remunk_p.c
    copy $(DCOMIDL)\remunk.idl .

contxt.idl : $(DCOMIDL)\contxt.idl
    -erase proxy\contxt_p.c
    copy $(DCOMIDL)\contxt.idl .

..\proxy\unknwn_p.c : unknwn.idl

..\proxy\objidl_p.c : objidl.idl

..\proxy\oleidl_p.c : oleidl.idl

..\proxy\oaidl_p.c : oaidl.idl

..\proxy\remunk_p.c : remunk.idl

..\proxy\contxt_p.c : contxt.idl

..\proxy\connct_p.c : connct.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oledbg\oledbg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oledbg.cxx
//
//  Contents:   OLE debugger extention DLL
//
//  Classes:
//
//  Functions:
//
//  History:    8-05-94   kevinro   Created
//
//----------------------------------------------------------------------------
extern "C" {
#undef DBG
#define DBG 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <rpc.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <oledbg.h>

#pragma hdrstop

PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;

//
char achTokenBuf[1024];
char *pszTokenNext = NULL;
char *pszToken = NULL;

void InitTokenStr(LPSTR lpszString)
{
    if (lpszString)
    {
	strcpy(achTokenBuf,lpszString);
    }
    else
    {
	achTokenBuf[0]=0;
    }

    pszTokenNext = achTokenBuf;
    pszToken = NULL;
}

char *NextToken()
{
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadMemory
//
//  Synopsis:   Reads memory from the debuggee
//
//  Effects:
//
//  Arguments:  [pvAddress] --
//		[cbMemory] --
//		[pvLocalMemory] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    ULONG       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return((DWORD)-1);
        }
        return(0);
    }
    return(GetLastError());

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteMemory
//
//  Synopsis:   Writes memory to the debuggee
//
//  Effects:
//
//  Arguments:  [pvLocalMemory] --
//		[cbMemory] --
//		[pvAddress] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WriteMemory(PVOID           pvLocalMemory,
            ULONG           cbMemory,
            PVOID           pvAddress)
{
    ULONG       cbActual = cbMemory;

    if (WriteProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return((DWORD)-1);
        }
        return(0);
    }
    return(GetLastError());
}
#define AllocHeap(x)    RtlAllocateHeap(RtlProcessHeap(), 0, x)
#define FreeHeap(x) 	RtlFreeHeap(RtlProcessHeap(), 0, x)


DWORD
GetTlsEntry(ULONG       TlsValue,
            PVOID *     ppvValue)
{
    NTSTATUS                    Status;
    THREAD_BASIC_INFORMATION    ThreadInfo;
    ULONG                       cbReturned;
    PVOID                       *Slot;
    PTEB                        Teb;

    Status = NtQueryInformationThread(  hDbgThread,
                                        ThreadBasicInformation,
                                        &ThreadInfo,
                                        sizeof(ThreadInfo),
                                        &cbReturned);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Teb = (PTEB) AllocHeap(sizeof(TEB));

    ReadMemory(ThreadInfo.TebBaseAddress, sizeof(TEB), Teb);

    Slot = &Teb->TlsSlots[TlsValue];
    *ppvValue = *Slot;

    FreeHeap(Teb);

    return(0);

}

void ShowBinaryData(PBYTE   pData,
                    DWORD   cbData)
{
    DWORD                   i;
    char                    line[20];
    PNTSD_EXTENSION_APIS    lpExt = pExtApis;

    line[16] = '\0';
    if (cbData > 65536)
    {
        ntsdPrintf("ShowBinaryData:  Data @%x is said to be %d bytes in length\n");
        ntsdPrintf("                 Rejecting request.  Corrupt data\n");
        return;
    }
    for (; cbData > 0 ; )
    {
        for (i = 0; i < 16 && cbData > 0 ; i++, cbData-- )
        {
            ntsdPrintf(" %02x", (unsigned) *pData);
            if (isprint(*pData))
                line[i] = *pData;
             else
                line[i] = '.';
            pData++;
        }
        if (i < 16)
        {
            for (;i < 16 ; i++ )
            {
                ntsdPrintf("   ");
                line[i] = ' ';
            }
        }
        ntsdPrintf("\t%s\n",line);
        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }

    }
}



BOOL
IsDebug_olethk32()
{
    ULONG addr;
    DWORD dwValue;
    addr = ntsdGetExpr("olethk32!oledbgCheck_olethk32");

    if (addr == 0)
    {
	ntsdPrintf("warning: olethk32 not debug version\n");
	return(0);
    }

    if (ReadMemory((LPVOID)addr,sizeof(dwValue),(PVOID)&dwValue))
    {
	ntsdPrintf("warning: could not read check value at %x\n",addr);
	return(0);
    }

     if (dwValue != 0x12345678)
    {
	ntsdPrintf("warning: olethk32!oledbgCheck_olethk32 value wrong\n");
	ntsdPrintf("warning: suspect wrong symbols for olethk32\n");
	return(0);
    }
    return(1);
}


BOOL
IsDebug_ole32()
{
    ULONG addr;
    DWORD dwValue;
    addr = ntsdGetExpr("ole32!oledbgCheck_ole32");
    if (addr == 0)
    {
	ntsdPrintf("warning: ole32 not debug version\n");
	return(0);
    }

    if (ReadMemory((LPVOID)addr,sizeof(dwValue),(PVOID)&dwValue))
    {
	ntsdPrintf("warning: could not read check value at %x\n",addr);
	return(0);
    }

    if (dwValue != 0x12345678)
    {
	ntsdPrintf("warning: olethk32!oledbgCheck_ole32 value wrong\n");
	ntsdPrintf("warning: suspect wrong symbols for ole32\n");
	return(0);
    }
    return(1);
}

//+---------------------------------------------------------------------------
//
//  Function:   DumpVtbl
//
//  Synopsis:   Dumps a vtbl to the debugger
//
//  Effects:	Given a pointer to a vtbl, output the name of the vtbl, and
//		its contents to the debugger.
//
//  Arguments:  [pvtbl] -- Address of vtbl
//		[pszCommand] -- Symbolic expression for pvtbl
//
//  History:    8-07-94   kevinro   Created
//
//----------------------------------------------------------------------------
extern "C"
void
DumpVtbl(PVOID pvtbl, LPSTR pszCommand)
{
   DWORD dwVtblOffset;
   char achNextSymbol[256];

   if (pvtbl == 0)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s has a vtbl pointer of NULL\n",pszCommand);
       return;
   }

   if ((DWORD)pvtbl == 0xdededede)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s may be deleted memory. pvtbl==0xdededede\n",pszCommand);
       return;
   }

   // This value points at the VTBL. Find a symbol for the VTBL
   ntsdGetSymbol((LPVOID)pvtbl,(UCHAR *)achNextSymbol,(LPDWORD)&dwVtblOffset);

   // If the dwVtblOffset is not zero, then we are pointing into the table.
   // This could mean multiple inheritance. We could be tricky, and try to
   // determine the vtbl by backing up here. Maybe later
   if (dwVtblOffset != 0)
   {
       ntsdPrintf("Closest Previous symbol is %s at 0x%x (offset -0x%x)\n",
		  achNextSymbol,
		  (DWORD)pvtbl - dwVtblOffset,
		  dwVtblOffset);
       return;
   }
   ntsdPrintf("0x%08x -->\t %s\n",pvtbl,achNextSymbol);
   // vtbl entries should always point at functions. Therefore, we should
   // always have a displacement of zero. To check for the end of the table
   // we will reevaluate the vtbl pointer. If the offset isn't what we
   // expected, then we are done.

   DWORD dwIndex;
   for (dwIndex = 0 ; dwIndex < 4096 ; dwIndex += 4)
   {
       DWORD dwVtblEntry;

       ntsdGetSymbol((LPVOID)((DWORD)pvtbl+dwIndex),
		     (UCHAR *)achNextSymbol,
		     (LPDWORD)&dwVtblOffset);

       if (dwVtblOffset != dwIndex)
       {
	   //
	   // May have moved on to another vtable
	   //
#ifdef DBG_OLEDBG
	   ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
	   ntsdPrintf("Moved to another table?\n");
#endif
	   return;
       }

       if (ReadMemory((LPVOID)((DWORD)pvtbl+dwIndex),
		      sizeof(dwVtblEntry),
		      (PVOID)&dwVtblEntry))
       {
	   //
	   // Must be off the end of a page or something.
	   //
#ifdef DBG_OLEDBG
	   ntsdPrintf("End of page?\n");
#endif
	   return;
       }

       // If the function is at zero, then must be at end of table
       if (dwVtblEntry == 0)
       {
#ifdef DBG_OLEDBG
	   ntsdPrintf("dwVtblEntry is zero. Must be end of table\n");
	   return;
#endif

       }

       // Now, determine the symbol for the entry in the vtbl
       ntsdGetSymbol((LPVOID)dwVtblEntry,
		     (UCHAR *)achNextSymbol,
		     (LPDWORD)&dwVtblOffset);

       // If it doesn't point to the start of a routine, then it
       // probably isn't part of the vtbl
       if (dwVtblOffset != 0)
       {
#ifdef DBG_OLEDBG
	   ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
	   ntsdPrintf("Doesn't point to function?\n");
#endif
	   return;
       }

       ntsdPrintf("   0x%08x\t %s\n",dwVtblEntry,achNextSymbol);
   }
   ntsdPrintf("Wow, there were at least 1024 entries in the table!\n");

}

extern "C"
void
punk(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
   PVOID punk;
   PVOID pvtbl;

   InitDebugHelp(hProcess, hThread, lpExt);

   // Evalute the first pointer. This is a pointer to the object
   punk = (PVOID) ntsdGetExpr(pszCommand);

   if (punk == NULL)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s is not a valid pointer\n",pszCommand);
       return;
   }
   // Now, read the first DWORD of this memory location
   // This is a pointer to the table
   if (ReadMemory(punk,sizeof(pvtbl),(PVOID)&pvtbl))
   {
       ntsdPrintf("Couldn't read memory at %x\n",punk);
       return;
   }

   DumpVtbl(pvtbl,pszCommand);

}
extern "C"
void
vtbl(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
   PVOID pvtbl;

   InitDebugHelp(hProcess, hThread, lpExt);

   // Evalute the first pointer. This is a pointer to the table
   pvtbl = (PVOID) ntsdGetExpr(pszCommand);
   DumpVtbl(pvtbl,pszCommand);
}

extern "C"
void
expr(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    InitDebugHelp(hProcess, hThread, lpExt);

    UCHAR symbol[256];
    DWORD expr;
    DWORD disp;

    expr = ntsdGetExpr(pszCommand);

    ntsdGetSymbol((LPVOID)expr,(UCHAR *)symbol,(LPDWORD)&disp);

    ntsdPrintf("expr: %s = %x (%d) %s + %d\n",pszCommand,expr,expr,symbol,disp);

}

extern "C"
void
isdbg(  HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    if (IsDebug_ole32())
    {
	ntsdPrintf("ole32.dll is debug\n");
    }
    if (IsDebug_olethk32())
    {
	ntsdPrintf("olethk32.dll is debug\n");
    }
}

extern "C"
void
help(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    ntsdPrintf(" help		\tThis Message\n");
    ntsdPrintf(" isdbg		\tDetermine if DLL's are debug\n");
    ntsdPrintf(" punk <expr>	\tDump IUnknown vtbl\n");
    ntsdPrintf(" vtbl <expr>	\tDump vtbl\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\clipformat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       clipformat.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for CLIPFORMAT.
//
//  Functions:  
//              CLIPFORMAT_UserSize
//              CLIPFORMAT_UserMarshal
//              CLIPFORMAT_UserUnmarshal
//              CLIPFORMAT_UserFree
//              CLIPFORMAT_UserSize64
//              CLIPFORMAT_UserMarshal64
//              CLIPFORMAT_UserUnmarshal64
//              CLIPFORMAT_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>
#include <winsta.h>
#include <allproc.h>

typedef HANDLE __stdcall FN_WinStationOpenServerW(LPWSTR);
typedef BOOLEAN __stdcall FN_WinStationGetTermSrvCountersValue(HANDLE, ULONG, PVOID);
typedef BOOLEAN __stdcall FN_WinStationCloseServer(HANDLE);

static DWORD g_cTSSessions = -1;

#include "carefulreader.hxx"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
void CountTSSessions()
{
    DWORD cTSSessions = 0;
    HINSTANCE hTSLib = LoadLibraryW(L"winsta.dll");
    if (hTSLib) 
    {
        FN_WinStationOpenServerW *pFNOpen = (FN_WinStationOpenServerW *)GetProcAddress(hTSLib, "WinStationOpenServerW");
        FN_WinStationGetTermSrvCountersValue *pFNCount = (FN_WinStationGetTermSrvCountersValue *)GetProcAddress(hTSLib, "WinStationGetTermSrvCountersValue");
        FN_WinStationCloseServer *pFNClose = (FN_WinStationCloseServer *)GetProcAddress(hTSLib, "WinStationCloseServer");
        if (pFNOpen && pFNCount && pFNClose) 
        {
            HANDLE hServer = pFNOpen(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
            if (hServer != NULL)
            {
                TS_COUNTER tsCounters[2] = {0};
               
                tsCounters[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
                tsCounters[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;
               
                if (pFNCount(hServer, ARRAYSIZE(tsCounters), tsCounters))
                {
                    int i;
                    for (i = 0; i < ARRAYSIZE(tsCounters); i++)
                    {
                        if (tsCounters[i].counterHead.bResult)
                        {
                            cTSSessions += tsCounters[i].dwValue;
                        }
                    }
                }
                pFNClose(hServer);
            }
        }
        FreeLibrary(hTSLib);
    }
    g_cTSSessions = cTSSessions;
}

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserSize
//
//  Synopsis:   Sizes a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
CLIPFORMAT_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return( Offset );

    if (g_cTSSessions == -1) 
    {
        CountTSSessions();
    }

    // userCLIPFORMAT is an encapsulated union with a string.
    LENGTH_ALIGN( Offset, 3);
    Offset += sizeof(long) + sizeof(void *);

    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && ((REMOTE_CLIPFORMAT( pFlags) ) 
                                                || (g_cTSSessions > 1 ))) // ignore console session
    {
        wchar_t temp[CLIPFORMAT_BUFFER_MAX];

        int ret = GetClipboardFormatName( *pObject,
                                          temp,
                                          CLIPFORMAT_BUFFER_MAX - 1 );

        if ( ret )
        {
            Offset += 3 * sizeof(long)  +  (ret+1) * sizeof(wchar_t);
        }
        else
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );
    }

    return( Offset );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserMarshal
//
//  Synopsis:   Marshals a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return pBuffer;

    // userCLIPFORMAT is an encapsulated union with a string.

    ALIGN( pBuffer, 3);

    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && (( REMOTE_CLIPFORMAT(pFlags) ) || (g_cTSSessions > 1 ))) // ignore console session
    {
        // sending a wide string

        unsigned long    ret;

        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *(PULONG_LV_CAST pBuffer)++ = (ulong) *pObject;

        // On Chicago this is GetClipboardFormatNameX.
        // When the buffer is too short, this call would still
        // return a decent, null terminated, truncated string.
        //

        wchar_t temp[CLIPFORMAT_BUFFER_MAX];
        ret = (ulong) GetClipboardFormatName( *pObject,
                                              temp,
                                              CLIPFORMAT_BUFFER_MAX - 1 );

        if ( ret )
        {
            ret++;
            lstrcpynW( (wchar_t *)(pBuffer + 12), temp, ret);
            // conformat size etc. for string.
   
            *(PULONG_LV_CAST pBuffer)++ = ret;
            *(PULONG_LV_CAST pBuffer)++ = 0;
            *(PULONG_LV_CAST pBuffer)++ = ret;
            // skip the string in the bbuffer, including the terminator

            pBuffer += ret * sizeof(wchar_t);
        }
        else
            RpcRaiseException( DV_E_CLIPFORMAT );
    }
    else
    {
        // sending the number itself

        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *(PULONG_LV_CAST pBuffer)++ = (ulong) *pObject;
    }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserUnmarshal
//
//  Synopsis:   Unmarshals a CLIPFORMAT; registers if needed.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//              Aug-99   JohnStra      Added consistency checks
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    ulong UnionDisc;
    UINT  cf;

    if (g_cTSSessions == -1) 
        CountTSSessions();

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save the fixup size.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing buffer.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    UnionDisc =        *(PULONG_LV_CAST pBuffer)++;
    cf        = (WORD) *(PULONG_LV_CAST pBuffer)++;

    if ( WDT_DATA_MARKER == UnionDisc )
    {
        // CLIPFORMAT value must be in valid range.
        if ( cf < 0xc000 || cf > 0xffff )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        // Check for EOB before accessing string header.
        CHECK_BUFFER_SIZE( BufferSize, cbFixup + (5 * sizeof( ULONG )) );

        // Get the string header from the buffer and subtract the string
        // header from the BufferSize.
        ULONG ConfSize = *(PULONG_LV_CAST pBuffer)++;
        ULONG Offset = *(PULONG_LV_CAST pBuffer)++;
        ULONG ActualSize = *(PULONG_LV_CAST pBuffer)++;

        // Verify the header: Offset must always be zero, length must match
        // size, and size can't be zero since that would mean no NULL
        // terminator.
        if ( 0 != Offset || ActualSize != ConfSize || 0 == ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Check for EOB before accessing string.
        CHECK_BUFFER_SIZE(
            BufferSize,
            cbFixup + (5 * sizeof(ULONG)) + (ActualSize * sizeof(WCHAR)) );

        // Last two bytes of the buffer must be unicode terminator
        if ( *(WCHAR*)(pBuffer + ((ActualSize-1) * sizeof(WCHAR))) != 0x0000 )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Must be only 1 unicode terminator.
        if ( (ULONG)(lstrlenW( (WCHAR*)pBuffer ) + 1) != ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Register the clipboard format.
        cf = RegisterClipboardFormat( (wchar_t *)pBuffer );
        if ( cf == 0 )
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );

        // Advance buffer pointer past string.
        pBuffer += ActualSize * sizeof(wchar_t);
    }
    else 
    {
        if ( WDT_HANDLE_MARKER != UnionDisc )
        {
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

        if ( (NON_STANDARD_CLIPFORMAT(&cf)) && (( REMOTE_CLIPFORMAT(pFlags) ) || (g_cTSSessions > 1 )))
        {
            // Should have sent this one by value!
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }        
    }

    *pObject = (CLIPFORMAT) cf;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserFree
//
//  Synopsis:   Frees remnants of CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//
//--------------------------------------------------------------------------

void  __RPC_USER
CLIPFORMAT_UserFree(
    unsigned long * pFlags,
    CLIPFORMAT * pObject )
{
    // Nothing to free, as nothing gets allocated when we unmarshal.
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserSize64
//
//  Synopsis:   Sizes a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
CLIPFORMAT_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return( Offset );

    if (g_cTSSessions == -1) 
        CountTSSessions();

    // userCLIPFORMAT is an encapsulated union with a string.
    // max align of the union is size of 64b pointer.
    LENGTH_ALIGN( Offset, 7 );
    Offset += 8;               // 4 byte discriminant, 4 byte alignment
    
    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && ((REMOTE_CLIPFORMAT( pFlags) ) 
                                                || (g_cTSSessions > 1 ))) // ignore console session
    {
        // Writing another pointer...
        Offset += 8;           // 64b pointer

        wchar_t temp[CLIPFORMAT_BUFFER_MAX + 1];

        int ret = GetClipboardFormatName( *pObject,
                                          temp,
                                          CLIPFORMAT_BUFFER_MAX );

        if ( ret )
        {
            // This string has 3 conformance fields (64b) followed by an
            // array of 16b chars.
            Offset += (3 * 8)  +  ((ret + 1) * 2);
        }
        else
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );
    }
    else
    {
        // Writing a DWORD
        Offset += 4;
    }

    return( Offset );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserMarshal64
//
//  Synopsis:   Marshals a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return pBuffer;

    // userCLIPFORMAT is an encapsulated union with a string.

    ALIGN( pBuffer, 7 );

    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && ((REMOTE_CLIPFORMAT( pFlags) ) 
                                                || (g_cTSSessions > 1 ))) // ignore console session
    {
        // sending a wide string
        unsigned long    ret;

        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper) *pObject;

        // On Chicago this is GetClipboardFormatNameX.
        // When the buffer is too short, this call would still
        // return a decent, null terminated, truncated string.
        //
        wchar_t temp[CLIPFORMAT_BUFFER_MAX];
        ret = (ulong) GetClipboardFormatName( *pObject,
                                              temp,
                                              CLIPFORMAT_BUFFER_MAX - 1 );

        if ( ret )
        {
            // Account for the trailing NULL.
            ret ++;
            lstrcpynW( (wchar_t *)(pBuffer + (3 * 8)), temp, ret);

            // conformat size etc. for string.
            *(PHYPER_LV_CAST pBuffer)++ = ret;   // Conformance
            *(PHYPER_LV_CAST pBuffer)++ = 0;     // Offset
            *(PHYPER_LV_CAST pBuffer)++ = ret;   // Actual Size

            // skip the string in the buffer, including the terminator
            pBuffer += (ret * 2);
        }
        else
            RpcRaiseException( DV_E_CLIPFORMAT );
    }
    else
    {
        // sending the number itself

        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        ALIGN( pBuffer, 7 );
        *(PULONG_LV_CAST pBuffer)++ = (ulong) *pObject;
    }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserUnmarshal64
//
//  Synopsis:   Unmarshals a CLIPFORMAT; registers if needed.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    ulong  UnionDisc;
    hyper  cf;

    if (g_cTSSessions == -1) 
        CountTSSessions();

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream( pBuffer, MarshalInfo.GetBufferSize() );

    stream.Align( 8 );                 // Must align on 8, union rules.
    UnionDisc = stream.ReadULONGNA();  // ...so no need to align on 4 here...
    stream.Align( 8 );                 // ...but must explicitly align to 8 here again.

    if ( WDT_DATA_MARKER == UnionDisc )
    {
        cf = stream.ReadHYPERNA();     // Just aligned 8, so don't align again.

        // CLIPFORMAT value must be in valid range.
        if ( cf < 0xc000 || cf > 0xffff )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        // Get the string header from the buffer and subtract the string
        // header from the BufferSize.
        hyper ConfSize   = stream.ReadHYPERNA();
        hyper Offset     = stream.ReadHYPERNA();
        hyper ActualSize = stream.ReadHYPERNA();

        // Verify the header: Offset must always be zero, length must match
        // size, and size can't be zero since that would mean no NULL
        // terminator.
        if ( 0 != Offset || ActualSize != ConfSize || 0 == ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Check for EOB before accessing string.
        stream.CheckSize((unsigned long)(ActualSize * sizeof(WCHAR)));

        // Last two bytes of the buffer must be unicode terminator
        WCHAR *pCheck = (WCHAR *)stream.GetBuffer();
        if ( pCheck[ActualSize-1] != 0x0000 )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );
        
        // Must be only 1 unicode terminator.
        if ( (ULONG)(lstrlenW( pCheck ) + 1) != ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Register the clipboard format.
        cf = RegisterClipboardFormat( pCheck );
        if ( cf == 0 )
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );

        // Advance buffer pointer past string.
        stream.Advance((unsigned long)(ActualSize * sizeof(WCHAR)));
    }
    else if ( WDT_HANDLE_MARKER == UnionDisc )
    {        
        cf = (hyper)stream.ReadULONGNA();  // Just aligned on 8...

        if ( (NON_STANDARD_CLIPFORMAT(&cf)) && ((REMOTE_CLIPFORMAT(pFlags)) || (g_cTSSessions > 1 )) )
        {
            // We should have marshalled this by value-- this is a bogus clipboard format!
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );
        }
    }
    else
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }

    *pObject = (CLIPFORMAT) cf;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserFree64
//
//  Synopsis:   Frees remnants of CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

void  __RPC_USER
CLIPFORMAT_UserFree64 (
    unsigned long * pFlags,
    CLIPFORMAT * pObject )
{
    // Nothing to free, as nothing gets allocated when we unmarshal.
}

#endif // win64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\bitmap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       bitmap.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HBITMAP.
//
//  Functions:  
//              HBITMAP_UserSize
//              HBITMAP_UserMarshal
//              HBITMAP_UserUnmarshal
//              HBITMAP_UserFree
//              HBITMAP_UserSize64
//              HBITMAP_UserMarshal64
//              HBITMAP_UserUnmarshal64
//              HBITMAP_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserSize
//
//  Synopsis:   Get the wire size the HBITMAP handle and data.
//
//  Derivation: Union of a long and the bitmap handle and then struct.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBITMAP_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return Offset;

    BITMAP      bm;
    HBITMAP     hBitmap = *pHBitmap;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);

    if ( ! *pHBitmap )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Pointee of the union arm for the remote case.
        // Conformat size, 6 fields, size, conf array.
        
        Offset += 4 + 4 * sizeof(LONG) + 2 * sizeof(WORD) + 4;
        
        // Get information about the bitmap
        if (FALSE == GetObjectA(hBitmap, sizeof(BITMAP), &bm))
        {
            RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
        }
        
        ULONG ulDataSize = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;
        
        Offset += ulDataSize;
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserMarshall
//
//  Synopsis:   Marshalls an HBITMAP object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHBITMAP
        
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*pHBitmap);
        
        if ( ! *pHBitmap )
            return pBuffer;
        
        // Get information about the bitmap        
        BITMAP bm;
        HBITMAP hBitmap = *pHBitmap;
        
        if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
        
        DWORD dwCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

        *( PULONG_LV_CAST pBuffer)++ = dwCount;

        // Get the bm structure fields.        
        ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );
        
        memcpy( pBuffer, (void *) &bm, ulBmSize );
        pBuffer += ulBmSize;
        
        // Get the raw bits.        
        if (0 == GetBitmapBits( hBitmap, dwCount, pBuffer ) )
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
        pBuffer += dwCount;
    }
    else
    {
        // Sending a handle.        
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*(HANDLE *)pHBitmap);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshallWorker
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap,
    ULONG_PTR       BufferSize )
{
    HBITMAP         hBitmap;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get Discriminant and handle.  Caller checked for EOB.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hBitmap = (HBITMAP)LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER(UnionDisc) )
    {
        if ( GDI_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hBitmap )
        {
            ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );

            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE(
                BufferSize,
                cbFixup + (3 * sizeof( ULONG )) + ulBmSize );

            DWORD    dwCount = *( PULONG_LV_CAST  pBuffer)++;
            BITMAP * pBm     = (BITMAP *) pBuffer;

            // verify dwCount matches the bitmap.
            if ( dwCount != (DWORD) pBm->bmPlanes * pBm->bmHeight * pBm->bmWidthBytes )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            pBuffer += ulBmSize;

            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE(
                BufferSize,
                cbFixup + (3 * sizeof(ULONG)) + ulBmSize + dwCount);

            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer

            hBitmap = CreateBitmap( pBm->bmWidth,
                                    pBm->bmHeight,
                                    pBm->bmPlanes,
                                    pBm->bmBitsPixel,
                                    pBuffer );

            pBuffer += dwCount;
        }
    }
    else 
    {
        if ( !IS_HANDLE_MARKER( UnionDisc ) )
        {
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

        if ( GDI_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }
    
    // A new bitmap handle is ready, destroy the old one, if needed.

    if ( *pHBitmap )
        DeleteObject( *pHBitmap );

    *pHBitmap = hBitmap;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work into a worker
//                                     routine in order to add consistency
//                                     checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserUnmarshal\n"));

    // Get the buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = HBITMAP_UserUnmarshalWorker( pFlags,
                                           pBufferStart,
                                           pHBitmap,
                                           BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserFree
//
//  Synopsis:   Free an HBITMAP.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBITMAP_UserFree(
    unsigned long * pFlags,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserFree\n"));

    if( pHBitmap  &&  *pHBitmap )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteObject( *pHBitmap );
            }
        }
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserSize64
//
//  Synopsis:   Get the wire size the HBITMAP handle and data.
//
//  Derivation: Union of a long and the bitmap handle and then struct.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBITMAP_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return Offset;

    BITMAP      bm;
    HBITMAP     hBitmap = *pHBitmap;

    LENGTH_ALIGN( Offset, 7 );

    // The encapsulated union.
    //   (aligned on 8)
    //   discriminant   4
    //   (align on 8)   4
    //   handle or ptr  8
    Offset += 16;

    if ( ! *pHBitmap )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Pointee of the union arm for the remote case.
        //   (aligned on 8)
        //   conformance 8
        //   4xlong      16
        //   2xword      4
        //   size        4
        //   data        ulDataSize;
        if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
            RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));

        ULONG ulDataSize = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;
        Offset += 32 + ulDataSize;
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserMarshal64
//
//  Synopsis:   Marshalls an HBITMAP object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return pBuffer;
    
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserMarshal64\n"));
    
    ALIGN( pBuffer, 7 );
    
    // Discriminant of the encapsulated union and union arm.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHBITMAP
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHBitmap);

        if ( ! *pHBitmap )
            return pBuffer;

        // Get information about the bitmap        
        BITMAP bm;
        HBITMAP hBitmap = *pHBitmap;

        if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        ULONG ulCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

        // Conformance...
        *(PHYPER_LV_CAST pBuffer)++ = ulCount;

        // Get the bm structure fields.
        ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );
        memcpy( pBuffer, &bm, ulBmSize );
        pBuffer += ulBmSize;

        // Get the raw bits.
        *(PULONG_LV_CAST pBuffer)++ = ulCount;

        if (0 == GetBitmapBits( hBitmap, ulCount, pBuffer ) )
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        pBuffer += ulCount;
    }
    else
    {
        // Sending a handle.        
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*(HANDLE *)pHBitmap);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshallWorker64
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);    

    stream.Align(8);

    // Get Discriminant and handle.
    unsigned long UnionDisc = stream.ReadULONGNA();
    HBITMAP hBitmap = (HBITMAP)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( GDI_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hBitmap )
        {
            DWORD    dwCount = (DWORD)stream.ReadHYPERNA();
            
            // Check for EOB before accessing metadata.
            ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof(WORD);
            stream.CheckSize(ulBmSize);

            BITMAP * pBm = (BITMAP *)stream.GetBuffer();
            // verify dwCount matches the bitmap.
            if ( dwCount != (DWORD) pBm->bmPlanes * pBm->bmHeight * pBm->bmWidthBytes )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            stream.Advance(ulBmSize);
            
            if (stream.ReadULONGNA() != dwCount)
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // Check for EOB before accessing data.
            stream.CheckSize(dwCount);

            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer
            hBitmap = CreateBitmap( pBm->bmWidth,
                                    pBm->bmHeight,
                                    pBm->bmPlanes,
                                    pBm->bmBitsPixel,
                                    stream.GetBuffer() );
            if (hBitmap == NULL)
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

            stream.Advance(dwCount);
        }
    }
    else 
    {
        if ( !IS_HANDLE64_MARKER( UnionDisc ) )
        {
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

        if ( GDI_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }
    
    // A new bitmap handle is ready, destroy the old one, if needed.
    if ( *pHBitmap )
        DeleteObject( *pHBitmap );

    *pHBitmap = hBitmap;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserUnmarshal\n"));
    
    // Get the buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();
    
    pBuffer = HBITMAP_UserUnmarshalWorker64( pFlags,
                                             pBufferStart,
                                             pHBitmap,
                                             BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserFree64
//
//  Synopsis:   Free an HBITMAP.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBITMAP_UserFree64 (
    unsigned long * pFlags,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserFree\n"));

    if( pHBitmap  &&  *pHBitmap )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteObject( *pHBitmap );
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\hglobal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       hglobal.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HGLOBAL.
//
//  Functions:  
//              HGLOBAL_UserSize
//              HGLOBAL_UserMarshal
//              HGLOBAL_UserUnmarshal
//              HGLOBAL_UserFree
//              HGLOBAL_UserSize64
//              HGLOBAL_UserMarshal64
//              HGLOBAL_UserUnmarshal64
//              HGLOBAL_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserSize
//
//  Synopsis:   Get the wire size the HGLOBAL handle and data.
//
//  Derivation: Conformant struct with a flag field:
//                  align + 12 + data size.
//
//  history:    May-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HGLOBAL_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return Offset;

    // userHGLOBAL: the encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    LENGTH_ALIGN( Offset, 3 );

    // Union discriminent is 4 bytes
    Offset += sizeof( long );

    // Handle represented by a polymorphic type - for inproc case only!
    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        LENGTH_ALIGN( Offset, sizeof( HGLOBAL )-1 );
        Offset += sizeof( HGLOBAL );
    }
    else
        Offset += ( sizeof(long) + sizeof(HGLOBAL) );
    
    if ( ! *pGlobal )
        return Offset;
    
    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        unsigned long   ulDataSize = (ULONG) GlobalSize( *pGlobal );
        
        Offset += 3 * sizeof(long) + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserMarshall
//
//  Synopsis:   Marshalls an HGLOBAL object into the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    May-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return pBuffer;

    // We marshal a null handle, too.

    UserNdrDebugOut((UNDR_OUT4, "HGLOBAL_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        unsigned long   ulDataSize;
        
        // userHGLOBAL
        
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pGlobal );
        
        
        if ( ! *pGlobal )
            return pBuffer;
        
        // FLAGGED_BYTE_BLOB

        ulDataSize = (ULONG) GlobalSize( *pGlobal );

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        // Handle is the non-null flag

        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pGlobal );
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if( ulDataSize )
        {
            void * pData = GlobalLock( *pGlobal);
            memcpy( pBuffer, pData, ulDataSize );
            GlobalUnlock( *pGlobal);
        }

        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.
        // For WIN64 HGLOBALs, 64 bits may by significant (e.i. GPTR).
#if defined(_WIN64)
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)pGlobal;
#else
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pGlobal );
#endif
    }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   WdtpGlobalUnmarshal
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  Note:       Reallocation is forbidden when the hglobal is part of
//              an [in,out] STGMEDIUM in IDataObject::GetDataHere.
//              This affects only data passing with old handles being
//              non null.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpGlobalUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal,
    BOOL            fCanReallocate,
    ULONG_PTR       BufferSize )
{
    unsigned long   ulDataSize, fHandle, UnionDisc;
    HGLOBAL         hGlobal;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get the tag from buffer.
    UnionDisc = *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
        {
            // Hey, you can't send us one of these!
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }


        // Get the marker from the buffer.
        hGlobal = (HGLOBAL) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
        
        // If handle is NULL, we are done.
        if ( ! hGlobal )
        {
            if ( *pGlobal )
                GlobalFree( *pGlobal );
            *pGlobal = NULL;
            return pBuffer;
        }

        // Check for EOB before accessing header.
        CHECK_BUFFER_SIZE( BufferSize, cbFixup + (5 * sizeof( ULONG )) );

        // Get the rest of the header from the buffer.
                ulDataSize    = *( PULONG_LV_CAST pBuffer)++;
        HGLOBAL hGlobalDup    = (HGLOBAL) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
        ULONG   ulDataSizeDup = *( PULONG_LV_CAST pBuffer)++;

        // Validate the header: handle and size are put on wire twice, make
        // sure both instances of each are the same.
        if ( (hGlobalDup != hGlobal) ||
             (ulDataSizeDup != ulDataSize) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( *pGlobal )
        {
            // Check for reallocation

            if ( GlobalSize( *pGlobal ) == ulDataSize )
                hGlobal = *pGlobal;
            else
            {
                if ( fCanReallocate )
                {
                    GlobalFree( *pGlobal );
                    hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
                }
                else
                {
                    if ( GlobalSize(*pGlobal) < ulDataSize )
                    {
                        RAISE_RPC_EXCEPTION( STG_E_MEDIUMFULL );
                    }
                    else
                        hGlobal = *pGlobal;
                }
            }
        }
        else
        {
            // allocate a new block            
            hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
        }
        
        if ( hGlobal == NULL )
        {
            RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
        }
        else
        {
            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE( BufferSize,
                               cbFixup + (5 * sizeof( ULONG )) + ulDataSize );
            
            // Get the data from the buffer.
            void * pData = GlobalLock( hGlobal);
            memcpy( pData, pBuffer, ulDataSize );
            pBuffer += ulDataSize;
            GlobalUnlock( hGlobal);
        }
    }
    else
    {
        // Sending a handle only.
        // Reallocation problem doesn't apply to handle passing.
        if ( HGLOBAL_DATA_PASSING(*pFlags) )
        {
            // Hey, you can't send us one of these!
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }
        
        if ( IS_HANDLE_MARKER( UnionDisc ) )
        {
            hGlobal = (HGLOBAL) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
        }
        else if (IS_HANDLE64_MARKER( UnionDisc ) )
        {
            ALIGN( pBuffer, 7 );
            
            // Must be enough buffer to do alignment fixup.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup +
                               (ULONG_PTR) (pBuffer - pBufferStart) + sizeof( __int64 ));
            
            hGlobal = (HGLOBAL) ( *( PHYPER_LV_CAST pBuffer)++ );
        }
        else
        {
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }
        
        if ( *pGlobal != hGlobal  && *pGlobal )
            GlobalFree( *pGlobal );
    }
    
    *pGlobal = hGlobal;
    
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = WdtpGlobalUnmarshal( pFlags,
                                   pBufferStart,
                                   pGlobal,
                                   TRUE,              // reallocation possible
                                   BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserFree
//
//  Synopsis:   Free an HGLOBAL.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HGLOBAL_UserFree(
    unsigned long * pFlags,
    HGLOBAL *       pGlobal)
{
    if( pGlobal  &&  *pGlobal )
    {
        if ( HGLOBAL_DATA_PASSING(*pFlags) )
            GlobalFree( *pGlobal);
    }
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserSize64
//
//  Synopsis:   Get the wire size the HGLOBAL handle and data.
//
//  Derivation: Union around a pointer to a conformant struct with a 
//              flag field.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HGLOBAL_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return Offset;

    // userHGLOBAL: the encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    // Union discriminent is 4 bytes, but it contains a pointer, so 
    // align on union is 8 bytes.
    LENGTH_ALIGN( Offset, 7 );   
    Offset += sizeof( long );
    LENGTH_ALIGN( Offset, 7 );

    // Handle represented by a polymorphic type - for inproc case only!
    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        // Doesn't matter which arm we take inproc, it's size of native
        // HGLOBAL.
        Offset += sizeof( HGLOBAL );
    }
    else
    {
        // Pointer representation...
        Offset += 8;
    }

    if ( ! *pGlobal )
        return Offset;

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        // Struct must be aligned on 8, but already aligned on 
        // 8...

        unsigned long   ulDataSize = (ULONG) GlobalSize( *pGlobal );
        
        Offset += 8 + 2 * sizeof(long) + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserMarshal64
//
//  Synopsis:   Marshalls an HGLOBAL object into the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return pBuffer;

    // We marshal a null handle, too.

    UserNdrDebugOut((UNDR_OUT4, "HGLOBAL_UserMarshal\n"));

    ALIGN( pBuffer, 7 );

    // Discriminant of the encapsulated union and union arm.
    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        unsigned long   ulDataSize;

        // userHGLOBAL
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)*pGlobal;

        if ( ! *pGlobal )
            return pBuffer;
        
        // FLAGGED_BYTE_BLOB
        ulDataSize = (ULONG) GlobalSize( *pGlobal );

        *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;

        // Handle is the non-null flag
        *( PLONG_LV_CAST pBuffer)++  = HandleToLong( *pGlobal );
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if( ulDataSize )
        {
            void * pData = GlobalLock( *pGlobal);
            memcpy( pBuffer, pData, ulDataSize );
            GlobalUnlock( *pGlobal);
        }

        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.
        // For WIN64 HGLOBALs, 64 bits may by significant (e.i. GPTR).
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)pGlobal;
    }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   WdtpGlobalUnmarshal64
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  Note:       Reallocation is forbidden when the hglobal is part of
//              an [in,out] STGMEDIUM in IDataObject::GetDataHere.
//              This affects only data passing with old handles being
//              non null.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpGlobalUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal,
    BOOL            fCanReallocate,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    unsigned long   ulDataSize, fHandle, UnionDisc;
    HGLOBAL         hGlobal;

    // Align the buffer and save the fixup size.
    stream.Align(8);

    // Get the tag from buffer.
    UnionDisc = stream.ReadULONGNA();

    // Get the marker from the buffer.
    hGlobal = (HGLOBAL)stream.ReadHYPER();

    if ( IS_DATA_MARKER(UnionDisc) )
    {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
        {
            // Hey, you can't send us one of these!
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }

        // If the handle was NULL, return out now.
        if (!hGlobal)
        {
            if (*pGlobal)
                GlobalFree(*pGlobal);
            *pGlobal = NULL;
            return stream.GetBuffer();
        }

        // Get the rest of the header from the buffer.
              ulDataSize    = (ULONG)stream.ReadHYPERNA();
         LONG hGlobalDup    = stream.ReadLONGNA();
        ULONG ulDataSizeDup = stream.ReadULONGNA();
            
        // Validate the header: handle and size are put on wire twice, make
        // sure both instances of each are the same.
        if ( (hGlobalDup != HandleToLong(hGlobal)) ||
             (ulDataSizeDup != ulDataSize) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        
        if ( *pGlobal )
        {
            // Check for reallocation            
            if ( GlobalSize( *pGlobal ) == ulDataSize )
                hGlobal = *pGlobal;
            else
            {
                if ( fCanReallocate )
                {
                    GlobalFree( *pGlobal );
                    hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
                }
                else
                {
                    if ( GlobalSize(*pGlobal) < ulDataSize )
                    {
                        RAISE_RPC_EXCEPTION( STG_E_MEDIUMFULL );
                    }
                    else
                        hGlobal = *pGlobal;
                }
            }
        }
        else
        {
            // allocate a new block            
            hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
        }
        
        if ( hGlobal == NULL )
        {
            RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
        }
        else
        {
            // Check for EOB before accessing data.
            stream.CheckSize(ulDataSize);
            
            // Get the data from the buffer.
            void * pData = GlobalLock( hGlobal);
            memcpy( pData, stream.GetBuffer(), ulDataSize );
            GlobalUnlock( hGlobal);
            
            stream.Advance(ulDataSize);
        }
    }
    else if (IS_HANDLE64_MARKER( UnionDisc ))
    {
        if ( HGLOBAL_DATA_PASSING(*pFlags) )
        {
            // Hey, you can't send us one of these!
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }

        // Make sure the old stuff is cleaned up...
        if ( *pGlobal != hGlobal  && *pGlobal )
            GlobalFree( *pGlobal );    
    }
    else
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }
    
    *pGlobal = hGlobal;
    
    return( stream.GetBuffer() );
}
    
//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = WdtpGlobalUnmarshal64( pFlags,
                                     pBufferStart,
                                     pGlobal,
                                     TRUE,              // reallocation possible
                                     BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserFree64
//
//  Synopsis:   Free an HGLOBAL.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

void __RPC_USER
HGLOBAL_UserFree64 (
    unsigned long * pFlags,
    HGLOBAL *       pGlobal)
{
    if( pGlobal  &&  *pGlobal )
    {
        if ( HGLOBAL_DATA_PASSING(*pFlags) )
            GlobalFree( *pGlobal);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\call_as.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       call_as.c
//
//  Contents:   [call_as] wrapper functions for COMMON\types.
//
//  Functions:  IAdviseSink2_OnLinkSrcChange_Proxy
//              IAdviseSink2_OnLinkSrcChange_Stub
//              IAdviseSink_OnDataChange_Proxy
//              IAdviseSink_OnDataChange_Stub
//              IAdviseSink_OnViewChange_Proxy
//              IAdviseSink_OnViewChange_Stub
//              IAdviseSink_OnRename_Proxy
//              IAdviseSink_OnRename_Stub
//              IAdviseSink_OnSave_Proxy
//              IAdviseSink_OnSave_Stub
//              IAdviseSink_OnClose_Proxy
//              IAdviseSink_OnClose_Stub
//              IBindCtx_GetBindOptions_Proxy
//              IBindCtx_GetBindOptions_Stub
//              IBindCtx_SetBindOptions_Proxy
//              IBindCtx_SetBindOptions_Stub
//              IClassFactory_CreateInstance_Proxy
//              IClassFactory_CreateInstance_Stub
//              IDataObject_GetData_Proxy
//              IDataObject_GetData_Stub
//              IDataObject_GetDataHere_Proxy
//              IDataObject_GetDataHere_Stub
//              IDataObject_SetData_Proxy
//              IDataObject_SetData_Stub
//              IEnumConnectionPoints_Next_Proxy
//              IEnumConnectionPoints_Next_Stub
//              IEnumConnections_Next_Proxy
//              IEnumConnections_Next_Stub
//              IEnumFORMATETC_Next_Proxy
//              IEnumFORMATETC_Next_Stub
//              IEnumMoniker_Next_Proxy
//              IEnumMoniker_Next_Stub
//              IEnumSTATDATA_Next_Proxy
//              IEnumSTATDATA_Next_Stub
//              IEnumSTATSTG_Next_Proxy
//              IEnumSTATSTG_Next_Stub
//              IEnumString_Next_Proxy
//              IEnumString_Next_Stub
//              IEnumUnknown_Next_Proxy
//              IEnumUnknown_Next_Stub
//              IEnumOLEVERB_Next_Proxy
//              IEnumOLEVERB_Next_Stub
//              ILockBytes_ReadAt_Proxy
//              ILockBytes_ReadAt_Stub
//              ILockBytes_WriteAt_Proxy
//              ILockBytes_WriteAt_Stub
//              IMoniker_BindToObject_Proxy
//              IMoniker_BindToObject_Stub
//              IMoniker_BindToStorage_Proxy
//              IMoniker_BindToStorage_Stub
//              IClientSiteHandler_PrivQueryInterface_Proxy
//              IClientSiteHandler_PrivQueryInterface_Stub
//              IOleInPlaceActiveObject_TranslateAccelerator_Proxy
//              IOleInPlaceActiveObject_TranslateAccelerator_Stub
//              IOleInPlaceActiveObject_ResizeBorder_Proxy
//              IOleInPlaceActiveObject_ResizeBorder_Stub
//              IRunnableObject_IsRunning_Proxy
//              IRunnableObject_IsRunning_Stub
//              IStorage_OpenStream_Proxy
//              IStorage_OpenStream_Stub
//              IStorage_EnumElements_Proxy
//              IStorage_EnumElements_Stub
//              ISequentialStream_Read_Proxy
//              ISequentialStream_Read_Stub
//              IStream_Seek_Proxy
//              IStream_Seek_Stub
//              ISequentialStream_Write_Proxy
//              ISequentialStream_Write_Stub
//              IStream_CopyTo_Proxy
//              IStream_CopyTo_Stub
//              IOverlappedStream_ReadOverlapped_Proxy
//              IOverlappedStream_ReadOverlapped_Stub
//              IOverlappedStream_WriteOverlapped_Proxy
//              IOverlappedStream_WriteOverlapped_Stub
//              IEnumSTATPROPSTG_Next_Proxy
//              IEnumSTATPROPSTG_Next_Stub
//              IEnumSTATPROPSETSTG_Next_Proxy
//              IEnumSTATPROPSETSTG_Next_Stub
//
//
//  History:    May-01-94   ShannonC    Created
//              Jul-10-94   ShannonC    Fix memory leak (bug #20124)
//              Aug-09-94   AlexT       Add ResizeBorder proxy, stub
//              Apr-25-95   RyszardK    Rewrote STGMEDIUM support
//              Nov-03-95   JohannP     Added IClientSite proxy, stub
//
//--------------------------------------------------------------------------

#include <rpcproxy.h>
#include <debnot.h>
#include "mega.h"
#include "transmit.h"
#include "stdidx.h"

#pragma code_seg(".orpc")

#define ASSERT(expr) Win4Assert(expr)

HRESULT CreateCallback(
    BOOL (STDMETHODCALLTYPE *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue,
    IContinue **ppContinue);

BOOL    CoIsSurrogateProcess();
HRESULT CoRegisterSurrogatedObject(IUnknown *pObject);

// The following is needed to avoid the async path when calling IAdviseSink 
// notifications cross-context. The async approach causes problems in the 
// cross-context case since the wrapper calls the real object and if it 
// implements IID_ICallFactory, creates a proxy for it. The proxy is basically
// useless since ICallFactory is a [local] interface. So the notification
// does not make it through to the other side.

DEFINE_OLEGUID(IID_IStdIdentity,        0x0000001bL, 0, 0);

BOOL IsStdIdentity(IAdviseSink* This)
{
    void *pStdId;

    if (SUCCEEDED( This->lpVtbl->QueryInterface(This, &IID_IStdIdentity, &pStdId) ))
    {
        ((IUnknown *)pStdId)->lpVtbl->Release(pStdId);
        return TRUE;   
    }
    return FALSE;   //not an StdIdentity
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink2_OnLinkSrcChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink2::OnLinkSrcChange.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink2_OnLinkSrcChange_Proxy(
    IAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink2_RemoteOnLinkSrcChange_Proxy(This, pmk);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink2 *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink2, NULL, 
                                                    &IID_AsyncIAdviseSink2, (LPUNKNOWN *) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnLinkSrcChange(pAAS, pmk);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink2_OnLinkSrcChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink2::OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink2_OnLinkSrcChange_Stub(
    IAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->OnLinkSrcChange(This, pmk);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Begin_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy(
    AsyncIAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Proxy(This, pmk);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Finish_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy(
    AsyncIAdviseSink2 __RPC_FAR * This)
{
    AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Begin_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub(
    AsyncIAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->Begin_OnLinkSrcChange(This, pmk);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Finish_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub(
    AsyncIAdviseSink2 __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnLinkSrcChange(This);
    return S_OK;

}



////////////////////////////////////////////////////////////////////////////////////////



//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnDataChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnDataChange.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnDataChange_Proxy(
    IAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)

{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnDataChange_Proxy(This, pFormatetc, pStgmed);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnDataChange(pAAS, pFormatetc, pStgmed);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);  
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnDataChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnDataChange_Stub(
    IAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)
{
    This->lpVtbl->OnDataChange(This, pFormatetc, pStgmed);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnDataChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnDataChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)
{
    AsyncIAdviseSink_Begin_RemoteOnDataChange_Proxy(This, pFormatetc, pStgmed);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnDataChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnDataChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnDataChange_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnDataChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnDataChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)
{
    This->lpVtbl->Begin_OnDataChange(This, pFormatetc, pStgmed);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnDataChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnDataChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnDataChange(This);
    return S_OK;

}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////



//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnViewChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnViewChange.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnViewChange_Proxy(
    IAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnViewChange_Proxy(This, dwAspect, lindex);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnViewChange(pAAS, dwAspect, lindex);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);            
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnViewChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnViewChange_Stub(
    IAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    This->lpVtbl->OnViewChange(This, dwAspect, lindex);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnViewChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnViewChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    AsyncIAdviseSink_Begin_RemoteOnViewChange_Proxy(This, dwAspect, lindex);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnViewChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnViewChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnViewChange_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnViewChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnViewChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    This->lpVtbl->Begin_OnViewChange(This, dwAspect, lindex);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnViewChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnViewChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnViewChange(This);
    return S_OK;

}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnRename_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnRename.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnRename_Proxy(
    IAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnRename_Proxy(This, pmk);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnRename(pAAS, pmk);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnRename_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnRename_Stub(
    IAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->OnRename(This, pmk);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnRename_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnRename_Proxy(
    AsyncIAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)

{
    AsyncIAdviseSink_Begin_RemoteOnRename_Proxy(This, pmk);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnRename_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnRename_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnRename_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnRename_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnRename_Stub(
    AsyncIAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->Begin_OnRename(This, pmk);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnRename_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnRename_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnRename(This);
    return S_OK;

}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnSave_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnSave.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnSave_Proxy(
    IAdviseSink __RPC_FAR * This)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnSave_Proxy(This);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnSave(pAAS);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnSave_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnSave_Stub(
    IAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->OnSave(This);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnSave_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnSave_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Begin_RemoteOnSave_Proxy(This);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnSave_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnSave_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnSave_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnSave_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnSave_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Begin_OnSave(This);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnSave_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnSave_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnSave(This);
    return S_OK;

}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnClose_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnClose.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnClose_Proxy(
    IAdviseSink __RPC_FAR * This)
{
    __try
    {
        // ignore the HRESULT return
        IAdviseSink_RemoteOnClose_Proxy(This);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnClose_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnClose_Stub(
    IAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->OnClose(This);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnClose_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnClose_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Begin_RemoteOnClose_Proxy(This);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnClose_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnClose_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnClose_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnClose_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnClose_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Begin_OnClose(This);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnClose_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnClose_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnClose(This);
    return S_OK;

}

////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_GetBindOptions_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IBindCtx::GetBindOptions.
//
//  Returns:    S_OK
//
//  Notes:      If the caller's BIND_OPTS is smaller than the current
//              BIND_OPTS definition, then we must truncate the results
//              so that we don't go off the end of the structure.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_GetBindOptions_Proxy(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS __RPC_FAR *pbindopts)
{
    HRESULT hr;

    if(pbindopts->cbStruct >= sizeof(BIND_OPTS2))
    {
        hr = IBindCtx_RemoteGetBindOptions_Proxy(This, (BIND_OPTS2 *) pbindopts);
    }
    else
    {
        BIND_OPTS2 bindOptions;

        //The pbindopts supplied by the caller is too small.
        //We need a BIND_OPTS2 for the marshalling code.
        memset(&bindOptions, 0, sizeof(BIND_OPTS2));
        memcpy(&bindOptions, pbindopts, pbindopts->cbStruct);

        hr = IBindCtx_RemoteGetBindOptions_Proxy(This, &bindOptions);

        if(SUCCEEDED(hr))
        {
            memcpy(pbindopts, &bindOptions, pbindopts->cbStruct);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_GetBindOptions_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IBindCtx::GetBindOptions.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_GetBindOptions_Stub(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS2 __RPC_FAR *pbindopts)
{
    HRESULT hr;

    //make sure we don't request more data than we can handle.
    if(pbindopts->cbStruct > sizeof(BIND_OPTS2))
    {
        pbindopts->cbStruct = sizeof(BIND_OPTS2);
    }

    hr = This->lpVtbl->GetBindOptions(This, (BIND_OPTS *)pbindopts);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_SetBindOptions_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IBindCtx::SetBindOptions.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_SetBindOptions_Proxy(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS __RPC_FAR *pbindopts)
{
    HRESULT hr;

    if(sizeof(BIND_OPTS2) == pbindopts->cbStruct)
    {
        hr = IBindCtx_RemoteSetBindOptions_Proxy(This, (BIND_OPTS2 *) pbindopts);
    }
    else if(sizeof(BIND_OPTS2) > pbindopts->cbStruct)
    {
        BIND_OPTS2 bindOptions;

        memset(&bindOptions, 0, sizeof(bindOptions));
        memcpy(&bindOptions, pbindopts, pbindopts->cbStruct);
        hr = IBindCtx_RemoteSetBindOptions_Proxy(This, &bindOptions);
    }
    else
    {
        //The caller's BIND_OPTS is too large.
        //We don't want to truncate, so we return an error.
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_SetBindOptions_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IBindCtx::SetBindOptions.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_SetBindOptions_Stub(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS2 __RPC_FAR *pbindopts)
{
    HRESULT hr;

    hr = This->lpVtbl->SetBindOptions(This, (BIND_OPTS *)pbindopts);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_CreateInstance_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IClassFactory::CreateInstance.
//
//  Returns:    CLASS_E_NO_AGGREGREGRATION - if punkOuter != 0.
//              Any errors returned by Remote_CreateInstance_Proxy.
//              Any errors from QI() on Proxy IUnknown for local interfaces.
//
//  Notes:      We don't support remote aggregation. punkOuter must be zero.
//
//              If the interface being created is implemented on the proxy,
//              we create the object and then QI() the proxy returned to us
//              for the interface.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Proxy(
    IClassFactory __RPC_FAR * This,
    IUnknown __RPC_FAR *pUnkOuter,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
    HRESULT hr;

    *ppvObject = 0;

    if(pUnkOuter != 0)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else 
    {
        BOOL fIsOnProxy = IsInterfaceImplementedByProxy(riid);
        IUnknown* pUnk = NULL;

        hr = IClassFactory_RemoteCreateInstance_Proxy(This, 
                                                      fIsOnProxy ? &IID_IUnknown : riid,
                                                      &pUnk);
        if ( fIsOnProxy && SUCCEEDED(hr) && pUnk != NULL)
        {
            hr = pUnk->lpVtbl->QueryInterface(pUnk, riid, ppvObject);
            pUnk->lpVtbl->Release(pUnk);
        }
        else
        {
            *ppvObject = (void*) pUnk;
        }
    }

    return hr;

}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_CreateInstance_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IClassFactory::CreateInstance.
//
//  Returns:    Any errors returned by CreateInstance.
//
//  Notes:      We don't support remote aggregation.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Stub(
    IClassFactory __RPC_FAR * This,
    REFIID riid,
    IUnknown __RPC_FAR *__RPC_FAR *ppvObject)
{
    HRESULT hr;

    hr = This->lpVtbl->CreateInstance(This, 0, riid, ppvObject);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppvObject to zero.
        ASSERT(*ppvObject == 0);

        //Set it to zero, in case we have a badly behaved server.
        *ppvObject = 0;
    }
    else if (S_OK == hr && CoIsSurrogateProcess())
    {
        // Don't worry about any errors.  The worst that will happen is that
        // keyboard accelerators won't work.
        CoRegisterSurrogatedObject(*ppvObject);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_LockServer_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IClassFactory::LockServer.
//
//  Returns:    S_OK
//
//  Notes:      The server activation code does an implicit LockServer(TRUE)
//              when it marshals the class object, and an implicit
//              LockServer(FALSE) when the client releases it, so calls
//              made by the client are ignored.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Proxy(
    IClassFactory __RPC_FAR * This,
    BOOL fLock)
{
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_LockServer_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IClassFactory::LockServer.
//
//  Returns:    S_OK
//
//  Notes:      The server activation code does an implicit LockServer(TRUE)
//              when it marshals the class object, and an implicit
//              LockServer(FALSE) when the client releases it, so calls
//              made by the client are ignored.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Stub(
    IClassFactory __RPC_FAR * This,
    BOOL fLock)
{
    return This->lpVtbl->LockServer(This, fLock);
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetData_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::GetData.
//              pMedium is [out] only.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetData_Proxy(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetcIn,
    STGMEDIUM __RPC_FAR *pMedium)
{
    HRESULT hr;

    UserNdrDebugOut((UNDR_FORCE, "==GetData_Proxy\n"));

    WdtpZeroMemory( pMedium, sizeof(STGMEDIUM) );
    hr = IDataObject_RemoteGetData_Proxy(This, pformatetcIn, pMedium);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetData_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IDataObject::GetData.
//              pMedium is [out] only.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetData_Stub(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetcIn,
    STGMEDIUM __RPC_FAR * pMedium)
{
    HRESULT hr;

    UserNdrDebugOut((UNDR_FORCE, "==GetData_Stub\n"));

    hr = This->lpVtbl->GetData(This, pformatetcIn, pMedium);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetDataHere_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::GetDataHere.
//              pMedium is [in,out].
//
//  History:    05-19-94  AlexT     Handle all cases correctly
//
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetDataHere_Proxy(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    STGMEDIUM __RPC_FAR *pmedium)
{
    HRESULT   hr;
    IUnknown * punkSaved;
    IStorage * pStgSaved = NULL;

    UserNdrDebugOut((UNDR_FORCE, "==GetDataHere_Proxy: %s\n", WdtpGetStgmedName(pmedium)));

    if ((pmedium->tymed &
         (TYMED_FILE | TYMED_ISTORAGE | TYMED_ISTREAM | TYMED_HGLOBAL)) == 0)
    {
        //  We only support GetDataHere for files, storages, streams,
        //  and HGLOBALs

        return(DV_E_TYMED);
    }

    if (pmedium->tymed != pformatetc->tymed)
    {
        //  tymeds must match!
        return(DV_E_TYMED);
    }

    // NULL the pUnkForRelease. It makes no sense to pass this parameter
    // since the callee will never call it.  NULLing saves all the marshalling
    // and associated Rpc calls, and reduces complexity in this code.

    punkSaved = pmedium->pUnkForRelease;
    pmedium->pUnkForRelease = NULL;

    // This is a hack to make Exchange 8.0.829.1 work HenryLee 04/18/96
    // So probably can't remove it now JohnDoty 04/24/00
    if (pmedium->tymed == TYMED_ISTORAGE || pmedium->tymed == TYMED_ISTREAM)
    {
        pStgSaved = pmedium->pstg;
        if (pStgSaved)
            pStgSaved->lpVtbl->AddRef(pStgSaved);     // save the old pointer
    }

    hr = IDataObject_RemoteGetDataHere_Proxy(This, pformatetc, pmedium );

    pmedium->pUnkForRelease = punkSaved;

    if (pStgSaved != NULL)
    {
        if (pmedium->pstg != NULL)                       // discard the new one
           (pmedium->pstg)->lpVtbl->Release(pmedium->pstg);
        pmedium->pstg = pStgSaved;                       // restore old one
    }

    if(SUCCEEDED(hr) )
        {
        UserNdrDebugOut((UNDR_FORCE, "  (GetDataHere_ProxyO: new if ptr)\n"));
        }
    else
        UserNdrDebugOut((UNDR_FORCE, "  (GetDataHere_ProxyO: didn't succeed : %lx)\n", hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetDataHere_Stub
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::GetData.
//              pMedium is [in,out].
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetDataHere_Stub(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    STGMEDIUM __RPC_FAR * pMedium)
{
    HRESULT hr;

    UserNdrDebugOut((UNDR_FORCE, "==GetDataHere_Stub: %s\n", WdtpGetStgmedName(pMedium)));

    hr = This->lpVtbl->GetDataHere(This, pformatetc, pMedium);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_SetData_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::SetData.
//              This wrapper function uses FLAG_STGMEDIUM type.
//              pMedium is [in].
//
//  Notes:      If fRelease is TRUE, then the callee is responsible for
//              freeing the STGMEDIUM.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_SetData_Proxy(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    STGMEDIUM __RPC_FAR *pmedium,
    BOOL fRelease)
{
    HRESULT hr;
    FLAG_STGMEDIUM   RemoteStgmed;

    UserNdrDebugOut((UNDR_FORCE, "  SetData_Proxy %s\n", WdtpGetStgmedName(pmedium)));
    UserNdrDebugOut((UNDR_FORCE, "      fRelease=%d, punk=%p\n", fRelease, pmedium->pUnkForRelease));

    __try
    {
        RemoteStgmed.ContextFlags = 0;
        RemoteStgmed.fPassOwnership = fRelease;
        RemoteStgmed.Stgmed = *pmedium;

        hr = IDataObject_RemoteSetData_Proxy( This,
                                              pformatetc,
                                              & RemoteStgmed,
                                              fRelease);

        if (fRelease && SUCCEEDED(hr))
        {
            // Caller has given ownership to callee.
            // Free the resources left on this side.
            // Context flags have been set by the unmarshalling routine.

            if ( pmedium->tymed != TYMED_FILE )
                STGMEDIUM_UserFree( &RemoteStgmed.ContextFlags, pmedium );
            else
                {
                // For files, STGMEDIUM_UserFree dereferences pStubMsg via pFlags
                // to get to the right freeing routine. As the StubMsg is gone,
                // we need to free the file here.

                NdrOleFree( pmedium->lpszFileName );
                NukeHandleAndReleasePunk( pmedium );
                }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DWORD dwExceptionCode = GetExceptionCode();

        if(FAILED((HRESULT) dwExceptionCode))
            hr = (HRESULT) dwExceptionCode;
        else
            hr = HRESULT_FROM_WIN32(dwExceptionCode);
    }

    UserNdrDebugOut((UNDR_FORCE, "  SetData_Proxy hr=%lx\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_SetData_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IDataObject::SetData.
//              pMedium is [in].
//
//  Notes:      If fRelease is TRUE, then the callee is responsible for
//              freeing the STGMEDIUM.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_SetData_Stub(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    FLAG_STGMEDIUM __RPC_FAR *pFlagStgmed,
    BOOL fRelease)
{
    HRESULT     hr;
    STGMEDIUM   Stgmed;

    __try
    {
        Stgmed = pFlagStgmed->Stgmed;

        UserNdrDebugOut((UNDR_FORCE, "  SetData_Stub %s\n", WdtpGetStgmedName(& Stgmed)));
        UserNdrDebugOut((UNDR_FORCE, "      fRelease=%d, punk=%p\n", fRelease, Stgmed.pUnkForRelease));


        hr = This->lpVtbl->SetData( This,
                                    pformatetc,
                                    & Stgmed,
                                    fRelease);

        if ( fRelease && SUCCEEDED(hr) )
            {
            // The ownership was passed successfully.
            // The user should free the object.
            // Make it so that our userfree routine for user medium
            // doesn't do anything to the user's object.

            pFlagStgmed->Stgmed.tymed = TYMED_NULL;
            }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DWORD dwExceptionCode = GetExceptionCode();

        if(FAILED((HRESULT) dwExceptionCode))
            hr = (HRESULT) dwExceptionCode;
        else
            hr = HRESULT_FROM_WIN32(dwExceptionCode);
    }


    UserNdrDebugOut((UNDR_FORCE, "  SetData_Stub hr=%lx\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnectionPoints_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumConnectionPoints::Next.  This wrapper function handles the
//              case where lpcFetched is NULL.
//
//  Notes:      If lpcFetched != 0, then the number of elements
//              fetched will be returned in *lpcFetched.  If an error
//              occurs, then *lpcFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnectionPoints_Next_Proxy(
    IEnumConnectionPoints __RPC_FAR * This,
    ULONG cConnections,
    IConnectionPoint __RPC_FAR *__RPC_FAR *rgpcn,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;
    ULONG cFetched = 0;

    if((cConnections > 1) && (lpcFetched == 0))
        return E_INVALIDARG;

    hr = IEnumConnectionPoints_RemoteNext_Proxy(This, cConnections, rgpcn, &cFetched);

    if(lpcFetched != 0)
        *lpcFetched = cFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnectionPoints_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumConnectionPoints::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnectionPoints_Next_Stub(
    IEnumConnectionPoints __RPC_FAR * This,
    ULONG cConnections,
    IConnectionPoint __RPC_FAR *__RPC_FAR *rgpcn,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, cConnections, rgpcn, lpcFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *lpcFetched to zero.
        ASSERT(*lpcFetched == 0);

        //Set *lpcFetched to zero in case we have a badly behaved server.
        *lpcFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnections_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumConnections::Next.  This wrapper function handles the
//              case where lpcFetched is NULL.
//
//  Notes:      If lpcFetched != 0, then the number of elements
//              fetched will be returned in *lpcFetched.  If an error
//              occurs, then *lpcFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnections_Next_Proxy(
    IEnumConnections __RPC_FAR * This,
    ULONG cConnections,
    CONNECTDATA __RPC_FAR *rgpunk,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;
    ULONG cFetched = 0;

    if((cConnections > 1) && (lpcFetched == 0))
        return E_INVALIDARG;

    hr = IEnumConnections_RemoteNext_Proxy(This, cConnections, rgpunk, &cFetched);

    if(lpcFetched != 0)
        *lpcFetched = cFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnections_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumConnections::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnections_Next_Stub(
    IEnumConnections __RPC_FAR * This,
    ULONG cConnections,
    CONNECTDATA __RPC_FAR *rgpunk,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, cConnections, rgpunk, lpcFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *lpcFetched to zero.
        ASSERT(*lpcFetched == 0);

        //Set *lpcFetched to zero in case we have a badly behaved server.
        *lpcFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumFORMATETC_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumFORMATETC::Next.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Next_Proxy(
    IEnumFORMATETC __RPC_FAR * This,
    ULONG celt,
    FORMATETC __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumFORMATETC_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumFORMATETC_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumFORMATETC::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Next_Stub(
    IEnumFORMATETC __RPC_FAR * This,
    ULONG celt,
    FORMATETC __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumMoniker_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumMoniker::Next.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumMoniker_Next_Proxy(
    IEnumMoniker __RPC_FAR * This,
    ULONG celt,
    IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumMoniker_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumMoniker_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumMoniker::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumMoniker_Next_Stub(
    IEnumMoniker __RPC_FAR * This,
    ULONG celt,
    IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATDATA_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumSTATDATA::Next.  This wrapper function handles the
//              case where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Next_Proxy(
    IEnumSTATDATA __RPC_FAR * This,
    ULONG celt,
    STATDATA __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATDATA_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATDATA_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumSTATDATA::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Next_Stub(
    IEnumSTATDATA __RPC_FAR * This,
    ULONG celt,
    STATDATA __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATSTG_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumSTATSTG::Next.  This wrapper function handles the case
//              where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Next_Proxy(
    IEnumSTATSTG __RPC_FAR * This,
    ULONG celt,
    STATSTG __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATSTG_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATSTG_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumSTATSTG::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Next_Stub(
    IEnumSTATSTG __RPC_FAR * This,
    ULONG celt,
    STATSTG __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumString_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumString::Next.  This wrapper function handles the
//              case where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumString_Next_Proxy(
    IEnumString __RPC_FAR * This,
    ULONG celt,
    LPOLESTR __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumString_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumString_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumString::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumString_Next_Stub(
    IEnumString __RPC_FAR * This,
    ULONG celt,
    LPOLESTR __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumUnknown_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumUnknown::Next.  This wrapper function handles the
//              case where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumUnknown_Next_Proxy(
    IEnumUnknown __RPC_FAR * This,
    ULONG celt,
    IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumUnknown_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumUnknown_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumUnknown::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumUnknown_Next_Stub(
    IEnumUnknown __RPC_FAR * This,
    ULONG celt,
    IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumOLEVERB_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumOLEVERB::Next.  This wrapper function handles the case
//              where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumOLEVERB_Next_Proxy(
    IEnumOLEVERB __RPC_FAR * This,
    ULONG celt,
    LPOLEVERB rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumOLEVERB_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumOLEVERB_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumOLEVERB::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumOLEVERB_Next_Stub(
    IEnumOLEVERB __RPC_FAR * This,
    ULONG celt,
    LPOLEVERB rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_ReadAt_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ILockBytes::ReadAt.  This wrapper function
//              handles the case where pcbRead is NULL.
//
//  Notes:      If pcbRead != 0, then the number of bytes read
//              will be returned in *pcbRead.  If an error
//              occurs, then *pcbRead is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_ReadAt_Proxy(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;
    ULONG cbRead = 0;

    hr = ILockBytes_RemoteReadAt_Proxy(This, ulOffset, (byte __RPC_FAR *) pv, cb, &cbRead);

    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_ReadAt_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ILockBytes::ReadAt.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_ReadAt_Stub(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;

    *pcbRead = 0;
    hr = This->lpVtbl->ReadAt(This, ulOffset, (void __RPC_FAR *) pv, cb, pcbRead);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_WriteAt_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ILockBytes::WriteAt.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//  History:    ?        ?          Created
//              05-27-94 AlexT      Actually return count of bytes written
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_WriteAt_Proxy(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = ILockBytes_RemoteWriteAt_Proxy(This, ulOffset, (byte __RPC_FAR *)pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_WriteAt_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ILockBytes::WriteAt.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_WriteAt_Stub(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->WriteAt(This, ulOffset, pv, cb, pcbWritten);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToObject_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IMoniker::BindToObject.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToObject_Proxy(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    *ppvObj = 0;

    hr = IMoniker_RemoteBindToObject_Proxy(
        This, pbc, pmkToLeft, riid, (IUnknown **) ppvObj);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToObject_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IMoniker::BindToObject.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToObject_Stub(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    IUnknown __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    hr = This->lpVtbl->BindToObject(
        This, pbc, pmkToLeft, riid, (void **) ppvObj);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppvObj to zero.
        ASSERT(*ppvObj == 0);

        //Set it to zero in case we have a badly behaved server.
        *ppvObj = 0;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToStorage_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IMoniker::BindToStorage.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToStorage_Proxy(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    *ppvObj = 0;

    hr = IMoniker_RemoteBindToStorage_Proxy(
        This, pbc, pmkToLeft, riid, (IUnknown **)ppvObj);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToStorage_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IMoniker::BindToStorage.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToStorage_Stub(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    IUnknown __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    hr = This->lpVtbl->BindToStorage(
        This, pbc, pmkToLeft, riid, (void **) ppvObj);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppvObj to zero.
        ASSERT(*ppvObj == 0);

        //Set it to zero in case we have a badly behaved server.
        *ppvObj = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleCache2_UpdateCache_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IOleCache2:UpdateCache
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleCache2_UpdateCache_Proxy(
    IOleCache2 __RPC_FAR * This,
    LPDATAOBJECT pDataObject,
    DWORD grfUpdf,
    LPVOID pReserved)
{
    HRESULT hr;
    hr = IOleCache2_RemoteUpdateCache_Proxy(This,
                                            pDataObject,
                                            grfUpdf,
                                            (LONG_PTR) pReserved);
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IOleCache2_UpdateCache_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IOleCache2::UpdateCache.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleCache2_UpdateCache_Stub(
    IOleCache2 __RPC_FAR * This,
    LPDATAOBJECT pDataObject,
    DWORD grfUpdf,
    LONG_PTR pReserved)
{
    HRESULT hr;
    hr = This->lpVtbl->UpdateCache(This,
                                   pDataObject,
                                   grfUpdf,
                                   (void *)pReserved);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_TranslateAccelerator_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::TranslateAccelerator.
//
//  Returns:    This function always returns S_FALSE.
//
//  Notes:      A container needs to process accelerators differently
//              depending on whether an inplace server is running
//              in process or as a local server.  When the container
//              calls IOleInPlaceActiveObject::TranslateAccelerator on
//              an inprocess server, the server can return S_OK if it
//              successfully translated the message.  When the container
//              calls IOleInPlaceActiveObject::TranslateAccelerator on
//              a local server, the proxy will always return S_FALSE.
//              In other words, a local server never gets the opportunity
//              to translate messages from the container.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_TranslateAccelerator_Proxy(
    IOleInPlaceActiveObject __RPC_FAR * This,
    LPMSG lpmsg)
{
    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_TranslateAccelerator_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::TranslateAccelerator
//
//  Notes:      This function should never be called.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_TranslateAccelerator_Stub(
    IOleInPlaceActiveObject __RPC_FAR * This)
{
    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_ResizeBorder_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::ResizeBorder
//
//  Notes:      The pUIWindow interface is either an IOleInPlaceUIWindow or
//              an IOleInPlaceFrame, based on fFrameWindow.  We use
//              fFrameWindow to tell the proxy exactly which interace it
//              is so that it gets marshalled and unmarshalled correctly.
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_ResizeBorder_Proxy(
    IOleInPlaceActiveObject __RPC_FAR * This,
    LPCRECT prcBorder,
    IOleInPlaceUIWindow *pUIWindow,
    BOOL fFrameWindow)
{
    HRESULT hr;
    REFIID riid;

    if (fFrameWindow)
    {
        riid = &IID_IOleInPlaceFrame;
    }
    else
    {
        riid = &IID_IOleInPlaceUIWindow;
    }

    hr = IOleInPlaceActiveObject_RemoteResizeBorder_Proxy(
             This, prcBorder, riid, pUIWindow, fFrameWindow);

    return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_ResizeBorder_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::ResizeBorder
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_ResizeBorder_Stub(
    IOleInPlaceActiveObject __RPC_FAR * This,
    LPCRECT prcBorder,
    REFIID riid,
    IOleInPlaceUIWindow *pUIWindow,
    BOOL fFrameWindow)
{
    HRESULT hr;

    hr = This->lpVtbl->ResizeBorder(This, prcBorder, pUIWindow, fFrameWindow);

    return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   IStorage_OpenStream_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStorage::OpenStream.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_OpenStream_Proxy(
    IStorage __RPC_FAR * This,
    const OLECHAR __RPC_FAR *pwcsName,
    void __RPC_FAR *pReserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr;

#if DBG == 1
    if(pReserved1 != 0)
        return STG_E_INVALIDPARAMETER;
#endif

    *ppstm = 0;

    hr = IStorage_RemoteOpenStream_Proxy(
        This, pwcsName, 0, 0, grfMode, reserved2, ppstm);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IStorage_OpenStream_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStorage::OpenStream.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_OpenStream_Stub(
    IStorage __RPC_FAR * This,
    const OLECHAR __RPC_FAR *pwcsName,
    unsigned long cbReserved1,
    byte __RPC_FAR *reserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr;


    hr = This->lpVtbl->OpenStream(This, pwcsName, 0, grfMode, reserved2, ppstm);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppstm to zero.
        ASSERT(*ppstm == 0);

        //Set *ppstm to zero in case we have a badly behaved server.
        *ppstm = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IStorage_EnumElements_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStorage_EnumElements_Proxy
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_EnumElements_Proxy(
    IStorage __RPC_FAR * This,
    DWORD reserved1,
    void __RPC_FAR *reserved2,
    DWORD reserved3,
    IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    HRESULT hr;

    *ppenum = 0;

    hr = IStorage_RemoteEnumElements_Proxy(
        This, reserved1, 0, 0, reserved3, ppenum);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IStorage_EnumElements_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStorage::EnumElements.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_EnumElements_Stub(
    IStorage __RPC_FAR * This,
    DWORD reserved1,
    unsigned long cbReserved2,
    byte __RPC_FAR *reserved2,
    DWORD reserved3,
    IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    HRESULT hr;

    hr = This->lpVtbl->EnumElements(This, reserved1, 0, reserved3, ppenum);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppenum to zero.
        ASSERT(*ppenum == 0);

        //Set *ppenum to zero in case we have a badly behaved server.
        *ppenum = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IRunnableObject_IsRunning_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IRunnableObject::IsRunning.
//
//--------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE IRunnableObject_IsRunning_Proxy(
    IRunnableObject __RPC_FAR * This)
{
    BOOL bIsRunning = TRUE;
    HRESULT hr;

    hr = IRunnableObject_RemoteIsRunning_Proxy(This);

    if(S_FALSE == hr)
        bIsRunning = FALSE;

    return bIsRunning;
}

//+-------------------------------------------------------------------------
//
//  Function:   IRunnableObject_IsRunning_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IRunnableObject::IsRunning.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IRunnableObject_IsRunning_Stub(
    IRunnableObject __RPC_FAR * This)
{
    HRESULT hr;
    BOOL bIsRunning;

    bIsRunning = This->lpVtbl->IsRunning(This);

    if(TRUE == bIsRunning)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Read_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::Read.  This wrapper function handles the case
//              where pcbRead is NULL.
//
//  Notes:      If pcbRead != 0, then the number of bytes read
//              will be returned in *pcbRead.  If an error
//              occurs, then *pcbRead is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Read_Proxy(
    ISequentialStream __RPC_FAR * This,
    void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;
    ULONG cbRead = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif //DBG == 1

    hr = ISequentialStream_RemoteRead_Proxy(This, (byte *) pv, cb, &cbRead);

    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Read_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStream::Read.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Read_Stub(
    ISequentialStream __RPC_FAR * This,
    byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;

    *pcbRead = 0;
    hr = This->lpVtbl->Read(This, (void *) pv, cb, pcbRead);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IStream_Seek_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::Seek.  This wrapper function handles the case
//              where plibNewPosition is NULL.
//
//  Notes:      If plibNewPosition != 0, then the new position
//              will be returned in *plibNewPosition.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_Seek_Proxy(
    IStream __RPC_FAR * This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
    HRESULT hr;
    ULARGE_INTEGER libNewPosition;

    hr = IStream_RemoteSeek_Proxy(This, dlibMove, dwOrigin, &libNewPosition);

    if(plibNewPosition != 0)
    {
        *plibNewPosition = libNewPosition;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IStream_Seek_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStream::Seek.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_Seek_Stub(
    IStream __RPC_FAR * This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
    HRESULT hr;

    hr = This->lpVtbl->Seek(This, dlibMove, dwOrigin, plibNewPosition);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Write_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::Write.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Write_Proxy(
    ISequentialStream __RPC_FAR * This,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = ISequentialStream_RemoteWrite_Proxy(This, (byte *) pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Write_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ISequentialStream::Write.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Write_Stub(
    ISequentialStream __RPC_FAR * This,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->Write(This, (const void __RPC_FAR *) pv, cb, pcbWritten);

    return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   IStream_CopyTo_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::CopyTo.  This wrapper function handles the
//              cases where pcbRead is NULL or pcbWritten is NULL.
//
//  Notes:      If pcbRead != 0, then the number of bytes read
//              will be returned in *pcbRead.  If an error
//              occurs, then *pcbRead is set to zero.
//
//              If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_CopyTo_Proxy(
    IStream __RPC_FAR * This,
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULARGE_INTEGER cbRead;
    ULARGE_INTEGER cbWritten;

    cbRead.LowPart = 0;
    cbRead.HighPart = 0;
    cbWritten.LowPart = 0;
    cbWritten.HighPart = 0;

    hr = IStream_RemoteCopyTo_Proxy(This, pstm, cb, &cbRead, &cbWritten);

    if(pcbRead != 0)
        *pcbRead = cbRead;

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IStream_CopyTo_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStream::CopyTo.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_CopyTo_Stub(
    IStream __RPC_FAR * This,
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    pcbRead->LowPart = 0;
    pcbRead->HighPart = 0;
    pcbWritten->LowPart = 0;
    pcbWritten->HighPart = 0;

    hr = This->lpVtbl->CopyTo(This, pstm, cb, pcbRead, pcbWritten);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Draw_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::Draw.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Draw_Proxy(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    void __RPC_FAR *pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL (STDMETHODCALLTYPE __RPC_FAR *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    HRESULT hr;
    IContinue *pContinue = 0;

    if(pvAspect != 0)
        return E_INVALIDARG;

    if(pfnContinue != 0)
    {
        hr = CreateCallback(pfnContinue, dwContinue, &pContinue);
        if(FAILED(hr))
        {
             return hr;
        }
    }

    hr = IViewObject_RemoteDraw_Proxy(This,
                                      dwDrawAspect,
                                      lindex,
                                      (LONG_PTR) pvAspect,
                                      ptd,
                                      (LONG_PTR) hdcTargetDev,
                                      (LONG_PTR) hdcDraw,
                                      lprcBounds,
                                      lprcWBounds,
                                      pContinue);

    if(pContinue != 0)
    {
        pContinue->lpVtbl->Release(pContinue);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_RemoteContinue
//
//  Synopsis:   Wrapper function for IContinue::FContinue.  This function
//              is used for marshalling the pfnContinue parameter in
//              IViewObject::Draw.
//
//  Algorithm:  Cast the dwContinue to an IContinue * and then
//              call IContinue::FContinue.
//
//--------------------------------------------------------------------------
BOOL STDAPICALLTYPE IViewObject_RemoteContinue(ULONG_PTR dwContinue)
{
    BOOL bContinue = TRUE;
    HRESULT hr;
    IContinue *pContinue = (IContinue *) dwContinue;

    if(pContinue != 0)
    {
        hr = pContinue->lpVtbl->FContinue(pContinue);

        if(S_FALSE == hr)
            bContinue = FALSE;
    }

    return bContinue;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Draw_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::Draw.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Draw_Stub(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    ULONG_PTR hdcTargetDev,
    ULONG_PTR hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    IContinue *pContinue)
{
    HRESULT hr;
    BOOL (STDMETHODCALLTYPE __RPC_FAR *pfnContinue )(ULONG_PTR dwContinue) = 0;
    ULONG_PTR dwContinue = 0;

    if(pContinue != 0)
    {
        pfnContinue = IViewObject_RemoteContinue;
        dwContinue = (ULONG_PTR) pContinue;
    }

    hr = This->lpVtbl->Draw(This,
                            dwDrawAspect,
                            lindex,
                            (void *) pvAspect,
                            ptd,
                            (HDC) hdcTargetDev,
                            (HDC) hdcDraw,
                            lprcBounds,
                            lprcWBounds,
                            pfnContinue,
                            dwContinue);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Freeze_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::Freeze.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Freeze_Proxy(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    void __RPC_FAR *pvAspect,
    DWORD __RPC_FAR *pdwFreeze)
{
    HRESULT hr;

    if(pvAspect != 0)
        return E_INVALIDARG;

    hr = IViewObject_RemoteFreeze_Proxy(This,
                                        dwDrawAspect,
                                        lindex,
                                        (LONG_PTR) pvAspect,
                                        pdwFreeze);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Freeze_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::Freeze.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Freeze_Stub(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DWORD __RPC_FAR *pdwFreeze)
{
    HRESULT hr;

    hr = This->lpVtbl->Freeze(This,
                              dwDrawAspect,
                              lindex,
                              (void *) pvAspect,
                              pdwFreeze);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetAdvise_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::GetAdvise.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetAdvise_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [unique][out] */ DWORD __RPC_FAR *pAspects,
    /* [unique][out] */ DWORD __RPC_FAR *pAdvf,
    /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink)
{
    HRESULT hr;
    DWORD dwAspects = 0;
    DWORD dwAdvf = 0;

    hr = IViewObject_RemoteGetAdvise_Proxy(This,
                                           &dwAspects,
                                           &dwAdvf,
                                           ppAdvSink);

    if(pAspects != NULL)
    {
        *pAspects = dwAspects;
    }

    if(pAdvf != NULL)
    {
        *pAdvf = dwAdvf;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetAdvise_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::GetAdvise.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetAdvise_Stub( 
    IViewObject __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pAspects,
    /* [out] */ DWORD __RPC_FAR *pAdvf,
    /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink)
{
    HRESULT hr;

    hr = This->lpVtbl->GetAdvise(This,
                                 pAspects,
                                 pAdvf,
                                 ppAdvSink);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetColorSet_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::GetColorSet.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetColorSet_Proxy(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    void __RPC_FAR *pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    HDC hicTargetDev,
    LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet)
{
    HRESULT hr;

    if(pvAspect != 0)
        return E_INVALIDARG;

    hr = IViewObject_RemoteGetColorSet_Proxy(This,
                                             dwDrawAspect,
                                             lindex,
                                             (LONG_PTR) pvAspect,
                                             ptd,
                                             (LONG_PTR) hicTargetDev,
                                             ppColorSet);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetColorSet_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::GetColorSet.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetColorSet_Stub(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    ULONG_PTR hicTargetDev,
    LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet)
{
    HRESULT hr;

    hr = This->lpVtbl->GetColorSet(This,
                                   dwDrawAspect,
                                   lindex,
                                   (void *)pvAspect,
                                   ptd,
                                   (HDC) hicTargetDev,
                                   ppColorSet);

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:    IEnumSTATPROPSTG_Next_Proxy
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Proxy(
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ STATPROPSTG __RPC_FAR *rgelt,
    /* [unique][out][in] */ ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATPROPSTG_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if (pceltFetched != 0)
    {
        *pceltFetched = celtFetched;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATPROPSTG_Next_Stub
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Stub(
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    return This->lpVtbl->Next(This, celt, rgelt, pceltFetched);
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATPROPSETSTG_Next_Proxy
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Proxy(
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ STATPROPSETSTG __RPC_FAR *rgelt,
    /* [unique][out][in] */ ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATPROPSETSTG_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if (pceltFetched != 0)
    {
        *pceltFetched = celtFetched;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATPROPSETSTG_Next_Stub
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Stub(
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    return This->lpVtbl->Next(This, celt, rgelt, pceltFetched);
}

//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAt_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IFillLockBytes::FillAt.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//  History:    ?        ?          Created
//              05-27-94 AlexT      Actually return count of bytes written
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAt_Proxy(
    IFillLockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = IFillLockBytes_RemoteFillAt_Proxy(This, ulOffset, (byte __RPC_FAR *)pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAt_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IFillLockBytes::FillAt.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAt_Stub(
    IFillLockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->FillAt(This, ulOffset, pv, cb, pcbWritten);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAppend_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IFillLockBytes::FillAppend.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//  History:    ?        ?          Created
//              05-27-94 AlexT      Actually return count of bytes written
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAppend_Proxy(
    IFillLockBytes __RPC_FAR * This,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = IFillLockBytes_RemoteFillAppend_Proxy(This, (byte __RPC_FAR *)pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAppend_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IFillLockBytes::FillAppend.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAppend_Stub(
    IFillLockBytes __RPC_FAR * This,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->FillAppend(This, pv, cb, pcbWritten);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\bstr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bstr.cxx

Abstract:

    Windows Data Type Support by means of [user_marshal] attribute.

    Covers:
        BSTR
    

Author:

    Bill Morel (billmo)  Oct 14, 1995

    These routines provide [wire_marshal] support for BSTRs.

Revision History:

    14-Jun-96   MikeHill    Converted to use the new PrivSysAllocString,
                            PrivSysReAllocString, & PrivSysFreeString routines
                            (defined elsewhere in OLE32).

-------------------------------------------------------------------*/


//#include "stdrpc.hxx"
#pragma hdrstop

#include <wtypes.h>
#include "transmit.h"
#include <privoa.h>     // PrivSys* routines

// round up string alloc requests to nearest N-byte boundary, since allocator
// will round up anyway. Improves cache hits.
//
// UNDONE: optimal for Chicago is 4
// UNDONE: optimal for Daytona is 32
// UNDONE: 4 didn't help the a$ = a$ + "x" case at all.
// UNDONE: 8 did (gave 50% cache hit)
//
#define WIN32_ALLOC_ALIGN (4 - 1)	
#define DEFAULT_ALLOC_ALIGN (2 - 1)


/***
*unsigned int PrivSysStringByteLen(BSTR)
*Purpose:
*  return the length in bytes of the given BSTR.
*
*Entry:
*  bstr = the BSTR to return the length of
*
*Exit:
*  return value = unsigned int, length in bytes.
*
***********************************************************************/

// #########################################################################
//
//  BSTR
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserSize
//
//  Synopsis:   Get the wire size for the BSTR handle and data.
//
//  Derivation: Conformant struct with a flag field:
//                  align + 12 + data size.
//
//--------------------------------------------------------------------------

unsigned long __RPC_USER
BSTR_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    BSTR          * pBstr)
{
    // Null bstr doesn't get marshalled.

    if ( pBstr == NULL  ||  *pBstr == NULL )
        return Offset;

    unsigned long   ulDataSize;

    LENGTH_ALIGN( Offset, 3 );

    // Takes the byte length of a unicode string

    ulDataSize = PrivSysStringByteLen( *pBstr );

    return( Offset + 12 + ulDataSize) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserMarshall
//
//  Synopsis:   Marshalls an BSTR object into the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
BSTR_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    BSTR          * pBstr)
{
    // A null Bstr is not marshalled, the engine will take care of it.

    if ( pBstr == NULL  ||  *pBstr == NULL )
        return pBuffer;

    unsigned long   ulDataSize;

    // Data size (in bytes): a null bstr gets a data size of zero.

    ulDataSize = PrivSysStringByteLen( *pBstr );

    // Conformant size.

    ALIGN( pBuffer, 3 );
    *( PULONG_LV_CAST pBuffer)++ = (ulDataSize >> 1);

    // FLAGGED_WORD_BLOB: Handle is the null/non-null flag

    *( PULONG_LV_CAST pBuffer)++ = (unsigned long)*pBstr;

    // Length on wire is in words.

    *( PULONG_LV_CAST pBuffer)++ = (ulDataSize >> 1);

    if( ulDataSize )
        {
        // we don't put the terminating string on wire

        WdtpMemoryCopy( pBuffer, *pBstr, ulDataSize );
        }

    return( pBuffer + ulDataSize );
}


//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserUnmarshall
//
//  Synopsis:   Unmarshalls an BSTR object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
BSTR_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    BSTR          * pBstr)
{
    unsigned long   ulDataSize, fHandle;
    BSTR            Bstr = NULL;    // Default to NULL BSTR

    ALIGN( pBuffer, 3 );

    ulDataSize = *( PULONG_LV_CAST pBuffer)++;
    fHandle = *(ulong *)pBuffer;
    pBuffer += 8;

    if ( fHandle  )
        {
        // Length on wire is in words, and the string is unicode.

        if ( *pBstr  &&
             *(((ulong *)*pBstr) -1) == (ulDataSize << 1) )
            WdtpMemoryCopy( *pBstr, pBuffer, (ulDataSize << 1) );
        else
            {
            if (!PrivSysReAllocStringLen( pBstr, 
                                          (OLECHAR *)pBuffer,
                                          ulDataSize ))
                RpcRaiseException( E_OUTOFMEMORY );
            }
        }
    else
        {
        // free the old one, make it NULL.

        PrivSysFreeString( *pBstr );
        *pBstr = NULL;
        }

    return( pBuffer + (ulDataSize << 1) );
}

//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserFree
//
//  Synopsis:   Free an BSTR.
//
//--------------------------------------------------------------------------
void __RPC_USER
BSTR_UserFree(
    unsigned long * pFlags,
    BSTR * pBstr)
{
    if( pBstr && *pBstr )
            {
            PrivSysFreeString(* pBstr);
            *pBstr = NULL;
            }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\mega.h ===
// a giant mega idl file to put the whole proxy together

#include "unknwn.h"

#include "objidl.h"

#include "oleidl.h"

#include "oaidl.h"

#include "ocidl.h"

#include "contxt.h"

#ifdef DCOM

// internal interfaces used by DCOM
// this is private! (for now)
#include "oleprv.h"

#endif // DCOM

#ifdef ASYNC
#include "iconn.h"
#endif

#ifdef _CAIRO_
#include "storext.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\pipes.cxx ===
//+--------------------------------------------------------------------------
//
//   Microsoft Windows
//   Copyright (C) Microsoft Corporation, 1992 - 1997
//
//   File: pipes.cxx
//
//   History:
//           RichN  10/30/97  Created.
//
//---------------------------------------------------------------------------
#include <ole2int.h>
#include "pipes.hxx"

/////////////////////////////////////////////////////////////////////////////
// Externals
EXTERN_C HRESULT PrxDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
//////////////////////////////////////////////////////////////////////////////
// Constants
const DWORD WAIT_INFINITE = DWORD(-1);
const ULONG FRAGMENT_SIZE = 1300;

typedef struct
{
  const char *key;
  const char *value;
} RegistryKeyValue;

const RegistryKeyValue REG_CONST_KEY[] =
{
  "CLSID\\{0000032E-0000-0000-C000-000000000046}", "PipePSFactory",
  "CLSID\\{0000032E-0000-0000-C000-000000000046}\\InprocServer32", "ole32.dll",

  "Interface\\{DB2F3ACA-2F86-11d1-8E04-00C04FB9989A}", "IPipeByte",
  "Interface\\{DB2F3ACA-2F86-11d1-8E04-00C04FB9989A}\\ProxyStubClsid32", "{0000032E-0000-0000-C000-000000000046}",

  "Interface\\{DB2F3ACC-2F86-11d1-8E04-00C04FB9989A}", "IPipeLong",
  "Interface\\{DB2F3ACC-2F86-11d1-8E04-00C04FB9989A}\\ProxyStubClsid32", "{0000032E-0000-0000-C000-000000000046}",

  "Interface\\{DB2F3ACE-2F86-11d1-8E04-00C04FB9989A}", "IPipeDouble",
  "Interface\\{DB2F3ACE-2F86-11d1-8E04-00C04FB9989A}\\ProxyStubClsid32", "{0000032E-0000-0000-C000-000000000046}",

  // Indicates end of list.
  "", ""
};

/////////////////////////////////////////////////////////////////////////////
// Macros
inline ULONG MIN( ULONG a, ULONG b )
{
    return a < b ? a : b;
}
inline ULONG MAX( ULONG a, ULONG b )
{
    return a < b ? b : a;
}

inline HRESULT MAKE_WIN32( HRESULT status )
{
    return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, status );
}

inline HRESULT FIX_WIN32( HRESULT result )
{
    if ((ULONG) result > 0xfffffff7 || (ULONG) result < 0x2000)
        return MAKE_WIN32( result );
    else
        return result;
}

/////////////////////////////////////////////////////////////////////////////
// Globals
#define DISABLEASYNC    0

/////////////////////////////////////////////////////////////////////////////
// Prototypes

//+**************************************************************************
// FixUpPipeRegistry(void)
//
// Description: Modifies the registry to have the pipe interface point
//              to a different class ID for the PSFactory.  Adds to the
//              registry the new ID for the PipePSFactory.
//
// History:
// Date:   Time:          Developer:    Action:
// 12/3/97 10:14:48 AM    RichN         Created.
//
// Notes: We do not change the async interfaces.  They should still 
//        be handled by ole32 directly.  Only modify the synchronous varity.
//
//-**************************************************************************
HRESULT FixUpPipeRegistry(void)
{
    HRESULT result = ERROR_SUCCESS;

    // Create the Pipe interfaces and add the clsid for the PipePSFactory.
    for (int i = 0; (REG_CONST_KEY[i].key[0] != '\0') && result == ERROR_SUCCESS; i++)
    {
        // Use Ascii so it works on Win95.
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_CONST_KEY[i].key,
                 REG_SZ,
                 REG_CONST_KEY[i].value,
                 (DWORD) strlen(REG_CONST_KEY[i].value) );
    }

    if( result != ERROR_SUCCESS )
        return FIX_WIN32( result );

    return S_OK;
}


//+**************************************************************************
// ProxyDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
//
// Description: Creates a proxy.  Trys PrxDllGetClassObject first since that
//              is the most likely.  If not, then sees if it is the pipe
//              proxy being created.
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 11:43:55 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv)
{
    ComDebOut(( DEB_MARSHAL, "ProxyDllGetClassObject, clsid: %l, riid: %l \n", 
                                                            clsid, riid));

    HRESULT hr = PrxDllGetClassObject(clsid, riid, ppv);

    if( FAILED(hr) )
    {
        // Not a well known one, maybe it is the pipe factory.
        if( clsid == CLSID_PipePSFactory )
        {
            // Create the pipe proxy/stub class factory
            CPipePSFactory *pPipePSFactory = new CPipePSFactory();

            if( NULL != pPipePSFactory )
           {
                // Get the interface Requested.
                hr = pPipePSFactory->QueryInterface(riid, ppv);
                pPipePSFactory->Release();
            }
            else
            {
                *ppv = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

//+**************************************************************************
// CPipePSFactory()
//
// Description: CTOR
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 12:55:55 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipePSFactory::CPipePSFactory() :
    m_cRef(1)
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory - ctor, this:%x \n", this));    
}

//+**************************************************************************
// CPipePSFactory()
//
// Description: DTOR
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 12:56:19 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipePSFactory::~CPipePSFactory()
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory - dtor, this:%x \n"));
}

//+**************************************************************************
// QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Description: Standard QI
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 11:10:58 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipePSFactory::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory::QueryInterface, this:%x, riid:%i \n", 
                                                              this, riid));
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPSFactoryBuffer) )
    {
        *ppvObj = (IPSFactoryBuffer *) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+**************************************************************************
// CPipePSFactory::AddRef()
//
// Description: Standard AddRef
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 11:11:16 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipePSFactory::AddRef()
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory::AddRef, this:%x, m_cRef:%d \n", 
                                                      this, m_cRef + 1));
    return InterlockedIncrement( &m_cRef );
}

//+**************************************************************************
// CPipePSFactory::Release()
//
// Description: Standard Release
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 11:11:31 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipePSFactory::Release()
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory::Release, this:%x, m_cRef:%d \n", 
                                                       this, m_cRef - 1));
    ULONG lRef;

    if( (lRef = InterlockedDecrement( &m_cRef )) == 0)
    {
        delete this;
        return 0;
    }

    return lRef;
}


//+**************************************************************************
// CreateProxy
//
// Description: Creates a pipe proxy.
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 11:11:45 AM    RichN         Created.
//
// Notes: We will pass back to the call a ptr to our object and we will
//        hold a pointer to the real proxy.  When the client calls us, we
//        can do whatever we want/need to do and then call the real proxy.
//
//-**************************************************************************
STDMETHODIMP CPipePSFactory::CreateProxy( IUnknown *pUnkOuter,
                                          REFIID riid,
                                          IRpcProxyBuffer **ppProxy,
                                          void **ppv )
{
    ComDebOut(( DEB_MARSHAL, "CreateProxy, pUnkOuter:%x riid:%I \n", 
                                                    pUnkOuter, riid));

    if( NULL == ppv || NULL == ppProxy )
        return E_INVALIDARG;

    *ppProxy = NULL;
    *ppv     = NULL;

    IPSFactoryBuffer *pPSFactory;

    // Create the real PSFactory for the pipe interface.
    HRESULT hr = PrxDllGetClassObject(  riid, 
                                        IID_IPSFactoryBuffer, 
                                        (void **) &pPSFactory);

    IUnknown *pNDRPipeProxy = NULL;
    IRpcProxyBuffer *pInternalProxyBuffer = NULL;
    
    if( SUCCEEDED(hr) )
    {
        // Create the real proxy.
        hr = pPSFactory->CreateProxy(  pUnkOuter, 
                                       riid, 
                                       &pInternalProxyBuffer, 
                                       (void **)&pNDRPipeProxy);
        pPSFactory->Release();
    }

    if( FAILED(hr) )
        return hr;

    if( IID_IPipeByte == riid )
    {
        *ppv = new CPipeProxy<BYTE, 
                              &IID_IPipeByte,
                              &IID_AsyncIPipeByte,
                              IPipeByte,
                              AsyncIPipeByte>
                             (pUnkOuter, pNDRPipeProxy);
    }
    else if( IID_IPipeLong == riid )
    {
        *ppv = new CPipeProxy<LONG, 
                              &IID_IPipeLong,
                              &IID_AsyncIPipeLong, 
                              IPipeLong,
                              AsyncIPipeLong>
                             (pUnkOuter,  pNDRPipeProxy);
    }
    else if( IID_IPipeDouble == riid )
    {
        *ppv = new CPipeProxy<DOUBLE, 
                              &IID_IPipeDouble,
                              &IID_AsyncIPipeDouble, 
                              IPipeDouble,
                              AsyncIPipeDouble>
                             (pUnkOuter, pNDRPipeProxy);
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    
    if( SUCCEEDED(hr) && NULL == *ppv)
        hr = E_OUTOFMEMORY;

    // Create the object that contains the IRpcProxyBuffer 
    // and the pipe interface.  Created with refcount of 1.
    if( SUCCEEDED(hr) )
    {
        CPipeProxyImp *pProxyImp = new CPipeProxyImp(pUnkOuter,
                                                     pInternalProxyBuffer,
                                                     pNDRPipeProxy,
                                                     (IUnknown*) *ppv,
                                                     riid);
        if( NULL == pProxyImp )
        {
            hr = E_OUTOFMEMORY;
        }
        else
            *ppProxy = (IRpcProxyBuffer *) pProxyImp;
    }

    // Clean up failure.
    if( FAILED(hr) )
    {
        if( NULL != *ppv )
        {
            delete *ppv;
            *ppv = NULL;
        }

        pNDRPipeProxy->Release();
        pInternalProxyBuffer->Release();

    }

    return hr;
}

//+**************************************************************************
// CreateStub
//
// Description: Creates a pipe stub.
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 11:12:46 AM    RichN         Created.
//
// Notes: 
//
//-**************************************************************************
STDMETHODIMP CPipePSFactory::CreateStub( REFIID riid,
                                         IUnknown *pUnkServer,
                                         IRpcStubBuffer **ppStub )
{
    ComDebOut(( DEB_MARSHAL, "CreateStub, riid:%x pUnkServer:%x \n", 
                                               riid, pUnkServer ));
    HRESULT hr = S_OK;
    IPSFactoryBuffer *pPSFactory;

    // Create the real PSFactory for the pipe interface.
    hr = PrxDllGetClassObject( riid, 
                               IID_IPSFactoryBuffer, 
                               (void **) &pPSFactory);

    // Call real factory to get stub.
    if( SUCCEEDED(hr) )
    {
        hr = pPSFactory->CreateStub(riid, pUnkServer, ppStub);
    
        pPSFactory->Release();
    }

    return hr;
}

//+**************************************************************************
// CPipePoxyImp(IRpcProxyBuffer *pInternalPB, IUnknown *pPipe)
//
// Description: CTOR
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:31:43 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipeProxyImp::CPipeProxyImp(IUnknown *pUnkOuter,
                             IRpcProxyBuffer *pInternalPB, 
                             IUnknown *pRealPipeProxy,
                             IUnknown *pInternalPipeProxy,
                             IID iid) :
    m_cRef              (1),
    m_pInternalPipeProxy(pInternalPipeProxy),
    m_pInternalPB       (pInternalPB),
    m_pRealPipeProxy    (pRealPipeProxy),
    m_pUnkOuter         (pUnkOuter),
    m_IidOfPipe         (iid)
{
    ComDebOut(( DEB_MARSHAL, "CPipeProxyImp ctor, this:%x \n"));

    Win4Assert(NULL != m_pInternalPB);
    Win4Assert(NULL != m_pRealPipeProxy);
    Win4Assert(NULL != m_pInternalPipeProxy);

}

//+**************************************************************************
// CPipeProxyImp()
//
// Description: DTOR
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:32:02 AM    RichN         Created.
//
// Notes: 
//
//-**************************************************************************
CPipeProxyImp::~CPipeProxyImp()
{
    ComDebOut(( DEB_MARSHAL, "~CPipeProxyImp, this:%x \n", this));

    // AddRef the outer because we are aggregated.
    m_pUnkOuter->AddRef();

    // Delete the internal proxy.
    if( NULL != m_pInternalPipeProxy )
    {
        delete m_pInternalPipeProxy;
        m_pInternalPipeProxy = NULL;
    }

    // Release the real proxy.
    if( NULL != m_pRealPipeProxy )
    {
        m_pRealPipeProxy->Release();
        m_pRealPipeProxy = NULL;
    }

    // Release the pointer to the IRpcProxyBuffer
    if( NULL != m_pInternalPB )
        m_pInternalPB->Release();

}

//+**************************************************************************
// QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Description: QI
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:15 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipeProxyImp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    ComDebOut(( DEB_MARSHAL, "QueryInterface, this:%x \n", this));

    HRESULT hr = S_OK;

    if( NULL == ppvObj )
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IRpcProxyBuffer) )
    {
        *ppvObj = (IUnknown *) this;
    }
    else if( IsEqualIID(riid, m_IidOfPipe) )
    {
        *ppvObj = m_pInternalPipeProxy;
    }
    else
    {
        return m_pInternalPB->QueryInterface(riid, ppvObj);
    }
   
    ((IUnknown *)(*ppvObj))->AddRef();
    return hr;
}

//+**************************************************************************
// CPipeProxyImp::AddRef()
//
// Description: AddRef
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:34 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipeProxyImp::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}

//+**************************************************************************
// CPipeProxyImp::Release()
//
// Description: 
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:48 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipeProxyImp::Release()
{
  ULONG lRef;

  if( (lRef = InterlockedDecrement( &m_cRef )) == 0)
  {
    delete this;
    return 0;
  }

  return lRef;
}


//+**************************************************************************
// Connect(IRpcChannelBuffer *pRpcChannelBuffer)
//
// Description: Simple pass through.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:59 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipeProxyImp::Connect(IRpcChannelBuffer *pRpcChannelBuffer)
{
    return m_pInternalPB->Connect(pRpcChannelBuffer);
}

//+**************************************************************************
// Disconnect( void )
//
// Description: Simple pass through.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:37:25 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(void) CPipeProxyImp::Disconnect( void )
{
    m_pInternalPB->Disconnect();
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CPipeProxy( void * pProxy ): 
//
// Description:CTOR 
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:43:00 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CPipeProxy(IUnknown *pUnkOuter, void * pProxy ): 
    m_cFreeSpace      (0),           m_cKeepBufferSize (0),
    m_cKeepDataSize   (0),           m_cLastRead       (0),
    m_cPushBufferSize (0),           m_cReadAhead      (0),         
    m_cRef            (0),           m_pAsyncPullPipe  (NULL),      
    m_pAsyncPushPipe  (NULL),        m_pFreeSpace      (NULL),      
    m_pISyncPull      (NULL),        m_pISyncPush      (NULL),      
    m_pKeepBuffer     (NULL),        m_pKeepData       (NULL),      
    m_pRealProxy      ((I *)pProxy), m_pUnkOuter       (pUnkOuter), 
    m_pPushBuffer     (NULL),        m_PullState       (PULLSTATE0_ENTRY),
    m_PushState       (PUSHSTATE0_ENTRY)
{
    ComDebOut(( DEB_MARSHAL, "CPipeProxy, pUnkOuter:%x pProxy:%x p \n",
                                                pUnkOuter, pProxy));
    Win4Assert(NULL != m_pUnkOuter);
    Win4Assert(NULL != m_pRealProxy);

    // Fill in the array of functions for the pull states.
    PullStateFunc[0] = NULL;       // Should never execute in state zero.
    PullStateFunc[1] = NbNaRgtRA1; // No Buffer, No async outstanding, Request > Read ahead
    PullStateFunc[2] = NbaRltRA2;  // No Buffer, async call outstanding, Request < Read Ahead
    PullStateFunc[3] = NbaRgtRA3;  // No Buffer, async, Req >= Read ahead
    PullStateFunc[4] = baRltB4;    // Buffer, async, Request < Buffer size
    PullStateFunc[5] = baRgtB5;    // Buffer, async, Request >= Buffer size
    PullStateFunc[6] = PullDone6;  // done.

    // Fill in the array of functions for the push states.
    PushStateFunc[0] = NULL;      // Should never execute in state zero.
    PushStateFunc[1] = NbNf1;     // No Buffer, No free buffer space
    PushStateFunc[2] = bfPgtF2;   // Buffer, free space in buffer, push size >= free size
    PushStateFunc[3] = bfPltF3;   // Buffer, free, push < free
    PushStateFunc[4] = bPSz4;     // Buffer, push size zero
    PushStateFunc[5] = PushDone5; // Done

#if DBG==1
    for(int i = 1; i < MAX_PULL_STATES; i++)
        Win4Assert(PullStateFunc[i] != NULL);

    for(i = 1; i < MAX_PUSH_STATES; i++)
        Win4Assert(PushStateFunc[i] != NULL);
#endif

    return;

}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CPipeProxy( void )
//
// Description: DTOR
//
// History:
// Date:   Time:         Developer:    Action:
// 11/11/97 11:43:20 AM    RichN         Created.
//
// Notes: Addref the outer unknown and then release the pointer to the 
//        real proxy.
//
//-**************************************************************************
CPipeProxy<T, ID, AsyncID, I, AsyncI>
::~CPipeProxy( void )
{
    Win4Assert(NULL != m_pUnkOuter);
    Win4Assert(NULL != m_pRealProxy);

}    
//+**************************************************************************
// QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Description: IUnknown implementation.  All delegate to outer unknown.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/11/97 11:48:42 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
STDMETHODIMP CPipeProxy<T, ID, AsyncID, I, AsyncI>
::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    return m_pUnkOuter->QueryInterface(riid, ppvObj);
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
STDMETHODIMP_(ULONG) CPipeProxy<T, ID, AsyncID, I, AsyncI>
::AddRef()
{
    m_cRef++;
    return m_pUnkOuter->AddRef();
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
STDMETHODIMP_(ULONG) CPipeProxy<T, ID, AsyncID, I, AsyncI>
::Release()
{
    m_cRef--;
    return m_pUnkOuter->Release();
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// Pull( T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull the data from the server.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:49:18 AM    RichN         Created.
//
// Notes: We read data ahead by using async calls.  The size of the
//        read ahead can be controled by the user by implementing
//        the IPipeHueristic and setting it on the interface.
//
//-**************************************************************************
STDMETHODIMP CPipeProxy<T, ID, AsyncID, I, AsyncI>
::Pull( T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "Pull, this:%x, Buf:%x, Request:%d, Received:%x \n", 
                                    this, Buf, Request, Received));

    if( 0 == Request )
        return E_UNEXPECTED;

    HRESULT hr;

    // For debugging it is sometimes useful to disable
    // the async read ahead.
#if DISABLEASYNC==1
    hr = m_pRealProxy->Pull(Buf, Request, Received);
    return hr;
#endif

    *Received = 0;

    // Transition to the next state.
    hr = PullStateTransition( Request );

    // Should never see state 0.
    Win4Assert(0 != m_PullState);

    // Call the function for the new state.
    if( SUCCEEDED(hr) )
    {
        hr = (this->*(PullStateFunc[m_PullState]))( Buf, Request, Received );
    }

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// Push( T *Buf, ULONG count)
//
// Description: Pushes data to the server.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:49:39 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipeProxy<T, ID, AsyncID, I, AsyncI>
::Push( T *Buf, ULONG Count)
{
    ComDebOut(( DEB_MARSHAL, "Push, this:%x, Buf:%x, Count:%u \n",
                                    this, Buf, Count));
    HRESULT hr; 
    
    // For debugging it is sometimes useful to disable 
    // write behind.
#if DISABLEASYNC==1
    hr = m_pRealProxy->Push(Buf, Count);
    return hr;
#endif

    // Transition to the next state.
    hr = PushStateTransition( Count );

    // Should never see state 0.
    Win4Assert(0 != m_PushState);

    // Call the function for the new state.
    if( SUCCEEDED(hr) )
    {
        hr = (this->*(PushStateFunc[m_PushState]))( Buf, Count );
    }

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// InitAsync(void)
//
// Description: Initializes, gets, the pointers to the async parts.
//
// History:
// Date:   Time:         Developer:    Action:
// 12/8/97 4:45:22 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::InitAsync(IUnknown**     ppCallObj, 
            AsyncI**       ppAsyncPipe,
            ISynchronize** ppISync)
{
    ComDebOut(( DEB_MARSHAL, "InitAsync, this:%x \n", this));

    Win4Assert(NULL != m_pRealProxy);
    Win4Assert(NULL == (*ppAsyncPipe));
    Win4Assert(NULL == (*ppISync));

    HRESULT hr;
    ICallFactory *pCF = NULL;

    hr = m_pRealProxy->QueryInterface(IID_ICallFactory, (void **) &pCF);

    if( FAILED(hr) )
        return hr;

    hr = pCF->CreateCall(*AsyncID, NULL, IID_IUnknown, ppCallObj);
    pCF->Release();

    if( FAILED(hr) )
        return hr;

    hr = (*ppCallObj)->QueryInterface(*AsyncID, (void **) ppAsyncPipe);
    if( FAILED(hr) )
        goto ErrorCallObj;

    hr = (*ppCallObj)->QueryInterface(IID_ISynchronize, (void **) ppISync);
    if( FAILED(hr) )
        goto ErrorAsyncPipe;

    return S_OK;

ErrorAsyncPipe:
    (*ppAsyncPipe)->Release();
    (*ppAsyncPipe) = NULL;

ErrorCallObj:
    (*ppCallObj)->Release();
    (*ppCallObj) = NULL;

    return hr;

}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CleanupProxy(IUnknown* pCallObj, IUnknown* pAsyncPipe, ISynchronize* pISync)
//
// Description: Cleans up all the async interfaces acquired.
//
// History:
// Date:    Time:          Developer:    Action:
// 12/16/97 11:42:42 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
void CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CleanupProxy(T **           ppBuffer, 
               IUnknown**     ppCallObj, 
               AsyncI**       ppAsyncPipe, 
               ISynchronize** ppISync)
{

    if( *ppBuffer )
    {
        delete (*ppBuffer);
        (*ppBuffer) = NULL;
    }

    if( NULL != (*ppISync) )
    {
        (*ppISync)->Release();
        *ppISync = NULL;
    }

    if( NULL != (*ppAsyncPipe) )
    {
        (*ppAsyncPipe)->Release();
        *ppAsyncPipe = NULL;
    }

    if( NULL != (*ppCallObj) )
    {
        (*ppCallObj)->Release();
        *ppCallObj = NULL;
    }

}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CancelTheCall(DWORD delay)
//
// Description: Cancel the currently outstanding call.
//
// History:
// Date:   Time:          Developer:    Action:
// 12/9/97 10:59:54 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
void CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CancelTheCall(IUnknown *pCallObj, DWORD delay)
{
    ComDebOut(( DEB_MARSHAL, "CancelTheCall, this:%x \n", this));

    ICancelMethodCalls *pICancel;
    HRESULT hr = pCallObj->QueryInterface(IID_ICancelMethodCalls, 
                                          (void **) &pICancel);
    if( FAILED(hr) )
        return;

    pICancel->Cancel(delay);
    
    pICancel->Release();
    
    return;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// SetReadAhead(ULONG Request)
//
// Description: Determine the size of the read ahead.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/20/97 10:01:10 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
void CPipeProxy<T, ID, AsyncID, I, AsyncI>
::SetReadAhead(ULONG Request)
{
    ComDebOut(( DEB_MARSHAL, "SetReadAhead, this:%x Request:%u \n", this, Request));
    Win4Assert(Request != 0);

    switch(m_PullState)
    {
    case PULLSTATE1_FIRST_CALL :
        // On the first call just set the read ahead to the request.
        // This assumes that the request will be constant and 
        // we will be one call ahead all the time.
        m_cReadAhead = Request;
        break;
    case PULLSTATE2_NS_RQlsRA :
        // We haven't had a zero read or we wouldn't be here
        Win4Assert(m_cLastRead != 0);

        // Set the read ahead to the lesser of the request and the 
        // amount last read.  We are trying to match the read ahead with
        // the request by assuming a constant request, but the server
        // may only return a given amount regardless of what we 
        // request.
        m_cReadAhead = MIN(Request, m_cLastRead);
        break;
    case PULLSTATE3_NS_RQgeRA :
    case PULLSTATE5_S_RQgeBS :
        // No zero read
        Win4Assert(m_cLastRead != 0);

        // The request is greater than what was asked for last time.  So
        // we increase the read ahead to the max of the request or what
        // was actually read last time.
        m_cReadAhead = MAX(Request, m_cLastRead);
        break;
    default :
        // For all other states we should not be making read ahead calls.
        // Mostly because we read zero elements last time which indicates
        // the end of the data.  The PULLSTATE4_S_RQlsBS doesn't do a read
        // ahead so we shouldn't be here while in that state.
        Win4Assert(FALSE && "Request read ahead in wrong state.");
    }

    Win4Assert( 0 != m_cReadAhead );
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CheckAndSetKeepBuffer()
//
// Description: Check to see if the Buffer is the correct size and if not
//              make it the correct size.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/19/97 3:27:25 PM    RichN         Created.
//
// Notes: The buffer will never get smaller.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CheckAndSetKeepBuffer(void)
{
    Win4Assert(0 != m_cReadAhead);

    // Create a keep buffer the size of the read ahead.
    // We assume here that the user will not change the
    // request size and that the amount of data on hand
    // will never be larger.  When it is we will re-allocate.
    // The buffer will never get smaller.  Something to look at.
    if( m_cKeepBufferSize >= m_cReadAhead )
        return S_OK;
    
    T *temp = new T[m_cReadAhead];

    if( NULL == temp )
    {
        delete[] m_pKeepBuffer;
        m_pKeepBuffer = NULL;
        return E_OUTOFMEMORY;
    }

    if( m_pKeepBuffer != NULL )
    {
        // Copy the data into the new buffer
        memcpy(temp, m_pKeepBuffer, m_cKeepDataSize * sizeof(T));

        // Delete the old buffer and reset the bookkeeping.
        delete[] m_pKeepBuffer;
    }
    m_pKeepBuffer     = temp;
    m_cKeepBufferSize = m_cReadAhead;
    m_pKeepData       = m_pKeepBuffer + m_cKeepDataSize;

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PullStateTransition(ULONG Request)
//
// Description: Transition from one state to the next.  See pipes document
//              for a description of the state machine.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/11/97 4:20:19 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PullStateTransition(ULONG Request)
{
    ComDebOut(( DEB_MARSHAL, "PullStateTransition \n"));

    Win4Assert(Request > 0);

    switch( m_PullState )
    {
    case PULLSTATE0_ENTRY:
        // Transition to the first call state.
        m_PullState = PULLSTATE1_FIRST_CALL;
        break;

    case PULLSTATE1_FIRST_CALL:
        // If the last read was zero we are done.  We have no stored 
        // data so go to the state that handles request
        // that are either less than or greater than or
        // equal to the last read ahead.  Realize the amount of
        // data returned from the last read ahead may
        // not equal the requeat and could be greater than or less than.
        if( 0 == m_cLastRead )
            m_PullState = PULLSTATE6_DONE;
        else 
            m_PullState = (Request < m_cReadAhead) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
        break;

    case PULLSTATE2_NS_RQlsRA:
        // In this state, either the last read is not zero or
        // the amount of data remaining is zero.  Whatever state
        // we get to this one from does not go here on a last read
        // of zero nor if there is any data in the buffer (kept data).  
        // Possible we where in this state and got a last
        // read of zero, in which case the amount of held data will
        // be = zero.  We are in a state with no held data and got
        // a zero read of data, there can't be any kept data.
        Win4Assert(!( m_cLastRead == 0 && m_cKeepDataSize > 0));

        // If we had a zero read, we cleaned up in
        // this state and go to the state that just returns zero.
        if( 0 == m_cLastRead)
        {
            Win4Assert( 0 == m_cKeepDataSize );
            m_PullState = PULLSTATE6_DONE;
        }
        else
        {
            // If the kept data is zero, then we need to go to a state
            // that understands an empty buffer.  Determine which one
            // by the request and the read ahead.
            // If there is kept data then go to a state that understands
            // a non empty buffer.  This time the correct one depends on
            // the amount of data in the buffer.
            if( 0 == m_cKeepDataSize )
                m_PullState = ( Request < m_cReadAhead ) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
            else
                m_PullState = ( Request < m_cKeepDataSize) ? 
                            PULLSTATE4_S_RQlsBS : PULLSTATE5_S_RQgeBS;                   
        }
        break;

    case PULLSTATE3_NS_RQgeRA:
        // We can never leave this state with data in the buffer.  The
        // request is greater than the read ahead and the returned amount
        // of data can never be greater than the requested data, but it
        // could be less.
        Win4Assert(m_cKeepDataSize == 0);

        // If the last read was zero go to the done state.
        // else go to the state that understands empty buffers depending
        // on the request and the read ahead.
        if( 0 == m_cLastRead )
            m_PullState = PULLSTATE6_DONE;
        else
            m_PullState = ( Request < m_cReadAhead ) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
        break;

    case PULLSTATE4_S_RQlsBS:
        // When this state was entered there was data in the buffer.  The 
        // request was for less than the buffer size so when we returned
        // there should have still been data in the buffer.  No read is done.
        Win4Assert(m_cKeepDataSize > 0);
        Win4Assert(m_cLastRead > 0);

        // Go to the state that handles data in the buffer
        // depending on the request and the amount of data in the buffer.
        m_PullState = ( Request < m_cKeepDataSize ) ? 
                        PULLSTATE4_S_RQlsBS : PULLSTATE5_S_RQgeBS;
        break;

    case PULLSTATE5_S_RQgeBS:
        // Because we can fulfill at aleast part of the request from
        // the buffer, we don't wait on the async call to finish.  If it 
        // did finish (wait 0 tells us that) then there is data in the
        // buffer (assuming it returned data) otherwise it is empty.  
        // So when the call finished last time the buffer 
        // could be empty or not.  If the read was zero the buffer is empty.
        Win4Assert( (m_cLastRead == 0 && m_cKeepDataSize == 0) ||
                     m_cLastRead != 0 );

        // If the buffer is empty then on a zero last read go to done. 
        // Otherwise go to a state that understands empty buffers depending
        // on the request size and the read ahead.
        if( 0 == m_cKeepDataSize )
            if( 0 == m_cLastRead )
                m_PullState = PULLSTATE6_DONE;
            else
                m_PullState = ( Request < m_cReadAhead ) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
        else
            // Otherwise go to one that understands having data in the 
            // buffer depending on the request and the amount of data in
            // the buffer.
            m_PullState = ( Request < m_cKeepDataSize ) ? 
                            PULLSTATE4_S_RQlsBS : PULLSTATE5_S_RQgeBS;
        break;

    case PULLSTATE6_DONE:
        // When in this state there better not be any data left and
        // the last read must be zero.
        Win4Assert(m_cKeepDataSize == 0);
        Win4Assert(m_cLastRead == 0);
        
        m_PullState = PULLSTATE1_FIRST_CALL;

        break;

    default:
        return E_UNEXPECTED; 
    }
    
    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbNaRgtRA1 
//
// Description: Pull, No data in buffer, no async call outstanding and 
//              request is >= read ahead.  State 1.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/19/97 2:30:11 PM    RichN         Created.
//
// Notes: Make a sync call to get some data and then make an async call to
//        read ahead.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbNaRgtRA1(T *Buf, 
           ULONG Request, 
           ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "NbNaRgtRA1 Request:%d\n", Request));
    Win4Assert(1 == m_PullState);
    Win4Assert(NULL != Buf);

    // State conditions
    Win4Assert(0 == m_cLastRead );
    Win4Assert(0 == m_cKeepDataSize);

    HRESULT hr = S_OK;

    // We are only in this state one time.  There will always be
    // an out standing async call, so we init async here.
    hr = InitAsync(&m_pPullCallObj, &m_pAsyncPullPipe, &m_pISyncPull);

    if( FAILED(hr) )
        return hr;

    // make a sync call to get started.
    hr = m_pRealProxy->Pull(Buf, Request, Received);
    m_cLastRead = *Received;

    if( m_cLastRead > 0 && SUCCEEDED(hr))
    {
        SetReadAhead(Request);

        // Make the async call.
        hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
    }
    else
    {
        CleanupProxy(&m_pKeepBuffer,
                     &m_pPullCallObj, 
                     &m_pAsyncPullPipe, 
                     &m_pISyncPull);

    }

    // Post condition
    // Wouldn't expect the last read to be zero here, but no reason 
    // it couldn't be.
    Win4Assert( 0 == m_cKeepDataSize );

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbaRltRA2 (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, No Buffer, read ahead call outstanding.  
//              State 2.  We have to be prepared
//              for the amount returned to be greater than, less than or equal
//              to the amount requested.  This works for both states 2 and 3.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/19/97 2:32:13 PM    RichN         Created.
//
// Notes: wait on the sync object,
//        Finish the async call,
//        Copy the data into the user Buffer
//        make another async call
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbaRltRA2 (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "NbaRltRA2 Request:%d\n", Request));
    Win4Assert(2 == m_PullState);
    Win4Assert(NULL != Buf);

    // State conditions.
    Win4Assert(0 == m_cKeepDataSize); // No data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request < m_cReadAhead);

    HRESULT hr = S_OK;
    bool bDoCleanup = false;

    // There might be a Bug here. Bug!
    // We should just be able to call the finish method, but the 
    // bug requires us to wait first.
    hr = m_pISyncPull->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr) )
    {
        hr = CheckAndSetKeepBuffer();
        if( SUCCEEDED(hr) )
        {
            // Get the data requested last time.  Remember the amount returned
            // could be less than we requested.
            hr = m_pAsyncPullPipe->Finish_Pull(m_pKeepBuffer, &m_cLastRead);

            // We can't return more than requested, the buffer may not be 
            // large enough.
            *Received = MIN(Request, m_cLastRead);
            
            if( SUCCEEDED(hr) && m_cLastRead > 0 )
            {
                // Copy the data to the users Buffer and updata bookkeeping.
                memcpy(Buf, m_pKeepBuffer, (*Received) * sizeof(T));

                m_pKeepData = m_pKeepBuffer + *Received;
                m_cKeepDataSize = m_cLastRead - *Received;

                SetReadAhead(Request);

                // Make another read ahead
                hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
            }
            else
            {
                // If the call failed or we received no data, we
                // need to clean up since we won't be called again.
                bDoCleanup = true;
            }
        }
        else
        {
            //Cancel the call here.
            CancelTheCall(m_pPullCallObj, 0);
        }
    }

    if( FAILED(hr) || bDoCleanup )
        CleanupProxy(&m_pKeepBuffer,
                     &m_pPullCallObj, 
                     &m_pAsyncPullPipe, 
                     &m_pISyncPull);


    // Post condition
    Win4Assert(!(m_cLastRead == 0 && m_cKeepDataSize > 0));

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbaRgtRA3 (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, No Buffered data, async call outstanding and request
//              is greater than read ahead.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/20/97 10:50:22 AM    RichN         Created.
//
// Notes: Difference between this and the previous state: we know
//        we don't need a keep Buffer here.
//        wait on the sync object,
//        Finish the async call,
//        Copy the data into the user Buffer
//        make another async call
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbaRgtRA3 (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "NbaRgtRA3, Request:%d  \n", Request));
    Win4Assert(3 == m_PullState);
    Win4Assert(NULL != Buf);

    // State conditions.
    Win4Assert(0 == m_cKeepDataSize); // No data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request >= m_cReadAhead);

    bool bDoCleanup = false;
    HRESULT hr = m_pISyncPull->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr))
    {
        // Get the data requested last time.
        hr = m_pAsyncPullPipe->Finish_Pull(Buf, &m_cLastRead);
        
        *Received = m_cLastRead;

        if( SUCCEEDED(hr) && m_cLastRead > 0 )
        {
            // Reset the amount of data remaining.
            m_cKeepDataSize = 0;
            m_pKeepData    = NULL;

            SetReadAhead(Request);

            // Make another read ahead
            hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
        }
        else
        {
            // If the call failed or we received no data, we
            // need to clean up since we won't be called again.
            bDoCleanup = TRUE;
        }
    }

    if( FAILED(hr) || bDoCleanup )
        CleanupProxy(&m_pKeepBuffer,
             &m_pPullCallObj, 
             &m_pAsyncPullPipe, 
             &m_pISyncPull);

    // Post condition
    Win4Assert( 0 < m_cReadAhead);
    Win4Assert(0 == m_cKeepDataSize);

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// baRltB4   (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, Data in Buffer, async call outstanding and Request is
//              less than the data in the keep Buffer.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/20/97 1:22:41 PM    RichN         Created.
//
// Notes: Copy data from the keep Buffer to the users Buffer.
//        Update state variables.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::baRltB4   (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "baRltB4    \n"));

    Win4Assert(NULL != Buf);
    Win4Assert(4 == m_PullState);

    // State conditions.
    Win4Assert(0 < m_cKeepDataSize); // Data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request < m_cKeepDataSize);

    memcpy(Buf, m_pKeepData, Request * (sizeof(T)));

    m_cKeepDataSize -= Request;
    m_pKeepData     += Request;

    // Post condition
    Win4Assert(m_cKeepDataSize > 0);
    Win4Assert(m_cLastRead > 0);

    // Post condition
    Win4Assert(0 < m_cKeepDataSize); // Data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    

    return S_OK;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// baRgtB5   (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, Data in Buffer, async call outstanding and Request is
//              greater than or equal the data in the keep Buffer.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/20/97 1:24:25 PM    RichN         Created.
//
// Notes:  Copy the keep Buffer data to the users Buffer.
//         Wait 0
//         if the call has completed.
//             Finish the async call (keep Buffer, RA)
//             Copy data into users Buffer to fill request
//             Update keep data size.
//             if we didn't read zero
//                 set read ahead
//                 Begin async call(RA)
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::baRgtB5   (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "baRgtB5    \n"));

    Win4Assert(NULL != Buf);
    Win4Assert(5 == m_PullState);

    // State conditions.
    Win4Assert(0 < m_cKeepDataSize); // Data in keep buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request >= m_cKeepDataSize);

    HRESULT hr = S_OK;

    // Give whatever data we already have.
    T *tempBuf = Buf;
    memcpy(tempBuf, m_pKeepData, m_cKeepDataSize * (sizeof(T)) );

    // Remainder of the request.
    ULONG Remainder = Request - m_cKeepDataSize;

    tempBuf        += m_cKeepDataSize;
    m_cKeepDataSize = 0;
    m_pKeepData     = NULL;

    hr = m_pISyncPull->Wait(0, 0);

    // If the call is finished get the data and 
    // copy up to the total request or as much as
    // we have into the buffer.
    if( SUCCEEDED(hr) && RPC_S_CALLPENDING != hr)
    {
        hr = CheckAndSetKeepBuffer();
        if( SUCCEEDED(hr) )
        {
            hr = m_pAsyncPullPipe->Finish_Pull(m_pKeepBuffer, &m_cLastRead);

            if( SUCCEEDED(hr) )
            {
                // Copy the smaller of the remainder of the
                // request or what was actually received.
                ULONG CopySize = MIN(Remainder, m_cLastRead);

                memcpy(tempBuf, m_pKeepBuffer, CopySize * sizeof(T));

                m_cKeepDataSize = m_cLastRead - CopySize;
                m_pKeepData     = m_pKeepBuffer + CopySize;

                if( m_cLastRead > 0 )
                {
                    SetReadAhead(Request);

                    hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
                }
            }
        }
        else
            CancelTheCall(m_pPullCallObj, 0);
    }
    else
    {
        if( RPC_S_CALLPENDING == hr )
            hr = S_OK;
        else
            CancelTheCall(m_pPullCallObj, 0);
    }

    *Received = (ULONG) (tempBuf - Buf);

    if( FAILED(hr) )
        CleanupProxy(&m_pKeepBuffer,
                     &m_pPullCallObj, 
                     &m_pAsyncPullPipe, 
                     &m_pISyncPull);

    // Post condition
    Win4Assert( (m_cLastRead == 0 && m_cKeepDataSize == 0) ||
                 m_cLastRead != 0 );

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PullDone6 (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull Done, no data in the Buffer and no outstanding calls.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/20/97 3:30:14 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PullDone6 (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "PullDone6  \n"));

    Win4Assert(6 == m_PullState);

    CleanupProxy(&m_pKeepBuffer,
                 &m_pPullCallObj, 
                 &m_pAsyncPullPipe, 
                 &m_pISyncPull);

    HRESULT hr = S_OK;
    if (Request > 0)
    {
        m_PullState = PULLSTATE1_FIRST_CALL;
        hr = (this->*(PullStateFunc[m_PullState]))( Buf, Request, Received );
    }
    else
    {
        *Received = 0;

        // Post condition
        Win4Assert( 0 == m_cKeepDataSize );
        Win4Assert( 0 == m_cLastRead );
    }

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// SetPushBuffer(ULONG PushSize)
//
// Description: Allocates a buffer for push, or reallocates if it 
//              needs to grow.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/21/97 10:10:50 AM    RichN         Created.
//
// Notes: The buffer will never get smaller.  We might want
//        to reduce it by some algorithm, but not this time.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::SetPushBuffer(ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "SetPushBuffer, PushSize:%l \n"));
    // If it is already big enough just return.
    if( m_cPushBufferSize >= PushSize )
        return S_OK;


    ULONG NewSize = MAX(PushSize, (FRAGMENT_SIZE / sizeof(T)) + 1);
    T *pTtemp = new T[NewSize];

    if( NULL == pTtemp )
    {
        delete[] m_pPushBuffer;
        m_pPushBuffer = NULL;
        return E_OUTOFMEMORY;
    }

    ULONG BufferedDataSize = m_cPushBufferSize - m_cFreeSpace;

    if( m_pPushBuffer != NULL )
    {
        // Copy data over and reset bookkeeping.
        memcpy(pTtemp, m_pPushBuffer, BufferedDataSize * sizeof(T));

        delete[] m_pPushBuffer;
    }

    m_pPushBuffer     = pTtemp;
    m_cPushBufferSize = NewSize;
    m_pFreeSpace      = m_pPushBuffer + BufferedDataSize;
    m_cFreeSpace      = m_cPushBufferSize - BufferedDataSize;

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PushStateTransition(ULONG Request)
//
// Description: Implements the transition table for push.  See the pipes 
//              document for a description of the state machine.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/13/97 4:36:43 PM    RichN         Created.
//
// 02/05/99               JohnStra      Modified Push state machine to
//                                      allow multiple Push operations
//                                      on a pipe.
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PushStateTransition(ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "PushStateTransition, PushSize:%l \n"));

    switch( m_PushState )
    {
        case PUSHSTATE0_ENTRY:
            // From the entry state we always go to the first call state.
            m_PushState = PUSHSTATE1_FIRSTCALL;
            break;

        case PUSHSTATE1_FIRSTCALL:
        case PUSHSTATE2_FS_PSgeFS:
        case PUSHSTATE3_FS_PSltFS:
            // If the push size is zero transition to state that
            // does a zero send.
            if( 0 == PushSize )
                m_PushState = PUSHSTATE4_FS_PSZERO;
            else
                // Go to state that either puts the data in free space
                // or one that handles a push greater than the free space.
                m_PushState = (PushSize < m_cFreeSpace) ? 
                             PUSHSTATE3_FS_PSltFS : PUSHSTATE2_FS_PSgeFS;
            break;

        case PUSHSTATE4_FS_PSZERO:
            // If we are in the state that handles a zero push we may
            // be called again with a positive buffer size to execute
            // another push.  If we are called with any other 
            // buffer size, go to the state that returns an error.
            if( 0 < PushSize )
                m_PushState = PUSHSTATE1_FIRSTCALL;
            else
                m_PushState = PUSHSTATE5_DONE_ERROR;
            break;

        case PUSHSTATE5_DONE_ERROR:
            // Stay in state PUSHSTATE_DONE_ERROR.
            break;

        default:
            return E_UNEXPECTED; 

    }

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbNf1(T *Buf, ULONG PushSize)
//
// Description: Push, No buffer, no free, state 1.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/21/97 9:42:57 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbNf1(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "NbNf1, PushSize:%l \n", PushSize));

    Win4Assert(1 == m_PushState);

    // This is the first call to push so PushSize shouldn't be zero.
    if( PushSize == 0 || NULL == Buf)
        return E_INVALIDARG;

    HRESULT hr;

    // We are only in this state one time so init the async stuff.
    hr = InitAsync(&m_pPushCallObj, &m_pAsyncPushPipe, &m_pISyncPush);

    if( FAILED(hr) )
        return hr;

    hr = m_pAsyncPushPipe->Begin_Push(Buf, PushSize);

    if( FAILED(hr) )
        CleanupProxy(&m_pPushBuffer,
                     &m_pPushCallObj, 
                     &m_pAsyncPushPipe, 
                     &m_pISyncPush);

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// bfPgtF2(T *Buf, ULONG PushSize)
//
// Description: Push, Have a buffer with free space and the push size
//              is greater than or equal to the free space. State 2.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/21/97 10:52:41 AM    RichN         Created.
//
// Notes: This may grow the buffer, look at reducing it in the next method.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::bfPgtF2(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "bfPgtF2, PushSize:%l \n", PushSize));

    Win4Assert(2 == m_PushState);
    Win4Assert( PushSize >= m_cFreeSpace );
    Win4Assert( PushSize > 0 );
    Win4Assert( (LONG) m_cFreeSpace >= 0 );

    if( PushSize == 0 || NULL == Buf)
        return E_INVALIDARG;

    // There might be a BUG here. BUG! Shouldn't have to wait.
    HRESULT hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr) )
        hr = m_pAsyncPushPipe->Finish_Push();

    if( SUCCEEDED(hr) )
    {
        ULONG TotalData = PushSize + (m_cPushBufferSize - m_cFreeSpace);
        hr = SetPushBuffer( TotalData );

        if( SUCCEEDED(hr) )
        {
            // Append the data to the buffer.
            memcpy(m_pFreeSpace, Buf, PushSize * sizeof(T));

            hr = m_pAsyncPushPipe->Begin_Push(m_pPushBuffer, TotalData);

            m_pFreeSpace       = m_pPushBuffer;
            m_cFreeSpace       = m_cPushBufferSize;
        }
    }

    if( FAILED(hr) )
        CleanupProxy(&m_pPushBuffer,
                     &m_pPushCallObj, 
                     &m_pAsyncPushPipe, 
                     &m_pISyncPush);


    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// bfPltF3(T *Buf, ULONG PushSize)
//
// Description: Push, Have buffer and pushed data is less than free space.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/21/97 11:03:19 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::bfPltF3(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "bfPltF3, PushSize:%l \n", PushSize));

    Win4Assert(3 == m_PushState);
    Win4Assert( m_cFreeSpace > PushSize );
    Win4Assert( PushSize     > 0 );
    Win4Assert( m_cFreeSpace > 0 );

    if( NULL == Buf)
        return E_INVALIDARG;

    // Copy the data into the buffer.
    memcpy(m_pFreeSpace, Buf, PushSize * sizeof(T));

    m_cFreeSpace -= PushSize;
    m_pFreeSpace += PushSize;

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// bPSz4(T *Buf, ULONG PushSize)
//
// Description: Push, Have buffer and push size is zero.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/21/97 11:33:32 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::bPSz4(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "bPSz4, PushSize:$l \n", PushSize));

    Win4Assert(4 == m_PushState);
    Win4Assert( PushSize == 0 );
    Win4Assert( (LONG) m_cFreeSpace >= 0 );

    // There might be a BUG here.  BUG! Shouldn't have to wait.
    HRESULT hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr) )
        hr = m_pAsyncPushPipe->Finish_Push();

    if( SUCCEEDED(hr) )
    {
        if( (m_cPushBufferSize - m_cFreeSpace) > 0 )
        {
            // Data in buffer so send it.
            hr = m_pAsyncPushPipe->Begin_Push(m_pPushBuffer, 
                                              m_cPushBufferSize - m_cFreeSpace);
            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pAsyncPushPipe->Finish_Push();
        }
        
        if( SUCCEEDED(hr) )
        {
            // Push a zero size buffer to signal end of data.
            hr = m_pAsyncPushPipe->Begin_Push(Buf, PushSize);
            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pAsyncPushPipe->Finish_Push();
        }

    }

asyncFailed:
    // Last call regardless of success or failure so clean async up.
    CleanupProxy(&m_pPushBuffer,
                 &m_pPushCallObj, 
                 &m_pAsyncPushPipe, 
                 &m_pISyncPush);

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PushDone5(T *Buf, ULONG PushSize)
//
// Description: Push Done, so this should never be called.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/21/97 11:42:08 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PushDone5(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "PushDone5, PushSize:%u \n"));
    Win4Assert(FALSE && "Push call after completion.");
    Win4Assert(5 == m_PushState);

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\metafile.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       metafile.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HMETAFILEPICT, HENHMETAFILE, and
//              HMETAFILE.
//
//  Functions:  
//              HMETAFILEPICT_UserSize
//              HMETAFILEPICT_UserMarshal
//              HMETAFILEPICT_UserUnmarshal
//              HMETAFILEPICT_UserFree
//              HMETAFILEPICT_UserSize64
//              HMETAFILEPICT_UserMarshal64
//              HMETAFILEPICT_UserUnmarshal64
//              HMETAFILEPICT_UserFree64
//              HENHMETAFILE_UserSize
//              HENHMETAFILE_UserMarshal
//              HENHMETAFILE_UserUnmarshal
//              HENHMETAFILE_UserFree
//              HENHMETAFILE_UserSize64
//              HENHMETAFILE_UserMarshal64
//              HENHMETAFILE_UserUnmarshal64
//              HENHMETAFILE_UserFree64
//              HMETAFILE_UserSize
//              HMETAFILE_UserMarshal
//              HMETAFILE_UserUnmarshal
//              HMETAFILE_UserFree
//              HMETAFILE_UserSize64
//              HMETAFILE_UserMarshal64
//              HMETAFILE_UserUnmarshal64
//              HMETAFILE_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

// #########################################################################
//
//  HMETAFILEPICT
//  See transmit.h for explanation of hglobal vs. gdi data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserSize
//
//  Synopsis:   Get the wire size the HMETAFILEPICT handle and data.
//
//  Derivation: Union of a long and the meta file pict handle.
//              Then struct with top layer (and a hmetafile handle).
//              The the representation of the metafile.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILEPICT_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // Discriminant of the encapsulated union and the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += 8;


    if ( ! *pHMetaFilePict )
        return Offset;

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
#if defined(_WIN64)
        //Win64, inproc, we need a bit more space for the handle.
        Offset -= 4;  //Get rid of that bogus long...
        LENGTH_ALIGN( Offset, 7 ); //Make sure alignment is right...
        Offset += 8; //And add in the real size of the handle...
#endif
        return Offset;
    }

    // Now, this is a two layer object with HGLOBAL on top.
    // Upper layer - hglobal part - needs to be sent as data.

    METAFILEPICT *
    pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

    if ( pMFP == NULL )
        RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

    // Upper layer: 3 long fields + ptr marker + enc. union

    Offset += 4 * sizeof(long) + sizeof(userHMETAFILE);

    // The lower part is a metafile handle.

    if ( GDI_DATA_PASSING( *pFlags) )
        {
        ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );

        Offset += 12 + ulDataSize;
        }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( Offset ) ;
}


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserMarshal
//
//  Synopsis:   Marshalls an HMETAFILEPICT object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        // Sending only the top level global handle.
#if defined(_WIN64)
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)( pHMetaFilePict );
#else
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pHMetaFilePict );
#endif
        
        return pBuffer;
    }

    // userHMETAFILEPICT
    // We need to send the data from the top (hglobal) layer.

    *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
    *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pHMetaFilePict );

    if ( ! *pHMetaFilePict )
        return pBuffer;

    // remoteHMETAFILEPICT

    METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock(
                                             *(HANDLE *)pHMetaFilePict );
    if ( pMFP == NULL )
        RpcRaiseException( E_OUTOFMEMORY );

    *( PULONG_LV_CAST pBuffer)++ = pMFP->mm;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->xExt;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->yExt;
    *( PULONG_LV_CAST pBuffer)++ = USER_MARSHAL_MARKER;

    // See if the HMETAFILE needs to be sent as data, too.

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHMETAFILE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pMFP->hMF );

        if ( pMFP->hMF )
        {
            ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );

            // conformant size then the size field

            *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
            *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

            GetMetaFileBitsEx( pMFP->hMF, ulDataSize , pBuffer );

            pBuffer += ulDataSize;
        }
    }
    else
    {
        // Sending only an HMETAFILE handle.
        
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pMFP->hMF );
    }
    
    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshalWorker
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict,
    ULONG_PTR       BufferSize )
{
    BOOL            fAllocMetaFile = FALSE;
    HMETAFILEPICT   hMetaFilePict;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get the tag and handle from the buffer.  Caller checked for EOB.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    if (IS_HANDLE64_MARKER(UnionDisc))
    {
        ALIGN( pBuffer, 7 );
        hMetaFilePict = (HMETAFILEPICT)(*( PHYPER_LV_CAST pBuffer)++ );
    }
    else
    {
        hMetaFilePict = (HMETAFILEPICT)LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
    }

    if ( IS_DATA_MARKER( UnionDisc ) )
    {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hMetaFilePict )
        {
            HGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, sizeof(METAFILEPICT) );
            HMETAFILEPICT hmfTemp = (HMETAFILEPICT) hGlobal;            
            if ( hmfTemp == NULL )
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

            fAllocMetaFile = TRUE;
            
            METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock((HANDLE) hmfTemp );
            if ( pMFP == NULL )
            {
                GlobalFree((HANDLE)hmfTemp);
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
            }
            
            RpcTryFinally
            {
                // Check for EOB before accessing metadata.
                CHECK_BUFFER_SIZE( BufferSize, cbFixup + (8 * sizeof( ULONG )) );
                
                pMFP->mm   = *( PULONG_LV_CAST pBuffer)++;
                pMFP->xExt = *( PULONG_LV_CAST pBuffer)++;
                pMFP->yExt = *( PULONG_LV_CAST pBuffer)++;
                
                // validate marker.
                if ( *( PULONG_LV_CAST pBuffer)++ != USER_MARSHAL_MARKER )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                
                UnionDisc  = *( PULONG_LV_CAST pBuffer)++;
                pMFP->hMF  = (HMETAFILE) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
                
                if ( pMFP->hMF )
                {
                    if (IS_DATA_MARKER( UnionDisc ) )
                    {
                        if ( GDI_HANDLE_PASSING(*pFlags) )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                        // Check for EOB.
                        if ( BufferSize < cbFixup + (10 * sizeof( ULONG )) )
                        {
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                        }
                        else
                        {
                            // Conformant size then the size field.  These must be the same.
                            ulong ulDataSize = *( PULONG_LV_CAST pBuffer)++;
                            if ( ulDataSize == *( PULONG_LV_CAST pBuffer)++ )
                            {
                                // Check for EOB before accessing data.
                                if ( BufferSize < cbFixup + (10 * sizeof(ULONG)) + ulDataSize )
                                {
                                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                                }
                                else
                                {
                                    pMFP->hMF = SetMetaFileBitsEx( ulDataSize, (uchar*)pBuffer );
                                    if (NULL == pMFP->hMF)
                                        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

                                    pBuffer += ulDataSize;
                                }
                            }
                            else
                                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                        }
                    }
                    else 
                    {
                        if ( !IS_HANDLE_MARKER( UnionDisc ) )
                            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

                        if ( GDI_DATA_PASSING(*pFlags) )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                }

                GlobalUnlock( (HANDLE) hmfTemp );                
                hMetaFilePict = hmfTemp;
                hmfTemp = NULL;
            }
            RpcFinally
            {
                if (hmfTemp != NULL)
                {
                    GlobalUnlock(hmfTemp);
                    GlobalFree(hmfTemp);
                }
            }         
            RpcEndFinally;
        }
    }
    else 
    {
        if ( !(IS_HANDLE_MARKER( UnionDisc ) || IS_HANDLE64_MARKER( UnionDisc )) )
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

        if ( HGLOBAL_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }
    
    // no reusage, just release the previous one.
    
    if ( *pHMetaFilePict )
    {
        // This may happen on the client only and doesn't depend on
        // how the other one was passed.        
        METAFILEPICT *pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );
        
        if ( pMFP == NULL )
        {
            if (fAllocMetaFile)
            {
                // Do our best to clean up before we throw.
                METAFILEPICT *ptmfp = (METAFILEPICT*)GlobalLock((HANDLE)hMetaFilePict);
                if (ptmfp)
                {
                    if (ptmfp->hMF)
                        DeleteMetaFile(ptmfp->hMF);
                    
                    GlobalUnlock((HANDLE)hMetaFilePict);
                }
                GlobalFree(hMetaFilePict);
            }
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
        }
        
        if ( pMFP->hMF )
            DeleteMetaFile( pMFP->hMF );
        
        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
    }
    
    *pHMetaFilePict = hMetaFilePict;
    
    return( pBuffer );
}
//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshal
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored out bulk of work into a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserUnmarshal\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HMETAFILEPICT_UserUnmarshalWorker( pFlags,
                                                  pBufferStart,
                                                  pHMetaFilePict,
                                                  BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserFree
//
//  Synopsis:   Free an HMETAFILEPICT.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILEPICT_UserFree(
    unsigned long * pFlags,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILEPICT_UserFree\n"));

    if( pHMetaFilePict && *pHMetaFilePict )
    {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            return;

        // Need to free the upper hglobal part.
        
        METAFILEPICT *
          pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );
        
        if ( pMFP == NULL )
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
        
        // See if we need to free the hglobal, too.
        
        if ( pMFP->hMF  &&  HGLOBAL_DATA_PASSING(*pFlags) )
            DeleteMetaFile( pMFP->hMF );
        
        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserSize
//
//  Synopsis:   Get the wire size the HENHMETAFILE handle and data.
//
//  Derivation: Union of a long and the meta file handle and then struct.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HENHMETAFILE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);

    if ( ! *pHEnhMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Pointee of the union arm for the remote case.
        // Byte blob : conformant size, size field, data
        
        Offset += 2 * sizeof(long);
        
        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );
        Offset += ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserMarshall
//
//  Synopsis:   Marshalls an HENHMETAFILE object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHENHMETAFILE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pHEnhMetafile );
        
        if ( !*pHEnhMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data

        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetEnhMetaFileBits( *pHEnhMetafile,
                                      ulDataSize,
                                      (uchar*)pBuffer ) )
           RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));

        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.        
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong(*(HANDLE *)pHEnhMetafile);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshallWorker
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile,
    ULONG_PTR       BufferSize )
{
    HENHMETAFILE    hEnhMetafile;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get the tag and handle.  Caller checked for EOB.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hEnhMetafile = (HENHMETAFILE) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( GDI_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hEnhMetafile )
        {
            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup + (4 * sizeof( ULONG )) );

            // Byte blob : conformant size, size field, data

            ulong ulDataSize = *( PULONG_LV_CAST pBuffer)++;
            if ( *( PULONG_LV_CAST pBuffer)++ != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup + (4 * sizeof(ULONG)) + ulDataSize );

            hEnhMetafile = SetEnhMetaFileBits( ulDataSize, (uchar*) pBuffer );            
            pBuffer += ulDataSize;
        }
    }
    else
    { 
        if ( !IS_HANDLE_MARKER( UnionDisc ) )
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        
        if ( GDI_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }

    // No reusage of the old object.
    if (*pHEnhMetafile)
        DeleteEnhMetaFile( *pHEnhMetafile );

    *pHEnhMetafile = hEnhMetafile;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work out into a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserUnmarshal\n"));

    // Get the buffer size and start of buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = HENHMETAFILE_UserUnmarshalWorker( pFlags,
                                                pBufferStart,
                                                pHEnhMetafile,
                                                BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserFree
//
//  Synopsis:   Free an HENHMETAFILE.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HENHMETAFILE_UserFree(
    unsigned long * pFlags,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HENHMETAFILE_UserFree\n"));

    if( pHEnhMetafile  &&  *pHEnhMetafile )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteEnhMetaFile( *pHEnhMetafile );
            }
        }
}


// #########################################################################
//
//  HMETAFILE
//  See transmit.h for explanation of gdi data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserSize
//
//  Synopsis:   Get the wire size the HMETAFILE handle and data.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);

    if ( ! *pHMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Pointee of the union arm for the remote case.
        // Byte blob : conformant size, size field, data        
        Offset += 2 * sizeof(long);

        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );
        Offset += ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserMarshal
//
//  Synopsis:   Marshals an HMETAFILE object into the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHMETAFILE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*pHMetafile);

        if ( !*pHMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data

        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetMetaFileBitsEx( *pHMetafile,
                                     ulDataSize,
                                     (uchar*)pBuffer ) )
           RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));

        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.
        
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*(HANDLE *)pHMetafile);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserUnmarshal
//
//  Synopsis:   Unmarshalls an HMETAFILE object from the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{
    HMETAFILE    hMetafile;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserUnmarshal\n"));

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save the fixup size.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof(ULONG)) );

    unsigned long UnionDisc =  *( PULONG_LV_CAST pBuffer)++;
    hMetafile = (HMETAFILE) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( GDI_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hMetafile )
        {
            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup + (4 * sizeof( ULONG )) );
            
            // Byte blob : conformant size, size field, data
            ulong ulDataSize = *( PULONG_LV_CAST pBuffer)++;
            if ( *( PULONG_LV_CAST pBuffer)++ != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE( BufferSize,
                               cbFixup + (4 * sizeof( ULONG )) + ulDataSize );

            hMetafile = SetMetaFileBitsEx( ulDataSize, (uchar*) pBuffer );            
            pBuffer += ulDataSize;
        }
    }
    else 
    {
        if ( !IS_HANDLE_MARKER( UnionDisc ) )
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

        if ( GDI_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }

    // No reusage of the old object.

    if (*pHMetafile)
        DeleteMetaFile( *pHMetafile );

    *pHMetafile = hMetafile;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserFree
//
//  Synopsis:   Free an HMETAFILE.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILE_UserFree(
    unsigned long * pFlags,
    HMETAFILE     * pHMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILE_UserFree\n"));

    if( pHMetafile  &&  *pHMetafile )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteMetaFile( *pHMetafile );
        }
    }
}


#if defined(_WIN64)


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserSize64
//
//  Synopsis:   Get the wire size the HMETAFILEPICT handle and data.
//
//  Derivation: Union of a long and the meta file pict handle.
//              Then struct with top layer (and a hmetafile handle).
//              The the representation of the metafile.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILEPICT_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return Offset;
    
    // Discriminant of the encapsulated union and the union arm.
    // Union discriminant is 4 bytes
    LENGTH_ALIGN( Offset, 7 );
    Offset += 4;
    LENGTH_ALIGN( Offset, 7 );

    // Rest of the upper layer:
    //   (already aligned on 8)
    //   pointer marker (or handle)    8
    Offset += 8;    

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        return Offset;
    }

    if ( ! *pHMetaFilePict )
    {
        return Offset;
    }

    // METAFILEPICT is a structure containing an HMETAFILE.
    // The structure is GlobalAlloc'd.    
    METAFILEPICT *
        pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

    if ( pMFP == NULL )
        RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

    //   3xlong            12
    //   (align on 8)      4
    //   lower lev ptr.    8
    // Lower level:
    //   (already aligned on 8)
    //   discriminant      4
    //   (align on 8)      4
    Offset += 32;

    // Lower layer: userHMETAFILE union...
    if ( GDI_DATA_PASSING( *pFlags) )
    {
        // pointer         8
        // BYTE_BLOB:
        // conformance     8
        // size            4
        // bytes           ulDataSize
        ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );
        if (0 == ulDataSize)
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        Offset += 20 + ulDataSize;
    }
    else
    {
        // handle          8        
        Offset += 8;
    }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( Offset ) ;
}


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserMarshal64
//
//  Synopsis:   Marshalls an HMETAFILEPICT object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserMarshal64\n"));

    ALIGN( pBuffer, 7 );

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)( pHMetaFilePict );

        return pBuffer;
    }

    // userHMETAFILEPICT
    // We need to send the data from the top (hglobal) layer.

    *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
    ALIGN( pBuffer, 7 );
    *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)( pHMetaFilePict );

    if ( ! *pHMetaFilePict )
        return pBuffer;

    // remoteHMETAFILEPICT

    METAFILEPICT * pMFP = (METAFILEPICT*)GlobalLock( *(HANDLE *)pHMetaFilePict );
    if ( pMFP == NULL )
        RpcRaiseException( E_OUTOFMEMORY );

    *( PULONG_LV_CAST pBuffer)++ = pMFP->mm;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->xExt;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->yExt;
    ALIGN( pBuffer, 7 );
    *( PHYPER_LV_CAST pBuffer)++ = USER_MARSHAL_MARKER;

    // See if the HMETAFILE needs to be sent as data, too.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHMETAFILE
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)( pMFP->hMF );

        if ( pMFP->hMF )
        {
            ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );
            if (0 == ulDataSize)
            {
                GlobalUnlock (*(HANDLE *)pHMetaFilePict);
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            }
            
            // conformant size then the size field
            *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;
            *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
            
            GetMetaFileBitsEx( pMFP->hMF, ulDataSize , pBuffer );
            
            pBuffer += ulDataSize;
        }
    }
    else
    {
        // Sending only an HMETAFILE handle.            
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)( pMFP->hMF );
    }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshalWorker64
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    BOOL            fAllocMetaFile = FALSE;
    HMETAFILEPICT   hMetaFilePict;
    
    stream.Align(8);

    unsigned long UnionDisc = stream.ReadULONGNA();
    hMetaFilePict = (HMETAFILEPICT)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc ) )
    {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hMetaFilePict )
        {
            HGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, sizeof(METAFILEPICT) );
            HMETAFILEPICT hmfTemp = (HMETAFILEPICT) hGlobal;

            if ( hmfTemp == NULL )
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

            METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock((HANDLE) hmfTemp);
            if ( pMFP == NULL )
            {
                GlobalFree((HANDLE)hmfTemp);
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
            }
         
            fAllocMetaFile = TRUE;
   
            RpcTryFinally
            {
                pMFP->mm   = stream.ReadULONGNA();
                pMFP->xExt = stream.ReadULONGNA();
                pMFP->yExt = stream.ReadULONGNA();

                // validate marker.
                if ( stream.ReadHYPER() != USER_MARSHAL_MARKER )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                UnionDisc = stream.ReadULONGNA();
                pMFP->hMF = (HMETAFILE)stream.ReadHYPER();

                if ( pMFP->hMF )
                {
                    if ( IS_DATA_MARKER( UnionDisc ) )
                    {
                        if ( GDI_HANDLE_PASSING(*pFlags) )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                        // Conformant size then the size field.  These must be the same.
                        ULONG ulDataSize = (ULONG)stream.ReadHYPERNA();
                        if ( ulDataSize == stream.ReadULONGNA() )
                        {
                            stream.CheckSize(ulDataSize);
                            pMFP->hMF = SetMetaFileBitsEx( ulDataSize, 
                                                           (uchar*)stream.GetBuffer() );
                            if (NULL == pMFP->hMF)
                                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                            stream.Advance(ulDataSize);
                        }
                        else
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                    else 
                    {
                        if ( !IS_HANDLE64_MARKER( UnionDisc ) )
                            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

                        if ( GDI_DATA_PASSING(*pFlags) )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                }

                GlobalUnlock( (HANDLE) hmfTemp );
                hMetaFilePict = hmfTemp;
                hmfTemp = NULL;
            }
            RpcFinally
            {
                if (hmfTemp != NULL)
                {
                    GlobalUnlock( (HANDLE) hmfTemp );
                    GlobalFree( (HANDLE) hmfTemp );
                }
            }
            RpcEndFinally;
        }
    }
    else 
    {
        if ( !IS_HANDLE64_MARKER( UnionDisc ) )
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

        if ( HGLOBAL_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }


    // no reusage, just release the previous one.    
    if ( *pHMetaFilePict )
    {
        // This may happen on the client only and doesn't depend on
        // how the other one was passed.
        METAFILEPICT *
            pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

        if ( pMFP == NULL )
        {
            if (fAllocMetaFile)
            {
                // Do our best to clean up before we throw.
                METAFILEPICT *ptmfp = (METAFILEPICT*)GlobalLock((HANDLE)hMetaFilePict);
                if (ptmfp)
                {
                    if (ptmfp->hMF)
                        DeleteMetaFile(ptmfp->hMF);
                    
                    GlobalUnlock((HANDLE)hMetaFilePict);
                }
                GlobalFree(hMetaFilePict);
            }
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
        }
        
        if ( pMFP->hMF )
            DeleteMetaFile( pMFP->hMF );
        
        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
    }

    *pHMetaFilePict = hMetaFilePict;

    return( stream.GetBuffer() );
}
//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserUnmarshal64\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HMETAFILEPICT_UserUnmarshalWorker64( pFlags,
                                                    pBufferStart,
                                                    pHMetaFilePict,
                                                    BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserFree64
//
//  Synopsis:   Free an HMETAFILEPICT.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILEPICT_UserFree64 (
    unsigned long * pFlags,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILEPICT_UserFree64\n"));
    
    if( pHMetaFilePict  &&  *pHMetaFilePict )
    {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            return;
        
        // Need to free the upper hglobal part.
        
        METAFILEPICT *
            pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );
        
        if ( pMFP == NULL )
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
        
        // See if we need to free the hglobal, too.
        
        if ( pMFP->hMF  &&  HGLOBAL_DATA_PASSING(*pFlags) )
            DeleteMetaFile( pMFP->hMF );

        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserSize64
//
//  Synopsis:   Get the wire size the HENHMETAFILE handle and data.
//
//  Derivation: Union of a long and the meta file handle and then struct.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------
unsigned long  __RPC_USER
HENHMETAFILE_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );
    
    // The encapsulated union.
    //   (aligned on 8)
    //   discriminant      4
    //   (align on 8)      4
    //   pointer or handle 8
    Offset += 16;

    if ( ! *pHEnhMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // BYTE_BLOB
        //   (aligned on 8)
        //   conformance   8
        //   size          4
        //   data          ulDataSize
        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );
        if (0 == ulDataSize)
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        Offset += 12 + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserMarshal64
//
//  Synopsis:   Marshalls an HENHMETAFILE object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserMarshal64\n"));

    ALIGN( pBuffer, 7 );
    
    // Discriminant of the encapsulated union and union arm.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHENHMETAFILE
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHEnhMetafile);

        if ( !*pHEnhMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data
        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );

        *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetEnhMetaFileBits( *pHEnhMetafile,
                                      ulDataSize,
                                      (uchar*)pBuffer ) )
            RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));
        
        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.
        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHEnhMetafile);
    }
    
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshallWorker64
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    HENHMETAFILE    hEnhMetafile;

    stream.Align(8);

    // Get the tag and handle.  Caller checked for EOB.
    unsigned long UnionDisc = stream.ReadULONGNA();
    hEnhMetafile = (HENHMETAFILE)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( GDI_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hEnhMetafile )
        {
            // Byte blob : conformant size, size field, data            
            ulong ulDataSize = (ulong)stream.ReadHYPERNA();
            if ( stream.ReadULONGNA() != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            
            stream.CheckSize(ulDataSize);
            hEnhMetafile = SetEnhMetaFileBits( ulDataSize, (uchar*)stream.GetBuffer() );
            if (NULL == hEnhMetafile)
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            stream.Advance(ulDataSize);
        }
    }
    else 
    {
        if ( !IS_HANDLE64_MARKER( UnionDisc ) )
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

        if ( GDI_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }

    // No reusage of the old object.

    if (*pHEnhMetafile)
        DeleteEnhMetaFile( *pHEnhMetafile );
    
    *pHEnhMetafile = hEnhMetafile;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserUnmarshal64\n"));

    // Get the buffer size and start of buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = HENHMETAFILE_UserUnmarshalWorker64( pFlags,
                                                  pBufferStart,
                                                  pHEnhMetafile,
                                                  BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserFree64
//
//  Synopsis:   Free an HENHMETAFILE.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HENHMETAFILE_UserFree64 (
    unsigned long * pFlags,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HENHMETAFILE_UserFree64\n"));

    if( pHEnhMetafile  &&  *pHEnhMetafile )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteEnhMetaFile( *pHEnhMetafile );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserSize64
//
//  Synopsis:   Get the wire size the HMETAFILE handle and data.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILE_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    // The encapsulated union.
    //   (aligned on 8)
    //   discriminant     4
    //   (align on 8)     4
    //   ptr or handle    8
    Offset += 16;

    if ( ! *pHMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Byte blob
        //  (aligned on 8)
        //  conformance   8
        //  size          4
        //  data          ulDataSize
        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );
        if (0 == ulDataSize)
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        Offset += 12 + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserMarshal64
//
//  Synopsis:   Marshals an HMETAFILE object into the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserMarshal64\n"));

    ALIGN( pBuffer, 7 );

    // Discriminant of the encapsulated union and union arm.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHMETAFILE
        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHMetafile);

        if ( !*pHMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data
        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );

        *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetMetaFileBitsEx( *pHMetafile,
                                     ulDataSize,
                                     (uchar*)pBuffer ) )
            RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));
        
        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.        
        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*(HANDLE *)pHMetafile);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HMETAFILE object from the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{    
    HMETAFILE    hMetafile;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserUnmarshal64\n"));

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream( pBuffer, MarshalInfo.GetBufferSize() );

    // Align the buffer and save the fixup size.
    stream.Align(8);
    unsigned long UnionDisc = stream.ReadULONGNA();
    hMetafile = (HMETAFILE)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( GDI_HANDLE_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( hMetafile )
        {
            // Byte blob : conformant size, size field, data
            ulong ulDataSize = (ulong)stream.ReadHYPERNA();
            if ( stream.ReadULONGNA() != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            stream.CheckSize(ulDataSize);
            hMetafile = SetMetaFileBitsEx( ulDataSize, (uchar*) stream.GetBuffer() );
            if (NULL == hMetafile)
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            stream.Advance(ulDataSize);
        }
    }
    else 
    {
        if ( !IS_HANDLE64_MARKER( UnionDisc ) )
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

        if ( GDI_DATA_PASSING(*pFlags) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
    }
    
    // No reusage of the old object.    
    if (*pHMetafile)
        DeleteMetaFile( *pHMetafile );
    
    *pHMetafile = hMetafile;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserFree64
//
//  Synopsis:   Free an HMETAFILE.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILE_UserFree64(
    unsigned long * pFlags,
    HMETAFILE     * pHMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILE_UserFree64\n"));
    
    if( pHMetafile  &&  *pHMetafile )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteMetaFile( *pHMetafile );
        }
    }
}

#endif // win64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\hpalette.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       hpalette.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HPALETTE.
//
//  Functions:  
//              HPALETTE_UserSize
//              HPALETTE_UserMarshal
//              HPALETTE_UserUnmarshal
//              HPALETTE_UserFree
//              HPALETTE_UserSize64
//              HPALETTE_UserMarshal64
//              HPALETTE_UserUnmarshal64
//              HPALETTE_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserSize
//
//  Synopsis:   Get the wire size the HPALETTE handle and data.
//
//  Derivation: Union of a long and the hpalette handle.
//              Then the struct represents hpalette.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HPALETTE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return Offset;
    
    LENGTH_ALIGN( Offset, 3 );
    
    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);
    
    if ( ! *pHPalette )
        return Offset;
    
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Conformat struct with version and size and conf array of entries.
        
        Offset += sizeof(long) + 2 * sizeof(short);
        
        // Determine the number of color entries in the palette

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        Offset += cEntries * sizeof(PALETTEENTRY);
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserMarshall
//
//  Synopsis:   Marshalls an HPALETTE object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHPALETTE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*pHPalette);

        if ( ! *pHPalette )
            return pBuffer;

        // rpcLOGPALETTE
        // Logpalette is a conformant struct with a version field,
        // size filed and conformant array of palentries.

        // Determine the number of color entries in the palette

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        // Conformant size

        *( PULONG_LV_CAST pBuffer)++ = cEntries;

        // Fields: both are short!
        // The old code was just setting the version number.
        // They say it has to be that way.

        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) 0x300;
        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) cEntries;

        // Entries: each entry is a struct with 4 bytes.
        // Calculate the resultant data size

        DWORD cbData = cEntries * sizeof(PALETTEENTRY);

        if (cbData)
        {
            if (0 == GetPaletteEntries( *pHPalette,
                                        0,
                                        cEntries,
                                        (PALETTEENTRY *)pBuffer ) )
            {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            }
            pBuffer += cbData;
        }
    }
    else
    {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*(HANDLE *)pHPalette);        
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshallWorker
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette,
    ULONG_PTR       BufferSize )
{
    HPALETTE        hPalette;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get disc and handle.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hPalette = (HPALETTE)LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hPalette )
        {
            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE(
                BufferSize,
                cbFixup + (3 * sizeof(ULONG)) + (2 * sizeof(USHORT))) ;

            // Get the conformant size.

            DWORD           cEntries = *( PULONG_LV_CAST pBuffer)++;
            LOGPALETTE *    pLogPal;

            // If there are 0 color entries, we need to allocate the LOGPALETTE
            // structure with the one dummy entry (it's a variably sized struct).
            // Otherwise, we need to allocate enough space for the extra n-1
            // entries at the tail of the structure

            if (0 == cEntries)
            {
                pLogPal = (LOGPALETTE *) WdtpAllocate( pFlags,
                                                       sizeof(LOGPALETTE));
            }
            else
            {
                pLogPal = (LOGPALETTE *)
                  WdtpAllocate( pFlags,
                                sizeof(LOGPALETTE) +
                                (cEntries - 1) * sizeof(PALETTEENTRY));
            }
            if (NULL == pLogPal)
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

            __try
              {
                  pLogPal->palVersion    = *( PUSHORT_LV_CAST pBuffer)++;
                  pLogPal->palNumEntries = *( PUSHORT_LV_CAST pBuffer)++;
                  if ( pLogPal->palVersion != 0x300 || pLogPal->palNumEntries != cEntries )
                      RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                  
                  // If there are entries, move them into out LOGPALETTE structure                  
                  if (cEntries)
                  {
                      // Check for EOB before accessing data.
                      CHECK_BUFFER_SIZE(
                          BufferSize,
                          cbFixup + (3 * sizeof(ULONG)) +
                          (2 * sizeof(USHORT)) +
                          (cEntries * sizeof(PALETTEENTRY)) );
                      
                      memcpy( &(pLogPal->palPalEntry[0]),
                              pBuffer,
                              cEntries * sizeof(PALETTEENTRY) );
                      pBuffer += cEntries * sizeof(PALETTEENTRY);
                  }

                  // Attempt to create the palette
                  hPalette = CreatePalette(pLogPal);
              }
            __finally
              {
                  // Success or failure, we're done with the LOGPALETTE structure
                  WdtpFree( pFlags, pLogPal );
              }

            // If the creation failed, raise an exception
            if (NULL == hPalette)
            {
                RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
            }
        }
    }
    else
    {
        if ( !IS_HANDLE_MARKER( UnionDisc ) )
        {
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

        if ( GDI_DATA_PASSING(*pFlags) )
        {
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }
    }

    // A new palette is ready, destroy the old one, if needed.

    if ( *pHPalette )
        DeleteObject( *pHPalette );

    *pHPalette = hPalette;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work out inta a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserUnmarshal\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HPALETTE_UserUnmarshalWorker( pFlags,
                                             pBufferStart,
                                             pHPalette,
                                             BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserFree
//
//  Synopsis:   Free an HPALETTE.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HPALETTE_UserFree(
    unsigned long * pFlags,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserFree\n"));

    if( pHPalette  &&  *pHPalette )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteObject( *pHPalette );
        }
    }
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserSize64
//
//  Synopsis:   Get the wire size the HPALETTE handle and data.
//
//  Derivation: Union of a long and the hpalette handle.
//              Then the struct represents hpalette.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HPALETTE_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    // The encapsulated union.
    //   (aligned to 8)
    //   discriminant    4
    //   (align to 8)    4
    //   ptr or handle   8
    Offset += 16;

    if ( ! *pHPalette )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Conformat struct with version and size and conf array of entries.
        //   (aligned to 8)
        //   conformance    8
        //   palVersion     2
        //   palNumEntries  2
        //   entries        sizeof(PALETTEENTRY) * cEntries

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);
        Offset += 12 + (cEntries * sizeof(PALETTEENTRY));
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserMarshal64
//
//  Synopsis:   Marshalls an HPALETTE object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserMarshal\n"));

    ALIGN( pBuffer, 7 );

    // Discriminant of the encapsulated union and union arm.    
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHPALETTE
        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHPalette);

        if ( ! *pHPalette )
            return pBuffer;
        
        // rpcLOGPALETTE
        // Logpalette is a conformant struct with a version field,
        // size filed and conformant array of palentries.
        
        // Determine the number of color entries in the palette
        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        // Conformant size
        *( PHYPER_LV_CAST pBuffer)++ = cEntries;

        // Fields: both are short!
        // The old code was just setting the version number.
        // They say it has to be that way.
        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) 0x300;
        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) cEntries;

        // Entries: each entry is a struct with 4 bytes.
        // Calculate the resultant data size
        DWORD cbData = cEntries * sizeof(PALETTEENTRY);

        if (cbData)
        {
            if (0 == GetPaletteEntries( *pHPalette,
                                        0,
                                        cEntries,
                                        (PALETTEENTRY *)pBuffer ) )
            {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            }

            pBuffer += cbData;
        }
    }
    else
    {
        // Sending a handle.
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*(HANDLE *)pHPalette);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshalWorker64
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    HPALETTE        hPalette;

    // Align the buffer and save the fixup size.
    stream.Align(8);

    // Get disc and handle.
    unsigned long UnionDisc = stream.ReadULONGNA();
    hPalette = (HPALETTE)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hPalette )
        {
            // Get the conformant size.
            DWORD           cEntries = (DWORD)stream.ReadHYPER();
            LOGPALETTE *    pLogPal;

            // If there are 0 color entries, we need to allocate the LOGPALETTE
            // structure with the one dummy entry (it's a variably sized struct).
            // Otherwise, we need to allocate enough space for the extra n-1
            // entries at the tail of the structure
            
            if (0 == cEntries)
            {
                pLogPal = (LOGPALETTE *) WdtpAllocate( pFlags,
                                                       sizeof(LOGPALETTE));
            }
            else
            {
                pLogPal = (LOGPALETTE *) WdtpAllocate( pFlags,
                                                       sizeof(LOGPALETTE) +
                                                       (cEntries - 1) * sizeof(PALETTEENTRY));
            }
            if (NULL == pLogPal)
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

            __try
              {
                  pLogPal->palVersion    = stream.ReadUSHORTNA();
                  pLogPal->palNumEntries = stream.ReadUSHORTNA();
                  if ( pLogPal->palVersion != 0x300 || pLogPal->palNumEntries != cEntries )
                      RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                  
                  // If there are entries, move them into out LOGPALETTE structure
                  if (cEntries)
                  {
                      // Check for EOB before accessing data.
                      stream.CheckSize(cEntries * sizeof(PALETTEENTRY));
                      
                      memcpy( &(pLogPal->palPalEntry[0]),
                              stream.GetBuffer(),
                              cEntries * sizeof(PALETTEENTRY) );
                      
                      stream.Advance(cEntries * sizeof(PALETTEENTRY));
                  }

                  // Attempt to create the palette
                  hPalette = CreatePalette(pLogPal);
              }
            __finally
              {
                  // Success or failure, we're done with the LOGPALETTE structure
                  WdtpFree( pFlags, pLogPal );
              }

            // If the creation failed, raise an exception
            if (NULL == hPalette)
            {
                RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
            }
        }
    }
    else 
    {
        if ( !IS_HANDLE64_MARKER( UnionDisc ) )
        {
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }


        if ( GDI_DATA_PASSING(*pFlags) )
        {
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }
    }
    
    // A new palette is ready, destroy the old one, if needed.
    if ( *pHPalette )
        DeleteObject( *pHPalette );

    *pHPalette = hPalette;
    
    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserUnmarshal\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HPALETTE_UserUnmarshalWorker64( pFlags,
                                               pBufferStart,
                                               pHPalette,
                                               BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserFree64
//
//  Synopsis:   Free an HPALETTE.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HPALETTE_UserFree64 (
    unsigned long * pFlags,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserFree\n"));

    if( pHPalette  &&  *pHPalette )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteObject( *pHPalette );
        }
    }
}

#endif // win64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\prop.h ===
#include "propidl.h"  // Public property interfaces
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\transmit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       transmit.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//  Functions:  
//              HBRUSH_UserSize
//              HBRUSH_UserMarshal
//              HBRUSH_UserUnmarshal
//              HBRUSH_UserFree
//              HACCEL_UserSize
//              HACCEL_UserMarshal
//              HACCEL_UserUnmarshal
//              HACCEL_UserFree
//              HWND_UserSize
//              HWND_UserMarshal
//              HWND_UserUnmarshal
//              HWND_UserFree
//              HMENU_UserSize
//              HMENU_UserMarshal
//              HMENU_UserUnmarshal
//              HMENU_UserFree
//              HICON_User*
//              HDC_UserSize
//              HDC_UserMarshal
//              HDC_UserUnmarshal
//              HDC_UserFree
//
//  History:    24-Aug-93   ShannonC    Created
//              24-Nov-93   ShannonC    Added HGLOBAL
//              14-May-94   DavePl      Added HENHMETAFILE
//              18-May-94   ShannonC    Added HACCEL, UINT, WPARAM
//              19-May-94   DavePl      Added HENHMETAFILE to STGMEDIUM code
//                 May-95   Ryszardk    Wrote all the _User* routines
//                 Feb-96   Ryszardk    Added CLIPFORMAT support
//              25-Jun-99   a-olegi     Added HDC code
//              14-Dec-00   JohnDoty    Because the size of the code nearly
//                                      doubled for NDR64, factored out the
//                                      involved routines to seperate files.
//                                      see:
//                                         clipformat.cxx
//                                         bitmap.cxx
//                                         hpalette.cxx
//                                         metafile.cxx
//                                         snb.cxx
//                                         hglobal.cxx
//                                         stgmedium.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>


WINOLEAPI_(void) ReleaseStgMedium(LPSTGMEDIUM pStgMed);

#pragma code_seg(".orpc")

EXTERN_C const CLSID CLSID_MyPSFactoryBuffer = {0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}};

// Used to detect if the channel is a CRpcChannelBuffer object
extern const IID IID_CPPRpcChannelBuffer;

class CRpcChannelBuffer;

extern HRESULT GetIIDFromObjRef(OBJREF &objref, IID **piid);


// These methods are needed as the object is used for interface marshaling.

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::AddRef( THIS )
{
  return ref_count += 1;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Clone(THIS_ IStream * *ppstm)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Commit(THIS_ DWORD grfCommitFlags)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::CopyTo(THIS_ IStream *pstm,
                  ULARGE_INTEGER cb,
                  ULARGE_INTEGER *pcbRead,
                  ULARGE_INTEGER *pcbWritten)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
CStreamOnMessage::CStreamOnMessage(unsigned char **ppMessageBuffer)
    : ref_count(1), ppBuffer(ppMessageBuffer), cbMaxStreamLength(0xFFFFFFFF)
{
    pStartOfStream = *ppMessageBuffer;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::LockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown))
  {
    *ppvObj = (IUnknown *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else if (IsEqualIID(riid, IID_IStream))
  {
    *ppvObj = (IStream *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else
    return ResultFromScode(E_NOINTERFACE);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Read(THIS_ VOID HUGEP *pv,
                  ULONG cb, ULONG *pcbRead)
{
  memcpy( pv, *ppBuffer, cb );
  *ppBuffer += cb;
  if (pcbRead != NULL)
    *pcbRead = cb;
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::Release( THIS )
{
  ref_count -= 1;
  if (ref_count == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;

}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Revert(THIS)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Seek(THIS_ LARGE_INTEGER dlibMove,
                                    DWORD dwOrigin,
                                    ULARGE_INTEGER *plibNewPosition)
{
    ULONG   pos;

    // Verify that the offset isn't out of range.
    if (dlibMove.HighPart != 0)
        return ResultFromScode( E_FAIL );

    // Determine the new seek pointer.
    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        pos = dlibMove.LowPart;
        break;

    case STREAM_SEEK_CUR:
        /* Must use signed math here. */
        pos = (ULONG) (*ppBuffer - pStartOfStream);
        if ((long) dlibMove.LowPart < 0 &&
            pos < (unsigned long) - (long) dlibMove.LowPart)
            return ResultFromScode( E_FAIL );
        pos += (long) dlibMove.LowPart;
        break;

    case STREAM_SEEK_END:
        return ResultFromScode(E_NOTIMPL);
        break;

    default:
        return ResultFromScode( E_FAIL );
    }

    // Set the seek pointer.
    *ppBuffer = pStartOfStream + pos;
    if (plibNewPosition != NULL)
    {
        plibNewPosition->LowPart = pos;
        plibNewPosition->HighPart = 0;
    }
    return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Stat(THIS_ STATSTG *pstatstg, DWORD grfStatFlag)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Write(THIS_ VOID const HUGEP *pv,
                  ULONG cb,
                  ULONG *pcbWritten)
{
  // Write the data.
  memcpy( *ppBuffer, pv, cb );
  if (pcbWritten != NULL)
    *pcbWritten = cb;
  *ppBuffer += cb;
  return ResultFromScode(S_OK);
}



// #########################################################################
//
//  WdtpRemotableHandle helper
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserSize
//
//  Synopsis:   Sizes a void star handle as a union with a long.
//              Handle size may be 8 bytes but on wire it is still a long.
//
//  history:    Dec-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
WdtpRemotableHandle_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    LONG_PTR      * pHandle )
{
    if ( !pHandle )
        return Offset;

    if ( *pHandle && DIFFERENT_MACHINE_CALL(*pFlags) )
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

    LENGTH_ALIGN( Offset, 3 );

    // 4 bytes for discriminator, 4 bytes for the long.
    return( Offset + 8 ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserMarshall
//
//  Synopsis:   Marshalls a handle as a union with a long.
//              We represent a GDI or USER handle, which may be 4 or 8 bytes,
//              as a long on wire.
//
//  history:    Dec-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpRemotableHandle_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    LONG_PTR      * pHandle )
{
    if ( !pHandle )
        return pBuffer;

    if ( *pHandle && DIFFERENT_MACHINE_CALL(*pFlags) )
        RpcRaiseException( RPC_S_INVALID_TAG );

    ALIGN( pBuffer, 3 );

    *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
    *( PLONG_LV_CAST pBuffer)++ = (long)*pHandle;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserUnmarshall
//
//  Synopsis:   Unmarshalls a remotable void star as union with ulong.
//              Handle is represented as a long on wire.
//              On 64b platforms, we sign extended it to 8 bytes to get
//              the proper USER or GDI handle representation.
//
//  history:    Dec-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//              Aug-99   JohnStra      Added consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpRemotableHandle_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    LONG_PTR      * pHandle )
{
    unsigned long HandleMarker;

    // Should not be getting one of these cross-machine.
    if ( DIFFERENT_MACHINE_CALL(*pFlags) )
        RpcRaiseException( RPC_S_INVALID_TAG );

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save fixup size.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing data.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    HandleMarker = *( PULONG_LV_CAST pBuffer)++;

    if ( HandleMarker == WDT_HANDLE_MARKER )
        *pHandle = *( PLONG_LV_CAST pBuffer)++;
    else
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserFree
//
//--------------------------------------------------------------------------

void __RPC_USER
WdtpRemotableHandle_UserFree(
    unsigned long * pFlags,
    LONG_PTR * pHandle )
{
}

//+-------------------------------------------------------------------------

//
//  Function:   HWND_UserSize
//
//  Synopsis:   Sizes an HWND handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HWND_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserMarshall
//
//  Synopsis:   Marshalls an HWND handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HWND handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserFree
//
//  Synopsis:   Shouldn't be called.
//
//--------------------------------------------------------------------------

void __RPC_USER
HWND_UserFree(
    unsigned long * pFlags,
    HWND          * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserSize
//
//  Synopsis:   Sizes an HMENU handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMENU_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserMarshall
//
//  Synopsis:   Marshalls an HMENU handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HMENU handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserFree
//
//  Synopsis:   Free an HMENU.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMENU_UserFree(
    unsigned long * pFlags,
    HMENU         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserSize
//
//  Synopsis:   Sizes an HACCEL handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HACCEL_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserMarshall
//
//  Synopsis:   Marshalls an HACCEL handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HACCEL handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserFree
//
//  Synopsis:   Free an HACCEL.
//
//--------------------------------------------------------------------------

void __RPC_USER
HACCEL_UserFree(
    unsigned long * pFlags,
    HACCEL        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserSize
//
//  Synopsis:   Sizes an HBRUSH handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBRUSH_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserMarshall
//
//  Synopsis:   Marshalls an HBRUSH handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBRUSH handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserFree
//
//  Synopsis:   Free an HBRUSH.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBRUSH_UserFree(
    unsigned long * pFlags,
    HBRUSH        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserSize
//
//  Synopsis:   Sizes an HICON handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HICON_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserFree
//
//  Synopsis:   Free an HICON.
//
//--------------------------------------------------------------------------

void __RPC_USER
HICON_UserFree(
    unsigned long * pFlags,
    HICON         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserSize
//
//  Synopsis:   Sizes an HDC handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HDC_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserFree
//
//  Synopsis:   Free an HDC.
//
//--------------------------------------------------------------------------

void __RPC_USER
HDC_UserFree(
    unsigned long * pFlags,
    HDC           * pH )
{
}


// #########################################################################
//
//  Interface pointers.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserSize
//
//  Synopsis:   Get the wire size for an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned long  __RPC_USER __stdcall
WdtpInterfacePointer_UserSize (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned long       Offset,
    IUnknown          * pIf,
    const IID &         IId )
{
    if ( pIf )
        {
        LENGTH_ALIGN( Offset, 3 );

        //Leave space for array bounds and length

        Offset += 2 * sizeof(long);

        HRESULT         hr;
        unsigned long   cbSize = 0;

        hr = CoGetMarshalSizeMax( &cbSize,
                                  IId,
                                  pIf,
                                  USER_CALL_CTXT_MASK( Flags ),
                                  pContext->pStubMsg->pvDestContext,
                                  MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
            RAISE_RPC_EXCEPTION( hr );

        Offset += cbSize;
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserMarshal
//
//  Synopsis:   Marshalls an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserMarshal (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned char     * pBuffer,
    IUnknown          * pIf,
    const IID &         IId )
{
    unsigned long * pMaxCount, *pSize;
    unsigned long   cbData = 0;

    UserNdrDebugOut((UNDR_OUT1, "WdtpInterface_PointerMarshal\n"));

    if ( pIf )
        {
        // Always marshaled because of the apartment model.

        CStreamOnMessage MemStream( (unsigned char **) &pBuffer );

        ALIGN( pBuffer, 3 );

        pMaxCount = (unsigned long *) pBuffer;
        pBuffer += 4;

        // Leave space for length

        pSize = (unsigned long *) pBuffer;
        pBuffer += 4;

        HRESULT  hr;
        unsigned char * pBufferMark = pBuffer;

        hr = CoMarshalInterface( &MemStream,
                                 IId,
                                 pIf,
                                 USER_CALL_CTXT_MASK( Flags ),
                                 pContext->pStubMsg->pvDestContext,
                                 MSHLFLAGS_NORMAL );
        if( FAILED(hr) )
            {
            RpcRaiseException(hr);
            }

        // Calculate the size of the data written

        DWORD cbData = (ULONG) (pBuffer - pBufferMark);

        // Update the array bounds.

        *pMaxCount = cbData;
        *pSize = cbData;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserUnmarshalWorker
//
//  Synopsis:   Unmarshalls an interface pointer from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//              Oct-00   ScottRob/
//                       YongQu        NDR64 Support.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpInterfacePointer_UserUnmarshalWorker (
    USER_MARSHAL_CB   * pContext,
    unsigned char     * pBuffer,
    IUnknown         ** ppIf,
    const IID &         IId,
    ULONG_PTR           BufferSize,
    BOOL fNDR64 )
{
    unsigned long      *pMaxCount, *pSize;
    unsigned long       cbData = 0;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    if (fNDR64) ALIGN(pBuffer, 7); else ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing data.
    int cbHeader = (int)((fNDR64) ? 3*sizeof( ULONG ) : 2*sizeof( ULONG ));

    CHECK_BUFFER_SIZE( BufferSize, cbFixup + cbHeader + 2*sizeof( ULONG ) + sizeof( GUID ) );
    UserNdrDebugOut((UNDR_OUT1, "WdtpInterfacePointerUnmarshal\n"));

    pMaxCount = (unsigned long *) pBuffer;
    pBuffer += sizeof(long);

    if (fNDR64) pBuffer += sizeof(long);  //NDR64 Padding

    //Unmarshal count
    pSize = (unsigned long *) pBuffer;
    pBuffer += sizeof(long);

    // max count and unmarshal count must be the same.
    if ( *pSize != *pMaxCount )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Get IID from the OBJREF and verify that it matches the supplied IID.
    IID* piid;
    if( FAILED( GetIIDFromObjRef( *(OBJREF *)pBuffer, &piid ) ) )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    if( 0 != memcmp( &IId, piid, sizeof(IID) ) )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Check for EOB before unmarshaling.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + cbHeader + *pSize );

    // Release the old pointer after unmarshalling the new one
    // to prevent object from getting released too early.
    // Then release the old one only when successful.

    IUnknown * punkTemp = 0;

//CodeReview: The original code
// CNdrStream MemStream( pBuffer,
//               (ULONG) BufferSize + (2 * sizeof(ULONG)) + *pSize );
// Doesn't look right... We just verified that BufferSize was large enough to
// hold the data. Then we tell the CNdrStream that the size of buffer is double
// that size when we should be only unmarshaling pSize bytes.
// Is this to prevent CoUnmarshalInterface from running up against the end of a corrupted stream?

    // Use a CNdrStream for unmarshaling because it checks for buffer overruns.
    CNdrStream MemStream( pBuffer,
                  (ULONG) *pSize );

    HRESULT hr = CoUnmarshalInterface( &MemStream,
                                       IId,
                                       (void **) &punkTemp );
    if(FAILED(hr))
        {
        RAISE_RPC_EXCEPTION(hr);
        }
    else
        {
        // Get the number of bytes read from the stream.
        LARGE_INTEGER lOffset = { 0, 0 };
        ULARGE_INTEGER ulCurPos;
        hr = MemStream.Seek( lOffset, STREAM_SEEK_CUR, &ulCurPos );
        if ( FAILED(hr) )
            RAISE_RPC_EXCEPTION( hr );

        // Make sure the number of bytes read is what we expected.
        if ( ulCurPos.LowPart != *pSize )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        // Increment pBuffer pointer by the amount we unmarshaled from it.
        pBuffer += ulCurPos.LowPart;

        // On the client side, release the [in,out] interface pointer.
        // The pointer may be different from NULL only on the client side.

        // release the old one, keep the new one.

        if ( *ppIf )
            (*ppIf)->Release();
        *ppIf = punkTemp;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserUnmarshal
//
//  Synopsis:   Unmarshalls an interface pointer from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work out into
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserUnmarshal (
    USER_MARSHAL_CB   * pContext,
    unsigned char     * pBuffer,
    IUnknown         ** ppIf,
    const IID &         IId )
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( (ULONG*)pContext, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Delegate to worker routine.
    pBuffer = WdtpInterfacePointer_UserUnmarshalWorker( pContext,
                                                        pBufferStart,
                                                        ppIf,
                                                        IId,
                                                        BufferSize,
                                                        FALSE );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserFree
//
//  Synopsis:   Releases an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

EXTERN_C void __RPC_USER __stdcall
WdtpInterfacePointer_UserFree(
    IUnknown      * pIf )
{
    UserNdrDebugOut((UNDR_OUT1, "WdtpInterfacePointer_UserFree\n"));

    if( pIf )
        {
        pIf->Release();
        }
}




#if (DBG==1)
//+-------------------------------------------------------------------------
//
//  Function:   WdtpGetStgmedName
//
//  Synopsis:   Debug support
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

char *
WdtpGetStgmedName( STGMEDIUM * pStgmed)

{
    char * Name;
    if ( pStgmed )
        {
        switch (pStgmed->tymed)
            {
            case TYMED_NULL:
                Name = "TYMED_NULL";
                break;
            case TYMED_MFPICT:
                Name = "TYMED_MFPICT";
                break;
            case TYMED_ENHMF:
                Name = "TYMED_ENHMF";
                break;
            case TYMED_GDI:
                Name = "TYMED_GDI";
                break;
            case TYMED_HGLOBAL:
                Name = "TYMED_HGLOBAL";
                break;
            case TYMED_FILE:
                Name = "TYMED_FILE";
                break;
            case TYMED_ISTREAM:
                Name = "TYMED_ISTREAM";
                break;
            case TYMED_ISTORAGE:
                Name = "TYMED_ISTORAGE";
                break;
            default:
                Name = "TYMED invalid";
                break;
            }
        return Name;
        }
    else
        return "STGMED * is null";
}
#endif

//+-------------------------------------------------------------------------
//
//  Class:      CContinue
//
//  Synopsis:   Notification object
//
//--------------------------------------------------------------------------
class CContinue : public IContinue
{
private:
    long _cRef;
    BOOL (__stdcall *_pfnContinue)(LONG_PTR);
    LONG_PTR _dwContinue;
    ~CContinue(void);

public:
    CContinue(BOOL (__stdcall *pfnContinue)(LONG_PTR dwContinue), LONG_PTR dwContinue);

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, void **);

    ULONG STDMETHODCALLTYPE AddRef();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE FContinue();
};




//+-------------------------------------------------------------------------
//
//  Method:     CContinue::CContinue, public
//
//  Synopsis:   Constructor for CContinue
//
//--------------------------------------------------------------------------
CContinue::CContinue(BOOL (__stdcall *pfnContinue)(LONG_PTR dwContinue), LONG_PTR dwContinue)
: _cRef(1), _pfnContinue(pfnContinue), _dwContinue(dwContinue)
{
}

CContinue::~CContinue()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CContinue::QueryInterface, public
//
//  Synopsis:   Query for an interface on the notification object.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CContinue::QueryInterface (
    REFIID iid,
    void **ppv )
{
    HRESULT hr = E_NOINTERFACE;

    if ((IID_IUnknown == iid) || (IID_IContinue == iid))
    {
        this->AddRef();
        *ppv = (IContinue *) this;
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CContinue::AddRef, public
//
//  Synopsis:   Increment the reference count.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CContinue::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return (unsigned long) _cRef;
}

//+-------------------------------------------------------------------------
//
//  Method:     CContinue::Release, public
//
//  Synopsis:   Decrement the reference count.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CContinue::Release()
{
    unsigned long count = _cRef - 1;

    if(0 == InterlockedDecrement((long *)&_cRef))
    {
        count = 0;
        delete this;
    }

    return count;
}


//+-------------------------------------------------------------------------
//
//  Method:     CContinue::FContinue, public
//
//  Synopsis:   Calls the callback function.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CContinue::FContinue()
{
    HRESULT hr;
    BOOL bResult;

    bResult = (*_pfnContinue) (_dwContinue);

    if(bResult == FALSE)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateCallback
//
//  Synopsis:   Create a callback notification object .
//
//--------------------------------------------------------------------------
extern "C" HRESULT CreateCallback(
    BOOL (__stdcall *pfnContinue)(LONG_PTR dwContinue),
    LONG_PTR dwContinue,
    IContinue **ppContinue)
{
    HRESULT hr;

    if(pfnContinue != 0)
    {
        CContinue *pContinue = new CContinue(pfnContinue, dwContinue);

        *ppContinue = (IContinue *) pContinue;

        if(pContinue != 0)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        *ppContinue = 0;
    }

    return hr;
}

////// NDR64 funcs
#ifdef _WIN64

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserSize
//
//  Synopsis:   Sizes an HWND handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HWND_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserMarshall
//
//  Synopsis:   Marshalls an HWND handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return HWND_UserMarshal( pFlags, pBuffer, pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HWND handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserFree
//
//  Synopsis:   Shouldn't be called.
//
//--------------------------------------------------------------------------

void __RPC_USER
HWND_UserFree64(
    unsigned long * pFlags,
    HWND          * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserSize
//
//  Synopsis:   Sizes an HMENU handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMENU_UserSize64(
    unsigned long * pFlags,
    unsigned long   Offset,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserMarshall
//
//  Synopsis:   Marshalls an HMENU handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserMarshal64(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HMENU handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserUnmarshal64(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserFree
//
//  Synopsis:   Free an HMENU.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMENU_UserFree64(
    unsigned long * pFlags,
    HMENU         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserSize
//
//  Synopsis:   Sizes an HACCEL handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HACCEL_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserMarshall
//
//  Synopsis:   Marshalls an HACCEL handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HACCEL handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserFree
//
//  Synopsis:   Free an HACCEL.
//
//--------------------------------------------------------------------------

void __RPC_USER
HACCEL_UserFree64(
    unsigned long * pFlags,
    HACCEL        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserSize
//
//  Synopsis:   Sizes an HBRUSH handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBRUSH_UserSize64(
    unsigned long * pFlags,
    unsigned long   Offset,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserMarshall
//
//  Synopsis:   Marshalls an HBRUSH handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBRUSH handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserFree
//
//  Synopsis:   Free an HBRUSH.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBRUSH_UserFree64(
    unsigned long * pFlags,
    HBRUSH        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserSize
//
//  Synopsis:   Sizes an HICON handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HICON_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserFree
//
//  Synopsis:   Free an HICON.
//
//--------------------------------------------------------------------------

void __RPC_USER
HICON_UserFree64(
    unsigned long * pFlags,
    HICON         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserSize
//
//  Synopsis:   Sizes an HDC handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HDC_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserFree
//
//  Synopsis:   Free an HDC.
//
//--------------------------------------------------------------------------

void __RPC_USER
HDC_UserFree64(
    unsigned long * pFlags,
    HDC           * pH )
{
}


// #########################################################################
//
//  Interface pointers.
//
// #########################################################################


//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserSize64
//
//  Synopsis:   Get the wire size for an interface pointer.
//
//  history:    Oct-00  ScottRob/
//                      YongQu         Created for NDR64 Support
//
//--------------------------------------------------------------------------
EXTERN_C unsigned long  __RPC_USER __stdcall
WdtpInterfacePointer_UserSize64 (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned long       Offset,
    IUnknown          * pIf,
    const IID &         IId )
{
    if ( pIf )
        {
        LENGTH_ALIGN( Offset, 7 );

        //Leave space for array bounds, padding, and length

        Offset += 3 * sizeof(long);

        HRESULT         hr;
        unsigned long   cbSize = 0;

        hr = CoGetMarshalSizeMax( &cbSize,
                                  IId,
                                  pIf,
                                  USER_CALL_CTXT_MASK( Flags ),
                                  pContext->pStubMsg->pvDestContext,
                                  MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
            RAISE_RPC_EXCEPTION( hr );

        Offset += cbSize;
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserMarshal64
//
//  Synopsis:   Marshalls an interface pointer.
//
//  history:    Oct-2000   ScottRob/YongQu      Created for NDR64.
//
//--------------------------------------------------------------------------
EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserMarshal64 (
                                   USER_MARSHAL_CB   * pContext,
                                   unsigned long       Flags,
                                   unsigned char     * pBuffer,
                                   IUnknown          * pIf,
                                   const IID &         IId )
{
    unsigned long * pMaxCount, *pSize;
    unsigned long   cbData = 0;

    UserNdrDebugOut((UNDR_OUT1, "WdtpInterface_PointerMarshal64\n"));

    if ( pIf )
    {
        // Always marshaled because of the apartment model.

        CStreamOnMessage MemStream( (unsigned char **) &pBuffer );

        ALIGN( pBuffer, 7 );        // need to align to 8

        pMaxCount = (unsigned long *) pBuffer;
        pBuffer +=  2 * sizeof( long );        // conformant size is 8

        // Leave space for length

        pSize = (unsigned long *) pBuffer;
        pBuffer += sizeof( long );

        HRESULT  hr;
        unsigned char * pBufferMark = pBuffer;

        hr = CoMarshalInterface( &MemStream,
                                 IId,
                                 pIf,
                                 USER_CALL_CTXT_MASK( Flags ),
                                 pContext->pStubMsg->pvDestContext,
                                 MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
        {
            RpcRaiseException(hr);
        }

        // Calculate the size of the data written

        DWORD cbData = (ULONG) (pBuffer - pBufferMark);

        // Update the array bounds.

        *pMaxCount = cbData;
        *pSize = cbData;
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an interface pointer from the RPC buffer.
//
//  history:    Oct-00   ScottRob/
//                       YongQu        Created for NDR64.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserUnmarshal64 (
    USER_MARSHAL_CB   * pContext,
    unsigned char     * pBuffer,
    IUnknown         ** ppIf,
    const IID &         IId )
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( (ULONG*)pContext, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Delegate to worker routine.
    pBuffer = WdtpInterfacePointer_UserUnmarshalWorker( pContext,
                                                        pBufferStart,
                                                        ppIf,
                                                        IId,
                                                        BufferSize,
                                                        TRUE );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserFree64
//
//  Synopsis:   Frees the unmarshaled interface
//
//  history:    Oct-2000   ScottRob/YongQu      Created for NDR64.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER __stdcall
WdtpInterfacePointer_UserFree64(
    IUnknown      * pIf )
{
    WdtpInterfacePointer_UserFree(pIf);
}

#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\sources.inc ===
NO_CAIRO_LIBS=1

TARGETNAME=oleprx32
TARGETPATH=obj
TARGETTYPE=LIBRARY

ASYNC_DOCFILE_INC=..\..\..\stg\async\docfile\$(DEST_TREE)\$(O)

INCLUDES=..\.;..\..\..\ih
INCLUDES=$(INCLUDES);..\..\..\com\inc
INCLUDES=$(INCLUDES);..\..\..\com\dcomrem
INCLUDES=$(INCLUDES);..\..\..\idl\internal
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\stg\h
INCLUDES=$(INCLUDES);$(ASYNC_DOCFILE_INC)
INCLUDES=$(INCLUDES);$(BASE_INC_PATH)
INCLUDES=$(INCLUDES);$(TERMSRV_INC_PATH)

CONDITIONAL_INCLUDES=

SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1

C_DEFINES=$(C_DEFINES) -DENTRY_PREFIX=Prx -DPROXY_CLSID=CLSID_PSOlePrx32 -DREGISTER_PROXY_DLL

# All the files listed below ending in _p.c are generated by MIDL

SOURCES= \
         dlldata.c         \
         mega_p.c          \
         mega_i.c          \
         prop_x.c          \
         prop_i.c          \
         ..\call_as.c      \
         ..\pipes.cxx      \
         ..\transmit.cxx   \
         ..\clipformat.cxx \
         ..\snb.cxx        \
         ..\hglobal.cxx    \
         ..\metafile.cxx   \
         ..\bitmap.cxx     \
         ..\hpalette.cxx   \
         ..\stgmedium.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\snb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       clipformat.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for SNB.
//
//  Functions:  
//              SNB_UserSize
//              SNB_UserMarshal
//              SNB_UserUnmarshal
//              SNB_UserFree
//              SNB_UserSize64
//              SNB_UserMarshal64
//              SNB_UserUnmarshal64
//              SNB_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserSize
//
//  Synopsis:   Sizes an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
SNB_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    SNB           * pSnb )
{
    if ( ! pSnb )
        return Offset;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
        {
        SNB snb = *pSnb;

        WCHAR *psz = *snb;
        while (psz)
            {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
            }
        }

    // The wire size is: conf size, 2 fields and the wchars.

    LENGTH_ALIGN( Offset, 3 );

    return ( Offset + 3 * sizeof(long) + ulCntChar * sizeof( WCHAR ) );
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserMarshall
//
//  Synopsis:   Marshalls an SNB into the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
SNB_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserMarshal\n"));

    if ( ! pSnb )
        return pBuffer;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
        {
        SNB snb = *pSnb;

        WCHAR *psz = *snb;
        while (psz)
            {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
            }
        }

    // conformant size

    ALIGN( pBuffer, 3 );
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // fields

    *( PULONG_LV_CAST pBuffer)++ = ulCntStr;
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // actual strings only

    if ( pSnb  &&  *pSnb )
        {
        // There is a NULL string pointer to mark the end of the pointer array.
        // However, the strings don't have to follow tightly.
        // Hence, we have to copy one string at a time.

        SNB   snb = *pSnb;
        WCHAR *pszSrc;

        while (pszSrc = *snb++)
            {
            ULONG ulCopyLen = (lstrlenW(pszSrc) + 1) * sizeof(WCHAR);

            WdtpMemoryCopy( pBuffer, pszSrc, ulCopyLen );
            pBuffer += ulCopyLen;
            }
        }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserUnmarshall
//
//  Synopsis:   Unmarshalls an SNB from the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//              Aug-99    JohnStra      Add consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
SNB_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserUnmarshal\n"));

    // Initialize CUserMarshalInfo object and get the buffer
    // size and pointer to the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save the size of the fixup.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before trying to get header.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (3 * sizeof( ULONG )) );

    // Get the header from the buffer.
    ULONG ulCntChar = *( PULONG_LV_CAST pBuffer)++;
    ULONG ulCntStr = *( PULONG_LV_CAST pBuffer)++;
    ULONG ulCntCharDup = *(PULONG_LV_CAST pBuffer)++;

    // Verify that 2nd instance of count matches first.
    if ( ulCntCharDup != ulCntChar )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // No reusage of pSNB.
    if ( *pSnb )
        WdtpFree( pFlags, *pSnb );

    if ( ulCntStr == 0 )
        {
        // There are no strings.

        // NULL pSnb and return.
        *pSnb = NULL;
        return pBuffer;
        }

    // Validate the header:
    // Repeated char count must match first instance and char count must
    // not be less than the number of strings since that would mean at
    // least one of them doesn't isn't terminated.
    if ( (ulCntChar != ulCntCharDup) || (ulCntChar < ulCntStr) )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Check for EOB before trying to get the strings.
    CHECK_BUFFER_SIZE(
        BufferSize,
        cbFixup + (3 * sizeof(ULONG)) + (ulCntChar * sizeof(WCHAR)) );

    // Last WCHAR in the buffer must be the UNICODE terminator.
    WCHAR* pszChars = (WCHAR*) pBuffer;
    if ( pszChars[ulCntChar - 1] != 0x0000 )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // construct the SNB.
    SNB Snb = (SNB) WdtpAllocate( pFlags,
                                  ( (ulCntStr + 1) * sizeof(WCHAR *) +
                                     ulCntChar * sizeof(WCHAR)) );
    *pSnb = Snb;

    if (Snb)
        {
        // create the pointer array within the SNB.  to do this, we go through
        // the buffer, and use strlen to find the end of the each string for
        // us.
        WCHAR *pszSrc = (WCHAR *) pBuffer;
        WCHAR *pszTgt = (WCHAR *) (Snb + ulCntStr + 1); // right behind array

        void* SnbStart = Snb;
        ULONG ulTotLen = 0;
        ULONG i;
        for (i = ulCntStr; (i > 0) && (ulTotLen < ulCntChar); i--)
            {
            *Snb++ = pszTgt;

            ULONG ulLen = lstrlenW(pszSrc) + 1;
            pszSrc += ulLen;
            pszTgt += ulLen;
            ulTotLen += ulLen;
            }

        *Snb++ = NULL;

        // Verify that the number of strings and the number of chars
        // in the buffer matches what is supposed to be there.
        if ( (i > 0) || (ulTotLen < ulCntChar) )
            {
            WdtpFree( pFlags, SnbStart );
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            }

        // Copy the actual strings.
        // We can do a block copy here as we packed them tight in the buffer.
        // Snb points right behind the lastarray of pointers within the SNB.
        WdtpMemoryCopy( Snb, pBuffer, ulCntChar * sizeof(WCHAR) );
        pBuffer += ulCntChar * sizeof(WCHAR);
        }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserFree
//
//  Synopsis:   Frees an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

void __RPC_USER
SNB_UserFree(
    unsigned long * pFlags,
    SNB           * pSnb )
{
    if ( pSnb && *pSnb )
        WdtpFree( pFlags, *pSnb );
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserSize64
//
//  Synopsis:   Sizes an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
SNB_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    SNB           * pSnb )
{
    if ( ! pSnb )
        return Offset;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
    {
        SNB snb = *pSnb;
        
        WCHAR *psz = *snb;
        while (psz)
        {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
        }
    }
    
    // The wire size is: conf size, 2 fields and the wchars.
    LENGTH_ALIGN( Offset, 7 );    
    return ( Offset + 8 + (2 * sizeof(long)) + (ulCntChar * sizeof(WCHAR)) );
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserMarshal64
//
//  Synopsis:   Marshalls an SNB into the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
SNB_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserMarshal\n"));

    if ( ! pSnb )
        return pBuffer;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
    {
        SNB snb = *pSnb;
        
        WCHAR *psz = *snb;
        while (psz)
        {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
        }
    }

    // conformant size
    ALIGN( pBuffer, 7 );
    *( PHYPER_LV_CAST pBuffer)++ = ulCntChar;

    // fields
    *( PULONG_LV_CAST pBuffer)++ = ulCntStr;
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // actual strings only

    if ( pSnb  &&  *pSnb )
    {
        // There is a NULL string pointer to mark the end of the pointer array.
        // However, the strings don't have to follow tightly.
        // Hence, we have to copy one string at a time.
        
        SNB   snb = *pSnb;
        WCHAR *pszSrc;
        
        while (pszSrc = *snb++)
        {
            ULONG ulCopyLen = (lstrlenW(pszSrc) + 1) * sizeof(WCHAR);
            
            WdtpMemoryCopy( pBuffer, pszSrc, ulCopyLen );
            pBuffer += ulCopyLen;
        }
    }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an SNB from the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00   JohnDoty       Created from 32bit function
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
SNB_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserUnmarshal\n"));

    // Initialize CUserMarshalInfo object and get the buffer
    // size and pointer to the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream( pBuffer, MarshalInfo.GetBufferSize() );

    // Get the header from the buffer....  (ReadHYPER aligns on 8).
    ULONG ulCntChar    = (ULONG)stream.ReadHYPER();
    ULONG ulCntStr     = stream.ReadULONGNA();
    ULONG ulCntCharDup = stream.ReadULONGNA();

    // Verify that 2nd instance of count matches first.
    if ( ulCntCharDup != ulCntChar )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // No reusage of pSNB.
    if ( *pSnb )
    {
        WdtpFree( pFlags, *pSnb );
        *pSnb = NULL;
    }

    if ( ulCntStr == 0 )
    {
        // There are no strings.
        return stream.GetBuffer();
    }

    // Validate the header:
    // Repeated char count must match first instance and char count must
    // not be less than the number of strings since that would mean at
    // least one of them doesn't isn't terminated.
    if ( ulCntChar < ulCntStr )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Check for EOB before trying to get the strings.
    stream.CheckSize(ulCntChar * sizeof(WCHAR));

    // Last WCHAR in the buffer must be the UNICODE terminator.
    WCHAR* pszChars = (WCHAR*)stream.GetBuffer();
    if ( pszChars[ulCntChar - 1] != L'\0' )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // construct the SNB.
    SNB Snb = (SNB) WdtpAllocate( pFlags,
                                  ( (ulCntStr + 1) * sizeof(WCHAR *) +
                                     ulCntChar * sizeof(WCHAR)) );
    *pSnb = Snb;

    if (Snb)
    {
        // create the pointer array within the SNB.  to do this, we go through
        // the buffer, and use strlen to find the end of the each string for
        // us.
        WCHAR *pszSrc = (WCHAR *) stream.GetBuffer();
        WCHAR *pszTgt = (WCHAR *) (Snb + ulCntStr + 1); // right behind array
        
        void* SnbStart = Snb;
        ULONG ulTotLen = 0;
        ULONG i;
        for (i = ulCntStr; (i > 0) && (ulTotLen < ulCntChar); i--)
        {
            *Snb++ = pszTgt;
            
            ULONG ulLen = lstrlenW(pszSrc) + 1;
            pszSrc += ulLen;
            pszTgt += ulLen;
            ulTotLen += ulLen;
        }
        
        *Snb++ = NULL;
        
        // Verify that the number of strings and the number of chars
        // in the buffer matches what is supposed to be there.
        if ( (i > 0) || (ulTotLen < ulCntChar) )
        {
            WdtpFree( pFlags, SnbStart );
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }
        
        // Copy the actual strings.
        // We can do a block copy here as we packed them tight in the buffer.
        // Snb points right behind the lastarray of pointers within the SNB.
        WdtpMemoryCopy( Snb, stream.GetBuffer(), ulCntChar * sizeof(WCHAR) );
        stream.Advance(ulCntChar * sizeof(WCHAR));
    }

    return stream.GetBuffer();
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserFree64
//
//  Synopsis:   Frees an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00    JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

void __RPC_USER
SNB_UserFree64 (
    unsigned long * pFlags,
    SNB           * pSnb )
{
    if ( pSnb && *pSnb )
        WdtpFree( pFlags, *pSnb );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\stgmedium.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       hpalette.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for STGMEDIUM, FLAG_STGMEDIUM, and 
//               ASYNC_STGMEDIUM.
//
//  Functions:  
//              STGMEDIUM_UserSize
//              STGMEDIUM_UserMarshal
//              STGMEDIUM_UserUnmarshal
//              STGMEDIUM_UserFree
//              STGMEDIUM_UserSize64
//              STGMEDIUM_UserMarshal64
//              STGMEDIUM_UserUnmarshal64
//              STGMEDIUM_UserFree64
//              FLAG_STGMEDIUM_UserSize
//              FLAG_STGMEDIUM_UserMarshal
//              FLAG_STGMEDIUM_UserUnmarshal
//              FLAG_STGMEDIUM_UserFree
//              FLAG_STGMEDIUM_UserSize64
//              FLAG_STGMEDIUM_UserMarshal64
//              FLAG_STGMEDIUM_UserUnmarshal64
//              FLAG_STGMEDIUM_UserFree64
//              ASYNC_STGMEDIUM_UserSize
//              ASYNC_STGMEDIUM_UserMarshal
//              ASYNC_STGMEDIUM_UserUnmarshal
//              ASYNC_STGMEDIUM_UserFree
//              ASYNC_STGMEDIUM_UserSize64
//              ASYNC_STGMEDIUM_UserMarshal64
//              ASYNC_STGMEDIUM_UserUnmarshal64
//              ASYNC_STGMEDIUM_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx,
//                                      created NDR64 functions
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

// PROTOTYPES FOR OTHER USERMARSHAL ROUTINES, TO HELP US!
EXTERN_C unsigned long __stdcall __RPC_USER WdtpInterfacePointer_UserSize (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned long Offset, IUnknown *pIf, const IID &IId );
EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall WdtpInterfacePointer_UserMarshal (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned char *pBuffer, IUnknown *pIf, const IID &IId );
EXTERN_C unsigned long __stdcall __RPC_USER WdtpInterfacePointer_UserSize64 (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned long Offset, IUnknown *pIf, const IID &IId );
EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall WdtpInterfacePointer_UserMarshal64 (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned char *pBuffer, IUnknown *pIf, const IID &IId );
unsigned char __RPC_FAR * __RPC_USER WdtpInterfacePointer_UserUnmarshalWorker (USER_MARSHAL_CB * pContext,  unsigned char * pBuffer, IUnknown ** ppIf, const IID &IId, ULONG_PTR BufferSize, BOOL fNDR64 );


unsigned char __RPC_FAR * __RPC_USER HMETAFILEPICT_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HMETAFILEPICT * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HMETAFILEPICT_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HMETAFILEPICT * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER HENHMETAFILE_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HENHMETAFILE * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HENHMETAFILE_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HENHMETAFILE * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER HBITMAP_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HBITMAP * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HBITMAP_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HBITMAP * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER HPALETTE_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HPALETTE * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HPALETTE_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HPALETTE * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER WdtpGlobalUnmarshal (unsigned long * pFlags, unsigned char * pBuffer, HGLOBAL * pGlobal, BOOL fCanReallocate, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER WdtpGlobalUnmarshal64 (unsigned long * pFlags, unsigned char * pBuffer, HGLOBAL * pGlobal, BOOL fCanReallocate, ULONG_PTR BufferSize);


//+-------------------------------------------------------------------------
//
//  class:  CPunkForRelease
//
//  purpose:    special IUnknown for remoted STGMEDIUMs
//
//  history:    02-Mar-94   Rickhi      Created
//
//  notes:  This class is used to do the cleanup correctly when certain
//      types of storages are passed between processes or machines
//      in Nt and Chicago.
//
//      On NT, GLOBAL, GDI, and BITMAP handles cannot be passed between
//      processes, so we actually copy the whole data and create a
//      new handle in the receiving process. However, STGMEDIUMs have
//      this weird behaviour where if PunkForRelease is non-NULL then
//      the sender is responsible for cleanup, not the receiver. Since
//      we create a new handle in the receiver, we would leak handles
//      if we didnt do some special processing.  So, we do the
//      following...
//
//          During STGMEDIUM_UserUnmarshal, if there is a pUnkForRelease
//          replace it with a CPunkForRelease.  When Release is called
//          on the CPunkForRelease, do the necessary cleanup work,
//          then call the real PunkForRelease.
//
//+-------------------------------------------------------------------------

class   CPunkForRelease : public IUnknown
{
public:
    CPunkForRelease( STGMEDIUM *pStgMed, ulong fTopLayerOnly);

    //  IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppunk);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

private:
    ~CPunkForRelease(void);

    ULONG       _cRefs;                 //  reference count
    ULONG       _fTopLayerMFP:1;        //  optimisation flag for Chicago
    STGMEDIUM   _stgmed;                //  storage medium
    IUnknown  * _pUnkForRelease;        //  real pUnkForRelease
};


inline CPunkForRelease::CPunkForRelease(
    STGMEDIUM * pStgMed,
    ulong       fTopLayerMFPict
    ) :
    _cRefs(1),
    _fTopLayerMFP( fTopLayerMFPict),
    _stgmed(*pStgMed)
{
    //  NOTE: we assume the caller has verified pStgMed is not NULL,
    //  and the pUnkForRelease is non-null, otherwise there is no
    //  point in constructing this object.  The tymed must also be
    //  one of the special ones.

    UserNdrAssert(pStgMed);
    UserNdrAssert(pStgMed->tymed == TYMED_HGLOBAL ||
       pStgMed->tymed == TYMED_GDI  ||
       pStgMed->tymed == TYMED_MFPICT  ||
       pStgMed->tymed == TYMED_ENHMF);

    _pUnkForRelease = pStgMed->pUnkForRelease;
}


inline CPunkForRelease::~CPunkForRelease()
{
    //  since we really have our own copies of these handles' data, just
    //  pretend like the callee is responsible for the release, and
    //  recurse into ReleaseStgMedium to do the cleanup.

    _stgmed.pUnkForRelease = NULL;

    // There is this weird optimized case of Chicago MFPICT when we have two
    // layers with a HENHMETAFILE handle inside. Top layer is an HGLOBAL.

    if ( _fTopLayerMFP )
        GlobalFree( _stgmed.hGlobal );
    else
        ReleaseStgMedium( &_stgmed );

    //  release the callers punk
    _pUnkForRelease->Release();
}

STDMETHODIMP_(ULONG) CPunkForRelease::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CPunkForRelease::Release(void)
{
    long Ref = _cRefs - 1;

    UserNdrAssert( _cRefs );

    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
        {
        // null out the vtable.
        long * p = (long *)this;
        *p = 0;

        delete this;
        return 0;
        }
    else
        return Ref;
}

STDMETHODIMP CPunkForRelease::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
    *ppv = (void *)(IUnknown *) this;
    AddRef();
    return S_OK;
    }
    else
    {
    *ppv = NULL;
    return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SetContextFlagsForAsyncCall
//
//  Synopsis:   Forces correct flags for an async stgmed call.
//
//  history:    May-97   Ryszardk      Created.
//
//  We used to force MSHCTX_DIFFERENTMACHINE context on every
//  async stgmedium call because of problems with handles - for a truly
//  async call passing a handle, the client may free the handle before
//  the server can use it.
//  That is still needed. However, we cannot force the different machine
//  flags on IStream and IStorage as that prevents custom marshaler from
//  running.
//
//--------------------------------------------------------------------------

void inline
SetContextFlagsForAsyncCall(
    unsigned long * pFlags,
    STGMEDIUM     * pStgmed )
{
    if ( *pFlags & USER_CALL_IS_ASYNC )
        {
        // Additional considerations for async calls.

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
            case TYMED_MFPICT:
            case TYMED_ENHMF:
            case TYMED_GDI:
            case TYMED_HGLOBAL:
            case TYMED_FILE:
            default:
                if (!REMOTE_CALL(*pFlags))
                    {
                    *pFlags &= ~0xff;
                    *pFlags |= MSHCTX_DIFFERENTMACHINE;
                    }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                // Dont force remote.
                break;

            }
        }
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a stgmedium pbject for RPC marshalling.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    STGMEDIUM     * pStgmed )
{
    if ( ! pStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // Both handle and pUnk are represented by a long.
    if ( pStgmed->tymed == TYMED_NULL )
        Offset += sizeof(long) + sizeof(long);  // switch, (empty arm), pUnk
    else
        Offset += sizeof(long) + 2 * sizeof(long); // switch, handle, pUnk

    // Pointee of the union arm.
    // Only if the handle/pointer field is non-null.

    if ( pStgmed->hGlobal )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                Offset = HMETAFILEPICT_UserSize( pFlags,
                                                  Offset,
                                                  &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                Offset = HENHMETAFILE_UserSize( pFlags,
                                                  Offset,
                                                  &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:

                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                // switch for object type.

                Offset += sizeof(long);

                switch( GetObjectType( (HGDIOBJ)pStgmed->hBitmap ) )
                    {
                    case OBJ_BITMAP:
                        Offset = HBITMAP_UserSize( pFlags,
                                                   Offset,
                                                   &pStgmed->hBitmap );
                        break;

                    case OBJ_PAL:
                        Offset = HPALETTE_UserSize( pFlags,
                                                    Offset,
                                       (HPALETTE *) & pStgmed->hBitmap );
                        break;

                    default:
                        RAISE_RPC_EXCEPTION(DV_E_TYMED);
                        break;
                    }
                break;

            case TYMED_HGLOBAL:
                Offset = HGLOBAL_UserSize( pFlags,
                                            Offset,
                                            &pStgmed->hGlobal );
                break;
            case TYMED_FILE:
                {
                ulong ulDataSize = lstrlenW(pStgmed->lpszFileName) + 1;
                Offset += 3 * sizeof(long); // [string]
                Offset += ulDataSize * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                Offset = WdtpInterfacePointer_UserSize(
                            (USER_MARSHAL_CB *)pFlags,
                            *pFlags,
                            Offset,
                            pStgmed->pstg,
                            ((pStgmed->tymed == TYMED_ISTREAM)  ? IID_IStream
                                                                : IID_IStorage));
                break;

            default:
                break;

            }
        }

    // pUnkForRelease, if not null.

    if ( pStgmed->pUnkForRelease )
        Offset = WdtpInterfacePointer_UserSize( (USER_MARSHAL_CB *)pFlags,
                                                 *pFlags,
                                                 Offset,
                                                 pStgmed->pUnkForRelease,
                                                 IID_IUnknown );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a stgmedium pbject for RPC.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBufferStart,
    STGMEDIUM     * pStgmed )
{
    unsigned char * pBuffer;
    unsigned char * pUnionArmMark;

    if ( ! pStgmed )
        return pBufferStart;

    UserNdrDebugOut((
        UNDR_FORCE,
        "--STGMEDIUM_UserMarshal: %s\n",
        WdtpGetStgmedName(pStgmed)));

    pBuffer = pBufferStart;
    ALIGN( pBuffer, 3 );

    // userSTGMEDIUM: switch, union arm, pUnk ptr.

    *( PULONG_LV_CAST pBuffer)++ = pStgmed->tymed;
    pUnionArmMark = pBuffer;
    if ( pStgmed->tymed != TYMED_NULL )
        {
        // hGlobal stands for any of these handles.

        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pStgmed->hGlobal );
        }

    *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pStgmed->pUnkForRelease );

    // Now the pointee of the union arm.
    // We need to marshal only if the handle/pointer field is non null.
    // Otherwise it is already in the buffer.

    if ( pStgmed->hGlobal )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                pBuffer = HMETAFILEPICT_UserMarshal( pFlags,
                                                     pBuffer,
                                                     &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                pBuffer = HENHMETAFILE_UserMarshal( pFlags,
                                                    pBuffer,
                                                    &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:

                {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                ulong GdiObjectType = GetObjectType( (HGDIOBJ)pStgmed->hBitmap );

                // GDI_OBJECT

                *( PULONG_LV_CAST pBuffer)++ = GdiObjectType;

                switch( GdiObjectType )
                    {
                    case OBJ_BITMAP:
                        pBuffer = HBITMAP_UserMarshal( pFlags,
                                                       pBuffer,
                                                       &pStgmed->hBitmap );
                        break;

                    case OBJ_PAL:
                        pBuffer = HPALETTE_UserMarshal( pFlags,
                                                        pBuffer,
                                           (HPALETTE *) & pStgmed->hBitmap );
                        break;

                    default:
                        RpcRaiseException(DV_E_TYMED);
                    }
                }
                break;

            case TYMED_HGLOBAL:
                pBuffer = HGLOBAL_UserMarshal( pFlags,
                                               pBuffer,
                                               & pStgmed->hGlobal );
                break;
            case TYMED_FILE:
                {
                // We marshal it as a [string].

                ulong Count = (pStgmed->lpszFileName)
                                    ?  lstrlenW(pStgmed->lpszFileName) + 1
                                    :  0;

                *( PULONG_LV_CAST pBuffer)++ = Count;
                *( PULONG_LV_CAST pBuffer)++ = 0;
                *( PULONG_LV_CAST pBuffer)++ = Count;
                memcpy( pBuffer, pStgmed->lpszFileName, Count * sizeof(wchar_t) );
                pBuffer += Count * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                pBuffer = WdtpInterfacePointer_UserMarshal(
                               ((USER_MARSHAL_CB *)pFlags),
                               *pFlags,
                               pBuffer,
                               pStgmed->pstg,
                               ((pStgmed->tymed == TYMED_ISTREAM)  ? IID_IStream
                                                                   : IID_IStorage));
                break;

            default:
                break;
            }
        }

    // Marker for this pointer is already in the buffer.

    if ( pStgmed->pUnkForRelease )
        pBuffer = WdtpInterfacePointer_UserMarshal( ((USER_MARSHAL_CB *)pFlags
),
                                                    *pFlags,
                                                    pBuffer,
                                                    pStgmed->pUnkForRelease,
                                                    IID_IUnknown );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshalWorker
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshalWorker(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed,
    ULONG_PTR       BufferSize )
{
    unsigned long   fUnkForRelease;
    LONG_PTR        Handle = 0;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR) (pBuffer - pBufferStart);

    // Check for EOB.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + sizeof( ULONG ) );

    // switch, union arm, pUnk.
    pStgmed->tymed = *( PULONG_LV_CAST pBuffer)++;

    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserUnmarshal: %s\n",
                     WdtpGetStgmedName(pStgmed) ));

    ULONG_PTR cbData = cbFixup + (2 * sizeof( ULONG ));
    if ( pStgmed->tymed != TYMED_NULL )
        {
        cbData += sizeof( ULONG );

        CHECK_BUFFER_SIZE( BufferSize, cbData );

        // This value is just a marker for the handle - a long.
        Handle =  *( PLONG_LV_CAST pBuffer)++;
        }
    else
        {
        CHECK_BUFFER_SIZE( BufferSize, cbData );
        }

    // pUnkForRelease pointer marker.
    fUnkForRelease = *( PULONG_LV_CAST pBuffer)++;

    // First pointee

    // Union arm pointee.
    // We need to unmarshal only if the handle/pointer field was not NULL.

    if ( Handle )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        LONG* pBuf = (LONG*)pBuffer;

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:

#if defined(_WIN64)
                if ( IS_DATA_MARKER( pBuf[0] ) )
                {
                    CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof( ULONG )) );

                    if ( Handle != pBuf[1] )
                    {
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                }
                else
                {
                    //Inproc should always have marked this as handle64....
                    //Out-of-proc should always have marked this with a data marker....
                    if (!IS_HANDLE64_MARKER(pBuf[0]))
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                    // Align to 64b.
                    PBYTE pbBuf = (PBYTE)( pBuf + 1 );
                    PBYTE pbBufStart = pbBuf;
                    ALIGN( pbBuf, 7 );

                    // Make sure we don't step off the end of the buffer.
                    CHECK_BUFFER_SIZE( BufferSize, cbData +
                                        (ULONG_PTR)(pbBuf - pbBufStart) +
                                                   (sizeof(__int64)) );

                    // Verify that the handle put on the wire matches the
                    // first instance of the handle on the wire.
                    if ( Handle != (LONG_PTR) (*(LONG *)pbBuf ) )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                }
#else
                CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof(ULONG)) );

                if ( Handle != pBuf[1] )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
#endif

                pBuffer = HMETAFILEPICT_UserUnmarshalWorker(
                                      pFlags,
                                      pBuffer,
                                     &pStgmed->hMetaFilePict,
                                      BufferSize - cbData );
                break;
            case TYMED_ENHMF:
                // Must be room in buffer to do lookahead check.
                CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof( ULONG )) );

                // validate the handle.
                if ( Handle != pBuf[1] )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                pBuffer = HENHMETAFILE_UserUnmarshalWorker( pFlags,
                                                            pBuffer,
                                                        &pStgmed->hEnhMetaFile,
                                                            BufferSize - cbData );
                break;
            case TYMED_GDI:
                {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we
                // handle those types we know about based on the object type,
                // and reject those which we do not support.

                // Make sure we don't walk off the end of the buffer.
                CHECK_BUFFER_SIZE( BufferSize, cbData + (3 * sizeof( ULONG )) );

                cbData += sizeof( ULONG );

                DWORD GdiObjectType = *( PULONG_LV_CAST pBuffer)++;

                switch( GdiObjectType )
                    {
                    case OBJ_BITMAP:
                        // Lookahead validaton of the handle.  We look at
                        // the 3rd DWORD: GDI type, DISC, Handle.
                        if ( Handle != pBuf[2] )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                        pBuffer = HBITMAP_UserUnmarshalWorker( pFlags,
                                                               pBuffer,
                                                              &pStgmed->hBitmap,
                                                               BufferSize - cbData );
                        break;

                    case OBJ_PAL:
                        // Lookahead validaton of the handle.
                        if ( Handle != pBuf[2] )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                        pBuffer = HPALETTE_UserUnmarshalWorker( pFlags,
                                                                pBuffer,
                                               (HPALETTE *) & pStgmed->hBitmap,
                                                                BufferSize - cbData );
                        break;

                    default:
                        RAISE_RPC_EXCEPTION(DV_E_TYMED);
                    }
                }
                break;

            case TYMED_HGLOBAL:
                {
                // reallocation is forbidden for [in-out] hglobal in STGMEDIUM.

#if defined(_WIN64)
                if ( IS_DATA_MARKER( pBuf[0] ) )
                {
                    CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof( ULONG )) );

                    if ( Handle != pBuf[1] )
                    {
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                }
                else
                {
                    // Align to 64b.
                    PBYTE pbBuf = (PBYTE)( pBuf + 1 );
                    PBYTE pbBufStart = pbBuf;
                    ALIGN( pbBuf, 7 );

                    // Make sure we don't step off the end of the buffer.
                    CHECK_BUFFER_SIZE( BufferSize, cbData +
                                        (ULONG_PTR)(pbBuf - pbBufStart) +
                                                   (sizeof(__int64)) );

                    // Verify that the handle put on the wire matches the
                    // first instance of the handle on the wire.
                    if ( Handle != (LONG_PTR) (*(LONG *)pbBuf ) )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                }
#else
                CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof(ULONG)) );

                if ( Handle != pBuf[1] )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
#endif

                pBuffer = WdtpGlobalUnmarshal( pFlags,
                                               pBuffer,
                                               & pStgmed->hGlobal,
                                               FALSE,
                                               BufferSize - cbData);
                break;
                }
            case TYMED_FILE:
                {
                // Must be room in buffer for header.
                CHECK_BUFFER_SIZE( BufferSize, cbData + (3 * sizeof(ULONG)) );

                // We marshal it as a [string].

                ulong Count = *( PULONG_LV_CAST pBuffer)++;
                if ( *( PULONG_LV_CAST pBuffer)++ != 0 ||
                     *( PULONG_LV_CAST pBuffer)++ != Count )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                if ( ! pStgmed->lpszFileName )
                {
                    pStgmed->lpszFileName = (LPOLESTR)
                                        WdtpAllocate( pFlags,
                                                      Count * sizeof(wchar_t) );
                    if (!pStgmed->lpszFileName)
                        RpcRaiseException( E_OUTOFMEMORY );
                }

                // Must be room in the buffer for the string.
                CHECK_BUFFER_SIZE(
                    BufferSize,
                    cbData + (3 * sizeof( ULONG )) + (Count * sizeof( wchar_t )) );

                memcpy(pStgmed->lpszFileName, pBuffer, Count * sizeof(wchar_t));
                pBuffer += Count * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                // Non null pointer, retrieve the interface pointer

                pBuffer = WdtpInterfacePointer_UserUnmarshalWorker(
                              (USER_MARSHAL_CB *)pFlags,
                              pBuffer,
                              (IUnknown **) &pStgmed->pstm,
                              ((pStgmed->tymed == TYMED_ISTREAM)
                                    ? IID_IStream
                                    : IID_IStorage),
                               BufferSize - cbData,
                              FALSE );
                break;

            default:
                break;
            }
        }
    else
        {
        // New handle/pointer field is null, so release the previous one
        // if it wasn't null.

        if ( pStgmed->hGlobal )
            {
            // This should never happen for GetDataHere.

            // Note, that we release the handle field, not the stgmedium itself.
            // Accordingly, we don't follow punkForRelease.

            UserNdrDebugOut((
                  UNDR_FORCE,
                  "--STGMEDIUM_UserUnmarshal: %s: NULL in, freeing old one\n",
                  WdtpGetStgmedName(pStgmed)));

            STGMEDIUM  TmpStg = *pStgmed;
            TmpStg.pUnkForRelease = NULL;

            if ( pStgmed->tymed == TYMED_HGLOBAL )
                {
                // Cannot reallocate.
                RAISE_RPC_EXCEPTION(DV_E_TYMED);
                }
            else
                {
                ReleaseStgMedium( &TmpStg );
                }
            }

        pStgmed->hGlobal = 0;
        }

    // Fixup the buffer size so if fUnkForRelease is set, we
    // pass the correct BufferSize to the unmarshal routine.
    BufferSize -= (ULONG_PTR)(pBuffer - pBufferStart);

    if ( fUnkForRelease )
        {
        // There is an interface pointer on the wire.

        pBuffer = WdtpInterfacePointer_UserUnmarshalWorker(
                        (USER_MARSHAL_CB *)pFlags,
                        pBuffer,
                        &pStgmed->pUnkForRelease,
                        IID_IUnknown,
                        BufferSize,
                        FALSE );
        }

    if ( pStgmed->pUnkForRelease )
        {
        // Replace the app's punkForRelease with our custom release
        // handler for special situations.

        // The special situation is when a handle is remoted with data
        // and so we have to clean up a side effect of having a data copy
        // around. UserFree does it properly but we need that for the callee.
        // When the callee releases a stgmed, it would invoke
        // ReleaseStgMedium and this API doesn't do anything for handles
        // when the punkForRelease is not NULL.

        ULONG fHandleWithData = 0;
        ULONG fTopLevelOnly = 0;

        switch ( pStgmed->tymed )
            {
            case TYMED_HGLOBAL:
                fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
                break;

            case TYMED_ENHMF:
            case TYMED_GDI:
                fHandleWithData = GDI_DATA_PASSING( *pFlags );
                break;

            case TYMED_MFPICT:
                fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
                fTopLevelOnly   = fHandleWithData  &&
                                        ! GDI_DATA_PASSING( *pFlags );
                break;

            default:
                break;
            }

        if ( fHandleWithData )
            {
            IUnknown *
            punkTmp = (IUnknown *) new CPunkForRelease( pStgmed,
                                                        fTopLevelOnly );
            if (!punkTmp)
                {
                RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
                }

            pStgmed->pUnkForRelease = punkTmp;
            }
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of code out into a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed )
{
    // Init buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = STGMEDIUM_UserUnmarshalWorker( pFlags,
                                             pBufferStart,
                                             pStgmed,
                                             BufferSize );
    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserFree
//
//  Synopsis:   Frees a stgmedium object for RPC.
//
//  history:    May-95   Ryszardk      Created.
//
//  Note:       This routine is called from the freeing walk at server
//              or from the SetData *proxy*, when ownership has been passed.
//
//--------------------------------------------------------------------------

EXTERN_C
void NukeHandleAndReleasePunk(
    STGMEDIUM * pStgmed )
{
    pStgmed->hGlobal = NULL;
    pStgmed->tymed = TYMED_NULL;

    if (pStgmed->pUnkForRelease)
        {
        pStgmed->pUnkForRelease->Release();
        pStgmed->pUnkForRelease = 0;
        }
}

void __RPC_USER
STGMEDIUM_UserFree(
    unsigned long * pFlags,
    STGMEDIUM * pStgmed )
{
    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserFree: %s\n", WdtpGetStgmedName(pStgmed)));

    if( pStgmed )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        switch ( pStgmed->tymed )
            {
            case TYMED_FILE:
                WdtpFree( pFlags, pStgmed->lpszFileName);
                NukeHandleAndReleasePunk( pStgmed );
                break;

            case TYMED_NULL:
            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                ReleaseStgMedium( pStgmed );
                break;

            case TYMED_GDI:
            case TYMED_ENHMF:

                if ( GDI_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk !=0, this will go to our CPunk object.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            case TYMED_HGLOBAL:

                if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk ==0, this will just release the data.
                    // For punk !=0, this will go to our CPunk object,
                    // release the data, and then call the original punk.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            case TYMED_MFPICT:

                if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else if ( GDI_HANDLE_PASSING(*pFlags) )
                    {
                    if ( pStgmed->pUnkForRelease )
                        {
                        pStgmed->pUnkForRelease->Release();
                        }
                    else
                        {
                        if ( pStgmed->hGlobal )
                            GlobalFree( pStgmed->hGlobal );
                        pStgmed->hGlobal = NULL;
                        pStgmed->tymed = TYMED_NULL;
                        }
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk !=0, this will go to our CPunk object.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            default:
                RAISE_RPC_EXCEPTION( E_INVALIDARG );
                break;
            }
        }
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
FLAG_STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    Offset += 2 * sizeof(long);
    Offset  = STGMEDIUM_UserSize( pFlags, Offset, & pFlagStgmed->Stgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return pBuffer;

    ALIGN( pBuffer, 3 );

    // Flags: we need them when freeing in the client call_as routine

    pFlagStgmed->ContextFlags = *pFlags;

    *( PULONG_LV_CAST pBuffer)++ = *pFlags;
    *( PULONG_LV_CAST pBuffer)++ = pFlagStgmed->fPassOwnership;

    pBuffer = STGMEDIUM_UserMarshal( pFlags,
                                     pBuffer,
                                     & pFlagStgmed->Stgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();
    UCHAR*    pBufferPtr   = pBufferStart;

    // Align the buffer.
    ALIGN( pBufferPtr, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBufferPtr - pBufferStart);

    // BufferSize must not be less than the
    // alignment fixup + ContextFlags + fPassOwnership + tymed.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Flags and buffer marker

    pFlagStgmed->ContextFlags = *( PULONG_LV_CAST pBufferPtr)++;

    // Flags: we need them when freeing in the client call_as routine
    // We need that in the Proxy, when we call the user free routine.

    pFlagStgmed->fPassOwnership = *( PULONG_LV_CAST pBufferPtr)++;
    pFlagStgmed->ContextFlags   = *pFlags;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    // Subtract alignment fixup + 2 DWORDs from BufferSize.
    BufferSize -= cbFixup + (2 * sizeof( ULONG ));

    pBuffer = STGMEDIUM_UserUnmarshalWorker( pFlags,
                                             pBufferPtr,
                                           & pFlagStgmed->Stgmed,
                                             BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserFree
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
FLAG_STGMEDIUM_UserFree(
    unsigned long * pFlags,
    FLAG_STGMEDIUM* pFlagsStgmed )
{
    if ( ! pFlagsStgmed->fPassOwnership )
        STGMEDIUM_UserFree( pFlags, & pFlagsStgmed->Stgmed );

    // else the callee is supposed to release the stg medium.
}


//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//              May-97   Ryszardk      introduced the async flag to optimize
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
ASYNC_STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return Offset;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    // BTW: This is needed only as a workaround because the [async] attr
    // has been temporarily removed from objidl.idl. (May 1997).
    // After we have the new [async] in place, this code is unnecessary
    // as the NDR engine is setting the same flag for every async call.

    *pFlags |= USER_CALL_IS_ASYNC;

    Offset  = STGMEDIUM_UserSize( pFlags, Offset, pAsyncStgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return pBuffer;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer = STGMEDIUM_UserMarshal( pFlags,
                                     pBuffer,
                                     pAsyncStgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer =  STGMEDIUM_UserUnmarshalWorker( pFlags,
                                              pBufferStart,
                                              pAsyncStgmed,
                                              BufferSize );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserFree
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
ASYNC_STGMEDIUM_UserFree(
    unsigned long * pFlags,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    STGMEDIUM_UserFree( pFlags, pAsyncStgmed );
}


#if defined(_WIN64)
//
// NDR64 Support routines.
//

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserSize64
//
//  Synopsis:   Sizes a stgmedium pbject for RPC marshalling.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
STGMEDIUM_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    STGMEDIUM     * pStgmed )
{
    if ( ! pStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    // tymed is 4 bytes, plus 4 bytes padding, plus potentially the handle (8 bytes),
    // plus the pUnk.
    if ( pStgmed->tymed == TYMED_NULL )
        Offset += 4 + 4 + 8;                       // switch, pad, (empty arm), pUnk
    else
    {
        Offset += 4 + 4 + 8 + 8;                   // switch, pad, handle, pUnk

        // Pointee of the union arm.
        // Only if the handle/pointer field is non-null.
    
        if ( pStgmed->hGlobal )
        {
            SetContextFlagsForAsyncCall( pFlags, pStgmed );
            
            switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                Offset = HMETAFILEPICT_UserSize64( pFlags,
                                                   Offset,
                                                   &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                Offset = HENHMETAFILE_UserSize64( pFlags,
                                                  Offset,
                                                  &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:                
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                // 4 bytes for disc, plus 4 bytes pad, plus 8 bytes pointer?
                Offset += 4 + 4 + 8; 

                switch( GetObjectType( (HGDIOBJ)pStgmed->hBitmap ) )
                {
                case OBJ_BITMAP:
                    Offset = HBITMAP_UserSize64( pFlags,
                                                 Offset,
                                                 &pStgmed->hBitmap );
                    break;

                case OBJ_PAL:
                    Offset = HPALETTE_UserSize64( pFlags,
                                                  Offset,
                                                  (HPALETTE *) & pStgmed->hBitmap );
                    break;

                default:
                    RAISE_RPC_EXCEPTION(DV_E_TYMED);
                    break;
                }
                break;

            case TYMED_HGLOBAL:
                Offset = HGLOBAL_UserSize64( pFlags,
                                             Offset,
                                             &pStgmed->hGlobal );
                break;

            case TYMED_FILE:
                {           
                    ulong ulDataSize = 0;
                    if (pStgmed->lpszFileName)
                        ulDataSize = lstrlenW(pStgmed->lpszFileName) + 1;
                    Offset += 3 * 8; // max size, offset, conformance
                    Offset += ulDataSize * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
                Offset = WdtpInterfacePointer_UserSize64((USER_MARSHAL_CB *)pFlags,
                                                         *pFlags,
                                                         Offset,
                                                         pStgmed->pstm,
                                                         IID_IStream);
                break;

            case TYMED_ISTORAGE:
                Offset = WdtpInterfacePointer_UserSize64((USER_MARSHAL_CB *)pFlags,
                                                         *pFlags,
                                                         Offset,
                                                         pStgmed->pstg,
                                                         IID_IStorage);
                break;

            default:
                RAISE_RPC_EXCEPTION(DV_E_TYMED);
                break;
            }
        }
    }

    // pUnkForRelease, if not null.

    if ( pStgmed->pUnkForRelease )
        Offset = WdtpInterfacePointer_UserSize64( (USER_MARSHAL_CB *)pFlags,
                                                  *pFlags,
                                                  Offset,
                                                  pStgmed->pUnkForRelease,
                                                  IID_IUnknown );
    
    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserMarshal64
//
//  Synopsis:   Marshals a stgmedium pbject for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBufferStart,
    STGMEDIUM     * pStgmed )
{
    unsigned char * pBuffer;
    unsigned char * pUnionArmMark;
    DWORD tymed;

    if ( ! pStgmed )
        return pBufferStart;
    
    UserNdrDebugOut((
        UNDR_FORCE,
        "--STGMEDIUM_UserMarshal64: %s\n",
        WdtpGetStgmedName(pStgmed)));

    pBuffer = pBufferStart;
    ALIGN( pBuffer, 7 );

    // userSTGMEDIUM: switch, union arm, pUnk ptr.
    tymed = pStgmed->tymed;
    *( PULONG_LV_CAST pBuffer)++ = tymed;
    ALIGN( pBuffer, 7 );
    
    pUnionArmMark = pBuffer;
    if ( tymed != TYMED_NULL )
    {
        // hGlobal stands for any of these handles.        
      *(PHYPER_LV_CAST pBuffer)++ = (hyper)( pStgmed->hGlobal );
    }
    
    *(PHYPER_LV_CAST pBuffer)++ = (hyper)( pStgmed->pUnkForRelease );

    // Now the pointee of the union arm.
    // We need to marshal only if the handle/pointer field is non null.
    // Otherwise it is already in the buffer.
    if ( pStgmed->hGlobal )
    {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );
        
        switch( pStgmed->tymed )
        {
        case TYMED_NULL:
            break;
            
        case TYMED_MFPICT:
            pBuffer = HMETAFILEPICT_UserMarshal64( pFlags,
                                                   pBuffer,
                                                   &pStgmed->hMetaFilePict );
            break;

        case TYMED_ENHMF:
            pBuffer = HENHMETAFILE_UserMarshal64( pFlags,
                                                  pBuffer,
                                                  &pStgmed->hEnhMetaFile );
            break;
            
        case TYMED_GDI:
            {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                ulong GdiObjectType = GetObjectType( (HGDIOBJ)pStgmed->hBitmap );

                // GDI_OBJECT
                *(PULONG_LV_CAST pBuffer)++ = GdiObjectType;
                ALIGN( pBuffer, 7 );
                *(PHYPER_LV_CAST pBuffer)++ = (hyper)(pStgmed->hBitmap);

                switch( GdiObjectType )
                {
                case OBJ_BITMAP:
                    pBuffer = HBITMAP_UserMarshal64( pFlags,
                                                     pBuffer,
                                                     &pStgmed->hBitmap );
                    break;

                case OBJ_PAL:
                    pBuffer = HPALETTE_UserMarshal64( pFlags,
                                                      pBuffer,
                                                      (HPALETTE *) & pStgmed->hBitmap );
                    break;
                    
                default:
                    RpcRaiseException(DV_E_TYMED);
                }
            }
            break;

        case TYMED_HGLOBAL:
            pBuffer = HGLOBAL_UserMarshal64( pFlags,
                                             pBuffer,
                                             &pStgmed->hGlobal );
            break;
        case TYMED_FILE:
            {
                // We marshal it as a [string].
                ulong Count = 0;
                if (pStgmed->lpszFileName)
                    Count = lstrlenW(pStgmed->lpszFileName) + 1;

                *( PHYPER_LV_CAST pBuffer)++ = Count;
                *( PHYPER_LV_CAST pBuffer)++ = 0;
                *( PHYPER_LV_CAST pBuffer)++ = Count;
                memcpy( pBuffer, pStgmed->lpszFileName, Count * sizeof(wchar_t) );
                pBuffer += Count * sizeof(wchar_t);
            }
            break;

        case TYMED_ISTREAM:
            pBuffer = WdtpInterfacePointer_UserMarshal64(((USER_MARSHAL_CB *)pFlags),
                                                         *pFlags,
                                                         pBuffer,
                                                         pStgmed->pstm,
                                                         IID_IStream);
            break;
            
        case TYMED_ISTORAGE:
            pBuffer = WdtpInterfacePointer_UserMarshal64(((USER_MARSHAL_CB *)pFlags),
                                                         *pFlags,
                                                         pBuffer,
                                                         pStgmed->pstg,
                                                         IID_IStorage);
            break;

        default:
            RpcRaiseException(DV_E_TYMED);
            break;
        }
    }

    // Marker for this pointer is already in the buffer.
    if ( pStgmed->pUnkForRelease )
        pBuffer = WdtpInterfacePointer_UserMarshal64( ((USER_MARSHAL_CB *)pFlags),
                                                      *pFlags,
                                                      pBuffer,
                                                      pStgmed->pUnkForRelease,
                                                      IID_IUnknown );
    
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshalWorker64
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    LONG_PTR        fUnkForRelease;
    LONG_PTR        Handle = 0;
    unsigned char  *mark = NULL;

    // Align the buffer and save the fixup size.
    stream.Align(8);

    // switch, union arm, pUnk.
    pStgmed->tymed = stream.ReadULONGNA();
    
    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserUnmarshal64: %s\n",
                     WdtpGetStgmedName(pStgmed) ));

    // (Force the align here so we only align once)
    stream.Align(8);
    if ( pStgmed->tymed != TYMED_NULL )
    {
        // This value is just a marker for the handle - a long.
        Handle = stream.ReadHYPERNA();
    }
    
    // pUnkForRelease pointer marker.
    fUnkForRelease = stream.ReadHYPERNA();

    // First pointee

    // Union arm pointee.
    // We need to unmarshal only if the handle/pointer field was not NULL.
    if ( Handle )
    {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        hyper* pBuf = (hyper*)stream.GetBuffer();

        switch( pStgmed->tymed )
        {
        case TYMED_NULL:
            break;

        case TYMED_MFPICT:            
            // validate the handle...
            stream.CheckSize( 4 + 4 + 8 ); // enc. union: 4b switch + 4b pad + 8b handle            
            
            if ( Handle != pBuf[1] )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            mark = HMETAFILEPICT_UserUnmarshalWorker64 (pFlags,
                                                        stream.GetBuffer(),
                                                        &pStgmed->hMetaFilePict,
                                                        stream.BytesRemaining() );
            stream.AdvanceTo(mark);
            break;

        case TYMED_ENHMF:
            // validate the handle...
            stream.CheckSize( 4 + 4 + 8 ); // enc. union: 4b switch + 4b pad + 8b handle            
            
            if ( Handle != pBuf[1] )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );            

            mark = HENHMETAFILE_UserUnmarshalWorker64 ( pFlags,
                                                        stream.GetBuffer(),
                                                        &pStgmed->hEnhMetaFile,
                                                        stream.BytesRemaining() );
            stream.AdvanceTo(mark);
            break;

        case TYMED_GDI:
            {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we
                // handle those types we know about based on the object type,
                // and reject those which we do not support.
                
                DWORD GdiObjectType = stream.ReadULONGNA();
                Handle = stream.ReadHYPER();

                switch( GdiObjectType )
                {
                case OBJ_BITMAP:
                    // Lookahead validation of the handle. 
                    stream.CheckSize( 4 + 4 + 8 );
                    pBuf = (hyper*)stream.GetBuffer();
                    if ( Handle != pBuf[1] )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                    mark = HBITMAP_UserUnmarshalWorker64( pFlags,
                                                          stream.GetBuffer(),
                                                          &pStgmed->hBitmap,
                                                          stream.BytesRemaining() );
                    stream.AdvanceTo(mark);
                    break;

                case OBJ_PAL:
                    // Lookahead validaton of the handle.
                    stream.CheckSize( 4 + 4 + 8 );
                    pBuf = (hyper*)stream.GetBuffer();
                    if ( Handle != pBuf[1] )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                    mark = HPALETTE_UserUnmarshalWorker64( pFlags,
                                                           stream.GetBuffer(),
                                                           (HPALETTE *) & pStgmed->hBitmap,
                                                           stream.BytesRemaining() );
                    stream.AdvanceTo(mark);
                    break;
                    
                default:
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                }
            }
            break;

        case TYMED_HGLOBAL:
            // reallocation is forbidden for [in-out] hglobal in STGMEDIUM.
            // validate the handle.
            stream.CheckSize( 4 + 4 + 8 ); // enc. union: 4b switch + 4b pad + 8b handle            
            
            if ( Handle != pBuf[1] )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            
            mark = WdtpGlobalUnmarshal64( pFlags,
                                          stream.GetBuffer(),
                                          & pStgmed->hGlobal,
                                          FALSE,
                                          stream.BytesRemaining() );
            stream.AdvanceTo(mark);
            break;
        
        case TYMED_FILE:
            {
                // Must be room in buffer for header.
                ulong Count = (ulong)stream.ReadHYPERNA();

                // We marshal it as a [string].
                if ( stream.ReadHYPERNA() != 0 )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                if ( stream.ReadHYPERNA() != Count )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                if ( ! pStgmed->lpszFileName )
                {
                    pStgmed->lpszFileName = (LPOLESTR) WdtpAllocate( pFlags, Count * sizeof(wchar_t) );
                    if (!pStgmed->lpszFileName)
                        RpcRaiseException( E_OUTOFMEMORY );
                }

                // Must be room in the buffer for the string.
                stream.CheckSize( Count * sizeof(WCHAR) );
                memcpy(pStgmed->lpszFileName, 
                       stream.GetBuffer(), 
                       Count * sizeof(wchar_t));
                stream.Advance( Count * sizeof(WCHAR) );
            }
            break;

        case TYMED_ISTREAM:
            mark = WdtpInterfacePointer_UserUnmarshalWorker((USER_MARSHAL_CB *)pFlags,
                                                            stream.GetBuffer(),
                                                            (IUnknown **) &pStgmed->pstm,
                                                            IID_IStream,
                                                            stream.BytesRemaining(),
                                                            TRUE);
            stream.AdvanceTo(mark);
            break;

        case TYMED_ISTORAGE:
            mark = WdtpInterfacePointer_UserUnmarshalWorker((USER_MARSHAL_CB *)pFlags,
                                                            stream.GetBuffer(),
                                                            (IUnknown **) &pStgmed->pstg,
                                                            IID_IStorage,
                                                            stream.BytesRemaining(),
                                                            TRUE);
            stream.AdvanceTo(mark);
            break;

        default:
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            break;
        }
    }
    else
    {
        // New handle/pointer field is null, so release the previous one
        // if it wasn't null.

        if ( pStgmed->hGlobal )
        {
            // This should never happen for GetDataHere.
            
            // Note, that we release the handle field, not the stgmedium itself.
            // Accordingly, we don't follow punkForRelease.            
            UserNdrDebugOut((
                  UNDR_FORCE,
                  "--STGMEDIUM_UserUnmarshal64: %s: NULL in, freeing old one\n",
                  WdtpGetStgmedName(pStgmed)));

            STGMEDIUM  TmpStg = *pStgmed;
            TmpStg.pUnkForRelease = NULL;
            
            if ( pStgmed->tymed == TYMED_HGLOBAL )
            {
                // Cannot reallocate.
                RAISE_RPC_EXCEPTION(DV_E_TYMED);
            }
            else
            {
                ReleaseStgMedium( &TmpStg );
            }
        }
        
        pStgmed->hGlobal = 0;
    }

    if ( fUnkForRelease )
    {
        // There is an interface pointer on the wire.
        mark = WdtpInterfacePointer_UserUnmarshalWorker((USER_MARSHAL_CB *)pFlags,
                                                        stream.GetBuffer(),
                                                        &pStgmed->pUnkForRelease,
                                                        IID_IUnknown,
                                                        stream.BytesRemaining(),
                                                        TRUE);
        stream.AdvanceTo(mark);
    }

    if ( pStgmed->pUnkForRelease )
    {
        // Replace the app's punkForRelease with our custom release
        // handler for special situations.

        // The special situation is when a handle is remoted with data
        // and so we have to clean up a side effect of having a data copy
        // around. UserFree does it properly but we need that for the callee.
        // When the callee releases a stgmed, it would invoke
        // ReleaseStgMedium and this API doesn't do anything for handles
        // when the punkForRelease is not NULL.
        ULONG fHandleWithData = 0;
        ULONG fTopLevelOnly = 0;

        switch ( pStgmed->tymed )
        {
        case TYMED_HGLOBAL:
            fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
            break;
            
        case TYMED_ENHMF:
        case TYMED_GDI:
            fHandleWithData = GDI_DATA_PASSING( *pFlags );
            break;
            
        case TYMED_MFPICT:
            fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
            fTopLevelOnly   = fHandleWithData  && !GDI_DATA_PASSING( *pFlags );
            break;
            
        default:
            break;
        }

        if ( fHandleWithData )
        {
            IUnknown *
                punkTmp = (IUnknown *) new CPunkForRelease( pStgmed,
                                                            fTopLevelOnly );
            if (!punkTmp)
            {
                RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
            }

            pStgmed->pUnkForRelease = punkTmp;
        }
    }

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshal64
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed )
{
    // Init buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = STGMEDIUM_UserUnmarshalWorker64( pFlags,
                                               pBufferStart,
                                               pStgmed,
                                               BufferSize );
    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserFree64
//
//  Synopsis:   Frees a stgmedium object for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//  Note:       This routine is called from the freeing walk at server
//              or from the SetData *proxy*, when ownership has been passed.
//
//--------------------------------------------------------------------------

void __RPC_USER
STGMEDIUM_UserFree64 (
    unsigned long * pFlags,
    STGMEDIUM * pStgmed )
{
    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserFree64: %s\n", WdtpGetStgmedName(pStgmed)));

    if( pStgmed )
    {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );
        
        switch ( pStgmed->tymed )
        {
        case TYMED_FILE:
            WdtpFree( pFlags, pStgmed->lpszFileName);
            NukeHandleAndReleasePunk( pStgmed );
            break;
            
        case TYMED_NULL:
        case TYMED_ISTREAM:
        case TYMED_ISTORAGE:
            ReleaseStgMedium( pStgmed );
            break;
            
        case TYMED_GDI:
        case TYMED_ENHMF:
            
            if ( GDI_HANDLE_PASSING(*pFlags) )
            {
                NukeHandleAndReleasePunk( pStgmed );
            }
            else
            {
                // Handle w/data: there is a side effect to clean up.
                // For punk !=0, this will go to our CPunk object.
                
                ReleaseStgMedium( pStgmed );
            }
            break;
            
        case TYMED_HGLOBAL:
            
            if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            {
                NukeHandleAndReleasePunk( pStgmed );
            }
            else
            {
                // Handle w/data: there is a side effect to clean up.
                // For punk ==0, this will just release the data.
                // For punk !=0, this will go to our CPunk object,
                // release the data, and then call the original punk.
                
                ReleaseStgMedium( pStgmed );
            }
            break;
            
        case TYMED_MFPICT:
            
            if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            {
                NukeHandleAndReleasePunk( pStgmed );
            }
            else if ( GDI_HANDLE_PASSING(*pFlags) )
            {
                if ( pStgmed->pUnkForRelease )
                {
                    pStgmed->pUnkForRelease->Release();
                }
                else
                {
                    if ( pStgmed->hGlobal )
                        GlobalFree( pStgmed->hGlobal );
                    pStgmed->hGlobal = NULL;
                    pStgmed->tymed = TYMED_NULL;
                }
            }
            else
            {
                // Handle w/data: there is a side effect to clean up.
                // For punk !=0, this will go to our CPunk object.
                
                ReleaseStgMedium( pStgmed );
            }
            break;
            
        default:
            RAISE_RPC_EXCEPTION( E_INVALIDARG );
            break;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserSize64
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
FLAG_STGMEDIUM_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    Offset += 2 * sizeof(long);
    Offset  = STGMEDIUM_UserSize64 ( pFlags, Offset, & pFlagStgmed->Stgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserMarshal64
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return pBuffer;

    ALIGN( pBuffer, 7 );

    // Flags: we need them when freeing in the client call_as routine

    pFlagStgmed->ContextFlags = *pFlags;

    *( PULONG_LV_CAST pBuffer)++ = *pFlags;
    *( PULONG_LV_CAST pBuffer)++ = pFlagStgmed->fPassOwnership;

    pBuffer = STGMEDIUM_UserMarshal64( pFlags,
                                       pBuffer,
                                       & pFlagStgmed->Stgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserUnmarshal64
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream(pBuffer, MarshalInfo.GetBufferSize());


    // Align the buffer.
    stream.Align(8);
    
    // Flags and buffer marker
    pFlagStgmed->ContextFlags = stream.ReadULONGNA();

    // Flags: we need them when freeing in the client call_as routine
    // We need that in the Proxy, when we call the user free routine.
    pFlagStgmed->fPassOwnership = stream.ReadULONGNA();
    pFlagStgmed->ContextFlags   = *pFlags;

    pBuffer = STGMEDIUM_UserUnmarshalWorker64( pFlags,
                                               stream.GetBuffer(),
                                               & pFlagStgmed->Stgmed,
                                               stream.BytesRemaining() );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserFree64
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

void __RPC_USER
FLAG_STGMEDIUM_UserFree64 (
    unsigned long * pFlags,
    FLAG_STGMEDIUM* pFlagsStgmed )
{
    if ( ! pFlagsStgmed->fPassOwnership )
        STGMEDIUM_UserFree64 ( pFlags, & pFlagsStgmed->Stgmed );

    // else the callee is supposed to release the stg medium.
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserSize64
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
ASYNC_STGMEDIUM_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return Offset;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    // BTW: This is needed only as a workaround because the [async] attr
    // has been temporarily removed from objidl.idl. (May 1997).
    // After we have the new [async] in place, this code is unnecessary
    // as the NDR engine is setting the same flag for every async call.

    *pFlags |= USER_CALL_IS_ASYNC;

    Offset  = STGMEDIUM_UserSize64 ( pFlags, Offset, pAsyncStgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserMarshal64
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return pBuffer;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer = STGMEDIUM_UserMarshal64( pFlags,
                                       pBuffer,
                                       pAsyncStgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserUnmarshal64
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserUnmarshal64(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer =  STGMEDIUM_UserUnmarshalWorker64( pFlags,
                                                pBufferStart,
                                                pAsyncStgmed,
                                                BufferSize );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserFree64
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

void __RPC_USER
ASYNC_STGMEDIUM_UserFree64(
    unsigned long * pFlags,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    STGMEDIUM_UserFree64( pFlags, pAsyncStgmed );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\transmit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       transmit.h
//
//  Contents:   Function prototypes for STGMEDIUM marshalling.
//
//  Functions:  STGMEDIUM_to_xmit
//              STGMEDIUM_from_xmit
//              STGMEDIUM_free_inst
//
//  History:    May-10-94   ShannonC    Created
//  History:    May-10-95   Ryszardk    wire_marshal changes
//
//--------------------------------------------------------------------------
#pragma once
#ifndef __TRANSMIT_H__
#define __TRANSMIT_H__

#include <debnot.h>

#if (DBG==1)

DECLARE_DEBUG(UserNdr)
//
#define UserNdrDebugOut(x) UserNdrInlineDebugOut x
#define UserNdrAssert(x)   Win4Assert(x)
#define UserNdrVerify(x)   Win4Assert(x)

//#define UNDR_FORCE   DEB_FORCE
#define UNDR_FORCE   0
#define UNDR_OUT1    0
#define UNDR_OUT4    0

EXTERN_C char *
WdtpGetStgmedName( STGMEDIUM * );

#else

#define UserNdrDebugOut(x)
#define UserNdrAssert(x)
#define UserNdrVerify(x)

#define UNDR_FORCE   0
#define UNDR_OUT1    0
#define UNDR_OUT4    0

#endif

// Shortcut typedefs.
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;

#ifndef TRUE
#define TRUE    (1)
#define FALSE   (0)
typedef unsigned short BOOL;
#endif

//
// Alignment and access macros.
//
#define ALIGN( pStuff, cAlign ) \
        pStuff = (unsigned char *)((ULONG_PTR)((pStuff) + (cAlign)) & ~ (cAlign))

#define LENGTH_ALIGN( Length, cAlign ) \
            Length = (((Length) + (cAlign)) & ~ (cAlign))

#define PCHAR_LV_CAST   *(char __RPC_FAR * __RPC_FAR *)&
#define PSHORT_LV_CAST  *(short __RPC_FAR * __RPC_FAR *)&
#define PLONG_LV_CAST   *(long __RPC_FAR * __RPC_FAR *)&
#define PHYPER_LV_CAST  *(hyper __RPC_FAR * __RPC_FAR *)&

#define PUSHORT_LV_CAST  *(unsigned short __RPC_FAR * __RPC_FAR *)&
#define PULONG_LV_CAST   *(unsigned long __RPC_FAR * __RPC_FAR *)&

// Just a pointer sized random thing we can identify in the stream.
// For error checking purposes only.
#define USER_MARSHAL_MARKER     0x72657355

//
// These are based on flags defined in wtypes.idl comming from the channel.
// They indicate where we are marshalling.
//
#define INPROC_CALL( Flags) (USER_CALL_CTXT_MASK(Flags) == MSHCTX_INPROC)
#define REMOTE_CALL( Flags) ((USER_CALL_CTXT_MASK(Flags) == MSHCTX_DIFFERENTMACHINE) \
                          || (USER_CALL_CTXT_MASK(Flags) == MSHCTX_NOSHAREDMEM))
#define DIFFERENT_MACHINE_CALL( Flags)  \
                        (USER_CALL_CTXT_MASK(Flags) == MSHCTX_DIFFERENTMACHINE)

// There is a difference in the scope of handles, Daytona vs. Chicago.
// The following is an illustration of the notions of
//    HGLOBAL handle vs. data passing and  GDI handle vs. data passing.
// The type of an rpc call is defined by the flags above.
//
// This is included only for historical interest, as this code no longer
// has anything to do with chicago, win9x, or any of that goo.
//
// Daytona rules: GDI same as HGLOBAL
//I------------I----------------I-----------------------------------I
//I   inproc   I  same machine  I  diff. machine (a.k.a "remote" )  I
//I------------I----------------------------------------------------I
//| HGLOBL h.p.|           HGLOBAL data passing                     |
//|------------|----------------------------------------------------|
//|  GDI h.p.  |             GDI data passing                       |
//|------------|----------------------------------------------------|
//
// Chicago rules: HGLOBAL stricter than GDI.
//I------------I----------------I-----------------------------------I
//I   inproc   I  same machine  I  diff. machine (a.k.a "remote" )  I
//I------------I----------------------------------------------------I
//| HGLOBL h.p.|           HGLOBAL data passing                     |
//|-----------------------------------------------------------------|
//|  GDI handle passing         |          GDI data passing         |
//|-----------------------------|-----------------------------------|

#define HGLOBAL_HANDLE_PASSING( Flags )     INPROC_CALL( Flags)
#define HGLOBAL_DATA_PASSING( Flags )     (!INPROC_CALL( Flags))

#define GDI_HANDLE_PASSING( Flags )         HGLOBAL_HANDLE_PASSING( Flags )
#define GDI_DATA_PASSING( Flags )           HGLOBAL_DATA_PASSING( Flags )


#define WDT_DATA_MARKER        WDT_REMOTE_CALL
#define WDT_HANDLE_MARKER      WDT_INPROC_CALL
#define WDT_HANDLE64_MARKER    WDT_INPROC64_CALL
#define IS_DATA_MARKER( dw )   (WDT_REMOTE_CALL == dw)
#define IS_HANDLE_MARKER( dw ) (WDT_INPROC_CALL == dw)
#define IS_HANDLE64_MARKER( dw ) (WDT_INPROC64_CALL == dw)

//
// CLIPFORMAT remoting
//
#define CLIPFORMAT_BUFFER_MAX  248

#define NON_STANDARD_CLIPFORMAT(pcf)((0xC000<= *pcf) && (*pcf <=0xFFFF))

#define REMOTE_CLIPFORMAT(pFlags) ((USER_CALL_CTXT_MASK(*pFlags) == MSHCTX_DIFFERENTMACHINE) )

//
// Useful memory macros, for consistency.
//
#define WdtpMemoryCopy(Destination, Source, Length) \
    RtlCopyMemory(Destination, Source, Length)
#define WdtpZeroMemory(Destination, Length) \
    RtlZeroMemory(Destination, Length)

#define WdtpAllocate(p,size)    \
    ((USER_MARSHAL_CB *)p)->pStubMsg->pfnAllocate( size )
#define WdtpFree(pf,ptr)    \
    ((USER_MARSHAL_CB *)pf)->pStubMsg->pfnFree( ptr )

//
// Used in call_as.c
//
EXTERN_C
void NukeHandleAndReleasePunk(
    STGMEDIUM * pStgmed );

//
// Useful checking/exception routines.
//
#if DBG==1
#define RAISE_RPC_EXCEPTION( e )                                 \
    {                                                            \
    Win4Assert( !"Wire marshaling problem!" );                   \
    RpcRaiseException( (e) );                                    \
    }
#else
#define RAISE_RPC_EXCEPTION( e )                                 \
    {                                                            \
    RpcRaiseException( (e) );                                    \
    }
#endif

#define CHECK_BUFFER_SIZE( b, s )                                \
    if ( (b) < (s) )                                             \
        {                                                        \
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );              \
        }

#endif  // __TRANSMIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\oleprx32\proxy\daytona\prop_x.c ===
//+===================================================================
//
//   This file is a wrapper for prop_p.c (which is generated by MIDL
//   from ..\..\idl\prop.idl).
//
//   Prop_p.c makes references to wire-marshal routines that are
//   provided by oleaut32.dll.  But we can't (for performance
//   reasons) link ole32.dll directly to oleaut32, we do it
//   lazily.  So in this file, we use #defines to map
//   the wire-marshal routines called by prop_p.c so that
//   they are actually calls to "Load*" wrappers.  These
//   wrappers load oleaut32.dll, do a GetProcAddr, and
//   then make the actual call.
//
//+===================================================================

#include "prop.h"
#include <privoa.h>

#define BSTR_UserSize        LoadBSTR_UserSize
#define BSTR_UserMarshal     LoadBSTR_UserMarshal
#define BSTR_UserUnmarshal   LoadBSTR_UserUnmarshal
#define BSTR_UserFree        LoadBSTR_UserFree

#define LPSAFEARRAY_UserSize        LoadLPSAFEARRAY_UserSize
#define LPSAFEARRAY_UserMarshal     LoadLPSAFEARRAY_UserMarshal
#define LPSAFEARRAY_UserUnmarshal   LoadLPSAFEARRAY_UserUnmarshal
#define LPSAFEARRAY_UserFree        LoadLPSAFEARRAY_UserFree

#if defined(_WIN64)
#define BSTR_UserSize64        LoadBSTR_UserSize
#define BSTR_UserMarshal64     LoadBSTR_UserMarshal
#define BSTR_UserUnmarshal64   LoadBSTR_UserUnmarshal
#define BSTR_UserFree64        LoadBSTR_UserFree

#define LPSAFEARRAY_UserSize64        LoadLPSAFEARRAY_UserSize
#define LPSAFEARRAY_UserMarshal64     LoadLPSAFEARRAY_UserMarshal
#define LPSAFEARRAY_UserUnmarshal64   LoadLPSAFEARRAY_UserUnmarshal
#define LPSAFEARRAY_UserFree64        LoadLPSAFEARRAY_UserFree
#endif // defined(_WIN64)

#include "prop_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\debnot\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#if DBG == 1

#define _W4SPRINTF_
#include "printf.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\debnot\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  _Assert
//              _PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92  BryanT    Switched to w4crt.h instead of wchar.h
//
//----------------------------------------------------------------------------

//
// This one file **always** uses debugging options
//

#if DBG == 1

#include <stdarg.h>

# include <debnot.h>
# include "dprintf.h"            // w4printf, w4dprintf prototypes

extern "C"
{
#include <windows.h>

#ifndef WIN32
#define MessageBoxA MessageBox
#define wsprintfA wsprintf
#endif
}

int APINOT _PopUpError(char const FAR *szMsg,
                       int iLine,
                       char const FAR *szFile);

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void _asdprintf(char const FAR *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------

void APINOT _Win4Assert(char const FAR * szFile,
                        int iLine,
                        char const FAR * szMessage)
{
    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = _PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifndef FLAT
            _asm int 3;
#else
            DebugBreak();
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifndef FLAT
        _asm int 3;
#else
        DebugBreak();
#endif
    }
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4InfoLevel(unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4InfoMask(unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4AssertLevel(unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    _PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT _PopUpError(char const FAR *szMsg,int iLine, char const FAR *szFile)
{

    int id;
    static char szAssertCaption[100];
    wsprintfA(szAssertCaption, "File: %s line %u", szFile,iLine);

    id = MessageBoxA(NULL,
                     (char FAR *) szMsg,
                     (LPSTR) szAssertCaption,
		     MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);
    return id;
}


//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT vdprintf(unsigned long ulCompMask,
              char const FAR *pszComp,
              char const FAR *ppszfmt,
              va_list     pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        if (! (ulCompMask & DEB_NOCOMPNAME))
        {
#ifdef WIN32
            w4dprintf("%03d.%03d> %s: ",
                      GetCurrentProcessId(),
                      GetCurrentThreadId(),
                      pszComp);
#else
            w4dprintf("%07x> %s: ",
                      GetCurrentTask(),
                      pszComp);
#endif
        }
        w4vdprintf(ppszfmt, pargs);

        // Chicago and Win32s debugging is usually through wdeb386
        // which needs carriage returns
#if WIN32 == 50 || WIN32 == 200
        w4dprintf("\r");
#endif
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\debnot\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#if DBG == 1

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"

LPVOID lpThkCallOutputFunctionsProc = NULL;

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\debnot\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//		w4vprintf
//  		w4dprintf
//		w4vdprintf
//		
//  History:    18-Oct-91   vich	Created
//	
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WIN32
int _cdecl w4dprintf(const char __far *format, ...);
int _cdecl w4vdprintf(const char __far *format, va_list arglist);
#else
int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\debnot\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <stdarg.h>
#include <limits.h>
#include <windows.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char FAR *s, long cch, long FAR * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifndef FLAT
#     define OutputDebugStringA OutputDebugString
#   endif
    int _cdecl _pflushbuf(struct w4io FAR *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io FAR *f, int FAR *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ FAR *string) const char FAR *format, va_list arglist);

#ifdef __cplusplus
extern "C"
{
#endif
DWORD  FAR PASCAL CallProc32W(DWORD dw1, DWORD dw2, DWORD dw3,
                              LPVOID pfn32, DWORD dwPtrTranslate,
                              DWORD dwArgCount);
#ifdef __cplusplus
}
#endif
LPVOID lpThkCallOutputFunctionsProc;


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ FAR *string) const char FAR *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ FAR *string) const char FAR *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (long)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugStringA("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io FAR *f, int FAR *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef FLAT
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io FAR *f)
{
    int cch;

    if (cch = (int) (f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        if (lpThkCallOutputFunctionsProc == NULL)
        {
            OutputDebugStringA(f->pchstart);
        }
        else
        {
            // note casting and dummy arguments to match other uses of it (see interop.hxx)
            CallProc32W((DWORD) f->pchstart, 0, 0, lpThkCallOutputFunctionsProc, 0x00000004, 3); // thunk it to olethk32.dll
        }
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\debnot\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(FLAT)
#ifndef FAR
#define FAR
#endif
#  ifndef FLAT
#    define FLAT
#  endif
#else
#ifndef FAR
#define FAR __far
#endif
#endif

#ifndef NULL
#  define NULL 0
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

struct w4io
{
    union
    {
	struct
	{
	    wchar_t FAR *_pwcbuf;	// wchar_t output buffer
	    wchar_t FAR *_pwcstart;
	} wc;
	struct
	{
	    char FAR *_pchbuf;	// char output buffer
	    char FAR *_pchstart;
	} ch;
    } buf ;
    unsigned int cchleft;	// output buffer character count
    void (_cdecl *writechar)(int ch,
			     int num,
			     struct w4io FAR *f,
			     int FAR *pcchwritten);
};

#define pwcbuf		buf.wc._pwcbuf
#define pwcstart	buf.wc._pwcstart
#define pchbuf		buf.ch._pchbuf
#define pchstart	buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io FAR *stream, const char FAR *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\debnot\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*
*******************************************************************************/

#if DBG == 1

#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS			// Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT	     1	     /* 1 means long is same size as int */
#  define SHORT_IS_INT	     0	     /* 1 means short is same size as int */
#  define PTR_IS_INT	     1	     /* 1 means ptr is same size as int */
#  define PTR_IS_LONG	     0	     /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT	     0	     /* 1 means long is same size as int */
#  define SHORT_IS_INT	     1	     /* 1 means short is same size as int */
#  define PTR_IS_INT	     0	     /* 1 means ptr is same size as int */
#  define PTR_IS_LONG	     1	     /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0	     /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if PTR_IS_INT
    #define get_ptr_arg(x) (void FAR *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void FAR *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE	    /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001	  /* put plus or minus in front */
#define FL_SIGNSP     0x0002	  /* put space or minus in front */
#define FL_LEFT       0x0004	  /* left justify */
#define FL_LEADZERO   0x0008	  /* pad with leading zeros */
#define FL_LONG       0x0010	  /* long value given */
#define FL_SHORT      0x0020	  /* short value given */
#define FL_SIGNED     0x0040	  /* signed data given */
#define FL_ALTERNATE  0x0080	  /* alternate form requested */
#define FL_NEGATIVE   0x0100	  /* value is negative */
#define FL_FORCEOCTAL 0x0200	  /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400	  /* long double value given */
#define FL_WIDE	      0x0800	  /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,		    /* normal state; outputting literal chars */
    ST_PERCENT, 	    /* just read '%' */
    ST_FLAG,		    /* just read flag character */
    ST_WIDTH,		    /* just read width specifier */
    ST_DOT,		    /* just read '.' */
    ST_PRECIS,		    /* just read precision specifier */
    ST_SIZE,		    /* just read size specifier */
    ST_TYPE		    /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,		    /* character with no special meaning */
    CH_PERCENT, 	    /* '%' */
    CH_DOT,		    /* '.' */
    CH_STAR,		    /* '*' */
    CH_ZERO,		    /* '0' */
    CH_DIGIT,		    /* '1'..'9' */
    CH_FLAG,		    /* ' ', '+', '-', '#' */
    CH_SIZE,		    /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE		    /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";	/* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any	  */
/* character; while the uper nybble of the byte gives the next state	  */
/* to enter.  See the macros below the table for details.		  */
/*									  */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.								  */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)		\
	((c) < ' ' || (c) > 'x' ?	\
	    CH_OTHER			\
	:				\
	    lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)	\
	(lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list FAR *pargptr);
#endif
LOCAL(int) get_int_arg(va_list FAR *pargptr);
LOCAL(void) writestring(char FAR *string,
			int len,
			struct w4io FAR *f,
			int FAR *pcchwritten,
			int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (FAR * PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)	    (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)	    (*_cfltcvt_tab[3])(a)
#define _positive(a)	    (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.	It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*	The format string is parsed by using a finite state automaton
*	based on the current state and the current character read from
*	the format string.  Thus, looping is on a per-character basis,
*	not a per conversion specifier basis.  Once the format specififying
*	character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io FAR *f, const char FAR *format, va_list argptr)
{
    int hexadd; 	/* offset to add to number to get 'a'..'f' */
    char ch;		/* character just read */
    wchar_t wc;		/* wide character temp */
    wchar_t FAR *pwc;	/* wide character temp pointer */
    int flags;		/* flag word -- see #defines above for flag values */
    enum STATE state;	/* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;		/* current conversion radix */
    int charsout;	/* characters currently written so far, -1 = IO error */
    int fldwidth;	/* selected field with -- 0 means default */
    int fwide;
    int precision;	/* selected precision -- -1 means default */
    char prefix[2];	/* numeric prefix -- up to two characters */
    int prefixlen;	/* length of prefix -- 0 means no prefix */
    int capexp; 	/* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;	/* non-zero = prodcue no output for this specifier */
    char FAR *text; 	/* pointer text to be printed, not zero terminated */
    char FAR *text2; 	/* pointer text to be printed, not zero terminated */
    int textlen;	/* length of the text to be printed */
    char buffer[BUFFERSIZE];	/* buffer for conversions */

    charsout = 0;		/* no characters written yet */
    state = ST_NORMAL;		/* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
	chclass = find_char_class(ch);	/* find character class */
	state = find_next_state(chclass, state); /* find next state */

	/* execute code for each state */
	switch (state) {

	case ST_NORMAL:
	    /* normal state -- just write character */
	    f->writechar(ch, 1, f, &charsout);
	    break;

	case ST_PERCENT:
	    /* set default value of conversion parameters */
	    prefixlen = fldwidth = no_output = capexp = 0;
	    flags = 0;
	    precision = -1;
	    fwide = 0;
	    break;

	case ST_FLAG:
	    /* set flag based on which flag character */
	    switch (ch) {
	    case '-':
		flags |= FL_LEFT;	/* '-' => left justify */
		break;
	    case '+':
		flags |= FL_SIGN;	/* '+' => force sign indicator */
		break;
	    case ' ':
		flags |= FL_SIGNSP;	/* ' ' => force sign or space */
		break;
	    case '#':
		flags |= FL_ALTERNATE;	/* '#' => alternate form */
		break;
	    case '0':
		flags |= FL_LEADZERO;	/* '0' => pad with leading zeros */
		break;
	    }
	    break;

	case ST_WIDTH:
	    /* update width value */
	    if (ch == '*') {
		/* get width from arg list */
		fldwidth = get_int_arg(&argptr);
		if (fldwidth < 0) {
		    /* ANSI says neg fld width means '-' flag and pos width */
		    flags |= FL_LEFT;
		    fldwidth = -fldwidth;
		}
	    }
	    else {
		/* add digit to current field width */
		fldwidth = fldwidth * 10 + (ch - '0');
	    }
	    break;

	case ST_DOT:
	    /* zero the precision, since dot with no number means 0
	       not default, according to ANSI */
	    precision = 0;
	    break;

	case ST_PRECIS:
	    /* update precison value */
	    if (ch == '*') {
		/* get precision from arg list */
		precision = get_int_arg(&argptr);
		if (precision < 0)
		    precision = -1;	/* neg precision means default */
	    }
	    else {
		/* add digit to current precision */
		precision = precision * 10 + (ch - '0');
	    }
	    break;

	case ST_SIZE:
	    /* just read a size specifier, set the flags based on it */
	    switch (ch) {
#if !LONG_IS_INT
	    case 'l':
		flags |= FL_LONG;   /* 'l' => long int */
		break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
	    case 'L':
		flags |= FL_LONGDOUBLE; /* 'L' => long double */
		break;
#endif

#if !SHORT_IS_INT
	    case 'h':
		flags |= FL_SHORT;  /* 'h' => short int */
		break;
#endif
	    case 'w':
		flags |= FL_WIDE;   /* 'w' => wide character */
		break;
	    }
	    break;

	case ST_TYPE:
	    /* we have finally read the actual type character, so we	   */
	    /* now format and "print" the output.  We use a big switch	   */
	    /* statement that sets 'text' to point to the text that should */
	    /* be printed, and 'textlen' to the length of this text.	   */
	    /* Common code later on takes care of justifying it and	   */
	    /* other miscellaneous chores.  Note that cases share code,    */
	    /* in particular, all integer formatting is doen in one place. */
	    /* Look at those funky goto statements!			   */

	    switch (ch) {

	    case 'c': {
		/* print a single character specified by int argument */
		wc = (wchar_t) get_int_arg(&argptr);	/* get char to print */
		* (wchar_t FAR *) buffer = wc;
		text = buffer;
		textlen = 1;	    /* print just a single character */
	    }
	    break;

	    case 'S': {
		/* print a Counted String

		int i;
		char FAR *p;       /* temps */
                struct string {
                    short Length;
                    short MaximumLength;
                    char FAR *Buffer;
                } *pstr;

		pstr = get_ptr_arg(&argptr);
		if (pstr == NULL || pstr->Buffer == NULL) {
		    /* null ptr passed, use special string */
		    text = nullstring;
#ifdef FLAT
                    textlen = strlen(text);
#else
                    textlen = _fstrlen(text);
#endif
		    flags &= ~FL_WIDE;
		} else {
                    text = pstr->Buffer;
                    textlen = pstr->Length;
                }

	    }
	    break;

	    case 's': {
		/* print a string --				*/
		/* ANSI rules on how much of string to print:	*/
		/*   all if precision is default,		*/
		/*   min(precision, length) if precision given. */
		/* prints '(null)' if a null string is passed	*/

		int i;
		char FAR *p;       /* temps */

		text = get_ptr_arg(&argptr);
		if (text == NULL) {
		    /* null ptr passed, use special string */
		    text = nullstring;
		    flags &= ~FL_WIDE;
		}

		/* At this point it is tempting to use strlen(), but */
		/* if a precision is specified, we're not allowed to */
		/* scan past there, because there might be no null   */
		/* at all.  Thus, we must do our own scan.	     */

		i = (precision == -1) ? INT_MAX : precision;

		/* scan for null upto i characters */
		if (flags & FL_WIDE) {
		    pwc = (wchar_t FAR *) text;
		    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
			++pwc;
			if (wc & 0xff00) {	// if high byte set,
			    break;		// error will be indicated
			}
		    }
		    textlen = (int) (pwc - (wchar_t FAR *) text) ;  /* length of string */
		} else {
		    p = text;
		    while (i-- && *p) {
			++p;
		    }
		    textlen = (int) (p - text);    /* length of the string */
		}
	    }
	    break;

	    case 'n': {
		/* write count of characters seen so far into */
		/* short/int/long thru ptr read from args */

		void FAR *p;	    /* temp */

		p = get_ptr_arg(&argptr);

		/* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
		if (flags & FL_LONG)
		    *(long FAR *)p = charsout;
		else
#endif

#if !SHORT_IS_INT
		if (flags & FL_SHORT)
		    *(short FAR *)p = (short) charsout;
		else
#endif
		    *(int FAR *)p = charsout;

		no_output = 1;		    /* force no output */
	    }
	    break;


#ifndef NOFLOATS
	    case 'E':
	    case 'G':
		capexp = 1;		    /* capitalize exponent */
		ch += 'a' - 'A';	    /* convert format char to lower */
		/* DROP THROUGH */
	    case 'e':
	    case 'f':
	    case 'g':	{
		/* floating point conversion -- we call cfltcvt routines */
		/* to do the work for us.				 */
		flags |= FL_SIGNED;	    /* floating point is signed conversion */
		text = buffer;		    /* put result in buffer */
		flags &= ~FL_WIDE;	    /* 8 bit string */

		/* compute the precision value */
		if (precision < 0)
		    precision = 6;	/* default precision: 6 */
		else if (precision == 0 && ch == 'g')
		    precision = 1;	/* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
		/* do the conversion */
		if (flags & FL_LONGDOUBLE) {
		    _cldcvt(argptr, text, ch, precision, capexp);
		    va_arg(argptr, LONGDOUBLE);
		}
		else
#endif
		{
		    _cfltcvt(argptr, text, ch, precision, capexp);
		    va_arg(argptr, DOUBLE);
		}

		/* '#' and precision == 0 means force a decimal point */
		if ((flags & FL_ALTERNATE) && precision == 0)
		    _forcdecpt(text);

		/* 'g' format means crop zero unless '#' given */
		if (ch == 'g' && !(flags & FL_ALTERNATE))
		    _cropzeros(text);

		/* check if result was negative, save '-' for later */
		/* and point to positive part (this is for '0' padding) */
		if (*text == '-') {
		    flags |= FL_NEGATIVE;
		    ++text;
		}

		textlen = strlen(text);     /* compute length of text */
	    }
	    break;
#endif // NOFLOATS

	    case 'd':
	    case 'i':
		/* signed decimal output */
		flags |= FL_SIGNED;
		radix = 10;
		goto COMMON_INT;

	    case 'u':
		radix = 10;
		goto COMMON_INT;

	    case 'p':
		/* write a pointer -- this is like an integer or long */
		/* except we force precision to pad with zeros and */
		/* output in big hex. */

		precision = 2 * sizeof(void FAR *);     /* number of hex digits needed */
#if !PTR_IS_INT
		flags |= FL_LONG;	/* assume we're converting a long */
#endif
		/* DROP THROUGH to hex formatting */

	    case 'C':
	    case 'X':
		/* unsigned upper hex output */
		hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
		goto COMMON_HEX;

	    case 'x':
		/* unsigned lower hex output */
		hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
		/* DROP THROUGH TO COMMON_HEX */

	    COMMON_HEX:
		radix = 16;
		if (flags & FL_ALTERNATE) {
		    /* alternate form means '0x' prefix */
		    prefix[0] = '0';
		    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);	/* 'x' or 'X' */
		    prefixlen = 2;
		}
		goto COMMON_INT;

	    case 'o':
		/* unsigned octal output */
		radix = 8;
		if (flags & FL_ALTERNATE) {
		    /* alternate form means force a leading 0 */
		    flags |= FL_FORCEOCTAL;
		}
		/* DROP THROUGH to COMMON_INT */

	    COMMON_INT: {
		/* This is the general integer formatting routine. */
		/* Basically, we get an argument, make it positive */
		/* if necessary, and convert it according to the */
		/* correct radix, setting text and textlen */
		/* appropriately. */

		unsigned long number;	/* number to convert */
		int digit;		/* ascii value of digit */
		long l; 		/* temp long value */

		/* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
		if (flags & FL_LONG)
		    l = get_long_arg(&argptr);
		else
#endif

#if !SHORT_IS_INT
		if (flags & FL_SHORT) {
		    if (flags & FL_SIGNED)
			l = (short) get_int_arg(&argptr); /* sign extend */
		    else
			l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
		}
		else
#endif
		{
		    if (flags & FL_SIGNED)
			l = get_int_arg(&argptr); /* sign extend */
		    else
			l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
		}

		/* 2. check for negative; copy into number */
		if ( (flags & FL_SIGNED) && l < 0) {
		    number = -l;
		    flags |= FL_NEGATIVE;   /* remember negative sign */
		}
		else {
		    number = l;
		}

		/* 3. check precision value for default; non-default */
		/*    turns off 0 flag, according to ANSI. */
		if (precision < 0)
		    precision = 1;		/* default precision */
		else
		    flags &= ~FL_LEADZERO;

		/* 4. Check if data is 0; if so, turn off hex prefix */
		if (number == 0)
		    prefixlen = 0;

		/* 5. Convert data to ASCII -- note if precision is zero */
		/*    and number is zero, we get no digits at all.	 */

		text2 = text = &buffer[BUFFERSIZE-1];	// last digit at end of buffer
		flags &= ~FL_WIDE;		// 8 bit characters

		while (precision-- > 0 || number != 0) {
		    digit = (int)(number % radix) + '0';
		    number /= radix;		/* reduce number */
		    if (digit > '9') {
			/* a hex digit, make it a letter */
			digit += hexadd;
		    }
		    *text-- = (char)digit;	/* store the digit */
		}

		textlen = text2 - text; /* compute length of number */
		++text; 	/* text points to first digit now */


		/* 6. Force a leading zero if FORCEOCTAL flag set */
		if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
		    *--text = '0';
		    ++textlen;		/* add a zero */
		}
	    }
	    break;
	    }

	    /* At this point, we have done the specific conversion, and */
	    /* 'text' points to text to print; 'textlen' is length.  Now we */
	    /* justify it, put on prefixes, leading zeros, and then */
	    /* print it. */

	    if (!no_output) {
		int padding;	/* amount of padding, negative means zero */

		if (flags & FL_SIGNED) {
		    if (flags & FL_NEGATIVE) {
			/* prefix is a '-' */
			prefix[0] = '-';
			prefixlen = 1;
		    }
		    else if (flags & FL_SIGN) {
			/* prefix is '+' */
			prefix[0] = '+';
			prefixlen = 1;
		    }
		    else if (flags & FL_SIGNSP) {
			/* prefix is ' ' */
			prefix[0] = ' ';
			prefixlen = 1;
		    }
		}

		/* calculate amount of padding -- might be negative, */
		/* but this will just mean zero */
		padding = fldwidth - textlen - prefixlen;

		/* put out the padding, prefix, and text, in the correct order */

		if (!(flags & (FL_LEFT | FL_LEADZERO))) {
		    /* pad on left with blanks */
		    f->writechar(' ', padding, f, &charsout);
		}

		/* write prefix */
		writestring(prefix, prefixlen, f, &charsout, 0);

		if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
		    /* write leading zeros */
		    f->writechar('0', padding, f, &charsout);
		}

		/* write text */
		writestring(text, textlen, f, &charsout, flags & FL_WIDE);

		if (flags & FL_LEFT) {
		    /* pad on right with blanks */
		    f->writechar(' ', padding, f, &charsout);
		}

		/* we're done! */
	    }
	    break;
	}
    }

    return charsout;	    /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list FAR *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list FAR *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif



/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len	     - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide	     - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
	char FAR *string,
	int len,
	struct w4io FAR *f,
	int FAR *pcchwritten,
	int fwide)
{
    wchar_t FAR *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
	pwc = (wchar_t FAR *) string;
	while (len-- > 0) {
	    if (*pwc & 0xff00) {
		f->writechar('^', 1, f, pcchwritten);
	    }
	    f->writechar((char) *pwc++, 1, f, pcchwritten);
	}
    } else {
	while (len-- > 0) {
	    f->writechar(*string++, 1, f, pcchwritten);
	}
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\h\io16.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	io16.h
//
//  Contents:	16-bit generic include
//
//  History:	18-Feb-94	DrewB	Created
//              07-Mar-94       BobDay  Pre-adjusted STACK_PTR, prepared for
//                                      removal of other macros
//
//----------------------------------------------------------------------------

#ifndef __IO16_H__
#define __IO16_H__

// Get a pointer to a _pascal stack via an argument
#define PASCAL_STACK_PTR(v) ((LPVOID)((DWORD)&(v)+sizeof(v)))

// Get a pointer to a _cdecl stack via an argument
#define CDECL_STACK_PTR(v) ((LPVOID)(&(v)))

#endif // #ifndef __IO16_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\assrtdlg.h ===
#define AssertFail                  5100
#define Expr                        5101
#define Location                    5102
#define ASSRT_ID_BREAK                     5103
#define ASSRT_ID_EXIT                      5104
#define ASSRT_ID_IGNORE                    5105
#define ASSRT_ID_LOC                       5106
#define ASSRT_ID_EXPR                      5107
#define ASSRT_ID_MSG                5108
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\h\wow16fn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	wow16fn.h
//
//  Contents:	WOW 16-bit private function declarations
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#ifndef __WOW16FN_H__
#define __WOW16FN_H__

#ifdef __cplusplus
extern "C"
{
#endif

DWORD  FAR PASCAL LoadLibraryEx32W(LPCSTR pszDll, DWORD reserved,
                                   DWORD dwFlags);
BOOL   FAR PASCAL FreeLibrary32W(DWORD hLibrary);
LPVOID FAR PASCAL GetProcAddress32W(DWORD hMod, LPCSTR pszProc);
DWORD  FAR PASCAL GetVDMPointer32W(LPVOID pv, UINT cb);

/* This API actually takes a variable number of user arguments before
   the three required arguments.  We only need three user arguments at
   most so that's the way we declare it.
   When using this call, dwArgCount must always be three.
   Use CP32_NARGS to track changes*/

#define CP32_NARGS 3
DWORD  FAR PASCAL CallProc32W(DWORD dw1, DWORD dw2, DWORD dw3,
                              LPVOID pfn32, DWORD dwPtrTranslate,
                              DWORD dwArgCount);

#define CallProcIn32(a,b,c,d,e,f) 	CallProc32W(a,b,c,d,e,f)


#ifdef __cplusplus
}
#endif

#endif // #ifndef __WOW16FN_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\coll\plex.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include <windows.h>
#include <ole2.h>
#include <ole2sp.h>
#include <olecoll.h>
#include <memctx.hxx>


#include "plex.h"
ASSERTDATA



CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, DWORD mp, UINT nMax, UINT cbElement)
{
	AssertSz(nMax > 0 && cbElement > 0,0);
	CPlex FAR* p = (CPlex FAR*)CoMemAlloc(sizeof(CPlex) + nMax * cbElement, mp, NULL);
	if (p == NULL)
		return NULL;

	p->nMax = nMax;
	p->nCur = 0;
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CPlex::FreeDataChain(DWORD mp)     // free this one and links
{
    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
		CoMemFree(pThis, mp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\coll\map_kv.cxx ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <ole2.h>
#include <ole2sp.h>
#include <olecoll.h>
#include <memctx.hxx>


#include "map_kv.h"

#include "plex.h"
ASSERTDATA


/////////////////////////////////////////////////////////////////////////////


CMapKeyToValue::CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey,
	int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
	Assert(nBlockSize > 0);

	m_cbValue = cbValue;
	m_cbKey = cbKey;
	m_cbKeyInAssoc = cbKey == 0 ? sizeof(CKeyWrap) : cbKey;

	m_pHashTable = NULL;
	m_nHashTableSize = nHashSize;
	m_lpfnHashKey = lpfnHashKey;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
	if (memctx == MEMCTX_SAME)
		memctx = CoMemctxOf(this);
	m_memctx = memctx;
	Assert(m_memctx != MEMCTX_UNKNOWN);
}

CMapKeyToValue::~CMapKeyToValue()
{
	ASSERT_VALID(this);
	RemoveAll();
	Assert(m_nCount == 0);
}


// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
	UINT hash = 0;
	BYTE FAR* lpb = (BYTE FAR*)pKey;

	while (cbKey-- != 0)
		hash = 257 * hash + *lpb++;

	return hash;
}


BOOL CMapKeyToValue::InitHashTable()
{
	ASSERT_VALID(this);
	Assert(m_nHashTableSize  > 0);
	
	if (m_pHashTable != NULL)
		return TRUE;

	Assert(m_nCount == 0);

	if ((m_pHashTable = (CAssoc FAR* FAR*)CoMemAlloc(m_nHashTableSize * sizeof(CAssoc FAR*), m_memctx, NULL)) == NULL)
		return FALSE;

	_fmemset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

	ASSERT_VALID(this);

	return TRUE;
}


void CMapKeyToValue::RemoveAll()
{
	ASSERT_VALID(this);

	// free all key values and then hash table
	if (m_pHashTable != NULL)
	{
		// destroy assocs
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			register CAssoc FAR* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
				// assoc itself is freed by FreeDataChain below
				FreeAssocKey(pAssoc);
		}

		// free hash table
		CoMemFree(m_pHashTable, m_memctx);
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain(m_memctx);
	m_pBlocks = NULL;

	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_memctx, m_nBlockSize, SizeAssoc());

		if (newBlock == NULL)
			return NULL;

		// chain them into free list
		register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
		// free in reverse order to make it easier to debug
		pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
		for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
		{
			((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
			m_pFreeList = (CAssoc FAR*)pbAssoc;
		}
	}
	Assert(m_pFreeList != NULL); // we must have something

	CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

	// init all fields except pNext while still on free list
	pAssoc->nHashValue = hash;
	if (!SetAssocKey(pAssoc, pKey, cbKey))
		return NULL;

	SetAssocValue(pAssoc, pValue);

	// remove from free list after successfully initializing it (except pNext)
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	Assert(m_nCount > 0);       // make sure we don't overflow

	return pAssoc;
}


// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	Assert(m_nCount >= 0);      // make sure we don't underflow

	FreeAssocKey(pAssoc);
}


// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
	if (m_lpfnHashKey)
		nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else {
		Assert(m_lpfnHashKey);
		return NULL;
	}

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	register CAssoc  FAR* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
			return pAssoc;
	}
	return NULL;
}


BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
	LPVOID pKey1;
	UINT cbKey1;

	GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
	return cbKey1 == cbKey2 && _fmemcmp(pKey1, pKey2, cbKey1) == 0;
}


BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
	Assert(cbKey == m_cbKey || m_cbKey == 0);

	if (m_cbKey == 0)
	{
		Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

		// alloc, set size and pointer
		if ((pAssoc->key.pKey = CoMemAlloc(cbKey, m_memctx, NULL)) == NULL)
			return FALSE;

		pAssoc->key.cbKey = cbKey;
	}

	LPVOID pKeyTo;

	GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

	_fmemcpy(pKeyTo, pKey, cbKey);

	return TRUE;
}


// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
	if (m_cbKey == 0)
	{
		// variable length key; go indirect
		*ppKey = pAssoc->key.pKey;
		*pcbKey = pAssoc->key.cbKey;
	}
	else
	{
		// fixed length key; key in assoc
		*ppKey = (LPVOID)&pAssoc->key;
		*pcbKey = m_cbKey;
	}
}


void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
	if (m_cbKey == 0)
		CoMemFree(pAssoc->key.pKey, m_memctx);
}


void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
	*ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueFrom;
	GetAssocValuePtr(pAssoc, &pValueFrom);
	Assert(pValue != NULL);
	_fmemcpy(pValue, pValueFrom, m_cbValue);
}


void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueTo;
	GetAssocValuePtr(pAssoc, &pValueTo);
	if (pValue == NULL)
		_fmemset(pValueTo, 0, m_cbValue);
	else
		_fmemcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	UINT nHash;
	return LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
}


// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
	{
		_fmemset(pValue, 0, m_cbValue);
		return FALSE;       // not in map
	}

	ASSERT_VALID(this);

	GetAssocValue(pAssoc, pValue);
	return TRUE;
}


// lookup and if not found add; returns FALSE only if OOM; if added, 
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	if (Lookup(pKey, cbKey, pValue))
		return TRUE;

	// value set to zeros since lookup failed

	return ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);
}


// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	UINT nHash;
	register CAssoc  FAR* pAssoc;

	ASSERT_VALID(this);

	if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
	{
		if (!InitHashTable())
			// out of memory
			return FALSE;

		// it doesn't exist, add a new Association
		if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
			return FALSE;

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;

		ASSERT_VALID(this);
	}
	else
	{
		SetAssocValue(pAssoc, pValue);
	}

	return TRUE;
}


// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
		return FALSE;       // not in map

	ASSERT_VALID(this);

	SetAssocValue(pAssoc, pValue);
	return TRUE;
}


// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[(*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize];

	CAssoc  FAR* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;   // not found
}


// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	// REVIEW: would like some way to verify that hKey is valid
	CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
		// null hkey or bad hash value
		return FALSE;

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

	while (*ppAssocPrev != NULL)
	{
		if (*ppAssocPrev == pAssoc)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &(*ppAssocPrev)->pNext;
	}

	return FALSE;   // not found (must have a messed up list or passed 
					// a key from another list)
}


HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
	UINT nHash;

	ASSERT_VALID(this);

	return (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition, 
		LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
	ASSERT_VALID(this);

	Assert(m_pHashTable != NULL);       // never call on empty map

	register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
	Assert(pAssocRet != NULL);

	if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		Assert(pAssocRet != NULL);  // must find something
	}

	// find next association
	CAssoc  FAR* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// fill in return data
	*pNextPosition = (POSITION) pAssocNext;

	// fill in key/pointer to key
	LPVOID pKeyFrom;
	UINT cbKey;
	GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
	if (m_cbKey == 0)
		// variable length key; just return pointer to key itself
		*(void FAR* FAR*)pKey = pKeyFrom;
	else
		_fmemcpy(pKey, pKeyFrom, cbKey);

	if (pcbKey != NULL)
		*pcbKey = cbKey;

	// get value
	GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

void CMapKeyToValue::AssertValid() const
{
#ifdef _DEBUG
	Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

	Assert(m_nHashTableSize > 0);
	Assert(m_nCount == 0 || m_pHashTable != NULL);

	if (m_pHashTable != NULL)
		Assert(!IsBadReadPtr(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

	Assert(!IsBadCodePtr((FARPROC)m_lpfnHashKey));

	if (m_pFreeList != NULL)
		Assert(!IsBadReadPtr(m_pFreeList, SizeAssoc()));

	if (m_pBlocks != NULL)
		Assert(!IsBadReadPtr(m_pBlocks, SizeAssoc() * m_nBlockSize));

	// some collections live as global variables in the libraries, but 
	// have their existance in some context.  Also, we can't check shared
	// collections since we might be checking the etask collection
	// which would cause an infinite recursion.
	Assert(m_memctx == MEMCTX_SHARED || CoMemctxOf(this) == MEMCTX_UNKNOWN || CoMemctxOf(this) == m_memctx);
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\h\wow32fn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	wow32fn.h
//
//  Contents:	WOW 32-bit private function declarations
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#ifndef __WOW32FN_H__
#define __WOW32FN_H__

//
// WOW types
//

// 'V'DM pointers
typedef DWORD VPVOID;
typedef DWORD VPSTR;

typedef HANDLE HAND32;
typedef WORD HAND16;

typedef HAND16 HMEM16;
typedef HAND16 HWND16;
typedef HAND16 HDC16;
typedef HAND16 HRGN16;
typedef HAND16 HMENU16;
typedef HAND16 HICON16;
typedef HAND16 HBITMAP16;
typedef HAND16 HACCEL16;
typedef HAND16 HTASK16;
typedef HAND16 HMETAFILE16;

#ifdef __cplusplus
extern "C"
{
#endif

// Macros to handle conversion of 16:16 pointers to 0:32 pointers
// On NT this mapping is guaranteed to stay stable in a WOW process
// as long as a 32->16 transition doesn't occur
//

#define WOWFIXVDMPTR(vp, cb) WOWGetVDMPointer(vp, cb, TRUE)
#define WOWRELVDMPTR(vp)     (vp)

#define FIXVDMPTR(vp, type) \
    (type UNALIGNED *)WOWFIXVDMPTR(vp, sizeof(type))
#define RELVDMPTR(vp) \
    WOWRELVDMPTR(vp)

HAND16 CopyDropFilesFrom32(HANDLE h32);
HANDLE CopyDropFilesFrom16(HAND16 h16);

#ifdef __cplusplus
}
#endif

// 16-bit HGLOBAL tracking functions
#if DBG == 1
VPVOID WgtAllocLock(WORD wFlags, DWORD cb, HMEM16 *ph);
void WgtUnlockFree(VPVOID vpv);
void WgtDump(void);
#else
#define WgtAllocLock(wFlags, cb, ph) \
    WOWGlobalAllocLock16(wFlags, cb, ph)
#define WgtUnlockFree(vpv) \
    WOWGlobalUnlockFree16(vpv)
#define WgtDump()
#endif

#endif // #ifndef __WOW32FN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\makefile.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!include $(NTMAKEENV)\makefile.plt

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif


!if "$(OPST)" == ""
!error OPSTR must be defined [chic|dayt]
!endif

OUTNUL= 1>nul 2>nul

# !if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
# OBJDIR = objd$(OPST)
# !else
# OBJDIR = objr$(OPST)
# !endif
OBJDIR=$(_OBJ_DIR)\$(TARGET_DIRECTORY)

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR
#
# JohnDoty:
# The build will break with $(O) has a new range of supported types.
# This sucks.  However, I don't think I can do this correctly.
#
!if "$(OBJDIR)" == "obj\i386"
OBJFILES = $(OBJFILES:.\=obj\i386\)
RESFILES = $(RESFILES:.\=obj\i386\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif
BLDKEEP=        KEEP

!ifndef OLEDIR
OLEDIR=..\..\..
!endif
OLETHUNK= $(OLEDIR)\olethunk
OLE16= $(OLETHUNK)\ole16

!if "$(OPST)" == "chic"
RCINC = $(RCINC) -i..\inc\chicago -i..\inc
!else
RCINC = $(RCINC) -i$(OLE16)\inc
!endif
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(SDK_INC_PATH)

PATH    = $(OLE16)\tools;$(PATH)
LINK    = link16
#
#  We need to mark our Windows 95 components as version 4.0.
#
!if "$(OPST)" == "chic"
RCT     = rc_chic -40
!else
RCT     = rc16
!endif
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = $(DEFINES) -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -Alfw $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if ("$(NTDEBUGTYPE)" == "windbg") || ("$(NTDEBUGTYPE)" == "both")
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip -DDBG=1 -DDEVL=1
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs -DDBG=0 -DDEVL=1
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RCT)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RCT) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\clstub16.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       clstub16.cxx
//
//  Contents:   32->16 bit call forwarding stub
//
//  History:    25-Feb-93       DrewB   Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CallStub16, public
//
//  Synopsis:   Invokes a 16-bit routine on behalf of the 32-bit code
//
//  Arguments:  [pcd] - Data describing the call to be made
//
//  Returns:    Appropriate status code
//
//  History:    18-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL CallStub16(LPCALLDATA pcd)
{
    DWORD dwRes;
    DWORD pfn;
    WORD cbStack;
    DWORD pvStack;
    
    thkAssert(pcd != NULL);

    pfn = pcd->vpfn;
    cbStack = (WORD)pcd->cbStack;
    pvStack = pcd->vpvStack16;

    thkDebugOut((DEB_ITRACE, "In CallStub16(%08lX, %u, %08lX)\n",
                 pfn, cbStack, pvStack));
    
    // Check for wildly out-of-range stack sizes
    thkAssert(cbStack < 0x100);

    // Make sure that the stack size is even to
    // maintain alignment and allow free use of movsw
    thkAssert((cbStack & 1) == 0);
    
    __asm
    {
        // Make space on the real stack for the stack given to us from 32-bits
        sub sp, cbStack

        // Simple sanity checks on new stack pointer
        jc StackOverflow
        cmp sp, 512
        jb StackOverflow

        // Copy pvStack to the real stack
        push ds
        push si
        push es
        push di

        mov ds, WORD PTR pvStack+2
        mov si, WORD PTR pvStack
        
        mov ax, ss
        mov es, ax
        mov di, sp
        // Skip over saved registers
        add di, 8

        mov cx, cbStack
        shr cx, 1
        cld        
        rep movsw

        pop di
        pop es
        pop si
        pop ds

        // Call the routine
        call DWORD PTR pfn
        
        jmp End

    StackOverflow:
        // E_OUTOFMEMORY
        mov dx, 8000h
        mov ax, 0002h
        
    End:
        mov WORD PTR dwRes, ax
        mov WORD PTR dwRes+2, dx
        
        add sp, cbStack
    }

    thkDebugOut((DEB_ITRACE, "Out CallStub16: return %ld\n",dwRes));

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\comguid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	ComGUID.cxx	(16 bit target)
//
//  Contents:	GUIDs for CompObj 
//
//  Functions:	
//
//  History:	17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "initguid.h"
#include "coguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\call32.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       call32.cxx      (16 bit target)
//
//  Contents:   Functions to call 32 bit dll in WOW
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>

#include "map_htsk.h"
#include "etask.hxx"

#include <call32.hxx>
#include <obj16.hxx>
#include <go1632pr.hxx>
#include <comlocal.hxx>

static LPVOID lpInvokeOn32Proc;     // Address of InvokeOn32() in 32-bits
static LPVOID lpSSInvokeOn32Proc;   // Address of InvokeOn32() in 32-bits
LPVOID lpIUnknownObj32;             // Address of IUnknown methods handler
static LPVOID lpCallbackProcessing; // Address of CallbackProcessing_3216
static LPVOID pfnCSm16ReleaseHandler_Release32;

static LPVOID pfnConvertHr1632;     // TranslateHRESULT_1632
static LPVOID pfnConvertHr3216;     // TranslateHRESULT_3216
static LPVOID pfnThkAddAppCompatFlag; // Add an AppCompatibility flag

static DWORD hmodOLEThunkDLL;       // Module handle of 32-bit OLE interop DLL
EXTERN_C LPVOID lpThkCallOutputFunctionsProc; // Address of ThkCallOutputFunctions in olethk32.dll

static LPVOID pfnIntOpUninitialize; // Uninitialize function


DWORD __loadds FAR PASCAL CallStub16(LPCALLDATA pcd);

// Address of ThkInitialize() in 32-bits
static LPVOID lpThkInitializeProc;
// Address of ThkUninitialize() in 32-bits
static LPVOID lpThkUninitializeProc;

BOOL  __loadds FAR PASCAL CallbackHandler( DWORD dwContinue );
DWORD __loadds FAR PASCAL LoadProcDll( LPLOADPROCDLLSTRUCT lplpds );
DWORD __loadds FAR PASCAL UnloadProcDll( DWORD vhmodule );
DWORD __loadds FAR PASCAL CallGetClassObject( LPCALLGETCLASSOBJECTSTRUCT
                                              lpcgcos );
DWORD __loadds FAR PASCAL CallCanUnloadNow( DWORD vpfnCanUnloadNow );
DWORD __loadds FAR PASCAL QueryInterface16(IUnknown FAR *punk,
                                           REFIID riid,
                                           void FAR * FAR *ppv);
DWORD __loadds FAR PASCAL AddRef16(IUnknown FAR *punk);
DWORD __loadds FAR PASCAL Release16(IUnknown FAR *punk);
DWORD __loadds FAR PASCAL ReleaseStgMedium16(STGMEDIUM FAR *psm);
DWORD __loadds FAR PASCAL TouchPointer16(BYTE FAR *pb);
DWORD __loadds FAR PASCAL StgMediumStreamHandler16(IStream FAR *pstmFrom,
                                         IStream FAR *pstmTo);
DWORD __loadds FAR PASCAL SetOwnerPublic16( DWORD hMem16 );
ULONG __loadds FAR PASCAL WinExec16( LPWINEXEC16STRUCT lpwes );


extern DWORD Sm16RhVtbl[SMI_COUNT];

// This DBG block allows assertion that the list is the same size
// as a DATA16
#if DBG == 1
DWORD gdata16[] =
#else
DATA16 gdata16 =
#endif
{
    (DWORD)atfnProxy1632Vtbl,
    (DWORD)CallbackHandler,
    (DWORD)TaskAlloc,
    (DWORD)TaskFree,
    (DWORD)LoadProcDll,
    (DWORD)UnloadProcDll,
    (DWORD)CallGetClassObject,
    (DWORD)CallCanUnloadNow,
    (DWORD)QueryInterface16,
    (DWORD)AddRef16,
    (DWORD)Release16,
    (DWORD)ReleaseStgMedium16,
    (DWORD)Sm16RhVtbl,
    (DWORD)TouchPointer16,
    (DWORD)StgMediumStreamHandler16,
    (DWORD)CallStub16,
    (DWORD)SetOwnerPublic16,
    (DWORD)WinExec16
};

//+---------------------------------------------------------------------------
//
//  Function:   CallbackHandler
//
//  Synopsis:   Provides 16-bit address that will allow calling back into
//              the 32-bit world's callback handler.  See IViewObject::Draw
//              lpfnContinue function parameter for the reasons for this
//              function.
//
//  Returns:    BOOL
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
BOOL __loadds FAR PASCAL CallbackHandler( DWORD dwContinue )
{
    BOOL    fResult;

    thkDebugOut((DEB_ITRACE, "CallbackHandler\n"));

    fResult = (BOOL)CallProcIn32( dwContinue, 0, 0,
                                 lpCallbackProcessing, 0, CP32_NARGS);

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Call32Initialize, public
//
//  Synopsis:   Called once when compobj.dll gets loaded.
//              Connects to the interop DLL on the 32-bit side and
//              finds entry points
//
//  Returns:    BOOL
//
//  History:    18-Feb-94       JohannP Created
//
//  Notes:      Called at library initialization time
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) Call32Initialize(void)
{
    LPVOID lpAddr;
    BOOL fRet;
    DWORD hr;

    thkDebugOut((DEB_ITRACE | DEB_THUNKMGR, "In  Call32Initialize\n"));

    thkAssert(sizeof(gdata16) == sizeof(DATA16));

    fRet = FALSE;
    do
    {
        //
        // Load the OLETHK32.DLL in WOW
        //
        hmodOLEThunkDLL = LoadLibraryEx32W("OLETHK32.DLL", 0, 0);
        if (hmodOLEThunkDLL == 0)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; LoadLibary failed.\n"));
            break;
        }

        //
        // Get the 32-bit initalization routine
        //
        lpAddr = GetProcAddress32W(hmodOLEThunkDLL, "IntOpInitialize");
        if (lpAddr == NULL)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress IntOpInitialize failed.\n"));
            break;
        }

        // Call the initialization routine and pass the 16-bit
        // invocation and proxy setup routine pointers
        // We want to keep these pointers in VDM form for Callback16
        // so we do not have them mapped flat

        if ((hr = CallProcIn32((DWORD)(LPDATA16)(&gdata16), 0, 0, lpAddr, 1 << 2, CP32_NARGS)) != NOERROR)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; Call IntOpInitialize failed. hr = %x\n", hr));
            break;
        }

        //
        // Get the address of the start of the 32-bit thunk interpreter
        //
        lpInvokeOn32Proc = GetProcAddress32W(hmodOLEThunkDLL, "InvokeOn32");
        if (lpInvokeOn32Proc == NULL)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress InvokeOn32 failed.\n"));
            break;
        }

        lpIUnknownObj32 = GetProcAddress32W(hmodOLEThunkDLL, "IUnknownObj32");
        if (lpIUnknownObj32 == NULL)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress IUnknowObj32 failed.\n"));
            break;
        }

        // proc address to initialize the thunk manager for
        // needs to be called for each apartment
        lpThkInitializeProc = GetProcAddress32W(hmodOLEThunkDLL,
                                                "ThkMgrInitialize");
        if (lpThkInitializeProc == NULL)
        {
            break;
        }

        lpThkUninitializeProc = GetProcAddress32W(hmodOLEThunkDLL,
                                                  "ThkMgrUninitialize");
        if (lpThkUninitializeProc == NULL)
        {
            break;
        }

        pfnCSm16ReleaseHandler_Release32 =
            GetProcAddress32W(hmodOLEThunkDLL,
                              "CSm16ReleaseHandler_Release32");
        if (pfnCSm16ReleaseHandler_Release32 == NULL)
        {
            break;
        }

        //
        // Get the address of the callback procedure for 32-bit callbacks
        //
        lpCallbackProcessing = GetProcAddress32W(hmodOLEThunkDLL,
                                                 "CallbackProcessing_3216");
        if ( lpCallbackProcessing == NULL )
        {
            break;
        }

        pfnConvertHr1632 = GetProcAddress32W(hmodOLEThunkDLL,
                                             "ConvertHr1632Thunk");
        if (pfnConvertHr1632 == NULL)
        {
            break;
        }

        pfnConvertHr3216 = GetProcAddress32W(hmodOLEThunkDLL,
                                             "ConvertHr3216Thunk");
        if (pfnConvertHr3216 == NULL)
        {
            break;
        }

        pfnIntOpUninitialize = GetProcAddress32W(hmodOLEThunkDLL,
                                                "IntOpUninitialize");
        if (pfnIntOpUninitialize == NULL)
        {
            break;
        }

        pfnThkAddAppCompatFlag = GetProcAddress32W(hmodOLEThunkDLL,
                                        "ThkAddAppCompatFlag");

        if (pfnThkAddAppCompatFlag == NULL )
        {
                break;
        }

#if DBG == 1
        lpThkCallOutputFunctionsProc = GetProcAddress32W(hmodOLEThunkDLL, "ThkCallOutputFunctions");
        if (lpThkCallOutputFunctionsProc == NULL)
        {
            // Ignore error as stuff will go to debugger screen by default
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress ThkCallOutputFunctions failed.\n"));
        }
#endif

        fRet = TRUE;
    }
    while (FALSE);

    if (!fRet && hmodOLEThunkDLL != 0)
    {
        FreeLibrary32W(hmodOLEThunkDLL);
    }

    thkDebugOut((DEB_ITRACE | DEB_THUNKMGR, "Out Call32Initialize exit, %d\n", fRet));
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   Call32Uninitialize, public
//
//  Synopsis:   Called once when compobj.dll gets unloaded.
//              Disconnects to the interop DLL on the 32-bit side
//
//  History:    13-Jul-94       BobDay      Created
//
//  Notes:      Called at library WEP time
//
//----------------------------------------------------------------------------
STDAPI_(void) Call32Uninitialize(void)
{
    //
    // The notification is only sent on Windows/NT. On Win95, the 32-bit
    // side has already been cleaned up at this point, so calling over to
    // 32-bits is a really bad idea. We could fault.
    //
    // Notify olethk32 that the 16-bit half of interop is going away
    if (pfnIntOpUninitialize != NULL)
    {
        CallProc32W(0, 0, 0, pfnIntOpUninitialize, 0, CP32_NARGS);
    }

    //
    // Free OLETHK32.DLL
    //
    if ( CanReleaseDLL() && hmodOLEThunkDLL != 0 )
    {
        FreeLibrary32W(hmodOLEThunkDLL);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CallThkUninitialize
//
//  Synopsis:   Uninitialize the thunk manager and the tls data
//
//  History:    5-24-94   JohannP (Johann Posch)   Created
//
//  Notes:      Is called after CoUnintialize returned.
//
//----------------------------------------------------------------------------
STDAPI_(void) CallThkMgrUninitialize(void)
{
    thkAssert(lpThkUninitializeProc != NULL);

    CallProc32W(0, 0, 0,
                lpThkUninitializeProc, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallThkInitialize
//
//  Synopsis:   Initializes the thunk manager and the tls data
//
//  Returns:    Appropriate status code
//
//  History:    5-24-94   JohannP (Johann Posch)   Created
//
//  Notes:      Called during CoInitialize.
//
//----------------------------------------------------------------------------

STDAPI CallThkMgrInitialize(void)
{
    thkAssert(lpThkInitializeProc != NULL);

    return (HRESULT)CallProc32W(0, 0, 0,
                                lpThkInitializeProc, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallObjectInWOW, public
//
//  Synopsis:   Wrapper for CallProcIn32 which handles our particular
//              form of call for thunked APIs and methods
//
//  Arguments:  [oid] - Object ID
//              [dwMethod] - Method index
//              [pvStack] - Beginning of stack in 16-bits
//
//  Returns:    32-bit call result
//
//  History:    18-Feb-94       JohannP Created
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CallObjectInWOW(DWORD dwMethod, LPVOID pvStack)
{

    thkDebugOut((DEB_ITRACE, "CallObjectInWOW\n"));
    thkAssert(lpInvokeOn32Proc != NULL);

    // If the stack pointer is NULL then pass along our own stack
    // It won't be used but we need a valid pointer for CallProcIn32
    // to work on
    if (pvStack == NULL)
    {
        pvStack = PASCAL_STACK_PTR(dwMethod);
    }

    thkDebugOut((DEB_ITRACE, "CallProcIn32(%08lX)(0x%08lX, %p)\n",
                 lpInvokeOn32Proc, dwMethod, pvStack));

    // Translate the stack pointer from 16:16 to flat 32
    // The other user parameters aren't pointers
    return CallProcIn32(0, dwMethod, (DWORD)pvStack,
                       lpInvokeOn32Proc, (1 << 0), CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSCallObjectInWOW
//
//  Synopsis:
//
//  Arguments:  [dwMetho] --
//              [pvStack] --
//
//  Returns:
//
//  History:    1-24-95   JohannP (Johann Posch)   Created
//
//  Notes:      Same functionality as CallObjectInWOW except
//              not switching to 32 bit stack first.
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) SSCallObjectInWOW(DWORD dwMethod, LPVOID pvStack)
{
    thkDebugOut((DEB_ITRACE, "CallObjectInWOW\n"));
    thkAssert(lpInvokeOn32Proc != NULL);

    // If the stack pointer is NULL then pass along our own stack
    // It won't be used but we need a valid pointer for CallProcIn32
    // to work on
    if (pvStack == NULL)
    {
        pvStack = PASCAL_STACK_PTR(dwMethod);
    }

    thkDebugOut((DEB_ITRACE, "CallProcIn32(%08lX)(0x%08lX, %p)\n",
                 lpInvokeOn32Proc, dwMethod, pvStack));

    // Translate the stack pointer from 16:16 to flat 32
    // The other user parameters aren't pointers
    return CallProcIn32(0, dwMethod, (DWORD)pvStack,
                       lpSSInvokeOn32Proc, (1 << 0), CP32_NARGS);
}


//+---------------------------------------------------------------------------
//
//  Function:   CallObjectInWOWCheckInit, public
//
//  Synopsis:   Performs CallObjectInWOW with guaranteed initialization
//
//  Arguments:  [oid] - Object ID
//              [dwMethod] - Method index
//              [pvStack] - Beginning of stack in 16-bits
//
//  Returns:    32-bit call result
//
//  History:    18-Feb-94       JohannP Created
//
//  Notes:      Since this function can return an error code from
//              CoInitialize, it should only be used directly for
//              functions which return HRESULTs
//              Other functions should check the HRESULT and map
//              it into an appropriate return value
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CallObjectInWOWCheckInit(DWORD dwMethod, LPVOID pvStack)
{
    Etask etask;
    HTASK htask;
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CallObjectInWOWCheckInit\n"));

    if (!IsEtaskInit(htask, etask))
    {
        hr = CoInitialize( NULL );
        if (FAILED(hr))
        {
            return (DWORD)hr;
        }

        thkVerify(LookupEtask( htask, etask ));
        etask.m_inits = ETASK_FAKE_INIT;
        thkVerify(SetEtask(htask, etask));
    }

    return( CallObjectInWOW( dwMethod, pvStack) );
}
//+---------------------------------------------------------------------------
//
//  Function:   CallObjectInWOWCheckThkMgr, public
//
//  Synopsis:   Performs CallObjectInWOW with guaranteed initialization
//              of ThkMgr.
//
//  Arguments:  [oid] - Object ID
//              [dwMethod] - Method index
//              [pvStack] - Beginning of stack in 16-bits
//
//  Returns:    32-bit call result
//
//  History:    25-Aug-94       JohannP Created
//
//  Notes:      Since this function can return an error code from
//              ThkMgrInitialize, it should only be used directly for
//              functions which return HRESULTs
//              Other functions should check the HRESULT and map
//              it into an appropriate return value
//              This function is used by Storage api's since
//              they do not need compobj.
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CallObjectInWOWCheckThkMgr(DWORD dwMethod, LPVOID pvStack)
{
    Etask etask;
    HTASK htask;
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CallObjectInWOWCheckThkMgr\n"));

    // Note: IsEtaskInit will fail until CoInitialize
    // gets called.
    // ThkMgrInitialize can be called mutliple time
    // on the same apartment. This is inefficient but
    // the simplest solution; there are only a few
    // apps out there which use Storage api's without
    // compobj and ole2.
    if (!IsEtaskInit(htask, etask))
    {
        //  Note:
        //  Under Chicago 32-bit DLL's are loaded into a 16-bit apps private
        //  memory address space.  (Under Daytona, 32-bit DLL's are loaded in
        //  common memory).  This causes an abort as the logic assumes that
        //  OLETHK32.DLL is loaded at this point.
        //
        //  So if not initialize, initialize the thunk layer now.
        //
        hr = CallThkMgrInitialize();
        if (FAILED(hr))
        {
            return (DWORD)hr;
        }
    }

    return( CallObjectInWOW( dwMethod, pvStack) );
}



//+---------------------------------------------------------------------------
//
//  Function:   LoadProcDll, public
//
//  Synopsis:   Routine to load a 16-bit DLL and get the OLE entry points
//
//  Arguments:  [lplpds] - LoadProcDll struct full of needed goodies
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL LoadProcDll( LPLOADPROCDLLSTRUCT lplpds )
{
    DWORD   dwResult;
    HMODULE hmod16;
    LPDWORD lpdw;

    thkDebugOut((DEB_ITRACE, "LoadProcDll\n"));

    hmod16 = LoadLibrary( (LPSTR)lplpds->vpDllName );

    if ( hmod16 < HINSTANCE_ERROR )
    {
        return OLETHUNK_DLL16NOTFOUND;
    }

    lplpds->vpfnGetClassObject =
                (DWORD)GetProcAddress( hmod16, "DllGetClassObject" );
    lplpds->vpfnCanUnloadNow   =
                (DWORD)GetProcAddress( hmod16, "DllCanUnloadNow" );

    lplpds->vhmodule = (DWORD) hmod16;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnloadProcDll, public
//
//  Synopsis:   Routine to unload a 16-bit DLL
//
//  Arguments:  [vhmodule] - hmodule to unload
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL UnloadProcDll( DWORD vhmodule )
{
    DWORD   dwResult;
    HMODULE hmod16;

    thkDebugOut((DEB_ITRACE, "UnloadProcDll\n"));

    hmod16 = (HMODULE)vhmodule;

    FreeLibrary( hmod16 );

    return (DWORD)0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallGetClassObject, public
//
//  Synopsis:   Routine to call 16-bit DLL's DllGetClassObject entrypoint
//
//  Arguments:  [lpcgcos] - CallGetClassObject struct full of needed goodies
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL CallGetClassObject(
    LPCALLGETCLASSOBJECTSTRUCT lpcgcos )
{
    HRESULT hresult;
    HRESULT (FAR PASCAL *lpfn)(CLSID &,IID &,LPVOID FAR *);

    thkDebugOut((DEB_ITRACE, "CallGetClassObject\n"));

    lpfn = (HRESULT (FAR PASCAL *)(CLSID &,IID &,LPVOID FAR*))
                     lpcgcos->vpfnGetClassObject;

    hresult = (*lpfn)( lpcgcos->clsid,
                       lpcgcos->iid,
                       (LPVOID FAR *)&lpcgcos->iface );

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallCanUnloadNow, public
//
//  Synopsis:   Routine to call 16-bit DLL's DllCanUnloadNow entrypoint
//
//  Arguments:  [vpfnCanUnloadNow] - 16:16 address of DllCanUnloadNow in DLL
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL CallCanUnloadNow( DWORD vpfnCanUnloadNow )
{
    HRESULT hresult;
    HRESULT (FAR PASCAL *lpfn)(void);

    thkDebugOut((DEB_ITRACE, "CallGetClassObject\n"));

    lpfn = (HRESULT (FAR PASCAL *)(void))vpfnCanUnloadNow;

    hresult = (*lpfn)();

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryInterface16, public
//
//  Synopsis:   Calls QueryInterface on behalf of the 32-bit code
//
//  Arguments:  [punk] - Object
//              [riid] - IID
//              [ppv] - Interface return
//
//  Returns:    HRESULT
//
//  History:    24-Mar-94       JohannP   Created
//
//----------------------------------------------------------------------------
DWORD __loadds FAR PASCAL QueryInterface16(IUnknown *punk,
                                           REFIID riid,
                                           void **ppv)
{
    DWORD dwRet;

    thkAssert(punk != NULL);

    // There are shutdown cases where we will attempt to release objects
    // which no longer exist in the 16-bit world
    // According to CraigWi, in 16-bit OLE objects which had an
    // external reference were not cleaned up in CoUninitialize,
    // while in 32-bit OLE things are always cleaned up.  This
    // means that apps which are leaking objects with external locks
    // (Word can in some situations) get Releases that they do not
    // expect, so protect against calling invalid objects
    if (!IsValidInterface(punk))
    {
        thkDebugOut((DEB_ERROR, "QueryInterface16(%p) - Object invalid\n",
                     punk));
        return (DWORD)E_UNEXPECTED;
    }

    thkDebugOut((DEB_THUNKMGR, "In QueryInterface16(%p, %p, %p)\n",
                 punk, &riid, ppv));

    dwRet = (DWORD)punk->QueryInterface(riid, ppv);

    // There are some apps (Works is one) that return an IOleItemContainer
    // as an IOleContainer but neglect to respond to IOleContainer
    // in their QueryInterface implementations
    // In that event, retry with IOleItemContainer.  This is legal
    // to return as an IOleContainer since IOleItemContainer is
    // derived from IOleContainer

    // There are other derivation cases in the same vein

    if (dwRet == (DWORD)E_NOINTERFACE)
    {
        if (IsEqualIID(riid, IID_IOleContainer))
        {
            // Works has this problem

            dwRet = (DWORD)punk->QueryInterface(IID_IOleItemContainer, ppv);
        }
        else if (IsEqualIID(riid, IID_IPersist))
        {
            // According to the OLE 2.01 16-bit sources, Corel PhotoPaint
            // supports IPersistStorage but not IPersist.  Try all persist
            // combinations.

            dwRet = (DWORD)punk->QueryInterface(IID_IPersistStorage, ppv);
            if (dwRet == (DWORD)E_NOINTERFACE)
            {
                dwRet = (DWORD)punk->QueryInterface(IID_IPersistFile, ppv);
                if (dwRet == (DWORD)E_NOINTERFACE)
                {
                    dwRet = (DWORD)punk->QueryInterface(IID_IPersistStream,
                                                        ppv);
                }
            }
        }
    }

    thkDebugOut((DEB_THUNKMGR,
                 "  >>IUnknowObj16:QueryInterface (%p):0x%08lx\n",
                 *ppv, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRef16, public
//
//  Synopsis:   Calls AddRef on behalf of the 32-bit code
//
//  Arguments:  [punk] - Object
//
//  Returns:    16-bit call return
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL AddRef16(IUnknown *punk)
{
    // There are shutdown cases where we will attempt to release objects
    // which no longer exist in the 16-bit world
    // According to CraigWi, in 16-bit OLE objects which had an
    // external reference were not cleaned up in CoUninitialize,
    // while in 32-bit OLE things are always cleaned up.  This
    // means that apps which are leaking objects with external locks
    // (Word can in some situations) get Releases that they do not
    // expect, so protect against calling invalid objects
    if (!IsValidInterface(punk))
    {
        thkDebugOut((DEB_ERROR, "AddRef16(%p) - Object invalid\n", punk));
        return 0;
    }

    return punk->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Function:   Release16, public
//
//  Synopsis:   Calls Release on behalf of the 32-bit code
//
//  Arguments:  [punk] - Object
//
//  Returns:    16-bit call return
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL Release16(IUnknown *punk)
{
    // There are shutdown cases where we will attempt to release objects
    // which no longer exist in the 16-bit world
    // According to CraigWi, in 16-bit OLE objects which had an
    // external reference were not cleaned up in CoUninitialize,
    // while in 32-bit OLE things are always cleaned up.  This
    // means that apps which are leaking objects with external locks
    // (Word can in some situations) get Releases that they do not
    // expect, so protect against calling invalid objects
    if (!IsValidInterface(punk))
    {
        thkDebugOut((DEB_ERROR, "Release16(%p) - Object invalid\n", punk));
        return 0;
    }

    return punk->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseStgMedium16, public
//
//  Synopsis:   Calls ReleaseStgMedium
//
//  Arguments:  [psm] - STGMEDIUM
//
//  Returns:    Appropriate status code
//
//  History:    25-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL ReleaseStgMedium16(STGMEDIUM FAR *psm)
{
    ReleaseStgMedium(psm);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSm16ReleaseHandler routines, public
//
//  Synopsis:   Method implementations for CSm16ReleaseHandler
//
//  History:    24-Apr-94       DrewB   Created
//              26-Mar-97       Gopalk  Removed call on the proxy to 32-bit
//                                      punkForRelease as the proxy is not
//                                      created in the first place
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) Sm16RhAddRef(CSm16ReleaseHandler FAR *psrh)
{
    return ++psrh->_cReferences;
}

STDMETHODIMP Sm16RhQI(CSm16ReleaseHandler FAR *psrh,
                      REFIID riid,
                      void FAR * FAR *ppv)
{
    if ( IsEqualIID(riid,IID_IUnknown) )
    {
        *ppv = psrh;
        Sm16RhAddRef(psrh);
        return NOERROR;
    }
    else
    {
        thkDebugOut((DEB_WARN, "Not a QI for IUnknown\n"));
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) Sm16RhRelease(CSm16ReleaseHandler FAR *psrh)
{
    STGMEDIUM *psm;
    METAFILEPICT *pmfp;
    HGLOBAL hg;

    if (--psrh->_cReferences != 0)
    {
        return psrh->_cReferences;
    }

    psm = &psrh->_sm16;
    switch(psm->tymed)
    {
    case TYMED_HGLOBAL:
        // Don't free this because copyback needs to occur in the
        // 32-bit world
        break;

    case TYMED_MFPICT:
        // Win95 thunking shares HMETAFILEs between 16/32 so we don't
        // need to clean up our copy
        pmfp = (METAFILEPICT *)GlobalLock(psm->hGlobal);
        DeleteMetaFile(pmfp->hMF);
        GlobalUnlock(psm->hGlobal);
        GlobalFree(psm->hGlobal);
        break;

    case TYMED_FILE:
    case TYMED_ISTREAM:
    case TYMED_ISTORAGE:
        // Handled by ReleaseStgMedium
        // 32-bit name handled by 32-bit part of processing
        break;

    case TYMED_GDI:
    case TYMED_NULL:
        // Nothing to release
        break;

    default:
        thkAssert(!"Unknown tymed in CSm16ReleaseHandler::Release");
        break;
    }

    // Continue call in 32-bits where 32-bit task allocations
    // and other 32-bit objects are cleaned up
    CallProcIn32( (DWORD)psrh, 0, 0,
                 pfnCSm16ReleaseHandler_Release32, (1 << 2), CP32_NARGS);

    // Clean up this
    hg = LOWORD(GlobalHandle(HIWORD((unsigned long)psrh)));
    GlobalUnlock(hg);
    GlobalFree(hg);

    return 0;
}

DWORD Sm16RhVtbl[SMI_COUNT] =
{
    (DWORD)Sm16RhQI,
    (DWORD)Sm16RhAddRef,
    (DWORD)Sm16RhRelease
};


//+---------------------------------------------------------------------------
//
//  Function:   StgMediumStreamHandler16
//
//  Synopsis:   Copies one stream to another
//
//  Effects:    Turns out that Excel does the wrong thing with STGMEDIUM's
//      when its GetDataHere() method is called. Instead of using
//      the provided stream, like it was supposed to, it creates its
//      own stream, and smashes the passed in streams pointer. This
//      appears to be happening on the Clipboard object for Excel.
//      To fix this, the thop function for STGMEDIUM input is going to
//      watch for changes to the stream pointer. If it changes, then
//      the 'app' (excel) has done something wrong.
//
//      To recover from this, the thop will call this routine passing
//      the bogus stream and the stream that was supposed to be used.
//      This routine will do a pstmFrom->CopyTo(pstmTo), and then
//      release the 'bogus' stream pointer.
//
//  Arguments:  [pstmFrom] -- Stream to copy then release
//      [pstmTo] -- Destination stream
//
//  History:    7-07-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD __loadds FAR PASCAL StgMediumStreamHandler16(IStream FAR *pstmFrom,
                                         IStream FAR *pstmTo)
{
    HRESULT hresult;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;
    ULONG ul;

    thkDebugOut((DEB_ITRACE,
                 "*** StgMediumStreamHandler16(pstmFrom=%p,pstmTo=%p)\n",
         pstmFrom,pstmTo));

    //
    // Assume that the entire stream is the data set to be copied.
    // Seek to the start of the stream
    //
    ULISet32(li,0);
    hresult = pstmFrom->Seek(li,STREAM_SEEK_SET,NULL);
    if (hresult != NOERROR)
    {
       thkDebugOut((DEB_ITRACE,
                     "StgMediumStreamHandler16 failed on seek %lx\n",hresult));
        goto exitRtn;
    }

    //
    // To copy the entire stream, specify the maximum size possible.
    //
    uli.LowPart = -1;
    uli.HighPart = -1;
    hresult = pstmFrom->CopyTo(pstmTo,uli,NULL,NULL);
    if (hresult != NOERROR)
    {
       thkDebugOut((DEB_ITRACE,
                     "StgMediumStreamHandler16 failed CopyTo %lx\n",hresult));
        goto exitRtn;
    }

exitRtn:
    //
    // In all cases, it is proper to release the pstmFrom, since we didn't
    // want it on the 32-bit side at all.
    //

    ul = pstmFrom->Release();


    if (ul != 0)
    {
       //
       // Whoops, we expected this stream pointer to go to zero. We can
       // only print a message, then let it leak.
       //
       thkDebugOut((DEB_ITRACE,
            "StgMediumStreamHandler16() Stream not released. ref=%lx\n",ul));
    }

    thkDebugOut((DEB_ITRACE,
    "*** StgMediumStreamHandler16(pstmFrom=%p,pstmTo=%p) returns %lx\n",
         pstmFrom,pstmTo,hresult));

    return((DWORD)hresult);

}

//+---------------------------------------------------------------------------
//
//  Function:   TouchPointer16, public
//
//  Synopsis:   Touches a byte at the given pointer's address to
//              bring in not-present segments
//
//  Arguments:  [pb] - Pointer
//
//  History:    25-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL TouchPointer16(BYTE FAR *pb)
{
    BYTE b = 0;

    if (pb)
    {
        b = *pb;
    }

    return b;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetOwnerPublic16, public
//
//  Synopsis:   Sets a given 16-bit memory handle to be owned by nobody
//              (everybody)
//
//  Arguments:  [hmem] - 16-bit memory handle
//
//  History:    13-Jul-94       BobDay      Created
//
//----------------------------------------------------------------------------
extern "C" void FAR PASCAL KERNEL_SetOwner( WORD hMem16, WORD wOwner );

DWORD __loadds FAR PASCAL SetOwnerPublic16(DWORD hmem)
{
    KERNEL_SetOwner( (WORD)hmem, (WORD)-1 );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   WinExec16, public
//
//  Synopsis:   Routine to run an application on behalf of ole32.dll
//
//  Arguments:  [lpwes] - WinExec16 struct full of needed goodies
//
//  Returns:
//
//  History:    27-Jul-94   AlexT   Created
//
//----------------------------------------------------------------------------

ULONG __loadds FAR PASCAL WinExec16( LPWINEXEC16STRUCT lpwes )
{
    ULONG ulResult;

    thkDebugOut((DEB_ITRACE, "WinExec16(%s, %d)\n",
                 lpwes->vpCommandLine, lpwes->vusShow));

    ulResult = (ULONG) WinExec((LPSTR)lpwes->vpCommandLine,
                               (UINT)lpwes->vusShow);
    thkDebugOut((DEB_ITRACE, "WinExec returned %ld\n", ulResult));

    return ulResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertHr1632, public
//
//  Synopsis:   Converts a 16-bit HRESULT into a 32-bit HRESULT
//
//  Arguments:  [hr] - 16-bit HRESULT
//
//  Returns:    Appropriate status code
//
//  History:    26-Sep-94       DrewB   Created
//
//  Notes:      Delegates to 32-bit functions
//
//----------------------------------------------------------------------------

STDAPI ConvertHr1632(HRESULT hr)
{
    return (HRESULT)CallProcIn32( (DWORD)hr, 0, 0,
                                 pfnConvertHr1632, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertHr3216, public
//
//  Synopsis:   Converts a 32-bit HRESULT into a 16-bit HRESULT
//
//  Arguments:  [hr] - 32-bit HRESULT
//
//  Returns:    Appropriate status code
//
//  History:    26-Sep-94       DrewB   Created
//
//  Notes:      Delegates to 32-bit functions
//
//----------------------------------------------------------------------------

STDAPI ConvertHr3216(HRESULT hr)
{
    return (HRESULT)CallProcIn32( (DWORD)hr, 0, 0,
                                 pfnConvertHr3216, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCallProc32, public
//
//  Synopsis:   Wrapper for CallProc32W which switches to a bigger stack
//
//  Arguments:  [dw1] - argumensts similar to CallProc32W
//              [dw2]
//              [dw3]
//              [pfn32]
//              [dwPtrTranslate]
//              [dwArgCount]
//
//  Returns:    32-bit call result
//
//  History:    5-Dec-94       JohannP Created
//
//  Note:       this will be enabled as soon as I get the CallProc32WFix from
//              Win95
//----------------------------------------------------------------------------
#ifdef _STACKSWITCHON16_
DWORD  FAR PASCAL SSCallProc32(DWORD dw1, DWORD dw2, DWORD dw3,
                              LPVOID pfn32, DWORD dwPtrTranslate,
                              DWORD dwArgCount)
{
    DWORD dwRet = 0;
    // switch to the 32 bit stack
    //
    // return  SSCall(24,SSF_BigStack, (LPVOID)CallProc32W, dw1, dw2, dw3, pfn32, dwPtrTranslate, dwArgCount);
    thkDebugOut((DEB_ERROR, "SSCallProc32(dwArgCount:%x, dwPtrTranslate:%x, pfn32:%x, dw3:%x, dw2:%x, dw1:%x)\n",
                                dwArgCount, dwPtrTranslate, pfn32, dw3, dw2, dw1));
#if DBG == 1
    if (fSSOn)
    {
        dwRet = SSCall(24,SSF_BigStack, (LPVOID)CallProc32WFix, dwArgCount, dwPtrTranslate, pfn32, dw3, dw2, dw1);
    }
    else
#endif // DBG==1
    {
        dwRet = CallProc32W(dw1, dw2, dw3, pfn32, dwPtrTranslate, dwArgCount);
    }

    return dwRet;
}
#endif // _STACKSWITCHON16_

//+-------------------------------------------------------------------------
//
//  Function:   AddAppCompatFlag
//
//  Synopsis:   calls into olethk32 to add an app compability flag.
//
//  Effects:
//
//  Arguments:  [dwFlag]        -- the flag to add
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Mar-95 alexgo    author
//
//  Notes:      this function is exported so that ole2.dll can also call it
//
//--------------------------------------------------------------------------

STDAPI_(void) AddAppCompatFlag( DWORD dwFlag )
{
    CallProcIn32( (DWORD)dwFlag, 0, 0,
                                 pfnThkAddAppCompatFlag, 0, CP32_NARGS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\comlocal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       COMLOCAL.CXX    (16 bit target)
//
//  Contents:   CompObj APIs
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>

#include "comlocal.hxx"
#include "map_htsk.h"
#include "etask.hxx"

#include "call32.hxx"
#include "apilist.hxx"

UINT v_pidHighWord = 1;                         // incremented each time used
IMalloc FAR* v_pMallocShared = NULL; // is not addrefed

// Note: bug 3698
// MsPub is not calling CoInitialize befor calling OpenStorage to
// preview templates. This pointer has an addref!
// When this pointer is not NULL CoGetMalloc was called prior to CoInitialize
// The pointer is transfered as soon as CoInitialize is called by any task.
IMalloc FAR* v_pMallocPreShared = NULL;
BOOL SetupSharedAllocator(Etask FAR& etask);


//+---------------------------------------------------------------------------
//
//  Function:   TaskAlloc, private
//
//  Synopsis:   Allocates task memory
//
//  Arguments:  [cb] - Number of bytes to allocate
//
//  Returns:    Pointer to memory or NULL
//
//  History:    03-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

LPVOID __loadds FAR PASCAL TaskAlloc(ULONG cb)
{
    HRESULT     hr;
    LPMALLOC    lpMalloc = NULL;
    LPVOID      lpv;

    hr = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
    if (FAILED(GetScode(hr)) )
    {
        lpv = NULL;
    }
    else
    {
        thkAssert(lpMalloc != NULL && "CoGetMalloc pMalloce is NULL\n");
        lpv = lpMalloc->Alloc(cb);
        lpMalloc->Release();
    }

    return lpv;
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskFree, private
//
//  Synopsis:   Free task memory
//
//  Arguments:  [pv] - Memory
//
//  History:    03-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

void __loadds FAR PASCAL TaskFree(LPVOID pv)
{
    HRESULT     hr;
    LPMALLOC    lpMalloc;

    hr = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
    if (SUCCEEDED(GetScode(hr)))
    {
        lpMalloc->Free(pv);
        lpMalloc->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     SetupSharedAllocator
//
//  Synopsis:   Allocats the shared allocator and
//              initializes the etask shared allocator
//
//  Arguments:  [etask] --
//
//  Returns:
//
//  History:    2-03-95   JohannP (Johann Posch)   Created
//
//  Notes:      call by CoInitialize and DllEntryPoint
//
//----------------------------------------------------------------------------
BOOL SetupSharedAllocator(Etask FAR& etask)
{
    // we must ensure we have a shared allocator now since that is where the
    // etask map wiil be stored; if another process already created it, use it;
    // this is so we always use the same shared pool of memory for all
    // processes (so the DidAlloc method returns 1 for the same call from
    // different process); the pointer refers to shared memory within
    // the blocks managed by the IMalloc implementation and the
    // vtable is always valid on Windows; the global pointer carries
    // no ref count on its own; changes might be requires on
    // other platforms.
    if (v_pMallocPreShared != NULL)
    {
        // Note: fix for bug 3698;l MsPub not calling CoInitialize
        // transfer addref from preshared to task entry
        etask.m_pMallocShared = v_pMallocPreShared;
        v_pMallocShared = v_pMallocPreShared;
        v_pMallocPreShared = NULL;
    }
    else if (v_pMallocShared != NULL)
    {
        (etask.m_pMallocShared = v_pMallocShared)->AddRef();
    }
    else
    {
        // sets pMalloc to NULL on error
        CoCreateStandardMalloc(MEMCTX_SHARED, &etask.m_pMallocShared);
        v_pMallocShared = etask.m_pMallocShared;
        thkAssert(v_pMallocShared != NULL && "SetupSharedAllocator failed!");
    }
    return (v_pMallocShared != NULL) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              3-08-94   BobDay    Added code from \\ole\slm\...\compobj.cpp
//
//  Notes:
//
//----------------------------------------------------------------------------
// initialize compobj; errors: S_FALSE, E_OUTOFMEMORY
STDAPI  CoInitialize(IMalloc FAR* pMalloc)
{
    LPMALLOC pmlNull = NULL;
    HRESULT hresult;
    HTASK htask;
    Etask etask;

    thkDebugOut((DEB_ITRACE, "CoInitialize\n"));
    thkDebugOut((DEB_APIS16, "CoInitilaize called on Process (%X) \n", GetCurrentProcess()));

    // if already init, bump count and return S_FALSE
    if (   IsEtaskInit(htask, etask)
        && IsValidInterface((etask.m_pMalloc)) )
    {
        if ( etask.m_inits != ETASK_FAKE_INIT )
        {
            etask.m_inits++;
            thkVerify(SetEtask(htask, etask));
            return ResultFromScode(S_FALSE);
        }

        //
        // CoInitialize has been called after we've done a fake call for them
        // we can just take over their allocator and get rid of our fake one.
        //

        if ( pMalloc != NULL )
        {
            etask.m_pMalloc->Release();   // Get rid of the old task allocator
            etask.m_pMalloc = pMalloc;
            etask.m_pMalloc->AddRef();
        }
        else
        {
            //
            // It would be nice if we could assert that the fake task
            // allocator was a default task allocator.  i.e. no operation
            // were really needed!
            //
        }

        //
        // "We need to have a way to clean up any fake calls to
        // CoInitialize.  Should the application go away after using one of
        // the apis that caused us to do a fake CoInitialize in the first
        // place, and should the application exit without really making a
        // call to CoInitialize eventually, then we wouldn't know enough to
        // clean up...  I think this is ok for now.  Most apps do call
        // CoInitialize eventually."
        //
        etask.m_inits = 1;

        thkAssert(etask.m_pMalloc != NULL); // now have task allocator in all cases
        thkVerify(SetEtask(htask, etask));
        return ResultFromScode(S_OK);
    }

    // set/create task malloc
    if (pMalloc != NULL)
    {
        VDATEIFACE( pMalloc );
        (etask.m_pMalloc = pMalloc)->AddRef();
    }
    else
    {
        if ((hresult = CoCreateStandardMalloc(MEMCTX_TASK,
                                              &etask.m_pMalloc)) != NOERROR)
            return hresult;
    }
    thkAssert(etask.m_pMalloc != NULL); // now have task allocator in all cases


    // set up the shared allocator
    if (   etask.m_pMallocShared == NULL
        && SetupSharedAllocator(etask) == FALSE)
    {
        etask.m_pMalloc->Release();        // was created or AddRef'd above
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // now have shared allocator in all cases
    thkAssert(etask.m_pMallocShared != NULL);

    // init remaining entries and add entry to table for this app/task pair;
    // leave maps null for now (they are allocated on demand)
    etask.m_pMallocSBlock = NULL;
    etask.m_pMallocPrivate = NULL;
    etask.m_pid = MAKELONG(GetCurrentProcess(),v_pidHighWord++);
    etask.m_inits = 1;
    etask.m_oleinits = 0;
    etask.m_reserved = 0;
    etask.m_pDlls = NULL;
    etask.m_pMapToServerCO = NULL;
    etask.m_pMapToHandlerCO = NULL;
    etask.m_pArraySH = NULL;
    etask.m_pCThrd = NULL;
    etask.m_hwndClip = NULL;
    etask.m_hwndDde = NULL;
    etask.m_punkState = NULL;

    if (!SetEtask(htask, etask))
    {
        ReleaseEtask(NULL, etask);
        thkAssert(0 && "CompObj: CoInitialize SetEtask failed.");
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Initialize the thunk manager for this apartment.
    if (SUCCEEDED(hresult = CallThkMgrInitialize()))
    {
        //
        // Now transition into 32-bit world to give it a chance for
        // initialization at this time.
        //
        // Never pass the 16-bit allocator on to 32-bits
        pMalloc = NULL;
        hresult = (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoInitialize),
                                           PASCAL_STACK_PTR(pMalloc) );
    }

    if (FAILED(GetScode(hresult)))
    {
        ReleaseEtask(htask, etask);
    }

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoUninitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              10-Mar-94   BobDay  Copied & Merged with compobj.cpp 16-bit
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(void) CoUninitialize(void)
{
    HTASK htask;
    Etask etask;

    thkDebugOut((DEB_ITRACE, "CoUninitialize\n"));
    thkDebugOut((DEB_APIS16, "CoUninitilaize called on Process (%X) \n", GetCurrentProcess()));

    if (!IsEtaskInit(htask, etask))
        return;

    // if not last uninit, just decrement count and return.
    if (etask.m_inits != 1)
    {
        //
        // If a fake init, then just ignore as if we haven't ever init'd
        //
        if ( etask.m_inits == ETASK_FAKE_INIT )
        {
            //
            // Some slimy app doesn't call CoInitialize but does eventually
            // call CoUninitialize. Lets find them if they do!
            //
            thkAssert(FALSE &&
                      "CoUninitialize called after fake CoInitialize\n");
        }
        else
        {
            etask.m_inits--;
            thkVerify(SetEtask(htask, etask));
        }
        return ;
    }

    // Some applications pass on module handle of loaded dlls.
    // As a result LibMain and WEP is not called in the same process.
    // To prevent premature unloading of OleThk32.dll call
    // SetReleaseDLL(FALSE)

    SetReleaseDLL(FALSE);

    //
    // Now transition into 32-bit world to give it a chance for
    // initialization at this time.
    //
    CallObjectInWOW(THK_API_METHOD(THK_API_CoUninitialize), NULL );

    // Reset dll unloading - see above
    SetReleaseDLL(TRUE);

    CoFreeAllLibraries();

    //
    // We do not uninitialize the thunk manager at this point. The app may attempt
    // to call additional API's after CoUninitialize. For example, Lotus 1-2-3
    // is known to do this, as is Publisher. The thunk manager will clean up
    // as part of its thread detach.
    //

    // the last thing is to remove the allocator and delete the etask for us;
    // must lookup again in case contents changed.

    if (LookupEtask(htask, etask))
        ReleaseEtask(htask, etask);

    thkDebugOut((DEB_APIS16, "CoUninitilaize on Process (%X) done.\n", GetCurrentProcess()));
    thkDebugOut((DEB_ITRACE, "CoUninitialize exit\n"));

    // Note: some apps check the return value if the void function CoUninitialize
    //       and they fail if it is not NULL like WinOffice Setup 4.3
    //       Please don't take it out.
    _asm mov ax,0;
    _asm mov dx,0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetMalloc, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [dwMemContext] --
//      [ppMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              10-Mar-94   BobDay  Copied & Merged with compobj.cpp 16-bit
//
//  Notes:
//
//----------------------------------------------------------------------------
// return pMalloc for the current task; errors: E_INVALIDARG,
// CO_E_NOTINITIALIZED, E_OUTOFMEMORY (not for task or shared allocators)
STDAPI  CoGetMalloc(DWORD dwContext, IMalloc FAR* FAR* ppMalloc)
{
    Etask etask;
    HTASK htask;

    thkDebugOut((DEB_ITRACE, " CoGetMalloc\n"));

    VDATEPTROUT( ppMalloc, IMalloc FAR* );
    // NOTE: we set *ppMalloc to NULL only in the error cases below

    // MOre work here!
    // need this for the bootstrap case
    if (dwContext == MEMCTX_SHARED)
    {
        if (v_pMallocShared != NULL)
        {
            *ppMalloc = v_pMallocShared;
            goto Exit;
        }
        // pMallocShared is NULL -- CoInitialize was not called yet.
        if (v_pMallocPreShared == NULL)
        {
            CoCreateStandardMalloc(MEMCTX_SHARED, &v_pMallocPreShared);
            if (v_pMallocPreShared != NULL)
            {
                *ppMalloc = v_pMallocPreShared;
                goto Exit;
            }
            else
            {
                *ppMalloc = NULL;
                return ResultFromScode(CO_E_NOTINITIALIZED);
            }
        }
        else
        {
            *ppMalloc = v_pMallocPreShared;
            goto Exit;
        }
    }

    //
    //  Clip Art Gallery will call pStream->Stat before calling CoInitialize.
    //  This causes the thunk logic to allocation 16bit memory which will
    //  fail at this point.  The below code to auto-initialize should this
    //  happen.  (Really just a hack for Clip Art Gallery).
    //
    if (   !IsEtaskInit(htask, etask)
        || !IsValidInterface((etask.m_pMalloc)) )
    {
        if (FAILED(CoInitialize(NULL)))
        {
            *ppMalloc = NULL;
            return ResultFromScode(CO_E_NOTINITIALIZED);
        }

        thkVerify(LookupEtask( htask, etask ));
        etask.m_inits = ETASK_FAKE_INIT;
        thkVerify(SetEtask(htask, etask));
    }

    // shared always available if initialized; no need to handle here
    thkAssert(dwContext != MEMCTX_SHARED);

    if (dwContext == MEMCTX_TASK)
    {
        thkAssert(etask.m_pMalloc != NULL);
        *ppMalloc = etask.m_pMalloc;
    }
    else
    {
        // invalid context
        thkAssert(!"Unknown memctx in CoGetMalloc");
        *ppMalloc = NULL;
        return ResultFromScode(E_INVALIDARG);
    }

 Exit:  // have non-null *ppMalloc
    thkAssert(*ppMalloc != NULL);
    (*ppMalloc)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetState, Local
//
//  Synopsis:   Retrieves task-specific state
//
//  Arguments:  [ppunk] - IUnknown pointer to fill in
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DrewB   Created
//
//  Notes:      Private API for OLE automation
//
//----------------------------------------------------------------------------

STDAPI CoGetState(IUnknown FAR * FAR *ppunk)
{
    Etask etask;
    HTASK htask;

    thkDebugOut((DEB_APIS16, "CoGetState called\n"));
    if (IsBadWritePtr(ppunk, sizeof(IUnknown *)))
    {
        thkDebugOut((DEB_APIS16, "CoGetState failed\n"));
        return ResultFromScode(E_INVALIDARG);
    }

    if (!LookupEtask(htask, etask) || etask.m_punkState == NULL )
    {
        *ppunk = NULL;
        thkDebugOut((DEB_APIS16, "CoGetState failed\n"));
        return ResultFromScode(S_FALSE);
    }

    if ( !IsValidInterface((etask.m_punkState)) )
    {
        *ppunk = NULL;
        etask.m_punkState = NULL;
        thkDebugOut((DEB_APIS16, "CoGetState failed (invalid interface)\n"));
        return ResultFromScode(S_FALSE);
    }


    *ppunk = etask.m_punkState;
    etask.m_punkState->AddRef();

    thkDebugOut((DEB_APIS16, "CoGetState done %p\n", *ppunk));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoSetState, Local
//
//  Synopsis:   Sets task-specific state
//
//  Arguments:  [punk] - State to set
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DrewB   Created
//
//  Notes:      Private API for OLE automation
//
//----------------------------------------------------------------------------

STDAPI CoSetState(IUnknown FAR *punk)
{
    Etask etask;
    HTASK htask;
    IUnknown FAR *punkStateOld;

    thkDebugOut((DEB_APIS16, "CoSetState called %p\n", punk));

    if (punk != NULL && !IsValidInterface(punk))
    {
        thkDebugOut((DEB_APIS16, "CoSetState called %p failed\n", punk));
        return ResultFromScode(E_INVALIDARG);
    }

    if (!IsEtaskInit(htask, etask))
    {
        thkDebugOut((DEB_APIS16, "CoSetState called %p failed\n", punk));
        return ResultFromScode(S_FALSE);
    }

    if (punk != NULL)
    {
        punk->AddRef();
    }

    punkStateOld = etask.m_punkState;
    etask.m_punkState = punk;

    thkVerify(SetEtask(htask, etask));

    if (punkStateOld != NULL && IsValidInterface(punkStateOld))
    {
        punkStateOld->Release();
    }

    thkDebugOut((DEB_APIS16, "CoSetState called %p done\n", punk));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetCurrentProcess, Local
//
//----------------------------------------------------------------------------
// returns a unique value for the current task; this routine is
// necessary because htask values from Window get reused periodically.
STDAPI_(DWORD)  CoGetCurrentProcess(void)
{
    HTASK htask;
    Etask etask;

    thkDebugOut((DEB_ITRACE, " CoGetCurrentProcess\n"));

    if (!IsEtaskInit(htask, etask))
        return 0;

    return etask.m_pid;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoBuildVersion, Local
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CoBuildVersion(VOID)
{
    thkDebugOut((DEB_ITRACE, " CoBuildVersion\n"));

    // We must return 23 as our major version number to remain
    // compatible with shipped OLE 2.01
    // OLE 2.01 shipped with minor version 640
    // We return a number slightly higher to differentiate
    // our product while indicating compatibility
    return MAKELONG(700, 23);
}

//+---------------------------------------------------------------------------
//
//  Function:   CoMarshalHresult, Local
//
//  History:    Taken straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult)
{
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CoMarshalHresult\n"));

    if (!IsValidInterface(pstm))
    {
        hr = ResultFromScode(E_INVALIDARG);
    }
    else
    {
        SCODE sc;
        ULONG cb;

        sc = GetScode(hresult);
        hr = pstm->Write(&sc, sizeof(sc), &cb);
        if (SUCCEEDED(GetScode(hr)) && cb != sizeof(sc))
        {
            hr = ResultFromScode(STG_E_WRITEFAULT);
        }
    }
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   CoUnmarshalHresult, Local
//
//  History:    Taken straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult)
{
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CoUnmarshalHresult\n"));

    if (!IsValidPtrOut(phresult, sizeof(HRESULT)))
    {
        hr = ResultFromScode(E_INVALIDARG);
    }
    else
    {
        *phresult = 0;

        if (!IsValidInterface(pstm))
        {
            hr = ResultFromScode(E_INVALIDARG);
        }
        else
        {
            SCODE sc;
            ULONG cb;

            hr = pstm->Read(&sc, sizeof(sc), &cb);
            if (SUCCEEDED(GetScode(hr)))
            {
                if (cb != sizeof(sc))
                {
                    hr = ResultFromScode(STG_E_READFAULT);
                }
                else
                {
                    *phresult = ResultFromScode(sc);
                }
            }
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEqualGUID, Local
//
//  History:    Taken straight from OLE2 sources
//
//----------------------------------------------------------------------------
#pragma intrinsic(_fmemcmp)
STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    //thkDebugOut((DEB_ITRACE, "IsEqualGUID\n"));

    return !_fmemcmp(&rguid1, &rguid2, sizeof(GUID));
}
#pragma function(_fmemcmp)

#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

//+---------------------------------------------------------------------------
//
//  Function:   HexStringToDword, private
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

static BOOL HexStringToDword(LPCSTR FAR& lpsz, DWORD FAR& Value, int cDigits,
                             char chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
        {
            Value = (Value << 4) + *lpsz - '0';
        }
        else if (*lpsz >= 'A' && *lpsz <= 'F')
        {
            Value = (Value << 4) + *lpsz - 'A' + 10;
        }
        else if (*lpsz >= 'a' && *lpsz <= 'f')
        {
            Value = (Value << 4) + *lpsz - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }
    }
    if (chDelim != 0)
    {
        return *lpsz++ == chDelim;
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GUIDFromString, private
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) GUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz++ != '{')
        return FALSE;

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))
        return FALSE;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
        return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '}'))
        return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromCLSID, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

#define CLSIDSTR_MAX (GUIDSTR_MAX)

STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz)
{
    SCODE sc;
    char *psz;

    thkDebugOut((DEB_ITRACE, "StringFromCLSID\n"));

    psz = NULL;
    do
    {
        if (!IsValidPtrOut(lplpsz, sizeof(LPSTR)))
        {
            sc = E_INVALIDARG;
            break;
        }
        *lplpsz = NULL;

        if (!IsValidPtrIn(&rclsid, sizeof(CLSID)))
        {
            sc = E_INVALIDARG;
            break;
        }

        psz = (char *)TaskAlloc(CLSIDSTR_MAX);
        if (psz == NULL)
        {
            sc = E_OUTOFMEMORY;
            break;
        }

        if (StringFromGUID2(rclsid, psz, CLSIDSTR_MAX) == 0)
        {
            sc = E_INVALIDARG;
            TaskFree(psz);
            break;
        }

   *lplpsz = psz;
        sc = S_OK;
    } while (FALSE);

    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromIID, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz)
{
    SCODE sc;
    char *psz;

    thkDebugOut((DEB_ITRACE, "StringFromIID\n"));

    do
    {
        if (!IsValidPtrOut(lplpsz, sizeof(LPSTR)))
        {
            sc = E_INVALIDARG;
            break;
        }
        *lplpsz = NULL;

        if (!IsValidPtrIn(&rclsid, sizeof(IID)))
        {
            sc = E_INVALIDARG;
            break;
        }

        psz = (char *)TaskAlloc(GUIDSTR_MAX);
        if (psz == NULL)
        {
            sc = E_OUTOFMEMORY;
            break;
        }

        if (StringFromGUID2(rclsid, psz, GUIDSTR_MAX) == 0)
        {
            sc = E_INVALIDARG;
            TaskFree(psz);
            break;
        }

   *lplpsz = psz;
        sc = S_OK;
    } while (FALSE);

    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   IIDFromString, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid)
{
    SCODE sc;

    thkDebugOut((DEB_ITRACE, "IIDFromString\n"));

    sc = S_OK;
    if (!IsValidPtrOut(lpiid, sizeof(IID)))
    {
        sc = E_INVALIDARG;
    }
    else if (lpsz == NULL)
    {
        *lpiid = IID_NULL;
    }
    else if (!IsValidPtrIn(lpsz, sizeof(LPSTR)))
    {
        sc = E_INVALIDARG;
    }
    else if (!GUIDFromString(lpsz, lpiid))
    {
        sc = CO_E_IIDSTRING;
    }

    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromGUID2, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPSTR lpsz, int cbMax)
{
    thkDebugOut((DEB_ITRACE, "StringFromGUID2\n"));

    if (cbMax < GUIDSTR_MAX)
    {
        return 0;
    }    

    wsprintf(lpsz, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
             rguid.Data1, rguid.Data2, rguid.Data3,
             rguid.Data4[0], rguid.Data4[1],
             rguid.Data4[2], rguid.Data4[3],
             rguid.Data4[4], rguid.Data4[5],
             rguid.Data4[6], rguid.Data4[7]);

    return GUIDSTR_MAX;
}

// The following two APIs are now macros but must still be exported
// so use PASCAL-form names to avoid problems with the macros

//+---------------------------------------------------------------------------
//
//  Function:   GETSCODE, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI_(SCODE) GETSCODE(HRESULT hr)
{
    return GetScode(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   RESULTFROMSCODE, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI RESULTFROMSCODE(SCODE sc)
{
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   PropagateResult, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew)
{
    thkDebugOut((DEB_ITRACE, "PropagateResult\n"));

    return (HRESULT)((scNew & 0x800FFFFF) | ((DWORD)hrPrev & 0x7FF00000)
                     + 0x100000);
}

//+---------------------------------------------------------------------------
//
//  Function:   FnAssert, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

#if DBG == 1
static char lpBuffer[512];
static char lpLocBuffer[256];
#endif

STDAPI FnAssert( LPSTR lpstrExpr,
                 LPSTR lpstrMsg,
                 LPSTR lpstrFileName,
                 UINT iLine )
{
#if DBG == 1
    int iResult;

    wsprintf(lpBuffer, "Assertion \"%s\" failed! %s", lpstrExpr, lpstrMsg);
    wsprintf(lpLocBuffer, "File %s, line %d; (A=exit; R=break; I=continue)",
             lpstrFileName, iLine);
    iResult = MessageBox(NULL, lpLocBuffer, lpBuffer,
                         MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);

    if (iResult == IDRETRY)
    {
        DebugBreak();
    }
    else if (iResult == IDABORT)
    {
        CoFreeAllLibraries();
        FatalAppExit(0, "Assertion failure");
    }
#endif
    return NOERROR;
}

//
// NOTE- These APIs are exported by the .DEF file, but are not documented,
// nor is there any code in the 16-bit world to deal with them.  Each of these
// needs to be investigated to determine what we need to do to implement them.
//
// LRPCDISPATCH
// REMCONNECTTOOBJECT
// REMCREATEREMOTEHANDLER
// REMALLOCOID
// LRPCFREEMONITORDATA
// TIMERCALLBACKPROC
// COSETACKSTATE
// COGETCLASSEXT
// LRPCCALL
// LRPCREGISTERMONITOR
// CLSIDFROMOLE1CLASS
// COOPENCLASSKEY
// LRPCGETTHREADWINDOW
// LRPCREVOKEMONITOR
// COHANDLEINCOMINGCALL
// REMGETINFOFORCID
//
// The below stubs probably don't clean up the stack properly either!!!

#define UNDEFINED_DEF_ENTRY(x)  STDAPI x ( void ) \
                                   { return ResultFromScode(E_NOTIMPL); }


UNDEFINED_DEF_ENTRY( LRPCDISPATCH            )
UNDEFINED_DEF_ENTRY( REMCONNECTTOOBJECT      )
UNDEFINED_DEF_ENTRY( REMCREATEREMOTEHANDLER  )
UNDEFINED_DEF_ENTRY( REMALLOCOID             )
UNDEFINED_DEF_ENTRY( LRPCFREEMONITORDATA     )
UNDEFINED_DEF_ENTRY( TIMERCALLBACKPROC       )
UNDEFINED_DEF_ENTRY( COSETACKSTATE           )
UNDEFINED_DEF_ENTRY( COGETCLASSEXT           )
UNDEFINED_DEF_ENTRY( LRPCCALL                )
UNDEFINED_DEF_ENTRY( LRPCREGISTERMONITOR     )
UNDEFINED_DEF_ENTRY( CLSIDFROMOLE1CLASS      )
UNDEFINED_DEF_ENTRY( COOPENCLASSKEY          )
UNDEFINED_DEF_ENTRY( LRPCGETTHREADWINDOW     )
UNDEFINED_DEF_ENTRY( LRPCREVOKEMONITOR       )
UNDEFINED_DEF_ENTRY( COHANDLEINCOMINGCALL    )
UNDEFINED_DEF_ENTRY( REMGETINFOFORCID        )
UNDEFINED_DEF_ENTRY( OLE1CLASSFROMCLSID2     )
UNDEFINED_DEF_ENTRY( REMLOOKUPSHUNK          )
UNDEFINED_DEF_ENTRY( REMFREEOID              )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\compobj.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ComAPIs.cxx     (16 bit target)
//
//  Contents:   CompObj APIs
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop
#include <ole2sp.h>
#include <olecoll.h>
#include <map_kv.h>
#include <stdlib.h>

#include "map_htsk.h"
#include "etask.hxx"
#include "call32.hxx"
#include "apilist.hxx"

// Opmodes should be removed
// They don't seem to be necessary any more

DECLARE_INFOLEVEL(thk1);
DECLARE_INFOLEVEL(Stack1);

CMapHandleEtask NEAR v_mapToEtask(MEMCTX_SHARED);

//+---------------------------------------------------------------------------
//
//  Function:   LibMain, public
//
//  Synopsis:   DLL initialization function
//
//  Arguments:  [hinst] - Instance handle
//              [wDataSeg] - Current DS
//              [cbHeapSize] - Heap size for the DLL
//              [lpszCmdLine] - Command line information
//
//  Returns:    One for success, zero for failure
//
//  History:    21-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static char achInfoLevel[32];
#endif

extern "C" int CALLBACK LibMain(HINSTANCE hinst,
                                WORD wDataSeg,
                                WORD cbHeapSize,
                                LPSTR lpszCmdLine)
{

#if DBG == 1
    if (GetProfileString("olethk32", "InfoLevel", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }
#endif

    thkDebugOut((DEB_DLLS16, "CompObj16: LibMain called on Process (%X) \n", GetCurrentProcess() ));

    if (!Call32Initialize())
    {
        return 0;
    }

#ifdef _DEBUG
        v_mapToEtask.AssertValid();
#endif

        UNREFERENCED(cbHeapSize);

    // Leave our DS unlocked when we're not running
    UnlockData( 0 );

#if defined(_CHIC_INIT_IN_LIBMAIN_)
    if (SetupSharedAllocator(getask) == FALSE)
    {
	return FALSE;
    }
#endif // _CHIC_INIT_IN_LIBMAIN_

    thkDebugOut((DEB_DLLS16, "CompObj16: LibMain called on Process (%X) Exitype (%ld)\n", GetCurrentProcess() ));
	
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   WEP, public
//
//  Synopsis:   Windows Exit Point routine, for receiving DLL unload
//              notification
//
//  Arguments:  [nExitType] - Type of exit occurring
//
//  Returns:    One for success, zero for failure
//
//  History:    21-Feb-94       DrewB   Created
//
//  Note:       Does nothing on WIN95. Call32Unitialize is called in
//		DllEntryPoint when load count goes to zero.
//
//----------------------------------------------------------------------------

extern "C" int CALLBACK WEP(int nExitType)
{
    thkDebugOut((DEB_DLLS16, "CompObj16: WEP called on Process (%X) Exitype (%ld)\n", GetCurrentProcess(),nExitType));

    HTASK htask;
    Etask etask;
    if (LookupEtask(htask, etask))
    {
	//
	// There is an etask. Check to see if the etask for this task has
	// its init count set to ETASK_FAKE_INIT. If it does, we cheated
	// and called CoInitialize on the processes behalf, but it never
	// called CoUninitialize(). Some apps that only make storage calls
	// demonstrate this behaviour. If it is ETASK_FAKE_INIT, then we
	// are going to call CoUninitialize on the apps behalf.
	//
	if (etask.m_inits == ETASK_FAKE_INIT)
	{
	    //
	    // We are going to set the m_inits == 1, since we called it
	    // once. Then we are going to call our very own CoUninitialize()
	    // to let it handle the rest of the cleanup.
	    //
	    etask.m_inits = 1;
	    thkVerify(SetEtask(htask, etask));
	    CoUninitialize();
	}
    }

    //
    // Now uninit the thunk layer
    //
    Call32Uninitialize();

    thkDebugOut((DEB_DLLS16, "CompObj16: WEP called on Process (%X) done\n", GetCurrentProcess()));
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\comdthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Comdthk.c   (16 bit target)
//
//  Contents:   CompObj Directly Thunked APIs
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//              07-Mar-94 BobDay     Moved into COMTHUNK.C from COMAPI.CXX
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

STDAPI_(BOOL) GUIDFromString(LPCSTR lpsz, LPGUID pguid);

//+---------------------------------------------------------------------------
//
//  Function:   Straight thunk routines
//
//  Synopsis:   The following routines do not need to do any special
//              processing on the 16-bit side so they thunk straight
//              through
//
//  History:    18-Feb-94       JohannP Created
//
//  Notes:      "Review to ensure these don't have to do any work"
//              15-Feb-2000  I'm pretty sure they don't.  JohnDoty
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   CLSIDFromString, Remote
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid)
{
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CLSIDFromString\n"));

    //
    //	The 16-bit OLE2 application "Family Tree Maker" always passes a bad
    //	string to CLSIDFromString.  We need to make sure we fail in the exact
    //	same way with the interop layer.  This will also provide a speed
    //	improvement since we only need to remote to the 32bit version of
    //	CLSIDFromString when the string provided does not start with '{'.
    //
    if (lpsz[0] == '{')
	return GUIDFromString(lpsz, pclsid)
		? NOERROR : ResultFromScode(CO_E_CLASSSTRING);

    // Note: Corel calls this function prior to calling
    //       CoInitialize so use CheckInit

    return (HRESULT)CallObjectInWOWCheckInit(THK_API_METHOD(THK_API_CLSIDFromString),
                                             PASCAL_STACK_PTR(lpsz));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [dwClsContext] --
//      [pvReserved] --
//      [riid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                        REFIID riid, LPVOID FAR* ppv)
{
    thkDebugOut((DEB_ITRACE, " CoGetClassObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoGetClassObject),
                                    PASCAL_STACK_PTR(rclsid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [pUnk] --
//      [dwClsContext] --
//      [flags] --
//      [lpdwRegister] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                             DWORD dwClsContext, DWORD flags,
                             LPDWORD lpdwRegister)
{
    thkDebugOut((DEB_ITRACE, " CoRegisterClassObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoRegisterClassObject),
                                    PASCAL_STACK_PTR(rclsid));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoRevokeClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [dwRegister] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoRevokeClassObject(DWORD dwRegister)
{
    thkDebugOut((DEB_ITRACE, " CoRevokeClassObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoRevokeClassObject),
                                    PASCAL_STACK_PTR(dwRegister) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoMarshalInterface, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [riid] --
//      [pUnk] --
//      [dwDestContext] --
//      [pvDestContext] --
//      [mshlflags] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                          DWORD dwDestContext, LPVOID pvDestContext,
                          DWORD mshlflags)
{
    thkDebugOut((DEB_ITRACE, " CoMarshalInterface\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoMarshalInterface),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoUnmarshalInterface, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [riid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv)
{
    thkDebugOut((DEB_ITRACE, "CoUnmarshalInterface\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoUnmarshalInterface),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoReleaseMarshalData, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoReleaseMarshalData(LPSTREAM pStm)
{
    thkDebugOut((DEB_ITRACE, "CoReleaseMarshalData\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoReleaseMarshalData),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoDisconnectObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnk] --
//      [dwReserved] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved)
{
    thkDebugOut((DEB_ITRACE, "CoDisconnectObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoDisconnectObject),
                                    PASCAL_STACK_PTR(pUnk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoLockObjectExternal, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnk] --
//      [fLock] --
//      [fLastUnlockReleases] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock,
                            BOOL fLastUnlockReleases)
{
    thkDebugOut((DEB_ITRACE, "CoLockObjectExternal\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoLockObjectExternal),
                                    PASCAL_STACK_PTR(pUnk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetStandardMarshal, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [riid] --
//      [pUnk] --
//      [dwDestContext] --
//      [pvDestContext] --
//      [mshlflags] --
//      [ppMarshal] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk,
                            DWORD dwDestContext, LPVOID pvDestContext,
                            DWORD mshlflags,
                            LPMARSHAL FAR* ppMarshal)
{
    thkDebugOut((DEB_ITRACE, "CoGetStandardMarshal\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoGetStandardMarshal),
                                    PASCAL_STACK_PTR(riid));
}


//+---------------------------------------------------------------------------
//
//  Function:   CoIsHandlerConnected, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk)
{
    thkDebugOut((DEB_ITRACE, "CoIsHandlerConnected\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoIsHandlerConnected),
                                 PASCAL_STACK_PTR(pUnk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoCreateInstance, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [pUnkOuter] --
//      [dwClsContext] --
//      [riid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                        DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv)
{
    thkDebugOut((DEB_ITRACE, "CoCreateInstance\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoCreateInstance),
                                    PASCAL_STACK_PTR(rclsid) );
}



//+---------------------------------------------------------------------------
//
//  Function:   CoIsOle1Class, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid)
{
    thkDebugOut((DEB_ITRACE, "CoIsOle1Class\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoIsOle1Class),
                                 PASCAL_STACK_PTR(rclsid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ProgIDFromCLSID, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [lplpszProgID] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ProgIDFromCLSID(REFCLSID clsid, LPSTR FAR* lplpszProgID)
{
    thkDebugOut((DEB_ITRACE, "ProgIDFromCLSID\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ProgIDFromCLSID),
                                    PASCAL_STACK_PTR(clsid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CLSIDFromProgID, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszProgID] --
//      [lpclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CLSIDFromProgID(LPCSTR lpszProgID, LPCLSID lpclsid)
{
    thkDebugOut((DEB_ITRACE, "CLSIDFromProgID\n"));

    // Note: Word 6 calls this function prior to calling
    //       CoInitialize so use CheckInit

    return (HRESULT)CallObjectInWOWCheckInit(THK_API_METHOD(THK_API_CLSIDFromProgID),
                                             PASCAL_STACK_PTR(lpszProgID) );
}


//+---------------------------------------------------------------------------
//
//  Function:   CoCreateGuid, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pguid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoCreateGuid(GUID FAR *pguid)
{
    thkDebugOut((DEB_ITRACE, "CoCreateGuid\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoCreateGuid),
                                    PASCAL_STACK_PTR(pguid));
}


//+---------------------------------------------------------------------------
//
//  Function:   CoFileTimeToDosDateTime, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpFileTime] --
//      [lpDosDate] --
//      [lpDosTime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoFileTimeToDosDateTime(FILETIME FAR* lpFileTime,
                                      LPWORD lpDosDate, LPWORD lpDosTime)
{
    thkDebugOut((DEB_ITRACE, "CoFileTimeToDosDateTime\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoFileTimeToDosDateTime),
                                 PASCAL_STACK_PTR(lpFileTime));
}


//+---------------------------------------------------------------------------
//
//  Function:   CoDosDateTimeToFileTime, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [nDosDate] --
//      [nDosTime] --
//      [lpFileTime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoDosDateTimeToFileTime(WORD nDosDate, WORD nDosTime,
                                      FILETIME FAR* lpFileTime)
{
    thkDebugOut((DEB_ITRACE, "CoDosDateTimeToFileTime\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoDosDateTimeToFileTime),
                                 PASCAL_STACK_PTR(nDosDate));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoFileTimeNow, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpFileTime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoFileTimeNow(FILETIME FAR* lpFileTime)
{
    thkDebugOut((DEB_ITRACE, "CoFileTimeNow\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoFileTimeNow),
                                    PASCAL_STACK_PTR(lpFileTime));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterMessageFilter, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpMessageFilter] --
//      [lplpMessageFilter] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoRegisterMessageFilter(LPMESSAGEFILTER lpMessageFilter,
                               LPMESSAGEFILTER FAR* lplpMessageFilter)
{
    thkDebugOut((DEB_ITRACE, "CoRegisterMessageFilter\n"));

    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoRegisterMessageFilter),
                                    PASCAL_STACK_PTR(lpMessageFilter) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetTreatAsClass, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [pClsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew)
{
    thkDebugOut((DEB_ITRACE, "CoGetTreatAsClass\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoGetTreatAsClass),
                                    PASCAL_STACK_PTR(clsidOld) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoTreatAsClass, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [clsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew)
{
    thkDebugOut((DEB_ITRACE, "CoTreatAsClass\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoTreatAsClass),
                                    PASCAL_STACK_PTR(clsidOld) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\dlltable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dlltable.cxx
//
//  Contents:   DLL table management
//
//  History:    16-Mar-94       DrewB   Taken from OLE2 16-bit sources
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2int.h>
#include <taskmap.h>
#include <call32.hxx>
#include <apilist.hxx>

#include "dlltable.h"

// FUTURE: move to some private header file
INTERNAL_(void) ReleaseDemandLoadCO(Etask FAR& etask);

//  Keep only hInst.  Always do LoadLibrary; if hInst already exist
//  do FreeLibrary.  This is because GetModuleHandle(pLibName) doesn't
//  neccessarily return same value as LoadLibrary(pLibName).
//
HINSTANCE  CDlls::GetLibrary(LPSTR pLibName, BOOL fAutoFree)
{
    UINT i, nFree, nOldErrorMode;
    HINSTANCE hInst;

// REVIEW:  The SetErrorMode calls turn of the Windows "File not found"
// message box, assuming that the app will respond to the error code.
// The name of the file that was not found will be lost by the time we
// return to the app, however.  We may want to reconsider this.

   nOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hInst = LoadLibrary(pLibName);
   SetErrorMode(nOldErrorMode);

    if (hInst < HINSTANCE_ERROR)
        return hInst;

    for (nFree = m_size, i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0) {
            if (nFree > i)
                nFree = i;
            continue;
        }

        if (hInst == m_pDlls[i].hInst) {
            m_pDlls[i].refsTotal++;
                if (fAutoFree)
                        m_pDlls[i].refsAuto++;
            FreeLibrary(hInst);
            return hInst;
        }
    }

    if (nFree == m_size) {
        UINT newsize = m_size + 10;
        void FAR* pMem = NULL;
        IMalloc FAR* pMalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pMalloc) == 0) {
                pMem = pMalloc->Realloc(m_pDlls, newsize * sizeof(m_pDlls[0]));
                pMalloc->Release();
        }

        if (pMem == NULL) {
            FreeLibrary(hInst);
            return NULL; // Out of memory
        }

        _fmemset(((char FAR*) pMem) + m_size * sizeof(m_pDlls[0]),0,
                                   (newsize - m_size) * sizeof(m_pDlls[0]));
        *((void FAR* FAR*) &m_pDlls) = pMem;
        m_size = newsize;
    }

    m_pDlls[nFree].hInst = hInst;
    m_pDlls[nFree].refsTotal = 1;
    m_pDlls[nFree].refsAuto = fAutoFree != 0;
   m_pDlls[nFree].lpfnDllCanUnloadNow =
        (LPFNCANUNLOADNOW)IGetProcAddress(hInst, "DllCanUnloadNow");

#ifdef _DEBUG
   // call it now to prevent dlls from using it to indicate they will be
   // unloaded.
   if (m_pDlls[nFree].lpfnDllCanUnloadNow != NULL)
        (void)(*m_pDlls[nFree].lpfnDllCanUnloadNow)();
#endif // _DEBUG

    return hInst;
}



// unload library.
void  CDlls::ReleaseLibrary(HINSTANCE hInst)
{
    UINT i;

    for (i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0)
            continue;

        if (hInst == m_pDlls[i].hInst) {

            if (--m_pDlls[i].refsTotal == 0) {
                        Assert(m_pDlls[i].refsAuto == 0);
                FreeLibrary(m_pDlls[i].hInst);
                m_pDlls[i].hInst = NULL;
                m_pDlls[i].lpfnDllCanUnloadNow = NULL;
            }

            return;
        }
    }
}

void  CDlls::FreeAllLibraries(void)
{
   UINT i;

    for (i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0)
            continue;

        // A dll loaded on behalf of this app hasn't been freed by it
        //
#ifdef _DEBUG
        if (m_pDlls[i].refsTotal != m_pDlls[i].refsAuto) {
                // not all references to this dll are auto load; print message
                char pln[_MAX_PATH];

                if (GetModuleFileName(m_pDlls[i].hInst,pln,_MAX_PATH) == 0)
                        lstrcpy(pln,"<unknown>");
                Puts("WARNING in Uninitialize: Did not free ");
                Puts(pln);
                Puts("\r\n");
        }
#endif
        FreeLibrary(m_pDlls[i].hInst);
    }

    CoMemFree(m_pDlls, MEMCTX_TASK);
    m_size = 0;
    m_pDlls = NULL;
}


// for all dlls, find lpfnDllCanUnloadNow; call it; do it
void  CDlls::FreeUnusedLibraries(void)
{
   static BOOL v_fReadUnloadOption = FALSE;
   static BOOL v_fAllowUnloading = TRUE;
   UINT i;

    for (i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0)
            continue;

        if (m_pDlls[i].refsTotal != m_pDlls[i].refsAuto)
                continue;

        // have an auto-free dll (total refs == auto refs)

        if (m_pDlls[i].lpfnDllCanUnloadNow == NULL)
                continue;

        if (!v_fReadUnloadOption) {
                v_fAllowUnloading = GetProfileInt("windows",
                        "AllowOptimalDllUnload", TRUE);

                v_fReadUnloadOption = TRUE;
        }

        // we want to actually make the call and then check the flag; that
        // way, we ensure that the dlls are exercising their code, but we
        // don't take action on it.
        if ((*m_pDlls[i].lpfnDllCanUnloadNow)() == NOERROR &&
                v_fAllowUnloading) {
                FreeLibrary(m_pDlls[i].hInst);
                m_pDlls[i].refsTotal = NULL;
                m_pDlls[i].refsAuto = NULL;
                m_pDlls[i].hInst = NULL;
                m_pDlls[i].lpfnDllCanUnloadNow = NULL;
        }
    }
}


static INTERNAL_(BOOL)  EnsureDllMap(CDlls FAR* FAR* ppDlls)
{
   HTASK hTask;
   Etask etask;

   if (!LookupEtask(hTask, etask))
        return FALSE;

   // NOTE - The original code used TASK-allocating operator new
   if (etask.m_pDlls == NULL) {
        if ((etask.m_pDlls = new FAR CDlls) == NULL)
                return FALSE;

        SetEtask(hTask, etask);
   }

   *ppDlls = etask.m_pDlls;
   return TRUE;
}


STDAPI_(HINSTANCE)  CoLoadLibrary(LPSTR pLibName, BOOL fAutoFree)
{
   CDlls FAR* pCDlls;

   if (!EnsureDllMap(&pCDlls))
        return NULL;

    return pCDlls->GetLibrary(pLibName, fAutoFree);
}

STDAPI_(void)  CoFreeLibrary(HINSTANCE hInst)
{
    CDlls FAR* pCDlls;

   if (!EnsureDllMap(&pCDlls))
        return;

    pCDlls->ReleaseLibrary(hInst);
}

STDAPI_(void)  CoFreeAllLibraries(void)
{
    thkDebugOut((DEB_ITRACE, "CoFreeAllLibraries\n"));
    CDlls FAR* pCDlls;

    if (!EnsureDllMap(&pCDlls))
        return;

    pCDlls->FreeAllLibraries();

    // Also thunk the call to 32-bits
    CallObjectInWOW(THK_API_METHOD(THK_API_CoFreeAllLibraries), NULL);
    thkDebugOut((DEB_ITRACE, "CoFreeAllLibraries exit\n"));
}

STDAPI_(void)  CoFreeUnusedLibraries(void)
{
    HTASK hTask;
    Etask etask;

    if (!LookupEtask(hTask, etask) || etask.m_pDlls == NULL)
        return;

    etask.m_pDlls->FreeUnusedLibraries();

    // Also thunk the call to 32-bits
    CallObjectInWOW(THK_API_METHOD(THK_API_CoFreeUnusedLibraries), NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\dlltable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dlltable.h
//
//  Contents:	DLL tracking class
//
//  Classes:	CDll
//
//  History:	16-Mar-94	DrewB	Taken from OLE2 16-bit sources
//
//----------------------------------------------------------------------------

#ifndef __DLLTABLE_H__
#define __DLLTABLE_H__

class FAR CDlls
{
public:
    HINSTANCE GetLibrary(LPSTR pLibName, BOOL fAutoFree);
    void ReleaseLibrary(HINSTANCE hInst);
    void FreeAllLibraries(void);
    void FreeUnusedLibraries(void);

    CDlls() { m_size = 0; m_pDlls = NULL; }
    ~CDlls() {}

private:
    UINT m_size;                 // Number of entries
    struct {
        HINSTANCE hInst;
        ULONG refsTotal;		// total number of refs
        ULONG refsAuto;			// number of autounload refs
        LPFNCANUNLOADNOW lpfnDllCanUnloadNow;	// set on first load
    } FAR* m_pDlls;
};

#endif // #ifndef __DLLTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Precompiled header file
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include <ole2.h>
#include <valid.h>

#include <interop.hxx>
#include <wow16fn.h>
#include <io16.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\stdalloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       stdalloc.cxx
//
//  Contents:   16-bit OLE allocator
//
//  Classes:
//
//  Functions:
//
//  History:    3-07-94   kevinro   Ported from ole2.01 (16-bit)
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>

/****** Standard Task/Shared Allocator **********************************/

#define NULLSAB ((__segment)0)

typedef __segment SAB;

// amount of space windows reserves at start of segment
#define cbWinRes	16

// amount of space LocalInit takes (somewhat empirical)
#define cbWinOH		(6+10+46)

// total overhead per global block
#define cbTotalOH	(cbWinRes + sizeof(StdAllocHdr) + cbWinOH + 32)

// maximum sized object in a SAB (fudged to include space for per-block
// overhead and most anything else we missed).
#define cbMaxSAB (0xfffe - cbTotalOH)

//+---------------------------------------------------------------------------
//
//  Class:      CStdMalloc ()
//
//  Purpose:    Standard task allocator
//
//  History:    3-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
class FAR CStdMalloc : public IMalloc
{
public:
	CStdMalloc(DWORD memctx)
	{
		m_refs = 1;
		m_pStdAllocHead = NULL;
		m_flags = (memctx == MEMCTX_TASK)? GMEM_MOVEABLE :
						   GMEM_MOVEABLE|GMEM_SHARE;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void FAR* FAR* ppvObj)
	{
                VDATEPTROUT( ppvObj, LPVOID );
                *ppvObj = NULL;
                VDATEIID( iid );

		if (iid == IID_IUnknown || iid == IID_IMalloc) {
			*ppvObj = this;
			++m_refs;
			return NOERROR;
		} else {
			*ppvObj = NULL;
			return ReportResult(0, E_NOINTERFACE, 0, 0);
		}
	}
	
	STDMETHOD_(ULONG,AddRef)(void) { return ++m_refs; }
		
	STDMETHOD_(ULONG,Release)(void)
	{
		if (--m_refs == 0) {
			// free all memory (includes the memory for this class)
			FreeAllMem();
			return 0;
		} else
			return m_refs;
	}
		
    STDMETHOD_(void FAR*, Alloc) (ULONG cb);
    STDMETHOD_(void FAR*, Realloc) (void FAR* pv, ULONG cb);
    STDMETHOD_(void, Free) (void FAR* pv);
    STDMETHOD_(ULONG, GetSize) (void FAR* pv);
    STDMETHOD_(int, DidAlloc) (void FAR* pv);
    STDMETHOD_(void, HeapMinimize) ();

private:
	ULONG m_refs;
	UINT m_flags;

	#define STDALLOC_SIG 0x4D445453		// 'STDM'

	struct StdAllocHdr
	{
		ULONG m_Signature;
		HTASK m_hTask;					// task which owns this block
		StdAllocHdr FAR* m_pStdAllocNext;
	};

	StdAllocHdr FAR* m_pStdAllocHead;

	INTERNAL_(StdAllocHdr FAR*) MapBlockToSA(SAB sab) { return (StdAllocHdr FAR*)MAKELONG(cbWinRes, sab); }
	INTERNAL_(SAB) MapSAToBlock(StdAllocHdr FAR* pSA) { return (__segment)pSA; }
	INTERNAL_(void FAR*) AllocInBlock(SAB seg, UINT cb);
	INTERNAL_(SAB) AllocNewBlock(UINT cb);
	INTERNAL_(SAB) MapPtrToBlock(void FAR* pv);

	INTERNAL_(CStdMalloc FAR*) MoveSelf(LPVOID lpv);
	friend HRESULT STDAPICALLTYPE CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


	INTERNAL_(void) FreeAllMem(void);
};


INTERNAL_(void FAR*) CStdMalloc::AllocInBlock(SAB sab, UINT cb)
{
#ifdef _DEBUG
	WINDEBUGINFO Olddebuginfo, debuginfo;
	
	//get initial debug state
	
	GetWinDebugInfo(&debuginfo, WDI_OPTIONS);
	Olddebuginfo = debuginfo;
	
	//turn off alerts (see bug 3502)
	debuginfo.dwOptions |= DBO_SILENT;
	SetWinDebugInfo(&debuginfo);
	
#endif	// _DEBUG

	// must make alloc of 0 mean alloc something; LocalAlloc fails on cb == 0
	if (0==cb)
		cb = 2;

	_asm push DS;
	_asm mov DS, sab;
	void NEAR *npv = (void NEAR*)LocalAlloc(LMEM_FIXED, cb);
	_asm pop DS;

#ifdef _DEBUG
	//restore Debug state
		SetWinDebugInfo(&Olddebuginfo);
#endif	// _DEBUG

    if (npv == NULL) // npv is near pointer
        return NULL; // returned value is far pointer

	return (void FAR*)MAKELONG(npv, sab);
}


INTERNAL_(SAB) CStdMalloc::AllocNewBlock(UINT cb)
{
	if (cb > cbMaxSAB)
		// overflow
		return NULLSAB;

	if (cb < 4096 - cbTotalOH)
		// minimum is 4k global block
		cb = 4096;
	else
		// size will be larger than 4K; must include total overhead
		cb += cbTotalOH;

	// allocate block and get segment value
	HGLOBAL h;
	if ((h = GlobalAlloc(m_flags, cb)) == NULL)
		return NULLSAB;

	UINT segment;
	segment = HIWORD(GlobalHandle(h));

	// init windows local heap
	if (!LocalInit(segment, cbWinRes + sizeof(StdAllocHdr), cb)) {
		GlobalFree(h);
		return NULLSAB;
	}

	// init block and put it on front of list
	StdAllocHdr FAR* pSA;
	pSA = MapBlockToSA((SAB)segment);
	pSA->m_Signature = STDALLOC_SIG;
	pSA->m_hTask = (m_flags & GMEM_SHARE) != 0 ? NULL : GetCurrentTask();
	pSA->m_pStdAllocNext = m_pStdAllocHead;
	m_pStdAllocHead = pSA;

	return (SAB)segment;
}


INTERNAL_(SAB) CStdMalloc::MapPtrToBlock(void FAR* pv)
{
	if (pv == NULL)
		return NULLSAB;

	StdAllocHdr FAR* pSA;
	pSA = MapBlockToSA((SAB)pv);
	if (pSA->m_Signature != STDALLOC_SIG)
		return NULLSAB;
	if (m_flags & GMEM_SHARE) {
		if (pSA->m_hTask != NULL)
			// owned by task; not shared memory
			return NULLSAB;
	} else {
		if (pSA->m_hTask != GetCurrentTask()) {
			// if not same task, not this allocator; if different task,
			// something is wrong.
			AssertSz(pSA->m_hTask == NULL, "pointer used in wrong task");
			return NULLSAB;
		}
	}

	return MapSAToBlock(pSA);
}


STDMETHODIMP_(void FAR*) CStdMalloc::Alloc(ULONG cb)
{
	if (cb > cbMaxSAB)
		// can't deal with objects larger than 64k
		return NULL;

	// try all sab in order (newest allocated sab on front)
	StdAllocHdr FAR* pSA = m_pStdAllocHead;
	while (pSA != NULL) {
		// try allocating the memory; if successful, return

		void FAR* pv;
		if ((pv = AllocInBlock(MapSAToBlock(pSA), (UINT)cb)) != NULL)
			return pv;

		pSA = pSA->m_pStdAllocNext;
	}

	SAB sab;
	if ((sab = AllocNewBlock((UINT)cb)) == NULLSAB)
		return NULL;

	// this should really succeed (i.e., an assert would be better)
	return AllocInBlock(sab, (UINT)cb);
}


STDMETHODIMP_(void FAR*) CStdMalloc::Realloc(void FAR* pv, ULONG cb)
{


	if (cb > cbMaxSAB)
		// can't deal with objects larger than 64k
		return NULL;

	SAB sab;
	if (pv == NULL)
		// same as allocating a new pointer
		return Alloc(cb);
	
	//VDATEPTRIN rejects NULL (changed by alexgo 8/3/93)	
	GEN_VDATEPTRIN( pv, int, (LPVOID)NULL );	
	if ((sab = MapPtrToBlock(pv)) == NULLSAB)
		// attempt to realloc a pointer from some other allocator
		return NULL;
	else if (cb == 0) {
		// Realloc(pv, 0) -> frees and returns NULL; this is C library behavior
		Free(pv);
		return NULL;
	}

	void NEAR* npv;
	npv = (void NEAR*)(ULONG)pv;

	// first try realloc within same sab
	Assert(sab != NULLSAB);
	{
		void NEAR* npvT;

		_asm push DS;
		_asm mov DS, sab;
		npvT = (void NEAR*)LocalReAlloc((HLOCAL)npv, (UINT)cb, LMEM_MOVEABLE);
		_asm pop DS;

		if (npvT != NULL)
			return (void FAR*)MAKELONG(npvT, sab);
	}

	// now try allocating new sab and copying
	void FAR* pvT;
	if ((pvT = Alloc(cb)) == NULL)
		return NULL;

	// only copy the smaller of the old and new size
	_asm push ds;
	_asm mov ds,sab;
	UINT cbCopy = LocalSize((HLOCAL)npv);
	_asm pop ds;

	if ((UINT)cb < cbCopy)
		// new size smaller
		cbCopy = (UINT)cb;

	_fmemcpy(pvT, pv, cbCopy);
	

	Free(pv);

	return pvT;
}


STDMETHODIMP_(void) CStdMalloc::Free(void FAR* pv)
{
	SAB sab;

	if (pv == NULL)
		return;

	//VDATEPTRIN rejects NULL (changed by alexgo 8/3/93)
 	VOID_VDATEPTRIN( pv, int );
 	
	if ((sab = MapPtrToBlock(pv)) == NULLSAB) {
#ifdef _DEBUG
		AssertSz(FALSE, "Pointer freed by wrong allocator; filling with 0xcc");

		// we don't own block; this is an error; fill it with 0xcccc anyway
		UINT cb = (UINT)GlobalSize((HGLOBAL)GlobalHandle((__segment)pv));
		cb -= (UINT)(ULONG)pv;

		_fmemset(pv, 0xcc, (size_t)cb);
#endif
	} else {
#ifdef _DEBUG
		// we own block; fill it with 0xcccc
		_fmemset(pv, 0xcc, (size_t)GetSize(pv));
#endif
		_asm push ds;
		_asm mov ds,sab;
		LocalFree((HLOCAL)(void NEAR*)(ULONG)pv);
		_asm pop ds;
	}
}


STDMETHODIMP_(ULONG) CStdMalloc::GetSize(void FAR* pv)
{
	ULONG size = 0;
	SAB sab;

	//VDATEPTRIN rejects NULL (added by alexgo 8/3/93)	
	if( pv == NULL )
		return -1;
		
	GEN_VDATEPTRIN( pv , int, 0 );

	if ((sab = MapPtrToBlock(pv)) != NULLSAB) {
		_asm push ds;
		_asm mov ds,sab;
		size = LocalSize((HLOCAL)(void NEAR*)(ULONG)pv);
		_asm pop ds;
	}

	return size;
}


STDMETHODIMP_(int) CStdMalloc::DidAlloc(void FAR* pv)
{


	if (pv == NULL)
		return -1;

 	//VDATEPTRIN rejects NULL (added by alexgo 8/3/93)
	GEN_VDATEPTRIN( pv , int, 0 );
	
	// returns 1 if we allocated, 0 if not; this impl never returns -1.
	return MapPtrToBlock(pv) != NULLSAB;
}


STDMETHODIMP_(void) CStdMalloc::HeapMinimize()
{
	// LATER : could do local compact here
}


// move this instance of stdmalloc to lpv (which must be large enough)
INTERNAL_(CStdMalloc FAR*) CStdMalloc::MoveSelf(LPVOID lpv)
{
	_fmemcpy(lpv, this, sizeof(*this));
	m_pStdAllocHead = NULL;
	return (CStdMalloc FAR*)lpv;
}


INTERNAL_(void) CStdMalloc::FreeAllMem(void)
{
	// get/null out head of list; null now in case we are freeing self.
	StdAllocHdr FAR* pSA = m_pStdAllocHead;
	m_pStdAllocHead = NULL;

	// free all blocks
	while (pSA != NULL) {
		StdAllocHdr FAR* pSANext = pSA->m_pStdAllocNext;
		pSA->m_pStdAllocNext = NULL;		// to prevent incorrect compiler opt

		GlobalFree(LOWORD(GlobalHandle((UINT)MapSAToBlock(pSA))));

		pSA = pSANext;
	}
}


/****** Global API for creating *****************************************/


// create and return an impl of IMalloc of given memctx
//+---------------------------------------------------------------------------
//
//  Function:   CoCreateStandardMalloc, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [memctx] --
//		[ppMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc)
{
	thkDebugOut((DEB_ITRACE, " CoCreateStandardMalloc\n"));
	*ppMalloc = NULL;

	switch (memctx) {

	case MEMCTX_TASK:
	case MEMCTX_SHARED:
		{
		CStdMalloc sm(memctx);			// local one

		void FAR* lpv;
		if ((lpv = sm.Alloc(sizeof(CStdMalloc))) == NULL)
			return ResultFromScode(E_OUTOFMEMORY);

		*ppMalloc = sm.MoveSelf(lpv);		// move to newly allocated memory
		return NOERROR;
		}
	default:
		return ResultFromScode(E_INVALIDARG);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\etask.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ETASK.CXX   (16 bit target)
//
//  Contents:   ETask management code, taken from 16-bit COMPOBJ.CPP
//
//  Functions:
//
//  History:    08-Mar-94   BobDay  Copied parts from \\ole\slm\...\compobj.cpp
//		01-Feb-95   JohannP modified/simplified
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>

#include "comlocal.hxx"
#include "map_htsk.h"
#include "etask.hxx"

#include "call32.hxx"
#include "apilist.hxx"

// NOTE: NEAR forces this variable to be in the default data segment; without
// NEAR, the ambient model of the class CMapHandleEtask, which is FAR,
// causes the variable to be in a far_data segment.
//

HTASK	v_hTaskCache = NULL;
Etask	NEAR v_etaskCache;


// quick check that the etask is valid (e.g., pointers are valid)
INTERNAL_(BOOL) IsValidEtask(HTASK hTask, Etask FAR& etask)
{   
    Assert(GetCurrentProcess() == hTask);
    thkDebugOut((DEB_DLLS16, "IsValidEtask (%X) pMalloc(%p)\n", hTask, etask.m_pMalloc));

    if (!IsValidInterface(etask.m_pMalloc))
    {
	thkDebugOut((DEB_DLLS16, "IsValidEtask (%X) FALSE\n", hTask));
	return FALSE;
    }

    // FUTURE: verify that stack segment is the same
    // FUTURE: verify that hInst/hMod are the same
    thkDebugOut((DEB_DLLS16, "IsValidEtask (%X) TRUE\n", hTask));

    return TRUE;
}


// if task map empty, clear globals in case lib doesn't get unloaded
INTERNAL_(void) CheckIfMapEmpty(void)
{
	// if no more entries, clear v_pMallocShared; this ensures we clear the
	// variable if the app holds onto this pointer erroneously.
	if (v_mapToEtask.IsEmpty()) {
		v_pMallocShared = NULL;
	}
}

//+---------------------------------------------------------------------------
//
//  Method:     LookupEtask
//
//  Synopsis: 	get etask for current task (and also return hTask);
//		does not create if none
//
//  Arguments:  [hTask] --
//		[etask] --
//
//  Returns:
//
//  History:	Ole16	  created for CompObj 16 bit for Ole2
//		2-03-95   JohannP (Johann Posch)   modified/simplified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) LookupEtask(HTASK FAR& hTask, Etask FAR& etask)
{
    hTask = GetCurrentProcess();
    thkDebugOut((DEB_DLLS16, "LookupEtask on Process (%X) \n", hTask));

    if (hTask == v_hTaskCache)
    {
	thkDebugOut((DEB_DLLS16, "LookupEtask found in cache (%X) \n", hTask));
	etask = v_etaskCache;
	goto CheckEtask;
    }

    if (!v_mapToEtask.Lookup(hTask, etask))
    {
	thkDebugOut((DEB_DLLS16, "LookupEtask faild on lookup (%X) \n", hTask));
	return FALSE;
    }
    else
    {
	thkDebugOut((DEB_DLLS16, "LookupEtask found in lookup (%X) \n", hTask));
    }

    // found etask; make this the current cache
    v_hTaskCache = hTask;
    v_etaskCache = etask;

CheckEtask:
    if (IsValidEtask(hTask, etask))
    {
	return TRUE;
    }
    else
    {
	// task got reused; kill cache and entry in map
	v_hTaskCache = NULL;
	v_mapToEtask.RemoveKey(hTask);
	CheckIfMapEmpty();
	thkAssert(0 && "LookupEtask - failed (invalid Etask)");
	return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     SetEtask
//
//  Synopsis: set etask for task given (must be current task); return FALSE
//	      if OOM (only first time; all other times should return TRUE).
//
//  Arguments:  [hTask] --
//		[etask] --
//
//  Returns:
//
//  History:	Ole16      created for CompObj 16 bit for Ole2
//		02-03-95   JohannP (Johann Posch)   modified/simplified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) SetEtask(HTASK hTask, Etask FAR& etask)
{
    Assert(GetCurrentProcess() == hTask);

    if (!v_mapToEtask.SetAt(hTask, etask))
		return FALSE;

	Assert(IsValidEtask(hTask, etask));

	// map set; make this the current cache
	v_hTaskCache = hTask;
	v_etaskCache = etask;
	return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     ReleaseEtask
//
//  Synopsis:	release all fields in the etask; do all the task memory
//		(except the task allocator) first; then all the shared
//		memory (except the shared allocator); then the shared
//		allocator and finally the task allocator.
// 		Also removes key if htask is given.
//
//  Arguments:  [htask] --
//		[etask] --
//
//  Returns:
//
//  History:	Ole16	  created for CompObj 16 bit for Ole2
//		2-03-95   JohannP (Johann Posch)   modified/simplified
//
//  Notes:	Called by daytona and chicago.
//
//----------------------------------------------------------------------------
void  ReleaseEtask(HTASK htask, Etask FAR& etask)
{
	thkDebugOut((DEB_DLLS16, "ReleaseEtask on Process (%X) \n", htask));
	Assert(etask.m_inits == 1);
	Assert(etask.m_oleinits == 0);
	Assert(etask.m_reserved == 0);

        // Release any state that may have been set
        if (etask.m_punkState != NULL && IsValidInterface(etask.m_punkState))
        {
            etask.m_punkState->Release();
        }
	// first delete all task memory items
	delete etask.m_pDlls;					// task memory
	delete etask.m_pMapToServerCO;			// task memory
	delete etask.m_pMapToHandlerCO;			// task memory
	delete etask.m_pArraySH;				// task memory
	Assert(etask.m_pCThrd == NULL);			// task memory; must be gone by now


	// remove key now that all task memory that will be freed is freed
	if (htask != NULL) {
		v_mapToEtask.RemoveKey(htask);
	}
	// if no more entries, remove last remaining memory; this prevents
	// problems if the dll is not unloaded for some reason before being
	// used again.
	if (v_mapToEtask.IsEmpty())
		v_mapToEtask.RemoveAll();

	// now remove all shared memory (doesn't need access to task pMalloc)

	Assert(etask.m_pMallocShared != NULL);
	if (etask.m_pMallocShared->Release() == 0) { // in shared memory
		// last use of the shared allocator; set global to null
		v_pMallocShared = NULL;
		Assert(v_mapToEtask.IsEmpty());
	}

	CheckIfMapEmpty();

	// finally, release the task memory
	Assert(etask.m_pMalloc != NULL);
	etask.m_pMalloc->Release();				// in task memory
	etask.m_pMalloc = NULL;
	thkDebugOut((DEB_DLLS16, "ReleaseEtask (%X) pMalloc(%p)\n", htask, etask.m_pMalloc));

	// invalidate cache
	v_hTaskCache = NULL;
	thkDebugOut((DEB_DLLS16, "ReleaseEtask done on (%X) \n", htask));
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveEtask
//
//  Synopsis:   Releases the shares allocator and removes
//		the etask from the global list
//
//  Arguments:  [hTask] -- htask
//		[etask] -- etask
//
//  Returns:
//
//  History:    2-03-95   JohannP (Johann Posch)   Created
//
//  Notes:	Called only by Chicago.
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) RemoveEtask(HTASK FAR& hTask, Etask FAR& etask)
{
    hTask = GetCurrentProcess();
    thkDebugOut((DEB_DLLS16, "RemoveEtask on Process (%X) \n", hTask));

    if (hTask == v_hTaskCache)
    {
	v_hTaskCache = NULL;
    }
    v_mapToEtask.RemoveKey(hTask);

    if (v_mapToEtask.IsEmpty())
	v_mapToEtask.RemoveAll();

    thkAssert(etask.m_pMallocShared != NULL);
    if(etask.m_pMallocShared->Release() == 0)
    {
	// in shared memory
	// last use of the shared allocator; set global to null
	v_pMallocShared = NULL;
	thkDebugOut((DEB_DLLS16, "RemoveEtask Set v_pMallocShared to NULL  (%X) \n", hTask));
	Assert(v_mapToEtask.IsEmpty());
    }

    CheckIfMapEmpty();

    thkDebugOut((DEB_DLLS16, "RemoveEtask done (%X) \n", hTask));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\valid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:		Valid.cxx	(16 bit target)
//
//  Contents:	Validation APIs exported by CompObj
//
//  Functions:	
//
//  History:	93 OLE 2.0 Dev team  Cretead
//				17-Dec-93 JohannP
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

/*
 * IsValidPtrIn -- Check if the pointer points to a readable segment
 * and if the pointer + #of bytes stays within the segment.
 *
 * NULL will fail
 *
 * cb == 0 will FAIL
 *
 * This function exists only for compatibility with already-compiled apps.
 * We now use macros for IsValidPtrIn and IsValidPtrOut
 * Check out the comments in inc\valid.h
 */


//+---------------------------------------------------------------------------
//
//  Function:   ISVALIDPTRIN, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pv] --
//		[cb] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL)
ISVALIDPTRIN( const void FAR* pv, UINT cb )
{
	return !IsBadReadPtr (pv, cb);
	// We cannot use inline assembly here because the VERR instruction does
	// not work if the segment has been discarded (but is still valid).
}


// This function exists only for compatibility with already-compiled apps.
// We now use macros for IsValidPtrIn and IsValidPtrOut
//
// Check out the comments in inc\valid.h


//+---------------------------------------------------------------------------
//
//  Function:   ISVALIDPTROUT, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pv] --
//		[cb] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL)
ISVALIDPTROUT( void FAR* pv, UINT cb )
										//	NULL is not acceptable
{
	return !IsBadWritePtr (pv, cb);
}


//	valid code begins 0xb8, ??, ??, followed by:

// BYTE validcode[6] = { 0x55, 0x8b, 0xec, 0x1e, 0x8e, 0xd8};


//+---------------------------------------------------------------------------
//
//  Function:   IsValidInterface, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) IsValidInterface( void FAR* pv )
{
	BYTE FAR* pb;
	
	//	NULL is not acceptable as input.

	if (!IsValidPtrIn(pv,4)) goto false;
#ifdef _STRICT_VALIDATION
	//	if the interface was compiled with C++, the virtual function table
	//	will be in a code segment
	if (IsBadCodePtr(*(FARPROC FAR*)pv)) goto false;
#endif
	pb = *(BYTE FAR* FAR*)pv;		//	pb points to beginning of vftable
    if (!IsValidPtrIn(pb, 4)) goto false;
	if (IsBadCodePtr(*(FARPROC FAR*)pb)) goto false;
	pb = *(BYTE FAR* FAR*)pb;
	if (!IsValidPtrIn(pb, 9)) goto false;
//	if (*pb != 0xb8) goto false;
//	pb += 3;
//	if (_fmemcmp(pb, validcode, 6)) goto false;
	return TRUE;
false:
//	AssertSz(FALSE, "Invalid interface pointer");
	return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsValidIid, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [iid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL)
IsValidIid( REFIID iid )
{
	IID iidTemp = iid;
	DWORD FAR* pdw = (DWORD FAR*)&iidTemp;
	*pdw = 0;
	if (IID_IUnknown == iidTemp) return TRUE;
        thkDebugOut((DEB_IERROR, "WARNING: Nonstandard IID parameter"));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\go1632pr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       GO1632Pr.cxx    (16 bit target)
//
//  Contents:   Functions to thunk interface pointer from 16 to 32 bit.
//
//  Functions:
//
//  History:    13-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <obj16.hxx>
#include <go1632pr.hxx>

//+---------------------------------------------------------------------------
//
//  Macro:      DEFINE_METHOD
//
//  Synopsis:   Defines a generic 16->32 proxy method
//
//  History:    23-Feb-94       DrewB     Created
//
//
//  Notes:      A proxy method's primary reason for existence is to
//              get into the 32-bit world with a pointer to the 16-bit
//              stack.  This is accomplished by taking the address of
//              the this pointer.  Since methods are cdecl, this works
//              for methods with any number of parameters because the
//              first parameter is always the one closest to the return
//              address.
//              The method also passed on the object ID and the method
//              index so that the method's arguments can be properly
//              thunked on the 32-bit side
//
//----------------------------------------------------------------------------

#define DEFINE_METHOD(n) \
STDMETHODIMP_(DWORD) Proxy1632Method##n(THUNK1632OBJ FAR *ptoThis16) \
{ \
    thkDebugOut((DEB_THUNKMGR, "Proxy1632Method: %p(%d)\n", ptoThis16, n)); \
    return CallObjectInWOW( n, CDECL_STACK_PTR(ptoThis16)); \
}


#if DBG == 1

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidString(GUID const *pguid)
{
    static char ach[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    wsprintf(ach, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return ach;
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   Proxy1632QueryInterface, public
//
//  Synopsis:   QueryInterface for the proxy object.
//
//  History:    01-Apr-94       JohannP   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) Proxy1632QueryInterface(THUNK1632OBJ FAR *ptoThis16,
                                             REFIID refiid,
                                             LPVOID *ppv)
{
    DWORD dwRet;
    LPVOID lpvoid = (LPVOID)&refiid;
    IID iid = refiid;

    thkDebugOut((DEB_THUNKMGR, " Proxy1632QueryInterface: %p %s\n",
                 ptoThis16, GuidString((IID const *)&iid) ));

    // Why do we make a copy of the iid only so that we can over-write
    // it so that we can return the pointer to it in it?  This should be
    // re-written.
    //
    dwRet = CallProcIn32((DWORD)ptoThis16, SMI_QUERYINTERFACE, (DWORD)&iid,
                        lpIUnknownObj32, 0, CP32_NARGS);
    *ppv = (LPVOID) iid.Data1;

    thkDebugOut(( DEB_THUNKMGR,
                  "Out Proxy1632QueryInterface: (%p)->%p scRet:0x%08lx\n",
                  ptoThis16, *ppv, dwRet));

    return dwRet;

}

//+---------------------------------------------------------------------------
//
//  Function:   Proxy1632AddRef, public
//
//  Synopsis:   AddRef for the generic proxy object
//
//  History:    01-Apr-94       JohannP   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) Proxy1632AddRef(THUNK1632OBJ FAR *ptoThis16)
{
    DWORD dwRet;

    thkDebugOut(( DEB_THUNKMGR, "In Proxy1632AddRef: %p \n",ptoThis16));

    dwRet = CallProcIn32((DWORD)ptoThis16, SMI_ADDREF, 0,
                        lpIUnknownObj32, 0, CP32_NARGS);

    thkDebugOut(( DEB_THUNKMGR, "Out Proxy1632AddRef: %p dwRet:%ld\n",
                  ptoThis16, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   Proxy1632Release, public
//
//  Synopsis:   Release for the proxy object.
//
//  History:    01-Apr-94       JohannP   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) Proxy1632Release(THUNK1632OBJ FAR *ptoThis16)
{
    DWORD dwRet;

    thkDebugOut(( DEB_THUNKMGR, "In Proxy1632Release: %p\n", ptoThis16));

    dwRet = CallProcIn32((DWORD)ptoThis16, SMI_RELEASE, 0,
                        lpIUnknownObj32, 0, CP32_NARGS);

    thkDebugOut(( DEB_THUNKMGR, "Out Proxy1632Release: %p dwRet:%ld\n",
                               ptoThis16,dwRet));

    return dwRet;
}

// Additional methods so that any possible interface can be represented
// using the vtable made up out of all the methods

DEFINE_METHOD(3)
DEFINE_METHOD(4)
DEFINE_METHOD(5)
DEFINE_METHOD(6)
DEFINE_METHOD(7)
DEFINE_METHOD(8)
DEFINE_METHOD(9)
DEFINE_METHOD(10)
DEFINE_METHOD(11)
DEFINE_METHOD(12)
DEFINE_METHOD(13)
DEFINE_METHOD(14)
DEFINE_METHOD(15)
DEFINE_METHOD(16)
DEFINE_METHOD(17)
DEFINE_METHOD(18)
DEFINE_METHOD(19)
DEFINE_METHOD(20)
DEFINE_METHOD(21)
DEFINE_METHOD(22)
DEFINE_METHOD(23)
DEFINE_METHOD(24)
DEFINE_METHOD(25)
DEFINE_METHOD(26)
DEFINE_METHOD(27)
DEFINE_METHOD(28)
DEFINE_METHOD(29)
DEFINE_METHOD(30)
DEFINE_METHOD(31)

// A vtable which will end up calling back to our proxy methods
DWORD atfnProxy1632Vtbl[] =
{
    (DWORD)Proxy1632QueryInterface,
    (DWORD)Proxy1632AddRef,
    (DWORD)Proxy1632Release,
    (DWORD)Proxy1632Method3,
    (DWORD)Proxy1632Method4,
    (DWORD)Proxy1632Method5,
    (DWORD)Proxy1632Method6,
    (DWORD)Proxy1632Method7,
    (DWORD)Proxy1632Method8,
    (DWORD)Proxy1632Method9,
    (DWORD)Proxy1632Method10,
    (DWORD)Proxy1632Method11,
    (DWORD)Proxy1632Method12,
    (DWORD)Proxy1632Method13,
    (DWORD)Proxy1632Method14,
    (DWORD)Proxy1632Method15,
    (DWORD)Proxy1632Method16,
    (DWORD)Proxy1632Method17,
    (DWORD)Proxy1632Method18,
    (DWORD)Proxy1632Method19,
    (DWORD)Proxy1632Method20,
    (DWORD)Proxy1632Method21,
    (DWORD)Proxy1632Method22,
    (DWORD)Proxy1632Method23,
    (DWORD)Proxy1632Method24,
    (DWORD)Proxy1632Method25,
    (DWORD)Proxy1632Method26,
    (DWORD)Proxy1632Method27,
    (DWORD)Proxy1632Method28,
    (DWORD)Proxy1632Method29,
    (DWORD)Proxy1632Method30,
    (DWORD)Proxy1632Method31
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\compobj\memctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       memctx.cxx
//
//  Contents:   all memory management for compobj dll (exported as well)
//
//  Classes:
//
//  Functions:
//
//  History:    10-Mar-94   bobday  Ported from ole2.01 (16-bit)
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>
#include <memctx.hxx>

#include "comlocal.hxx"
#include "map_htsk.h"
#include "etask.hxx"


ASSERTDATA

STDAPI_(DWORD) CoMemctxOf(void const FAR* lpv)
{
	Etask etask;
	HTASK htask;
	int iDidTaskAlloc;

	if (lpv == NULL)
		return MEMCTX_UNKNOWN;

	// try shared memory first because of a bootstrapping problem when setting
	// the Etask the first time.
	if (v_pMallocShared != NULL && v_pMallocShared->DidAlloc((LPVOID)lpv) == 1)
		return MEMCTX_SHARED;

	// now try the other contexts by getting the pointers to their mallocs
	if (!LookupEtask(htask, etask))
		return MEMCTX_UNKNOWN;

	Assert(etask.m_pMalloc != NULL);			// should always have one
	if ((iDidTaskAlloc = etask.m_pMalloc->DidAlloc((LPVOID)lpv)) == 1)
		return MEMCTX_TASK;

	Assert(etask.m_pMallocShared == NULL || etask.m_pMallocShared == v_pMallocShared);

	// last ditch effort: if the task allocator returned -1 (may have alloc'd),
	// then we assume it is task memory.  We do this after the above tests
	// since we would prefer to be exact.
	if (iDidTaskAlloc == -1)
		return MEMCTX_TASK;

	return MEMCTX_UNKNOWN;
}


STDAPI_(void FAR*) CoMemAlloc(ULONG size, DWORD memctx, void FAR* lpvNear)
{
	if (memctx == MEMCTX_SAME)
		{
		AssertSz(lpvNear != NULL,0);
		memctx = CoMemctxOf(lpvNear);
		}
	else
		AssertSz(lpvNear == NULL,0);

	IMalloc FAR* pMalloc;
	void FAR* lpv = NULL;	// stays null if bad context or out of memory
	if (CoGetMalloc(memctx, &pMalloc) == 0) {
		lpv = pMalloc->Alloc(size);
		pMalloc->Release();
	}
	return lpv;
}


STDAPI_(void) CoMemFree(void FAR* lpv, DWORD memctx)
{
	if (lpv == NULL)
		return;

	if (memctx == MEMCTX_UNKNOWN)
		memctx = CoMemctxOf(lpv);

	IMalloc FAR* pMalloc;
	if (CoGetMalloc(memctx, &pMalloc) == 0) {
		pMalloc->Free(lpv);
		pMalloc->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\coguid.h ===
/*****************************************************************************\
*                                                                             *
* coguid.h -    Master definition of GUIDs for compobj.dll                    *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage 
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense 
   that part of the GUID range owned by OLE was used to define them.  
   
   NOTE: The second byte of all of these GUIDs is 0.
*/
   

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* interface to inform object of number of external connections */
DEFINE_OLEGUID(IID_IExternalConnection, 0x00000019L, 0, 0);

/* NOTE: LSB 0x1a through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\dvobj.h ===
/*****************************************************************************\
*                                                                             *
* dvobj.h -		Data/View object definitions								  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _DVOBJ_H_ )
#define _DVOBJ_H_

/****** DV value types ******************************************************/

//      forward type declarations
#if defined(__cplusplus)
interface IStorage;
interface IStream;
interface IAdviseSink;
interface IMoniker;
#else 
typedef interface IStorage IStorage;
typedef interface IStream IStream;
typedef interface IAdviseSink IAdviseSink;
typedef interface IMoniker IMoniker;
#endif

typedef            IStorage FAR* LPSTORAGE;
typedef             IStream FAR* LPSTREAM;
typedef         IAdviseSink FAR* LPADVISESINK;
typedef             IMoniker FAR* LPMONIKER;


#if !defined(_MAC)
typedef WORD CLIPFORMAT;
#else
typedef unsigned long CLIPFORMAT;            // ResType
#endif
typedef  CLIPFORMAT FAR* LPCLIPFORMAT;


// Data/View aspect; specifies the desired aspect of the object when 
// drawing or getting data.
typedef enum tagDVASPECT
{
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;


// Data/View target device; determines the device for drawing or gettting data
typedef struct FARSTRUCT tagDVTARGETDEVICE
{
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    BYTE tdData[1];
} DVTARGETDEVICE;


// Format, etc.; completely specifices the kind of data desired, including tymed
typedef struct FARSTRUCT tagFORMATETC
{
    CLIPFORMAT          cfFormat;
    DVTARGETDEVICE FAR* ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC, FAR* LPFORMATETC;


// TYpes of storage MEDiums; determines how data is stored or passed around
typedef enum tagTYMED
{
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_NULL = 0
} TYMED;


// DATA format DIRection
typedef enum tagDATADIR
{
    DATADIR_GET = 1,
    DATADIR_SET = 2,
} DATADIR;


// SToraGe MEDIUM; a block of data on a particular medium 
typedef struct FARSTRUCT tagSTGMEDIUM
{
    DWORD   tymed;
    union
    {
        HANDLE  hGlobal;
        LPSTR   lpszFileName;
        IStream FAR* pstm;
        IStorage FAR* pstg;
    }
#ifdef NONAMELESSUNION
    u       // add a tag when name less unions not supported
#endif
    ;
    IUnknown FAR* pUnkForRelease;
} STGMEDIUM, FAR* LPSTGMEDIUM;


// Advise Flags
typedef enum tagADVF
{
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
} ADVF;


// Stats for data; used by several enumerations and by at least one 
// implementation of IDataAdviseHolder; if a field is not used, it
// will be NULL.
typedef struct FARSTRUCT tagSTATDATA
{                                   // field used by:
    FORMATETC formatetc;            // EnumAdvise, EnumData (cache), EnumFormats
    DWORD advf;                     // EnumAdvise, EnumData (cache)
    IAdviseSink FAR* pAdvSink;      // EnumAdvise
    DWORD dwConnection;             // EnumAdvise
} STATDATA;
    
typedef  STATDATA FAR* LPSTATDATA;



/****** DV Interfaces ***************************************************/


#undef  INTERFACE
#define INTERFACE   IEnumFORMATETC

DECLARE_INTERFACE_(IEnumFORMATETC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumFORMATETC FAR* FAR* ppenum) PURE;
};
typedef        IEnumFORMATETC FAR* LPENUMFORMATETC;


#undef  INTERFACE
#define INTERFACE   IEnumSTATDATA

DECLARE_INTERFACE_(IEnumSTATDATA, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IEnumSTATDATA methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATDATA FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATDATA FAR* FAR* ppenum) PURE;
};
typedef        IEnumSTATDATA FAR* LPENUMSTATDATA;



#undef  INTERFACE
#define INTERFACE   IDataObject

#define DATA_E_FORMATETC        DV_E_FORMATETC
#define DATA_S_SAMEFORMATETC    (DATA_S_FIRST + 0)

DECLARE_INTERFACE_(IDataObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetc,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(QueryGetData) (THIS_ LPFORMATETC pformatetc ) PURE;
    STDMETHOD(GetCanonicalFormatEtc) (THIS_ LPFORMATETC pformatetc,
                            LPFORMATETC pformatetcOut) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
    STDMETHOD(EnumFormatEtc) (THIS_ DWORD dwDirection,
                            LPENUMFORMATETC FAR* ppenumFormatEtc) PURE;

    STDMETHOD(DAdvise) (THIS_ FORMATETC FAR* pFormatetc, DWORD advf, 
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(DUnadvise) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumDAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
};                 
typedef      IDataObject FAR* LPDATAOBJECT;



#undef  INTERFACE
#define INTERFACE   IViewObject

#define VIEW_E_DRAW             (VIEW_E_FIRST)
#define E_DRAW                  VIEW_E_DRAW

#define VIEW_S_ALREADY_FROZEN   (VIEW_S_FIRST)

DECLARE_INTERFACE_(IViewObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    LPCRECTL lprcBounds, 
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
};
typedef      IViewObject FAR* LPVIEWOBJECT;


#undef  INTERFACE
#define INTERFACE   IViewObject2

DECLARE_INTERFACE_(IViewObject2, IViewObject)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    LPCRECTL lprcBounds, 
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
					
    // *** IViewObject2 methods ***
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    DVTARGETDEVICE FAR * ptd, LPSIZEL lpsizel) PURE;
					
};
typedef      IViewObject2 FAR* LPVIEWOBJECT2;


#undef  INTERFACE
#define INTERFACE   IAdviseSink

DECLARE_INTERFACE_(IAdviseSink, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;
};
typedef      IAdviseSink FAR* LPADVISESINK;



#undef  INTERFACE
#define INTERFACE   IAdviseSink2

DECLARE_INTERFACE_(IAdviseSink2, IAdviseSink)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;

    // *** IAdviseSink2 methods ***
    STDMETHOD_(void,OnLinkSrcChange)(THIS_ LPMONIKER pmk) PURE;
};
typedef      IAdviseSink2 FAR* LPADVISESINK2;



#undef  INTERFACE
#define INTERFACE   IDataAdviseHolder

DECLARE_INTERFACE_(IDataAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDataAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPDATAOBJECT pDataObject, FORMATETC FAR* pFetc, 
            DWORD advf, LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnDataChange)(THIS_ LPDATAOBJECT pDataObject, DWORD dwReserved, DWORD advf) PURE;
};
typedef      IDataAdviseHolder FAR* LPDATAADVISEHOLDER;



#undef  INTERFACE
#define INTERFACE   IOleCache

#define CACHE_E_NOCACHE_UPDATED         (CACHE_E_FIRST)

#define CACHE_S_FORMATETC_NOTSUPPORTED  (CACHE_S_FIRST)
#define CACHE_S_SAMECACHE               (CACHE_S_FIRST+1)
#define CACHE_S_SOMECACHES_NOTUPDATED   (CACHE_S_FIRST+2)


DECLARE_INTERFACE_(IOleCache, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
};
typedef         IOleCache FAR* LPOLECACHE;



// Cache update Flags

#define	UPDFCACHE_NODATACACHE			0x00000001
#define UPDFCACHE_ONSAVECACHE			0x00000002
#define	UPDFCACHE_ONSTOPCACHE			0x00000004
#define	UPDFCACHE_NORMALCACHE			0x00000008
#define	UPDFCACHE_IFBLANK				0x00000010
#define UPDFCACHE_ONLYIFBLANK			0x80000000

#define UPDFCACHE_IFBLANKORONSAVECACHE	(UPDFCACHE_IFBLANK | UPDFCACHE_ONSAVECACHE )
#define UPDFCACHE_ALL					(~UPDFCACHE_ONLYIFBLANK)
#define UPDFCACHE_ALLBUTNODATACACHE		(UPDFCACHE_ALL & ~UPDFCACHE_NODATACACHE)


// IOleCache2::DiscardCache options
typedef enum tagDISCARDCACHE
{
	DISCARDCACHE_SAVEIFDIRTY =	0,	// Save all dirty cache before discarding
	DISCARDCACHE_NOSAVE		 =	1	// Don't save dirty caches before 
									// discarding
} DISCARDCACHE;


#undef  INTERFACE
#define INTERFACE   IOleCache2

DECLARE_INTERFACE_(IOleCache2, IOleCache)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;

    // *** IOleCache2 methods ***							
    STDMETHOD(UpdateCache) (THIS_ LPDATAOBJECT pDataObject, DWORD grfUpdf, 
							LPVOID pReserved) PURE;
    STDMETHOD(DiscardCache) (THIS_ DWORD dwDiscardOptions) PURE;
						
};
typedef      IOleCache2 FAR* LPOLECACHE2;


#undef  INTERFACE
#define INTERFACE   IOleCacheControl

DECLARE_INTERFACE_(IOleCacheControl, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(OnRun) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(OnStop) (THIS) PURE;
};                 
typedef      IOleCacheControl FAR* LPOLECACHECONTROL;



/****** DV APIs ***********************************************************/


STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

STDAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
					REFIID iid, LPVOID FAR* ppv);
					
#endif // _DVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\debug.h ===
/*
 *  DEBUG code - Contains declarations and macros for include debug support;
 *       Contains null definitions when !_DEBUG
 */

#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#include <ole2dbg.h>

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#ifdef _MAC
#ifdef __cplusplus
extern "C" {
#endif
void OutputDebugString(const char *);
#ifdef __cplusplus
}
#endif
#endif

#define ASSERTDATA  static char  _szAssertFile[]= __FILE__;

#undef Assert
// MAC compiler barfs on '(void)0'.
#ifdef _MAC
#define Assert(a) { if (!(a)) FnAssert(#a, NULL, _szAssertFile, __LINE__); }
#undef AssertSz
#define AssertSz(a, b) { if (!(a)) FnAssert(#a, b, _szAssertFile, __LINE__); }
#else
#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, _szAssertFile, __LINE__))
#endif
#undef Verify
#define Verify(a)   Assert(a)
#undef Puts
#define Puts(s) OutputDebugString(s)

#define ASSERT(cond, msg)

#else   //  !_DEBUG

#define ASSERTDATA
#define Assert(a)
#define AssertSz(a, b)
#define Verify(a) (a)
#define ASSERT(cond, msg)
#define Puts(s)

#endif  //  _DEBUG

#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
 *    LPSTR sz;
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    char ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( char ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#if _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif
#endif
};


#ifdef _MAC
typedef short HFILE;
#endif


/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPSTR lpszFile, LPSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

    #ifdef _MAC

        //#define STDDEBDECL(cclassname,classname)

        //#if 0
        #define STDDEBDECL(cclassname,classname) NESTED_CLASS(cclassname, CDebug):IDebug { public: \
            NC1(cclassname,CDebug)( cclassname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~##NC1(cclassname,CDebug)(void){} \
            STDMETHOD_(void, Dump)(THIS_ IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(THIS_ BOOL fSuspicious ); \
            private: cclassname FAR* m_p##classname; }; \
            DECLARE_NC2(cclassname, CDebug) \
            NC(cclassname, CDebug) m_Debug;
        //#endif

        #else  // _MAC

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;
    #endif

    //#ifdef _MAC
    //#define CONSTRUCT_DEBUG
    //#else
    #define CONSTRUCT_DEBUG m_Debug(this),
    //#endif

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif __cplusplus

#endif !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\compobj.h ===
/*****************************************************************************\
*                                                                             *
* compobj.h - 	Component object model definitions							  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _COMPOBJ_H_ )
#define _COMPOBJ_H_

/****** Linkage Definitions *************************************************/

/*
 *      These are macros for declaring methods/functions.  They exist so that
 *      control over the use of keywords (CDECL, PASCAL, __export,
 *      extern "C") resides in one place, and because this is the least
 *      intrusive way of writing function declarations that do not have
 *      to be modified in order to port to the Mac.
 *
 *      The macros without the trailing underscore are for functions/methods
 *      which a return value of type HRESULT; this is by far the most common
 *      case in OLE. The macros with a trailing underscore take a return
 *      type as a parameter.
 *
 * WARNING: STDAPI is hard coded into the LPFNGETCLASSOBJECT typedef below.
 */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _MAC
#define STDMETHODCALLTYPE
#define STDAPICALLTYPE          pascal

#define STDAPI                  EXTERN_C STDAPICALLTYPE HRESULT
#define STDAPI_(type)           EXTERN_C STDAPICALLTYPE type

#else   //  !_MAC

#ifdef WIN32
#define STDMETHODCALLTYPE       __export __cdecl
#define STDAPICALLTYPE          __export __stdcall

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#else
#define STDMETHODCALLTYPE       __export FAR CDECL
#define STDAPICALLTYPE          __export FAR PASCAL

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#endif

#endif //!_MAC

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE


/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __TURBOC__
#define interface               struct huge
#else
#define interface               struct FAR
#endif
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface

#else
#define interface               struct

#ifdef _MAC

#define STDMETHOD(method)       long    method##pad;\
                                HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) long    method##pad;\
                                type (STDMETHODCALLTYPE * method)

#else // _MAC

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)

#endif // !_MAC

#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif


/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT   
#endif  // __cplusplus
#endif  // FARSTRUCT


#ifndef WINAPI          /* If not included with 3.1 headers... */

#ifdef WIN32
#define FAR
#define PASCAL          __stdcall
#define CDECL
#else
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#endif

#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;

typedef long LONG;
typedef unsigned long DWORD;


typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

typedef unsigned int HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name

DECLARE_HANDLE(HMODULE);
DECLARE_HANDLE(HINSTANCE);
DECLARE_HANDLE(HLOCAL);
DECLARE_HANDLE(HGLOBAL);
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HWND);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HTASK);

#ifndef NULL
#define NULL 0
#endif


typedef void FAR *      LPVOID;
typedef WORD FAR *      LPWORD;
typedef DWORD FAR *     LPDWORD;
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;
typedef void FAR*       LPLOGPALETTE;
typedef void FAR*       LPMSG;
//typedef struct tagMSG FAR *LPMSG;

typedef HANDLE FAR *LPHANDLE;
typedef struct tagRECT FAR *LPRECT;

typedef struct FARSTRUCT tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;


#endif  /* WINAPI */


typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;


#ifndef HUGEP
#ifdef WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP

typedef WORD WCHAR;

#ifndef WIN32
typedef struct FARSTRUCT _LARGE_INTEGER {
    DWORD LowPart;
    LONG  HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif
#define LISet32(li, v) ((li).HighPart = ((LONG)(v)) < 0 ? -1 : 0, (li).LowPart = (v))

#ifndef WIN32
typedef struct FARSTRUCT _ULARGE_INTEGER {
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
#endif
#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))

#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif

#ifdef WIN32
#define HTASK DWORD
#endif

#include "scode.h"



// *********************** Compobj errors **********************************

#define CO_E_NOTINITIALIZED         (CO_E_FIRST + 0x0)
// CoInitialize has not been called and must be

#define CO_E_ALREADYINITIALIZED     (CO_E_FIRST + 0x1)
// CoInitialize has already been called and cannot be called again (temporary)

#define CO_E_CANTDETERMINECLASS     (CO_E_FIRST + 0x2)
// can't determine clsid (e.g., extension not in reg.dat)

#define CO_E_CLASSSTRING            (CO_E_FIRST + 0x3)
// the string form of the clsid is invalid (including ole1 classes)

#define CO_E_IIDSTRING              (CO_E_FIRST + 0x4)
// the string form of the iid is invalid

#define CO_E_APPNOTFOUND            (CO_E_FIRST + 0x5)
// application not found

#define CO_E_APPSINGLEUSE           (CO_E_FIRST + 0x6)
// application cannot be run more than once

#define CO_E_ERRORINAPP             (CO_E_FIRST + 0x7)
// some error in the app program file

#define CO_E_DLLNOTFOUND            (CO_E_FIRST + 0x8)
// dll not found

#define CO_E_ERRORINDLL             (CO_E_FIRST + 0x9)
// some error in the dll file

#define CO_E_WRONGOSFORAPP          (CO_E_FIRST + 0xa)
// app written for other version of OS or other OS altogether

#define CO_E_OBJNOTREG              (CO_E_FIRST + 0xb)
// object is not registered

#define CO_E_OBJISREG               (CO_E_FIRST + 0xc)
// object is already registered

#define CO_E_OBJNOTCONNECTED        (CO_E_FIRST + 0xd)
// handler is not connected to server

#define CO_E_APPDIDNTREG            (CO_E_FIRST + 0xe)
// app was launched, but didn't registered a class factory


// ********************* ClassObject errors ********************************

#define CLASS_E_NOAGGREGATION       (CLASSFACTORY_E_FIRST + 0x0)
// class does not support aggregation (or class object is remote)

#define CLASS_E_CLASSNOTAVAILABLE   (CLASSFACTORY_E_FIRST + 0x1)
// dll doesn't support that class (returned from DllGetClassObject)


// *********************** Reg.dat errors **********************************

#define REGDB_E_READREGDB           (REGDB_E_FIRST + 0x0)
// some error reading the registration database

#define REGDB_E_WRITEREGDB          (REGDB_E_FIRST + 0x1)
// some error reading the registration database

#define REGDB_E_KEYMISSING          (REGDB_E_FIRST + 0x2)
// some error reading the registration database

#define REGDB_E_INVALIDVALUE        (REGDB_E_FIRST + 0x3)
// some error reading the registration database

#define REGDB_E_CLASSNOTREG         (REGDB_E_FIRST + 0x4)
// some error reading the registration database

#define REGDB_E_IIDNOTREG           (REGDB_E_FIRST + 0x5)
// some error reading the registration database


// *************************** RPC errors **********************************

#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)

// call was rejected by callee, either by MF::HandleIncomingCall or
#define RPC_E_CALL_REJECTED             (RPC_E_FIRST + 0x1)         

// call was canceld by call - returned by MessagePending
// this code only occurs if MessagePending return cancel
#define RPC_E_CALL_CANCELED             (RPC_E_FIRST + 0x2)         

// the caller is dispatching an intertask SendMessage call and 
// can NOT call out via PostMessage
#define RPC_E_CANTPOST_INSENDCALL       (RPC_E_FIRST + 0x3)             

// the caller is dispatching an asynchronus call can NOT 
// make an outgoing call on behalf of this call
#define RPC_E_CANTCALLOUT_INASYNCCALL   (RPC_E_FIRST + 0x4)         

// the caller is not in a state where an outgoing call can be made
// this is the case if the caller has an outstandig call and
// another incoming call was excepted by HIC; now the caller is
// not allowed to call out again
#define RPC_E_CANTCALLOUT_INEXTERNALCALL (RPC_E_FIRST + 0x5)                

// the connection terminated or is in a bogus state
// and can not be used any more. Other connections
// are still valid.
#define RPC_E_CONNECTION_TERMINATED     (RPC_E_FIRST + 0x6)         

// the callee (server [not server application]) is not available 
// and disappeared; all connections are invalid
#define RPC_E_SERVER_DIED               (RPC_E_FIRST + 0x7)         

// the caller (client ) disappeared while the callee (server) was 
// processing a call 
#define RPC_E_CLIENT_DIED               (RPC_E_FIRST + 0x8)         

// the date paket with the marshalled parameter data is
// incorrect 
#define RPC_E_INVALID_DATAPACKET        (RPC_E_FIRST + 0x9)         

// the call was not transmitted properly; the message queue 
// was full and was not emptied after yielding
#define RPC_E_CANTTRANSMIT_CALL         (RPC_E_FIRST + 0xa)         

// the client (caller) can not marshall the parameter data 
// or unmarshall the return data - low memory etc.
#define RPC_E_CLIENT_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xb)         
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xc)         

// the server (caller) can not unmarshall the parameter data
// or marshall the return data - low memory
#define RPC_E_SERVER_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xd)         
#define RPC_E_SERVER_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xe)         

// received data are invalid; can be server or 
// client data
#define RPC_E_INVALID_DATA              (RPC_E_FIRST + 0xf)         

// a particular parameter is invalid and can not be un/marshalled
#define RPC_E_INVALID_PARAMETER         (RPC_E_FIRST + 0x10)

// DDE conversation - no second outgoing call on same channel
#define RPC_E_CANTCALLOUT_AGAIN			(RPC_E_FIRST + 0x11)         

// a internal error occured 
#define RPC_E_UNEXPECTED                (RPC_E_FIRST + 0xFFFF)


/****** Globally Unique Ids *************************************************/
 
#ifdef __cplusplus

struct FAR GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];

    BOOL operator==(const GUID& iidOther) const

#ifdef WIN32
        { return !memcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#else        
        { return !_fmemcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#endif
    BOOL operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};

#else
typedef struct GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
} GUID;
#endif

typedef                GUID FAR* LPGUID;


// macros to define byte pattern for a GUID.  
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including compobj.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in compobj.dll.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of compobj.h and then include initguid.h 
// after compobj.h followed by one or more of the guid defintion files.


#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


// Interface ID are just a kind of GUID
typedef GUID IID;
typedef                IID FAR* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)


// Class ID are just a kind of GUID
typedef GUID CLSID;
typedef              CLSID FAR* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if defined(__cplusplus)
#define REFGUID             const GUID FAR&
#define REFIID              const IID FAR&
#define REFCLSID            const CLSID FAR&
#else
#define REFGUID             const GUID FAR* const
#define REFIID              const IID FAR* const
#define REFCLSID            const CLSID FAR* const
#endif


#ifndef INITGUID
#include "coguid.h"
#endif

/****** Other value types ***************************************************/

// memory context values; passed to CoGetMalloc
typedef enum tagMEMCTX
{
    MEMCTX_TASK = 1,            // task (private) memory
    MEMCTX_SHARED = 2,          // shared memory (between processes)
#ifdef _MAC
    MEMCTX_MACSYSTEM = 3,       // on the mac, the system heap
#endif 

    // these are mostly for internal use...
    MEMCTX_UNKNOWN = -1,        // unknown context (when asked about it)
    MEMCTX_SAME = -2,           // same context (as some other pointer)
} MEMCTX;



// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 1,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 2,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 4     // server exe (runs on same machine; diff proc)
} CLSCTX;

#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
								// and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
								// context.

	// NOTE: CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE is the same as
	// (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER), REGCLS_MULTI_SEPARATE, but
	// not the same as CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE.
} REGCLS;


// interface marshaling definitions
#define MARSHALINTERFACE_MIN 40 // minimum number of bytes for interface marshl

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2     // doesn't hold object alive; still must release
} MSHLFLAGS;

// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
} MSHCTX;


// call type used by IMessageFilter::HandleIncommingMessage
typedef enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,      // toplevel call - no outgoing call 
    CALLTYPE_NESTED   = 2,      // callback on behalf of previous outgoing call - should always handle
    CALLTYPE_ASYNC    = 3,      // aysnchronous call - can NOT be rejected
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,  // new toplevel call with new LID
    CALLTYPE_ASYNC_CALLPENDING    = 5   // async call - can NOT be rejected
} CALLTYPE;

typedef struct tagINTERFACEINFO 
{               
    interface IUnknown FAR *pUnk;       // the pointer to the object
    IID      			iid;            // interface id
    WORD        		wMethod;        // interface methode
} INTERFACEINFO, FAR * LPINTERFACEINFO;

// status of server call - returned by IMessageFilter::HandleIncommingCall
// and passed to  IMessageFilter::RetryRejectedCall
typedef enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED    = 0,
    SERVERCALL_REJECTED     = 1,
    SERVERCALL_RETRYLATER   = 2         
} SERVERCALL;


// Pending type indicates the level of nesting
typedef enum tagPENDINGTYPE
{   
    PENDINGTYPE_TOPLEVEL = 1,       // toplevel call
    PENDINGTYPE_NESTED   = 2,       // nested call
} PENDINGTYPE;

// return values of MessagePending
typedef enum tagPENDINGMSG
{   
    PENDINGMSG_CANCELCALL  = 0, // cancel the outgoing call
    PENDINGMSG_WAITNOPROCESS  = 1, // wait for the return and don't dispatch the message
    PENDINGMSG_WAITDEFPROCESS = 2  // wait and dispatch the message 
    
} PENDINGMSG;


// bit flags for IExternalConnection
typedef enum tagEXTCONN 
{
	EXTCONN_STRONG		= 0x0001	// strong connection
} EXTCONN;


/****** IUnknown Interface **************************************************/


#undef  INTERFACE
#define INTERFACE   IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
};

typedef        IUnknown FAR* LPUNKNOWN;


/****** Class Factory Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IClassFactory

DECLARE_INTERFACE_(IClassFactory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_ LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject) PURE;
    STDMETHOD(LockServer) (THIS_ BOOL fLock) PURE;

};
typedef       IClassFactory FAR* LPCLASSFACTORY;


/****** Memory Allocation Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ ULONG cb) PURE;
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, ULONG cb) PURE;
    STDMETHOD_(void, Free) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(ULONG, GetSize) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(void, HeapMinimize) (THIS) PURE;
};
typedef       IMalloc FAR* LPMALLOC;


/****** IMarshal Interface ************************************************/

// forward declaration for IStream; must include storage.h later to use
#ifdef __cplusplus
interface IStream;
#else
typedef interface IStream IStream;
#endif
typedef         IStream FAR* LPSTREAM;


#undef  INTERFACE
#define INTERFACE   IMarshal

DECLARE_INTERFACE_(IMarshal, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPCLSID pCid) PURE;
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPDWORD pSize) PURE;
    STDMETHOD(MarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags) PURE;
    STDMETHOD(UnmarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID FAR* ppv) PURE;
    STDMETHOD(ReleaseMarshalData)(THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved) PURE;
};
typedef         IMarshal FAR* LPMARSHAL;


#undef  INTERFACE
#define INTERFACE   IStdMarshalInfo

DECLARE_INTERFACE_(IStdMarshalInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStdMarshalInfo methods ***
    STDMETHOD(GetClassForHandler)(THIS_ DWORD dwDestContext, 
                        LPVOID pvDestContext, LPCLSID pClsid) PURE;
};
typedef         IStdMarshalInfo FAR* LPSTDMARSHALINFO;


/****** Message Filter Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IMessageFilter

DECLARE_INTERFACE_(IMessageFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMessageFilter methods ***
    STDMETHOD_(DWORD, HandleInComingCall) (THIS_ DWORD dwCallType,
                                HTASK htaskCaller, DWORD dwTickCount,
                                DWORD dwReserved ) PURE;
    STDMETHOD_(DWORD, RetryRejectedCall) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwRejectType ) PURE;
    STDMETHOD_(DWORD, MessagePending) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount, 
                                DWORD dwPendingType  ) PURE; 
};
typedef       IMessageFilter FAR* LPMESSAGEFILTER;


/****** External Connection Information ***********************************/

#undef  INTERFACE
#define INTERFACE   IExternalConnection

DECLARE_INTERFACE_(IExternalConnection, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExternalConnection methods ***
    STDMETHOD_(DWORD, AddConnection) (THIS_ DWORD extconn, DWORD reserved) PURE;
    STDMETHOD_(DWORD, ReleaseConnection) (THIS_ DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses) PURE;
};
typedef       IExternalConnection FAR* LPEXTERNALCONNECTION;


/****** Enumerator Interfaces *********************************************/

/*
 *  Since we don't use parametrized types, we put in explicit declarations
 *  of the enumerators we need.
 */


#undef  INTERFACE
#define INTERFACE   IEnumString

DECLARE_INTERFACE_(IEnumString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, 
                       LPSTR FAR* rgelt, 
                       ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumString FAR* FAR* ppenm) PURE;
};
typedef      IEnumString FAR* LPENUMSTRING;


#undef  INTERFACE
#define INTERFACE   IEnumUnknown

DECLARE_INTERFACE_(IEnumUnknown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUnknown methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPUNKNOWN FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumUnknown FAR* FAR* ppenm) PURE;
};
typedef         IEnumUnknown FAR* LPENUMUNKNOWN;


/****** STD Object API Prototypes *****************************************/

STDAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

STDAPI  CoInitialize(LPMALLOC pMalloc);
STDAPI_(void)  CoUninitialize(void);
STDAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
STDAPI_(DWORD) CoGetCurrentProcess(void);
STDAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/* register/revoke/get class objects */

STDAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
STDAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
STDAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
STDAPI CoReleaseMarshalData(LPSTREAM pStm);
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk, 
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

STDAPI_(HINSTANCE) CoLoadLibrary(LPSTR lpszLibName, BOOL bAutoFree);
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst);
STDAPI_(void) CoFreeAllLibraries(void);
STDAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */
STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2);
STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz);
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid);
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz);
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid);
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
STDAPI ProgIDFromCLSID (REFCLSID clsid, LPSTR FAR* lplpszProgID);
STDAPI CLSIDFromProgID (LPCSTR lpszProgID, LPCLSID lpclsid);
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPSTR lpsz, int cbMax);

STDAPI CoCreateGuid(GUID FAR *pguid);

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
STDAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


STDAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at 
 * the same time.
 */

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#endif


STDAPI  DllCanUnloadNow(void);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNCANUNLOADNOW)(void);
#endif


/****** Debugging Helpers *************************************************/

#ifdef _DEBUG
// writes to the debug port and displays a message box
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
#endif  //  _DEBUG

#endif // _COMPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#ifndef _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char __near __cdecl _ctype[];

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int __cdecl isalpha(int);
int __cdecl isupper(int);
int __cdecl islower(int);
int __cdecl isdigit(int);
int __cdecl isxdigit(int);
int __cdecl isspace(int);
int __cdecl ispunct(int);
int __cdecl isalnum(int);
int __cdecl isprint(int);
int __cdecl isgraph(int);
int __cdecl iscntrl(int);
int __cdecl toupper(int);
int __cdecl tolower(int);
int __cdecl _tolower(int);
int __cdecl _toupper(int);
int __cdecl __isascii(int);
int __cdecl __toascii(int);
int __cdecl __iscsymf(int);
int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif


/* the character classification macro definitions */

#define isalpha(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c)	( (_ctype+1)[_c] & _UPPER )
#define islower(_c)	( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c)	( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)	( (_ctype+1)[_c] & _HEX )
#define isspace(_c)	( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c)	( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c)	( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c)	( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c)	( (_ctype+1)[_c] & _CONTROL )
#ifndef __STDC__
#define toupper(_c)	( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c)	( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif
#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )
#define __isascii(_c)	( (unsigned)(_c) < 0x80 )
#define __toascii(_c)	( (_c) & 0x7f )

/* extended ctype macros */

#define __iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)	(isalnum(_c) || ((_c) == '_'))

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _CTYPE_DEFINED
int __cdecl isascii(int);
int __cdecl toascii(int);
int __cdecl iscsymf(int);
int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym
#endif
#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#define _INC_CTYPE
#endif	/* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\commdlg.h ===
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HWND    hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN 			0x00000001
#define FR_WHOLEWORD			0x00000002
#define FR_MATCHCASE			0x00000004
#define FR_FINDNEXT			0x00000008
#define FR_REPLACE			0x00000010
#define FR_REPLACEALL			0x00000020
#define FR_DIALOGTERM			0x00000040
#define FR_SHOWHELP			0x00000080
#define FR_ENABLEHOOK			0x00000100
#define FR_ENABLETEMPLATE		0x00000200
#define FR_NOUPDOWN			0x00000400
#define FR_NOMATCHCASE			0x00000800
#define FR_NOWHOLEWORD			0x00001000
#define FR_ENABLETEMPLATEHANDLE 	0x00002000
#define FR_HIDEUPDOWN			0x00004000
#define FR_HIDEMATCHCASE		0x00008000
#define FR_HIDEWHOLEWORD		0x00010000

HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

typedef struct tagCHOOSEFONT
{
    DWORD	    lStructSize;	/* */
    HWND	    hwndOwner;		/* caller's window handle   */
    HDC 	    hDC;		/* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int		    iPointSize;		/* 10 * size in points of selected font */
    DWORD	    Flags;		/* enum. type flags	    */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
					/* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
					 * contains cust. dlg. template
					 */
    LPSTR	    lpszStyle;		/* return the style field here 
					 * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
					 * call back with the extra FONTTYPE_ 
					 * bits added */
    int		    nSizeMin;		/* minimum pt size allowed & */
    int		    nSizeMax;		/* max pt size allowed if    */
					/* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS		     0x00000001
#define CF_PRINTERFONTS 	     0x00000002
#define CF_BOTH 		     (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP		     0x00000004L
#define CF_ENABLEHOOK		     0x00000008L
#define CF_ENABLETEMPLATE	     0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE		     0x00000080L
#define CF_EFFECTS		     0x00000100L
#define CF_APPLY		     0x00000200L
#define CF_ANSIONLY		     0x00000400L
#define CF_NOVECTORFONTS	     0x00000800L
#define CF_NOOEMFONTS		     CF_NOVECTORFONTS
#define CF_NOSIMULATIONS	     0x00001000L
#define CF_LIMITSIZE		     0x00002000L
#define CF_FIXEDPITCHONLY	     0x00004000L
#define CF_WYSIWYG		     0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST	     0x00010000L
#define CF_SCALABLEONLY		     0x00020000L
#define CF_TTONLY		     0x00040000L
#define CF_NOFACESEL		     0x00080000L
#define CF_NOSTYLESEL		     0x00100000L
#define CF_NOSIZESEL		     0x00200000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE	0x8000
#define PRINTER_FONTTYPE	0x4000
#define SCREEN_FONTTYPE		0x2000
#define BOLD_FONTTYPE		0x0100
#define ITALIC_FONTTYPE		0x0200
#define REGULAR_FONTTYPE	0x0400

#define WM_CHOOSEFONT_GETLOGFONT	(WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\debnot.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       DEBNOT.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#ifndef __DEBNOT_H__
#define __DEBNOT_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message BUGBUG: Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
#ifndef DEBFAR
#define DEBFAR
#endif
 #include <windef.h>
 #if WIN32 > 200
  #include <winnot.h>
 #endif
#else
#ifndef DEBFAR
#define DEBFAR __far
#endif
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const DEBFAR *pszComp,
       char const DEBFAR *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const DEBFAR *pszFile,
       int iLine,
       char const DEBFAR *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const DEBFAR *pszMsg,
       int iLine,
       char const DEBFAR *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x) if ( !(x) ) \
        Win4AssertEx ( __FILE__, __LINE__, #x );


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif


# if (WIN32 > 200) && defined(WIN32) && defined(__cplusplus) && !defined(KERNEL)
#  include <dbgpoint.hxx>
# endif

//+----------------------------------------------------------------------
//
// This next section makes for some really dense reading! Most of it is
// used for the debugging window. It defines some macros that make it
// easier to define debug groups and debug break points, since the macros
// expand to nothing if DEVL != 1. Check out dbgpoint.hxx for more info.
//
//
// The following macros allow you to do things like this
//
// DECLARE_GROUP(FooDebugingGroup)
//
// DECLARE_BREAKPOINT(FooBreakPoint,FooDebuggingGroup,FALSE)
//
// foo()
// {
//      TEST_BREAKPOINT(FooBreakPoint);
// }
//
//
//-----------------------------------------------------------------------

# if (WIN32 > 200) && defined(__cplusplus) && defined(WIN32) && !defined(KERNEL)

//
// The following class is used to register debug groups as static
// members. Its only needed when DBG is set.
//
//
// The easy way to declare a group, and have it registered for you
//
#  define DECLARE_GROUP(grpName) \
    CDebugGroupClass grpName ((L#grpName));

//
// The easy way to define a group in a header file for use cross module
//
#  define DEFINE_GROUP(grpName) extern CDebugGroupClass grpName;

//
// The easy way to declare a breakpoint is with the following macro.
//
#  define DECLARE_BREAKPOINT(Name,hGroup,fEnabled) \
    CDebugBreakPoint Name((L#Name),hGroup,fEnabled)

//
// If you need to have global access to a break point, use this in
// an include file
//

#  define DEFINE_BREAKPOINT(Name) \
    extern CDebugBreakPoint Name;


//
// A debug value is a class that allows you to wrap the contents of any
// integer value, and publish it in the debug window. The actual debug
// value keeps a reference to the actual value. Therefore, you can attach
// it to any long in the program.
//
// If you use the CDebugValue::SetValue() to change it, the change will
// be reflected in the window immediately.
//
// DECLARE_DEBUGVALUE( Name of Debug Value, Group, Reference to data object)
//
#  define DECLARE_DEBUGVALUE(Name,hGroup,Value) \
    CDebugValue Name((L#Name),hGroup,Value)

#  define DEFINE_DEBUGVALUE(Name) \
    extern CDebugValue Name;


//
// This is the same as above, only you can specify your own title for the
// debug value.
//
// DECLARE_DEBUGVALUEEX( Name of Debug Value, Title, Group, Reference to data object)
//
#  define DECLARE_DEBUGVALUEEX(Name,Title,hGroup,Value) \
    CDebugValue Name(Title,hGroup,Value)

//
// If you need to have global access to a break point, use this in
// an include file
//

#  define DEFINE_BREAKPOINT(Name) \
    extern CDebugBreakPoint Name;


//
// This test uses a default value for the HRESULT in the window. Use it
// when you don't have one. If you have an HRESULT you could display,
// please use TEST_BREAKPOINTHR
//

#  define TEST_BREAKPOINT(x) if( (x).BreakPointTest() && \
                         (x).BreakPointMessage(__FILE__,__LINE__) )\
                         { DebugBreak(); }

//
// This test includes an HRESULT as a parameter. You should use this one
//
#  define TEST_BREAKPOINTHR(x,hr) if( (x).BreakPointTest() && \
                         (x).BreakPointMessage(__FILE__,__LINE__,hr) )\
                         { DebugBreak(); }


#  define MAKE_CINFOLEVEL(comp) \
   CInfoLevel comp##CInfoLevel((L#comp),comp##InfoLevel);

# else   // (WIN32 > 200) && defined(__cplusplus) && defined(WIN32) && !defined(KERNEL)


//
// In the non debug version or C version, don't define these
//

#  define MAKE_CINFOLEVEL(comp)
#  define DECLARE_GROUP(Name)
#  define DEFINE_GROUP(Name)
#  define DEFINE_BREAKPOINT(Name)
#  define DECLARE_BREAKPOINT(Name,hGroup,fEnabled)
#  define TEST_BREAKPOINT(x)
#  define TEST_BREAKPOINTHR(x,hr)
#  define DECLARE_DEBUGVALUE(Name,hGroup,Value)
#  define DECLARE_DEBUGVALUEEX(Name,Title,hGroup,Value)
#  define DEFINE_DEBUGVALUE(Name)

# endif  // #if (WIN32 > 200) && defined(__cplusplus) && defined(WIN32) && !defined(KERNEL)


//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;\
        MAKE_CINFOLEVEL(comp)

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const DEBFAR *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const DEBFAR * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const DEBFAR * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const DEBFAR * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const DEBFAR *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)
# define Assert(x)                             // OBSOLETE!
# define Verify(x)     (x)                     // OBSOLETE!

# define MAKE_CINFOLEVEL(comp)
# define DECLARE_GROUP(Name)
# define DEFINE_GROUP(Name)
# define DEFINE_BREAKPOINT(Name)
# define DECLARE_BREAKPOINT(Name,hGroup,fEnabled)
# define TEST_BREAKPOINT(x)
# define TEST_BREAKPOINTHR(x,hr)
# define DECLARE_DEBUGVALUE(Name,hGroup,Value)
# define DECLARE_DEBUGVALUEEX(Name,Title,hGroup,Value)
# define DEFINE_DEBUGVALUE(Name)
# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0


//
// The following section adds the API's used for the performance snapshots
//


#if PERFSNAP == 1

#ifdef __cplusplus
extern "C" {
#endif

void _stdcall InitPerformanceMetering(char const DEBFAR * const);
void _stdcall Perfon(char const DEBFAR * const);
void _stdcall Perfsnap(char const DEBFAR * const, int const);
void _stdcall Perfcomment(char const DEBFAR * const s);
void _stdcall Perfdelta(char const DEBFAR * const, int const);
void _stdcall Perfoff(char const DEBFAR * const);
void _stdcall EndPerformanceMetering(char const DEBFAR * const);

#ifdef __cplusplus
}
#endif

#define PSNAPINIT(pszFileKey) InitPerformanceMetering(pszFileKey)
#define PSNAPEND() EndPerformanceMetering(NULL)
#define PSNAP(s) Perfsnap(s,0)
#define PSNAPL(s,l) Perfsnap(s,l)
#define PSNAPC(s) Perfcomment(s)
#define PSNAPDELTA(s) Perfdelta(s,0)
#define PSNAPDELTAL(s,l) Perfdelta(s,l)
#define PSNAPON(s) Perfon(s)
#define PSNAPOFF(s) Perfoff(s)

#else   // PERFSNAP == 1

#define InitPerformanceMetering(x)
#define Perfon(x)
#define Perfsnap(x,y)
#define Perfcomment(x)
#define Perfdelta(x,y)
#define Perfoff(x)
#define EndPerformanceMetering(x)

#define PSNAPINIT(pszFileKey)
#define PSNAPEND()
#define PSNAP(s)
#define PSNAPL(s,l)
#define PSNAPC(s)
#define PSNAPDELTA(s)
#define PSNAPDELTAL(s,l)
#define PSNAPON(s)
#define PSNAPOFF(s)

#endif


//
// If the sampling profiler is to be used, then here are its includes
//
//

#ifdef WIN32
#if (DBG == 1) || (RTLPROFILE == 1)

#ifdef __cplusplus
extern "C" {
#endif
void _stdcall InitSamplingProfiler(void);
void _stdcall EndSamplingProfiler(void);
#ifdef __cplusplus
}
#endif


#define INITSAMPLINGPROFILER    InitSamplingProfiler()
#define ENDSAMPLINGPROFILER     EndSamplingProfiler()

#else   // RTLPROFILE == 1

#define INITSAMPLINGPROFILER
#define ENDSAMPLINGPROFILER

#endif  // RTLPROFILE == 1
#endif  // WIN32

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\limits.h ===
/***
*limits.h - implementation dependent values
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains defines for a number of implementation dependent values
*	which are commonly used in C programs.
*	[ANSI]
*
****/

#ifndef _INC_LIMITS

#define CHAR_BIT	  8		/* number of bits in a char */
#define SCHAR_MIN	(-127)		/* minimum signed char value */
#define SCHAR_MAX	  127		/* maximum signed char value */
#define UCHAR_MAX	  0xff		/* maximum unsigned char value */
#ifndef _CHAR_UNSIGNED
#define CHAR_MIN	SCHAR_MIN	/* mimimum char value */
#define CHAR_MAX	SCHAR_MAX	/* maximum char value */
#else
#define CHAR_MIN	  0
#define CHAR_MAX	UCHAR_MAX
#ifndef __cplusplus
unsigned int _charmax;			/* unsigned CHAR_MAX value */
#else
extern "C" unsigned int _charmax;	/* unsigned CHAR_MAX value */
static unsigned int *_char_max = &_charmax;
#endif
#endif
#define	MB_LEN_MAX	  2		/* max. # bytes in multibyte char */
#define SHRT_MIN	(-32767)	/* minimum (signed) short value */
#define SHRT_MAX	  32767 	/* maximum (signed) short value */
#define USHRT_MAX	  0xffff	/* maximum unsigned short value */
#define INT_MIN 	(-32767)	/* minimum (signed) int value */
#define INT_MAX 	  32767 	/* maximum (signed) int value */
#define UINT_MAX	  0xffff	/* maximum unsigned int value */
#define LONG_MIN	(-2147483647)	/* minimum (signed) long value */
#define LONG_MAX	  2147483647	/* maximum (signed) long value */
#define ULONG_MAX	  0xffffffff	/* maximum unsigned long value */

#define _INC_LIMITS
#endif	/* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -	Definitions for controlling GUID initialization				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This 
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#pragma error "initguid: must include compobj.h first."
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\moniker.h ===
/*****************************************************************************\
*                                                                             *
* moniker.h - 	Moniker and related interfaces and APIs						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _MONIKER_H_ )
#define _MONIKER_H_

#define MK_E_CONNECTMANUALLY        MK_E_FIRST
#define MK_E_EXCEEDEDDEADLINE       (MK_E_FIRST + 1)
#define MK_E_NEEDGENERIC            (MK_E_FIRST + 2)
#define MK_E_UNAVAILABLE            (MK_E_FIRST + 3)
#define MK_E_SYNTAX                 (MK_E_FIRST + 4)
#define MK_E_NOOBJECT               (MK_E_FIRST + 5)
#define MK_E_INVALIDEXTENSION       (MK_E_FIRST + 6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED (MK_E_FIRST + 7)
#define MK_E_NOTBINDABLE            (MK_E_FIRST + 8)
#define MK_E_NOTBOUND               (MK_E_FIRST + 9)
                            // called IBindCtx->RevokeObjectBound for an
                            // object which was not bound
#define MK_E_CANTOPENFILE           (MK_E_FIRST + 10)
#define MK_E_MUSTBOTHERUSER         (MK_E_FIRST + 11)
#define MK_E_NOINVERSE              (MK_E_FIRST + 12)
#define MK_E_NOSTORAGE              (MK_E_FIRST + 13)
#define MK_E_NOPREFIX               (MK_E_FIRST + 14)


// reserved                     MK_S_FIRST
// reserved                     (MK_S_FIRST + 1)
#define MK_S_REDUCED_TO_SELF    (MK_S_FIRST + 2)
// reserved                     (MK_S_FIRST + 3)
#define MK_S_ME                 (MK_S_FIRST + 4)
#define MK_S_HIM                (MK_S_FIRST + 5)
#define MK_S_US                 (MK_S_FIRST + 6)
#define MK_S_MONIKERALREADYREGISTERED (MK_S_FIRST + 7)


// bind options; variable sized
typedef struct FARSTRUCT tagBIND_OPTS
{
    DWORD       cbStruct;       //  sizeof(BIND_OPTS)
    DWORD       grfFlags;
    DWORD       grfMode;
    DWORD       dwTickCountDeadline;
} BIND_OPTS, FAR* LPBIND_OPTS;


// bind flags; controls binding; stored in bind options above
typedef enum
{
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2
} BIND_FLAGS;


// system moniker types; returned from IsSystemMoniker.
typedef enum tagMKSYS
{
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5
}MKSYS;


// bit wise enum to control how much reduction takes place.
typedef enum tagMKREDUCE
{
    MKRREDUCE_ONE           =   3<<16,
    MKRREDUCE_TOUSER        =   2<<16,
    MKRREDUCE_THROUGHUSER   =   1<<16,
    MKRREDUCE_ALL           =   0
} MKRREDUCE;


#if defined(__cplusplus)
interface IEnumMoniker;
interface IRunningObjectTable;
#else 
typedef interface IEnumMoniker IEnumMoniker;
typedef interface IRunningObjectTable IRunningObjectTable;
#endif

typedef       IEnumMoniker FAR* LPENUMMONIKER;
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IBindCtx

DECLARE_INTERFACE_(IBindCtx, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBindCtx methods ***
    STDMETHOD(RegisterObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(RevokeObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(ReleaseBoundObjects) (THIS) PURE;
    
    STDMETHOD(SetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetRunningObjectTable) (THIS_ LPRUNNINGOBJECTTABLE  FAR*
        pprot) PURE;
    STDMETHOD(RegisterObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN punk) PURE;
    STDMETHOD(GetObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHOD(EnumObjectParam) (THIS_ LPENUMSTRING FAR* ppenum) PURE;
    STDMETHOD(RevokeObjectParam) (THIS_ LPSTR lpszKey) PURE;
};
typedef             IBindCtx FAR* LPBC;
typedef         IBindCtx FAR* LPBINDCTX;



#undef  INTERFACE
#define INTERFACE   IMoniker

DECLARE_INTERFACE_(IMoniker, IPersistStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) PURE;

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID FAR* ppvResult) PURE;
    STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
        ppmkToLeft, LPMONIKER FAR * ppmkReduced) PURE;
    STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER FAR* ppmkComposite) PURE;
    STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
        PURE;
    STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker) PURE;
    STDMETHOD(Hash) (THIS_ LPDWORD pdwHash) PURE;
    STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
        pmkNewlyRunning) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR* pfiletime) PURE;
    STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(CommonPrefixWith) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix) PURE;
    STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath) PURE;
    STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR lpszDisplayName, ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut) PURE;
    STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys) PURE;
};
typedef         IMoniker FAR* LPMONIKER;


//  IRunningObjectTable::Register flags
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 1

#undef  INTERFACE
#define INTERFACE   IRunningObjectTable

DECLARE_INTERFACE_(IRunningObjectTable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRunningObjectTable methods ***
    STDMETHOD(Register) (THIS_ DWORD grfFlags, LPUNKNOWN punkObject, 
        LPMONIKER pmkObjectName, DWORD FAR * pdwRegister) PURE;
    STDMETHOD(Revoke) (THIS_ DWORD dwRegister) PURE;
    STDMETHOD(IsRunning) (THIS_ LPMONIKER pmkObjectName) PURE;
    STDMETHOD(GetObject) (THIS_ LPMONIKER pmkObjectName,
        LPUNKNOWN FAR* ppunkObject) PURE;
    STDMETHOD(NoteChangeTime) (THIS_ DWORD dwRegister, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPMONIKER pmkObjectName, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(EnumRunning) (THIS_ LPENUMMONIKER FAR * ppenumMoniker ) PURE;
};
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IEnumMoniker

DECLARE_INTERFACE_(IEnumMoniker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOleDataObject methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPMONIKER FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumMoniker FAR* FAR* ppenm) PURE;
};
typedef       IEnumMoniker FAR* LPENUMMONIKER;




STDAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
STDAPI  MkParseDisplayName(LPBC pbc, LPSTR szUserName, 
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL fCalledFromMethod);
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
STDAPI  GetClassFile (LPCSTR szFilename, CLSID FAR* pclsid);

STDAPI  CreateFileMoniker(LPSTR lpszPathName, LPMONIKER FAR* ppmk);
STDAPI  CreateItemMoniker(LPSTR lpszDelim, LPSTR lpszItem,
    LPMONIKER FAR* ppmk);
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);


#endif  // _MONIKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ole2dbg.h ===
/*
	ole2dbg.h:	This header file contains the function declarations for the publicly
	exported debugging interfaces.

	Include *after* standard OLE2 includes.
	
	Copyright (c) 1992-1993, Microsoft Corp. All rights reserved.
*/

#ifndef __OLE2DBG_H
#define __OLE2DBG_H

STDAPI_(void) DbgDumpObject( IUnknown FAR * pUnk, DWORD dwReserved);
STDAPI_(void) DbgDumpExternalObject( IUnknown FAR * pUnk, DWORD dwReserved );

STDAPI_(BOOL) DbgIsObjectValid( IUnknown FAR * pUnk );
STDAPI_(void) DbgDumpClassName( IUnknown FAR * pUnk );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#ifndef _INC_MEMORY

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
	int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
	size_t);
void * __cdecl memcpy(void *, const void *,
	size_t);
int __cdecl _memicmp(const void *, const void *,
	unsigned int);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
	int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
	size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
	size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
	unsigned int);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
	int, unsigned int);
int __cdecl memicmp(const void *, const void *,
	unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
#endif

#ifdef __cplusplus
}
#endif

#define _INC_MEMORY
#endif	/* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ole2anac.h ===
// ole2anac.h - anachronisms for pre-release code

#if !defined( _OLE2ANAC_H_ )
#define _OLE2ANAC_H_

#define IIDEQ(riid1, riid2) IsEqualIID(riid1, riid2)
#define CLSIDEQ(rclsid1, rclsid2) IsEqualCLSID(rclsid1, rclsid2)

#define RetryRejectedCall RetryRejectedMessage

#define FileTimeToDosDateTime(pft,pdd,pdt) CoFileTimeToDosDateTime(pft,pdd,pdt)
#define DosDateTimeToFileTime(pdd,pdt,pft) CoDosDateTimeToFileTime(pdd,pdt,pft)

typedef enum tagSTGSTATE
{
    STGSTATE_DOC         = 1,
    STGSTATE_CONVERT     = 2,
    STGSTATE_FILESTGSAME = 4
} STGSTATE;


#define MK_E_EXCEEDED_DEADLINE      MK_E_EXCEEDEDDEADLINE
#define MK_E_NEED_GENERIC           MK_E_NEEDGENERIC
#define MK_E_INVALID_EXTENSION      MK_E_INVALIDEXTENSION 
#define MK_E_INTERMEDIATE_INTERFACE_NOT_SUPPORTED \
    MK_E_INTERMEDIATEINTERFACENONOT_SUPPORTED
#define MK_E_NOT_BINDABLE           MK_E_NOTBINDABLE 
#define S_TRUE                      S_OK


#define OLEMETHODCALLTYPE       STDMETHODCALLTYPE
#define OLEAPICALLTYPE          STDAPICALLTYPE

#define OLEAPI                  STDAPI
#define OLEAPI_(type)           STDAPI_(type)

#define OLEMETHOD(method)       STDMETHOD(method)
#define OLEMETHOD_(type,method) STDMETHOD_(type,method)

#define OLEMETHODIMP            STDMETHODIMP
#define OLEMETHODIMP_(type)     STDMETHODIMP_(type)

#define OLESTATIC_(type) static type __export
#define OLESTATICIMP_(type) type __export


#define E_BLANK             OLE_E_BLANK
#define E_STATIC            OLE_E_STATIC
#define E_NOTRUNNING        OLE_E_NOTRUNNING
#define E_FORMAT            DV_E_CLIPFORMAT
#define E_UNSPEC            E_FAIL
#define OLE_E_CLSID         REGDB_E_CLASSNOTREG
#define OLE_E_NOTSUPPORTED  E_NOTIMPL
#define OLE_E_REGDB_KEY     REGDB_E_KEYMISSING
#define OLE_E_REGDB_FMT     REGDB_E_INVALIDVALUE


#define OLEVERB_PRIMARY     OLEIVERB_PRIMARY
#define OLEVERB_SHOW        OLEIVERB_SHOW

#define DAdvise Advise
#define DUnadvise Unadvise
#define EnumDAdvise EnumAdvise


// these DDE error codes are not returned anymore; these definitions are
// here just to make existing code compile without changes.
#define RPC_E_DDE_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x100)

#define RPC_E_DDE_BUSY              (RPC_E_DDE_FIRST + 0x0)         
#define RPC_E_DDE_CANT_UPDATE       (RPC_E_DDE_FIRST + 0x1)
#define RPC_E_DDE_INIT              (RPC_E_DDE_FIRST + 0x2)
#define RPC_E_DDE_NACK              E_FAIL
#define RPC_E_DDE_LAUNCH            CO_E_APPNOTFOUND
#define RPC_E_DDE_POST              RPC_E_SERVER_DIED
#define RPC_E_DDE_PROTOCOL          (RPC_E_DDE_FIRST + 0x6)
#define RPC_E_DDE_REVOKE            (RPC_E_DDE_FIRST + 0x7)
#define RPC_E_DDE_SYNTAX_EXECUTE    RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_SYNTAX_ITEM       RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_UNEXP_MSG     	(RPC_E_DDE_FIRST + 0xa)
#define RPC_E_DDE_DATA              RPC_E_INVALID_PARAMETER


#define RPC_E_CONNECTION_LOST           (RPC_E_FIRST + 0x6)         
#define RPC_E_BUSY                      (RPC_E_FIRST + 0x0)         
#define RPC_E_MSG_REJECTED              (RPC_E_FIRST + 0x1)         
#define RPC_E_CANCELLED                 (RPC_E_FIRST + 0x2)         
#define RPC_E_DISPATCH_ASYNCCALL        (RPC_E_FIRST + 0x4)         


#endif // _OLE2ANAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ole2.h ===
/*****************************************************************************\
*                                                                             *
* ole2.h - 		Main OLE2 header; includes all subcomponents				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _OLE2_H_ )
#define _OLE2_H_

#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif  /* RC_INVOKED */

#include <string.h>

/****** Standard Object Definitions *****************************************/

#include <compobj.h>


// *************** FACILITY_ITF scodes common to all interfaces ************
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//

// error codes

#define OLE_E_OLEVERB               (OLE_E_FIRST)
// invalid OLEVERB structure  

#define OLE_E_ADVF                  (OLE_E_FIRST+1)
// invalid advise flags

#define OLE_E_ENUM_NOMORE           (OLE_E_FIRST+2)
// you can't enuemrate any more, because the associated data is missing

#define OLE_E_ADVISENOTSUPPORTED    (OLE_E_FIRST+3)
// this implementation doesn't take advises

#define OLE_E_NOCONNECTION          (OLE_E_FIRST+4)
// there is no connection for this connection id

#define OLE_E_NOTRUNNING            (OLE_E_FIRST+5)
// need run the object to perform this operation

#define OLE_E_NOCACHE               (OLE_E_FIRST+6)
// there is no cache to operate on

#define OLE_E_BLANK                 (OLE_E_FIRST+7)
// Uninitialized object

#define OLE_E_CLASSDIFF             (OLE_E_FIRST+8)
// linked object's source class has changed 

#define OLE_E_CANT_GETMONIKER       (OLE_E_FIRST+9)
// not able to get the moniker of the object

#define OLE_E_CANT_BINDTOSOURCE     (OLE_E_FIRST+10)
// not able to bind to the source

#define OLE_E_STATIC                (OLE_E_FIRST+11)
// object is static, operation not allowed

#define OLE_E_PROMPTSAVECANCELLED   (OLE_E_FIRST+12)
// user cancelled out of save dialog

#define OLE_E_INVALIDRECT           (OLE_E_FIRST+13)
// invalid rectangle 

#define OLE_E_WRONGCOMPOBJ          (OLE_E_FIRST+14)
// compobj.dll is too old for the ole2.dll initialized

#define OLE_E_INVALIDHWND           (OLE_E_FIRST+15)
// invalid window handle

#define OLE_E_NOT_INPLACEACTIVE     (OLE_E_FIRST+16)
// object is not in any of the inplace active states  

#define OLE_E_CANTCONVERT			(OLE_E_FIRST+17)
// not able to convert the object 

#define OLE_E_NOSTORAGE				(OLE_E_FIRST+18)
// not able to perform the operation because object is not given storage yet.
 

#define DVGEN_E_FIRST               (OLE_E_FIRST+100)

#define DV_E_FORMATETC              (DVGEN_E_FIRST)
// invalid FORMATETC structure

#define DV_E_DVTARGETDEVICE         (DVGEN_E_FIRST+1)
// invalid DVTARGETDEVICE structure

#define DV_E_STGMEDIUM              (DVGEN_E_FIRST+2)
// invalid STDGMEDIUM structure

#define DV_E_STATDATA               (DVGEN_E_FIRST+3)
// invalid STATDATA structure

#define DV_E_LINDEX                 (DVGEN_E_FIRST+4)
// invalid lindex

#define DV_E_TYMED                  (DVGEN_E_FIRST+5)
// invalid tymed

#define DV_E_CLIPFORMAT             (DVGEN_E_FIRST+6)
// invalid clipboard format

#define DV_E_DVASPECT               (DVGEN_E_FIRST+7)
// invalid aspect(s) 

#define DV_E_DVTARGETDEVICE_SIZE    (DVGEN_E_FIRST+8)
// tdSize paramter of the DVTARGETDEVICE structure is invalid

#define DV_E_NOIVIEWOBJECT          (DVGEN_E_FIRST+9)
// object doesn't support IViewObject interface


// Success codes

#define OLE_S_USEREG                (OLE_S_FIRST)
// use the reg database to provide the requested info

#define OLE_S_STATIC                (OLE_S_FIRST+1)
// success, but static 

#define OLE_S_MAC_CLIPFORMAT        (OLE_S_FIRST+2)
// macintosh clipboard format

//*************************** Interface or API specific scodes *************

// Errors for OleConvertOLESTREAMToIStorage and OleConvertIStorageToOLESTREAM

// OLESTREAM Get method failed
#define CONVERT10_E_OLESTREAM_GET       (CONVERT10_E_FIRST + 0)

// OLESTREAM Put method failed
#define CONVERT10_E_OLESTREAM_PUT       (CONVERT10_E_FIRST + 1)

// Contents of the OLESTREAM not in correct format
#define CONVERT10_E_OLESTREAM_FMT       (CONVERT10_E_FIRST + 2)

// There was in an error in a Windows GDI call while converting the bitmap
// to a DIB.
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB (CONVERT10_E_FIRST + 3)

// Contents of the IStorage not in correct format
#define CONVERT10_E_STG_FMT             (CONVERT10_E_FIRST + 4)

// Contents of IStorage is missing one of the standard streams ("\1CompObj", 
// "\1Ole", "\2OlePres000").  This may be the storage for a DLL object, or a
// class that does not use the def handler.
#define CONVERT10_E_STG_NO_STD_STREAM   (CONVERT10_E_FIRST + 5)

// There was in an error in a Windows GDI call while converting the DIB
// to a bitmap.
#define CONVERT10_E_STG_DIB_TO_BITMAP   (CONVERT10_E_FIRST + 6)


// Returned by either API, this scode indicates that the original object
//  had no presentation, therefore the converted object does not either.
#define CONVERT10_S_NO_PRESENTATION     (CONVERT10_S_FIRST + 0)


// Errors for Clipboard functions

// OpenClipboard Failed
#define CLIPBRD_E_CANT_OPEN     (CLIPBRD_E_FIRST + 0)

// EmptyClipboard Failed
#define CLIPBRD_E_CANT_EMPTY        (CLIPBRD_E_FIRST + 1)

// SetClipboard Failed
#define CLIPBRD_E_CANT_SET          (CLIPBRD_E_FIRST + 2)

// Data on clipboard is invalid
#define CLIPBRD_E_BAD_DATA          (CLIPBRD_E_FIRST + 3)

// CloseClipboard Failed
#define CLIPBRD_E_CANT_CLOSE        (CLIPBRD_E_FIRST + 4)


/****** OLE value types *****************************************************/

/* rendering options */
typedef enum tagOLERENDER
{
    OLERENDER_NONE   = 0, 
    OLERENDER_DRAW   = 1, 
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS   = 3
} OLERENDER;
typedef  OLERENDER FAR* LPOLERENDER;

// OLE verb; returned by IEnumOLEVERB
typedef struct FARSTRUCT tagOLEVERB
{
    LONG    lVerb;
    LPSTR   lpszVerbName;
    DWORD   fuFlags;
    DWORD	grfAttribs;
} OLEVERB, FAR* LPOLEVERB;


// Bitwise verb attributes used in OLEVERB.grfAttribs
typedef enum tagOLEVERBATTRIB // bitwise
{
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2
} OLEVERBATTRIB;


// IOleObject::GetUserType optons; determines which form of the string to use
typedef enum tagUSERCLASSTYPE
{
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT= 2,
    USERCLASSTYPE_APPNAME= 3,
} USERCLASSTYPE;


// bits returned from IOleObject::GetMistStatus
typedef enum tagOLEMISC // bitwise
{
    OLEMISC_RECOMPOSEONRESIZE				= 1,
    OLEMISC_ONLYICONIC						= 2,
    OLEMISC_INSERTNOTREPLACE				= 4,
    OLEMISC_STATIC							= 8,
    OLEMISC_CANTLINKINSIDE					= 16,
    OLEMISC_CANLINKBYOLE1					= 32,
    OLEMISC_ISLINKOBJECT					= 64,
    OLEMISC_INSIDEOUT						= 128,
    OLEMISC_ACTIVATEWHENVISIBLE				= 256,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT	= 512	
} OLEMISC;


// IOleObject::Close options
typedef enum tagOLECLOSE
{
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE      = 1,
    OLECLOSE_PROMPTSAVE  = 2
} OLECLOSE;


// IOleObject::GetMoniker and IOleClientSite::GetMoniker options; determines
// if and how monikers should be assigned.
typedef enum tagOLEGETMONIKER
{
    OLEGETMONIKER_ONLYIFTHERE=1,
    OLEGETMONIKER_FORCEASSIGN=2,
    OLEGETMONIKER_UNASSIGN=3,
    OLEGETMONIKER_TEMPFORUSER=4 
} OLEGETMONIKER;


// IOleObject::GetMoniker, IOleObject::SetMoniker and 
// IOleClientSite::GetMoniker options; determines which moniker to use
typedef enum tagOLEWHICHMK
{
    OLEWHICHMK_CONTAINER=1,
    OLEWHICHMK_OBJREL=2,
    OLEWHICHMK_OBJFULL=3
} OLEWHICHMK;


#ifdef WIN32
#define LPSIZEL PSIZEL
#else
typedef struct FARSTRUCT tagSIZEL
{
    long cx;
    long cy;
} SIZEL, FAR* LPSIZEL;
#endif


#ifdef WIN32
#define LPRECTL PRECTL
#else
typedef struct FARSTRUCT tagRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
} RECTL, FAR* LPRECTL;

typedef struct FARSTRUCT tagPOINTL {
    LONG x;
    LONG y;
} POINTL;

#endif
   

#ifndef LPCRECT
typedef const RECT FAR* LPCRECT;
#endif

#ifndef LPCRECTL
typedef const RECTL FAR* LPCRECTL;
#endif


// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L // role is handler; implementation is 
										 // default handler; pCF can be NULL
#define EMBDHLP_INPROC_SERVER    0x0001L // role is server; pCF can't be NULL

#define EMBDHLP_CREATENOW    0x00000000L // create using pCF immediately; if pCF
										 // is NULL, uses std remoting handler
#define EMBDHLP_DELAYCREATE  0x00010000L // delayed create; must supply pCF


// NOTE: OleCreateEmbeddingHelper(clsid, pUnkOuter, 
// 		EMBDHLP_INPROC_HANDLER | EMBDHLP_CREATENOW, NULL, riid, lplpObj) 
// is the same as OleCreateDefaultHandler(clsid, pUnkOuter, riid, lplpObj);
// i.e., the embedding helper is the default handler in various roles.


/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM FAR*  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;


/****** Clipboard Data structures *****************************************/

typedef struct tagOBJECTDESCRIPTOR
{
   ULONG    cbSize;              // Size of structure in bytes
   CLSID    clsid;               // CLSID of data being transferred
   DWORD    dwDrawAspect;        // Display aspect of the object
                                 //     normally DVASPECT_CONTENT or ICON.
                                 //     dwDrawAspect will be 0 (which is NOT
                                 //     DVASPECT_CONTENT) if the copier or 
                                 //     dragsource didn't draw the object to 
                                 //     begin with.
   SIZEL    sizel;               // size of the object in HIMETRIC
                                 //    sizel is opt.: will be (0,0) for apps
                                 //    which don't draw the object being
                                 //    transferred
   POINTL   pointl;              // Offset in HIMETRIC units from the
                                 //    upper-left corner of the obj where the
                                 //    mouse went down for the drag.
                                 //    NOTE: y coordinates increase downward.
                                 //          x coordinates increase to right
                                 //    pointl is opt.; it is only meaningful 
                                 //    if object is transfered via drag/drop.
                                 //    (0, 0) if mouse position is unspecified
                                 //    (eg. when obj transfered via clipboard)
   DWORD    dwStatus;            // Misc. status flags for object. Flags are 
                                 //    defined by OLEMISC enum. these flags 
                                 //    are as would be returned
                                 //    by IOleObject::GetMiscStatus.
   DWORD    dwFullUserTypeName;  // Offset from beginning of structure to 
                                 //    null-terminated string that specifies 
                                 //    Full User Type Name of the object. 
                                 //    0 indicates string not present.
   DWORD    dwSrcOfCopy;         // Offset from beginning of structure to 
                                 //    null-terminated string that specifies
                                 //    source of the transfer. 
                                 //    dwSrcOfCOpy is normally implemented as 
                                 //    the display name of the temp-for-user 
                                 //    moniker which identifies the source of 
                                 //    the data. 
                                 //    0 indicates string not present.
                                 //    NOTE: moniker assignment is NOT forced.
                                 //    see IOleObject::GetMoniker(
                                 //                OLEGETMONIKER_TEMPFORUSER)

 /* variable sized string data may appear here */

} OBJECTDESCRIPTOR,  *POBJECTDESCRIPTOR,  FAR *LPOBJECTDESCRIPTOR,
  LINKSRCDESCRIPTOR, *PLINKSRCDESCRIPTOR, FAR *LPLINKSRCDESCRIPTOR;



/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)


//      forward type declarations
#if defined(__cplusplus)
interface IOleClientSite;
interface IOleContainer;
interface IOleObject;
#else 
typedef interface IOleClientSite IOleClientSite;
typedef interface IOleContainer IOleContainer;
typedef interface IOleObject IOleObject;
#endif

typedef         IOleObject FAR* LPOLEOBJECT;
typedef     IOleClientSite FAR* LPOLECLIENTSITE;
typedef       IOleContainer FAR* LPOLECONTAINER;


/****** OLE GUIDs *********************************************************/

#ifndef INITGUID
#include "oleguid.h"
#endif


/****** Other Major Interfaces ********************************************/

#include <dvobj.h>

#include <storage.h>



/****** IDrop??? Interfaces ********************************************/

#define MK_ALT 0x0020


#define DROPEFFECT_NONE     0
#define DROPEFFECT_COPY     1
#define DROPEFFECT_MOVE     2
#define DROPEFFECT_LINK     4
#define DROPEFFECT_SCROLL   0x80000000

// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
#define DD_DEFSCROLLINSET		11

// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
#define DD_DEFSCROLLDELAY		50

// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval",
//                              DD_DEFSCROLLINTERVAL)
#define DD_DEFSCROLLINTERVAL	50

// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
#define DD_DEFDRAGDELAY     	200

// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
#define DD_DEFDRAGMINDIST		2



/* Dragdrop specific error codes */

#define DRAGDROP_E_NOTREGISTERED        (DRAGDROP_E_FIRST)
// trying to revoke a drop target that has not been registered 

#define DRAGDROP_E_ALREADYREGISTERED    (DRAGDROP_E_FIRST+1)
// this window has already been registered as a drop target

#define DRAGDROP_E_INVALIDHWND          (DRAGDROP_E_FIRST+2)
// invalid HWND


#define DRAGDROP_S_DROP                 (DRAGDROP_S_FIRST + 0)
// successful drop took place 

#define DRAGDROP_S_CANCEL               (DRAGDROP_S_FIRST + 1)
// drag-drop operation canceled

#define DRAGDROP_S_USEDEFAULTCURSORS    (DRAGDROP_S_FIRST + 2)
// use the default cursor


#undef INTERFACE
#define INTERFACE   IDropTarget

DECLARE_INTERFACE_(IDropTarget, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragOver) (THIS_ DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragLeave) (THIS) PURE;
    STDMETHOD(Drop) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
};
typedef         IDropTarget FAR* LPDROPTARGET;



#undef INTERFACE
#define INTERFACE   IDropSource

DECLARE_INTERFACE_(IDropSource, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropSource methods ***
    STDMETHOD(QueryContinueDrag) (THIS_ BOOL fEscapePressed, DWORD grfKeyState) PURE;
    STDMETHOD(GiveFeedback) (THIS_ DWORD dwEffect) PURE;
};
typedef         IDropSource FAR* LPDROPSOURCE;



/****** IPersist??? Interfaces ********************************************/


#undef INTERFACE
#define INTERFACE   IPersist

DECLARE_INTERFACE_(IPersist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
};
typedef            IPersist FAR* LPPERSIST;



#undef INTERFACE
#define INTERFACE   IPersistStorage

DECLARE_INTERFACE_(IPersistStorage, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStorage methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(InitNew) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Load) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Save) (THIS_ LPSTORAGE pStgSave, BOOL fSameAsLoad) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPSTORAGE pStgNew) PURE;
    STDMETHOD(HandsOffStorage) (THIS) PURE; 
};
typedef         IPersistStorage FAR* LPPERSISTSTORAGE;



#undef INTERFACE
#define INTERFACE   IPersistStream

DECLARE_INTERFACE_(IPersistStream, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR* pcbSize) PURE;
};
typedef          IPersistStream FAR* LPPERSISTSTREAM;



#undef INTERFACE
#define INTERFACE   IPersistFile

DECLARE_INTERFACE_(IPersistFile, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
    
    // *** IPersistFile methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPCSTR lpszFileName, DWORD grfMode) PURE;
    STDMETHOD(Save) (THIS_ LPCSTR lpszFileName, BOOL fRemember) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPCSTR lpszFileName) PURE;
    STDMETHOD(GetCurFile) (THIS_ LPSTR FAR* lplpszFileName) PURE;
};
typedef            IPersistFile FAR* LPPERSISTFILE;

  
/****** Moniker Object Interfaces ******************************************/

#include <moniker.h>


/****** OLE Object Interfaces ******************************************/
  
 
#undef  INTERFACE
#define INTERFACE   IEnumOLEVERB

DECLARE_INTERFACE_(IEnumOLEVERB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumOLEVERB FAR* FAR* ppenm) PURE;
};
typedef         IEnumOLEVERB FAR* LPENUMOLEVERB;




#undef  INTERFACE
#define INTERFACE   IOleObject

#define OLEOBJ_E_NOVERBS                (OLEOBJ_E_FIRST + 0)

#define OLEOBJ_E_INVALIDVERB            (OLEOBJ_E_FIRST + 1)

#define OLEOBJ_S_INVALIDVERB            (OLEOBJ_S_FIRST + 0)

#define OLEOBJ_S_CANNOT_DOVERB_NOW      (OLEOBJ_S_FIRST + 1)
// verb number is valid but verb cannot be done now, for instance
// hiding a link or hiding a visible OLE 1.0 server

#define OLEOBJ_S_INVALIDHWND            (OLEOBJ_S_FIRST + 2)
// invalid hwnd passed


DECLARE_INTERFACE_(IOleObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite) (THIS_ LPOLECLIENTSITE pClientSite) PURE;
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR* ppClientSite) PURE;
    STDMETHOD(SetHostNames) (THIS_ LPCSTR szContainerApp, LPCSTR szContainerObj) PURE;
    STDMETHOD(Close) (THIS_ DWORD dwSaveOption) PURE;
    STDMETHOD(SetMoniker) (THIS_ DWORD dwWhichMoniker, LPMONIKER pmk) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(InitFromData) (THIS_ LPDATAOBJECT pDataObject,
                BOOL fCreation,
                DWORD dwReserved) PURE;
    STDMETHOD(GetClipboardData) (THIS_ DWORD dwReserved, 
                LPDATAOBJECT FAR* ppDataObject) PURE;
    STDMETHOD(DoVerb) (THIS_ LONG iVerb,
                LPMSG lpmsg, 
                LPOLECLIENTSITE pActiveSite, 
                LONG lindex,
                HWND hwndParent,
                LPCRECT lprcPosRect) PURE;
    STDMETHOD(EnumVerbs) (THIS_ LPENUMOLEVERB FAR* ppenumOleVerb) PURE;
    STDMETHOD(Update) (THIS) PURE;
    STDMETHOD(IsUpToDate) (THIS) PURE;
    STDMETHOD(GetUserClassID) (THIS_ CLSID FAR* pClsid) PURE;
    STDMETHOD(GetUserType) (THIS_ DWORD dwFormOfType, LPSTR FAR* pszUserType) PURE;
    STDMETHOD(SetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;

    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
    STDMETHOD(GetMiscStatus) (THIS_ DWORD dwAspect, DWORD FAR* pdwStatus) PURE;
    STDMETHOD(SetColorScheme) (THIS_ LPLOGPALETTE lpLogpal) PURE;
};
typedef      IOleObject FAR* LPOLEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleClientSite

DECLARE_INTERFACE_(IOleClientSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject) (THIS) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer) PURE;   
    STDMETHOD(ShowObject) (THIS) PURE;  
    STDMETHOD(OnShowWindow) (THIS_ BOOL fShow) PURE;    
    STDMETHOD(RequestNewObjectLayout) (THIS) PURE;      
};
typedef      IOleClientSite FAR* LPOLECLIENTSITE;


/****** OLE Runnable Object Interface **********************************/

#undef  INTERFACE
#define INTERFACE	IRunnableObject

DECLARE_INTERFACE_(IRunnableObject, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IRunnableObject methods ***
    STDMETHOD(GetRunningClass) (THIS_ LPCLSID lpClsid) PURE;
    STDMETHOD(Run) (THIS_ LPBINDCTX pbc) PURE;
    STDMETHOD_(BOOL, IsRunning) (THIS) PURE;
	STDMETHOD(LockRunning)(THIS_ BOOL fLock, BOOL fLastUnlockCloses) PURE;
	STDMETHOD(SetContainedObject)(THIS_ BOOL fContained) PURE;
};
typedef      IRunnableObject FAR* LPRUNNABLEOBJECT;


/****** OLE Container Interfaces ***************************************/
  

#undef  INTERFACE
#define INTERFACE   IParseDisplayName

DECLARE_INTERFACE_(IParseDisplayName, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;
};
typedef       IParseDisplayName FAR* LPPARSEDISPLAYNAME;


#undef  INTERFACE
#define INTERFACE   IOleContainer

DECLARE_INTERFACE_(IOleContainer, IParseDisplayName)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) ( DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
};
typedef IOleContainer FAR* LPOLECONTAINER;


typedef enum tagBINDSPEED
{
    BINDSPEED_INDEFINITE    = 1,
    BINDSPEED_MODERATE      = 2,
    BINDSPEED_IMMEDIATE     = 3
} BINDSPEED;

typedef enum tagOLECONTF
{
    OLECONTF_EMBEDDINGS     =  1,
    OLECONTF_LINKS          =  2,
    OLECONTF_OTHERS         =  4,
    OLECONTF_ONLYUSER       =  8,
    OLECONTF_ONLYIFRUNNING  = 16
} OLECONTF;


#undef  INTERFACE
#define INTERFACE   IOleItemContainer

DECLARE_INTERFACE_(IOleItemContainer, IOleContainer)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) (THIS_ DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
    
    // *** IOleItemContainer methods ***
    STDMETHOD(GetObject) (THIS_ LPSTR lpszItem, DWORD dwSpeedNeeded,
        LPBINDCTX pbc, REFIID riid, LPVOID FAR* ppvObject) PURE;
    STDMETHOD(GetObjectStorage) (THIS_ LPSTR lpszItem, LPBINDCTX pbc,
        REFIID riid, LPVOID FAR* ppvStorage) PURE;
    STDMETHOD(IsRunning) (THIS_ LPSTR lpszItem) PURE;
};
typedef       IOleItemContainer FAR* LPOLEITEMCONTAINER;


/****** OLE Advise Holder Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IOleAdviseHolder

DECLARE_INTERFACE_(IOleAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD(SendOnSave)(THIS) PURE;
    STDMETHOD(SendOnClose)(THIS) PURE;
};
typedef      IOleAdviseHolder FAR* LPOLEADVISEHOLDER;


/****** OLE Link Interface ************************************************/

/* Link update options */
typedef enum tagOLEUPDATE
{
    OLEUPDATE_ALWAYS=1,
    OLEUPDATE_ONCALL=3
} OLEUPDATE;
typedef  OLEUPDATE FAR* LPOLEUPDATE;


// for IOleLink::BindToSource
typedef enum tagOLELINKBIND
{
    OLELINKBIND_EVENIFCLASSDIFF = 1,
} OLELINKBIND;


#undef  INTERFACE
#define INTERFACE   IOleLink

DECLARE_INTERFACE_(IOleLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleLink methods ***
    STDMETHOD(SetUpdateOptions) (THIS_ DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetUpdateOptions) (THIS_ LPDWORD pdwUpdateOpt) PURE;
    STDMETHOD(SetSourceMoniker) (THIS_ LPMONIKER pmk, REFCLSID rclsid) PURE;
    STDMETHOD(GetSourceMoniker) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(SetSourceDisplayName) (THIS_ LPCSTR lpszDisplayName) PURE;
    STDMETHOD(GetSourceDisplayName) (THIS_ LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(BindToSource) (THIS_ DWORD bindflags, LPBINDCTX pbc) PURE;
    STDMETHOD(BindIfRunning) (THIS) PURE;
    STDMETHOD(GetBoundSource) (THIS_ LPUNKNOWN FAR* ppUnk) PURE;
    STDMETHOD(UnbindSource) (THIS) PURE;
    STDMETHOD(Update) (THIS_ LPBINDCTX pbc) PURE;
};
typedef         IOleLink FAR* LPOLELINK;


/****** OLE InPlace Editing Interfaces ************************************/
  
#ifdef _MAC
typedef Handle  HOLEMENU;
typedef long    SIZE;
typedef long    HACCEL;
#else
DECLARE_HANDLE(HOLEMENU);
#endif  

typedef struct FARSTRUCT tagOIFI          // OleInPlaceFrameInfo
{
    UINT    cb;
    BOOL    fMDIApp;
    HWND    hwndFrame;
    HACCEL  haccel;
    int     cAccelEntries;
} OLEINPLACEFRAMEINFO, FAR* LPOLEINPLACEFRAMEINFO;


typedef struct FARSTRUCT tagOleMenuGroupWidths
{
    LONG    width[6];
} OLEMENUGROUPWIDTHS, FAR* LPOLEMENUGROUPWIDTHS;

typedef RECT    BORDERWIDTHS;
typedef LPRECT  LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;

/* Inplace editing specific error codes */

#define INPLACE_E_NOTUNDOABLE   (INPLACE_E_FIRST)
// undo is not avaiable

#define INPLACE_E_NOTOOLSPACE       (INPLACE_E_FIRST+1)
// Space for tools is not available

#define INPLACE_S_TRUNCATED     (INPLACE_S_FIRST)
// Message is too long, some of it had to be truncated before displaying

//misc definitions
#define INPLACE_DEFBORDERWIDTH	4

//      forward type declarations
#if defined(__cplusplus)
interface IOleInPlaceUIWindow;
#else 
typedef interface IOleInPlaceUIWindow IOleInPlaceUIWindow;
#endif

typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;


#undef  INTERFACE
#define INTERFACE   IOleWindow

DECLARE_INTERFACE_(IOleWindow, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
};

typedef         IOleWindow FAR* LPOLEWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceObject

DECLARE_INTERFACE_(IOleInPlaceObject, IOleWindow)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceObject methods ***
    STDMETHOD(InPlaceDeactivate) (THIS) PURE;   
    STDMETHOD(UIDeactivate) (THIS) PURE;
    STDMETHOD(SetObjectRects) (THIS_ LPCRECT lprcPosRect, 
                    LPCRECT lprcClipRect) PURE;
    STDMETHOD(ReactivateAndUndo) (THIS) PURE;   
};
typedef         IOleInPlaceObject FAR* LPOLEINPLACEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceActiveObject

DECLARE_INTERFACE_(IOleInPlaceActiveObject, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceActiveObject methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;   
    STDMETHOD(OnFrameWindowActivate) (THIS_ BOOL fActivate) PURE;           
    STDMETHOD(OnDocWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(ResizeBorder) (THIS_ LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow) PURE;          
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};
typedef         IOleInPlaceActiveObject FAR* LPOLEINPLACEACTIVEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceUIWindow

DECLARE_INTERFACE_(IOleInPlaceUIWindow, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                        LPCSTR lpszObjName) PURE; 
};
typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceFrame

DECLARE_INTERFACE_(IOleInPlaceFrame, IOleInPlaceUIWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                    LPCSTR lpszObjName) PURE; 
    
    
    // *** IOleInPlaceFrame methods ***
    STDMETHOD(InsertMenus) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenu) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenus) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusText) (THIS_ LPCSTR lpszStatusText) PURE;    
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg, WORD wID) PURE;
};
typedef     IOleInPlaceFrame FAR* LPOLEINPLACEFRAME;


#undef  INTERFACE
#define INTERFACE   IOleInPlaceSite

DECLARE_INTERFACE_(IOleInPlaceSite, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceSite methods ***
    STDMETHOD(CanInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnUIActivate) (THIS) PURE;    
    STDMETHOD(GetWindowContext) (THIS_ LPOLEINPLACEFRAME FAR* lplpFrame,
                        LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                        LPRECT lprcPosRect,
                        LPRECT lprcClipRect,
                        LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
    STDMETHOD(Scroll) (THIS_ SIZE scrollExtent) PURE;       
    STDMETHOD(OnUIDeactivate) (THIS_ BOOL fUndoable) PURE;      
    STDMETHOD(OnInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(DiscardUndoState) (THIS) PURE;
    STDMETHOD(DeactivateAndUndo) (THIS) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcPosRect) PURE; 
};
typedef         IOleInPlaceSite FAR* LPOLEINPLACESITE;



/****** OLE API Prototypes ************************************************/

STDAPI_(DWORD) OleBuildVersion( VOID );

/* helper functions */
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid);
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid);
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid);
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPSTR lpszUserType);
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPSTR FAR* lplpszUserType);


/* init/term */

STDAPI OleInitialize(LPMALLOC pMalloc);
STDAPI_(void) OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from 
   the data object */

STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);
                    

/* Object creation APIs */

STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt, 
                LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite, 
                LPSTORAGE pStg, LPVOID FAR* ppvObj); 

STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);    

                
STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);
            
STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite, 
            LPVOID FAR* ppvObj);
            
STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
STDAPI  RevokeDragDrop(HWND hwnd);
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj);
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);
STDAPI  OleFlushClipboard(void);
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

STDAPI_(HOLEMENU)   OleCreateMenuDescriptor (HMENU hmenuCombined, 
                                LPOLEMENUGROUPWIDTHS lpMenuWidths);
STDAPI              OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
STDAPI              OleDestroyMenuDescriptor (HOLEMENU holemenu);

STDAPI              OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame, 
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);
                                
                                    
/* Helper APIs */
STDAPI_(HANDLE) OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat, 
                        UINT uiFlags);

STDAPI          OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, 
                    LPCRECT lprcBounds); 
                        
STDAPI          OleRun(LPUNKNOWN pUnknown);
STDAPI_(BOOL)   OleIsRunning(LPOLEOBJECT pObject);
STDAPI          OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);

STDAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM);
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder);

STDAPI          OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    REFIID riid, LPVOID FAR* lplpObj);

STDAPI          OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    DWORD flags, LPCLASSFACTORY pCF,
					REFIID riid, LPVOID FAR* lplpObj);
					
STDAPI_(BOOL)	IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, 
					WORD FAR* lpwCmd);

					
/* Icon extraction Helper APIs */
					
STDAPI_(HGLOBAL) OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel);

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid,	LPSTR lpszLabel, 
					BOOL fUseTypeAsLabel);

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPSTR lpszLabel,
					LPSTR lpszSourceFile, UINT iIconIndex);


					
/* Registration Database Helper APIs */

STDAPI 			OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
					LPSTR FAR* pszUserType);

STDAPI 			OleRegGetMiscStatus	(REFCLSID clsid, DWORD dwAspect,
					DWORD FAR* pdwStatus);

STDAPI 			OleRegEnumFormatEtc	(REFCLSID clsid, DWORD dwDirection,
					LPENUMFORMATETC FAR* ppenum);

STDAPI 			OleRegEnumVerbs	(REFCLSID clsid, LPENUMOLEVERB FAR* ppenum);



/* OLE 1.0 conversion APIS */

STDAPI OleConvertIStorageToOLESTREAM
    (LPSTORAGE			pstg,
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                polestm,
     LPSTORAGE                  pstg,
     const DVTARGETDEVICE FAR*  ptd);

STDAPI OleConvertIStorageToOLESTREAMEx
    (LPSTORAGE			pstg,
									// Presentation data to OLESTREAM
	 CLIPFORMAT			cfFormat,	//		format
	 LONG				lWidth,		//		width
	 LONG				lHeight,	//		height
	 DWORD				dwSize,		//		size in bytes
     LPSTGMEDIUM		pmedium,	//		bits
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorageEx
    (LPOLESTREAM		polestm,
	 LPSTORAGE			pstg,
									// Presentation data from OLESTREAM
	 CLIPFORMAT FAR*	pcfFormat,	//		format
	 LONG FAR*			plwWidth,	//		width
	 LONG FAR*			plHeight,	//		height
	 DWORD FAR*			pdwSize,	//		size in bytes
	 LPSTGMEDIUM		pmedium);	//		bits



/* Storage Utility APIs */
STDAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL FAR* phglobal);
STDAPI CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES FAR* pplkbyt);

STDAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL FAR* phglobal);
STDAPI CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM FAR* ppstm);


/* ConvertTo APIS */

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);
STDAPI GetConvertStg(LPSTORAGE pStg);
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


#endif // _OLE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\map_kv.h ===
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);

DECLARE_HANDLE32(HMAPKEY);
typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class __export CMapKeyToValue
{
public:
	CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey = 0, 
		int nBlockSize=10, LPFNHASHKEY lpfnHashKey = &MKVDefaultHashKey,
		UINT nHashSize = 17);
	~CMapKeyToValue();

	// number of elements
	int     GetCount() const { return m_nCount; }
	BOOL    IsEmpty() const { return m_nCount == 0; }

	// Lookup; return FALSE if not found
	BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
	BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
	BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

	// add a new (key, value) pair; return FALSE if out of memory
	BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
	BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

	// removing existing (key, ?) pair; return FALSE if no such key
	BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
	BOOL    RemoveHKey(HMAPKEY hKey);
	void    RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
			{ return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
	void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey, 
				UINT FAR* pcbKey, LPVOID pValue) const;

	// return HMAPKEY for given key; returns NULL if not currently in map
	HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

	void    AssertValid() const;

private:
	// abstracts, somewhat, variable and fixed sized keys; size is really
	// m_cbKeyInAssoc.
	union CKeyWrap
	{
		BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
		struct
		{
			LPVOID pKey;
			UINT cbKey;
		};
	};

	// Association of one key and one value; NOTE: even though in general
	// the size of the key and value varies, for any given map,
	// the size of an assoc is fixed.
	struct CAssoc 
	{
		CAssoc  FAR* pNext;
		UINT    nHashValue; // needed for efficient iteration
		CKeyWrap key;		// size is really m_cbKeyInAssoc
		// BYTE rgbValue[m_cbValue];
	};

	UINT	SizeAssoc() const
		{ return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
	CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
	void    FreeAssoc(CAssoc FAR* pAssoc);
	BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
	CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

	BOOL	SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
	void	GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
	void	FreeAssocKey(CAssoc FAR* pAssoc) const;
	void	GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
	void	GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
	void	SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

	BOOL	InitHashTable();

	UINT	m_cbValue;
	UINT	m_cbKey;			// variable length if 0
	UINT	m_cbKeyInAssoc;		// always non-zero

	CAssoc  FAR* FAR* m_pHashTable;
	UINT    m_nHashTableSize;
	LPFNHASHKEY m_lpfnHashKey;

	int     m_nCount;
	CAssoc  FAR* m_pFreeList;
	struct CPlex FAR* m_pBlocks;
	int     m_nBlockSize;
	DWORD	m_memctx;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ole2ver.h ===
#define rmj		0
#define rmm		23
#define rup		640
#define szVerName	""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ole2int.h ===
/*
 *  This is the internal ole2 header, which means it contains those
 *  interfaces which might eventually be exposed to the outside
 *  and which will be exposed to our implementations. We don't want
 *  to expose these now, so I have put them in a separate file.
 */

#if !defined( _OLE2INT_H_ )
#define _OLE2INT_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING OLE2INT.H from " __FILE__)
#endif  /* RC_INVOKED */

// ------------------------------------
// system includes
#include <string.h>
#include <StdLib.h>

#include <windows.h>
#include <shellapi.h>



#define GetCurrentThread()  GetCurrentTask()
#define GetCurrentProcess() GetCurrentTask()
#define GetWindowThread(h)  GetWindowTask(h)
#define LocalHandle(p) LocalHandle((UINT)(p))
#define SETPVTBL(Name)


// ------------------------------------
// public includes
#include <ole2anac.h>
#include <ole2.h>
#include <ole2sp.h>

// ------------------------------------
// internal includes
#include <utils.h>
#include <olecoll.h>
#include <valid.h>
#include <map_kv.h>
#include <privguid.h>

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#if defined(_M_I86SM) || defined(_M_I86MM)
#define _NEARDATA
#endif

#include <utstream.h>

/*
 *      Warning disables:
 *
 *      We compile with warning level 4, with the following warnings
 *      disabled:
 *
 *      4355: 'this' used in base member initializer list
 *
 *              We don't see the point of this message and we do this all
 *              the time.
 *
 *      4505: Unreferenced local function has been removed -- the given
 *      function is local and not referenced in the body of the module.
 *
 *              Unfortunately, this is generated for every inline function
 *              seen in the header files that is not used in the module.
 *              Since we use a number of inlines, this is a nuisance
 *              warning.  It would be nice if the compiler distinguished
 *              between inlines and regular functions.
 *
 *      4706: Assignment within conditional expression.
 *
 *              We use this style of programming extensively, so this
 *              warning is disabled.
 */

#pragma warning(disable:4355)
#pragma warning(disable:4068)
/*
 *      MACROS for Mac/PC core code
 *
 *      The following macros reduce the proliferation of #ifdefs.  They
 *      allow tagging a fragment of code as Mac only, PC only, or with
 *      variants which differ on the PC and the Mac.
 *
 *      Usage:
 *
 *
 *      h = GetHandle();
 *      Mac(DisposeHandle(h));
 *
 *
 *      h = GetHandle();
 *      MacWin(h2 = h, CopyHandle(h, h2));
 *
 */
#define Mac(x)
#define Win(x) x
#define MacWin(x,y) y



// Macros for Double-Byte Character Support
// Beware of double evaluation
#define IncLpch(sz)          ((sz)=CharNext ((sz)))
#define DecLpch(szStart, sz) ((sz)=CharPrev ((szStart),(sz)))

/* dlls instance and module handles */

extern HMODULE          hmodOLE2;

/* Variables for registered clipboard formats */

extern  CLIPFORMAT   cfObjectLink;
extern  CLIPFORMAT   cfOwnerLink;
extern  CLIPFORMAT   cfNative;
extern  CLIPFORMAT   cfLink;
extern  CLIPFORMAT   cfBinary;
extern  CLIPFORMAT   cfFileName;
extern  CLIPFORMAT   cfNetworkName;
extern  CLIPFORMAT   cfDataObject;
extern  CLIPFORMAT   cfEmbeddedObject;
extern  CLIPFORMAT   cfEmbedSource;
extern  CLIPFORMAT   cfLinkSource;
extern  CLIPFORMAT   cfOleDraw;
extern  CLIPFORMAT   cfLinkSrcDescriptor;
extern  CLIPFORMAT   cfObjectDescriptor;
extern  CLIPFORMAT       cfCustomLinkSource;
extern  CLIPFORMAT       cfPBrush;
extern  CLIPFORMAT       cfMSDraw;


/* Number of logical pixels per inch for current driver */
extern  int     giPpliX;
extern  int             giPpliY;


/* Exported CLSIDs.. */
#define CLSID_StaticMetafile    CLSID_Picture_Metafile
#define CLSID_StaticDib                 CLSID_Picture_Dib


// special Assert for asserts below (since the expression is so large)
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, _szAssertFile, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
        AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(char)) || \
        FAILED(hr) && (p) == NULL, \
        szBadOutParam)

#define AssertOutPtrIface(hr, p) \
        AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
        FAILED(hr) && (p) == NULL, \
        szBadOutIface)

#define AssertOutPtrFailed(p) \
        AssertOut((p) == NULL, \
        szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
        AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
        FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
        szBadOutStgm)


// assert data for above assert out macros; once per dll
#define ASSERTOUTDATA \
        char szCheckOutParam[] = "check out param"; \
        char szBadOutParam[] = "Out pointer param conventions not followed"; \
        char szBadOutIface[] = "Out pointer interface conventions not followed"; \
        char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
        char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


/***********************************************************************/
/****                   C++ memory management                                                       ****/
/***********************************************************************/


// these should never be called (and assert if they are)
void * operator new(size_t size);
void operator delete(void * ptr);



void FAR* operator new(size_t size);            // same as new (MEMCTX_TASK)
void FAR* operator new(size_t size, DWORD memctx, void FAR* lpvSame=NULL);
void operator delete(void FAR* ptr);

// example usage:
//              lp = new(MEMCTX_TASK) CClass;
//              lp = new(MEMCTX_SHARED) CClass;
//              lp = new(MEMCTX_SAME, lpv) CClass;

// MEMCTX for compobj internal memory (only used by compobj code)
// NOTE: this value is not represented in the MEMCTX enum in compobj.h
#define MEMCTX_COPRIVATE 5

// exports from compobj.dll:
// returns MEMCTX of existing pointer
STDAPI_(DWORD) CoMemctxOf(void const FAR* lpv);
STDAPI_(void FAR*) CoMemAlloc(ULONG cb ,DWORD memctx, void FAR* lpvSame);
STDAPI_(void) CoMemFree(void FAR* lpv, DWORD memctx);


// old names
#define MemoryPlacement DWORD
#define PlacementOf     CoMemctxOf
#define TASK                    MEMCTX_TASK, NULL
#define SHARED                  MEMCTX_SHARED, NULL
#define SAME                    MEMCTX_SAME, NULL


/***********************************************************************/
/****                   FILE FORMAT RELATED INFO                                                        ****/
/***********************************************************************/

// Coponent object stream information

#define COMPOBJ_STREAM                          "\1CompObj"
#define BYTE_ORDER_INDICATOR            0xfffe    // for MAC it could be different
#define COMPOBJ_STREAM_VERSION          0x0001

// OLE defines values for different OSs
#define OS_WIN                                          0x0000
#define OS_MAC                                          0x0001
#define OS_NT                                           0x0002

// HIGH WORD is OS indicator, LOW WORD is OS version number
extern  DWORD   gdwOrgOSVersion;
extern  DWORD  gdwOleVersion;


// Ole streams information
#define OLE_STREAM                                      "\1Ole"
#define OLE_PRODUCT_VERSION                     0x0200          // (HIGH BYTE major version)
#define OLE_STREAM_VERSION                      0x0001

#define OLE10_NATIVE_STREAM                     "\1Ole10Native"
#define OLE10_ITEMNAME_STREAM           "\1Ole10ItemName"
#define OLE_PRESENTATION_STREAM         "\2OlePres000"
#define CONTENTS_STREAM                         "CONTENTS"

/***********************************************************************
                                Storage APIs internally used
*************************************************************************/

OLEAPI  ReadClipformatStm(LPSTREAM lpstream, DWORD FAR* lpdwCf);
OLEAPI  WriteClipformatStm(LPSTREAM lpstream, CLIPFORMAT cf);

OLEAPI WriteMonikerStm (LPSTREAM pstm, LPMONIKER pmk);
OLEAPI ReadMonikerStm (LPSTREAM pstm, LPMONIKER FAR* pmk);

OLEAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem);
OLEAPI_(LPSTREAM) CloneMemStm(HANDLE hMem);
OLEAPI_(void)     ReleaseMemStm (LPHANDLE hMem, BOOL fInternalOnly = FALSE);

/*************************************************************************
                        Initialization code for individual modules
*************************************************************************/

INTERNAL_(void) DDEWEP (
    BOOL fSystemExit
);

INTERNAL_(BOOL) DDELibMain (
        HANDLE  hInst,
        WORD    wDataSeg,
        WORD    cbHeapSize,
        LPSTR   lpszCmdLine
);

BOOL    InitializeRunningObjectTable(void);
void    DestroyRunningObjectTable(void);

#define BITMAP_TO_DIB(foretc) \
        if (foretc.cfFormat == CF_BITMAP) {\
                foretc.cfFormat = CF_DIB;\
                foretc.tymed = TYMED_HGLOBAL;\
        }


#define VERIFY_ASPECT_SINGLE(dwAsp) {\
        if (!(dwAsp && !(dwAsp & (dwAsp-1)) && (dwAsp <= DVASPECT_DOCPRINT))) {\
                AssertSz(FALSE, "More than 1 aspect is specified");\
                return ResultFromScode(DV_E_DVASPECT);\
        }\
}


#define VERIFY_TYMED_SINGLE(tymed) {\
        if (!(tymed && !(tymed & (tymed-1)) && (tymed <= TYMED_MFPICT))) \
                return ResultFromScode(DV_E_TYMED); \
}


#define VERIFY_TYMED_SINGLE_VALID_FOR_CLIPFORMAT(pfetc) {\
        if ((pfetc->cfFormat==CF_METAFILEPICT && pfetc->tymed!=TYMED_MFPICT)\
                        || (pfetc->cfFormat==CF_BITMAP && pfetc->tymed!=TYMED_GDI)\
                        || (pfetc->cfFormat!=CF_METAFILEPICT && \
                                pfetc->cfFormat!=CF_BITMAP && \
                                pfetc->tymed!=TYMED_HGLOBAL))\
                return ResultFromScode(DV_E_TYMED); \
}




// REVIEW ...
// Only DDE layer will test for these values. And only for advises on cached
// formats do we use these values

#define ADVFDDE_ONSAVE          0x40000000
#define ADVFDDE_ONCLOSE         0x80000000


// Used in Ole Private Stream
typedef enum tagOBJFLAGS
{
        OBJFLAGS_LINK=1L,
        OBJFLAGS_DOCUMENT=2L,           // this bit is owned by container and is
                                                                // propogated through saves
        OBJFLAGS_CONVERT=4L,
} OBJFLAGS;



/*****************************************
 Prototypes for dde\client\ddemnker.cpp
******************************************/

INTERNAL DdeBindToObject
        (LPCSTR  szFile,
        REFCLSID clsid,
        BOOL       fPackageLink,
        LPBC pbc,                         // not used
        LPMONIKER pmkToLeft,  // not used
        REFIID   iid,
        LPLPVOID ppv);

INTERNAL DdeIsRunning
        (CLSID clsid,
        LPCSTR szFile,
        LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning);


/**************************************
 Prototypes for moniker\mkparse.cpp
***************************************/

INTERNAL Ole10_ParseMoniker
        (LPMONIKER pmk,
        LPSTR FAR* pszFile,
        LPSTR FAR* pszItem);


/****************************************************************************/
/*                              Utility APIs, might get exposed later                                           */
/****************************************************************************/

OLEAPI  OleGetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetcIn,
                                                LPSTGMEDIUM pmedium, BOOL fGetOwnership);
OLEAPI  OleSetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetc,
                                                STGMEDIUM FAR * pmedium, BOOL fRelease);
STDAPI  OleDuplicateMedium(LPSTGMEDIUM lpMediumSrc, LPSTGMEDIUM lpMediumDest);

OLEAPI_(BOOL)    OleIsDcMeta (HDC hdc);

INTERNAL SzFixNet( LPBINDCTX pbc, LPSTR szUNCName, LPSTR FAR * lplpszReturn,
    UINT FAR * pEndServer, BOOL fForceConnection = TRUE);

FARINTERNAL ReadFmtUserTypeProgIdStg
        (IStorage FAR * pstg,
        CLIPFORMAT FAR* pcf,
        LPSTR FAR* pszUserType,
        LPSTR    szProgID);

/****************************************************************************/
/*                              Internal StubManager APIs, might get exposed later                      */
/****************************************************************************/
OLEAPI  CoDisconnectWeakExternal(IUnknown FAR* pUnk, DWORD dwReserved);


#pragma warning(disable: 4073) // disable warning about using init_seg
#pragma init_seg(lib)
#endif  //      _OLE2INT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\map_htsk.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapHandleEtask
{
public:
	// Construction
	CMapHandleEtask(DWORD memctx, UINT nBlockSize=10) 
		: m_mkv(memctx, sizeof(Etask), sizeof(HTASK), nBlockSize) { }
	CMapHandleEtask(DWORD memctx, UINT nBlockSize, UINT nHashTableSize) 
		: m_mkv(memctx, sizeof(Etask), sizeof(HTASK), nBlockSize,
			&MKVDefaultHashKey, nHashTableSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(HTASK key, Etask FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(HTASK), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, Etask FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(HTASK key, Etask FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(HTASK), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(HTASK key, Etask& value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(HTASK), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, Etask& value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(HTASK key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(HTASK)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, HTASK FAR& rKey, Etask FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(HTASK key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(HTASK)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\olecoll.h ===
// Microsoft OLE library.
// Copyright (C) 1992 Microsoft Corporation,
// All rights reserved.

// olecoll.h - global defines for collections and element definitions

#ifndef __OLECOLL_H__
#define __OLECOLL_H__


// ---------------------------------------------------------------------------
// general defines for collections

typedef void FAR* POSITION;

#define BEFORE_START_POSITION ((POSITION)(ULONG)-1L)
#define _AFX_FP_OFF(thing) (*((UINT FAR*)&(thing)))
#define _AFX_FP_SEG(lp) (*((UINT FAR*)&(lp)+1))

#ifdef _DEBUG
#define ASSERT_VALID(p) p->AssertValid()
#else
#define ASSERT_VALID(p)
#endif


// ---------------------------------------------------------------------------
// element defintions; can only depend upon definitions in ole2int.h

// per-task data; warning, there is no destructor and so
// releasing the elements of the mapping must be done by hand;
// this also means that RemoveAll should not be called and that
// RemoveKey should be called only after freeing the contained maps.
typedef struct FAR Etask
{
	DWORD m_pid;						// unique process id
	DWORD m_Dllinits;						// number of times init'd
	HTASK m_htask;
	DWORD m_inits;						// number of times init'd
	DWORD m_oleinits;					// number of OleInit
	DWORD m_reserved;					// reserved
	IMalloc FAR* m_pMalloc;				// task allocator (always one)
	IMalloc FAR* m_pMallocShared;		// shared allocator (always one)
	IMalloc FAR* m_pMallocSBlock;		// shared block allocator (if one)
	IMalloc FAR* m_pMallocPrivate;		// private allocator (if one)
	class CDlls FAR* m_pDlls;			// list of dlls loaded and their counts
	class CMapGUIDToPtr FAR* m_pMapToServerCO;//server class obj if reg/loaded
	class CMapGUIDToPtr FAR* m_pMapToHandlerCO;//handler CO obj if reg/loaded

	class CSHArray FAR* m_pArraySH;		// array of server/handler entries

	class CThrd FAR* m_pCThrd;			// pointer to header of thread list
	HWND  m_hwndClip;					// hwnd of our clip window
	HWND  m_hwndDde;					// hwnd of system dde window
	IUnknown FAR* m_punkState;		// Storage for CoGet/SetState
} _Etask;

#endif //!__OLECOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#ifndef __PLEX_H__
#define __PLEX_H__

struct FAR CPlex    // warning variable length structure
{
	CPlex FAR* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	INTERNAL_(void FAR*) data() { return this+1; }

	static INTERNAL_(CPlex FAR*) Create(CPlex FAR* FAR& head, DWORD mp, UINT nMax, UINT cbElement);

	INTERNAL_(void) FreeDataChain(DWORD mp);       // free this one and links
};

#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\oleguid.h ===
/*****************************************************************************\
*                                                                             *
* oleguid.h -   Master definition of GUIDs for ole2.dll                       *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all public GUIDs specific to OLE 
   and is included in ole2.h.
   
   NOTE: The second least significant byte of all of these GUIDs is 1.
*/
   

DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);

DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);

DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);

DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);

DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);

DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);

DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0); // unused
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);

DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);

DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);

DEFINE_OLEGUID(IID_IAdviseSink2,            0x00000125, 0, 0);

DEFINE_OLEGUID(IID_IRunnableObject,         0x00000126, 0, 0);

DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IOleCache2,				0x00000128, 0, 0);
DEFINE_OLEGUID(IID_IOleCacheControl,        0x00000129, 0, 0);

/* NOTE: LSB values 0x27 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,        0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,             0x00000316, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ole2sp.h ===
/* ole2sp.h - semi-private info; only for test apps within the development group
*/

#if !defined( _OLE2SP_H_ )
#define _OLE2SP_H_

#include <shellapi.h>

// MAC vestiges

#define M_PROLOG(where)
#define SET_A5
#define GET_A5()
#define A5_PROLOG(where)
#define RESTORE_A5()
#define NAME_SEG(x)

#define IGetProcAddress(a,b) GetProcAddress((a),(b))
#define ReportResult(a,b,c,d) ResultFromScode(b)

#define MAP16(v16) v16
#define MAP32(v32)
#define MAP1632(v16,v32)   v16



/****** Misc defintions ***************************************************/
#define implement struct
#define ctor_dtor private
#define implementations private
#define shared_state private

// helpers for internal methods and functions which follow the same convention
// as the external ones

#ifdef __cplusplus
#define INTERNALAPI_(type) extern "C" type
#else
#define INTERNALAPI_(type) type
#endif

#define INTERNAL HRESULT
#define INTERNAL_(type) type
#define FARINTERNAL HRESULT FAR
#define FARINTERNAL_(type) type FAR
#define NEARINTERNAL HRESULT NEAR
#define NEARINTERNAL_(type) type NEAR



//BEGIN REVIEW: We may not need all the following ones

#define OT_LINK     1L
#define OT_EMBEDDED 2L
#define OT_STATIC   3L


//END REVIEW .....


/****** Old Error Codes    ************************************************/

#define S_OOM               E_OUTOFMEMORY
#define S_BADARG            E_INVALIDARG
#define S_BLANK             E_BLANK
#define S_FORMAT            E_FORMAT
#define S_NOT_RUNNING       E_NOTRUNNING
#define E_UNSPEC            E_FAIL



/****** Macros for nested clases ******************************************/

/* MAC vestiges */

#define NC(a,b) a##::##b
#define DECLARE_NC(a,b) friend b;


/****** More Misc defintions **********************************************/


// LPLPVOID should not be made a typedef.  typedef won't compile; worse
// within complicated macros the compiler generates unclear error messages
//
#define LPLPVOID void FAR * FAR *

#define UNREFERENCED(a) ((void)(a))

#ifndef BASED_CODE
#define BASED_CODE __based(__segname("_CODE"))
#endif


/****** Standard IUnknown Implementation **********************************/

/*
 *      The following macro declares a nested class CUnknownImpl,
 *      creates an object of that class in the outer class, and
 *      declares CUnknownImpl to be a friend of the outer class.  After
 *      writing about 20 class headers, it became evident that the
 *      implementation of CUnknownImpl was very similar in all cases,
 *      and this macro captures the similarity.  The classname
 *      parameter is the name of the outer class WITHOUT the leading
 *      "C"; i.e., for CFileMoniker, classname is FileMoniker.
 */

#define noError return NOERROR

#define STDUNKDECL( ignore, classname ) implement CUnknownImpl:IUnknown { public: \
    CUnknownImpl( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj); \
    STDMETHOD_(ULONG,AddRef)(THIS); \
    STDMETHOD_(ULONG,Release)(THIS); \
    private: C##classname FAR* m_p##classname; }; \
    DECLARE_NC(C##classname, CUnknownImpl) \
    CUnknownImpl m_Unknown;

/*
 *      The following macro implements all the methods of a nested
 *      CUnknownImpl class EXCEPT FOR QUERYINTERFACE.  This macro was
 *      written after about 20 classes were written in which the
 *      implementations of CUnknownImpl were all the same.
 */

#define STDUNKIMPL(classname) \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::AddRef( void ){ \
    return ++m_p##classname->m_refs; } \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::Release( void ){ \
    if (--m_p##classname->m_refs == 0) { delete m_p##classname; return 0; } \
    return m_p##classname->m_refs;}


/*
 *      The following macro implements class::CUnknownImpl::QueryInterface IN
 *      THE SPECIAL CASE IN WHICH THE OUTER CLASS PRESENTS ONLY ONE INTERFACE
 *      OTHER THAN IUNKNOWN AND IDEBUG.  This is not universally the case,
 *      but it is common enough that this macro will save time and space.
 */

#ifdef _DEBUG
#define STDDEB_QI(classname) \
    if (iidInterface == IID_IDebug) {*ppv = (void FAR *)&(m_p##classname->m_Debug); return 0;} else
#else
#define STDDEB_QI(classname)
#endif

#define STDUNK_QI_IMPL(classname, interfacename) \
STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface \
    (REFIID iidInterface, void FAR * FAR * ppv) { \
    if (iidInterface == IID_IUnknown) {\
        *ppv = (void FAR *)&m_p##classname->m_Unknown;\
        AddRef(); noError;\
    } else if (iidInterface == IID_I##interfacename) { \
        *ppv = (void FAR *) &(m_p##classname->m_##classname); \
        m_p##classname->m_pUnkOuter->AddRef(); return NOERROR; \
    } else \
        STDDEB_QI(classname) \
        {*ppv = NULL; return ResultFromScode(E_NOINTERFACE);} \
}


/*
 *      The following macro implements the IUnknown methods inherited
 *      by the implementation of another interface.  The implementation
 *      is simply to delegate all calls to m_pUnkOuter.  Parameters:
 *      ocname is the outer class name, icname is the implementation
 *      class name.
 *
 */

#define STDUNKIMPL_FORDERIVED(ocname, icname) \
STDMETHODIMP NC(C##ocname,C##icname)::QueryInterface \
(REFIID iidInterface, LPLPVOID ppvObj) { \
    return m_p##ocname->m_pUnkOuter->QueryInterface(iidInterface, ppvObj);} \
STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::AddRef(void) { \
    return m_p##ocname->m_pUnkOuter->AddRef(); } \
STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::Release(void) { \
    return m_p##ocname->m_pUnkOuter->Release(); }


/****** Debug defintions **************************************************/

#include <debug.h>


/****** Other API defintions **********************************************/

//  Utility function not in the spec; in ole2.dll.
//  Read and write length-prefixed strings.  Open/Create stream.
//  ReadStringStream does allocation, returns length of
//  required buffer (strlen + 1 for terminating null)

STDAPI  ReadStringStream( LPSTREAM pstm, LPSTR FAR * ppsz );
STDAPI  WriteStringStream( LPSTREAM pstm, LPCSTR psz );
STDAPI  OpenOrCreateStream( IStorage FAR * pstg, const char FAR * pwcsName,
                                                      IStream FAR* FAR* ppstm);


// read and write ole control stream (in ole2.dll)
STDAPI  WriteOleStg (LPSTORAGE pstg, IOleObject FAR* pOleObj,
			DWORD dwReserved, LPSTREAM FAR* ppstmOut);
STDAPI  ReadOleStg (LPSTORAGE pstg, DWORD FAR* pdwFlags,
                DWORD FAR* pdwOptUpdate, DWORD FAR* pdwReserved,
				LPMONIKER FAR* ppmk, LPSTREAM FAR* pstmOut);
STDAPI ReadM1ClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteM1ClassStm(LPSTREAM pStm, REFCLSID rclsid);


// low level reg.dat access (in compobj.dll)
STDAPI CoGetInProcDll(REFCLSID rclsid, BOOL fServer, LPSTR lpszDll, int cbMax);
STDAPI CoGetLocalExe(REFCLSID rclsid, LPSTR lpszExe, int cbMax);
STDAPI CoGetPSClsid(REFIID iid, LPCLSID lpclsid);


// simpler alternatives to public apis
#define StringFromCLSID2(rclsid, lpsz, cbMax) \
    StringFromGUID2(rclsid, lpsz, cbMax)

#define StringFromIID2(riid, lpsz, cbMax) \
    StringFromGUID2(riid, lpsz, cbMax)

STDAPI_(int) Ole1ClassFromCLSID2(REFCLSID rclsid, LPSTR lpsz, int cbMax);
STDAPI_(BOOL) GUIDFromString(LPCSTR lpsz, LPGUID pguid);
STDAPI CLSIDFromOle1Class(LPCSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign=FALSE);
STDAPI_(BOOL)  CoIsHashedOle1Class(REFCLSID rclsid);
STDAPI       CoOpenClassKey(REFCLSID clsid, HKEY FAR* lphkeyClsid);


// were public; now not
STDAPI  SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument);
STDAPI  GetDocumentBitStg(LPSTORAGE pStg);



/*
 * Some docfiles stuff
 */

#define STGM_DFRALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE)
#define STGM_DFALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE)
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)


#endif // _OLE2SP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\privguid.h ===
/* this file is the master definition of all OLE2 product GUIDs (public and 
   private).  All GUIDs used by the ole2 product are of the form:

	   xxxxxxxx-xxxx-xxxY-C000-000000000046

   This range is broken down as follows:

	   000000xx-0000-0000-C000-000000000046 compobj IIDs (coguid.h)
	   000001xx-0000-0000-C000-000000000046 ole2 IIDs (oleguid.h)
	   000002xx-0000-0000-C000-000000000046 smoke test (testguid.h)
	   000003xx-0000-0000-C000-000000000046 ole2 CLSIDs (privguid.h; this file)
	   000004xx-0000-0000-C000-000000000046 ole2 sample apps (see DouglasH)

   Other interesting ranges are as follows:

	   0003xxxx-0000-0000-C000-000000000046 ole1 CLSIDs (ole1cls.h)
	   0004xxxx-0000-0000-C000-000000000046 hashed ole1 CLSIDs

*/
   

DEFINE_OLEGUID(CLSID_StdOleLink,		0x00000300, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemStm,			0x00000301, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemBytes,		0x00000302, 0, 0);
DEFINE_OLEGUID(CLSID_FileMoniker,		0x00000303, 0, 0);
DEFINE_OLEGUID(CLSID_ItemMoniker,		0x00000304, 0, 0);
DEFINE_OLEGUID(CLSID_AntiMoniker,		0x00000305, 0, 0);
DEFINE_OLEGUID(CLSID_PointerMoniker,	0x00000306, 0, 0);
// NOT TO BE USED						0x00000307, 0, 0);
DEFINE_OLEGUID(CLSID_PackagerMoniker,	0x00000308, 0, 0);
DEFINE_OLEGUID(CLSID_CompositeMoniker,	0x00000309, 0, 0);
// NOT TO BE USED						0x0000030a, 0, 0);
DEFINE_OLEGUID(CLSID_DfMarshal,			0x0000030b, 0, 0);

// clsids for proxy/stub objects
DEFINE_OLEGUID(CLSID_PSGenObject,		0x0000030c, 0, 0);
DEFINE_OLEGUID(CLSID_PSClientSite,		0x0000030d, 0, 0);
DEFINE_OLEGUID(CLSID_PSClassObject,		0x0000030e, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceActive,	0x0000030f, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceFrame,	0x00000310, 0, 0);
DEFINE_OLEGUID(CLSID_PSDragDrop,		0x00000311, 0, 0);
DEFINE_OLEGUID(CLSID_PSBindCtx,			0x00000312, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumerators,		0x00000313, 0, 0);
DEFINE_OLEGUID(CLSID_PSStore,			0x00000314, 0, 0);

/* These 2 are defined in "oleguid.h"
DEFINE_OLEGUID(CLSID_StaticMetafile,	0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,			0x00000316, 0, 0);
*/

/* NOTE: LSB values 0x17 through 0xff are reserved */

// copies from ole1cls.h; reduces the size of ole2.dll
DEFINE_OLEGUID(CLSID_MSDraw,            0x00030007, 0, 0);
DEFINE_OLEGUID(CLSID_Package,           0x0003000c, 0, 0);
DEFINE_OLEGUID(CLSID_ExcelWorksheet,   	0x00030000, 0, 0);
DEFINE_OLEGUID(CLSID_ExcelChart,       	0x00030001, 0, 0);
DEFINE_OLEGUID(CLSID_ExcelMacrosheet,  	0x00030002, 0, 0);
DEFINE_OLEGUID(CLSID_PBrush,  			0x0003000a, 0, 0);
DEFINE_OLEGUID(CLSID_WordDocument,      0x00030003, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#ifndef _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINDLL
#define _FARARG_ __far
#else
#define _FARARG_
#endif

#if (_MSC_VER <= 600)
#define __far       _far
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)	 ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif

#define _INC_STDARG
#endif	/* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\storage.h ===
/*****************************************************************************\
*                                                                             *
* storage.h -   Definitions for the strutured storage system
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _STORAGE_H_ )
#define _STORAGE_H_


#include <compobj.h>


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_EXTANTMARSHALLINGS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x108)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

/****** Storage types *******************************************************/

#if defined(_M_I286)
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP _huge
#endif
#else
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP
#endif
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L
#define STGM_TRANSACTED		0x00010000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef char FAR * FAR *SNB;


#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif


/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    char FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IENUMSTATSTG methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};

typedef IEnumSTATSTG FAR* LPENUMSTATSTG;



/****** ILockBytes Interface ************************************************/

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ILockBytes methods ***
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef ILockBytes FAR* LPLOCKBYTES;



/****** IStream Interface ***************************************************/


#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};

typedef IStream FAR* LPSTREAM;



/****** IStorage Interface **************************************************/

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStorage methods ***
    STDMETHOD(CreateStream) (THIS_ const char FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const char FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const char FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const char FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ char const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              char const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const char FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const char FAR* pwcsOldName,
                const char FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const char FAR *lpszName,
    			        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef IStorage FAR* LPSTORAGE;



/****** IRootStorage Interface **********************************************/

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRootStorage methods ***
    STDMETHOD(SwitchToFile) (THIS_ LPSTR lpstrFile) PURE;
};

typedef IRootStorage FAR* LPROOTSTORAGE;



/****** Storage API Prototypes ********************************************/

STDAPI StgCreateDocfile(const char FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const char FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const char FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgSetTimes(char const FAR* lpszName,
		  FILETIME const FAR* pctime,
                  FILETIME const FAR* patime,
                  FILETIME const FAR* pmtime);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\reterr.h ===
/* Jason's error handling macros */

#ifndef fRetErr_h
#define fRetErr_h

#ifdef _DEBUG
FARINTERNAL_(void) wWarn (LPSTR sz, LPSTR szFile, int iLine);
#define Warn(sz) wWarn(sz,_szAssertFile,__LINE__)
#else
#define Warn(sz)
#endif // _DEBUG

// Call x.  If hresult is not NOERROR, goto errRtn.
#define ErrRtn(x) do {if (NOERROR != (x)) {Warn(NULL); goto errRtn;}} while (0)

// Call x.  If hresult is not NOERROR, store it in hresult and goto errRtn.
#define ErrRtnH(x) do {if (NOERROR != (hresult=(x))) {Warn(NULL); goto errRtn;}} while (0)

// If x, goto errRtn.
#define ErrNz(x) do {if (x) {Warn(NULL); goto errRtn;}} while (0)

// If x==0, goto errRtn.
#define ErrZ(x) do {if (!(x)) {Warn(NULL); goto errRtn;}} while (0)

// If x==0, goto errRtn with a specific scode
#define ErrZS(x, scode) do {if (!(x)) {Warn(NULL); hresult=ResultFromScode(scode); goto errRtn;}} while (0)


// Call x.  If hresult is not NOERROR, return that hresult.
#define RetErr(x) do {HRESULT hresult; if (NOERROR != (hresult=(x))) {Warn(NULL); return hresult;}} while (0)

// Return unexpected error if x is non-zero
#define RetNz(x)  do {if (x) {AssertSz(0,#x); return ReportResult(0, E_UNEXPECTED, 0, 0);}} while (0)

// Return specific scode if x is non-zero
#define RetNzS(x, scode)  do {if (x) {Warn(NULL); return ResultFromScode (scode);}} while (0)

// Return unexpected error if x is zero
#define RetZ(x)   do {if (!(x)) {AssertSz(0,#x); return ReportResult(0, E_UNEXPECTED, 0, 0);}} while (0)

// Return specific scode if x is zero
#define RetZS(x, scode) do {if (!(x)) {Warn(NULL); return ResultFromScode (scode);}} while (0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\scode.h ===
/*****************************************************************************\
*                                                                             *
* scode.h - 	Defines standard status code services.						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#ifndef __SCODE_H__
#define __SCODE_H__

//
// SCODE
//

typedef long SCODE;
typedef SCODE *PSCODE;
typedef void FAR * HRESULT;
#define NOERROR 0

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+---------------------+-------+-------------------------------+
//  |S|       Context       | Facil |               Code            |
//  +-+---------------------+-------+-------------------------------+
//
//  where
//
//      S - is the severity code
//
//          0 - Success
//          1 - Error
//
//      Context - context info
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1



#define SUCCEEDED(Status) ((SCODE)(Status) >= 0)

#define FAILED(Status) ((SCODE)(Status)<0)


//
// Return the code
//

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define SCODE_FACILITY(sc)  (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define SCODE_SEVERITY(sc)  (((sc) >> 31) & 0x1)

//
// Create an SCODE value from component pieces
//

#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



// --------------------- Functions ---------------------------------------

#define GetScode(hr)        ((SCODE)(hr) & 0x800FFFFF)
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))

STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew);


// -------------------------- Facility definitions -------------------------

#define FACILITY_NULL       0x0000 // generally useful errors ([SE]_*)
#define FACILITY_RPC            0x0001 // remote procedure call errors (RPC_E_*)
#define FACILITY_DISPATCH   0x0002 // late binding dispatch errors
#define FACILITY_STORAGE   0x0003 // storage errors (STG_E_*)
#define FACILITY_ITF            0x0004 // interface-specific errors



#define S_OK                0L
#define S_FALSE             MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)



// --------------------- FACILITY_NULL errors ------------------------------

#define E_UNEXPECTED        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 0xffff)
                            // relatively catastrophic failure

#define E_NOTIMPL           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 1)
                            // not implemented

#define E_OUTOFMEMORY       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 2)
                            // ran out of memory

#define E_INVALIDARG        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 3)
                            // one or more arguments are invalid

#define E_NOINTERFACE       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 4)
                            // no such interface supported


#define E_POINTER           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 5)
                            // invalid pointer

#define E_HANDLE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 6)
                            // invalid handle

#define E_ABORT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 7)
                            // operation aborted

#define E_FAIL              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
                            // unspecified error


#define E_ACCESSDENIED      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 9)
                            // general access denied error


// ----------------- FACILITY_ITF errors used by OLE ---------------------
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an OLE interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//
// The ranges, their associated interfaces, and the header file that defines
// the actual scodes are given below.
// 

// Generic OLE errors that may be returned by many interfaces
#define OLE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0000)
#define OLE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x00FF)
#define OLE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0000)
#define OLE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x00FF)
// interfaces: all
// file: ole2.h


#define DRAGDROP_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0100)
#define DRAGDROP_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x010F)
#define DRAGDROP_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0100)
#define DRAGDROP_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x010F)
// interfaces: IDropSource, IDropTarget
// file: ole2.h

#define CLASSFACTORY_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0110)
#define CLASSFACTORY_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x011F)
#define CLASSFACTORY_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0110)
#define CLASSFACTORY_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x011F)
// interfaces: IClassFactory
// file:

#define MARSHAL_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0120)
#define MARSHAL_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x012F)
#define MARSHAL_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0120)
#define MARSHAL_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x012F)
// interfaces: IMarshal, IStdMarshalInfo, marshal APIs
// file:

#define DATA_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0130)
#define DATA_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x013F)
#define DATA_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0130)
#define DATA_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x013F)
// interfaces: IDataObject
// file: dvobj.h

#define VIEW_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0140)
#define VIEW_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x014F)
#define VIEW_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0140)
#define VIEW_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x014F)
// interfaces: IViewObject
// file: dvobj.h

#define REGDB_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0150)
#define REGDB_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x015F)
#define REGDB_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0150)
#define REGDB_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x015F)
// API: reg.dat manipulation
// file: 


// range 160 - 16F reserved

#define CACHE_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0170) 
#define CACHE_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x017F)
#define CACHE_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0170)
#define CACHE_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x017F)
// interfaces: IOleCache
// file:

#define OLEOBJ_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0180)
#define OLEOBJ_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x018F)
#define OLEOBJ_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0180)
#define OLEOBJ_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x018F)
// interfaces: IOleObject
// file:

#define CLIENTSITE_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0190) 
#define CLIENTSITE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x019F)
#define CLIENTSITE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0190)
#define CLIENTSITE_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x019F)
// interfaces: IOleClientSite
// file:

#define INPLACE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01A0)
#define INPLACE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01AF)
#define INPLACE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01A0)
#define INPLACE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01AF)
// interfaces: IOleWindow, IOleInPlaceObject, IOleInPlaceActiveObject,
//                 IOleInPlaceUIWindow, IOleInPlaceFrame, IOleInPlaceSite
// file:

#define ENUM_E_FIRST        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01B0)
#define ENUM_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01BF)
#define ENUM_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01B0)
#define ENUM_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01BF)
// interfaces: IEnum*
// file:

#define CONVERT10_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01C0)
#define CONVERT10_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01CF)
#define CONVERT10_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01C0)
#define CONVERT10_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01CF)
// API: OleConvertOLESTREAMToIStorage, OleConvertIStorageToOLESTREAM
// file:


#define CLIPBRD_E_FIRST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01D0)
#define CLIPBRD_E_LAST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01DF)
#define CLIPBRD_S_FIRST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01D0)
#define CLIPBRD_S_LAST      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01DF)
// interfaces: OleSetClipboard, OleGetClipboard, OleFlushClipboard
// file: ole2.h

#define MK_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01E0)
#define MK_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01EF)
#define MK_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01E0)
#define MK_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01EF)
// interfaces: IMoniker, IBindCtx, IRunningObjectTable, IParseDisplayName,
//             IOleContainer, IOleItemContainer, IOleLink
// file: moniker.h


#define CO_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01F0)
#define CO_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01FF)
#define CO_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01F0)
#define CO_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01FF)
// all Co* API
// file: compobj.h


// range 200 - ffff for new error codes



#endif      // ifndef __SCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	1

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#ifndef _INC_STDIO

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

/* buffered I/O macros */

#define BUFSIZ	512
#define _NFILE	20
#define EOF	(-1)

#ifndef _FILE_DEFINED
#pragma pack(2)
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	char  _flag;
	char  _file;
	};
typedef struct _iobuf FILE;
#pragma pack()
#define _FILE_DEFINED
#endif


/* _P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of _P_tmpdir
 *	+ 1 (in case _P_tmpdir does not end in "\\")
 *	+ 6 (for the temp number string)
 *	+ 1 (for the null terminator)
 */

#define  _P_tmpdir "\\"
#define  L_tmpnam sizeof(_P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 63
#define FOPEN_MAX 18
#define TMP_MAX 32767
#define _SYS_OPEN 20


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
extern FILE __near __cdecl _iob[];
#endif


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


/* standard file pointers */

#ifndef _WINDLL
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#endif
#ifndef _WINDOWS
#define _stdaux (&_iob[3])
#define _stdprn (&_iob[4])
#endif


#define _IOREAD 	0x01
#define _IOWRT		0x02

#define _IOFBF		0x0
#define _IOLBF		0x40
#define _IONBF		0x04

#define _IOMYBUF	0x08
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOSTRG 	0x40
#define _IORW		0x80


#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER	0

/* max number of windows */
#define _WFILE		20

/* values for windows screen buffer size */
#define _WINBUFINF	0
#define _WINBUFDEF	-1

/* size/move settings */
#define _WINSIZEMIN	1
#define _WINSIZEMAX	2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR	4

/* size/move query types */
#define _WINMAXREQ	100
#define _WINCURRREQ	101

/* values for closing window */
#define _WINPERSIST	1
#define _WINNOPERSIST	0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND	-1

/* menu items */
#define _WINSTATBAR	1
#define _WINTILE	2
#define _WINCASCADE	3
#define _WINARRANGE	4

/* quickwin exit options */
#define _WINEXITPROMPT		1
#define _WINEXITNOPERSIST	2
#define _WINEXITPERSIST 	3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
	unsigned int _version;
	const char __far * _title;
	long _wbufsize;
	};
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
	unsigned int _version;
	unsigned int _type;
	unsigned int _x;
	unsigned int _y;
	unsigned int _h;
	unsigned int _w;
	};
#define _WINFO_DEFINED
#endif
#endif
#endif

/* function prototypes */

#ifndef _STDIO_DEFINED
int __cdecl _filbuf(FILE *);
int __cdecl _flsbuf(int, FILE *);
FILE * __cdecl _fsopen(const char *,
	const char *, int);
void __cdecl clearerr(FILE *);
int __cdecl fclose(FILE *);
int __cdecl _fcloseall(void);
FILE * __cdecl _fdopen(int, const char *);
int __cdecl feof(FILE *);
int __cdecl ferror(FILE *);
int __cdecl fflush(FILE *);
int __cdecl fgetc(FILE *);
#ifndef _WINDLL
int __cdecl _fgetchar(void);
#endif
int __cdecl fgetpos(FILE *, fpos_t *);
char * __cdecl fgets(char *, int, FILE *);
int __cdecl _fileno(FILE *);
int __cdecl _flushall(void);
FILE * __cdecl fopen(const char *,
	const char *);
int __cdecl fprintf(FILE *, const char *, ...);
int __cdecl fputc(int, FILE *);
#ifndef _WINDLL
int __cdecl _fputchar(int);
#endif
int __cdecl fputs(const char *, FILE *);
size_t __cdecl fread(void *, size_t, size_t, FILE *);
FILE * __cdecl freopen(const char *,
	const char *, FILE *);
#ifndef _WINDLL
int __cdecl fscanf(FILE *, const char *, ...);
#endif
int __cdecl fsetpos(FILE *, const fpos_t *);
int __cdecl fseek(FILE *, long, int);
long __cdecl ftell(FILE *);
#ifdef _WINDOWS
#ifndef _WINDLL
FILE * __cdecl _fwopen(struct _wopeninfo *, struct _wsizeinfo *, const char *);
#endif
#endif
size_t __cdecl fwrite(const void *, size_t, size_t,
	FILE *);
int __cdecl getc(FILE *);
#ifndef _WINDLL
int __cdecl getchar(void);
char * __cdecl gets(char *);
#endif
int __cdecl _getw(FILE *);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif
int __cdecl printf(const char *, ...);
int __cdecl putc(int, FILE *);
#ifndef _WINDLL
int __cdecl putchar(int);
int __cdecl puts(const char *);
#endif
int __cdecl _putw(int, FILE *);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
void __cdecl rewind(FILE *);
int __cdecl _rmtmp(void);
#ifndef _WINDLL
int __cdecl scanf(const char *, ...);
#endif
void __cdecl setbuf(FILE *, char *);
int __cdecl setvbuf(FILE *, char *, int, size_t);
int __cdecl _snprintf(char *, size_t, const char *, ...);
int __cdecl sprintf(char *, const char *, ...);
#ifndef _WINDLL
int __cdecl sscanf(const char *, const char *, ...);
#endif
char * __cdecl _tempnam(char *, char *);
FILE * __cdecl tmpfile(void);
char * __cdecl tmpnam(char *);
int __cdecl ungetc(int, FILE *);
int __cdecl _unlink(const char *);
int __cdecl vfprintf(FILE *, const char *, va_list);
int __cdecl vprintf(const char *, va_list);
int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
int __cdecl vsprintf(char *, const char *, va_list);
#define _STDIO_DEFINED
#endif

/* macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
	: _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
	? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDLL
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)
#endif


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifndef _WINDOWS
#define stdaux	  _stdaux
#define stdprn	  _stdprn
#endif

int __cdecl fcloseall(void);
FILE * __cdecl fdopen(int, const char *);
#ifndef _WINDLL
int __cdecl fgetchar(void);
#endif
int __cdecl fileno(FILE *);
int __cdecl flushall(void);
#ifndef _WINDLL
int __cdecl fputchar(int);
#endif
int __cdecl getw(FILE *);
int __cdecl putw(int, FILE *);
int __cdecl rmtmp(void);
char * __cdecl tempnam(char *, char *);
int __cdecl unlink(const char *);

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#define _INC_STDIO
#endif	/* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#ifndef _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/* exit() arg values */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)();
typedef int (__far __cdecl * _fonexit_t)();
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef int (__cdecl * onexit_t)();
#endif
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

extern unsigned short __mb_cur_max; /* mb-len for curr. locale */
#define MB_CUR_MAX __mb_cur_max


/* min and max macros */

#define __max(a,b)	(((a) > (b)) ? (a) : (b))
#define __min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

extern int __near __cdecl volatile errno;	/* error value */
extern int __near __cdecl _doserrno;		/* OS system error value */

extern char * __near __cdecl _sys_errlist[];	/* perror error message table */
extern int __near __cdecl _sys_nerr;		/* # of entries in sys_errlist table */
extern char ** __near __cdecl _environ; 	/* pointer to environment table */
extern int __near __cdecl _fmode;		/* default file translation mode */
#ifndef _WINDOWS
extern int __near __cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int __near __cdecl _psp;	/* Program Segment Prefix */

/* OS major/minor version numbers */

extern unsigned char __near __cdecl _osmajor;
extern unsigned char __near __cdecl _osminor;

/* OS mode */

#define _DOS_MODE	0	/* DOS */
#define _OS2_MODE	1	/* OS/2 */
#define _WIN_MODE	2	/* Windows */

extern unsigned char __near __cdecl _osmode;

/* CPU mode */

#define _REAL_MODE	0	/* real mode */
#define _PROT_MODE	1	/* protect mode */

extern unsigned char __near __cdecl _cpumode;

/* function prototypes */

double __cdecl atof(const char *);
double __cdecl strtod(const char *, char * *);
ldiv_t __cdecl ldiv(long, long);

void __cdecl abort(void);
int __cdecl abs(int);
int __cdecl atexit(void (__cdecl *)(void));
int __cdecl atoi(const char *);
long __cdecl atol(const char *);
long double __cdecl _atold(const char *);
void * __cdecl bsearch(const void *, const void *,
	size_t, size_t, int (__cdecl *)(const void *,
	const void *));
void * __cdecl calloc(size_t, size_t);
div_t __cdecl div(int, int);
char * __cdecl _ecvt(double, int, int *, int *);
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif
int __far __cdecl _fatexit(void (__cdecl __far *)(void));
char * __cdecl _fcvt(double, int, int *, int *);
_fonexit_t __far __cdecl _fonexit(_fonexit_t);
void __cdecl free(void *);
char * __cdecl _fullpath(char *, const char *,
	size_t);
char * __cdecl _gcvt(double, int, char *);
char * __cdecl getenv(const char *);
char * __cdecl _itoa(int, char *, int);
long __cdecl labs(long);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
char * __cdecl _ltoa(long, char *, int);
void __cdecl _makepath(char *, const char *,
	const char *, const char *, const char *);
void * __cdecl malloc(size_t);
_onexit_t __cdecl _onexit(_onexit_t);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif
int __cdecl _putenv(const char *);
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
	(const void *, const void *));
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
int __cdecl rand(void);
void * __cdecl realloc(void *, size_t);
void __cdecl _searchenv(const char *, const char *,
	char *);
void __cdecl _splitpath(const char *, char *,
	char *, char *, char *);
void __cdecl srand(unsigned int);
long __cdecl strtol(const char *, char * *,
	int);
long double __cdecl _strtold(const char *,
	char * *);
unsigned long __cdecl strtoul(const char *,
	char * *, int);
void __cdecl _swab(char *, char *, int);
#ifndef _WINDOWS
int __cdecl system(const char *);
#endif
char * __cdecl _ultoa(unsigned long, char *, int);

int __cdecl mblen(const char *, size_t);
int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl wctomb(char *, wchar_t);
size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

/* model-independent function prototypes */

int __far __cdecl _fmblen(const char __far *, size_t);
int __far __cdecl _fmbtowc(wchar_t __far *, const char __far *,
	size_t);
int __far __cdecl _fwctomb(char __far *, wchar_t);
size_t __far __cdecl _fmbstowcs(wchar_t __far *, const char __far *,
	size_t);
size_t __far __cdecl _fwcstombs(char __far *, const wchar_t __far *,
	size_t);

#ifndef tolower 	/* tolower has been undefined - use function */
int __cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int __cdecl toupper(int);
#endif	/* toupper */

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

extern char * __near __cdecl sys_errlist[];
extern int __near __cdecl sys_nerr;
extern char ** __near __cdecl environ;

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

char * __cdecl ecvt(double, int, int *, int *);
char * __cdecl fcvt(double, int, int *, int *);
char * __cdecl gcvt(double, int, char *);
char * __cdecl itoa(int, char *, int);
char * __cdecl ltoa(long, char *, int);
onexit_t __cdecl onexit(onexit_t);
int __cdecl putenv(const char *);
void __cdecl swab(char *, char *, int);
char * __cdecl ultoa(unsigned long, char *, int);

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#define _INC_STDLIB
#endif	/* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\utils.h ===
#if !defined( _UTILS_H_ )
#define _UTILS_H_


#define	STREAMTYPE_CONTROL		0x00000001
#define	STREAMTYPE_CACHE		0x00000002
#define	STREAMTYPE_CONTAINER	0x00000004
#define STREAMTYPE_OTHER \
	(!(STREAMTYPE_CONTROL | STREAMTYPE_CACHE | STREAMTYPE_CONTAINER))
#define	STREAMTYPE_ALL			0xFFFFFFFF


#define OPCODE_COPY					1
#define OPCODE_REMOVE				2
#define OPCODE_MOVE					3
#define OPCODE_EXCLUDEFROMCOPY		4

#define CONVERT_NOSOURCE			1
#define CONVERT_NODESTINATION		2

typedef struct tagPLACEABLEMETAHEADER {
	DWORD	key;		/* must be 0x9AC6CDD7L */
	HANDLE	hmf;		/* must be zero */
	RECT	bbox;		/* bounding rectangle of the metafile */
	WORD	inch;		/* # of metafile units per inch must be < 1440 */
						/* most apps use 576 or 1000 */
	DWORD	reserved;	/* must be zero */
	WORD	checksum;
} PLACEABLEMETAHEADER;




#ifdef  _MAC
#define UtMemCpy(lpdst,lpsrc,dwCount)   (BlockMove(lpsrc, lpdst, dwCount))
#else
#define UtMemCpy(lpdst,lpsrc,dwCount)   (hmemcpy(lpdst, lpsrc, dwCount))
#endif

FARINTERNAL_(BOOL)		UtGlobalHandleCpy(HANDLE FAR* lphdst, HANDLE hsrc);

FARINTERNAL_(HANDLE)	UtDupGlobal (HANDLE hSrc, UINT uiFlags=GMEM_MOVEABLE);

FARINTERNAL_(BOOL)		UtIsFormatSupported (LPDATAOBJECT lpObj, BOOL fGet,
							BOOL fSet, CLIPFORMAT cfFormat);

FARINTERNAL_(LPSTR)		UtDupString(LPCSTR lpszIn);


FARINTERNAL_(BOOL)		UtCopyFormatEtc(FORMATETC FAR* pFetcIn, 
							FORMATETC FAR* pFetcCopy);

FARINTERNAL_(int)		UtCompareFormatEtc(FORMATETC FAR* pFetcLeft, 
							FORMATETC FAR* pFetcRight);

FARINTERNAL_(BOOL)		UtCompareTargetDevice(DVTARGETDEVICE FAR* ptdLeft, 
							DVTARGETDEVICE FAR* ptdRight);

FARINTERNAL_(BOOL)		UtCopyStatData(STATDATA FAR* pSDIn, 
							STATDATA FAR* pSDCopy);

FARINTERNAL_(void)		UtReleaseStatData(STATDATA FAR* pStatData);


FARINTERNAL_(HPALETTE)	UtDupPalette(HPALETTE hpalette);

FARINTERNAL_(int)		UtPaletteSize (int iBitCount);

FARINTERNAL_(DWORD)		UtFormatToTymed	(CLIPFORMAT cf);


FARINTERNAL_(BOOL)		UtQueryPictFormat(LPDATAOBJECT lpSrcDataObj, 
								LPFORMATETC	lpforetc);
								
FARINTERNAL_(HBITMAP)	UtConvertDibToBitmap(HANDLE hDib);
								
FARINTERNAL_(HANDLE)	UtConvertBitmapToDib(HBITMAP hBitmapm, 
								HPALETTE hpal = NULL);

FARINTERNAL_(void)		UtGetClassID(LPUNKNOWN lpUnk, CLSID FAR* lpClsid);

FARINTERNAL_(DVTARGETDEVICE FAR*) UtCopyTargetDevice(DVTARGETDEVICE FAR* ptd);

FARINTERNAL				UtGetIconData(LPDATAOBJECT lpSrcDataObj, 
							REFCLSID rclsid, LPFORMATETC lpforetc, 
							LPSTGMEDIUM lpstgmed);

OLEAPI					UtDoStreamOperation (LPSTORAGE pstgSrc, 
							LPSTORAGE pstgDst, int iOpCode, 
							DWORD grfAllowedStmTypes);

							
FARINTERNAL_(LPSTR)		UtStrRChr (LPCSTR sz, const char ch);

FARINTERNAL_(void)		UtGetPresStreamName (LPSTR lpszName, int iStreamNum);

FARINTERNAL_(void)		UtRemoveExtraOlePresStreams (LPSTORAGE pstg, 
							int iStart);

							
							
/*** Following routines can be found in convert.cpp *****/

FARINTERNAL				UtGetHGLOBALFromStm(LPSTREAM lpstream, DWORD dwSize, 
							HANDLE FAR* lphPres);
							
FARINTERNAL				UtGetHDIBFromDIBFileStm(LPSTREAM pstm, 
							HANDLE FAR* lphdata);

FARINTERNAL_(HANDLE)	UtGetHMFPICT(HMETAFILE hMF, BOOL fDeletOnError,
							DWORD xExt, DWORD yExt);
							
FARINTERNAL				UtGetHMFFromMFStm(LPSTREAM lpstream, DWORD dwSize, 
							BOOL fConvert, HANDLE FAR* lphPres);

FARINTERNAL				UtGetSizeAndExtentsFromPlaceableMFStm(LPSTREAM pstm,
							DWORD FAR* dwSize, LONG FAR* plWidth,  
							LONG FAR* plHeight);
		 
FARINTERNAL				UtGetHMFPICTFromPlaceableMFStm(LPSTREAM pstm, 
							HANDLE FAR* lphdata);

FARINTERNAL				UtHGLOBALToStm(HANDLE hdata, DWORD dwSize, 
							LPSTREAM pstm);

FARINTERNAL_(void)		UtGetDibExtents (LPBITMAPINFOHEADER lpbmi, 
							LONG FAR* plWidth, LONG FAR* plHeight);

FARINTERNAL				UtHDIBToDIBFileStm(HANDLE hdata, 
							DWORD dwSize, LPSTREAM pstm);

FARINTERNAL				UtDIBStmToDIBFileStm(LPSTREAM pstmDIB, 
							DWORD dwSize, LPSTREAM pstmDIBFile);

FARINTERNAL				UtHDIBFileToOlePresStm(HANDLE hdata, LPSTREAM pstm);

FARINTERNAL				UtHMFToMFStm(HANDLE FAR* lphMF, DWORD dwSize, 
							LPSTREAM lpstream); 
							
FARINTERNAL				UtHMFToPlaceableMFStm(HANDLE FAR* lphMF, 
							DWORD dwSize, LONG lWidth, LONG lHeight,
							LPSTREAM pstm);		
								
FARINTERNAL				UtMFStmToPlaceableMFStm(LPSTREAM pstmMF,
							DWORD dwSize, LONG lWidth, LONG lHeight, 
							LPSTREAM pstmPMF);

FARINTERNAL				UtReadOlePresStmHeader (LPSTREAM pstm, 
							LPFORMATETC pforetc, DWORD FAR* pdwAdvf, 
							BOOL FAR* pfConvert);

FARINTERNAL				UtWriteOlePresStmHeader(LPSTREAM lppstream, 
							LPFORMATETC pforetc, DWORD dwAdvf);

FARINTERNAL				UtOlePresStmToContentsStm (LPSTORAGE pstg, 
							LPSTR lpszPresStm, BOOL fDeletePresStm,
							UINT FAR* puiStatus);
							
/*** Following routines can be found in ..\dde\client\ddecnvrt.cpp *****/

							
FARINTERNAL				UtGetHMFPICTFromMSDrawNativeStm (LPSTREAM pstm,	
							DWORD dwSize, HANDLE FAR* lphdata);	
							
FARINTERNAL				UtPlaceableMFStmToMSDrawNativeStm (LPSTREAM pstmPMF, 
							LPSTREAM pstmMSDraw);
			
FARINTERNAL				UtDIBFileStmToPBrushNativeStm (LPSTREAM pstmDIBFile, 
							LPSTREAM pstmPBrush);
							
FARINTERNAL_(HANDLE)	UtGetHPRESFromNative (LPSTORAGE pstg, 
							CLIPFORMAT cfFormat, BOOL fOle10Native);
							
FARINTERNAL				UtContentsStmTo10NativeStm (LPSTORAGE pstg, 
							REFCLSID rclsid, BOOL fDeleteContents, 
							UINT FAR* puiStatus);

FARINTERNAL				Ut10NativeStmToContentsStm(LPSTORAGE pstg, 
							REFCLSID rclsid, BOOL fDeleteSrcStm);
		
#endif // _UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\taskmap.h ===
// taskmap.h - definitions for managing the etask (per task data).

// NOTE: this is private to compobj.dll for now; it can be made public if necc.

STDAPI_(BOOL) LookupEtask(HTASK FAR& hTask, Etask FAR& etask);
STDAPI_(BOOL) SetEtask(HTASK hTask, Etask FAR& etask);

extern IMalloc FAR* v_pMallocShared;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\utstream.h ===
#if !defined( _UTSTREAM_H_ )
#define _UTSTREAM_H_

/* stream ids used in the call to StGetStream */

FARINTERNAL_(HRESULT) StRead (IStream FAR * lpstream, LPVOID lpBuf, ULONG ulLen);
#define StWrite(lpstream, lpBuf, ulLen) lpstream->Write(lpBuf, ulLen, NULL)
FARINTERNAL_(ATOM)  StReadAtom (IStream FAR * lpstream);
FARINTERNAL_(HRESULT) StWriteAtom (IStream FAR * lpstream, ATOM at);

FARINTERNAL StSave10NativeData(IStorage FAR* pstgSave, HANDLE hNative, BOOL fIsOle1Interop);
FARINTERNAL StRead10NativeData(IStorage FAR* pstgSave, HANDLE FAR *phNative);
FARINTERNAL StSave10ItemName (IStorage FAR* pstg, LPCSTR szItemName);
OLEAPI		ReadStringStream( LPSTREAM pstm, LPSTR FAR * ppsz);
OLEAPI		WriteStringStream( LPSTREAM pstm, LPCSTR psz);

FARINTERNAL StSetSize(LPSTREAM pstm, DWORD dwSize = 0, BOOL fRelative = TRUE);

#endif // _UTSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\valid.h ===
//
// WARNING: IsValidPtrIn and IsValidPtrOut are defined as macros
// here. They are also defined as ISVALIDPTRIN and ISVALIDPTROUT
// in compobj\valid.cxx, which are functions. The functions are
// used to keep backward compatibility, while the macros are
// smaller and faster to use.
//

#define IsValidPtrIn(pv,cb)  (!IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );
STDAPI_(BOOL) IsValidIid( REFIID riid );


#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__); return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__), retval)

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__), retval)
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__); return; }

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__); return retval; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) \
    return retval;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\verinfo.h ===
#ifdef RC_INVOKED

#include <ver.h>

#define VER_FILEVERSION_STR      "2.1\0"
#define VER_FILEVERSION          2,0010,0035,0035

#define VER_PRODUCTNAME_STR      "Microsoft OLE 2.1 16/32 Interoperability for Windows\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1994\0"
#define VER_PRODUCTVERSION_STR   "2.1\0"
#define VER_PRODUCTVERSION       2,0010,0035,0035
#define VER_COMMENT_STR          "Windows OLE 16/32 Interoperability DLLs\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_DOS_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "OLE 2.1 16/32 Interoperability Library\0"

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef	unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
	int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
	size_t);
int __cdecl _memicmp(const void *, const void *,
	unsigned int);
void * __cdecl memcpy(void *, const void *,
	size_t);
void * __cdecl memmove(void *, const void *,
	size_t);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char * __cdecl strcat(char *, const char *);
char * __cdecl strchr(const char *, int);
int __cdecl strcmp(const char *, const char *);
int __cdecl _strcmpi(const char *, const char *);
int __cdecl strcoll(const char *, const char *);
int __cdecl _stricmp(const char *, const char *);
char * __cdecl strcpy(char *, const char *);
size_t __cdecl strcspn(const char *, const char *);
char * __cdecl _strdup(const char *);
char * __cdecl _strerror(const char *);
char * __cdecl strerror(int);
size_t __cdecl strlen(const char *);
char * __cdecl _strlwr(char *);
char * __cdecl strncat(char *, const char *,
	size_t);
int __cdecl strncmp(const char *, const char *,
	size_t);
int __cdecl _strnicmp(const char *, const char *,
	size_t);
char * __cdecl strncpy(char *, const char *,
	size_t);
char * __cdecl _strnset(char *, int, size_t);
char * __cdecl strpbrk(const char *,
	const char *);
char * __cdecl strrchr(const char *, int);
char * __cdecl _strrev(char *);
char * __cdecl _strset(char *, int);
size_t __cdecl strspn(const char *, const char *);
char * __cdecl strstr(const char *,
	const char *);
char * __cdecl strtok(char *, const char *);
char * __cdecl _strupr(char *);
size_t __cdecl strxfrm (char *, const char *,
	size_t);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
	int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
	size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
	size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
	unsigned int);
void __far * __far __cdecl _fmemmove(void __far *, const void __far *,
	size_t);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);
char __far * __far __cdecl _fstrcat(char __far *, const char __far *);
char __far * __far __cdecl _fstrchr(const char __far *, int);
int __far __cdecl _fstrcmp(const char __far *, const char __far *);
int __far __cdecl _fstricmp(const char __far *, const char __far *);
char __far * __far __cdecl _fstrcpy(char __far *, const char __far *);
size_t __far __cdecl _fstrcspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrdup(const char __far *);
char __near * __far __cdecl _nstrdup(const char __far *);
size_t __far __cdecl _fstrlen(const char __far *);
char __far * __far __cdecl _fstrlwr(char __far *);
char __far * __far __cdecl _fstrncat(char __far *, const char __far *,
	size_t);
int __far __cdecl _fstrncmp(const char __far *, const char __far *,
	size_t);
int __far __cdecl _fstrnicmp(const char __far *, const char __far *,
	size_t);
char __far * __far __cdecl _fstrncpy(char __far *, const char __far *,
	size_t);
char __far * __far __cdecl _fstrnset(char __far *, int, size_t);
char __far * __far __cdecl _fstrpbrk(const char __far *,
	const char __far *);
char __far * __far __cdecl _fstrrchr(const char __far *, int);
char __far * __far __cdecl _fstrrev(char __far *);
char __far * __far __cdecl _fstrset(char __far *, int);
size_t __far __cdecl _fstrspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrstr(const char __far *,
	const char __far *);
char __far * __far __cdecl _fstrtok(char __far *, const char __far *);
char __far * __far __cdecl _fstrupr(char __far *);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
	int, unsigned int);
int __cdecl memicmp(const void *, const void *,
	unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
int __cdecl strcmpi(const char *, const char *);
int __cdecl stricmp(const char *, const char *);
char * __cdecl strdup(const char *);
char * __cdecl strlwr(char *);
int __cdecl strnicmp(const char *, const char *,
	size_t);
char * __cdecl strnset(char *, int, size_t);
char * __cdecl strrev(char *);
char * __cdecl strset(char *, int);
char * __cdecl strupr(char *);
#endif

#ifdef __cplusplus
}
#endif

#define _INC_STRING
#endif	/* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\inc\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID		    void

#define FAR                 _far
#define NEAR		    _near
#define PASCAL		    _pascal
#define CDECL		    _cdecl

#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal

/****** Simple types & common helper macros *********************************/

typedef int		    BOOL;
#define FALSE		    0
#define TRUE		    1

typedef unsigned char	    BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int	    UINT;

#ifdef STRICT
typedef signed long	    LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)	((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)	((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL		    0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;


typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*	    PBYTE;
typedef BYTE FAR*	    LPBYTE;

typedef int NEAR*	    PINT;
typedef int FAR*	    LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*	    PLONG;
typedef long FAR*	    LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE* 	    PHANDLE;
typedef HANDLE NEAR*	    SPHANDLE;
typedef HANDLE FAR*	    LPHANDLE;

typedef HANDLE		    HGLOBAL;
typedef HANDLE		    HLOCAL;

typedef HANDLE		    GLOBALHANDLE;
typedef HANDLE		    LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE	0x0001
#define WF_CPU286	0x0002
#define WF_CPU386	0x0004
#define WF_CPU486	0x0008
#define WF_STANDARD	0x0010
#define WF_WIN286	0x0010
#define WF_ENHANCED	0x0020
#define WF_WIN386	0x0020
#define WF_CPU086	0x0040
#define WF_CPU186	0x0080
#define WF_LARGEFRAME	0x0100
#define WF_SMALLFRAME	0x0200
#define WF_80x87	0x0400
#define WF_PAGING	0x0800
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

#define ERR_SIZE_MASK		0x3000
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069


/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)


HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define	WEP_SYSTEM_EXIT	1
#define	WEP_FREE_DLL	0

/****** Task Management *****************************************************/

#endif	/* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);


/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND		    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR		    (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND		    (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		    (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND	    (LMEM_MOVEABLE)
#define NONZEROLPTR	    (LMEM_FIXED)


#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ 	    0x0000
#define OF_WRITE	    0x0001
#define OF_READWRITE	    0x0002
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	    0x0100
#define OF_DELETE	    0x0200
#define OF_VERIFY	    0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH	    0x0400	/* Used without OF_REOPEN */
#define OF_CANCEL	    0x0800
#define OF_CREATE	    0x1000
#define OF_PROMPT	    0x2000
#define OF_EXIST	    0x4000
#define OF_REOPEN	    0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ	    0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long	WINAPI _hread(HFILE, void _huge*, long);
long	WINAPI _hwrite(HFILE, const void _huge*, long);
#endif	/* WINVER >= 0x030a */


#endif	/* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE	    (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection errors */
#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)	    GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR	    MAKEINTRESOURCE(1)
#define RT_BITMAP	    MAKEINTRESOURCE(2)
#define RT_ICON 	    MAKEINTRESOURCE(3)
#define RT_MENU 	    MAKEINTRESOURCE(4)
#define RT_DIALOG	    MAKEINTRESOURCE(5)
#define RT_STRING	    MAKEINTRESOURCE(6)
#define RT_FONTDIR	    MAKEINTRESOURCE(7)
#define RT_FONT 	    MAKEINTRESOURCE(8)
#define RT_ACCELERATOR	    MAKEINTRESOURCE(9)
#define RT_RCDATA	    MAKEINTRESOURCE(10)

#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON	    MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE	    32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI	    32737
#define OBM_DNARROWI	    32736
#define OBM_RGARROWI	    32735
#define OBM_LFARROWI	    32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL	    32512
#define OCR_IBEAM	    32513
#define OCR_WAIT	    32514
#define OCR_CROSS	    32515
#define OCR_UP		    32516
#define OCR_SIZE	    32640
#define OCR_ICON	    32641
#define OCR_SIZENWSE	    32642
#define OCR_SIZENESW	    32643
#define OCR_SIZEWE	    32644
#define OCR_SIZENS	    32645
#define OCR_SIZEALL	    32646
#define OCR_ICOCUR	    32647

#define OIC_SAMPLE	    32512
#define OIC_HAND	    32513
#define OIC_QUES	    32514
#define OIC_BANG	    32515
#define OIC_NOTE	    32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE	    0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);


#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif	/* WINVER >= 0x030a */
#endif	/* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif	/* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef	NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif	/* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)	    (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY	DCB_ACCUMULATE
#define DCB_SET 	(DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);


/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR		   0
#define COLOR_BACKGROUND	   1
#define COLOR_ACTIVECAPTION	   2
#define COLOR_INACTIVECAPTION	   3
#define COLOR_MENU		   4
#define COLOR_WINDOW		   5
#define COLOR_WINDOWFRAME	   6
#define COLOR_MENUTEXT		   7
#define COLOR_WINDOWTEXT	   8
#define COLOR_CAPTIONTEXT  	   9
#define COLOR_ACTIVEBORDER	  10
#define COLOR_INACTIVEBORDER	  11
#define COLOR_APPWORKSPACE	  12
#define COLOR_HIGHLIGHT		  13
#define COLOR_HIGHLIGHTTEXT	  14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT		  18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN 	    1
#define OBJ_BRUSH	    2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID	    0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL 	    5
#define PS_INSIDEFRAME 	    6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4
#define	BS_DIBPATTERN	    5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH	    PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif	/* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR		    0
#define NULLREGION	    1
#define SIMPLEREGION	    2
#define COMPLEXREGION	    3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND 	    1
#define RGN_OR		    2
#define RGN_XOR 	    3
#define RGN_DIFF	    4
#define RGN_COPY	    5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED	0x01	/* palette index used for animation */
#define PC_EXPLICIT	0x02	/* palette index is explicit to device */
#define	PC_NOCOLLAPSE	0x04	/* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define	SYSPAL_STATIC	1
#define	SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);


/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);


/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED	0x0001
#define ETO_OPAQUE	0x0002
#define ETO_CLIPPED	0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP		    0x0000
#define DT_LEFT 	    0x0000
#define DT_CENTER	    0x0001
#define DT_RIGHT	    0x0002
#define DT_VCENTER	    0x0004
#define DT_BOTTOM	    0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE	    0x0020
#define DT_EXPANDTABS	    0x0040
#define DT_TABSTOP	    0x0080
#define DT_NOCLIP	    0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT	    0x0400
#define DT_NOPREFIX	    0x0800
#define DT_INTERNAL	    0x1000

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP		     0x0000
#define TA_UPDATECP		     0x0001
#define TA_LEFT 		     0x0000
#define TA_RIGHT		     0x0002
#define TA_CENTER		     0x0006
#define TA_TOP			     0x0000
#define TA_BOTTOM		     0x0008
#define TA_BASELINE		     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE	    32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE	    0
#define FW_THIN 	    100
#define FW_EXTRALIGHT	    200
#define FW_LIGHT	    300
#define FW_NORMAL	    400
#define FW_MEDIUM	    500
#define FW_SEMIBOLD	    600
#define FW_BOLD 	    700
#define FW_EXTRABOLD	    800
#define FW_HEAVY	    900

#define FW_ULTRALIGHT	    FW_EXTRALIGHT
#define FW_REGULAR	    FW_NORMAL
#define FW_DEMIBOLD	    FW_SEMIBOLD
#define FW_ULTRABOLD	    FW_EXTRABOLD
#define FW_BLACK	    FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET	    0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET	    2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET	    255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS		4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK		0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES		0x10
#define CLIP_TT_ALWAYS		0x20
#define CLIP_EMBEDDED		0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT	    10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT	    12
#define SYSTEM_FONT	    13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING	     0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE	    0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif	/* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR	    0x02
#define TMPF_DEVICE	    0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE	    0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR	0x00000040L
#define NTM_BOLD	0x00000020L
#define NTM_ITALIC	0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL	WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE	0x0001
#define TT_ENABLED	0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD	     bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE	     bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;


HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif	/* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif	/* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0410
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F

#define	META_CHORD		     0x0830
#define	META_SETMAPPERFLAGS	     0x0231
#define	META_EXTTEXTOUT		     0x0a32
#define	META_SETDIBTODEV	     0x0d33
#define	META_SELECTPALETTE	     0x0234
#define	META_REALIZEPALETTE	     0x0035
#define	META_ANIMATEPALETTE	     0x0436
#define	META_SETPALENTRIES	     0x0037
#define	META_POLYPOLYGON	     0x0538
#define	META_RESIZEPALETTE	     0x0139

#define	META_DIBBITBLT		     0x0940
#define	META_DIBSTRETCHBLT	     0x0b41
#define	META_DIBCREATEPATTERNBRUSH   0x0142
#define	META_STRETCHDIB		     0x0f43

#define META_EXTFLOODFILL	     0x0548

#define META_RESETDC		     0x014C
#define META_STARTDOC		     0x014D
#define META_STARTPAGE		     0x004F
#define META_ENDPAGE		     0x0050
#define META_ABORTDOC		     0x0052
#define META_ENDDOC		     0x005E

#define	META_DELETEOBJECT	     0x01f0

#define	META_CREATEPALETTE	     0x00f7
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED		     0x4000
#define SP_ERROR		     (-1)
#define SP_APPABORT		     (-2)
#define SP_USERABORT		     (-3)
#define SP_OUTOFDISK		     (-4)
#define SP_OUTOFMEMORY		     (-5)

#define PR_JOBSTATUS		     0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS	    0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETABORTPROC		     9
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define MOUSETRAILS		     39

#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;	    /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	     0
#define SM_CYSCREEN	     1
#define SM_CXVSCROLL	     2
#define SM_CYHSCROLL	     3
#define SM_CYCAPTION	     4
#define SM_CXBORDER	     5
#define SM_CYBORDER	     6
#define SM_CXDLGFRAME	     7
#define SM_CYDLGFRAME	     8
#define SM_CYVTHUMB	     9
#define SM_CXHTHUMB	     10
#define SM_CXICON	     11
#define SM_CYICON	     12
#define SM_CXCURSOR	     13
#define SM_CYCURSOR	     14
#define SM_CYMENU	     15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL	     20
#define SM_CXHSCROLL	     21
#define SM_DEBUG	     22
#define SM_SWAPBUTTON	     23
#define SM_RESERVED1	     24
#define SM_RESERVED2	     25
#define SM_RESERVED3	     26
#define SM_RESERVED4	     27
#define SM_CXMIN	     28
#define SM_CYMIN	     29
#define SM_CXSIZE	     30
#define SM_CYSIZE	     31
#define SM_CXFRAME	     32
#define SM_CYFRAME	     33
#define SM_CXMINTRACK	     34
#define SM_CYMINTRACK	     35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_CMETRICS	     43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE	    0x001E

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP		    1
#define SPI_SETBEEP		    2
#define SPI_GETMOUSE		    3
#define SPI_SETMOUSE		    4
#define SPI_GETBORDER		    5
#define SPI_SETBORDER		    6
#define SPI_GETKEYBOARDSPEED	    10
#define SPI_SETKEYBOARDSPEED	    11
#define SPI_LANGDRIVER		    12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY	    18
#define SPI_SETGRIDGRANULARITY	    19
#define SPI_SETDESKWALLPAPER	    20
#define SPI_SETDESKPATTERN	    21
#define SPI_GETKEYBOARDDELAY	    22
#define SPI_SETKEYBOARDDELAY	    23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP	    25
#define SPI_SETICONTITLEWRAP	    26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH	    29
#define SPI_SETDOUBLECLKHEIGHT	    30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME	    32
#define SPI_SETMOUSEBUTTONSWAP	    33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE	    0x0001
#define SPIF_SENDWININICHANGE	    0x0002

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL		    0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER		    0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND	hwnd;
    UINT        message;
    WPARAM	wParam;
    LPARAM	lParam;
    DWORD       time;
    POINT	pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE	0x0000
#define PM_REMOVE	0x0001
#define PM_NOYIELD	0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY		0x0001
#define QS_MOUSEMOVE	0x0002
#define QS_MOUSEBUTTON	0x0004
#define QS_MOUSE	(QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE	0x0008
#define QS_TIMER	0x0010
#define QS_PAINT	0x0020
#define QS_SENDMESSAGE	0x0040

#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST	((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE	    3

#define WH_CALLWNDPROC	    4

#define WH_MSGFILTER	    (-1)
#define WH_SYSMSGFILTER	    6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX		 0
#define MSGF_MENU		 2
#define MSGF_MOVE		 3
#define MSGF_SIZE		 4
#define MSGF_SCROLLBAR		 5
#define MSGF_NEXTWINDOW 	 6
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST	    0x0380
#define WM_PENWINLAST	    0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F


#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER	    0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION	    0x0016

#define WM_QUIT		    0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR	    0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC	lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE	hInstance;
    HICON	hIcon;
    HCURSOR	hCursor;
    HBRUSH	hbrBackground;
    LPCSTR	lpszMenuName;
    LPCSTR	lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW	    0x0001
#define CS_HREDRAW	    0x0002

#define CS_OWNDC	    0x0020
#define CS_CLASSDC	    0x0040
#define CS_PARENTDC	    0x0080

#define CS_SAVEBITS	    0x0800

#define CS_DBLCLKS	    0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE	    0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT	    0x0100

#define CS_GLOBALCLASS	    0x4000
#endif	/* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME	    (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR	    (-12)
#define GCW_HICON	    (-14)
#define GCW_HMODULE	    (-16)
#define GCW_CBWNDEXTRA	    (-18)
#define GCW_CBCLSEXTRA	    (-20)
#define GCL_WNDPROC	    (-24)
#define GCW_STYLE	    (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif	/* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED	    0x00000000L
#define WS_POPUP	    0x80000000L
#define WS_CHILD	    0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE	    0x10000000L
#define WS_DISABLED	    0x08000000L

/* Main window states */
#define WS_MINIMIZE	    0x20000000L
#define WS_MAXIMIZE	    0x01000000L

/* Main window styles */
#define WS_CAPTION	    0x00C00000L     /* WS_BORDER | WS_DLGFRAME	*/
#define WS_BORDER	    0x00800000L
#define WS_DLGFRAME	    0x00400000L
#define WS_VSCROLL	    0x00200000L
#define WS_HSCROLL	    0x00100000L
#define WS_SYSMENU	    0x00080000L
#define WS_THICKFRAME	    0x00040000L
#define WS_MINIMIZEBOX	    0x00020000L
#define WS_MAXIMIZEBOX	    0x00010000L

/* Control window styles */
#define WS_GROUP	    0x00020000L
#define WS_TABSTOP	    0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW	    (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	    (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST	     0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED	    WS_OVERLAPPED
#define WS_ICONIC	    WS_MINIMIZE
#define WS_SIZEBOX	    WS_THICKFRAME
#define WS_TILEDWINDOW	    WS_OVERLAPPEDWINDOW


#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE	    0x0001
#define WM_NCCREATE	    0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY	    0x0002
#define WM_NCDESTROY	    0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);


#ifndef NOSHOWWINDOW

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW	    0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW	    0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM	    SW_OTHERRESTORED
#endif	/* NOSHOWWINDOW */

#define WM_SETREDRAW	    0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE	    0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT	    0x000C
#define WM_GETTEXT	    0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	    (-4)
#define GWW_HINSTANCE	    (-6)
#define GWW_HWNDPARENT	    (-8)
#define GWW_ID		    (-12)
#define GWL_STYLE	    (-16)
#define GWL_EXSTYLE	    (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT	    ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE	    0x0001
#define SWP_NOMOVE	    0x0002
#define SWP_NOZORDER	    0x0004
#define SWP_NOREDRAW	    0x0008
#define SWP_NOACTIVATE	    0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW	    0x0040
#define SWP_HIDEWINDOW	    0x0080
#define SWP_NOCOPYBITS	    0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME	    SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM	    ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE		    0x0003
#define WM_SIZE		    0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED	    0
#define SIZE_MINIMIZED	    1
#define SIZE_MAXIMIZED	    2
#define SIZE_MAXSHOW	    3
#define SIZE_MAXHIDE	    4

/* Obsolete constant names */
#define SIZENORMAL	    SIZE_RESTORED
#define SIZEICONIC	    SIZE_MINIMIZED
#define SIZEFULLSCREEN	    SIZE_MAXIMIZED
#define SIZEZOOMSHOW	    SIZE_MAXSHOW
#define SIZEZOOMHIDE	    SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN	    0x0013
#define WM_CLOSE	    0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024


BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER	4
#define GW_CHILD	5


/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW	    0x00000001L
#define DCX_CACHE	    0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP	    0x00000020L

#define DCX_EXCLUDERGN	    0x00000040L
#define DCX_INTERSECTRGN    0x00000080L


#define DCX_LOCKWINDOWUPDATE 0x00000400L


#define DCX_USESTYLE	    0x00010000L

#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT	    0x000F
#define WM_ERASEBKGND	    0x0014
#define WM_ICONERASEBKGND   0x0027

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC 	hdc;
    BOOL	fErase;
    RECT	rcPaint;
    BOOL	fRestore;
    BOOL	fIncUpdate;
    BYTE	rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE		0x0001
#define RDW_INTERNALPAINT	0x0002
#define RDW_ERASE		0x0004

#define RDW_VALIDATE		0x0008
#define RDW_NOINTERNALPAINT	0x0010
#define RDW_NOERASE		0x0020

#define RDW_NOCHILDREN		0x0040
#define RDW_ALLCHILDREN 	0x0080

#define RDW_UPDATENOW		0x0100
#define RDW_ERASENOW		0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004


#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT	    0x0085

#define WM_NCCALCSIZE	    0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP	    0x0010
#define WVR_ALIGNLEFT	    0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT	    0x0080
#define WVR_HREDRAW	    0x0100
#define WVR_VREDRAW	    0x0200
#define WVR_REDRAW	    (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS	    0x0400


/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT	   rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST	    0x0084

/* WM_NCHITTEST return codes */
#define HTERROR 	    (-2)
#define HTTRANSPARENT	    (-1)
#define HTNOWHERE	    0
#define HTCLIENT	    1
#define HTCAPTION	    2
#define HTSYSMENU	    3
#define HTSIZE		    4
#define HTMENU		    5
#define HTHSCROLL	    6
#define HTVSCROLL	    7
#define HTMINBUTTON	    8
#define HTMAXBUTTON	    9
#define HTLEFT		    10
#define HTRIGHT 	    11
#define HTTOP		    12
#define HTTOPLEFT	    13
#define HTTOPRIGHT	    14
#define HTBOTTOM	    15
#define HTBOTTOMLEFT	    16
#define HTBOTTOMRIGHT	    17
#define HTBORDER	    18
#define HTGROWBOX	    HTSIZE
#define HTREDUCE	    HTMINBUTTON
#define HTZOOM		    HTMAXBUTTON

/****** Drag-and-drop support ***********************************************/

#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES	    0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE	    0
#define WA_ACTIVE	    1
#define WA_CLICKACTIVE	    2

#define WM_ACTIVATE	    0x0006
#define WM_ACTIVATEAPP	    0x001C
#define WM_NCACTIVATE	    0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101

#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103

#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105

#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107


/* Keyboard message range */
#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED	    0x0100
#define KF_DLGMODE	    0x0800
#define KF_MENUMODE	    0x1000
#define KF_ALTDOWN	    0x2000
#define KF_REPEAT	    0x4000
#define KF_UP		    0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON	    0x01
#define VK_RBUTTON	    0x02
#define VK_CANCEL	    0x03
#define VK_MBUTTON          0x04
#define VK_BACK 	    0x08
#define VK_TAB		    0x09
#define VK_CLEAR	    0x0C
#define VK_RETURN	    0x0D
#define VK_SHIFT	    0x10
#define VK_CONTROL	    0x11
#define VK_MENU 	    0x12
#define VK_PAUSE	    0x13
#define VK_CAPITAL	    0x14
#define VK_ESCAPE	    0x1B
#define VK_SPACE	    0x20
#define VK_PRIOR	    0x21
#define VK_NEXT 	    0x22
#define VK_END		    0x23
#define VK_HOME 	    0x24
#define VK_LEFT 	    0x25
#define VK_UP		    0x26
#define VK_RIGHT	    0x27
#define VK_DOWN 	    0x28
#define VK_SELECT	    0x29
#define VK_PRINT	    0x2A
#define VK_EXECUTE	    0x2B
#define VK_SNAPSHOT	    0x2C
#define VK_INSERT	    0x2D
#define VK_DELETE	    0x2E
#define VK_HELP 	    0x2F
#define VK_NUMPAD0	    0x60
#define VK_NUMPAD1	    0x61
#define VK_NUMPAD2	    0x62
#define VK_NUMPAD3	    0x63
#define VK_NUMPAD4	    0x64
#define VK_NUMPAD5	    0x65
#define VK_NUMPAD6	    0x66
#define VK_NUMPAD7	    0x67
#define VK_NUMPAD8	    0x68
#define VK_NUMPAD9	    0x69
#define VK_MULTIPLY	    0x6A
#define VK_ADD		    0x6B
#define VK_SEPARATOR	    0x6C
#define VK_SUBTRACT	    0x6D
#define VK_DECIMAL	    0x6E
#define VK_DIVIDE	    0x6F
#define VK_F1		    0x70
#define VK_F2		    0x71
#define VK_F3		    0x72
#define VK_F4		    0x73
#define VK_F5		    0x74
#define VK_F6		    0x75
#define VK_F7		    0x76
#define VK_F8		    0x77
#define VK_F9		    0x78
#define VK_F10		    0x79
#define VK_F11		    0x7A
#define VK_F12		    0x7B
#define VK_F13		    0x7C
#define VK_F14		    0x7D
#define VK_F15		    0x7E
#define VK_F16		    0x7F
#define VK_F17		    0x80
#define VK_F18		    0x81
#define VK_F19		    0x82
#define VK_F20		    0x83
#define VK_F21		    0x84
#define VK_F22		    0x85
#define VK_F23		    0x86
#define VK_F24		    0x87
#define VK_NUMLOCK	    0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD	    2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE	    0x0200
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON	    0x0001
#define MK_RBUTTON	    0x0002
#define MK_SHIFT	    0x0004
#define MK_CONTROL	    0x0008
#define MK_MBUTTON	    0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE	    0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP	    0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP	    0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP	    0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE	    7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif	/* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE	    0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER	    0x0113

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT	    0x0000
#define MF_CHANGE	    0x0080
#define MF_APPEND	    0x0100
#define MF_DELETE	    0x0200
#define MF_REMOVE	    0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND	    0x0000
#define MF_BYPOSITION	    0x0400

#define MF_SEPARATOR	    0x0800

#define MF_ENABLED	    0x0000
#define MF_GRAYED	    0x0001
#define MF_DISABLED	    0x0002

#define MF_UNCHECKED	    0x0000
#define MF_CHECKED	    0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING	    0x0000
#define MF_BITMAP	    0x0004
#define MF_OWNERDRAW	    0x0100

#define MF_POPUP	    0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK	    0x0040

#define MF_UNHILITE	    0x0000
#define MF_HILITE	    0x0080

#define MF_SYSMENU	    0x2000
#define MF_HELP 	    0x4000
#define MF_MOUSESELECT	    0x8000


#define MF_END		    0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT	    0x011F
#define WM_MENUCHAR	    0x0120

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND	    0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP	    0
#define SB_LINELEFT	    0
#define SB_LINEDOWN	    1
#define SB_LINERIGHT	    1
#define SB_PAGEUP	    2
#define SB_PAGELEFT	    2
#define SB_PAGEDOWN	    3
#define SB_PAGERIGHT	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_LEFT 	    6
#define SB_BOTTOM	    7
#define SB_RIGHT	    7
#define SB_ENDSCROLL	    8

/* Scroll bar selection constants */
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT 	     1
#define CF_BITMAP	     2
#define CF_METAFILEPICT      3
#define CF_SYLK 	     4
#define CF_DIF		     5
#define CF_TIFF 	     6
#define CF_OEMTEXT	     7
#define CF_DIB		     8
#define CF_PALETTE	     9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW	    MAKEINTRESOURCE(32512)
#define IDC_IBEAM	    MAKEINTRESOURCE(32513)
#define IDC_WAIT	    MAKEINTRESOURCE(32514)
#define IDC_CROSS	    MAKEINTRESOURCE(32515)
#define IDC_UPARROW	    MAKEINTRESOURCE(32516)
#define IDC_SIZE	    MAKEINTRESOURCE(32640)
#define IDC_ICON	    MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	    MAKEINTRESOURCE(32644)
#define IDC_SIZENS	    MAKEINTRESOURCE(32645)

#define WM_SETCURSOR	    0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND	    MAKEINTRESOURCE(32513)
#define IDI_QUESTION	    MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	    MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005
#define MB_TYPEMASK	    0x000F

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK	    0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200
#define MB_DEFMASK	    0x0F00

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000



#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND	0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_TASKLIST	0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM 	SC_MAXIMIZE


#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE	    0x0220
#define WM_MDIDESTROY	    0x0221
#define WM_MDIACTIVATE	    0x0222
#define WM_MDIRESTORE	    0x0223
#define WM_MDINEXT	    0x0224
#define WM_MDIMAXIMIZE	    0x0225
#define WM_MDITILE	    0x0226
#define WM_MDICASCADE	    0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU	    0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL	0x0000
#define MDITILE_HORIZONTAL	0x0001
#define MDITILE_SKIPDISABLED	0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG	(MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA	30

/* Dialog styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID	    (WM_USER+0)
#define DM_SETDEFID	    (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID	    0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG	    0x0110
#define WM_NEXTDLGCTL	    0x0028

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE	    0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT	0
#define DWL_DLGPROC	4
#define DWL_USER	8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE	    0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR	    0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT	    1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN	    3
#define CTLCOLOR_DLG	    4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6

#define WM_SETFONT          0x0030
#define WM_GETFONT	    0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK		    1
#define IDCANCEL	    2
#define IDABORT 	    3
#define IDRETRY 	    4
#define IDIGNORE	    5
#define IDYES		    6
#define IDNO		    7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU	1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

/* Owner draw actions */
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT	0x0002
#define ODA_FOCUS	0x0004

/* Owner draw state */
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS	0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND	hwndItem;
    HDC		hDC;
    RECT	rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM	    0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND	hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT 	    0x00000000L
#define SS_CENTER	    0x00000001L
#define SS_RIGHT	    0x00000002L
#define SS_ICON 	    0x00000003L
#define SS_BLACKRECT	    0x00000004L
#define SS_GRAYRECT	    0x00000005L
#define SS_WHITERECT	    0x00000006L
#define SS_BLACKFRAME	    0x00000007L
#define SS_GRAYFRAME	    0x00000008L
#define SS_WHITEFRAME	    0x00000009L
#define SS_SIMPLE	    0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON	    (WM_USER+0)
#define STM_GETICON	    (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON	    0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX	    0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON	    0x00000004L
#define BS_3STATE	    0x00000005L
#define BS_AUTO3STATE	    0x00000006L
#define BS_GROUPBOX	    0x00000007L
#define BS_USERBUTTON	    0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW	    0x0000000BL
#define BS_LEFTTEXT	    0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK	    (WM_USER+0)
#define BM_SETCHECK	    (WM_USER+1)
#define BM_GETSTATE	    (WM_USER+2)
#define BM_SETSTATE	    (WM_USER+3)
#define BM_SETSTYLE	    (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED	    0
#define BN_PAINT	    1
#define BN_HILITE	    2
#define BN_UNHILITE	    3
#define BN_DISABLE	    4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT 	    0x00000000L
#define ES_CENTER	    0x00000001L
#define ES_RIGHT	    0x00000002L
#define ES_MULTILINE	    0x00000004L
#define ES_UPPERCASE	    0x00000008L
#define ES_LOWERCASE	    0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL	    0x00000040L
#define ES_AUTOHSCROLL	    0x00000080L
#define ES_NOHIDESEL	    0x00000100L
#define ES_OEMCONVERT	    0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY	    0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL	        (WM_USER+0)
#define EM_SETSEL	        (WM_USER+1)
#define EM_GETRECT	        (WM_USER+2)
#define EM_SETRECT	        (WM_USER+3)
#define EM_SETRECTNP	        (WM_USER+4)
#define EM_LINESCROLL	        (WM_USER+6)
#define EM_GETMODIFY	        (WM_USER+8)
#define EM_SETMODIFY	        (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX	        (WM_USER+11)
#define EM_SETHANDLE	        (WM_USER+12)
#define EM_GETHANDLE	        (WM_USER+13)
#define EM_LINELENGTH	        (WM_USER+17)
#define EM_REPLACESEL	        (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE	        (WM_USER+20)
#define EM_LIMITTEXT	        (WM_USER+21)
#define EM_CANUNDO	        (WM_USER+22)
#define EM_UNDO 	        (WM_USER+23)
#define EM_FMTLINES	        (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS	        (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE	(WM_USER+30)
#define EM_SETREADONLY	        (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT		   0
#define WB_RIGHT	   1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	      0x0001L
#define LBS_SORT	      0x0002L
#define LBS_NOREDRAW	      0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD	      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	       (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL	       (WM_USER+6)
#define LB_SETCURSEL	       (WM_USER+7)
#define LB_GETSEL	       (WM_USER+8)
#define LB_GETCURSEL	       (WM_USER+9)
#define LB_GETTEXT	       (WM_USER+10)
#define LB_GETTEXTLEN	       (WM_USER+11)
#define LB_GETCOUNT	       (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR		       (WM_USER+14)
#define LB_GETTOPINDEX	       (WM_USER+15)
#define LB_FINDSTRING	       (WM_USER+16)
#define LB_GETSELCOUNT	       (WM_USER+17)
#define LB_GETSELITEMS	       (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX	       (WM_USER+24)
#define LB_GETITEMRECT	       (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE	    (-2)
#define LBN_SELCHANGE	    1
#define LBN_DBLCLK	    2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F

/* Listbox message return values */
#define LB_OKAY 	    0
#define LB_ERR		    (-1)
#define LB_ERRSPACE	    (-2)

#define LB_CTLCODE	    0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */


/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY	    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE	    0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL	         (WM_USER+0)
#define CB_LIMITTEXT	         (WM_USER+1)
#define CB_SETEDITSEL	         (WM_USER+2)
#define CB_ADDSTRING	         (WM_USER+3)
#define CB_DELETESTRING	         (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT	         (WM_USER+6)
#define CB_GETCURSEL	         (WM_USER+7)
#define CB_GETLBTEXT	         (WM_USER+8)
#define CB_GETLBTEXTLEN	         (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT	         (WM_USER+11)
#define CB_FINDSTRING	         (WM_USER+12)
#define CB_SELECTSTRING	         (WM_USER+13)
#define CB_SETCURSEL	         (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE	    (-1)
#define CBN_SELCHANGE	    1
#define CBN_DBLCLK	    2
#define CBN_SETFOCUS	    3
#define CBN_KILLFOCUS	    4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY 	    0
#define CB_ERR		    (-1)
#define CB_ERRSPACE	    (-2)

#endif	/* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */


/* Standard hook code */
#define HC_ACTION	    0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN	    (-3)
#define HC_LPLPFNNEXT	    (-2)
#define HC_LPFNNEXT	    (-1)

#endif	/* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT		    5

#define HCBT_MOVESIZE	    0
#define HCBT_MINMAX	    1
#define HCBT_QS 	    2
#define HCBT_CREATEWND	    3
#define HCBT_DESTROYWND	    4
#define HCBT_ACTIVATE	    5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND	    8
#define HCBT_SETFOCUS	    9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif	/* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE	    8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT	    1
#define HC_SKIP 	    2
#define HC_NOREMOVE	    3
#define HC_NOREM	    HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF	    5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif	/* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG	    9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE	hModuleHook;
    LPARAM	reserved;
    LPARAM	lParam;
    WPARAM	wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY	    0
#define S_THRESHOLD	    1
#define S_ALLTHRESHOLD	    2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY	    0
#define ODDPARITY	    1
#define EVENPARITY	    2
#define MARKPARITY	    3
#define SPACEPARITY	    4

#define ONESTOPBIT	    0
#define ONE5STOPBITS	    1
#define TWOSTOPBITS	    2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE	    EV_RingTe

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110	     0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY		0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int	FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD		0x0001
#define DRV_ENABLE		0x0002
#define DRV_OPEN		0x0003
#define DRV_CLOSE		0x0004
#define DRV_DISABLE		0x0005
#define DRV_FREE		0x0006
#define DRV_CONFIGURE		0x0007
#define DRV_QUERYCONFIGURE	0x0008
#define DRV_INSTALL		0x0009
#define DRV_REMOVE		0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER		0x000F

#define DRV_RESERVED		0x0800
#define DRV_USER		0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL		0x0000
#define DRVCNF_OK		0x0001
#define DRVCNF_RESTART		0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY	0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE		0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\icon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	icon.h
//
//  Contents:	icon.h from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

/*
 * ICON.H
 *
 * This file contains definitions and function prototypes used in geticon.c
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#if !defined( _ICON_H )
#define _ICON_H_

#if !defined( IDS_DEFICONLABEL )
#define IDS_DEFICONLABEL    310
#endif

STDAPI_(int)        XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int)        XformWidthInPixelsToHimetric(HDC, int);
STDAPI_(int)        XformHeightInHimetricToPixels(HDC, int);
STDAPI_(int)        XformHeightInPixelsToHimetric(HDC, int);

HICON FAR PASCAL    HIconAndSourceFromClass(REFCLSID, LPSTR, UINT FAR *);

BOOL FAR PASCAL		FIconFileFromClass(REFCLSID, LPSTR, UINT, UINT FAR *);

LPSTR FAR PASCAL    PointerToNthField(LPSTR, int, char);

BOOL FAR PASCAL		GetAssociatedExecutable(LPSTR, LPSTR);


STDAPI_(UINT)		OleStdGetAuxUserType(REFCLSID rclsid,
                                      WORD   wAuxUserType, 
                                      LPSTR  lpszAuxUserType, 
                                      int    cch,
                                      HKEY   hKey);

STDAPI_(UINT)		OleStdGetUserTypeOfClass(REFCLSID rclsid, 
                                           LPSTR lpszUserType, 
                                           UINT cch, 
                                           HKEY hKey);

STDAPI_(UINT)		OleStdIconLabelTextOut(HDC        hDC, 
                                         HFONT      hFont,
                                         int        nXStart, 
                                         int        nYStart, 
                                         UINT       fuOptions, 
                                         RECT FAR * lpRect, 
                                         LPSTR      lpszString, 
                                         UINT       cchString, 
                                         int FAR *  lpDX);

#endif // _ICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Precompiled header file
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include <compobj.h>
#include <storage.h>
#include <ole2.h>

#include <interop.hxx>
#include <wow16fn.h>
#include <io16.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\icon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	icon.cxx
//
//  Contents:	icon.cpp from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

/*
 *  ICON.CPP
 *
 *  Functions to create DVASPECT_ICON metafile from filename or classname.
 *
 *  OleGetIconOfFile
 *  OleGetIconOfClass
 *  OleMetafilePictFromIconAndLabel
 *
 *  HIconAndSourceFromClass Extracts the first icon in a class's server path
 *                          and returns the path and icon index to caller.
 *  FIconFileFromClass      Retrieves the path to the exe/dll containing the
 *                           default icon, and the index of the icon.
 *  OleStdIconLabelTextOut
 *  PointerToNthField
 *  XformWidthInPixelsToHimetric  Converts an int width into HiMetric units
 *  XformWidthInHimetricToPixels  Converts an int width from HiMetric units
 *  XformHeightInPixelsToHimetric Converts an int height into HiMetric units
 *  XformHeightInHimetricToPixels Converts an int height from HiMetric units
 *
 *    (c) Copyright Microsoft Corp. 1992-1993 All Rights Reserved
 */

#include <ole2int.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>
#include <stdio.h>

#include "icon.h"

static char szMaxWidth[] ="WWWWWWWWWW";

//Strings for metafile comments.
static char szIconOnly[]="IconOnly";        //Where to stop to exclude label.

#define OLEUI_CCHKEYMAX      256
#define OLEUI_CCHPATHMAX     256
#define OLEUI_CCHLABELMAX     40

#define ICONINDEX              0

#define AUXUSERTYPE_SHORTNAME  USERCLASSTYPE_SHORT  // short name
#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define PTS_PER_INCH          72      // number points (font size) per inch

#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

static char szVanillaDocIcon[] = "DefIcon";

static char szDocument[OLEUI_CCHLABELMAX] = "";
static char szSeparators[] = " \t\\/!:";
static const char szDefIconLabelKey[] = "Software\\Microsoft\\OLE2\\DefaultIconLabel";

#define IS_SEPARATOR(c)         ( (c) == ' ' || (c) == '\\' || (c) == '/' || (c) == '\t' || (c) == '!' || (c) == ':' )
#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':' )

#define LSTRCPYN(lpdst, lpsrc, cch) \
(\
	lpdst[cch-1] = '\0', \
	lstrcpyn(lpdst, lpsrc, cch-1)\
)


/*******
 *
 * ICON METAFILE FORMAT:
 *
 * The metafile generated with OleMetafilePictFromIconAndLabel contains
 * the following records which are used by the functions in DRAWICON.C
 * to draw the icon with and without the label and to extract the icon,
 * label, and icon source/index.
 *
 *  SetWindowOrg
 *  SetWindowExt
 *  DrawIcon:
 *      Inserts records of DIBBITBLT or DIBSTRETCHBLT, once for the
 *      AND mask, one for the image bits.
 *  Escape with the comment "IconOnly"
 *      This indicates where to stop record enumeration to draw only
 *      the icon.
 *  SetTextColor
 *  SetBkColor
 *  CreateFont
 *  SelectObject on the font.
 *  ExtTextOut
 *      One or more ExtTextOuts occur if the label is wrapped.  The
 *      text in these records is used to extract the label.
 *  SelectObject on the old font.
 *  DeleteObject on the font.
 *  Escape with a comment that contains the path to the icon source.
 *  Escape with a comment that is the ASCII of the icon index.
 *
 *******/




/*
 * OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel)
 *
 * Purpose:
 *  Returns a hMetaPict containing an icon and label (filename) for the
 *  specified filename.
 *
 * Parameters:
 *  lpszPath        LPSTR path including filename to use
 *  fUseFileAsLabel BOOL TRUE if the icon's label is the filename, FALSE if
 *                  there should be no label.
 *
 * Return Value:
 *  HGLOBAL         hMetaPict containing the icon and label - if there's no
 *                  class in reg db for the file in lpszPath, then we use
 *                  Document.  If lpszPath is NULL, then we return NULL.
 */

STDAPI_(HGLOBAL) OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel)
{


  char     szIconFile[OLEUI_CCHPATHMAX];
  char     szLabel[OLEUI_CCHLABELMAX];
  LPSTR    lpszClsid = NULL;
  CLSID    clsid;
  HICON    hDefIcon = NULL;
  UINT     IconIndex = 0;
  HGLOBAL  hMetaPict;
  HRESULT  hResult;

  if (NULL == lpszPath)  // even if fUseFileAsLabel is FALSE, we still
    return NULL;             // need a valid filename to get the class.

  hResult = GetClassFile(lpszPath, &clsid);

  if (NOERROR == hResult)  // use the clsid we got to get to the icon
  {
      hDefIcon = HIconAndSourceFromClass(clsid,
                                         (LPSTR)szIconFile,
                                         &IconIndex);
  }

  if ( (NOERROR != hResult) || (NULL == hDefIcon) )
  {
     // Here, either GetClassFile failed or HIconAndSourceFromClass failed.

     LPSTR lpszTemp;

     lpszTemp = lpszPath;

     while ((*lpszTemp != '.') && (*lpszTemp != '\0'))
        lpszTemp++;


     if ('.' != *lpszTemp)
       goto UseVanillaDocument;


     if (FALSE == GetAssociatedExecutable(lpszTemp, (LPSTR)szIconFile))
       goto UseVanillaDocument;

     hDefIcon = ExtractIcon(hmodOLE2, szIconFile, IconIndex);
  }

  if (hDefIcon <= (HICON)1) // ExtractIcon returns 1 if szExecutable is not exe,
  {                         // 0 if there are no icons.
UseVanillaDocument:
    
	if (!GetModuleFileName(hmodOLE2, (LPSTR)szIconFile, OLEUI_CCHPATHMAX))
	    szIconFile[0] = 0;
	
    IconIndex = ICONINDEX;
    hDefIcon = LoadIcon(hmodOLE2, (LPSTR)szVanillaDocIcon);
  }

  // Now let's get the label we want to use.

  if (fUseFileAsLabel)   // strip off path, so we just have the filename.
  {
     int istrlen;
     LPSTR lpszBeginFile;

     istrlen = lstrlen(lpszPath);

     // set pointer to END of path, so we can walk backwards through it.
     lpszBeginFile = lpszPath + istrlen -1;

     while ( (lpszBeginFile >= lpszPath)
             && (!IS_FILENAME_DELIM(*lpszBeginFile)) )
      lpszBeginFile--;


     lpszBeginFile++;  // step back over the delimiter


     LSTRCPYN(szLabel, lpszBeginFile, sizeof(szLabel));
  }

  else   // use the short user type (AuxUserType2) for the label
  {

      if (0 == OleStdGetAuxUserType(clsid, AUXUSERTYPE_SHORTNAME,
                                   (LPSTR)szLabel, OLEUI_CCHLABELMAX, NULL)) {

         if ('\0'==szDocument[0]) {
		 	LONG cb = sizeof (szDocument);
		 	RegQueryValue (HKEY_CLASSES_ROOT, szDefIconLabelKey, szDocument,
							&cb);
			// if szDocument is not big enough, RegQueryValue puts a NULL
			// at the end so we are safe.
			// if RegQueryValue fails, szDocument[0]=='\0' so we'll use that.
         }
         lstrcpy(szLabel, szDocument);
      }
  }


  hMetaPict = OleMetafilePictFromIconAndLabel(hDefIcon,
                                                szLabel,
                                                (LPSTR)szIconFile,
                                                IconIndex);

  DestroyIcon(hDefIcon);

  return hMetaPict;

}

/*
 * GetAssociatedExecutable
 *
 * Purpose:  Finds the executable associated with the provided extension
 *
 * Parameters:
 *   lpszExtension   LPSTR points to the extension we're trying to find an exe
 *                   for. Does **NO** validation.
 *
 *   lpszExecutable  LPSTR points to where the exe name will be returned.
 *                   No validation here either - pass in 128 char buffer.
 *
 * Return:
 *   BOOL            TRUE if we found an exe, FALSE if we didn't.
 *
 */

BOOL FAR PASCAL GetAssociatedExecutable(LPSTR lpszExtension, LPSTR lpszExecutable)

{
   HKEY    hKey;
   LONG	   dw;
   LRESULT lRet;
   char    szValue[OLEUI_CCHKEYMAX];
   char    szKey[OLEUI_CCHKEYMAX];
   LPSTR   lpszTemp, lpszExe;


   lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

   if (ERROR_SUCCESS != lRet)
      return FALSE;

   dw = OLEUI_CCHPATHMAX;
   lRet = RegQueryValue(hKey, lpszExtension, (LPSTR)szValue, &dw);  //ProgId

   if (ERROR_SUCCESS != lRet)
   {
      RegCloseKey(hKey);
      return FALSE;
   }


   // szValue now has ProgID
   szKey[sizeof(szKey)/sizeof(szKey[0]) - 1] = 0;
   if ((_snprintf(szKey, sizeof(szKey)/sizeof(szKey[0]), "%s%s", szValue, szKey) < 0) ||
      (szKey[sizeof(szKey)/sizeof(szKey[0]) - 1] != 0))
   {
      RegCloseKey(hKey);
      return FALSE;
   }

   dw = OLEUI_CCHPATHMAX;
   lRet = RegQueryValue(hKey, (LPSTR)szKey, (LPSTR)szValue, &dw);

   if (ERROR_SUCCESS != lRet)
   {
      RegCloseKey(hKey);
      return FALSE;
   }

   // szValue now has an executable name in it.  Let's null-terminate
   // at the first post-executable space (so we don't have cmd line
   // args.

   lpszTemp = (LPSTR)szValue;

   while (('\0' != *lpszTemp) && (isspace(*lpszTemp)))
      lpszTemp++;     // Strip off leading spaces

   lpszExe = lpszTemp;

   while (('\0' != *lpszTemp) && (!isspace(*lpszTemp)))
      lpszTemp++;     // Set through exe name

   *lpszTemp = '\0';  // null terminate at first space (or at end).


   lstrcpy(lpszExecutable, lpszExe);

   return TRUE;

}





/*
 * OleGetIconOfClass(REFCLSID rclsid, LPSTR lpszLabel, BOOL fUseTypeAsLabel)
 *
 * Purpose:
 *  Returns a hMetaPict containing an icon and label (human-readable form
 *  of class) for the specified clsid.
 *
 * Parameters:
 *  rclsid          REFCLSID pointing to clsid to use.
 *  lpszLabel       label to use for icon.
 *  fUseTypeAsLabel Use the clsid's user type name as the icon's label.
 *
 * Return Value:
 *  HGLOBAL         hMetaPict containing the icon and label - if we
 *                  don't find the clsid in the reg db then we
 *                  return NULL.
 */

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid, LPSTR lpszLabel, BOOL fUseTypeAsLabel)
{

  char    szLabel[OLEUI_CCHLABELMAX];
  char    szIconFile[OLEUI_CCHPATHMAX];
  HICON   hDefIcon;
  UINT    IconIndex;
  HGLOBAL hMetaPict;

  if (!fUseTypeAsLabel)  // Use string passed in as label
  {
    if (NULL != lpszLabel)
       LSTRCPYN(szLabel, lpszLabel, sizeof(szLabel));
    else
       *szLabel = '\0';
  }
  else   // Use AuxUserType2 (short name) as label
  {

      if (0 == OleStdGetAuxUserType(rclsid,
                                    AUXUSERTYPE_SHORTNAME,
                                    (LPSTR)szLabel,
                                    OLEUI_CCHLABELMAX,
                                    NULL))

       // If we can't get the AuxUserType2, then try the long name
       if (0 == OleStdGetUserTypeOfClass(rclsid, szLabel, OLEUI_CCHKEYMAX, NULL)) {
         if ('\0'==szDocument[0]) {
		 	LONG cb = sizeof (szDocument);
		 	RegQueryValue (HKEY_CLASSES_ROOT, szDefIconLabelKey, szDocument,
							&cb);
			// if RegQueryValue fails, szDocument=="" so we'll use that.
         }
         lstrcpy(szLabel, szDocument);  // last resort
       }
  }

  // Get the icon, icon index, and path to icon file
  hDefIcon = HIconAndSourceFromClass(rclsid,
                  (LPSTR)szIconFile,
                  &IconIndex);

  if (NULL == hDefIcon)  // Use Vanilla Document
  {
    if (!GetModuleFileName(hmodOLE2, (LPSTR)szIconFile, OLEUI_CCHPATHMAX))
        szIconFile[0] = 0;
    
    IconIndex = ICONINDEX;
    hDefIcon = LoadIcon(hmodOLE2, (LPSTR)szVanillaDocIcon);
  }

  // Create the metafile
  hMetaPict = OleMetafilePictFromIconAndLabel(hDefIcon, szLabel,
                                                (LPSTR)szIconFile, IconIndex);

  DestroyIcon(hDefIcon);

  return hMetaPict;

}





/*
 * HIconAndSourceFromClass
 *
 * Purpose:
 *  Given an object class name, finds an associated executable in the
 *  registration database and extracts the first icon from that
 *  executable.  If none is available or the class has no associated
 *  executable, this function returns NULL.
 *
 * Parameters:
 *  rclsid          pointer to clsid to look up.
 *  pszSource       LPSTR in which to place the source of the icon.
 *                  This is assumed to be OLEUI_CCHPATHMAX
 *  puIcon          UINT FAR * in which to store the index of the
 *                  icon in pszSource.
 *
 * Return Value:
 *  HICON           Handle to the extracted icon if there is a module
 *                  associated to pszClass.  NULL on failure to either
 *                  find the executable or extract and icon.
 */

HICON FAR PASCAL HIconAndSourceFromClass(REFCLSID rclsid, LPSTR pszSource, UINT FAR *puIcon)
    {
    HICON           hIcon;
    UINT            IconIndex;

    if (CLSID_NULL==rclsid || NULL==pszSource)
        return NULL;

    if (!FIconFileFromClass(rclsid, pszSource, OLEUI_CCHPATHMAX, &IconIndex))
        return NULL;

    hIcon=ExtractIcon(hmodOLE2, pszSource, IconIndex);

    if ((HICON)32 > hIcon)
        hIcon=NULL;
    else
        *puIcon= IconIndex;

    return hIcon;
    }



/*
 * FIconFileFromClass
 *
 * Purpose:
 *  Looks up the path to executable that contains the class default icon.
 *
 * Parameters:
 *  rclsid          pointer to CLSID to look up.
 *  pszEXE          LPSTR at which to store the server name
 *  cch             UINT size of pszEXE
 *  lpIndex         LPUINT to index of icon within executable
 *
 * Return Value:
 *  BOOL            TRUE if one or more characters were loaded into pszEXE.
 *                  FALSE otherwise.
 */

BOOL FAR PASCAL FIconFileFromClass(REFCLSID rclsid, LPSTR pszEXE, UINT cch, UINT FAR *lpIndex)
{

    LONG          dw;
    LONG          lRet;
    HKEY          hKey;
    LPMALLOC      lpIMalloc;
    HRESULT       hrErr;
    LPSTR         lpBuffer;
    LPSTR         lpIndexString;
    UINT          cBufferSize = 136;  // room for 128 char path and icon's index
    char          szKey[64];
    LPSTR         pszClass;


    if (CLSID_NULL==rclsid || NULL==pszEXE || 0==cch)
        return FALSE;

    //Here, we use CoGetMalloc and alloc a buffer (maxpathlen + 8) to
    //pass to RegQueryValue.  Then, we copy the exe to pszEXE and the
    //index to *lpIndex.

    hrErr = CoGetMalloc(MEMCTX_TASK, &lpIMalloc);

    if (NOERROR != hrErr)
      return FALSE;

    lpBuffer = (LPSTR)lpIMalloc->Alloc(cBufferSize);

    if (NULL == lpBuffer)
    {
      lpIMalloc->Release();
      return FALSE;
    }


    if (CoIsOle1Class(rclsid))
    {

      LPSTR lpszProgID;

      // we've got an ole 1.0 class on our hands, so we look at
      // progID\protocol\stdfileedting\server to get the
      // name of the executable.

      ProgIDFromCLSID(rclsid, &lpszProgID);

      //Open up the class key
      lRet=RegOpenKey(HKEY_CLASSES_ROOT, lpszProgID, &hKey);

      if (ERROR_SUCCESS != lRet)
      {
         lpIMalloc->Free(lpszProgID);
         lpIMalloc->Free(lpBuffer);
         lpIMalloc->Release();
         return FALSE;
      }

      dw=(LONG)cBufferSize;
      lRet = RegQueryValue(hKey, "Protocol\\StdFileEditing\\Server", lpBuffer, &dw);

      if (ERROR_SUCCESS != lRet)
      {

         RegCloseKey(hKey);
         lpIMalloc->Free(lpszProgID);
         lpIMalloc->Free(lpBuffer);
         lpIMalloc->Release();
         return FALSE;
      }


      // Use server and 0 as the icon index
      LSTRCPYN(pszEXE, lpBuffer, cch);

      *lpIndex = 0;

      RegCloseKey(hKey);
      lpIMalloc->Free(lpszProgID);
      lpIMalloc->Free(lpBuffer);
      lpIMalloc->Release();
      return TRUE;

    }



    /*
     * We have to go walking in the registration database under the
     * classname, so we first open the classname key and then check
     * under "\\DefaultIcon" to get the file that contains the icon.
     */

    StringFromCLSID(rclsid, &pszClass);

    lstrcpy(szKey, "CLSID\\");
    lstrcat(szKey, pszClass);

    //Open up the class key
    lRet=RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKey);

    if (ERROR_SUCCESS != lRet)
    {
        lpIMalloc->Free(lpBuffer);
        lpIMalloc->Free(pszClass);
        lpIMalloc->Release();
        return FALSE;
    }

    //Get the executable path and icon index.

    dw=(LONG)cBufferSize;
    lRet=RegQueryValue(hKey, "DefaultIcon", lpBuffer, &dw);

    if (ERROR_SUCCESS != lRet)
    {
      // no DefaultIcon  key...try LocalServer

      dw=(LONG)cBufferSize;
      lRet=RegQueryValue(hKey, "LocalServer", lpBuffer, &dw);

      if (ERROR_SUCCESS != lRet)
      {
         // no LocalServer entry either...they're outta luck.

         RegCloseKey(hKey);
         lpIMalloc->Free(lpBuffer);
         lpIMalloc->Free(pszClass);
         lpIMalloc->Release();
         return FALSE;
      }


      // Use server from LocalServer or Server and 0 as the icon index
      LSTRCPYN(pszEXE, lpBuffer, cch);

      *lpIndex = 0;

      RegCloseKey(hKey);
      lpIMalloc->Free(lpBuffer);
      lpIMalloc->Free(pszClass);
      lpIMalloc->Release();
      return TRUE;
    }

    RegCloseKey(hKey);

    // lpBuffer contains a string that looks like "<pathtoexe>,<iconindex>",
    // so we need to separate the path and the icon index.

    lpIndexString = PointerToNthField(lpBuffer, 2, ',');

    if ('\0' == *lpIndexString)  // no icon index specified - use 0 as default.
    {
       *lpIndex = 0;

    }
    else
    {
       LPSTR lpTemp;
       static char  szTemp[16];

       LSTRCPYN(((LPSTR)szTemp), lpIndexString, sizeof(szTemp));

       // Put the icon index part into *pIconIndex
       *lpIndex = atoi((const char *)szTemp);

       // Null-terminate the exe part.
       lpTemp = AnsiPrev(lpBuffer, lpIndexString);
       *lpTemp = '\0';
    }

    if (!LSTRCPYN(pszEXE, lpBuffer, cch))
    {
       lpIMalloc->Free(lpBuffer);
       lpIMalloc->Free(pszClass);
       lpIMalloc->Release();
       return FALSE;
    }

    // Free the memory we alloc'd and leave.
    lpIMalloc->Free(lpBuffer);
    lpIMalloc->Free(pszClass);
    lpIMalloc->Release();
    return TRUE;
}




/*
 * OleMetafilePictFromIconAndLabel
 *
 * Purpose:
 *  Creates a METAFILEPICT structure that container a metafile in which
 *  the icon and label are drawn.  A comment record is inserted between
 *  the icon and the label code so our special draw function can stop
 *  playing before the label.
 *
 * Parameters:
 *  hIcon           HICON to draw into the metafile
 *  pszLabel        LPSTR to the label string.
 *  pszSourceFile   LPSTR containing the local pathname of the icon
 *                  as we either get from the user or from the reg DB.
 *  iIcon           UINT providing the index into pszSourceFile where
 *                  the icon came from.
 *
 * Return Value:
 *  HGLOBAL         Global memory handle containing a METAFILEPICT where
 *                  the metafile uses the MM_ANISOTROPIC mapping mode.  The
 *                  extents reflect both icon and label.
 */

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPSTR pszLabel
    , LPSTR pszSourceFile, UINT iIcon)
    {
    HDC             hDC, hDCScreen;
    HMETAFILE       hMF;
    HGLOBAL         hMem;
    LPMETAFILEPICT  pMF;
    UINT            cxIcon, cyIcon;
    UINT            cxText, cyText;
    UINT            cx, cy;
    UINT            cchLabel = 0;
    HFONT           hFont, hSysFont, hFontT;
    int             cyFont;
    char            szIndex[10];
    RECT            TextRect;
    SIZE            size;
    POINT           point;
    LOGFONT         logfont;

    if (NULL==hIcon)  // null icon is valid
        return NULL;

    //Create a memory metafile
    hDC=(HDC)CreateMetaFile(NULL);

    if (NULL==hDC)
        return NULL;

    //Allocate the metafilepict
    hMem=GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, sizeof(METAFILEPICT));

    if (NULL==hMem)
        {
        hMF=CloseMetaFile(hDC);
        DeleteMetaFile(hMF);
        return NULL;
        }


    if (NULL!=pszLabel)
        {
        cchLabel=lstrlen(pszLabel);

        if (cchLabel >= OLEUI_CCHLABELMAX)
           pszLabel[cchLabel] = '\0';   // truncate string
        }

    //Need to use the screen DC for these operations
    hDCScreen=GetDC(NULL);
    cyFont=-(8*GetDeviceCaps(hDCScreen, LOGPIXELSY))/72;

    //cyFont was calculated to give us 8 point.

    //  We use the system font as the basis for the character set,
    //  allowing us to handle DBCS strings better
    hSysFont = GetStockObject( SYSTEM_FONT );
    GetObject(hSysFont, sizeof(LOGFONT), &logfont);
    hFont=CreateFont(cyFont, 5, 0, 0, FW_NORMAL, 0, 0, 0, logfont.lfCharSet
             , OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY
             , FF_SWISS, "MS Sans Serif");

    hFontT=SelectObject(hDCScreen, hFont);

    GetTextExtentPoint(hDCScreen,szMaxWidth,lstrlen(szMaxWidth),&size);
    SelectObject(hDCScreen, hFontT);

    cxText = size.cx;
    cyText = size.cy * 2;

    cxIcon = GetSystemMetrics(SM_CXICON);
    cyIcon = GetSystemMetrics(SM_CYICON);


    // If we have no label, then we want the metafile to be the width of
    // the icon (plus margin), not the width of the fattest string.
    if ( (NULL == pszLabel) || (NULL == *pszLabel) )
        cx = cxIcon + cxIcon / 4;
    else
        cx = max(cxText, cxIcon);

    cy=cyIcon+cyText+4;

    //Set the metafile size to fit the icon and label
    SetWindowOrgEx(hDC, 0, 0, &point);
    SetWindowExtEx(hDC, cx, cy, &size);

    //Set up rectangle to pass to OleStdIconLabelTextOut
    SetRectEmpty(&TextRect);

    TextRect.right = cx;
    TextRect.bottom = cy;

    //Draw the icon and the text, centered with respect to each other.
    DrawIcon(hDC, (cx-cxIcon)/2, 0, hIcon);

    //String that indicates where to stop if we're only doing icons
    Escape(hDC, MFCOMMENT, lstrlen(szIconOnly)+1, szIconOnly, NULL);

    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    SetBkMode(hDC, TRANSPARENT);

    OleStdIconLabelTextOut(hDC,
                           hFont,
                           0,
                           cy - cyText,
                           ETO_CLIPPED,
                           &TextRect,
                           pszLabel,
                           cchLabel,
                           NULL);

    //Write comments containing the icon source file and index.
    if (NULL!=pszSourceFile)
        {
        //+1 on string lengths insures the null terminator is embedded.
        Escape(hDC, MFCOMMENT, lstrlen(pszSourceFile)+1, pszSourceFile, NULL);

        cchLabel=wsprintf(szIndex, "%u", iIcon);
        Escape(hDC, MFCOMMENT, cchLabel+1, szIndex, NULL);
        }

    //All done with the metafile, now stuff it all into a METAFILEPICT.
    hMF=CloseMetaFile(hDC);

    if (NULL==hMF)
        {
        GlobalFree(hMem);
		ReleaseDC(NULL, hDCScreen);
        return NULL;
        }

    //Fill out the structure
    pMF=(LPMETAFILEPICT)GlobalLock(hMem);

    //Transform to HIMETRICS
    cx=XformWidthInPixelsToHimetric(hDCScreen, cx);
    cy=XformHeightInPixelsToHimetric(hDCScreen, cy);
	ReleaseDC(NULL, hDCScreen);
	
    pMF->mm=MM_ANISOTROPIC;
    pMF->xExt=cx;
    pMF->yExt=cy;
    pMF->hMF=hMF;

    GlobalUnlock(hMem);

    DeleteObject(hFont);

    return hMem;
    }



/*
 * OleStdIconLabelTextOut
 *
 * Purpose:
 *  Replacement for DrawText to be used in the "Display as Icon" metafile.
 *  Uses ExtTextOut to output a string center on (at most) two lines.
 *  Uses a very simple word wrap algorithm to split the lines.
 *
 * Parameters:  (same as for ExtTextOut, except for hFont)
 *  hDC           device context to draw into; if this is NULL, then we don't
 *                ETO the text, we just return the index of the beginning
 *                of the second line
 *  hFont         font to use
 *  nXStart       x-coordinate of starting position
 *  nYStart       y-coordinate of starting position
 *  fuOptions     rectangle type
 *  lpRect        rect far * containing rectangle to draw text in.
 *  lpszString    string to draw
 *  cchString     length of string (truncated if over OLEUI_CCHLABELMAX)
 *  lpDX          spacing between character cells
 *
 * Return Value:
 *  UINT          Index of beginning of last line (0 if there's only one
 *                line of text).
 *
 */

STDAPI_(UINT) OleStdIconLabelTextOut(HDC        hDC,
                                     HFONT      hFont,
                                     int        nXStart,
                                     int        nYStart,
                                     UINT       fuOptions,
                                     RECT FAR * lpRect,
                                     LPSTR      lpszString,
                                     UINT       cchString,
                                     int FAR *  lpDX)
{

  HDC          hDCScreen;
  static char  szTempBuff[OLEUI_CCHLABELMAX];
  int          cxString, cyString, cxMaxString;
  int          cxFirstLine, cyFirstLine, cxSecondLine;
  int          index;
  int          cch = cchString;
  char         chKeep;
  LPSTR        lpszSecondLine;
  HFONT        hFontT;
  BOOL         fPrintText = TRUE;
  UINT         iLastLineStart = 0;
  SIZE         size;  

  // Initialization stuff...

  if (NULL == hDC)  // If we got NULL as the hDC, then we don't actually call ETO
    fPrintText = FALSE;


  // Make a copy of the string (NULL or non-NULL) that we're using
  if (NULL == lpszString)
    *szTempBuff = '\0';

  else
    LSTRCPYN(szTempBuff, lpszString, sizeof(szTempBuff));

  // set maximum width
  cxMaxString = lpRect->right - lpRect->left;

  // get screen DC to do text size calculations
  hDCScreen = GetDC(NULL);

  hFontT=SelectObject(hDCScreen, hFont);

  // get the extent of our label
  GetTextExtentPoint(hDCScreen, szTempBuff, cch, &size);

  cxString = size.cx;
  cyString = size.cy;

  // Select in the font we want to use
  if (fPrintText)
     SelectObject(hDC, hFont);

  // String is smaller than max string - just center, ETO, and return.
  if (cxString <= cxMaxString)
  {

    if (fPrintText)
       ExtTextOut(hDC,
                  nXStart + (lpRect->right - cxString) / 2,
                  nYStart,
                  fuOptions,
                  lpRect,
                  szTempBuff,
                  cch,
                  NULL);

    iLastLineStart = 0;  // only 1 line of text
    goto CleanupAndLeave;
  }

  // String is too long...we've got to word-wrap it.


  // Are there any spaces, slashes, tabs, or bangs in string?

  if (lstrlen(szTempBuff) != (int)strcspn(szTempBuff, szSeparators))
  {
     // Yep, we've got spaces, so we'll try to find the largest
     // space-terminated string that will fit on the first line.

     index = cch;


     while (index >= 0)
     {

       char cchKeep;

       // scan the string backwards for spaces, slashes, tabs, or bangs

       while (!IS_SEPARATOR(szTempBuff[index]) )
         index--;


       if (index <= 0)
         break;

       cchKeep = szTempBuff[index];  // remember what char was there

       szTempBuff[index] = '\0';  // just for now

       GetTextExtentPoint(
               hDCScreen, (LPSTR)szTempBuff,lstrlen((LPSTR)szTempBuff),&size);

       cxFirstLine = size.cx;
       cyFirstLine = size.cy;

       szTempBuff[index] = cchKeep;   // put the right char back

       if (cxFirstLine <= cxMaxString)
       {

           iLastLineStart = index + 1;

           if (!fPrintText)
             goto CleanupAndLeave;

           ExtTextOut(hDC,
                      nXStart +  (lpRect->right - cxFirstLine) / 2,
                      nYStart,
                      fuOptions,
                      lpRect,
                      (LPSTR)szTempBuff,
                      index + 1,
                      lpDX);

           lpszSecondLine = (LPSTR)szTempBuff;

           lpszSecondLine += index + 1;

           GetTextExtentPoint(hDCScreen,
                                    lpszSecondLine,
                                    lstrlen(lpszSecondLine),
                                    &size);

           // If the second line is wider than the rectangle, we
           // just want to clip the text.
           cxSecondLine = min(size.cx, cxMaxString);

           ExtTextOut(hDC,
                      nXStart + (lpRect->right - cxSecondLine) / 2,
                      nYStart + cyFirstLine,
                      fuOptions,
                      lpRect,
                      lpszSecondLine,
                      lstrlen(lpszSecondLine),
                      lpDX);

           goto CleanupAndLeave;

       }  // end if

       index--;

     }  // end while

  }  // end if

  // Here, there are either no spaces in the string (strchr(szTempBuff, ' ')
  // returned NULL), or there spaces in the string, but they are
  // positioned so that the first space terminated string is still
  // longer than one line. So, we walk backwards from the end of the
  // string until we find the largest string that will fit on the first
  // line , and then we just clip the second line.

  cch = lstrlen((LPSTR)szTempBuff);

  chKeep = szTempBuff[cch];
  szTempBuff[cch] = '\0';

  GetTextExtentPoint(hDCScreen, szTempBuff, lstrlen(szTempBuff),&size);

  cxFirstLine = size.cx;
  cyFirstLine = size.cy;

  while (cxFirstLine > cxMaxString)
  {
     // We allow 40 characters in the label, but the metafile is
     // only as wide as 10 W's (for aesthetics - 20 W's wide looked
     // dumb.  This means that if we split a long string in half (in
     // terms of characters), then we could still be wider than the
     // metafile.  So, if this is the case, we just step backwards
     // from the halfway point until we get something that will fit.
     // Since we just let ETO clip the second line

     szTempBuff[cch--] = chKeep;
     if (0 == cch)
       goto CleanupAndLeave;

     chKeep = szTempBuff[cch];
     szTempBuff[cch] = '\0';

     GetTextExtentPoint(
             hDCScreen, szTempBuff, lstrlen(szTempBuff), &size);
     cxFirstLine = size.cx;
  }

  iLastLineStart = cch;

  if (!fPrintText)
    goto CleanupAndLeave;

  ExtTextOut(hDC,
             nXStart + (lpRect->right - cxFirstLine) / 2,
             nYStart,
             fuOptions,
             lpRect,
             (LPSTR)szTempBuff,
             lstrlen((LPSTR)szTempBuff),
             lpDX);

  szTempBuff[cch] = chKeep;
  lpszSecondLine = szTempBuff;
  lpszSecondLine += cch;

  GetTextExtentPoint(
          hDCScreen, (LPSTR)lpszSecondLine, lstrlen(lpszSecondLine), &size);

  // If the second line is wider than the rectangle, we
  // just want to clip the text.
  cxSecondLine = min(size.cx, cxMaxString);

  ExtTextOut(hDC,
             nXStart + (lpRect->right - cxSecondLine) / 2,
             nYStart + cyFirstLine,
             fuOptions,
             lpRect,
             lpszSecondLine,
             lstrlen(lpszSecondLine),
             lpDX);

CleanupAndLeave:
  SelectObject(hDCScreen, hFontT);
  ReleaseDC(NULL, hDCScreen);
  return iLastLineStart;

}


/*
 * OleStdGetUserTypeOfClass(REFCLSID, LPSTR, UINT, HKEY)
 *
 * Purpose:
 *  Returns the user type (human readable class name) of the specified class.
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve user type of.
 *  lpszUserType    pointer to buffer to return user type in.
 *  cch             length of buffer pointed to by lpszUserType
 *  hKey            hKey for reg db - if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \ root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *
 * Return Value:
 *  UINT            Number of characters in returned string.  0 on error.
 *
 */
STDAPI_(UINT) OleStdGetUserTypeOfClass(REFCLSID rclsid, LPSTR lpszUserType, UINT cch, HKEY hKey)
{

   LONG     dw;
   LONG     lRet;
   LPSTR    lpszCLSID, lpszProgID;
   BOOL     fFreeProgID = FALSE;
   BOOL     bCloseRegDB = FALSE;
   char     szKey[128];
   LPMALLOC lpIMalloc;

   if (hKey == NULL)
   {

     //Open up the root key.
     lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

     if ((LONG)ERROR_SUCCESS!=lRet)
       return (UINT)FALSE;

     bCloseRegDB = TRUE;
   }

   // Get a string containing the class name
   StringFromCLSID(rclsid, &lpszCLSID);

   wsprintf(szKey, "CLSID\\%s", lpszCLSID);


   dw=cch;
   lRet = RegQueryValue(hKey, szKey, lpszUserType, &dw);

   if ((LONG)ERROR_SUCCESS!=lRet)
       dw = 0;

   if ( ((LONG)ERROR_SUCCESS!=lRet) && (CoIsOle1Class(rclsid)) )
   {
      // We've got an OLE 1.0 class, so let's try to get the user type
      // name from the ProgID entry.

      ProgIDFromCLSID(rclsid, &lpszProgID);
      fFreeProgID = TRUE;

      dw = cch;
      lRet = RegQueryValue(hKey, lpszProgID, lpszUserType, &dw);

      if ((LONG)ERROR_SUCCESS != lRet)
        dw = 0;
   }


   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &lpIMalloc))
   {
       if (fFreeProgID)
         lpIMalloc->Free((LPVOID)lpszProgID);

       lpIMalloc->Free((LPVOID)lpszCLSID);
       lpIMalloc->Release();
   }

   if (bCloseRegDB)
      RegCloseKey(hKey);

   return (UINT)dw;

}



/*
 * OleStdGetAuxUserType(RCLSID, WORD, LPSTR, int, HKEY)
 *
 * Purpose:
 *  Returns the specified AuxUserType from the reg db.
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve aux user type of.
 *  hKey            hKey for reg db - if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \ root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *  wAuxUserType    which aux user type field to look for.  In 4/93 release
 *                  2 is short name and 3 is exe name.
 *  lpszUserType    pointer to buffer to return user type in.
 *  cch             length of buffer pointed to by lpszUserType
 *
 * Return Value:
 *  UINT            Number of characters in returned string.  0 on error.
 *
 */
STDAPI_(UINT) OleStdGetAuxUserType(REFCLSID rclsid,
                                   WORD     wAuxUserType,
                                   LPSTR    lpszAuxUserType,
                                   int      cch,
                                   HKEY     hKey)
{
   HKEY     hThisKey;
   BOOL     fCloseRegDB = FALSE;
   LONG     dw;
   LRESULT  lRet;
   LPSTR    lpszCLSID;
   LPMALLOC lpIMalloc;
   char     szKey[OLEUI_CCHKEYMAX];
   char     szTemp[32];

   lpszAuxUserType[0] = '\0';
   
   if (NULL == hKey)
   {
      lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hThisKey);

      if (ERROR_SUCCESS != lRet)
          return 0;
   }
   else
      hThisKey = hKey;

   StringFromCLSID(rclsid, &lpszCLSID);

   lstrcpy(szKey, "CLSID\\");
   lstrcat(szKey, lpszCLSID);
   wsprintf(szTemp, "\\AuxUserType\\%d", wAuxUserType);
   lstrcat(szKey, szTemp);

   dw = cch;

   lRet = RegQueryValue(hThisKey, szKey, lpszAuxUserType, &dw);

   if (ERROR_SUCCESS != lRet) {
     dw = 0;
     lpszAuxUserType[0] = '\0';
   }


   if (fCloseRegDB)
      RegCloseKey(hThisKey);

   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &lpIMalloc))
   {
       lpIMalloc->Free((LPVOID)lpszCLSID);
       lpIMalloc->Release();
   }

   return (UINT)dw;
}



/*
 * PointerToNthField
 *
 * Purpose:
 *  Returns a pointer to the beginning of the nth field.
 *  Assumes null-terminated string.
 *
 * Parameters:
 *  lpszString        string to parse
 *  nField            field to return starting index of.
 *  chDelimiter       char that delimits fields
 *
 * Return Value:
 *  LPSTR             pointer to beginning of nField field.
 *                    NOTE: If the null terminator is found
 *                          Before we find the Nth field, then
 *                          we return a pointer to the null terminator -
 *                          calling app should be sure to check for
 *                          this case.
 *
 */
LPSTR FAR PASCAL PointerToNthField(LPSTR lpszString, int nField, char chDelimiter)
{
   LPSTR lpField = lpszString;
   int   cFieldFound = 1;

   if (1 ==nField)
      return lpszString;

   while (*lpField != '\0')
   {

      if (*lpField++ == chDelimiter)
      {

         cFieldFound++;

         if (nField == cFieldFound)
            return lpField;
      }
   }

   return lpField;

}



/*
 * XformWidthInPixelsToHimetric
 * XformWidthInHimetricToPixels
 * XformHeightInPixelsToHimetric
 * XformHeightInHimetricToPixels
 *
 * Functions to convert an int between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.  This
 *                  contains pixels in XformSizeInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.  This contains pixels in
 *                  XformSizeInPixelsToHimetric and logical HiMetric
 *                  units in the complement function.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */
STDAPI_(int) XformWidthInPixelsToHimetric(HDC hDC, int iWidthInPix)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iWidthInHiMetric;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    //We got pixel units, convert them to logical HIMETRIC along the display
    iWidthInHiMetric = MAP_PIX_TO_LOGHIM(iWidthInPix, iXppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iWidthInHiMetric;
    }


STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iWidthInPix;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    //We got logical HIMETRIC along the display, convert them to pixel units
    iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iWidthInPix;
    }


STDAPI_(int) XformHeightInPixelsToHimetric(HDC hDC, int iHeightInPix)
    {
    int     iYppli;     //Pixels per logical inch along height
    int     iHeightInHiMetric;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //* We got pixel units, convert them to logical HIMETRIC along the display
    iHeightInHiMetric = MAP_PIX_TO_LOGHIM(iHeightInPix, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iHeightInHiMetric;
    }


STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
    {
    int     iYppli;     //Pixels per logical inch along height
    int     iHeightInPix;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //* We got logical HIMETRIC along the display, convert them to pixel units
    iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iHeightInPix;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\inplace.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	inplace.cxx
//
//  Contents:	Stripped-down OLE2 inplace.cpp
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2int.h>
#include "inplace.h"

WORD	wSignature; //    =  (WORD) {'S', 'K'};

UINT uOleMessage;
 
#define OM_CLEAR_MENU_STATE		0	// lParam is NULL
#define OM_COMMAND_ID			1	// LOWORD(lParam) contains the command ID

OLEAPI OleTranslateAccelerator
   (LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpMsg)
{
	WORD cmd;
	BOOL fFound;

	fFound = IsAccelerator(lpFrameInfo->haccel, lpFrameInfo->cAccelEntries,
					lpMsg, &cmd);
					
	if (!fFound && lpFrameInfo->fMDIApp)
		fFound = IsMDIAccelerator(lpMsg, &cmd);

	if (fFound) {
		AssertSz(lpFrameInfo->hwndFrame, 
			"OleTranslateAccelerator: Invalid lpFrameInfo->hwndFrame");
		SendMessage(lpFrameInfo->hwndFrame, uOleMessage, OM_COMMAND_ID, 
				MAKELONG(cmd, 0)); 	
#ifdef _DEBUG				
		OutputDebugString((LPSTR)"IOleInPlaceFrame::TranslateAccelerator called\r\n");
#endif		
		return lpFrame->TranslateAccelerator(lpMsg, cmd);
		
	} else {
		if (wSysKeyToKey(lpMsg) == WM_SYSCHAR) { 
			// Eat the message if it is "Alt -". This is supposed to bring 
			// MDI system menu down. But we can not support it. And we also
			// don't want the message to be Translated by the object 
			// application either. So, we return as if it has been accepted by
			// the container as an accelerator.
			
			// If the container wants to support this it can have an 
			// accelerator for this. This is not an issue for SDI apps, 
			// because it will be thrown away by USER anyway.
			
			if (lpMsg->wParam != '-')
				SendMessage(lpFrameInfo->hwndFrame, lpMsg->message, 
					lpMsg->wParam, lpMsg->lParam);
#ifdef _DEBUG
			else
				OutputDebugString((LPSTR)"OleTranslateAccelerator: Alt+ - key is discarded\r\n");
#endif					
					
			return NOERROR;
		}
	}
	
	return ResultFromScode(S_FALSE);
}

inline UINT wSysKeyToKey(LPMSG lpMsg)
{
	UINT message = lpMsg->message;
	
	// if the ALT key is down when a key is pressed, then the 29th bit of the
	// LPARAM will be set
	
	// If the message was not made with the ALT key down, convert the message
	// from a WM_SYSKEY* to a WM_KEY* message.

	if (!(HIWORD(lpMsg->lParam) & 0x2000) 
			&& (message >= WM_SYSKEYDOWN && message <= WM_SYSDEADCHAR))
		message -= (WM_SYSKEYDOWN - WM_KEYDOWN);	
	
	return message;
}


OLEAPI_(BOOL) IsAccelerator
	(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD FAR* lpwCmd)
{
	WORD		cmd = NULL;
	WORD		flags;	
	BOOL		fFound = FALSE;
	BOOL		fVirt;
	LPACCEL		lpAccel = NULL;
	UINT		message;	

	message = wSysKeyToKey(lpMsg);

	switch (message) {
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		fVirt = TRUE;
		break;

	case WM_CHAR:
	case WM_SYSCHAR:
		fVirt = FALSE;
		break;

	default:
		goto errRtn;
	}

	if (! (hAccel && (lpAccel = (LPACCEL) LockResource(hAccel))))
		goto errRtn;

	if (! cAccelEntries)
		goto errRtn;
			
	do {
		flags = lpAccel->fVirt;
		if ((lpAccel->key != (WORD) lpMsg->wParam) ||
				((fVirt != 0) != ((flags & FVIRTKEY) != 0)))
			goto Next;

		if (fVirt) {
			if ((GetKeyState(VK_SHIFT) < 0) != ((flags & FSHIFT) != 0))
				goto Next;
			if ((GetKeyState(VK_CONTROL) < 0) != ((flags & FCONTROL) != 0))
				goto Next;
	    }

		if ((GetKeyState(VK_MENU) < 0) != ((flags & FALT) != 0))
			goto Next;

		if (cmd = lpAccel->cmd)
			fFound = TRUE;

		goto errRtn;
		
Next:
		lpAccel++;

	} while (--cAccelEntries);
	
	
errRtn:
	if (lpAccel)  
		UnlockResource(hAccel);
	
	if (lpwCmd)
		*lpwCmd = cmd;

	return fFound;
}



BOOL IsMDIAccelerator(LPMSG lpMsg, WORD FAR* lpCmd)
{
	if (lpMsg->message != WM_KEYDOWN && lpMsg->message != WM_SYSKEYDOWN)
		return FALSE;

	/* All of these have the control key down */
	if (GetKeyState(VK_CONTROL) >= 0)
		return FALSE;

	if (GetKeyState(VK_MENU) < 0)
		return FALSE;

	switch ((WORD)lpMsg->wParam) {
	case VK_F4:
		*lpCmd = SC_CLOSE;

	case VK_F6:
	case VK_TAB:
		if (GetKeyState(VK_SHIFT) < 0)
			*lpCmd = SC_PREVWINDOW;
		else
			*lpCmd = SC_NEXTWINDOW;
		break;
		
    default:
		return FALSE;
    }

	return TRUE;
}

LPOLEMENU wGetOleMenuPtr(HOLEMENU holemenu)
{
	LPOLEMENU lpOleMenu;
	
	if (! (holemenu 
			&& (lpOleMenu = (LPOLEMENU) GlobalLock((HGLOBAL) holemenu))))
		return NULL;
		
	if (lpOleMenu->wSignature != wSignature) {
		AssertSz(FALSE, "Error - handle is not a HOLEMENU");
		GlobalUnlock((HGLOBAL) holemenu);
		return NULL;
	}
	
	return lpOleMenu;
}	

inline void	wReleaseOleMenuPtr(HOLEMENU holemenu)
{
	GlobalUnlock((HGLOBAL) holemenu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\cdebug.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:		OleAPIs.cxx	(16 bit target)
//
//  Contents:	OLE2 APIs 
//
//  Functions:	
//
//  History:	17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

// cdebug.cpp - implemention of debugstream and IDebug interface/class
/*
#include <olerem.h>	//for RemLookupSHUnk

#pragma SEG(cdebug)
#include <string.h>
#include <toolhelp.h>
*/

//some constants used only in this file
#define DBGMARGIN	45
#define DBGTABSIZE	4
#define HEADER		1
#define NOHEADER	0


#define DBGLOGFILENAME	"debug.log"
static void GetCurDateTime(LPSTR lpsz);


STDAPI_(HFILE) DbgLogOpen(LPSTR lpszFile, LPSTR lpszMode)
{
#ifdef _DEBUG
#ifndef _MAC
	HFILE fh;

	AssertSz( lpszFile && lpszMode, "Invalid arguments to DbgLogOpen");
	
	switch (lpszMode[0]) {
		case 'w':
			// Open for writing (overwrite if exists)
			fh = _lcreat(lpszFile, 0);
			break;

		case 'r':
			// Open for reading
			fh = _lopen(lpszFile, OF_READ);
			break;

		case 'a':
			// Open for appending
			// to append to log file seek to end before writing
			if ((fh = _lopen(lpszFile, OF_READWRITE)) != -1) {
				_llseek(fh, 0L, SEEK_END);
			} else {
				// file does not exist, create a new one.
				fh = _lcreat(lpszFile, 0);
			}
			break;
	}
	return fh;
#endif	//_MAC
#else
 	(void) lpszFile;
	(void) lpszMode;
	return -1;
#endif	//_DEBUG
}


STDAPI_(void) DbgLogClose(HFILE fh)
{
#ifdef _DEBUG
#ifndef _MAC
	if (fh != -1) 
		_lclose(fh);
#endif
#else
	(void) fh;
#endif
}


STDAPI_(void) DbgLogWrite(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
#ifndef _MAC
	if (fh != -1 && lpsz) 
		_lwrite(fh, lpsz, lstrlen(lpsz));
#endif
#else
	(void) fh;
	(void) lpsz;
#endif
}


STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
	char buffer[80];

	GetCurDateTime(buffer);
	
	DbgLogOutputDebugString(fh, "\n***************************************\n");
	if (lpsz) DbgLogOutputDebugString(fh, lpsz);
	DbgLogOutputDebugString(fh, ": ");
	DbgLogOutputDebugString(fh, buffer);
	DbgLogOutputDebugString(fh, "\n");
	DbgLogOutputDebugString(fh, ".......................................\n\n");
#else
	(void) fh;
	(void) lpsz;
#endif
}


STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
	DbgLogOutputDebugString(fh, "\n***************************************\n");
	if (lpsz) DbgLogOutputDebugString(fh, lpsz);
	DbgLogOutputDebugString(fh, "\n");
	DbgLogOutputDebugString(fh, ".......................................\n\n");
#else
	(void) fh;
	(void) lpsz;
#endif
}


STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
#ifndef _MAC
	if (fh != -1)   
		DbgLogWrite(fh, lpsz);
	OutputDebugString(lpsz);
#endif
#else
	(void)fh;
	(void)lpsz;
#endif
}


#ifdef _DEBUG

static void GetCurDateTime(LPSTR lpsz)
{
	unsigned year, month, day, dayOfweek, hours, min, sec;
    static char FAR* dayNames[7] =
		{ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
	static char FAR* monthNames[12] = 
        { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

#ifndef _MAC
#ifdef WIN32
    SYSTEMTIME st;
    GetLocalTime(&st);
    year = st.wYear;
    month = st.wMonth - 1;
    dayOfweek = st.wDayOfWeek;
    day = st.wDay;
    hours = st.wHour;
    min = st.wMinute;
    sec = st.wSecond;
#else
    _asm {
		// Call GetDate
		mov ah, 0x2a
		int 0x21
		mov year, cx
		mov month, dx
		mov day, dx
		mov dayOfweek, ax

		// Call GetTime
		mov ah, 0x2c
		int 0x21
		mov hours, cx
		mov min, cx
		mov sec, dx
	}
			
	month >>= 8;
	month -= 1;
	day &= 0xFF;
	dayOfweek &= 0xFF;
	hours >>= 8;
	min &= 0xFF;
    sec >>= 8;
#endif	//_WIN32
#else // defined(_MAC)

	// REVIEW MAC -- need function here to get current date & time
	day = 9;
	month = 1;
	year = 1960;
	hours = 12;
	min = 30;
	sec = 17;
	
#endif	//_MAC	

	// Format time as: Wed Jan 02 02:03:55 1990
	// Format time as: Wed 05/02/1992 02:03:55

	wsprintf(lpsz, "%s %s %02d %02d:%02d:%02d %d", 
		dayNames[dayOfweek],monthNames[month], day, hours, min, sec, year);
}


class FAR CDebugLog
{
private:
	HFILE m_fhLog;

public:
	CDebugLog( ) { m_fhLog = -1; }
	CDebugLog( LPSTR lpszFileName );
	~CDebugLog() { DbgLogClose(m_fhLog); }
	HFILE Open(LPSTR lpszFileName, LPSTR lpszMode) 
		{ return (m_fhLog = DbgLogOpen(lpszFileName, lpszMode)); }
	void Close(void) { DbgLogClose(m_fhLog); m_fhLog = -1; }
	void OutputDebugString(LPSTR lpsz) { DbgLogOutputDebugString(m_fhLog, lpsz); }
	void TimeStamp(LPSTR lpsz) { DbgLogTimeStamp(m_fhLog, lpsz); }
	void WriteBanner(LPSTR lpsz) { DbgLogWriteBanner(m_fhLog, lpsz); }

};

#if 0

class FAR CDebugStream
{

public:
	OLESTATIC_(IDebugStream FAR *) Create( // no aggregation
		int margin, int tabsize, BOOL fHeader);

private:
	CDebugStream( int margin, int tabsize, BOOL fHeader );
	~CDebugStream();
	void OutputDebugString( LPSTR lpsz ) {m_DbgLog.OutputDebugString(lpsz);}


implementations:
	implement CDSImpl :  IDebugStream
	{

	public:
		CDSImpl( CDebugStream FAR * pDebugStream )
			{ m_pDebugStream = pDebugStream; }
		~CDSImpl( void ) ; //{ if (m_pDebugStream->m_pendingReturn) ForceReturn(); }
		void PrintString( LPSTR );
		void ForceReturn( void );
		void ReturnIfPending( void );
		OLEMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppvObj );
		OLEMETHOD_(ULONG,AddRef)( void );
		OLEMETHOD_(ULONG,Release)( void );

		OLEMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug );
		OLEMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid );
		OLEMETHOD_(IDebugStream&, operator << ) ( int n );
		OLEMETHOD_(IDebugStream&, operator << ) ( long l );
		OLEMETHOD_(IDebugStream&, operator << ) ( ULONG l );
		OLEMETHOD_(IDebugStream&, operator << ) ( LPSTR sz );
		OLEMETHOD_(IDebugStream&, operator << ) ( char ch );
		OLEMETHOD_(IDebugStream&, operator << ) ( void FAR * pv );
		OLEMETHOD_(IDebugStream&, operator << ) ( CBool b );
		OLEMETHOD_(IDebugStream&, operator << ) ( CAtom atom );
		OLEMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd );
		OLEMETHOD_(IDebugStream&, Tab) ( void );
		OLEMETHOD_(IDebugStream&, Indent) ( void );
		OLEMETHOD_(IDebugStream&, UnIndent) ( void );
		OLEMETHOD_(IDebugStream&, Return) ( void );
		OLEMETHOD_(IDebugStream&, LF) ( void );
		CDebugStream FAR * m_pDebugStream;
	};
	DECLARE_NC(CDebugStream,CDSImpl)

	CDSImpl m_DebugStream;

shared_state:
	ULONG m_refs;
	int m_indent;
	int m_position;
	int m_margin;
	int m_tabsize;
	BOOL m_pendingReturn;
	CDebugLog m_DbgLog;
};
#endif

#endif // _DEBUG



/*
 *	The member variable m_pendingReturn is a hack to allow
 *	the sequence of operations Return, UnIndent put the character
 *	at the *beginning of the unindented line*  The debugwindow does
 *	not seem to support going to the beginning of the line or
 *	backspacing, so we do not actually do a Return until we know
 *	that the next operation is not UnIndent.
 *	
 */



/*
 *	Implementation of per process list heads
 */

#ifdef NEVER		// per-proces debug lists not used

static IDebug FAR * GetIDHead()
{
	if this gets enabled, the map should be in the etask
}

static void SetIDHead(IDebug FAR* pIDHead)
{
	if this gets enabled, the map should be in the etask
}

#endif // NEVER


/*
 *	Implementation of IDebug constructor and destructor
 */


#ifdef NEVER
__export IDebug::IDebug( void )
{
    SETPVTBL(IDebug);
//#ifdef _DEBUG
	BOOL fIsShared = (SHARED == PlacementOf(this));
	IDebug FAR* pIDHead = (fIsShared ? pIDHeadShared : GetIDHead());

	pIDPrev = NULL;
	if (pIDHead)
		pIDHead->pIDPrev = this;
	pIDNext = pIDHead;
	if (fIsShared) pIDHeadShared = this;
	else SetIDHead(this);
}
#endif	//NEVER	


#ifdef NEVER
__export IDebug::~IDebug( void )
{
//#ifdef _DEBUG
	BOOL fIsShared = (SHARED == PlacementOf(this));
	if (pIDPrev)
		pIDPrev->pIDNext = pIDNext;
	else
		if (fIsShared) pIDHeadShared = pIDNext;
		else
			SetIDHead(pIDNext);
	if (pIDNext)
		pIDNext->pIDPrev = pIDPrev;
}
#endif	//NEVER	
 
//REVIEW:  maybe we should expose this later
STDAPI OleGetClassID( LPUNKNOWN pUnk, LPCLSID lpclsid )
{
	HRESULT hresult = NOERROR;
#if 0
	LPRUNNABLEOBJECT lpRunnableObject = NULL;
	LPPERSIST lpPersist = NULL;
	
	VDATEIFACE(pUnk);
	VDATEPTROUT(lpclsid, LPCLSID);

	*lpclsid = CLSID_NULL;
				
	pUnk->QueryInterface(IID_IRunnableObject, (LPLPVOID)&lpRunnableObject);
	if( lpRunnableObject ){
		hresult = lpRunnableObject->GetRunningClass(lpclsid);
		lpRunnableObject->Release();
	} else {	
		pUnk->QueryInterface(IID_IPersist, (LPLPVOID)&lpPersist);
		if( lpPersist ){
			hresult = lpPersist->GetClassID( lpclsid );
			lpPersist->Release();
		}
	}
#endif
	return hresult;
}

#ifdef _DEBUG

CDebugStream::CDebugStream( int margin, int tabsize, BOOL fHeader) : m_DebugStream(this)
{
#ifndef _MAC
	static BOOL fAppendFile = FALSE;
	
	// Create the debug log file. Overwrite the existing file if it exists.
	m_DbgLog.Open(DBGLOGFILENAME, (fAppendFile ? "a" : "w"));

	if( fHeader )	
		// only add creation timestamp to top of file.
		if (! fAppendFile) {
			m_DbgLog.TimeStamp("Created");
			fAppendFile = TRUE;
		} else {
			m_DbgLog.WriteBanner(NULL);
		}
#endif
	m_indent = 0;
	m_position = m_indent;
	m_margin = margin;
	m_tabsize = tabsize;
	m_refs = 1;
	m_pendingReturn = FALSE;
}


CDebugStream::~CDebugStream()
{
	m_DbgLog.Close();
}


NC(CDebugStream,CDSImpl)::~CDSImpl(void)
{
	 if (m_pDebugStream->m_pendingReturn) ForceReturn(); 
}


OLEMETHODIMP NC(CDebugStream,CDSImpl)::QueryInterface(REFIID iidInterface,
	void FAR* FAR* ppvObj )
{
	VDATEPTROUT(ppvObj, LPLPVOID);

	if (iidInterface == IID_IUnknown || iidInterface == IID_IDebugStream) {
		*ppvObj = (void FAR *)this;
		return NOERROR;
	} else {
		*ppvObj = NULL;
		return ReportResult(0, E_NOINTERFACE, 0, 0);
	}
}


OLEMETHODIMP_(ULONG) NC(CDebugStream,CDSImpl)::AddRef( void )
{
	return ++m_pDebugStream->m_refs;
}


OLEMETHODIMP_(ULONG) NC(CDebugStream,CDSImpl)::Release( void )
{
	if (--m_pDebugStream->m_refs == 0) {
		delete m_pDebugStream;
		return 0;
	}

	return m_pDebugStream->m_refs;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (int n)
{
	char buffer[12];
	ReturnIfPending();
	buffer[wsprintf(buffer, "%d", n)] = '\0';
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (long l)
{
	char buffer[16];
	ReturnIfPending();
	buffer[wsprintf(buffer, "%ld", l)] = '\0';
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (ULONG l)
{
	char buffer[16];
	ReturnIfPending();
	buffer[wsprintf(buffer, "%lu", l)] = '\0';
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CAtom atom)
{
	char buffer[128];
	ReturnIfPending();
	
	if( (ATOM)atom ){
		if( !GetAtomName((ATOM)atom, (LPSTR)buffer, sizeof(buffer)) )
			buffer[wsprintf(buffer, "Invalid atom")] = '\0';
	}else
		buffer[wsprintf(buffer, "NULL atom")] = '\0';
		
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CHwnd hwnd)
{
	char szBuf[128];
	
	ReturnIfPending();

	if( (HWND)hwnd )
		szBuf[wsprintf(szBuf, "window handle: %x", (HWND)hwnd)] = '\0';
	else
		szBuf[wsprintf(szBuf, "NULL window handle")] = '\0';

	PrintString(szBuf);		
	return *this;
}

LPSTR FindBreak( LPSTR sz, int currentPosition, int margin )
{
	LPSTR szBreak = sz;
	LPSTR szPtr = sz;

	if( !sz )
		return NULL;
	
	while (*szPtr)
	{
		while (*(szPtr) && *(szPtr++) <= ' ');
		while (*(szPtr) && *(szPtr++) > ' ');
		if (currentPosition+(szPtr-sz) < margin)
		{
			szBreak = szPtr;
		}
		else return szBreak;
	}
	return szPtr;
}

/*
 *	PrintString is an internal utility routine that can assume that
 *	everything in the string (other than the null at the end) is >=
 *	' '.  Thus it knows that when it prints a single character, the
 *	position on the debug terminal advances a single columm.  This
 *	would not be the case if the string could contain tabs,
 *	returns, etc.
 */


void NC(CDebugStream,CDSImpl)::PrintString (LPSTR sz)
{
	//	assert sz != NULL
	LPSTR szUnprinted = sz;
	LPSTR szPtr = sz;
	char chSave;

	#ifdef _MAC
	Puts(sz);
	return;
	#endif
	
	if( !sz )
		return;
	
	while (*szUnprinted)
	{
		szPtr = FindBreak( szUnprinted, m_pDebugStream->m_position, m_pDebugStream->m_margin );
		if (szPtr == szUnprinted && m_pDebugStream->m_position > m_pDebugStream->m_indent)
		{
			Return();
			szPtr = FindBreak( szUnprinted, m_pDebugStream->m_position, m_pDebugStream->m_margin );
			if (szPtr == szUnprinted)	//	text won't fit even after word wrapping
			{
				m_pDebugStream->OutputDebugString(szUnprinted);
				m_pDebugStream->m_position += _fstrlen(szUnprinted);
				return;
			}
		}
		chSave = *szPtr;
		*szPtr = '\0';
		if (m_pDebugStream->m_position == m_pDebugStream->m_indent)		//	no text on line, skip blanks
		{
			while (*szUnprinted == ' ') szUnprinted++;
		}
		m_pDebugStream->OutputDebugString(szUnprinted);
		*szPtr = chSave;
		m_pDebugStream->m_position += (szPtr - szUnprinted);
		szUnprinted = szPtr;
	}
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (char ch)
{
	char buffer[2] = "a";
	if (ch=='\n') Return();
	else if (ch=='\t') Tab();
	else if (ch >= ' ')
	{
		ReturnIfPending();
		if (m_pDebugStream->m_position >= m_pDebugStream->m_margin) Return();
		*buffer = ch;
		m_pDebugStream->OutputDebugString(buffer);
		m_pDebugStream->m_position++;
	}
	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (LPSTR sz)
{
	LPSTR szCopy;
	char chSave;
	LPSTR szPtr;
	LPSTR szPtrSave;

	ReturnIfPending();
	
	if (!sz)
		return *this;

	szCopy = new FAR (TASK) char[2+_fstrlen(sz)];
	if (!szCopy)
	{
		Return();
		PrintString("Memory allocation error in DebugStream");
		Return();
		return *this;
	}
	
	_fstrcpy( szCopy, sz );	
	for (szPtr = szCopy, szPtrSave = szCopy; *szPtr; szPtr++)
	{
		if ( *szPtr < ' ')	// we hit a control character or the end
		{
			chSave = *szPtr;
			*szPtr = '\0';
			PrintString( szPtrSave );
			if (chSave != '\0')
				*szPtr = chSave;
			szPtrSave = szPtr+1;
			switch (chSave)
			{
				case '\t':  Tab();
							break;
				case '\n':	Return();
							break;
				case '\r':	m_pDebugStream->OutputDebugString("\r");
							break;
				default:
							break;
			}
		}
	}
	PrintString( szPtrSave );

	delete szCopy;

	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CBool b)
{
	ReturnIfPending();
	if (b) PrintString("TRUE");
	else PrintString("FALSE");
	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << ( void FAR * pv )
{
	char buffer[12];
	LPSTR sz = "NULL";
	ReturnIfPending();
	if (pv != NULL)
	{
		buffer[wsprintf(buffer, "%lX", pv)] = '\0';
		sz = buffer;
	}
	PrintString(sz);
	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator <<
	( REFCLSID rclsid )
{
	char sz[256];
	
	// REVIEW: do lookup in reg.dat for user type name
 
 	if( rclsid == CLSID_NULL )
 		_fstrcpy(sz, "NULL CLSID");
	else if (StringFromCLSID2(rclsid, sz, sizeof(sz)) == 0)
		_fstrcpy(sz, "Unknown CLSID");

	*this << sz;

	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator <<
	( IUnknown FAR * pUnk )
{
	IDebug FAR * pDebug = NULL;
	CLSID	clsid = CLSID_NULL;

	ReturnIfPending();
	
	if( IsValidInterface(pUnk) ){
		pUnk->QueryInterface(IID_IDebug, (void FAR* FAR*)&pDebug);
		if (pDebug) {
			pDebug->Dump( this );
			if ( !pDebug->IsValid( 0 ) )
				*this << "Object is not valid" << '\n';
			/*
			 * NB: Debug interfaces are *not* ref counted (so as not to skew the
			 * counts of the objects they are debugging! :)
			 */
		 } else {
		 	OleGetClassID(pUnk, (LPCLSID)&clsid);
			*this << clsid << " @ "<<(VOID FAR *)pUnk << " doesn't support debug dumping";
		}
	} else if (!pUnk)
		*this << "NULL interface";
	else
		*this << "Invalid interface @ " << (VOID FAR *)pUnk;
		
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Tab( void )
{
	ReturnIfPending();
	int advance = m_pDebugStream->m_tabsize * ( 1 + m_pDebugStream->m_position/m_pDebugStream->m_tabsize) - m_pDebugStream->m_position;

	if (m_pDebugStream->m_position + advance < m_pDebugStream->m_margin)
	{
		for (int i = 0; i < advance; i++) 
			m_pDebugStream->OutputDebugString(" ");
		m_pDebugStream->m_position += advance;
	}
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Indent( void )
{
	if (m_pDebugStream->m_indent + m_pDebugStream->m_tabsize < m_pDebugStream->m_margin)
		m_pDebugStream->m_indent += m_pDebugStream->m_tabsize;
	if (!m_pDebugStream->m_pendingReturn)
		while (m_pDebugStream->m_position < m_pDebugStream->m_indent)
			operator<<(' ');
		
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::UnIndent( void )
{
	if (m_pDebugStream->m_indent > 0) m_pDebugStream->m_indent -= m_pDebugStream->m_tabsize;
	return *this;
}


void NC(CDebugStream,CDSImpl)::ForceReturn( void )
{
	m_pDebugStream->OutputDebugString("\n");
	for (int i = 0; i<m_pDebugStream->m_indent; i++) 
		m_pDebugStream->OutputDebugString(" ");
	m_pDebugStream->m_position = m_pDebugStream->m_indent;
	m_pDebugStream->m_pendingReturn = FALSE;
}

void NC(CDebugStream,CDSImpl)::ReturnIfPending( void )
{
	if (m_pDebugStream->m_pendingReturn) ForceReturn();
}



OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Return( void )
{
	ReturnIfPending();
	m_pDebugStream->m_pendingReturn = TRUE;
    Yield();           // let dbwin get control
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::LF( void )
{
	return Return();
}

OLESTATICIMP_(IDebugStream FAR *) CDebugStream::Create( // no aggregation
		int margin, int tabsize, BOOL fHeader )
{
	CDebugStream FAR * pcds = new FAR (TASK)CDebugStream( margin, tabsize, fHeader );
	if( !pcds ){
		AssertSz( pcds, "Out of Memory");
		return NULL;
	}
	return &(pcds->m_DebugStream);
}
#endif // _DEBUG


#if 0
STDAPI_(IDebugStream FAR *) MakeDebugStream( short margin, short tabsize, BOOL fHeader)
{
#ifdef _DEBUG
	return CDebugStream::Create( margin, tabsize, fHeader );
#else
	(void) margin;
	(void) tabsize;
	(void) fHeader;
	return NULL;
#endif // _DEBUG
}
#else
STDAPI_(void FAR *) MakeDebugStream( short margin, short tabsize, BOOL fHeader)
{
	return NULL;
}
#endif


//
// IDebug helpers
//

STDAPI_(void) DbgDumpObject( IUnknown FAR * pUnk, DWORD dwReserved )
{
#ifdef _DEBUG
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );
 	(void)dwReserved;
 	
	if( pcds ) {	
		*pcds << pUnk;
		pcds->Return();
		pcds->Release();
	}
#else
	(void) pUnk;
	(void) dwReserved;
#endif	
}
 
STDAPI_(void) DbgDumpExternalObject( IUnknown FAR * pUnk, DWORD dwReserved )
{ 
#ifdef _DEBUG
	SHREG shreg;
	
	(void) dwReserved;

	if( IsValidInterface(pUnk) ){
		if( RemLookupSHUnk(pUnk, NULL, &shreg) == NOERROR ){
			DbgDumpObject(shreg.m_pSM, 0);
			shreg.m_pSM->Release();
		}
	}

#else
	(void) dwReserved;
	(void) pUnk;
#endif
}

STDAPI_(BOOL) DbgIsObjectValid( IUnknown FAR * pUnk )
{
#ifdef _DEBUG
	BOOL	fReturn = TRUE;	//	default value for objects that don't
							//	support IDebug
	IDebug FAR * pDebug = NULL;
	
	if( IsValidInterface(pUnk) ){
		pUnk->QueryInterface( IID_IDebug, (void FAR* FAR*)&pDebug);
		if (pDebug)
			fReturn = pDebug->IsValid();
		//IDebug is not addref'd
		return fReturn;
	}
	return FALSE;
#else
	(void) pUnk;
	return TRUE;
#endif
}


STDAPI_(void) DbgDumpClassName( IUnknown FAR * pUnk )
{
#ifdef _DEBUG
	CLSID clsid;

	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );
	
	if( pcds ) {
        if( IsValidInterface(pUnk) ){
 			OleGetClassID( pUnk, (LPCLSID)&clsid);
			*pcds << clsid << " @ " << (void FAR* )pUnk << '\n';
		}else if (!pUnk)
			*pcds << "NULL interface" << '\n';
		else
			*pcds << (void FAR *)pUnk << " is not a valid interface" << '\n';
		pcds->Release();
	}
#else
	(void)pUnk;
#endif
}

STDAPI_(void) DumpAllObjects( void )
{
//#ifdef _DEBUG
#ifdef NEVER
	IDebug FAR * pID = GetIDHead();
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );

	*pcds << "----TASK OBJECTS-------\n";
	while (pID)
	{
		pID->Dump( pcds );
		pID = pID->pIDNext;
	}
	*pcds << "----SHARED OBJECTS-------\n";
	pID = pIDHeadShared;
	while (pID)
	{
		pID->Dump( pcds );
		pID = pID->pIDNext;
	}

	pcds->Release();
#endif
}


STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious )
{
//#ifdef _DEBUG
#ifdef NEVER
	IDebug FAR * pID = GetIDHead();
	int pass = 0;
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER);
	BOOL fReturn = TRUE;

	while (pID)
	{
		if (!(pID->IsValid(fSuspicious)))
		{
			fReturn = FALSE;
			if (pass == 0)
				*pcds <<
					"\n****INVALID OBJECT*****\n";
			else
				*pcds << "\n****INVALID SHARED MEMORY OBJECT*****\n";
			pID->Dump( pcds );
			pcds->Return();
		}
		pID = pID->pIDNext;
		if ((pID == NULL) && (pass++ == 0))
			pID = pIDHeadShared;
	}
	pcds->Release();
	return fReturn;
#endif 	//NEVER
	(void) fSuspicious;
    return TRUE;
}


#ifdef _DEBUG


extern "C"
BOOL CALLBACK __loadds DebCallBack(WORD wID, DWORD dwData)
{
//    char rgchBuf[50];
////    BOOL    fTraceStack = FALSE;
////    STACKTRACEENTRY ste;
////    WORD wSS, wCS, wIP, wBP;
//    NFYLOADSEG FAR* pNFY = (NFYLOADSEG FAR *)dwData;
//
//    if (wID == NFY_LOADSEG)
//    {
//        if (0 == _fstrcmp(pNFY->lpstrModuleName,"OLE2"))
//        {
//            wsprintf(rgchBuf, "Load seg %02x(%#04x), module %s", pNFY->wSegNum,
//                pNFY->wSelector, pNFY->lpstrModuleName);
//            OutputDebugString(rgchBuf);
//            _asm int 3
////            if (fTraceStack)
////            {
////                _asm mov wSS, SS
////                _asm mov wCS, CS
////                _asm mov wIP, IP
////                _asm mov wBP, BP
////                ste.dwSize = sizeof(STACKTRACEENTRY);
////                if (StackTraceCSIPFirst(&ste, wSS, wCS, wIP, wBP))
////                {
////                    while (fTraceStack && StackTraceNext(&ste));
////                }
////        
////            }
//        }
//    }
//    else if (wID == NFY_FREESEG)
//    {
//    }
	(void) wID;
	(void) dwData;
    return FALSE;
}

BOOL InstallHooks(void)
{
//    return NotifyRegister(NULL, (LPFNNOTIFYCALLBACK)DebCallBack, NF_NORMAL);
return TRUE;
}

BOOL UnInstallHooks()
{
//    return NotifyUnRegister(NULL);
return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\inplace.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	inplace.h
//
//  Contents:	inplace.h from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#if !defined( _INPLACE_H_ )
#define _INPLACE_H_

// This ACCEL structure and the related constants definitions come with WIN32.
// Win31 also uses the same stuff internally but it's not exposed in the 
// header files. 

#ifndef FVIRTKEY 

#define FVIRTKEY  TRUE		// Assumed to be == TRUE
#define FLASTKEY  0x80		// Indicates last key in the table
#define FNOINVERT 0x02
#define FSHIFT	  0x04
#define FCONTROL  0x08
#define FALT	  0x10

#pragma pack(1)
typedef struct tagACCEL {	// Accelerator Table structure
	BYTE	fVirt;
	WORD	key;
	WORD	cmd;
} ACCEL, FAR* LPACCEL;
#pragma pack()

#endif // FVIRTKEY


typedef struct tagOLEMENUITEM {
	UINT	item;
	WORD	fwPopup;
	BOOL	fObjectMenu;
} OLEMENUITEM;
typedef OLEMENUITEM FAR* LPOLEMENUITEM;

typedef struct tagOLEMENU {
	WORD						wSignature;
	HWND						hwndFrame;
	HMENU						hmenuCombined;
	OLEMENUGROUPWIDTHS			MenuWidths;
	LONG						lMenuCnt;
	OLEMENUITEM					menuitem[1];
} OLEMENU;
typedef OLEMENU FAR* LPOLEMENU;


class FAR CFrameFilter 
{
public:
	static HRESULT Create(HOLEMENU hOleMenu, HMENU hmenuCombined, 
				HWND hwndFrame,	HWND hwndActiveObj,	
				LPOLEINPLACEFRAME lpFrame, 
				LPOLEINPLACEACTIVEOBJECT lpActiveObj);
		
	CFrameFilter (HWND hwndFrame, HWND hwndActiveObj);		
	~CFrameFilter(void);
	
	inline LRESULT	OnSysCommand(UINT uParam, LONG lParam);
	inline void		OnEnterMenuMode(void);
	inline void		OnExitMenuMode(void);
	inline void		OnEnterAltTabMode(void);
	inline void		OnExitAltTabMode(void);	
	inline LRESULT	OnMessage(UINT msg, UINT uParam, LONG lParam);	
	inline void		IsObjectMenu (UINT uMenuItem, UINT fwMenu);
	inline BOOL		IsMenuCollision(UINT uParam, LONG lParam);	
	inline BOOL		DoContextSensitiveHelp();
		
private:
	HWND						m_hwndObject;
	HWND						m_hwndFrame;
	LPOLEINPLACEFRAME			m_lpFrame;
	LPOLEINPLACEACTIVEOBJECT	m_lpObject;
	WNDPROC						m_lpfnPrevWndProc;
	BOOL						m_fObjectMenu;
	BOOL						m_fCurItemPopup;
	BOOL						m_fInMenuMode;
	BOOL						m_fDiscardWmCommand;
	BOOL						m_fGotMenuCloseEvent;
	UINT						m_cmdId;
	UINT						m_uCurItemID;
	HOLEMENU					m_hOleMenu;
	HMENU						m_hmenuCombined;
	HWND						m_hwndFocusOnEnter;
	int							m_cAltTab;
};

typedef CFrameFilter FAR* PCFRAMEFILTER;


OLEAPI_(LRESULT) FrameWndFilterProc (HWND hwnd, UINT msg, UINT uParam, 	LONG lParam);
OLEAPI_(LRESULT) MessageFilterProc(int nCode, WPARAM wParam, LPARAM lParam);

BOOL IsMDIAccelerator(LPMSG lpMsg, WORD FAR* cmd);

inline PCFRAMEFILTER wGetFrameFilterPtr(HWND hwndFrame);

LPOLEMENU	wGetOleMenuPtr(HOLEMENU holemenu);
inline void	wReleaseOleMenuPtr(HOLEMENU holemenu);

inline UINT wSysKeyToKey(LPMSG lpMsg);

#endif // _INPLACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\lockbyte.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	lockbyte.cxx
//
//  Contents:	lockbyte.cpp from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2int.h>

#include "memstm.h"
#include <reterr.h>

// CreateILockBytesOnHGlobal
//

OLEAPI CreateILockBytesOnHGlobal
	(HGLOBAL			hGlobal, 
	BOOL				fDeleteOnRelease, 
	LPLOCKBYTES FAR*	pplkbyt)
{
	HANDLE				 hMem	  = NULL; // point to
    struct MEMSTM FAR*   pData 	  = NULL; //   a struct MEMSTM
    ILockBytes FAR* 	 pBytes	  = NULL;  
	DWORD 		 		 cbSize   = -1L;

	VDATEPTRIN (pplkbyt, LPLOCKBYTES);
	*pplkbyt = NULL;

    if (NULL==hGlobal)
	{
		hGlobal = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, 0);
	    if (hGlobal == NULL)
    	    goto ErrorExit;
    	cbSize = 0;

		// REVIEW: need to free this block if error below
	}
	else
	{
		cbSize = GlobalSize (hGlobal);
		// Is there a way to verify a zero-sized handle?
		if (cbSize!=0)
		{
			// verify validity of passed-in handle
			if (NULL==GlobalLock(hGlobal))
			{
				// bad handle
				return ResultFromScode (E_INVALIDARG);
			}
			GlobalUnlock (hGlobal);
		}
	}

	hMem = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, sizeof (MEMSTM));
    if (hMem == NULL)
   	    goto ErrorExit;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
   	    goto FreeMem;

	pData->cRef = 0;
   	pData->cb = cbSize;
	pData->fDeleteOnRelease = fDeleteOnRelease;
	pData->hGlobal = hGlobal;

    pBytes = CMemBytes::Create(hMem); // Create the ILockBytes
    if (pBytes == NULL)
        goto FreeMem;

    *pplkbyt = pBytes;
	return NOERROR;
	
FreeMem:	
	if (hMem)
	    GlobalFree(hMem);
ErrorExit:
	Assert (0);
    return ReportResult(0, E_OUTOFMEMORY, 0, 0);
}




OLEAPI GetHGlobalFromILockBytes
	(LPLOCKBYTES 	plkbyt, 
	HGLOBAL	FAR*	phglobal)
{
	VDATEIFACE (plkbyt);
	VDATEPTRIN (phglobal, HANDLE);
	*phglobal = NULL;
	CMemBytes FAR* pCMemByte = (CMemBytes FAR*)plkbyt;

	if (IsBadReadPtr (&(pCMemByte->m_dwSig), sizeof(ULONG))
		|| pCMemByte->m_dwSig != LOCKBYTE_SIG)
	{
		// we were passed someone else's implementation of ILockBytes
		return ResultFromScode (E_INVALIDARG);
	}

	MEMSTM FAR* pMem= pCMemByte->m_pData;
	if (NULL==pMem)
	{
		Assert (0);
		return ResultFromScode (E_OUTOFMEMORY);
	}
	Assert (pMem->cb <= GlobalSize (pMem->hGlobal));
	Verify (*phglobal = pMem->hGlobal);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\ole2guid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:		OLE2GUID.cxx	(16 bit target)
//
//  Contents:	GUIDs for OLE2
//
//  Functions:	
//
//  History:	17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#pragma hdrstop
#define  INITGUID
#include <string.h>
#include "compobj.h"
#include "initguid.h"
#include "oleguid.h"
#include "privguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\memstm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	memstm.h
//
//  Contents:	memstm.h from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#if !defined( _MEMSTM_H_ )
#define _MEMSTM_H_

// These defines shorten the class name so that the compiler doesn't
// choke on really long decorated names for MarshalInterface
#define CMarshalMemStm CMMS
#define CMarshalMemBytes CMMB

class FAR CMarshalMemStm;
class FAR CMarshalMemBytes;

// CMemStm is a stream implementation on top of global shared memory MEMSTM
//
// CMemStm
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pMem  +-->|cb            |
// +---------+   |cRef          |
//               |hGlobal       |--->+--------------+
//               +--------------+	 | Actual Data	|
// CMemStm             MEMSTM		 +--------------+
//
struct MEMSTM {             // Data in shared memory
    DWORD  cb;              // Size of hGlobal
    DWORD  cRef;            // See below
    HANDLE hGlobal;         // The data
	BOOL   fDeleteOnRelease;
};

// cRef counts all CMemStm pointers to this MEMSTM plus the number of times
// a hMem handle to MEMSTM had been returned
//
#define STREAM_SIG (0x4d525453L)

class FAR CMemStm : public IStream { // Shared emmory stream
public:
    OLEMETHOD(QueryInterface) (REFIID iidInterface, void FAR* FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);
    OLEMETHOD(Read) (VOID HUGEP* pv, ULONG cb, ULONG FAR* pcbRead);
    OLEMETHOD(Write) (VOID const HUGEP* pv, ULONG cb, ULONG FAR* pcbWritten);
    OLEMETHOD(Seek) (LARGE_INTEGER dlibMove, 
                                DWORD dwOrigin, ULARGE_INTEGER FAR* plibNewPosition);
    OLEMETHOD(SetSize) (ULARGE_INTEGER cb);
    OLEMETHOD(CopyTo) (IStream FAR* pstm, 
                       ULARGE_INTEGER cb, ULARGE_INTEGER FAR* pcbRead, ULARGE_INTEGER FAR* pcbWritten);
    OLEMETHOD(Commit) (DWORD grfCommitFlags);
    OLEMETHOD(Revert) (void);
    OLEMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(Stat) (STATSTG FAR* pstatstg, DWORD statflag);
    OLEMETHOD(Clone)(IStream FAR * FAR *ppstm);

    OLESTATIC_(CMemStm FAR*) Create(HANDLE hMem);

ctor_dtor:
    CMemStm() { GET_A5(); m_hMem = NULL; m_pData = NULL; m_pos = 0; m_refs = 0; }
    ~CMemStm() {}

private:
 	DWORD m_dwSig;				   	// Signature indicating this is our
									// implementation of IStream: STREAM_SIG
    ULONG m_refs;                   // Number of references to this CmemStm
    ULONG m_pos;                    // Seek pointer for Read/Write
    HANDLE m_hMem;                  // Memory Handle passed on creation
    MEMSTM FAR* m_pData;            // Pointer to that memroy

 	friend HRESULT STDAPICALLTYPE GetHGlobalFromStream (LPSTREAM, HGLOBAL FAR*);
 	friend LPSTREAM STDAPICALLTYPE CreateMemStm (DWORD, LPHANDLE);
    friend class CMarshalMemStm;
	SET_A5;
};




// CMemBytes is an ILockBytes implementation on top of global shared
// memory MEMSTM
//
// CMemBytes
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pData +-->| cb           |	 
// +---------+   | cRef         |	 
//               | hGlobal      |--->+-------------+
//               +--------------+	 | Actual data |
// CMemBytes         MEMSTM  	  	 +-------------+
//

#define LOCKBYTE_SIG (0x0046574A)

// cRef counts all CMemBytes pointers to this MEMSTM. 
// It and fDeleteOnRelease control the GlobalFree'ing of the hGlobal.

class FAR CMemBytes : public ILockBytes { // Shared memory lock bytes
public:
    OLEMETHOD(QueryInterface) (REFIID iidInterface, void FAR* FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);
    OLEMETHOD(ReadAt) (ULARGE_INTEGER ulOffset, VOID HUGEP *pv, ULONG cb,
                                                    ULONG FAR *pcbRead);
    OLEMETHOD(WriteAt) (ULARGE_INTEGER ulOffset, VOID const HUGEP *pv, ULONG cb,
                                                    ULONG FAR *pcbWritten);
    OLEMETHOD(Flush) (void);
    OLEMETHOD(SetSize) (ULARGE_INTEGER cb);
    OLEMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD statflag);

    OLESTATIC_(CMemBytes FAR*) Create(HANDLE hMem);

ctor_dtor:
    CMemBytes() { GET_A5(); m_hMem = NULL; m_pData = NULL; m_refs = 0; }
    ~CMemBytes() {}

private:
	 DWORD m_dwSig;				   	// Signature indicating this is our
												// implementation of ILockBytes: LOCKBYTE_SIG
    ULONG m_refs;                   // Normal reference count
    HANDLE m_hMem;                  // Handle for bookeeping info (MEMSTM)
    MEMSTM FAR* m_pData;	        // Pointer to that memroy

 	friend HRESULT STDAPICALLTYPE GetHGlobalFromILockBytes	(LPLOCKBYTES, HGLOBAL FAR*);
    friend class CMarshalMemBytes;
	SET_A5;
};


// CMarshalMemStm can Marshal, Unmarshal CMemStm.  It is impletented as
// a seperate object accessible from CMemStm, CMemBytes: QueryIntreface of
// IMarshal on CMemStm's IStream will return an IMarshal pointer to
// CMarshalMemStm, but QueryInterface of IStream on that IMarshal will
// fail.
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// As QueryInterface of IUnkown on the original IStream.
//
class FAR CMarshalMemStm : public IMarshal {
public:
    OLEMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);

    OLEMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPCLSID pCid);
    OLEMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPDWORD pSize);
    OLEMETHOD(MarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
						LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags);
    OLEMETHOD(UnmarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
                        LPVOID FAR* ppv);
    OLEMETHOD(ReleaseMarshalData)(THIS_ IStream FAR* pStm);
    OLEMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    OLESTATIC_(CMarshalMemStm FAR*) Create(CMemStm FAR* pMemStm);

ctor_dtor:
    CMarshalMemStm() { GET_A5();m_pMemStm = NULL; m_refs = 0; }
    ~CMarshalMemStm() {}

private:
    ULONG m_refs;                   // Number of references to this CmemStm
    CMemStm FAR* m_pMemStm;         // Pointer to object [Un]Marshalled
    CLSID m_clsid;                      // Class of object pointed by pUnk
	SET_A5;
};


// CMarshalMemBytes can Marshal, Unmarshal CMemBytes.  It is impletented as
// a seperate object accessible from CMemBytes, CMemBytes: QueryIntreface of
// IMarshal on CMemBytes's ILocBytes will return an IMarshal pointer to
// CMarshalMemBytes, but QueryInterface of ILockBytes on that IMarshal will
// fail.
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// As QueryInterface of IUnkown on the original ILockBytes.
//
class FAR CMarshalMemBytes : public IMarshal {
public:
    OLEMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);

    OLEMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPCLSID pCid);
    OLEMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPDWORD pSize);
    OLEMETHOD(MarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
						LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags);
    OLEMETHOD(UnmarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
                        LPVOID FAR* ppv);
    OLEMETHOD(ReleaseMarshalData)(THIS_ IStream FAR* pStm);
    OLEMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    OLESTATIC_(CMarshalMemBytes FAR*) Create(CMemBytes FAR* pMemBytes);

ctor_dtor:
    CMarshalMemBytes() { GET_A5();m_pMemBytes = NULL; m_refs = 0; }
    ~CMarshalMemBytes() {}

private:
    ULONG m_refs;                   // Number of references to this CMemBytes
    CMemBytes FAR* m_pMemBytes;     // Pointer to object [Un]Marshalled
    CLSID m_clsid;                      // Class of object pointed by pUnk
	SET_A5;
};


#endif // _MemBytes_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\ole2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	ole2.cxx
//
//  Contents:	Thunk ole2.dll common code
//
//  History:	07-Mar-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

#include <ole2int.h>

DECLARE_INFOLEVEL(thk1);

// Not in any OLE2 header
extern UINT uOleMessage;

HMODULE hmodOLE2 = NULL;

//+---------------------------------------------------------------------------
//
//  Function:	LibMain, public, Local
//
//  Synopsis:	DLL initialization function
//
//  Arguments:	[hinst] - Instance handle
//              [wDataSeg] - Current DS
//              [cbHeapSize] - Heap size for the DLL
//              [lpszCmdLine] - Command line information
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static char achInfoLevel[32];
#endif

extern "C" int CALLBACK LibMain(HINSTANCE hinst,
                                WORD wDataSeg,
                                WORD cbHeapSize,
                                LPSTR lpszCmdLine)
{
#if DBG == 1
    if (GetProfileString("olethk32", "ole2", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }


    if ((thk1InfoLevel == 3) &&
	 GetProfileString("olethk32", "Infolevel", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }
#endif

    // The original OLE2 code does not check for success on this call
    // so neither do we
    uOleMessage		 = RegisterWindowMessage("OLE_MESSAHE");

    hmodOLE2 = hinst;

    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:	WEP, public, Local
//
//  Synopsis:	Windows Exit Point routine, for receiving DLL unload
//              notification
//
//  Arguments:	[nExitType] - Type of exit occurring
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

extern "C" int CALLBACK WEP(int nExitType)
{
    // Clean up thunk objects?
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\ole2dthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ole2dthk.cxx    (16 bit target)
//
//  Contents:   OLE2 APIs that are directly thunked
//
//  History:    17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <call32.hxx>
#include <apilist.hxx>

STDAPI_(HOLEMENU) OleCreateMenuDescriptor (HMENU hmenuCombined,
                                           LPOLEMENUGROUPWIDTHS lplMenuWidths)
{
    return (HOLEMENU)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateMenuDescriptor),
                                     PASCAL_STACK_PTR(hmenuCombined));
}

STDAPI OleDestroyMenuDescriptor (HOLEMENU holemenu)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleDestroyMenuDescriptor),
                                    PASCAL_STACK_PTR(holemenu));
}

//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [iid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    /* Relies on the fact that storage and ole2.dll both use the
       same DllGetClassObject in ole32.dll */
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_DllGetClassObject),
                                    PASCAL_STACK_PTR(clsid));
}

/* helper functions */
//+---------------------------------------------------------------------------
//
//  Function:   ReadClassStg, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [pclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadClassStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteClassStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [rclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteClassStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteFmtUserTypeStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [cf] --
//      [lpszUserType] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPSTR lpszUserType)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteFmtUserTypeStg),
                                    PASCAL_STACK_PTR(pstg));
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadFmtUserTypeStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [pcf] --
//      [lplpszUserType] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf,
                           LPSTR FAR* lplpszUserType)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadFmtUserTypeStg),
                                    PASCAL_STACK_PTR(pstg));
}

/* APIs to query whether (Embedded/Linked) object can be created from
   the data object */

//+---------------------------------------------------------------------------
//
//  Function:   OleQueryLinkFromData, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObject] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleQueryLinkFromData),
                                    PASCAL_STACK_PTR(pSrcDataObject));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleQueryCreateFromData, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObject] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleQueryCreateFromData),
                                    PASCAL_STACK_PTR(pSrcDataObject) );
}



/* Object creation APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleCreate, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [riid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt,
                  LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite,
                  LPSTORAGE pStg, LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreate),
                                    PASCAL_STACK_PTR(rclsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateFromData, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObj] --
//      [riid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                          DWORD renderopt, LPFORMATETC pFormatEtc,
                          LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                          LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateFromData),
                                    PASCAL_STACK_PTR(pSrcDataObj));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateLinkFromData, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObj] --
//      [riid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                              DWORD renderopt, LPFORMATETC pFormatEtc,
                              LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                              LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateLinkFromData),
                                    PASCAL_STACK_PTR(pSrcDataObj));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateStaticFromData, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObj] --
//      [iid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateStaticFromData),
                                    PASCAL_STACK_PTR(pSrcDataObj));
}



//+---------------------------------------------------------------------------
//
//  Function:   OleCreateLink, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkLinkSrc] --
//      [riid] --
//      [renderopt] --
//      [lpFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid,
                      DWORD renderopt, LPFORMATETC lpFormatEtc,
                      LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                      LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateLink),
                                    PASCAL_STACK_PTR(pmkLinkSrc));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateLinkToFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszFileName] --
//      [riid] --
//      [renderopt] --
//      [lpFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateLinkToFile),
                                    PASCAL_STACK_PTR(lpszFileName));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateFromFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [lpszFileName] --
//      [riid] --
//      [renderopt] --
//      [lpFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName, REFIID riid,
                          DWORD renderopt, LPFORMATETC lpFormatEtc,
                          LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                          LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateFromFile),
                                    PASCAL_STACK_PTR(rclsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleLoad, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [riid] --
//      [pClientSite] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite,
                LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleLoad),
                                    PASCAL_STACK_PTR(pStg));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleSave, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pPS] --
//      [pStg] --
//      [fSameAsLoad] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSave),
                                    PASCAL_STACK_PTR(pPS));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleLoadFromStream, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [iidInterface] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface,
                           LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleLoadFromStream),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSaveToStream, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pPStm] --
//      [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm )
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSaveToStream),
                                    PASCAL_STACK_PTR(pPStm));
}



//+---------------------------------------------------------------------------
//
//  Function:   OleSetContainedObject, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [fContained] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetContainedObject),
                                    PASCAL_STACK_PTR(pUnknown));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleNoteObjectVisible, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [fVisible] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleNoteObjectVisible),
                                    PASCAL_STACK_PTR(pUnknown));
}


/* Drag/Drop APIs */

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDragDrop, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hwnd] --
//      [pDropTarget] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_RegisterDragDrop),
                                    PASCAL_STACK_PTR(hwnd));
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeDragDrop, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hwnd] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  RevokeDragDrop(HWND hwnd)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_RevokeDragDrop),
                                    PASCAL_STACK_PTR(hwnd));
}

//+---------------------------------------------------------------------------
//
//  Function:   DoDragDrop, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pDataObj] --
//      [pDropSource] --
//      [dwOKEffects] --
//      [pdwEffect] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_DoDragDrop),
                                    PASCAL_STACK_PTR(pDataObj));
}


/* Clipboard APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleSetClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pDataObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj)
{
    if (pDataObj != NULL)
    {
        HRESULT hr;
        IDataObject FAR *pdoNull = NULL;

        /* If we are setting the clipboard's data object we first force
           the clipboard to an empty state.  This avoids a problem with
           Word where it always uses the same data object pointer in
           every clipboard call which results in the reference counts
           being too high since we reuse the proxy and addref it on
           the way in */
        hr = (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetClipboard),
                                      PASCAL_STACK_PTR(pdoNull));
        if (FAILED(GetScode(hr)))
        {
            return hr;
        }
    }

    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetClipboard),
                                    PASCAL_STACK_PTR(pDataObj));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleGetClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppDataObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleGetClipboard),
                                    PASCAL_STACK_PTR(ppDataObj));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleFlushClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleFlushClipboard(void)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleFlushClipboard),
                                    NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleIsCurrentClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pDataObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleIsCurrentClipboard),
                                    PASCAL_STACK_PTR(pDataObj));
}


/* InPlace Editing APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleSetMenuDescriptor, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [holemenu] --
//      [hwndFrame] --
//      [hwndActiveObject] --
//      [lpFrame] --
//      [lpActiveObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                             HWND hwndActiveObject,
                             LPOLEINPLACEFRAME lpFrame,
                             LPOLEINPLACEACTIVEOBJECT lpActiveObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetMenuDescriptor),
                                    PASCAL_STACK_PTR(holemenu));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleDraw, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [dwAspect] --
//      [hdcDraw] --
//      [lprcBounds] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw,
                LPCRECT lprcBounds)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleDraw),
                                    PASCAL_STACK_PTR(pUnknown));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRun, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI          OleRun(LPUNKNOWN pUnknown)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRun),
                                    PASCAL_STACK_PTR(pUnknown));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleIsRunning
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pObject] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) OleIsRunning(LPOLEOBJECT pObject)
{
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_OleIsRunning),
                                 PASCAL_STACK_PTR(pObject));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleLockRunning, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [fLock] --
//      [fLastUnlockCloses] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleLockRunning),
                                    PASCAL_STACK_PTR(pUnknown));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateOleAdviseHolder, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppOAHolder] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateOleAdviseHolder),
                                    PASCAL_STACK_PTR(ppOAHolder));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateDefaultHandler, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [pUnkOuter] --
//      [riid] --
//      [lplpObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                               REFIID riid, LPVOID FAR* lplpObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateDefaultHandler),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateEmbeddingHelper, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [pUnkOuter] --
//      [flags] --
//      [pCF] --
//      [riid] --
//      [lplpObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                                DWORD flags, LPCLASSFACTORY pCF,
                                REFIID riid, LPVOID FAR* lplpObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateEmbeddingHelper),
                                    PASCAL_STACK_PTR(clsid));
}

/* Registration Database Helper APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleRegGetUserType, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [dwFormOfType] --
//      [pszUserType] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
                          LPSTR FAR* pszUserType)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegGetUserType),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegGetMiscStatus, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [dwAspect] --
//      [pdwStatus] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegGetMiscStatus(REFCLSID clsid, DWORD dwAspect,
                           DWORD FAR* pdwStatus)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegGetMiscStatus),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegEnumFormatEtc, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [dwDirection] --
//      [ppenum] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegEnumFormatEtc(REFCLSID clsid, DWORD dwDirection,
                           LPENUMFORMATETC FAR* ppenum)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegEnumFormatEtc),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegEnumVerbs, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [ppenum] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegEnumVerbs(REFCLSID clsid, LPENUMOLEVERB FAR* ppenum)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegEnumVerbs),
                                    PASCAL_STACK_PTR(clsid));
}

/* OLE 1.0 conversion APIS */

//+---------------------------------------------------------------------------
//
//  Function:   OleConvertIStorageToOLESTREAM, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [polestm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertIStorageToOLESTREAM(LPSTORAGE pstg,
                                     LPOLESTREAM polestm)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertIStorageToOLESTREAM),
                                    PASCAL_STACK_PTR(pstg));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleConvertOLESTREAMToIStorage, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [polestm] --
//      [pstg] --
//      [ptd] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertOLESTREAMToIStorage(LPOLESTREAM polestm,
                                     LPSTORAGE pstg,
                                     const DVTARGETDEVICE FAR* ptd)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertOLESTREAMToIStorage),
                                    PASCAL_STACK_PTR(polestm));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleConvertIStorageToOLESTREAMEx, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [cfFormat] --
//      [lWidth] --
//      [lHeight] --
//      [dwSize] --
//      [pmedium] --
//      [polestm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertIStorageToOLESTREAMEx(
        LPSTORAGE       pstg,           // Presentation data to OLESTREAM
        CLIPFORMAT      cfFormat,       //              format
        LONG            lWidth,         //              width
        LONG            lHeight,        //              height
        DWORD           dwSize,         //              size in bytes
        LPSTGMEDIUM     pmedium,        //              bits
        LPOLESTREAM     polestm)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertIStorageToOLESTREAMEx),
                                    PASCAL_STACK_PTR(pstg));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleConvertOLESTREAMToIStorageEx, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [polestm] --
//      [pstg] --
//      [pcfFormat] --
//      [plwWidth] --
//      [plHeight] --
//      [pdwSize] --
//      [pmedium] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertOLESTREAMToIStorageEx(
        LPOLESTREAM     polestm,
        LPSTORAGE       pstg,           // Presentation data from OLESTREAM
        CLIPFORMAT FAR* pcfFormat,      //              format
        LONG FAR*       plwWidth,       //              width
        LONG FAR*       plHeight,       //              height
        DWORD FAR*      pdwSize,        //              size in bytes
        LPSTGMEDIUM     pmedium)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertOLESTREAMToIStorageEx),
                                    PASCAL_STACK_PTR(polestm));
}

/* ConvertTo APIS */

//+---------------------------------------------------------------------------
//
//  Function:   OleGetAutoConvert, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [pClsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleGetAutoConvert),
                                    PASCAL_STACK_PTR(clsidOld));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSetAutoConvert, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [clsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetAutoConvert),
                                    PASCAL_STACK_PTR(clsidOld));
}

//+---------------------------------------------------------------------------
//
//  Function:   GetConvertStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI GetConvertStg(LPSTORAGE pStg)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_GetConvertStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   SetConvertStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [fConvert] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_SetConvertStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateDataAdviseHolder, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppDAHolder] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateDataAdviseHolder),
                                    PASCAL_STACK_PTR(ppDAHolder));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateDataCache, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnkOuter] --
//      [rclsid] --
//      [iid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
                       REFIID iid, LPVOID FAR* ppv)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateDataCache),
                                    PASCAL_STACK_PTR(pUnkOuter));
}

//+---------------------------------------------------------------------------
//
//  Function:   Utility functions not in the spec; in ole2.dll.
//
//  History:    20-Apr-94       DrewB   Taken from OLE2 sources
//
//----------------------------------------------------------------------------

STDAPI ReadOleStg
   (LPSTORAGE pstg, DWORD FAR* pdwFlags, DWORD FAR* pdwOptUpdate,
    DWORD FAR* pdwReserved, LPMONIKER FAR* ppmk, LPSTREAM FAR* ppstmOut)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadOleStg),
                                    PASCAL_STACK_PTR(pstg));
}

STDAPI WriteOleStg
   (LPSTORAGE pstg, IOleObject FAR* pOleObj,
    DWORD dwReserved, LPSTREAM FAR* ppstmOut)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteOleStg),
                                    PASCAL_STACK_PTR(pstg));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\memstm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	memstm.cxx
//
//  Contents:	memstm.cpp from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2int.h>

#include "memstm.h"
#include <reterr.h>

static const UINT grfMem = GMEM_SHARE | GMEM_MOVEABLE;

// REVIEW: there is a lot of duplicate code.  There used to be two separate
// but identical structs: MEMSTM and MEMBYTES; the structs have be merged and
// common code should be pulled out including: Release, AddRef, marshal, SetSize


// Shared memory IStream implementation
//

OLEMETHODIMP CMemStm::QueryInterface(REFIID iidInterface, void FAR* FAR* ppvObj)
{
    M_PROLOG(this);
    HRESULT error;

    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;
    VDATEIID( iidInterface );

    // Two interfaces supported: IUnknown, IStream

    if (m_pData != NULL &&
            (iidInterface == IID_IStream || iidInterface == IID_IUnknown)) {

        m_refs++;   // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    } else
//
// BUGBUG - Renable this once CraigWi seperates Custom Marshalling stuff from
// standard identity stuff. (Right now you can't get in between the standard
// marshaller and the code which calls it, you're either completely custom
// marshalling, or your not).  Once it is better organized, we could marshall
// a heap handle and the custom marshalling stuff. Then when unmarshalling in
// the same wow, we unmarshal the heap handle, when not in the same wow, then
// use the standard marshalling stuff.
// Same goes for ILockBytesonHglobal below...
//
#define BOBDAY_DISABLE_MARSHAL_FOR_NOW
#ifdef BOBDAY_DISABLE_MARSHAL_FOR_NOW
#else
    if (iidInterface == IID_IMarshal) {
        *ppvObj = (LPVOID) CMarshalMemStm::Create(this);
        if (*ppvObj != NULL)
            error = NOERROR;
        else
            error = ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    else
#endif
    {                 // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    return error;
}


// Called when CMemStm is referenced by an additional pointer.
//

OLEMETHODIMP_(ULONG) CMemStm::AddRef(void)
{
	M_PROLOG(this);
    return ++m_refs;
}

// Called when a pointer to this CMemStm is discarded
//

OLEMETHODIMP_(ULONG) CMemStm::Release(void)
{
	M_PROLOG(this);

    if (--m_refs != 0) // Still used by others
        return m_refs;

	ReleaseMemStm(&m_hMem);

    delete this; // Free storage
    return 0;
}


OLEMETHODIMP CMemStm::Read(void HUGEP* pb, ULONG cb, ULONG FAR* pcbRead)
{
	M_PROLOG(this);
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::Read(pb=%p,cb=%lx)\n",
		 this,pb,cb));
    HRESULT error = NOERROR;
    ULONG cbRead = cb;

    VDATEPTROUT( pb, char);
    if (pcbRead) {
        VDATEPTROUT( pcbRead, ULONG );
        *pcbRead = 0L;
    }
	
    if (pcbRead != NULL)
        *pcbRead = 0;

    if (cbRead + m_pos > m_pData->cb)
	{
		// Caller is asking for more bytes than we have left
        cbRead = m_pData->cb - m_pos;
    }

	if (cbRead > 0)
	{
	   	Assert (m_pData->hGlobal);
		char HUGEP* pGlobal = GlobalLock (m_pData->hGlobal);
		if (NULL==pGlobal)
		{
			Assert (0);
			error =  ResultFromScode (STG_E_READFAULT);
			goto exitRtn;
		}
	    UtMemCpy (pb, pGlobal + m_pos, cbRead);
		GlobalUnlock (m_pData->hGlobal);
	    m_pos += cbRead;
	}

    if (pcbRead != NULL)
        *pcbRead = cbRead;
exitRtn:
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::Read() returns %lx\n",
		 this,error));
    return error;
}


OLEMETHODIMP CMemStm::Write(void const HUGEP* pb, ULONG cb, ULONG FAR* pcbWritten)
{
	A5_PROLOG(this);
    HRESULT error = NOERROR;
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::Write(pb=%p,cb=%lx)\n",
		 this,pb,cb));

    ULONG cbWritten = cb;
	ULARGE_INTEGER ularge_integer;
	char HUGEP* pGlobal;

    if ( pcbWritten ) {
        VDATEPTROUT( pcbWritten, ULONG );
        *pcbWritten = 0L;
    }
    VDATEPTRIN( pb , char );

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (cbWritten + m_pos > m_pData->cb) {
		ULISet32( ularge_integer, m_pos+cbWritten );
        error = SetSize(ularge_integer);
        if (error != NOERROR)
            goto Exit;
    }

	pGlobal = GlobalLock (m_pData->hGlobal);
	if (NULL==pGlobal)
	{
		Assert (0);
		error =  ResultFromScode (STG_E_WRITEFAULT);
		goto Exit;
	}
    UtMemCpy (pGlobal + m_pos, pb, cbWritten);
	GlobalUnlock (m_pData->hGlobal);

    m_pos += cbWritten;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    RESTORE_A5();
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::Write() returns %lx\n",
		 this,error));

    return error;
}

OLEMETHODIMP CMemStm::Seek(LARGE_INTEGER dlibMoveIN, DWORD dwOrigin, ULARGE_INTEGER FAR* plibNewPosition)
{
    M_PROLOG(this);
    thkDebugOut((DEB_ITRACE,"%p _IN CMemStm16::Seek()\n",this));

    HRESULT error  = NOERROR;
    LONG  dlibMove = dlibMoveIN.LowPart ;
    ULONG cbNewPos = dlibMove;

    if (plibNewPosition != NULL){
        VDATEPTROUT( plibNewPosition, ULONG );
        ULISet32(*plibNewPosition, m_pos);
    }

    switch(dwOrigin) {

        case STREAM_SEEK_SET:
            if (dlibMove >= 0)
                m_pos = dlibMove;
            else
                error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek
        break;

        case STREAM_SEEK_CUR:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pos))
                m_pos += dlibMove;
            else
                error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek
        break;

        case STREAM_SEEK_END:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pData->cb))
                m_pos = m_pData->cb + dlibMove;
            else
                error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek
        break;

        default:
            error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek mode
    }

    if (plibNewPosition != NULL)
        ULISet32(*plibNewPosition, m_pos);

    thkDebugOut((DEB_ITRACE,"%p OUT CMemStm16::Seek() returns %lx\n",this,error));

    return error;
}



OLEMETHODIMP CMemStm::SetSize(ULARGE_INTEGER cb)
{
	M_PROLOG(this);
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::SetSize(cb=%lx%lx)\n",
		 this,cb.HighPart,cb.LowPart));
    HANDLE hMemNew;
    HRESULT hresult = NOERROR;

    if (m_pData->cb == cb.LowPart)
    {
	goto errRtn;
    }


    hMemNew = GlobalReAlloc(m_pData->hGlobal,max (cb.LowPart,1),grfMem);

    if (hMemNew == NULL)
    {
	hresult =  ResultFromScode (E_OUTOFMEMORY);
	goto errRtn;
    }

    m_pData->hGlobal = hMemNew;
    m_pData->cb = cb.LowPart;

errRtn:
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::SetSize() returns %lx\n",
		 this,
		 hresult));

    return hresult;
}


OLEMETHODIMP CMemStm::CopyTo(IStream FAR *pstm,
			     ULARGE_INTEGER cb,
			     ULARGE_INTEGER FAR * pcbRead,
			     ULARGE_INTEGER FAR * pcbWritten)
{
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::CopyTo(pstm=%p)\n",
		 this,
		 pstm));
		
    ULONG	cbRead  	= cb.LowPart;
    ULONG	cbWritten	= 0;
    HRESULT hresult		= NOERROR;

    // pstm cannot be NULL

    VDATEPTRIN(pstm, LPSTREAM);
	
    // the spec says that if cb is it's maximum value (all bits set,
    // since it's unsigned), then we will simply read the copy of
    // this stream

    if ( ~(cb.LowPart) == 0 && ~(cb.HighPart) == 0 )
    {
    	cbRead = m_pData->cb - m_pos;
    }
    else if ( cb.HighPart > 0 )
    {
    	// we assume that our memory stream cannot
    	// be large enough to accomodate very large (>32bit)
    	// copy to requests.  Since this is probably an error
    	// on the caller's part, we assert.

    	thkAssert(!"WARNING: CopyTo request exceeds 32 bits");

    	// set the Read value to what's left, so that "Ignore"ing
    	// the assert works properly.
    	
    	cbRead = m_pData->cb - m_pos;
    }
    else if ( cbRead + m_pos > m_pData->cb )
    {
    	// more bytes were requested to read than we had left.
    	// cbRead is set to the amount remaining.

    	cbRead = m_pData->cb - m_pos;
    }

    // now write the data to the stream

    if ( cbRead > 0 )
    {	
    	BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
    			m_pData->hGlobal);

    	if( pGlobal == NULL )
    	{
    		thkAssert(!"GlobalLock failed");
		hresult = (HRESULT)STG_E_INSUFFICIENTMEMORY;
		goto errRtn;
    	}
    	
    	hresult = pstm->Write(pGlobal + m_pos, cbRead, &cbWritten);

    	// in the error case, the spec says that the return values
    	// may be meaningless, so we do not need to do any special
    	// error handling here
    	
    	GlobalUnlock(m_pData->hGlobal);
    }

    // increment our seek pointer and set the out parameters

    m_pos += cbRead;

    if( pcbRead )
    {
    	ULISet32(*pcbRead, cbRead);
    }

    if( pcbWritten )
    {
    	ULISet32(*pcbWritten, cbWritten);
    }

errRtn:
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::CopyTo(pstm=%p) returns %lx\n",
		 this,
		 pstm,
		 hresult));
    return hresult;

}

OLEMETHODIMP CMemStm::Commit(DWORD grfCommitFlags)
{
    M_PROLOG(this);
    return NOERROR;			// since this stream is not transacted, no error
}

OLEMETHODIMP CMemStm::Revert(void)
{
    M_PROLOG(this);
    return NOERROR;			// nothing done
}

OLEMETHODIMP CMemStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	M_PROLOG(this);
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

OLEMETHODIMP CMemStm::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	M_PROLOG(this);
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

OLEMETHODIMP CMemStm::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
	M_PROLOG(this);
    VDATEPTROUT( pstatstg, STATSTG );

    pstatstg->pwcsName = NULL;
    pstatstg->type = 0;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->cbSize.LowPart = m_pData->cb;
    pstatstg->mtime.dwLowDateTime = 0;
    pstatstg->mtime.dwHighDateTime = 0;
    pstatstg->ctime.dwLowDateTime = 0;
    pstatstg->ctime.dwHighDateTime = 0;
    pstatstg->atime.dwLowDateTime = 0;
    pstatstg->atime.dwHighDateTime = 0;
    pstatstg->grfMode = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    return NOERROR;
}


// returns new instance of pstm pointing to same data at same position.
OLEMETHODIMP CMemStm::Clone(IStream FAR * FAR *ppstm)
{
	M_PROLOG(this);
    CMemStm FAR* pCMemStm;

	VDATEPTROUT (ppstm, LPSTREAM);

	*ppstm = pCMemStm = CMemStm::Create(m_hMem);
	if (pCMemStm == NULL)
		return ResultFromScode(E_OUTOFMEMORY);

	pCMemStm->m_pos = m_pos;
	return NOERROR;
}


// Create CMemStm.  Handle must be a MEMSTM block.
//

OLESTATICIMP_(CMemStm FAR*) CMemStm::Create(HANDLE hMem)
{
    CMemStm FAR* pCMemStm;
    struct MEMSTM FAR* pData;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
        return NULL;

    pCMemStm = new CMemStm;

    if (pCMemStm == NULL)
        return NULL;

    // Initialize CMemStm
    //
    pCMemStm->m_hMem = hMem;
    (pCMemStm->m_pData = pData)->cRef++;	// AddRefMemStm
    pCMemStm->m_refs = 1;
	pCMemStm->m_dwSig = STREAM_SIG;

    return pCMemStm;
}




// Allocate shared memory and create CMemStm on top of it.
// Return pointer to the stream if done, NULL if error.
// If the handle is returned, it must be free with ReleaseMemStm
// (because of ref counting and the nested global handle).
//


OLEAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem)
{
	HANDLE h;
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CreateMemStm16(cb=%lx,phMem=%p\n",0,cb,phMem));


    LPSTREAM pstm = NULL;

    if (phMem)
    {
    	*phMem = NULL;
    }


    h = GlobalAlloc (grfMem, cb);
    if (NULL==h)
    {
	goto errRtn;
    }

    if (CreateStreamOnHGlobal (h, TRUE, &pstm) != NOERROR)
    {
	pstm = NULL;
	goto errRtn;
    }
    if (phMem)
    {
    	// retrieve handle from just-created CMemStm
    	*phMem = ((CMemStm FAR*)pstm)->m_hMem;

    	// use pointer to bump ref count
    	Assert(((CMemStm FAR*)pstm)->m_pData != NULL);
    	((CMemStm FAR*)pstm)->m_pData->cRef++;	// AddRefMemStm
    }

errRtn:
    thkDebugOut((DEB_ITRACE,
	     "%p OUT CreateMemStm16(cb=%lx,phMem=%p) returns %p\n",0,pstm));

    return pstm;
}


// Create CMemStm on top of the specified hMem (which must be a MEMSTM block).
// Return pointer to the stream if done, NULL if error.
//
OLEAPI_(LPSTREAM) CloneMemStm(HANDLE hMem)
{
    return CMemStm::Create(hMem); // Create the stream
}



OLEAPI_(void) ReleaseMemStm (LPHANDLE phMem, BOOL fInternalOnly)
{
    struct MEMSTM FAR* pData;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(*phMem)));

	// check for NULL pointer in case handle got freed already
	// decrement ref count and free if no refs left
    if (pData != NULL && --pData->cRef == 0)
	{
		if (pData->fDeleteOnRelease)
		{
			Verify (0==GlobalFree (pData->hGlobal));
		}

		if (!fInternalOnly)
		{
			Verify (0==GlobalFree(*phMem));
		}
    }
	*phMem = NULL;
}



OLEAPI CreateStreamOnHGlobal
	(HANDLE hGlobal,
	BOOL fDeleteOnRelease,
	LPSTREAM FAR* ppstm)
{
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CreateStreamOnHGlobal16(hGlobal=%x)\n",0,hGlobal));

	HANDLE				hMem	  = NULL; // point to
    struct MEMSTM FAR* 	pData 	  = NULL; //   a struct MEMSTM
    LPSTREAM 			pstm	  = NULL;
	DWORD 		 		cbSize   = -1L;

	VDATEPTRIN (ppstm, LPSTREAM);
	*ppstm = NULL;
    if (NULL==hGlobal)
	{
		hGlobal = GlobalAlloc(grfMem, 0);
	    if (hGlobal == NULL)
    	    goto ErrorExit;
    	cbSize = 0;
	}
	else
	{
		cbSize = GlobalSize (hGlobal);
		// Is there a way to verify a zero-sized handle?
		if (cbSize!=0)
		{
			// verify validity of passed-in handle
			if (NULL==GlobalLock(hGlobal))
			{
				// bad handle
				return ResultFromScode (E_INVALIDARG);
			}
			GlobalUnlock (hGlobal);
		}
	}

	hMem = GlobalAlloc (grfMem, sizeof (MEMSTM));
    if (hMem == NULL)
   	    goto ErrorExit;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
   	    goto FreeMem;

	pData->cRef = 0;
   	pData->cb = cbSize;
	pData->fDeleteOnRelease = fDeleteOnRelease;
	pData->hGlobal = hGlobal;

    pstm = CMemStm::Create(hMem);
    if (pstm == NULL)
        goto FreeMem;

    *ppstm = pstm;
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CreateStreamOnHGlobal16() returns NOERROR\n",0));
	return NOERROR;
	
FreeMem:	
	if (hMem)
	{
	    Verify(0==GlobalFree(hMem));
	}
ErrorExit:
	Assert (0);
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CreateStreamOnHGlobal16() returns E_OUTOFMEMORY\n",0));

    return ReportResult(0, E_OUTOFMEMORY, 0, 0);
}


OLEAPI GetHGlobalFromStream
	(LPSTREAM 		pstm,
	HGLOBAL	FAR*	phglobal)
{
	VDATEIFACE (pstm);
	VDATEPTRIN (phglobal, HANDLE);

	CMemStm FAR* pCMemStm = (CMemStm FAR*) pstm;
	if (IsBadReadPtr (&(pCMemStm->m_dwSig), sizeof(ULONG))
		|| pCMemStm->m_dwSig != STREAM_SIG)
	{
		// we were passed someone else's implementation of ILockBytes
		return ResultFromScode (E_INVALIDARG);
	}

	MEMSTM FAR* pMem= pCMemStm->m_pData;
	if (NULL==pMem)
	{
		Assert (0);
		return ResultFromScode (E_OUTOFMEMORY);
	}
	Assert (pMem->cb <= GlobalSize (pMem->hGlobal));
	Verify (*phglobal = pMem->hGlobal);

	return NOERROR;
}


//////////////////////////////////////////////////////////////////////////
//
// Shared memory ILockBytes implementation
//

OLEMETHODIMP CMemBytes::QueryInterface(REFIID iidInterface,
                                                    void FAR* FAR* ppvObj)
{
	M_PROLOG(this);
    HRESULT error;
    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;
    VDATEIID( iidInterface );

    // Two interfaces supported: IUnknown, ILockBytes

    if (m_pData != NULL &&
            (iidInterface == IID_ILockBytes || iidInterface == IID_IUnknown)) {

        m_refs++;   // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    } else
//
// BUGBUG - See comment above for CMemStm::Queryinterface and IID_IMarshal
//
#ifdef BOBDAY_DISABLE_MARSHAL_FOR_NOW
#else
    if (iidInterface == IID_IMarshal) {
        *ppvObj = (LPVOID) CMarshalMemBytes::Create(this);
        if (*ppvObj != NULL)
            error = NOERROR;
        else
            error = ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    else
#endif
    {                 // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    return error;
}


// Called when CMemBytes is referenced by an additional pointer.
//
OLEMETHODIMP_(ULONG) CMemBytes::AddRef(void)
{
	M_PROLOG(this);
    return ++m_refs;
}

// Called when a pointer to this CMemBytes is discarded
//
OLEMETHODIMP_(ULONG) CMemBytes::Release(void)
{
	M_PROLOG(this);
    if (--m_refs != 0) // Still used by others
        return m_refs;

	ReleaseMemStm(&m_hMem);

    delete this; // Free storage
    return 0;
}


OLEMETHODIMP CMemBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP* pb,
                                              ULONG cb, ULONG FAR* pcbRead)
{
	M_PROLOG(this);
    HRESULT error = NOERROR;
    ULONG cbRead = cb;

    VDATEPTROUT( pb, char );
    if (pcbRead) {
        VDATEPTROUT( pcbRead, ULONG );
        *pcbRead = 0L;
    }

    if (cbRead + ulOffset.LowPart > m_pData->cb) {

        if (ulOffset.LowPart > m_pData->cb)
            cbRead = 0;
        else
            cbRead = m_pData->cb - ulOffset.LowPart;
    }

	if (cbRead > 0)
	{
		char HUGEP* pGlobal = GlobalLock (m_pData->hGlobal);
		if (NULL==pGlobal)
		{
			Assert (0);
			return ResultFromScode (STG_E_READFAULT);
		}
	    UtMemCpy (pb, pGlobal + ulOffset.LowPart, cbRead);
		GlobalUnlock (m_pData->hGlobal);
	}

    if (pcbRead != NULL)
        *pcbRead = cbRead;

    return error;
}


OLEMETHODIMP CMemBytes::WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP* pb,
                                              ULONG cb, ULONG FAR* pcbWritten)
{
	A5_PROLOG(this);
    HRESULT error = NOERROR;
    ULONG cbWritten = cb;
	char HUGEP* pGlobal;

    VDATEPTRIN( pb, char );

    if (pcbWritten) {
        VDATEPTROUT( pcbWritten, ULONG );
        *pcbWritten = 0;
    }

    if (cbWritten + ulOffset.LowPart > m_pData->cb) {
		ULARGE_INTEGER ularge_integer;
		ULISet32( ularge_integer, ulOffset.LowPart + cbWritten);
        error = SetSize( ularge_integer );
        if (error != NOERROR)
            goto Exit;
    }

	pGlobal = GlobalLock (m_pData->hGlobal);
	if (NULL==pGlobal)
	{
		Assert (0);
		return ResultFromScode (STG_E_WRITEFAULT);
	}
    UtMemCpy (pGlobal + ulOffset.LowPart, pb, cbWritten);
	GlobalUnlock (m_pData->hGlobal);
	

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
	RESTORE_A5();
    return error;
}

OLEMETHODIMP CMemBytes::Flush(void)
{
	M_PROLOG(this);
    return NOERROR;
}


OLEMETHODIMP CMemBytes::SetSize(ULARGE_INTEGER cb)
{
	M_PROLOG(this);
    HANDLE hMemNew;

    if (m_pData->cb == cb.LowPart)
        return NOERROR;

    hMemNew = GlobalReAlloc(m_pData->hGlobal,
							max (cb.LowPart, 1),
							grfMem);

    if (hMemNew == NULL)
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);

    m_pData->hGlobal = hMemNew;
    m_pData->cb = cb.LowPart;

    return NOERROR;
}


OLEMETHODIMP CMemBytes::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    // REVIEW - Docfile bug. Must return NOERROR for StgCreateDocfileOnILockbytes
	M_PROLOG(this);
    return NOERROR;
}

OLEMETHODIMP CMemBytes::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                                                      DWORD dwLockType)
{
    // REVIEW - Docfiel bug. Must return NOERROR for StgCreateDocfileOnILockbytes
	M_PROLOG(this);
    return NOERROR;
}


OLEMETHODIMP CMemBytes::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
	M_PROLOG(this);
    VDATEPTROUT( pstatstg, STATSTG );

    pstatstg->pwcsName = NULL;
    pstatstg->type = 0;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->cbSize.LowPart = m_pData->cb;
    pstatstg->mtime.dwLowDateTime = 0;
    pstatstg->mtime.dwHighDateTime = 0;
    pstatstg->ctime.dwLowDateTime = 0;
    pstatstg->ctime.dwHighDateTime = 0;
    pstatstg->atime.dwLowDateTime = 0;
    pstatstg->atime.dwHighDateTime = 0;
    pstatstg->grfMode = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    return NOERROR;
}


// Create CMemBytes.  Handle must be a MEMSTM block.
//
OLESTATICIMP_(CMemBytes FAR*) CMemBytes::Create(HANDLE hMem)
{
    CMemBytes FAR* pCMemBytes;
    struct MEMSTM FAR* pData;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
        return NULL;
	Assert (pData->hGlobal);

    pCMemBytes = new CMemBytes;

    if (pCMemBytes == NULL)
        return NULL;

    // Initialize CMemBytes
    //
	pCMemBytes->m_dwSig = LOCKBYTE_SIG;
    pCMemBytes->m_hMem = hMem;
    (pCMemBytes->m_pData = pData)->cRef++;	// AddRefMemStm
    pCMemBytes->m_refs = 1;

    return pCMemBytes;
}



// CMemStm object's IMarshal implementation
//

OLEMETHODIMP CMarshalMemStm::QueryInterface(REFIID iidInterface,
                                                    void FAR* FAR* ppvObj)
{
	M_PROLOG(this);
    HRESULT error;

    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;
    VDATEIID( iidInterface );

    // Two interfaces supported: IUnknown, IMarshal

    if (iidInterface == IID_IMarshal || iidInterface == IID_IUnknown) {
        m_refs++;           // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    }
    else {                  // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ResultFromScode (E_NOINTERFACE);
    }

    return error;
}


// Called when CMarshalMemStm is referenced by an additional pointer.
//

OLEMETHODIMP_(ULONG) CMarshalMemStm::AddRef(void)
{
 	M_PROLOG(this);
   return ++m_refs;
}

// Called when a pointer to this CMarshalMemStm is discarded
//


OLEMETHODIMP_(ULONG) CMarshalMemStm::Release(void)
{
	M_PROLOG(this);
    if (--m_refs != 0) // Still used by others
        return m_refs;

    if (m_pMemStm != NULL)
        m_pMemStm->Release();

    delete this; // Free storage
    return 0;
}


// Returns the clsid of the object that created this CMarshalMemStm.
//

OLEMETHODIMP CMarshalMemStm::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID FAR* pCid)
{
	M_PROLOG(this);
    VDATEPTROUT( pCid, CLSID);
    VDATEIID( riid );

    *pCid = m_clsid;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemStm::GetMarshalSizeMax(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD FAR* pSize)
{
	M_PROLOG(this);
    VDATEIID( riid );
    VDATEIFACE( pv );
    if (pSize) {
        VDATEPTROUT( pSize, DWORD );
        *pSize = NULL;
    }

    *pSize = sizeof(m_pMemStm->m_hMem);
    return NOERROR;
}


OLEMETHODIMP CMarshalMemStm::MarshalInterface(IStream FAR* pStm,
		  REFIID riid, void FAR* pv,
		  DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
	M_PROLOG(this);
    VDATEPTRIN( pStm, IStream );
    VDATEIID( riid );
    VDATEIFACE( pv );

    if (m_pMemStm == NULL)
        return ReportResult(0, E_UNSPEC, 0, 0);

    if ((riid != IID_IStream && riid != IID_IUnknown) || pv != m_pMemStm)
        return ReportResult(0, E_INVALIDARG, 0, 0);

	// increase ref count on hglobal (ReleaseMarshalData has -- to match)
	HRESULT error;
	if ((error = pStm->Write(&m_pMemStm->m_hMem, sizeof(m_pMemStm->m_hMem),
				NULL)) == NOERROR)
		m_pMemStm->m_pData->cRef++;	// AddRefMemStm

	return error;
}


OLEMETHODIMP CMarshalMemStm::UnmarshalInterface(IStream FAR* pStm,
                                 REFIID riid, void FAR* FAR* ppv)
{
	M_PROLOG(this);
    HRESULT error;
    HANDLE hMem;

    VDATEPTROUT( ppv, LPVOID );
    *ppv = NULL;
    VDATEPTRIN( pStm, IStream );
    VDATEIID( riid );

    if (riid != IID_IStream && riid != IID_IUnknown)
        return ReportResult(0, E_INVALIDARG, 0, 0);

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != NOERROR)
        return error;

    if (m_pMemStm != NULL) {

        if (hMem != m_pMemStm->m_hMem)
            return ReportResult(0, E_UNSPEC, 0, 0);
    }
    else {
        m_pMemStm = (CMemStm FAR*) CloneMemStm(hMem);
        if (m_pMemStm == NULL)
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    m_pMemStm->AddRef();
    *ppv = (LPVOID) m_pMemStm;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemStm::ReleaseMarshalData(IStream FAR* pStm)
{
	M_PROLOG(this);
	// reduce ref count on hglobal (matches that done in MarshalInterface)
	HRESULT error;
	HANDLE hMem;

    VDATEIFACE( pStm );

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error == NOERROR)
		ReleaseMemStm(&hMem);

	return error;
}


OLEMETHODIMP CMarshalMemStm::DisconnectObject(DWORD dwReserved)
{
	M_PROLOG(this);
	return NOERROR;
}


OLESTATICIMP_(CMarshalMemStm FAR*) CMarshalMemStm::Create(CMemStm FAR* pMemStm)
{
    CMarshalMemStm FAR* pMMS;

	//VDATEPTRIN rejects NULL
	if( pMemStm )
    	GEN_VDATEPTRIN( pMemStm, CMemStm, (CMarshalMemStm FAR *) NULL );

    pMMS = new CMarshalMemStm;

    if (pMMS == NULL)
        return NULL;

    if (pMemStm != NULL) {
        pMMS->m_pMemStm = pMemStm;
        pMMS->m_pMemStm->AddRef();
    }

    pMMS->m_clsid = CLSID_StdMemStm;

    pMMS->m_refs = 1;

    return pMMS;
}


OLEAPI_(IUnknown FAR*) CMemStmUnMarshal(void)
{
    return CMarshalMemStm::Create(NULL);
}



// CMemBytes object's IMarshal implementation
//

OLEMETHODIMP CMarshalMemBytes::QueryInterface(REFIID iidInterface,
                                                    void FAR* FAR* ppvObj)
{
	M_PROLOG(this);
    HRESULT error;

    VDATEIID( iidInterface );
    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;

    // Two interfaces supported: IUnknown, IMarshal

    if (iidInterface == IID_IMarshal || iidInterface == IID_IUnknown) {
        m_refs++;           // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    }
    else {                  // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    return error;
}


// Called when CMarshalMemBytes is referenced by an additional pointer.
//

OLEMETHODIMP_(ULONG) CMarshalMemBytes::AddRef(void)
{
	M_PROLOG(this);
    return ++m_refs;
}

// Called when a pointer to this CMarshalMemBytes is discarded
//
OLEMETHODIMP_(ULONG) CMarshalMemBytes::Release(void)
{
	M_PROLOG(this);
    if (--m_refs != 0) // Still used by others
        return m_refs;

    if (m_pMemBytes != NULL)
        m_pMemBytes->Release();

    delete this; // Free storage
    return 0;
}


// Returns the clsid of the object that created this CMarshalMemBytes.
//
OLEMETHODIMP CMarshalMemBytes::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID FAR* pCid)
{
	M_PROLOG(this);
    VDATEIID( riid );
    VDATEIFACE( pv );

    *pCid = m_clsid;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemBytes::GetMarshalSizeMax(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD FAR* pSize)
{
 	M_PROLOG(this);
    VDATEPTROUT( pSize, DWORD );
    VDATEIID( riid );
    VDATEIFACE( pv );

   *pSize = sizeof(m_pMemBytes->m_hMem);
    return NOERROR;
}


OLEMETHODIMP CMarshalMemBytes::MarshalInterface(IStream FAR* pStm,
    REFIID riid, void FAR* pv, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
	M_PROLOG(this);
    VDATEPTRIN(pStm, IStream );
    VDATEIID( riid );
    if ( pv )
        VDATEPTRIN( pv , char );

    if (m_pMemBytes == NULL)
        return ReportResult(0, E_UNSPEC, 0, 0);

    if ((riid != IID_ILockBytes && riid != IID_IUnknown) || pv != m_pMemBytes)
        return ReportResult(0, E_INVALIDARG, 0, 0);

	// increase ref count on hglobal (ReleaseMarshalData has -- to match)
	HRESULT error;
	if ((error = pStm->Write(&m_pMemBytes->m_hMem, sizeof(m_pMemBytes->m_hMem),
				NULL)) == NOERROR)
		m_pMemBytes->m_pData->cRef++;	// AddRefMemStm

	return error;
}


OLEMETHODIMP CMarshalMemBytes::UnmarshalInterface(IStream FAR* pStm,
                                 REFIID riid, void FAR* FAR* ppv)
{
	M_PROLOG(this);
    HRESULT error;
    HANDLE hMem;

    VDATEPTROUT( ppv , LPVOID );
    *ppv = NULL;
    VDATEIFACE( pStm );
    VDATEIID( riid );


    if (riid != IID_ILockBytes && riid != IID_IUnknown)
        return ReportResult(0, E_INVALIDARG, 0, 0);

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != NOERROR)
        return error;

    if (m_pMemBytes != NULL) {

        if (hMem != m_pMemBytes->m_hMem)
            return ReportResult(0, E_UNSPEC, 0, 0);
    }
    else {
        m_pMemBytes = CMemBytes::Create(hMem); // Create the lockbytes

        if (m_pMemBytes == NULL)
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    m_pMemBytes->AddRef();
    *ppv = (LPVOID) m_pMemBytes;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemBytes::ReleaseMarshalData(IStream FAR* pStm)
{
    // reduce ref count on hglobal (matches that done in MarshalInterface)
	M_PROLOG(this);
    HRESULT error;
    MEMSTM FAR* pData;
	HANDLE hMem;

    VDATEIFACE( pStm );

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error == NOERROR)
		ReleaseMemStm(&hMem);

	return error;
}


OLEMETHODIMP CMarshalMemBytes::DisconnectObject(DWORD dwReserved)
{
	M_PROLOG(this);
	return NOERROR;
}


OLESTATICIMP_(CMarshalMemBytes FAR*) CMarshalMemBytes::Create(
                                                      CMemBytes FAR* pMemBytes)
{
    CMarshalMemBytes FAR* pMMB;

 	//VDATEPTRIN rejects NULL
 	if( pMemBytes )
    	GEN_VDATEPTRIN( pMemBytes, CMemBytes, (CMarshalMemBytes FAR *)NULL );

    pMMB = new CMarshalMemBytes;

    if (pMMB == NULL)
        return NULL;

    if (pMemBytes != NULL) {
        pMMB->m_pMemBytes = pMemBytes;
        pMMB->m_pMemBytes->AddRef();
    }

    pMMB->m_clsid = CLSID_StdMemBytes;

    pMMB->m_refs = 1;

    return pMMB;
}

OLEAPI_(IUnknown FAR*) CMemBytesUnMarshal(void)
{
    return CMarshalMemBytes::Create(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\mondthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mondthk.c       (16 bit target)
//
//  Contents:   Moniker APIs that are directly thunked
//
//  History:    17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   BindMoniker,    Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmk] --
//      [grfOpt] --
//      [iidResult] --
//      [ppvResult] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult,
                   LPVOID FAR* ppvResult)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_BindMoniker),
                                    PASCAL_STACK_PTR(pmk));
}

//+---------------------------------------------------------------------------
//
//  Function:   MkParseDisplayName, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pbc] --
//      [szUserName] --
//      [pchEaten] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  MkParseDisplayName(LPBC pbc, LPSTR szUserName,
                           ULONG FAR * pchEaten, LPMONIKER FAR * ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_MkParseDisplayName),
                                    PASCAL_STACK_PTR(pbc));
}

//+---------------------------------------------------------------------------
//
//  Function:   MonikerRelativePathTo, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkSrc] --
//      [pmkDest] --
//      [ppmkRelPath] --
//      [fCalledFromMethod] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                              FAR* ppmkRelPath, BOOL fCalledFromMethod)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_MonikerRelativePathTo),
                                    PASCAL_STACK_PTR(pmkSrc));
}

//+---------------------------------------------------------------------------
//
//  Function:   MonikerCommonPrefixWith, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkThis] --
//      [pmkOther] --
//      [ppmkCommon] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                                LPMONIKER FAR* ppmkCommon)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_MonikerCommonPrefixWith),
                                    PASCAL_STACK_PTR(pmkThis));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateBindCtx, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [reserved] --
//      [ppbc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateBindCtx),
                                    PASCAL_STACK_PTR(reserved));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateGenericComposite, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkFirst] --
//      [pmkRest] --
//      [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
                               LPMONIKER FAR* ppmkComposite)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateGenericComposite),
                                    PASCAL_STACK_PTR(pmkFirst));
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [szFilename] --
//      [pclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  GetClassFile (LPCSTR szFilename, CLSID FAR* pclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_GetClassFile),
                                    PASCAL_STACK_PTR(szFilename));
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateFileMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszPathName] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//		3-15-95	  alexgo    Added hack for CorelDraw
//
//  Notes:	When Corel5.0 starts up, it creates a file moniker
//		with it's string clsid as the name.  If the path name
//		is really CorelDraw, then call into olethk32 to set
//		an app compatibility flag.
//
//		The flag that we set disables paste-link to yourself.  CorelDraw
//		does not support this feature (because of a trashed memory
//		bug in 16bit OLE).
//
//----------------------------------------------------------------------------
STDAPI  CreateFileMoniker(LPSTR lpszPathName, LPMONIKER FAR* ppmk)
{
    static const char szCorelDraw[] =
	"{11A11440-0394-101B-A72E-04021C007002}";


    // just do a quick, manual string compare so we don't have to load
    // the c runtime.

    if( lpszPathName )
    {
	LPCSTR lpszCD = szCorelDraw;
	LPSTR lpszPN = lpszPathName;

	while( *lpszPN != '\0' && *lpszPN == *lpszCD && *lpszCD != '\0' )
	{
	    lpszPN++;
	    lpszCD++;
	}

	if( *lpszCD == '\0' && *lpszPN == '\0' )
	{
	    // the strings matched!  Set the compatibility flag for CorelDraw
	    AddAppCompatFlag(OACF_CORELTRASHMEM);
	}
    }

    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateFileMoniker),
                                    PASCAL_STACK_PTR(lpszPathName));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateItemMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszDelim] --
//      [lpszItem] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateItemMoniker(LPSTR lpszDelim, LPSTR lpszItem,
                          LPMONIKER FAR* ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateItemMoniker),
                                    PASCAL_STACK_PTR(lpszDelim));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAntiMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateAntiMoniker),
                                    PASCAL_STACK_PTR(ppmk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreatePointerMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [punk] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreatePointerMoniker),
                                    PASCAL_STACK_PTR(punk));
}


//+---------------------------------------------------------------------------
//
//  Function:   GetRunningObjectTable, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [reserved] --
//      [pprot] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_GetRunningObjectTable),
                                    PASCAL_STACK_PTR(reserved));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\ole2splt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       ole2splt.cxx
//
//  Contents:   OLE2 API whose implementation is split between 16/32
//
//  History:    07-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>
#include <ole2int.h>
#include <ole2ver.h>
#include <olecoll.h>
#include <map_kv.h>
#include <map_htsk.h>
#include <etask.hxx>

#include <call32.hxx>
#include <apilist.hxx>

// MFC HACK ALERT!!!  The followind constant is needed
// for an MFC workaround.  See OleInitialize for details

#define CLIPBOARDWNDCLASS "CLIPBOARDWNDCLASS"

//+---------------------------------------------------------------------------
//
//  Function:   OleInitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              05-26-94  AlexT     Return correct success code
//		08-22-94  AlexGo    added MFC CreateWindow hack
//
//  Notes:
//
//----------------------------------------------------------------------------

STDAPI OleInitialize(LPMALLOC pMalloc)
{
    HTASK htask;
    Etask etask;
    HRESULT hrCoInit, hrOleInit;
    static BOOL fCreatedClipWindowClass = FALSE;

    /* This version of ole2.dll simply needs to work with the same major build
       of compobj.dll.  Future versions of ole2.dll might be restricted to
       certain builds of compobj.dll. */
    if (HIWORD(CoBuildVersion()) != rmm)
    {
        return ResultFromScode(OLE_E_WRONGCOMPOBJ);
    }

    /* if already initialize one or more times, just bump count and return. */
    if (LookupEtask(htask, etask) && etask.m_oleinits != 0)
    {
        etask.m_oleinits++;
        thkVerify(SetEtask(htask, etask));
        return ResultFromScode(S_FALSE);
    }

    /* Initialize the 16-bit side of compobj */
    hrCoInit = CoInitialize(pMalloc);
    if (SUCCEEDED(GetScode(hrCoInit)))
    {
        /* Thunk OleInitialize
           Never pass on the IMalloc */
        pMalloc = NULL;
        hrOleInit = (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleInitialize),
                                      PASCAL_STACK_PTR(pMalloc) );
        if (FAILED(GetScode(hrOleInit)))
        {
            CoUninitialize();
            return(hrOleInit);
        }

        thkVerify(LookupEtask(htask, etask) && etask.m_oleinits == 0);
        etask.m_oleinits++;
        thkVerify(SetEtask(htask, etask));
    }

    //  Since we call 32-bit CoInitialize and then call 32-bit OleInitialize,
    //  and since the latter internally calls CoInitialize (a second time), we
    //  want to return the HRESULT of the call to CoInitialize since some
    //  applications look for S_OK (and our call to OleInitialize will return
    //  S_FALSE since it will be the second call to CoInitialize).


    //  MFC HACK ALERT!!  MFC2.5 (16bit) has a hack where they scan the
    //  window hierarchy for a window named "CLIPBOARDWNDCLASS".  They then
    //  subclass this window and do their own processing for clipboard
    //  windows messages.
    //
    //  In order to make them work, we create a dummy window for MFC to party
    //  on.  This allows them to successfully subclass and not interfere
    //  with 32bit OLE processing.  (since it's a dummy window)
    //
    //  NB!!  We do not bother with resource cleanup; we'll leave this window
    //  around until the process exits.  We also don't care about errors
    //  here.  In the off chance that one of the calls fails and we *don't*
    //  create a window that MFC can party on, then MFC *debug* apps will
    //  popup an assert dialog.  You can safely click 'OK' on this dialog
    //  and the app will proceed without undue trauma.

    if( !fCreatedClipWindowClass )
    {
	WNDCLASS	wc;

        // Register Clipboard window class
        //
        wc.style = 0;
        wc.lpfnWndProc = DefWindowProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 4;
        wc.hInstance = hmodOLE2;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = CLIPBOARDWNDCLASS;

	// don't bother checking for errors
        RegisterClass(&wc);
	fCreatedClipWindowClass = TRUE;
    }
	
    CreateWindow(CLIPBOARDWNDCLASS,"",WS_POPUP,CW_USEDEFAULT,
			CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
			NULL,NULL,hmodOLE2,NULL);

    return hrOleInit;
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUninitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(void) OleUninitialize(void)
{
    HTASK htask;
    Etask etask;

    /* If not init, just return */
    if (!LookupEtask(htask, etask) || etask.m_oleinits == 0)
    {
        return;
    }

    /* Must always decrement count and set since compobj may still be init'd */
    etask.m_oleinits--;
    thkVerify(SetEtask(htask, etask));

    /* if not last uninit, now return */
    if (etask.m_oleinits != 0)
    {
        return;
    }

    /* After this point, the uninit should not fail (because we don't have
       code to redo the init). */

    CallObjectInWOW(THK_API_METHOD(THK_API_OleUninitialize), NULL );
    CoUninitialize();
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadClassStm, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [pclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadClassStm),
                                    PASCAL_STACK_PTR(pStm) );
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteClassStm, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [rclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteClassStm) ,
                                    PASCAL_STACK_PTR(pStm) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\storage\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Precompiled header file
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include <compobj.h>
#include <storage.h>

#include <interop.hxx>
#include <wow16fn.h>
#include <io16.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\ole2\ole2lcl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	ole2lcl.cxx	(16 bit target)
//
//  Contents:	OLE2 APIs implemented locally
//
//  Functions:	
//
//  History:	17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <limits.h>

#include <ole2sp.h>
#include <ole2ver.h>
#include <valid.h>
#include <ole2int.h>

#include <call32.hxx>
#include <apilist.hxx>

DWORD gdwOleVersion = MAKELONG(OLE_STREAM_VERSION, OLE_PRODUCT_VERSION);

//+---------------------------------------------------------------------------
//
//  Function:   OleGetMalloc, Local
//
//----------------------------------------------------------------------------
STDAPI OleGetMalloc(DWORD dwContext, IMalloc FAR* FAR* ppMalloc)
{
    return CoGetMalloc(dwContext, ppMalloc);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleBuildVersion, Local
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) OleBuildVersion( VOID )
{
    return CoBuildVersion();
}

//+---------------------------------------------------------------------------
//
//  Function:	OleDuplicateData, Local
//
//  Synopsis:	Duplicates the given data
//
//  History:	11-Apr-94	DrewB	Copied from various places in OLE2
//
//----------------------------------------------------------------------------

FARINTERNAL_(HBITMAP) BmDuplicate 
	(HBITMAP hold, DWORD FAR* lpdwSize, LPBITMAP lpBm)
{
    HBITMAP     hnew = NULL;
    HANDLE      hMem;
    LPSTR       lpMem;
    DWORD       dwSize;
    BITMAP      bm;
    SIZE		extents;

    extents.cx = extents.cy = 0;

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
             ((DWORD) bm.bmPlanes);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
        return NULL;

    if (!(lpMem = (LPSTR) GlobalLock (hMem)))
		goto errRtn;
	GlobalUnlock (hMem);
    
    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight, 
                    bm.bmPlanes, bm.bmBitsPixel, NULL)) {
        if (!SetBitmapBits (hnew, dwSize, lpMem)) {
			DeleteObject (hnew);
			hnew = NULL;
			goto errRtn;
		}
	}

	if (lpdwSize)
		*lpdwSize = dwSize;
    
	if (lpBm)
        *lpBm = bm;
    
    if (GetBitmapDimensionEx(hold, &extents) && extents.cx && extents.cy)
        SetBitmapDimensionEx(hnew, extents.cx, extents.cy, NULL);
        
errRtn:
	if (hMem)
		GlobalFree (hMem);
        
	return hnew;
}

FARINTERNAL_(HPALETTE) UtDupPalette
	(HPALETTE hpalette) 
{
	WORD 			cEntries = 0;
	HANDLE 			hLogPal = NULL;
	LPLOGPALETTE 	pLogPal = NULL;
	HPALETTE		hpaletteNew = NULL;

	if (0==GetObject (hpalette, sizeof(cEntries), &cEntries))
		return NULL;

	if (NULL==(hLogPal = GlobalAlloc (GMEM_MOVEABLE, sizeof (LOGPALETTE) + 
										cEntries * sizeof (PALETTEENTRY))))
		return NULL;

	if (NULL==(pLogPal = (LPLOGPALETTE) GlobalLock (hLogPal)))
		goto errRtn;
		
	if (0==GetPaletteEntries (hpalette, 0, cEntries, pLogPal->palPalEntry))
		goto errRtn;

	pLogPal->palVersion    = 0x300;
	pLogPal->palNumEntries = cEntries;

	if (NULL==(hpaletteNew = CreatePalette (pLogPal)))
		goto errRtn;

errRtn:
	if (pLogPal)
		GlobalUnlock (hLogPal);
	if (hLogPal)
		GlobalFree (hLogPal);
	AssertSz (hpaletteNew, "Warning: UtDupPalette Failed");
	return hpaletteNew;
}
	
FARINTERNAL_(HANDLE) UtDupGlobal (HANDLE hsrc, UINT uiFlags)
{
    HANDLE  hdst;
    DWORD   dwSize;
    LPSTR   lpdst = NULL;
    LPSTR   lpsrc = NULL;

    if (!hsrc)
        return NULL;

    if (!(lpsrc = GlobalLock (hsrc)))
	return NULL;

    hdst = GlobalAlloc (uiFlags, (dwSize = GlobalSize(hsrc)));
    if (hdst == NULL || (lpdst = GlobalLock (hdst)) == NULL)
	goto errRtn;
	
    UtMemCpy (lpdst, lpsrc, dwSize);
    GlobalUnlock (hsrc);
    GlobalUnlock (hdst);
    return hdst;
	
errRtn:
    if (hdst) 
        GlobalFree (hdst);
    
    return NULL;
}

OLEAPI_(HANDLE) OleDuplicateData 
	(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
{	
	if (!hSrc) 
		return NULL;

	if (cfFormat == CF_BITMAP)
		return (HANDLE) BmDuplicate ((HBITMAP)hSrc, NULL, NULL);

	if (cfFormat == CF_PALETTE)
  		return (HANDLE) UtDupPalette ((HPALETTE)hSrc);

	if (uiFlags == NULL)
		uiFlags = GMEM_MOVEABLE;

	if (cfFormat == CF_METAFILEPICT) {
		HANDLE	hDst;

		LPMETAFILEPICT lpmfpSrc;
		LPMETAFILEPICT lpmfpDst;

		if (!(lpmfpSrc = (LPMETAFILEPICT) GlobalLock (hSrc)))
			return NULL;
		
		if (!(hDst = UtDupGlobal (hSrc, uiFlags)))
			return NULL;
		
		if (!(lpmfpDst = (LPMETAFILEPICT) GlobalLock (hDst))) {
			GlobalFree (hDst);
			return NULL;
		}			
		
		*lpmfpDst = *lpmfpSrc;
		lpmfpDst->hMF = CopyMetaFile (lpmfpSrc->hMF, NULL);
		GlobalUnlock (hSrc);	
		GlobalUnlock (hDst);			
		return hDst;
	
	} else {
		return  UtDupGlobal (hSrc, uiFlags);
	}
}

//+---------------------------------------------------------------------------
//
//  Function:	SetBitOleStg, private
//
//  Synopsis:   Sets bit in ole stream; doc bit preserved even when stream
//              rewritten above; the value written is (old & mask) | value.
//
//  Arguments:	[pstg] - Storage
//              [mask] - Mask
//              [value] - Value
//
//  Returns:	Appropriate status code
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

static INTERNAL SetBitOleStg(LPSTORAGE pstg, DWORD mask, DWORD value)
{
    IStream FAR *   pstm = NULL;
    HRESULT	    error;
    DWORD	    objflags = 0;
    LARGE_INTEGER   large_integer;
    ULONG           cbRead;

    VDATEIFACE( pstg );

    if (error = pstg->OpenStream(OLE_STREAM, NULL, STGM_SALL, 0, &pstm))
    {
        if (STG_E_FILENOTFOUND != GetScode(error))
        {
            goto errRtn;
        }

        if (error = pstg->CreateStream(OLE_STREAM, STGM_SALL, 0, 0, &pstm))
        {
            goto errRtn;
        }

        DWORD dwBuf[5];
        		
        dwBuf[0] = gdwOleVersion;
        dwBuf[1] = objflags;
        dwBuf[2] = 0L;
        dwBuf[3] = 0L;
        dwBuf[4] = 0L;
		
        if ((error = pstm->Write(dwBuf, 5*sizeof(DWORD), NULL)) != NOERROR)
        {
            goto errRtn;
        }
    }

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error = pstm->Seek(large_integer, STREAM_SEEK_SET, NULL)) != NOERROR)
    {
        goto errRtn;
    }

    if ((error = pstm->Read(&objflags, sizeof(objflags), &cbRead)) != NOERROR)
    {
        goto errRtn;
    }
    if (cbRead != sizeof(objflags))
    {
        goto errRtn;
    }

    objflags = (objflags & mask) | value;

    LISet32( large_integer, sizeof(DWORD) );
    if ((error = pstm->Seek(large_integer, STREAM_SEEK_SET, NULL)) != NOERROR)
    {
        goto errRtn;
    }

    error = pstm->Write(&objflags, sizeof(DWORD), NULL);
	
 errRtn:
    // close and return error code.
    if (pstm)
    {
        pstm->Release();
    }
    
    return error;
}

//+---------------------------------------------------------------------------
//
//  Function:	GetFlagsOleStg, private
//
//  Synopsis:	Return long word of flags from the ole stream
//
//  Arguments:	[pstg] - Storage
//              [lpobjflags] - Flags return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[lpobjflags]
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

static INTERNAL GetFlagsOleStg(LPSTORAGE pstg, LPDWORD lpobjflags)
{
    IStream FAR *   pstm = NULL;
    HRESULT	    error;
    LARGE_INTEGER   large_integer;
    ULONG           cbRead;

    VDATEIFACE( pstg );

    if ((error = pstg->OpenStream(OLE_STREAM, NULL, 
                                  (STGM_READ | STGM_SHARE_EXCLUSIVE), 
                                  0, &pstm)) != NOERROR)
    {
        goto errRtn;
    }

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL)) != NOERROR)
    {
        goto errRtn;
    }

    error = pstm->Read(lpobjflags, sizeof(*lpobjflags), &cbRead);
    if (SUCCEEDED(GetScode(error)) && cbRead != sizeof(*lpobjflags))
    {
        error = ResultFromScode(STG_E_READFAULT);
    }

 errRtn:
    // close and return error NOERROR (document)/S_FALSE (embedding);
    if (pstm)
    {
        pstm->Release();
    }
    
    return error == NOERROR ? NOERROR : ReportResult(0, S_FALSE, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:	GetDocumentBitStg, semi-private
//
//  Synopsis:   Get doc bit; return NOERROR if on; S_FALSE if off
//
//  Arguments:	[pStg] - Storage
//
//  Returns:	Appropriate status code
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

STDAPI GetDocumentBitStg(LPSTORAGE pStg)
{
    DWORD objflags;
    HRESULT error;

    if ((error = GetFlagsOleStg(pStg, &objflags)) != NOERROR)
    {
        return error;
    }

    return (objflags&OBJFLAGS_DOCUMENT) ? NOERROR : ResultFromScode(S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:	SetDocumentBitStg, semi-private
//
//  Synopsis:	Set doc bit according to fDocument
//
//  Arguments:	[pStg] - Storage
//              [fDocument] - Document flag
//
//  Returns:	Appropriate status code
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

STDAPI SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument)
{
    return SetBitOleStg(pStg, fDocument ? -1L : ~OBJFLAGS_DOCUMENT, 
                        fDocument ? OBJFLAGS_DOCUMENT : 0);
}

//+---------------------------------------------------------------------------
//
//  Function:	ReleaseStgMedium, public
//
//  History:	18-Mar-94	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

STDAPI_(void) ReleaseStgMedium(LPSTGMEDIUM pMedium)
{
    if (pMedium)
    {
        //VDATEPTRIN rejects NULL
        VOID_VDATEPTRIN( pMedium, STGMEDIUM );
        BOOL fPunkRel = pMedium->pUnkForRelease != NULL;

        switch (pMedium->tymed)
        {
        case TYMED_HGLOBAL:	
            if (pMedium->hGlobal != NULL && !fPunkRel)
                Verify(GlobalFree(pMedium->hGlobal) == 0);
            break;

        case TYMED_GDI:
            if (pMedium->hGlobal != NULL && !fPunkRel)
                DeleteObject(pMedium->hGlobal);
            break;

        case TYMED_MFPICT:
            if (pMedium->hGlobal != NULL && !fPunkRel)
            {
                LPMETAFILEPICT  pmfp;

                if ((pmfp = (LPMETAFILEPICT)GlobalLock(pMedium->hGlobal)) ==
                    NULL)
                    break;
                
                DeleteMetaFile(pmfp->hMF);
                GlobalUnlock(pMedium->hGlobal);
                Verify(GlobalFree(pMedium->hGlobal) == 0);
            }
            break;

        case TYMED_FILE:		
            if (pMedium->lpszFileName != NULL)
            {
                if (!IsValidPtrIn(pMedium->lpszFileName, 1))
                    break;
                if (!fPunkRel)
                {
                    OFSTRUCT of;
                    OpenFile(pMedium->lpszFileName, &of, OF_DELETE);
                }
                
                delete pMedium->lpszFileName;
            }
            break;
			
        case TYMED_ISTREAM:	
            if (pMedium->pstm != NULL && 
                IsValidInterface(pMedium->pstm))
                pMedium->pstm->Release(); 
            break;
			
        case TYMED_ISTORAGE:	
            if (pMedium->pstg != NULL && 
                IsValidInterface(pMedium->pstg))
                pMedium->pstg->Release(); 
            break;
			
        case TYMED_NULL:		
            break;
			
        default:
            thkAssert(!"Invalid medium in ReleaseStgMedium");
        }

        // NULL out to prevent unwanted use of just freed data
        pMedium->tymed = TYMED_NULL;

        if (pMedium->pUnkForRelease)
        {
            if (IsValidInterface(pMedium->pUnkForRelease))
                pMedium->pUnkForRelease->Release();
            pMedium->pUnkForRelease = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	OleDoAutoConvert, local
//
//  Synopsis:	Taken from ole32 code
//
//  History:	06-Oct-94	DrewB	Created
//
//  Notes:	This routine must be local because it can return
//              information through pClsidNew even when it is
//              returning an error
//
//----------------------------------------------------------------------------

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
{
    HRESULT error;
    CLSID clsidOld;
    CLIPFORMAT cfOld;
    LPSTR lpszOld = NULL;
    LPSTR lpszNew = NULL;
    LPMALLOC pma;
    
    if ((error = ReadClassStg(pStg, &clsidOld)) != NOERROR)
    {
        clsidOld = CLSID_NULL;
        goto errRtn;
    }

    if ((error = OleGetAutoConvert(clsidOld, pClsidNew)) != NOERROR)
    {
        goto errRtn;
    }

    // read old fmt/old user type; sets out params to NULL on error
    error = ReadFmtUserTypeStg(pStg, &cfOld, &lpszOld);
    Assert(error == NOERROR || (cfOld == NULL && lpszOld == NULL));

    // get new user type name; if error, set to NULL string
    if ((error = OleRegGetUserType(*pClsidNew, USERCLASSTYPE_FULL,
                                   &lpszNew)) != NOERROR)
    {
        lpszNew = NULL;
    }

    // write class stg
    if ((error = WriteClassStg(pStg, *pClsidNew)) != NOERROR)
    {
        goto errRtn;
    }

    // write old fmt/new user type;
    if ((error = WriteFmtUserTypeStg(pStg, cfOld, lpszNew)) != NOERROR)
    {
        goto errRewriteInfo;
    }

    // set convert bit
    if ((error = SetConvertStg(pStg, TRUE)) != NOERROR)
    {
        goto errRewriteInfo;
    }

    goto okRtn;

 errRewriteInfo:
    (void)WriteClassStg(pStg, clsidOld);
    (void)WriteFmtUserTypeStg(pStg, cfOld, lpszOld);

 errRtn:
    *pClsidNew = clsidOld;

 okRtn:
    if (CoGetMalloc(MEMCTX_TASK, &pma) == NOERROR)
    {
        pma->Free(lpszOld);
        pma->Free(lpszNew);
        pma->Release();
    }

    return error;
}

/****** Other API defintions **********************************************/

//+---------------------------------------------------------------------------
//
//  Function:	Utility functions not in the spec; in ole2.dll.
//
//  History:	20-Apr-94	DrewB	Taken from OLE2 sources
//
//----------------------------------------------------------------------------

#define AVERAGE_STR_SIZE	64

FARINTERNAL_(HRESULT) StRead (IStream FAR * lpstream, LPVOID lpBuf, ULONG ulLen)
{
    HRESULT error;
    ULONG cbRead;

    if ((error = lpstream->Read( lpBuf, ulLen, &cbRead)) != NOERROR)
        return error;
	
    return ((cbRead != ulLen) ? ResultFromScode(STG_E_READFAULT) : NOERROR);
}

// returns S_OK when string read and allocated (even if zero length) 
OLEAPI  ReadStringStream( LPSTREAM pstm, LPSTR FAR * ppsz )
{
    ULONG cb;
    HRESULT hresult;
	
    *ppsz = NULL;

    if ((hresult = StRead(pstm, (void FAR *)&cb, sizeof(ULONG))) != NOERROR)
        return hresult;

    if (cb == NULL)
        // NULL string case
        return NOERROR;

    if ((LONG)cb < 0 || cb > INT_MAX)
        // out of range
        return ReportResult(0, E_UNSPEC, 0, 0);
	
    if (!(*ppsz = new FAR char[(int)cb]))
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);

    if ((hresult = StRead(pstm, (void FAR *)(*ppsz), cb)) != NOERROR)
        goto errRtn;
	
    return NOERROR;

errRtn:	
    delete *ppsz;
    *ppsz = NULL;
    return hresult;
}

OLEAPI	WriteStringStream(LPSTREAM pstm, LPCSTR psz)
{
    HRESULT error;
    ULONG cb = NULL;

    if (psz) { 
        cb = 1 + _fstrlen(psz);

        // if possible, do a single write instead of two
		
        if (cb <= AVERAGE_STR_SIZE-4) {
            char szBuf[AVERAGE_STR_SIZE];
		
            *((ULONG FAR*) szBuf) = cb;
            lstrcpy(szBuf+sizeof(ULONG), psz);
			
            return pstm->Write((VOID FAR *)szBuf, cb+sizeof(ULONG), NULL);
        }
    }
	
    if (error = pstm->Write((VOID FAR *)&cb, sizeof(ULONG), NULL))
        return error;
	
    if (psz == NULL)
        // we are done writing the string
        return NOERROR;
		
    return pstm->Write((VOID FAR *)psz, cb, NULL);
}

OLEAPI	OpenOrCreateStream( IStorage FAR * pstg, char const FAR * pwcsName,
	IStream FAR* FAR* ppstm)
{
    HRESULT error;
    error = pstg->CreateStream(pwcsName,
                               STGM_SALL | STGM_FAILIFTHERE, 0, 0, ppstm);
    if (GetScode(error) == STG_E_FILEALREADYEXISTS)
        error = pstg->OpenStream(pwcsName, NULL, STGM_SALL, 0, ppstm);
    
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\storage\stgdthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       stgdthk.cxx     (16 bit target)
//
//  Contents:   Storage APIs that are directly thunked
//
//  History:    17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   Straight thunk routines
//
//  Synopsis:   The following routines thunk straight through
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    /* Relies on the fact that storage and ole2.dll both use the
       same DllGetClassObject in ole32.dll */
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_DllGetClassObject),
                                    PASCAL_STACK_PTR(clsid));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgCreateDocfile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pwcsName] --
//      [grfMode] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgCreateDocfile(const char FAR* pwcsName,
                        DWORD grfMode,
                        DWORD reserved,
                        IStorage FAR * FAR *ppstgOpen)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgCreateDocfile),
                                    PASCAL_STACK_PTR(pwcsName));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgCreateDocfileOnILockBytes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [plkbyt] --
//      [grfMode] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                                    DWORD grfMode,
                                    DWORD reserved,
                                    IStorage FAR * FAR *ppstgOpen)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgCreateDocfileOnILockBytes),
                                    PASCAL_STACK_PTR(plkbyt));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgOpenStorage, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pwcsName] --
//      [pstgPriority] --
//      [grfMode] --
//      [snbExclude] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgOpenStorage(const char FAR* pwcsName,
                      IStorage FAR *pstgPriority,
                      DWORD grfMode,
                      SNB snbExclude,
                      DWORD reserved,
                      IStorage FAR * FAR *ppstgOpen)
{
    // STGM_CREATE and STGM_CONVERT are illegal for open calls
    // 16-bit code did not enforce this, so mask out these flags
    // before passing grfMode on
    grfMode &= ~(STGM_CREATE | STGM_CONVERT);

    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgOpenStorage),
                                    PASCAL_STACK_PTR(pwcsName));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgOpenStorageOnILockBytes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [plkbyt] --
//      [pstgPriority] --
//      [grfMode] --
//      [snbExclude] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                                  IStorage FAR *pstgPriority,
                                  DWORD grfMode,
                                  SNB snbExclude,
                                  DWORD reserved,
                                  IStorage FAR * FAR *ppstgOpen)
{
    // STGM_CREATE and STGM_CONVERT are illegal for open calls
    // 16-bit code did not enforce this, so mask out these flags
    // before passing grfMode on
    grfMode &= ~(STGM_CREATE | STGM_CONVERT);

    return
       (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgOpenStorageOnILockBytes),
                                 PASCAL_STACK_PTR(plkbyt));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgIsStorageFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pwcsName] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgIsStorageFile(const char FAR* pwcsName)
{
    //
    // MSPUB 2.0a hack - We call the "CheckInit" version because they forgot
    // to call CoInitialize/OleInitialize first.
    //
    return
        (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgIsStorageFile),
                                          PASCAL_STACK_PTR(pwcsName));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgIsStorageILockBytes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [plkbyt] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgIsStorageILockBytes),
                                    PASCAL_STACK_PTR(plkbyt));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgSetTimes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszName] --
//      [pctime] --
//      [patime] --
//      [pmtime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgSetTimes(char const FAR* lpszName,
                   FILETIME const FAR* pctime,
                   FILETIME const FAR* patime,
                   FILETIME const FAR* pmtime)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgSetTimes),
                                    PASCAL_STACK_PTR(lpszName));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\ole16\storage\storage.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	storage.c	(16 bit target)
//
//  Contents:	Storage.dll common code
//
//  History:	17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

DECLARE_INFOLEVEL(thk1);

//+---------------------------------------------------------------------------
//
//  Function:	LibMain, public
//
//  Synopsis:	DLL initialization function
//
//  Arguments:	[hinst] - Instance handle
//              [wDataSeg] - Current DS
//              [cbHeapSize] - Heap size for the DLL
//              [lpszCmdLine] - Command line information
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static char achInfoLevel[32];
#endif

int CALLBACK LibMain(HINSTANCE hinst,
                     WORD wDataSeg,
                     WORD cbHeapSize,
                     LPSTR lpszCmdLine)
{
#if DBG == 1
    if (GetProfileString("olethk32", "InfoLevel", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }
#endif

    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:	WEP, public
//
//  Synopsis:	Windows Exit Point routine, for receiving DLL unload
//              notification
//
//  Arguments:	[nExitType] - Type of exit occurring
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

int CALLBACK WEP(int nExitType)
{
    // Clean up thunk objects?
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\alias.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	alias.cxx
//
//  Contents:	Alias implementations
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::CAliasBlock, public
//
//  Synopsis:	Constructor
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

CAliasBlock::CAliasBlock(ALIAS aliasBase,
                         CAliasBlock *pabNext)
{
    _aliasBase = aliasBase;
    _iFilled = 0;
    _pabNext = pabNext;

    // Since INVALID_VALUE is a DWORD we can't directly memset it,
    // but we'd like to use memset so assert that it's a known value
    // and go ahead
    thkAssert(INVALID_VALUE == 0);
    memset(_dwValues, 0, sizeof(_dwValues));
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::ValueAlias, public
//
//  Synopsis:	Find the alias for a value
//
//  Arguments:	[dwValue] - Value
//
//  Returns:    Alias or INVALID_ALIAS
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

ALIAS CAliasBlock::ValueAlias(DWORD dwValue)
{
    int i;
    DWORD *pdw;

    thkAssert(dwValue != INVALID_VALUE);

#if DBG == 1
    CheckFree();
#endif

    if (_iFilled == 0)
    {
        return INVALID_ALIAS;
    }

    pdw = _dwValues;
    for (i = 0; i < ALIAS_BLOCK_SIZE; i++)
    {
        if (*pdw == dwValue)
        {
            return IndexAlias(i);
        }

        pdw++;
    }

    return INVALID_ALIAS;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::AddValue, public
//
//  Synopsis:	Adds a new value
//
//  Arguments:	[dwValue] - New value
//
//  Returns:	Alias for block or INVALID_ALIAS
//
//  History:	26-May-94	DrewB	Created
//
//  Notes:      Duplicates are not allowed
//
//----------------------------------------------------------------------------

ALIAS CAliasBlock::AddValue(DWORD dwValue)
{
    int i;
    DWORD *pdw;

    thkAssert(dwValue != INVALID_VALUE);

#if DBG == 1
    CheckFree();
#endif

    if (_iFilled == ALIAS_BLOCK_SIZE)
    {
        return INVALID_ALIAS;
    }

    // Check for duplicates
    thkAssert(ValueAlias(dwValue) == INVALID_ALIAS);

    pdw = _dwValues;
    for (i = 0; i < ALIAS_BLOCK_SIZE; i++)
    {
        if (*pdw == INVALID_VALUE)
        {
            break;
        }

        pdw++;
    }

    thkAssert(i < ALIAS_BLOCK_SIZE);

    _iFilled++;
    _dwValues[i] = dwValue;

    return IndexAlias(i);
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::CheckFree, public debug
//
//  Synopsis:	Checks to make sure that _iFilled is correct
//
//  History:	30-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CAliasBlock::CheckFree(void)
{
    int i, iFilled;
    DWORD *pdw;

    iFilled = 0;
    pdw = _dwValues;
    for (i = 0; i < ALIAS_BLOCK_SIZE; i++)
    {
        if (*pdw != INVALID_VALUE)
        {
            iFilled++;
        }

        pdw++;
    }

    thkAssert(iFilled == _iFilled);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::~CAliases, public
//
//  Synopsis:	Destructor
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

CAliases::~CAliases(void)
{
    CAliasBlock *pab;

    while (_pabAliases)
    {
        pab = _pabAliases->GetNext();
	//
	// The first alias block added to the list is a static one. We
	// cannot call the heap to deallocate it.
	//
	if (_pabAliases != &_abStatic)
	{
	    delete _pabAliases;
	}

        _pabAliases = pab;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliases::AliasValue, public
//
//  Synopsis:	Returns the value for an alias
//
//  Arguments:	[alias] - Alias
//
//  Returns:	Value
//
//  History:	26-May-94	DrewB	Created
//
//  Notes:      Alias must be valid
//
//----------------------------------------------------------------------------

DWORD CAliases::AliasValue(ALIAS alias)
{
    CAliasBlock *pab;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        if (pab->ContainsAlias(alias))
        {
            return pab->AliasValue(alias);
        }
    }

    thkAssert(!"Invalid alias in CAliases::AliasValue");

    return 0xffffffff;
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::ValueAlias, public
//
//  Synopsis:	Returns the alias for a value
//
//  Arguments:	[dwValue] - Value
//
//  Returns:	Alias
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

ALIAS CAliases::ValueAlias(DWORD dwValue)
{
    CAliasBlock *pab;
    ALIAS alias;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        alias = pab->ValueAlias(dwValue);
        if (alias != INVALID_ALIAS)
        {
            return alias;
        }
    }

    return INVALID_ALIAS;
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::AddValue, public
//
//  Synopsis:	Adds a value and returns its alias
//
//  Arguments:	[dwValue] - Value
//
//  Returns:	Alias or INVALID_ALIAS
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

ALIAS CAliases::AddValue(DWORD dwValue)
{
    CAliasBlock *pab;
    ALIAS alias;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        alias = pab->AddValue(dwValue);
        if (alias != INVALID_ALIAS)
        {
            return alias;
        }
    }

    if ((long)_aliasBase+ALIAS_BLOCK_SIZE >= INVALID_ALIAS)
    {
        return INVALID_ALIAS;
    }

    pab = new CAliasBlock(_aliasBase+ALIAS_BLOCK_SIZE, _pabAliases);
    if (pab == NULL)
    {
        return INVALID_ALIAS;
    }

    _aliasBase += ALIAS_BLOCK_SIZE;
    _pabAliases = pab;

    alias = pab->AddValue(dwValue);

    thkAssert(alias != INVALID_ALIAS);

    return alias;
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::RemoveAlias, public
//
//  Synopsis:	Removes an alias
//
//  Arguments:	[alias] - Alias
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CAliases::RemoveAlias(ALIAS alias)
{
    CAliasBlock *pab, *pabPrev;

    pabPrev = NULL;
    for (pab = _pabAliases; pab; pabPrev = pab, pab = pab->GetNext())
    {
        if (pab->ContainsAlias(alias))
        {
            pab->RemoveAlias(alias);

            if (pab->AliasesFilled() == 0)
            {
                DeleteBlock(pab, pabPrev);
            }

            return;
        }
    }

    thkAssert(!"Invalid alias in CAliases::RemoveAlias");
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::SetValue, public
//
//  Synopsis:	Sets the value for an alias
//
//  Arguments:	[alias] - Alias
//              [dwValue] - Value
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CAliases::SetValue(ALIAS alias, DWORD dwValue)
{
    CAliasBlock *pab;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        if (pab->ContainsAlias(alias))
        {
            pab->SetValue(alias, dwValue);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliases::DeleteBlock, private
//
//  Synopsis:	Deletes an alias block if it's not the static block
//
//  Arguments:	[pab] - Alias block
//              [pabPrev] - Previous alias block
//
//  History:	27-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CAliases::DeleteBlock(CAliasBlock *pab, CAliasBlock *pabPrev)
{
    if (pab == &_abStatic)
    {
        return;
    }

    if (pabPrev)
    {
        pabPrev->SetNext(pab->GetNext());
    }
    else
    {
        _pabAliases = pab->GetNext();
    }

    delete pab;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\dbgint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dbgint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#if DBG == 1

char *apszIUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
};
char *apszIClassFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateInstance"
,    "LockServer"
};
char *apszIMarshalNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetUnmarshalClass"
,    "GetMarshalSizeMax"
,    "MarshalInterface"
,    "UnmarshalInterface"
,    "ReleaseMarshalData"
,    "DisconnectObject"
};
char *apszIStdMarshalInfoNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassForHandler"
};
char *apszIMessageFilterNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "HandleInComingCall"
,    "RetryRejectedCall"
,    "MessagePending"
};
char *apszIExternalConnectionNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "AddConnection"
,    "ReleaseConnection"
};
char *apszIEnumStringNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATSTGNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszILockBytesNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ReadAt"
,    "WriteAt"
,    "Flush"
,    "SetSize"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
};
char *apszIStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Read"
,    "Write"
,    "Seek"
,    "SetSize"
,    "CopyTo"
,    "Commit"
,    "Revert"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
,    "Clone"
};
char *apszIStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateStream"
,    "OpenStream"
,    "CreateStorage"
,    "OpenStorage"
,    "CopyTo"
,    "MoveElementTo"
,    "Commit"
,    "Revert"
,    "EnumElements"
,    "DestroyElement"
,    "RenameElement"
,    "SetElementTimes"
,    "SetClass"
,    "SetStateBits"
,    "Stat"
};
char *apszIRootStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SwitchToFile"
};
char *apszIEnumFORMATETCNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATDATANames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIDataObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetData"
,    "GetDataHere"
,    "QueryGetData"
,    "GetCanonicalFormatEtc"
,    "SetData"
,    "EnumFormatEtc"
,    "DAdvise"
,    "DUnadvise"
,    "EnumDAdvise"
};
char *apszIViewObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
};
char *apszIViewObject2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
,    "GetExtent"
};
char *apszIAdviseSinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
};
char *apszIAdviseSink2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
,    "OnLinkSrcChange"
};
char *apszIDataAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnDataChange"
};
char *apszIOleCacheNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
};
char *apszIOleCache2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
,    "UpdateCache"
,    "DiscardCache"
};
char *apszIOleCacheControlNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnRun"
,    "OnStop"
};
char *apszIDropTargetNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "DragEnter"
,    "DragOver"
,    "DragLeave"
,    "Drop"
};
char *apszIDropSourceNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "QueryContinueDrag"
,    "GiveFeedback"
};
char *apszIPersistNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
};
char *apszIPersistStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "InitNew"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "HandsOffStorage"
};
char *apszIPersistStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
};
char *apszIPersistFileNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "GetCurFile"
};
char *apszIBindCtxNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RegisterObjectBound"
,    "RevokeObjectBound"
,    "ReleaseBoundObjects"
,    "SetBindOptions"
,    "GetBindOptions"
,    "GetRunningObjectTable"
,    "RegisterObjectParam"
,    "GetObjectParam"
,    "EnumObjectParam"
,    "RevokeObjectParam"
};
char *apszIMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
,    "BindToObject"
,    "BindToStorage"
,    "Reduce"
,    "ComposeWith"
,    "Enum"
,    "IsEqual"
,    "Hash"
,    "IsRunning"
,    "GetTimeOfLastChange"
,    "Inverse"
,    "CommonPrefixWith"
,    "RelativePathTo"
,    "GetDisplayName"
,    "ParseDisplayName"
,    "IsSystemMoniker"
};
char *apszIRunningObjectTableNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Register"
,    "Revoke"
,    "IsRunning"
,    "GetObject"
,    "NoteChangeTime"
,    "GetTimeOfLastChange"
,    "EnumRunning"
};
char *apszIEnumMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumOLEVERBNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIOleObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetClientSite"
,    "GetClientSite"
,    "SetHostNames"
,    "Close"
,    "SetMoniker"
,    "GetMoniker"
,    "InitFromData"
,    "GetClipboardData"
,    "DoVerb"
,    "EnumVerbs"
,    "Update"
,    "IsUpToDate"
,    "GetUserClassID"
,    "GetUserType"
,    "SetExtent"
,    "GetExtent"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "GetMiscStatus"
,    "SetColorScheme"
};
char *apszIOleClientSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
};
char *apszIRunnableObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetRunningClass"
,    "Run"
,    "IsRunning"
,    "LockRunning"
,    "SetContainedObject"
};
char *apszIParseDisplayNameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
};
char *apszIOleContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
};
char *apszIOleItemContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
,    "GetObject"
,    "GetObjectStorage"
,    "IsRunning"
};
char *apszIOleAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnRename"
,    "SendOnSave"
,    "SendOnClose"
};
char *apszIOleLinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetUpdateOptions"
,    "GetUpdateOptions"
,    "SetSourceMoniker"
,    "GetSourceMoniker"
,    "SetSourceDisplayName"
,    "GetSourceDisplayName"
,    "BindToSource"
,    "BindIfRunning"
,    "GetBoundSource"
,    "UnbindSource"
,    "Update"
};
char *apszIOleWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
};
char *apszIOleInPlaceObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "InPlaceDeactivate"
,    "UIDeactivate"
,    "SetObjectRects"
,    "ReactivateAndUndo"
};
char *apszIOleInPlaceActiveObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "TranslateAccelerator"
,    "OnFrameWindowActivate"
,    "OnDocWindowActivate"
,    "ResizeBorder"
,    "EnableModeless"
};
char *apszIOleInPlaceUIWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
};
char *apszIOleInPlaceFrameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
,    "InsertMenus"
,    "SetMenu"
,    "RemoveMenus"
,    "SetStatusText"
,    "EnableModeless"
,    "TranslateAccelerator"
};
char *apszIOleInPlaceSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
};
char *apszIRpcChannelBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetBuffer"
,    "SendReceive"
,    "FreeBuffer"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
,    "DebugServerQueryInterface"
,    "DebugServerRelease"
};
char *apszIPSFactoryBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};
char *apszIRpcChannelNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetStream"
,    "Call"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
};
char *apszIPSFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\cthkmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cthkmgr.cxx
//
//  Contents:   cthunkmanager for an apartment
//
//  Classes:    CThkMgr derived from IThunkManager
//
//  Functions:
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include "headers.cxx"
#pragma hdrstop
#include <olepfn.hxx>
#if DBG == 1
BOOL fDebugDump = FALSE;
#define DBG_DUMP(x) if (fDebugDump) { x; }
#else
#define DBG_DUMP(x)
#endif

#define PprxNull(pprx) (((pprx).wType = PPRX_NONE), ((pprx).dwPtrVal = 0))
#define PprxIsNull(pprx) ((pprx).dwPtrVal == 0)
#define Pprx16(vpv) PROXYPTR((DWORD)vpv, PPRX_16)
#define Pprx32(pto) PROXYPTR((DWORD)pto, PPRX_32)

//+---------------------------------------------------------------------------
//
//  Function:   ResolvePprx, public
//
//  Synopsis:   Converts a PROXYPTR to a CProxy *
//
//  Arguments:  [ppprx] - PROXYPTR
//
//  Returns:    Pointer or NULL
//
//  History:    15-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

CProxy *ResolvePprx(PROXYPTR *ppprx)
{
    if (ppprx->wType == PPRX_32)
    {
        return (CProxy *)ppprx->dwPtrVal;
    }
    else
    {
        // Get a pointer to all of the proxy rather than just the CProxy part
        return FIXVDMPTR(ppprx->dwPtrVal, THUNK1632OBJ);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleasePprx, public
//
//  Synopsis:   Releases a resolved PROXYPTR
//
//  Arguments:  [ppprx] - PROXYPTR
//
//  History:    10-Oct-94       DrewB   Created
//
//----------------------------------------------------------------------------

void ReleasePprx(PROXYPTR *ppprx)
{
    if (ppprx->wType == PPRX_16)
    {
        RELVDMPTR(ppprx->dwPtrVal);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::NewHolder, public
//
//  Synopsis:   Creates a new proxy holder
//
//  Arguments:  [pUnk]      - IUnknown ptr
//              [punkProxy] - IUnknown proxy
//              [dwFlags]   - Flags
//
//  Returns:    Holder or NULL
//
//  History:    19-Mar-97       Gopalk    Rewritten to support object identity
//
//----------------------------------------------------------------------------
PROXYHOLDER *CThkMgr::NewHolder(VPVOID pUnk, PROXYPTR unkProxy, DWORD dwFlags)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  CThkMgr::NewHolder(0x%X)\n",
                 NestingLevelString(), dwFlags));
    DebugIncrementNestingLevel();

    // Local variables
    PROXYHOLDER *pph;
    CProxy *proxy;

    // Allocate a new holder
    pph = (PROXYHOLDER *)flHolderFreeList.AllocElement();
    if(pph) {
        // Initialize
        pph->dwFlags = dwFlags;
        pph->cProxies = 0;
        pph->unkProxy = unkProxy;
        PprxNull(pph->pprxProxies);

        // Establish the identity of the new holder
        if(_pHolderTbl->SetAt((DWORD)pUnk, pph)) {
            // Add the IUnknown proxy to the new holder
            proxy = ResolvePprx(&unkProxy);
			if (proxy) {
				AddProxyToHolder(pph, proxy, unkProxy);
				ReleasePprx(&unkProxy);
			}
			else {
				_pHolderTbl->RemoveKey((DWORD)pUnk);
				flHolderFreeList.FreeElement((DWORD)pph);
			}
        }
        else {
            // Free the newly allocated holder
            flHolderFreeList.FreeElement((DWORD)pph);
        }
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut CThkMgr::NewHolder => %p\n",
                 NestingLevelString(), pph));
    return pph;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::AddProxyToHolder, public
//
//  Synopsis:   Adds a new proxy to a holder
//
//  Arguments:  [pph] - Holder
//              [pprxReal] - Proxy
//              [pprx] - Abstract pointer
//
//  History:    07-Jul-94       DrewB   Extracted
//
//----------------------------------------------------------------------------

void CThkMgr::AddProxyToHolder(PROXYHOLDER *pph, CProxy *pprxReal, PROXYPTR &pprx)
{

    thkDebugOut((DEB_THUNKMGR, "%sIn AddProxyToHolder(%p, %p) cProxies %d\n",
                 NestingLevelString(), pph, pprx.dwPtrVal, pph->cProxies));
    DebugIncrementNestingLevel();

    thkAssert(ResolvePprx(&pprx) == pprxReal &&
              (ReleasePprx(&pprx), TRUE));

    // Bump count of held proxies
    AddRefHolder(pph);

    // Add proxy into list of object proxies
    thkAssert(PprxIsNull(pprxReal->pprxObject));
    pprxReal->pprxObject = pph->pprxProxies;
    pph->pprxProxies = pprx;

    thkAssert(pprxReal->pphHolder == NULL);
    pprxReal->pphHolder = pph;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sout AddProxyToHolder(%p, %p) cProxies %d\n",
                 NestingLevelString(), pph, pprx.dwPtrVal, pph->cProxies));
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::AddRefHolder, public
//
//  Synopsis:   Increments the proxy count for a holder
//
//  Arguments:  [pph] - Holder
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CThkMgr::AddRefHolder(PROXYHOLDER *pph)
{
    pph->cProxies++;

    thkDebugOut((DEB_THUNKMGR, "%sAddRefHolder(%p) cProxies %d\n",
                 NestingLevelString(), pph, pph->cProxies));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::ReleaseHolder, public
//
//  Synopsis:   Releases a proxy reference on the holder
//              Cleans up the holder if it was the last reference
//
//  Arguments:  [pph] - Holder
//
//  History:    19-Mar-97       Gopalk    Rewritten to support object identity
//
//----------------------------------------------------------------------------
void CThkMgr::ReleaseHolder(PROXYHOLDER *pph, DWORD ProxyType)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn ReleaseHolder(%p) pre cProxies %d\n",
                 NestingLevelString(), pph, pph->cProxies));
    DebugIncrementNestingLevel();

    // Validation checks
    thkAssert(pph->cProxies > 0);
    if(ProxyType == PROXYFLAG_PUNKINNER) {
        thkAssert(pph->dwFlags & PH_AGGREGATEE);
    }

    // Decrement holder proxy count
    pph->cProxies--;

    if(pph->cProxies==0 && !(pph->dwFlags & PH_IDREVOKED)) {
        // All interfaces on the object have been released
        DWORD dwUnk;

        // Mark the holder as zombie
        pph->dwFlags |= PH_IDREVOKED;

        // Revoke the identity of the holder
        if(pph->dwFlags & PH_AGGREGATEE) {
            dwUnk = pph->unkProxy.dwPtrVal;
        }
        else if(pph->unkProxy.wType == PPRX_16) {
            THUNK1632OBJ UNALIGNED *Id1632;

            Id1632 = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(Id1632);
            dwUnk = (DWORD) Id1632->punkThis32;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
        else {
            thkAssert(pph->unkProxy.wType == PPRX_32);
            dwUnk = ((THUNK3216OBJ *) pph->unkProxy.dwPtrVal)->vpvThis16;
        }
#if DBG==1
        thkAssert(_pHolderTbl->RemoveKey(dwUnk));
#else
        _pHolderTbl->RemoveKey(dwUnk);
#endif
    }

    if(pph->cProxies==0 && ProxyType!=PROXYFLAG_NONE) {
        // Not a nested release
        CProxy *pprxReal;
        PROXYPTR pprx, pprxNext;

        // Release all the proxies under the holder
        pprx = pph->pprxProxies;
        while(!PprxIsNull(pprx)) {
            pprxReal = ResolvePprx(&pprx);
			thkAssert(pprxReal && "pprx points to an invalid address!");
			if (pprxReal) {
				pprxNext = pprxReal->pprxObject;

				thkAssert(pprxReal->cRefLocal == 0);
				thkAssert(pprxReal->pphHolder == pph);

				// Remove the proxy
				if(pprx.wType == PPRX_16) {
					// 1632 proxy
					RemoveProxy1632((VPVOID)pprx.dwPtrVal, (THUNK1632OBJ *)pprxReal);
				}
				else {
					// 3216 proxy
					RemoveProxy3216((THUNK3216OBJ *)pprxReal);
				}

				pprx = pprxNext;
			}
			else
				break;
        }

        // By now, proxy count should be zero
        thkAssert(pph->cProxies == 0);

        // Return holder to free list
        flHolderFreeList.FreeElement((DWORD)pph);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOUT ReleaseHolder\n", NestingLevelString()));
    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::Create
//
//  Synopsis:   static member - creates complete thunkmanager
//
//  Arguments:  [void] --
//
//  Returns:    pointer to cthkmgr
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//              3-14-97   Gopalk                   Added Holder table
//
//  Notes:
//
//----------------------------------------------------------------------------
CThkMgr *CThkMgr::Create(void)
{
    CThkMgr *pcthkmgr = NULL;
    CMapDwordPtr *pPT1632 = new CMapDwordPtr(MEMCTX_TASK);
    CMapDwordPtr *pPT3216 = new CMapDwordPtr(MEMCTX_TASK);
    CMapDwordPtr *pHT = new CMapDwordPtr(MEMCTX_TASK);

    if (   (pPT1632 != NULL)
        && (pPT3216 != NULL)
        && (pHT != NULL)
        && (pcthkmgr = new CThkMgr( pPT1632, pPT3216, pHT )) )
    {
        // install the new thunkmanager
        TlsThkSetThkMgr(pcthkmgr);
    }
    else
    {
        if (pPT1632)
        {
            delete pPT1632;
        }
        if (pPT3216)
        {
            delete pPT3216;
        }
        if(pHT)
        {
            delete pHT;
        }

    }
    return pcthkmgr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CThkMgr
//
//  Synopsis:   private constructor - called by Create
//
//  Arguments:  [pPT1632] -- 16/32 proxy table
//              [pPT3216] -- 32/16 proxy table
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//              3-14-97   Gopalk                   Added Holder table
//
//----------------------------------------------------------------------------
CThkMgr::CThkMgr(CMapDwordPtr *pPT1632,
                 CMapDwordPtr *pPT3216,
                 CMapDwordPtr *pHT)

{
    _cRefs = 1;
    _thkstate = THKSTATE_NOCALL;
    _dwState = CALLBACK_ALLOWED;

    _piidnode = NULL;

    _pProxyTbl1632 = pPT1632;
    _pProxyTbl3216 = pPT3216;
    _pHolderTbl = pHT;

    _pphHolders = NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::~CThkMgr
//
//  Synopsis:   destructor
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
CThkMgr::~CThkMgr()
{
    PROXYHOLDER *pph;
    PIIDNODE pin;

    thkDebugOut((DEB_ITRACE, "_IN CThkMgr::~CThkMgr()\n"));

    RemoveAllProxies();
    thkAssert(_pHolderTbl->GetCount() == 0);
    delete _pProxyTbl1632;
    delete _pProxyTbl3216;

    // Clean up IID requests
#if DBG == 1
    if (_piidnode != NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: IID requests active at shutdown\n"));
    }
#endif

    while (_piidnode != NULL)
    {
        pin = _piidnode->pNextNode;

        thkDebugOut((DEB_IWARN, "IID request leak: %p {%s}\n",
                     _piidnode, IidOrInterfaceString(_piidnode->piid)));

        flRequestFreeList.FreeElement((DWORD)_piidnode);

        _piidnode = pin;
    }

    thkDebugOut((DEB_ITRACE, "OUT CThkMgr::~CThkMgr()\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:	CThkMgr::RemoveAllProxies, public
//
//  Synopsis:	Removes all live proxies from the proxy tables
//
//  History:	01-Dec-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CThkMgr::RemoveAllProxies(void)
{
    POSITION pos;
    DWORD dwKey;
    VPVOID vpv;

    thkDebugOut((DEB_ITRACE, "_IN CThkMgr::RemoveAllProxies()\n"));

    // Make sure that we disable 3216 proxies first to guard against calling
    // back into 16 bit land.

#if DBG == 1
    DWORD dwCount;

    dwCount = _pProxyTbl3216->GetCount();

    if (dwCount > 0)
    {
        thkDebugOut((DEB_WARN, "WARNING: %d 3216 proxies left\n", dwCount));
    }
#endif

    // delete the 3216 proxy table
    while (pos = _pProxyTbl3216->GetStartPosition())
    {
        THUNK3216OBJ *pto3216 = NULL;

        _pProxyTbl3216->GetNextAssoc(pos, dwKey, (void FAR* FAR&) pto3216);

		thkAssert(pto3216 && "CThkMgr::RemoveAllProxies-- found NULL proxy!");
		if (pto3216)
		{
			thkDebugOut((DEB_IWARN, "3216: %p {%d,%d, %p, %p} %s\n",
						 pto3216, pto3216->cRefLocal, pto3216->cRef,
						 pto3216->vpvThis16, pto3216->pphHolder,
						 IidIdxString(pto3216->iidx)));

			pto3216->grfFlags |= PROXYFLAG_CLEANEDUP;

			RemoveProxy3216(pto3216);
		}
    }

#if DBG == 1
    dwCount = _pProxyTbl1632->GetCount();

    if (dwCount > 0)
    {
        thkDebugOut((DEB_WARN, "WARNING: %d 1632 proxies left\n", dwCount));
    }
#endif

    // delete the 1632 proxy table
    while (pos = _pProxyTbl1632->GetStartPosition())
    {
        THUNK1632OBJ *pto1632;

        _pProxyTbl1632->GetNextAssoc(pos, dwKey, (void FAR* FAR&) vpv);

        pto1632 = FIXVDMPTR(vpv, THUNK1632OBJ);

#if DBG == 1
        thkDebugOut((DEB_IWARN, "1632: %p {%d,%d, %p, %p} %s\n",
                     vpv, pto1632->cRefLocal, pto1632->cRef,
                     pto1632->punkThis32, pto1632->pphHolder,
                     IidIdxString(pto1632->iidx)));
#endif
        //
        // Determine if this is a 'special' object that we know we want
        // to release. If it is, then remove all of the references this
        // proxy has on it.
        //
        if (CoQueryReleaseObject(pto1632->punkThis32) == NOERROR)
        {
            thkDebugOut((DEB_WARN,
                         "1632: %p is recognized Releasing object %d times\n",
                         pto1632->punkThis32,pto1632->cRef));

            while (pto1632->cRef)
            {
                IUnknown *punk;

                pto1632->cRef--;
                punk = pto1632->punkThis32;

                RELVDMPTR(vpv);

                if (punk->Release() == 0)
                {
                    break;
                }

                pto1632 = FIXVDMPTR(vpv, THUNK1632OBJ);
            }
        }

        // Releases pointer
        RemoveProxy1632(vpv, pto1632);
    }

    thkDebugOut((DEB_ITRACE, "OUT CThkMgr::RemoveAllProxies()\n"));
}

// *** IUnknown methods ***
//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::QueryInterface
//
//  Synopsis:   QueryInterface on the thunkmanager itself
//
//  Arguments:  [riid] -- IID of interface to return
//              [ppvObj] -- Interface return
//
//  Returns:    HRESULT
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CThkMgr::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsBadWritePtr(ppvObj, sizeof(void *)))
    {
        return E_INVALIDARG;
    }

    *ppvObj = NULL;

    // There is no IID_IThunkManager because nobody needs it

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IUnknown *) this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Methode:    CThkMgr::AddRef
//
//  Synopsis:   Adds a reference
//
//  Returns:    New ref count
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CThkMgr::AddRef ()
{
    InterlockedIncrement( &_cRefs );
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Methode:    CThkMgr::Release
//
//  Synopsis:   Releases a reference
//
//  Returns:    New ref count
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CThkMgr::Release()
{
    if (InterlockedDecrement( &_cRefs ) == 0)
    {

        return 0;
    }
    return _cRefs;
}

// *** IThunkManager methods ***
//
//
//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsIIDRequested
//
//  Synopsis:   checks if given refiid was requested by WOW
//
//  Arguments:  [riid] -- refiid
//
//  Returns:    true if requested by 16 bit
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_ (BOOL) CThkMgr::IsIIDRequested(REFIID riid)
{
    PIIDNODE piidnode = _piidnode;
    BOOL fRet = FALSE;

    while (piidnode)
    {
        if (*piidnode->piid == riid)
        {
            fRet = TRUE;
            break;
        }

        piidnode = piidnode->pNextNode;
    }

    thkDebugOut((DEB_THUNKMGR, "IsIIDRequested(%s) => %d\n",
                 GuidString(&riid), fRet));

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::IsCustom3216Proxy, public
//
//  Synopsis:   Attempts to identify the given IUnknown as a 32->16 proxy
//              and also checks whether it is a thunked interface or not
//
//  Arguments:  [punk] - Object
//
//  Returns:    BOOL
//
//  History:    11-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CThkMgr::IsCustom3216Proxy(IUnknown *punk,
                                               REFIID riid)
{
    return !IsIIDSupported(riid) && IsProxy3216(punk) != 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsIIDSupported
//
//  Synopsis:   Return whether the given interface is thunked or not
//
//  Arguments:  [riid] -- Interface
//
//  Returns:    BOOL
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
BOOL CThkMgr::IsIIDSupported(REFIID riid)
{
    return IIDIDX_IS_INDEX(IidToIidIdx(riid));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::AddIIDRequest
//
//  Synopsis:   adds the refiid to the request list
//
//  Arguments:  [riid] -- Interface
//
//  Returns:    true on success
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
BOOL CThkMgr::AddIIDRequest(REFIID riid)
{
    PIIDNODE piidnode = _piidnode;

    thkAssert(!IsIIDSupported(riid));

    // create a new node and add at front
    piidnode = (PIIDNODE)flRequestFreeList.AllocElement();
    if (piidnode == NULL)
    {
        return FALSE;
    }

    piidnode->pNextNode = _piidnode;
    _piidnode = piidnode;

    // IID requests are only valid for the lifetime of the call that
    // requested a custom interface, so there's no need to copy
    // the IID's memory since it must remain valid for the same time
    // period
    piidnode->piid = (IID *)&riid;

    thkDebugOut((DEB_THUNKMGR, "AddIIDRequest(%s)\n", GuidString(&riid)));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::RemoveIIDRequest
//
//  Synopsis:   removes a request for the request list
//
//  Arguments:  [riid] -- Interface
//
//  Returns:    true on success
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void CThkMgr::RemoveIIDRequest(REFIID riid)
{
    PIIDNODE piidnode;
    PIIDNODE pinPrev;

    thkAssert(!IsIIDSupported(riid));

    pinPrev = NULL;
    piidnode = _piidnode;
    while (piidnode)
    {
        if (*piidnode->piid == riid)
        {
            break;
        }

        pinPrev = piidnode;
        piidnode = piidnode->pNextNode;
    }

    thkAssert(piidnode != NULL && "RemoveIIDRequest: IID not found");

    thkDebugOut((DEB_THUNKMGR, "RemoveIIDRequest(%s)\n", GuidString(&riid)));

    if (pinPrev == NULL)
    {
        _piidnode = piidnode->pNextNode;
    }
    else
    {
        pinPrev->pNextNode = piidnode->pNextNode;
    }

    flRequestFreeList.FreeElement((DWORD)piidnode);
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CanGetNewProxy1632
//
//  Synopsis:   Preallocates proxy memory
//
//  Arguments:  [iidx] - Custom interface or known index
//
//  Returns:    vpv pointer if proxy is available, fails otherwise
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
VPVOID CThkMgr::CanGetNewProxy1632(IIDIDX iidx)
{
    VPVOID vpv;
    THUNK1632OBJ UNALIGNED *pto;

    thkDebugOut((DEB_THUNKMGR, "%sIn  CanGetNewProxy1632(%s)\n",
                 NestingLevelString(), IidIdxString(iidx)));

    // Allocate proxy memory
    vpv = (VPVOID)flFreeList16.AllocElement();

    if (vpv == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: Failed to allocate memory "
                     "for 16-bit proxies\n"));
        goto Exit;
    }

    // Add custom interface request if necessary
    if (vpv && IIDIDX_IS_IID(iidx))
    {
        // add the request for the unknown interface
        if ( !AddIIDRequest(*IIDIDX_IID(iidx)) )
        {
            flFreeList16.FreeElement( (DWORD)vpv );
            vpv = 0;
        }
    }

    // Set up the preallocated proxy as a temporary proxy so that
    // we can hand it out for nested callbacks
    pto = FIXVDMPTR(vpv, THUNK1632OBJ);
    thkAssert(pto != NULL);

    pto->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
    pto->cRefLocal = 0;
    pto->cRef = 0;
    pto->iidx = iidx;
    pto->punkThis32 = NULL;
    pto->pphHolder = NULL;
    PprxNull(pto->pprxObject);
    pto->grfFlags = PROXYFLAG_TEMPORARY;
#if DBG == 1
    // Deliberately make this an invalid proxy.  We want it to be used
    // in as few places as possible
    pto->dwSignature = PSIG1632TEMP;
#endif

    RELVDMPTR(vpv);

 Exit:
    thkDebugOut((DEB_THUNKMGR, "%sOut CanGetNewProxy1632: %p\n",
                 NestingLevelString(), vpv));

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FreeNewProxy1632
//
//  Synopsis:   frees unused preallocated proxies
//
//  Arguments:  [iidx] - Custom interface or known index
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void CThkMgr::FreeNewProxy1632(VPVOID vpv, IIDIDX iidx)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn FreeNewProxy1632(%s)\n",
                 NestingLevelString(), IidIdxString(iidx)));

    thkAssert(vpv != 0);

    if (IIDIDX_IS_IID(iidx))
    {
        // remove the request for the unknown interface
        RemoveIIDRequest(*IIDIDX_IID(iidx));
    }

#if DBG == 1
    // Ensure that we're not getting rid of a temporary proxy that's
    // in use
    THUNK1632OBJ UNALIGNED *pto;

    pto = FIXVDMPTR(vpv, THUNK1632OBJ);
    if (pto->grfFlags & PROXYFLAG_TEMPORARY)
    {
        thkAssert(pto->cRefLocal == 0 && pto->cRef == 0);
    }
    RELVDMPTR(vpv);
#endif

    // add element to free list
    flFreeList16.FreeElement( (DWORD)vpv );

    thkDebugOut((DEB_THUNKMGR, "%sOut FreeNewProxy1632\n",
                 NestingLevelString()));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsProxy1632
//
//  Synopsis:   checks if given object is an 16/32 object
//
//  Arguments:  [vpvObj16] -- Object to check
//
//  Returns:    32-bit interface being proxied or NULL
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
IUnknown *CThkMgr::IsProxy1632(VPVOID vpvThis16)
{
    // Local variables
    THUNK1632OBJ UNALIGNED *ptoThis16;
    IUnknown *punkThis32 = NULL;
    THUNKINFO ti;

    // Check if the pointer points to valid VDM memory of
    // 1632 proxy type
    ptoThis16 = (THUNK1632OBJ UNALIGNED *) GetReadPtr16(&ti, vpvThis16, sizeof(THUNK1632OBJ));
    if(ptoThis16) {
        // Check its vtable
        if(ptoThis16->pfnVtbl == gdata16Data.atfnProxy1632Vtbl) {
            // Check whether it is alive
            if(ptoThis16->pphHolder) {
                // Assert that the proxy is indeed alive
                thkAssert(ptoThis16->dwSignature == PSIG1632);

#if DBG==1
                // In debug builds, ensure that proxy is under its holder
                // and that there is atleast one active proxy under the holder
                BOOL fFound = FALSE, fActive = FALSE;
                CProxy *pProxy;
                PROXYPTR PrxCur, PrxPrev;

	        PrxCur = ptoThis16->pphHolder->pprxProxies;
                while(!(fFound && fActive) && !PprxIsNull(PrxCur)) {
	            // Remember the current proxy and resolve its reference
                    PrxPrev = PrxCur;
                    pProxy = ResolvePprx(&PrxCur);

                    // Assert that the holders match
                    thkAssert(ptoThis16->pphHolder == pProxy->pphHolder);

                    if(PrxCur.wType == PPRX_16) {
                        // Assert that the current 1632 proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG1632);

                        // Check if the given and current proxies are same
                        if(PrxCur.dwPtrVal == vpvThis16)
                            fFound = TRUE;
                    }
                    else {
                        // Assert that the current proxy is 3216 proxy
                        thkAssert(PrxCur.wType == PPRX_32);

                        // Assert that the current proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG3216);
                    }

                    // Check if the current proxy is active
                    if(pProxy->cRefLocal)
                        fActive = TRUE;

                    // Obtain the next proxy under this identity
                    PrxCur = pProxy->pprxObject;
                    ReleasePprx(&PrxPrev);
                }

                thkAssert(fFound && fActive);
#endif
                // Initialize the return value
                punkThis32 = ptoThis16->punkThis32;
            }
        }

        // Release the VDM pointer
        RELVDMPTR(vpvThis16);
    }

    return punkThis32;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindProxy1632
//
//  Synopsis:   Finds/Generates a 16/32 proxy for a given 32-bit interface.
//              If the given 32-bit interface itself is a proxy, returns
//              the actual 16-bit Interface
//
//  Arguments:  [vpvPrealloc] -- Preallocated 16/32 proxy
//              [punkThis32]  -- 32-bit Interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    16/32 proxy object or the actual 16-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
VPVOID CThkMgr::FindProxy1632(VPVOID vpvPrealloc, IUnknown *punkThis32,
                              PROXYHOLDER *pgHolder, IIDIDX iidx, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindProxy1632(%p, %p, %s)\n",
                 NestingLevelString(), vpvPrealloc, punkThis32, IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *pto;
    VPVOID vpv, vpvUnk = NULL;
    DWORD fst, Fail = FALSE;

    // Validation checks
    thkAssert(punkThis32 != NULL);
#if DBG == 1
    // Ensure that the preallocated proxy is not in use
    if (vpvPrealloc) {
        pto = FIXVDMPTR(vpvPrealloc, THUNK1632OBJ);
        if(pto->grfFlags & PROXYFLAG_TEMPORARY)
            thkAssert(pto->cRefLocal == 0 && pto->cRef == 0);
        RELVDMPTR(vpvPrealloc);
    }
#endif

    // Initialize return value
    fst = FST_ERROR;

    // If proxy was preallocated for this IID using CanGetNewProxy, it would
    // have added it to the requested IID list.
    if (vpvPrealloc != 0 && IIDIDX_IS_IID(iidx))
        RemoveIIDRequest(*IIDIDX_IID(iidx));

    if(vpv = LookupProxy1632(punkThis32)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy1632 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), punkThis32, vpv));

        // Fix the VDM pointer
        pto = FIXVDMPTR(vpv, THUNK1632OBJ);

        // Assert that holders match
        thkAssert(pto->pphHolder);
        if(pgHolder && pto->pphHolder!=pgHolder) {
            thkAssert(pto->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Check the proxy IID against the given IID. If the server has passed
        // the same 32-bit interface pointer against another IID, it is possible
        // for the IID's to be different. If the Interface2 derives from Interface1,
        // the interface pointers for them would be the same in C or C++. An
        // excellant example would be IPersistStorage deriving from IPersist.

        // IIDIDXs are related to interfaces in thunk tables, which are organized
        // such that more derived interfaces have higher indices than the less
        // derived ones. Custom interfaces have an IID rather than an index, and
        // consequently are not affected by the following statement.
        if(IIDIDX_IS_INDEX(iidx)) {
            // Check if the new IID is more derived than the existing one
            if(IIDIDX_INDEX(iidx) > IIDIDX_INDEX(pto->iidx)) {
                // As all 16-bit proxy vtables are the same, there is no need
                // to change  the vtable pointer.
                pto->iidx = iidx;
            }
        }

        // Release the VDM pointer
        RELVDMPTR(vpv);

        // AddRef the proxy
        AddRefProxy1632(vpv);

        // Set the type of proxy being returned
        fst = FST_USED_EXISTING;
    }
    else if(vpv = IsProxy3216(punkThis32)) {
        // The given 32-bit interface itself is a proxy to a 16-bit
        // interface
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy1632 shortcut proxy,(%p)->%p\n",
                     NestingLevelString(), punkThis32, vpv));
        THUNK3216OBJ *pProxy3216;

        // Assert that the holders match
        pProxy3216 = (THUNK3216OBJ *) punkThis32;
        thkAssert(pProxy3216->pphHolder);
        if(pgHolder && pProxy3216->pphHolder!=pgHolder) {
            thkAssert(pProxy3216->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Avoid creating a proxy to another proxy
        THKSTATE thkstate;

        // Remember the current thunk state
        thkstate = GetThkState();

        // Set the thunk state to THKSTATE_NOCALL
        SetThkState(THKSTATE_NOCALL);

        // AddRef actual the 16-bit interface
        AddRefOnObj16(vpv);

        // Restore previous thunk state
        SetThkState(thkstate);

        // Set the type of proxy being returned
        fst = FST_SHORTCUT;
    }
    else {
        // An existing proxy has not been found and the interface to proxied
        // is a real 32-bit interface.

        // Check if holder has not been given
        if(!pgHolder) {
            // This interface is being obtained through a method call
            PROXYPTR unkPPtr;
            SCODE error;

            // Obtain the identity of 32-bit object
            error = Object32Identity(punkThis32, &unkPPtr, &fst);
            if(error == NOERROR) {
                // Check for aggregation case
                if(unkPPtr.wType == PPRX_16) {
                    // Check if vpvThis32 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // Initialize the return value
                        vpv = unkPPtr.dwPtrVal;

                        // Check if the identity has been switched
                        if(fst == FST_USED_EXISTING) {
                            // The IUnknown identity has already been established
                            // The app was trying to pass someother 32-bit interface
                            // as IUnknown. Switch to correct identity
                            thkAssert(!"Switched to correct Identity");

                            // AddRef the proxy being returned
                            AddRefProxy1632(vpv);
                        }
                        else {
                            thkAssert(fst==FST_CREATED_NEW);
                        }
                    }
                    else {
                        THUNK1632OBJ UNALIGNED *Id1632;

                        // Fix the VDM pointer
                        Id1632 = FIXVDMPTR(unkPPtr.dwPtrVal, THUNK1632OBJ);

                        // Check if the identity has just been established
                        if(fst == FST_CREATED_NEW) {
                            // Check if the Identity and current IID share the same
                            // 32-bit interface pointer
                            if(Id1632->punkThis32 == punkThis32) {
                                // Check if the new IID is more derived than
                                // the existing one
                                if(IIDIDX_IS_INDEX(iidx) && iidx>Id1632->iidx) {
                                    // As all 16-bit proxy vtables are the same,
                                    // there is no need to change the vtable pointer
                                    Id1632->iidx = iidx;
                                }

                                // Initialize the return value
                                vpv = unkPPtr.dwPtrVal;
                            }
                            else {
                                // We need to release the IUnknown proxy after adding
                                // the proxy representing vpvThis16 to the its holder
                                vpvUnk = unkPPtr.dwPtrVal;
                            }
                        }
                        else {
                            thkAssert(fst == FST_USED_EXISTING);
                        }

                        // Obtain the holder of the identity
                        pgHolder = Id1632->pphHolder;

                        // Release the VDM pointer
                        RELVDMPTR(unkPPtr.dwPtrVal);
                    }
                }
                else {
                    // Obtain the holder of the identity
                    pgHolder = ((THUNK3216OBJ *)(unkPPtr.dwPtrVal))->pphHolder;

                    // Sanity checks
                    thkAssert(fst == FST_USED_EXISTING);
                    thkAssert(pgHolder->dwFlags & PH_AGGREGATEE);

                    // Check if vpvThis32 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // The IUnknown identity has already been established
                        // The app was trying to pass someother 32-bit interface
                        // as IUnknown. Switch to correct identity
                        thkAssert(!"Switched to correct Identity");

                        // Initialize the return value
                        vpv = ((THUNK3216OBJ *)(unkPPtr.dwPtrVal))->vpvThis16;

                        // AddRef the actual 16-bit interface being returned
                        AddRefOnObj16(vpv);
                    }
                }
            }
            else {
                // Failed to obtain the identity
                Fail = TRUE;
            }
        }
    }

    if(!vpv && !Fail) {
        // Assert that we have holder
        thkAssert(pgHolder);
        // Reset the fst value
        fst = FST_ERROR;

        // Obtain either a preallocated or a new proxy
        if(vpvPrealloc) {
            // Use the preallocated proxy
            vpv = vpvPrealloc;
            vpvPrealloc = NULL;
        }
        else {
            // Create a new proxy
            vpv = flFreeList16.AllocElement();
	}

        // Ensure that we have a proxy
        if(vpv) {
            // Put the new proxy in the proxy list
            if(_pProxyTbl1632->SetAt((DWORD)punkThis32, (void *)vpv)) {
                // Convert a custom IID to THI_IUnknown as we thunk only its IUnknown
                // methods
                if(IIDIDX_IS_IID(iidx))
                    iidx = INDEX_IIDIDX(THI_IUnknown);

                // AddRef the 32-bit interface
                punkThis32->AddRef();

                // Update proxy fields
                pto = FIXVDMPTR(vpv, THUNK1632OBJ);
                thkAssert(pto != NULL);
                pto->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
                pto->cRefLocal = 1;
                pto->cRef = 1;
                pto->iidx = iidx;
                pto->punkThis32 = punkThis32;
                pto->grfFlags = PROXYFLAG_PIFACE;
                PprxNull(pto->pprxObject);
                pto->pphHolder = NULL;
                AddProxyToHolder(pgHolder, pto, Pprx16(vpv));
#if DBG == 1
                pto->dwSignature = PSIG1632;
#endif
                thkDebugOut((DEB_THUNKMGR,
                             "%sFindProxy1632 added new proxy, %s (%p)->%p (%d,%d)\n",
                             NestingLevelString(), inInterfaceNames[pto->iidx].pszInterface,
                             punkThis32, vpv, pto->cRefLocal, pto->cRef));
                RELVDMPTR(vpv);

                // Set the type of proxy being returned
                fst = FST_CREATED_NEW;
            }
            else {
                // Cleanup the proxy only if was newly created
                if(fst == FST_CREATED_NEW)
                    flFreeList16.FreeElement(vpv);
                vpv = NULL;
                fst = 0;
            }
        }
    }
    else {
        if(Fail) {
            thkAssert(vpv == 0 && fst == FST_ERROR);
        }
    }

    // Cleanup the allocated proxy if it has not been used
    if(vpvPrealloc)
        flFreeList16.FreeElement(vpvPrealloc);

    // Release the IUnknown proxy. If it was newly created for establishing
    // the identity of the given 16-bit interface , the following release
    // would be the last release on the IUnknown proxy and consequently,
    // would destroy it along with its holder
    if(vpvUnk)
        ReleaseProxy1632(vpvUnk);

    // Set the return value
    if(pfst)
        *pfst = fst;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindProxy1632: (%p)->%p\n",
                 NestingLevelString(), punkThis32, vpv));

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::QueryInterfaceProxy1632
//
//  Synopsis:   QueryInterface on the  given proxy
//
//  Arguments:  [ptoThis] -- Proxy to a 32-bit interface
//              [refiid]  -- Interface IID
//              [ppv]     -- Place where the new interface is returned
//
//  Returns:    SCODE
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::QueryInterfaceProxy1632(VPVOID vpvThis16, REFIID refiid,
                                       LPVOID *ppv)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn QueryInterfaceProxy1632(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    // Local variables
    SCODE scRet = S_OK;
    THUNK1632OBJ UNALIGNED *ptoThis;
    IUnknown *punkThis, *punkNew;
    PROXYHOLDER *pph;
    VPVOID vpv;
    DWORD fst, dwFlags;

    // Validation checks
    DebugValidateProxy1632(vpvThis16);

    // Initialize
    *ppv = NULL;

    // Perform app compatiblity hacks
    // Ikitaro queries for IViewObject and uses it as IViewObject2
    REFIID newiid = ((TlsThkGetAppCompatFlags() & OACF_IVIEWOBJECT2) &&
                     IsEqualIID(refiid, IID_IViewObject)) ?
                     IID_IViewObject2 : refiid;

    // Convert interface IID to an IIDIDX
    IIDIDX iidx = IidToIidIdx(newiid);

    // Check if a custom interface has been requested
    if(IIDIDX_IS_IID(iidx)) {
        thkDebugOut((DEB_THUNKMGR, "%sQueryInterfaceProxy1632: unknown iid %s\n",
                     NestingLevelString(), IidIdxString(iidx)));

        // Add the request for the unknown interface
        if(!AddIIDRequest(newiid))
            return E_OUTOFMEMORY;
    }

    // Obtain the 32-bit interface
    ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
    dwFlags = ptoThis->grfFlags;
    pph = ptoThis->pphHolder;
    if(dwFlags & PROXYFLAG_TEMPORARY) {
        // QI on a temporary proxy
        punkThis = *(IUnknown **) ptoThis->punkThis32;
        thkAssert(!pph);
    }
    else {
        // QI on a normal proxy
        punkThis = ptoThis->punkThis32;
        Win4Assert(pph);
    }
    thkAssert(punkThis);
    RELVDMPTR(vpvThis16);

    // Ensure that the aggregatee identity gets correctly established
    if(dwFlags & PROXYFLAG_PUNKOUTER && iidx == THI_IUnknown) {
        // QI by the aggregatee for identity
        thkAssert(pph->unkProxy.dwPtrVal == vpvThis16);

        // AddRef and return outer proxy
        AddRefProxy1632(vpvThis16);
        *ppv = (void *) vpvThis16;
    }
    else {
        // Execute the QI on the 32-bit interface
        scRet = punkThis->QueryInterface(newiid, (void **) &punkNew);
        if(SUCCEEDED(scRet)) {
            if(punkNew) {

                // Check if this is a QI on an interface on the aggregatee
                if(pph && (pph->dwFlags & PH_AGGREGATEE)) {
                    if(dwFlags & PROXYFLAG_PIFACE) {
                        // QI on an interface on the aggregatee which
                        // delegates to the aggregator

                        // Note the above QI call can be short circuited as
                        // an optimization. It will be carried out in future
                        // after ensuring that apps do not break due to such
                        // short circuiting
                        thkAssert(pph->unkProxy.wType == PPRX_32);
                    }
                    else if(dwFlags & PROXYFLAG_PUNKOUTER) {
                        // QI by the aggregatee on aggregator
                        thkAssert(pph->unkProxy.dwPtrVal == vpvThis16);
                    }
                    else {
                        // QI by the aggregator on the aggregatee
                        thkAssert(dwFlags & PROXYFLAG_PUNKINNER);
                        thkAssert(pph->unkProxy.wType == PPRX_32);
                    }

                    // As aggregation is involved, we cannot be certain of
                    // identity of the returned interface
                    pph = NULL;
                }

                // Set the thunk status
                SetThkState(THKSTATE_INVOKETHKOUT32);

                vpv = FindProxy1632(NULL, punkNew, pph, iidx, &fst);

                if(vpv) {
                    // Set the return value
                    *ppv = (void *)vpv;
#if DBG==1
                    if(pph) {
                        // Ensure that the given and new proxies either have the same
                        // holder or point to same identity
                        if(fst & FST_PROXY_STATUS) {
                            THUNK1632OBJ UNALIGNED *ptoNew;

                            ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
                            ptoNew = FIXVDMPTR(vpv, THUNK1632OBJ);
                            thkAssert(ptoNew->pphHolder == ptoThis->pphHolder);
                            RELVDMPTR(vpvThis16);
                            RELVDMPTR(vpv);
                        }
                        else {
                            THUNK3216OBJ *ptoNew = (THUNK3216OBJ *) punkNew;

                            ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
                            thkAssert(fst == FST_SHORTCUT);
                            thkAssert(ptoNew->pphHolder != ptoThis->pphHolder);
                            thkAssert(ptoNew->pphHolder->dwFlags & PH_AGGREGATEE);
                            thkAssert(ptoNew->pphHolder->unkProxy.wType == PPRX_16);
                            RELVDMPTR(vpvThis16);
                        }
                    }
#endif

                    // Check for 32-bit custom interfaces that are not supported
                    if((fst & FST_PROXY_STATUS) && IIDIDX_IS_IID(iidx)) {
                        // Release proxy and fake E_NOINTERFACE
                        ReleaseProxy1632(vpv);
                        scRet = E_NOINTERFACE;
                    }
                }
                else {
                    scRet = E_OUTOFMEMORY;
                }

                // As the new interface is an OUT parameter, release the actual
                // 32-bit interface. This would counter the AddRef made by
                // a successfule FindProxy3216, else it would clean up the
                // reference count
                punkNew->Release();

                // Resert thunk status
                SetThkState(THKSTATE_NOCALL);
            }
            else {
                // Corel draw returns NOERROR while setting returned interface to NULL
                // We modify the returned value to suit 32-bit QI semantics.
                scRet = E_NOINTERFACE;
            }
        }
    }

    if(IIDIDX_IS_IID(iidx)) {
        // Clean up custom interface request
        RemoveIIDRequest(refiid);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut QueryInterfaceProxy1632(%p) => %p, 0x%08lX\n",
                 NestingLevelString(), ptoThis, *ppv, scRet));

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::LockProxy, public
//
//  Synopsis:   Locks a proxy so that it can't be freed
//
//  Arguments:  [pprx] - Proxy
//
//  History:    11-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CThkMgr::LockProxy(CProxy *pprx)
{
    pprx->grfFlags |= PROXYFLAG_LOCKED;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::TransferLocalRefs1632
//
//  Synopsis:   Transfer the all local references maintained by the proxy
//              to the actual object
//
//  Arguments:  [vpvProxy] -- 16/32 proxy
//
//  Returns:    refcount
//
//  History:    Mar 12,96   Gopalk         Created
//
//----------------------------------------------------------------------------
DWORD CThkMgr::TransferLocalRefs1632(VPVOID vpvProxy)
{
    // Debug output
    thkDebugOut((DEB_THUNKMGR, "%sIn TransferLocalRefs1632(%p)\n",
                 NestingLevelString(), vpvProxy));
    DebugIncrementNestingLevel();

    // Validation check
    DebugValidateProxy1632(vpvProxy);

    // Local variables
    THUNK1632OBJ UNALIGNED *pProxy1632;
    IUnknown *pUnk32;
    DWORD cRef;

    // Fix memory pointed to by 16:16 pointer
    pProxy1632 = FIXVDMPTR(vpvProxy, THUNK1632OBJ);
    pUnk32 = pProxy1632->punkThis32;

    // Transfer all local references maintained by the proxy
    while(pProxy1632->cRefLocal > pProxy1632->cRef) {
        // Increment actual ref count before AddRef on the actual object
        ++pProxy1632->cRef;

        // The following AddRef could cause callbacks to 16-bit world
        // and hence unfix the memory pointed to by 16:16 pointer
        RELVDMPTR(vpvProxy);

        // AddRef the actual object
        pUnk32->AddRef();

        // Refix memory pointed to by 16:16 pointer
        pProxy1632 = FIXVDMPTR(vpvProxy, THUNK1632OBJ);
    }

    // Debug output
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut TransferLocalRefs1632(%p)(%ld,%ld)\n",
                 NestingLevelString(), vpvProxy, pProxy1632->cRefLocal,
                 pProxy1632->cRef));

    // Cleanup
    cRef = pProxy1632->cRefLocal;
    RELVDMPTR(vpvProxy);

    // Debug validation
    DebugValidateProxy1632(vpvProxy);
    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::TransferLocalRefs3216
//
//  Synopsis:   Transfer the all local references maintained by the proxy
//              to the actual object
//
//  Arguments:  [vpvProxy1632] -- 16/32 proxy
//
//  Returns:    refcount
//
//  History:    Mar 12,96   Gopalk         Created
//
//----------------------------------------------------------------------------
DWORD CThkMgr::TransferLocalRefs3216(VPVOID vpvProxy)
{
    // Debug output
    thkDebugOut((DEB_THUNKMGR, "%sIn TransferLocalRefs3216(%p)\n",
                 NestingLevelString(), vpvProxy));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK3216OBJ *pProxy3216 = (THUNK3216OBJ *) vpvProxy;
    DWORD cRef;

    // Validation check
    DebugValidateProxy3216(pProxy3216);

    // Transfer all local references maintained by the proxy
    while(pProxy3216->cRefLocal > pProxy3216->cRef) {
        // Increment actual ref count before AddRef on the actual object
        ++pProxy3216->cRef;

        // AddRef the actual object
        AddRefOnObj16(pProxy3216->vpvThis16);
    }

    // Validation check
    DebugValidateProxy3216(pProxy3216);

    // Initialize return value
    cRef = pProxy3216->cRefLocal;

    // Debug output
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut TransferLocalRefs3216(%p)(%ld,%ld)\n",
                 NestingLevelString(), vpvProxy, pProxy3216->cRefLocal,
                 pProxy3216->cRef));
    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::AddRefProxy1632
//
//  Synopsis:   addrefs proxy object - delegate call on to real object
//
//  Arguments:  [vpvThis16] -- 16/32 proxy
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes: cRef is the addref passed on to the real object
//         cRefLocal is the addref collected locally
//----------------------------------------------------------------------------
DWORD CThkMgr::AddRefProxy1632(VPVOID vpvThis16)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn AddRefProxy1632(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    // Local variable
    THUNK1632OBJ UNALIGNED *ptoThis;
    DWORD cRef;

    // Validation checks
    DebugValidateProxy1632(vpvThis16);

    // Fix the VDM pointer
    ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
    // Assert that proxy has a holder
    thkAssert(ptoThis->pphHolder);

    // Increment local refcount
    thkAssert(ptoThis->cRefLocal >= 0);
    ptoThis->cRefLocal++;

    // Check for the need to AddRef the holder
    if(ptoThis->cRefLocal == 1) {
        // Assert that an aggregatee is not being revived
        thkAssert(!(ptoThis->grfFlags & PROXYFLAG_PUNKINNER));

        // AddRef the holder
        AddRefHolder(ptoThis->pphHolder);

        // Mark the proxy as revived
        ptoThis->grfFlags |= PROXYFLAG_REVIVED;
    }

    // Check for the need to forward AddRef to the actual 32-bit interface
    if(ptoThis->cRefLocal==1 || (ptoThis->pphHolder->dwFlags & PH_AGGREGATEE)) {
        IUnknown *punk;
#if DBG==1
        DWORD refsBefore, refsAfter;
        PROXYHOLDER *pph;
        THUNK3216OBJ *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 16-bit world
            thkAssert(pph->unkProxy.wType == PPRX_32);

            // Obtain the references on the outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
        }
#endif

        // Increment before calling the actual 32-bit interface
        ptoThis->cRef++;

        // Release VDM pointer before calling app code
        punk = ptoThis->punkThis32;
        RELVDMPTR(vpvThis16);

        // AddRef the actual 32-bit interface
        punk->AddRef();

        // Refix the VDM pointer
        ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above AddRef translated to a AddRef on the
            // outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter-1);
        }
#endif
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut AddRefProxy1632(%p), (%ld,%ld)\n",
                 NestingLevelString(), vpvThis16,
                 ptoThis->cRefLocal, ptoThis->cRef));

    cRef = ptoThis->cRefLocal;
    RELVDMPTR(vpvThis16);
    DebugValidateProxy1632(vpvThis16);

    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::ReleaseProxy1632
//
//  Synopsis:   release on 16/32 proxy - delegate call on to real object
//
//  Arguments:  [vpvThis16] -- proxy
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
DWORD CThkMgr::ReleaseProxy1632(VPVOID vpvThis16)
{

    thkDebugOut((DEB_THUNKMGR, "%sIn ReleaseProxy1632(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *ptoThis;
    DWORD dwLocalRefs, dwRefs, dwRet;
    PROXYHOLDER *pph;
    DWORD ProxyType;

    // Validation checks
    DebugValidateProxy1632(vpvThis16);

    // Fix the VDM pointer
    ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
    // Assert that proxy has a holder
    thkAssert(ptoThis->pphHolder);

    // Check for the need to forward the release to the actual
    // 32-bit interface
    if(ptoThis->cRef == ptoThis->cRefLocal) {
        IUnknown *punk;
#if DBG==1
        DWORD refsBefore, refsAfter;
        THUNK3216OBJ *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 16-bit world
            thkAssert(pph->unkProxy.wType == PPRX_32);

            // Obtain the references on the outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
        }
#endif

        // Assert that proxy holds references on the 32-bit interface
        thkAssert(ptoThis->cRef);

        // Release the VDM pointer before calling app code
        punk = ptoThis->punkThis32;
        RELVDMPTR(vpvThis16);

        // Release the actual 32-bit interface
        dwRet = punk->Release();

#if DBG==1
        if(dwRet==0 && TlsThkGetThkMgr()->GetThkState()==THKSTATE_VERIFY32INPARAM) {
            thkDebugOut((DEB_WARN, "WARINING: 32-bit 0x%x IN parameter with zero "
                                   "ref count\n", punk));

            if(thkInfoLevel & DEB_FAILURES)
                thkAssert(!"Wish to Debug");
        }
#endif

        // Refix the VDM pointer
	ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);

        // Decrement after calling the actual 32-bit interface
        --ptoThis->cRef;

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above release translated to a release on the
            // outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter+1);
        }
#endif
    }

    // Decrement the local refcount
    dwLocalRefs = --ptoThis->cRefLocal;
    thkAssert(ptoThis->cRefLocal>=0);
    dwRefs = ptoThis->cRef;
    pph = ptoThis->pphHolder;
    ProxyType = ptoThis->grfFlags & PROXYFLAG_TYPE;

    // Release the VDM pointer
    RELVDMPTR(vpvThis16);

    // Check if the proxy needs to be cleaned up
    if(dwLocalRefs == 0) {
        // Debug dump
        thkAssert(dwRefs == 0);
        DBG_DUMP(DebugDump1632());

        // Release the holder. If this is the last release on
        // the holder, the proxy would be destroyed. Hence,
        // we should not use any member variables hereafter.
        ReleaseHolder(pph, ProxyType);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut ReleaseProxy1632(%p) => %ld,%ld\n",
                 NestingLevelString(), vpvThis16, dwLocalRefs, dwRefs));

    return dwLocalRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::RemoveProxy1632, public
//
//  Synopsis:   Destroys the given proxy
//
//  Arguments:  [vpv] - 16-bit proxy pointer
//              [pto] - Flat proxy pointer
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes:      Also unfixes VDM pointer passed
//
//----------------------------------------------------------------------------
void CThkMgr::RemoveProxy1632(VPVOID vpv, THUNK1632OBJ *pto)
{
    // Revoke the assosiation between the proxy and
    // the 32-bit interface
    if(!(pto->grfFlags & PROXYFLAG_PUNKOUTER)) {
#if DBG==1
        thkAssert(_pProxyTbl1632->RemoveKey((DWORD) pto->punkThis32));
#else
        _pProxyTbl1632->RemoveKey((DWORD) pto->punkThis32);
#endif
    }

    // Release the holder if needed
    if(pto->cRefLocal)
        ReleaseHolder(pto->pphHolder, PROXYFLAG_NONE);

    // Check if the proxy is locked
    if(!(pto->grfFlags & PROXYFLAG_LOCKED)) {
        // In debug builds, mark the proxy dead
#if DBG == 1
        pto->dwSignature = PSIG1632DEAD;

        // Return the proxy to free list
        if (!fSaveProxy)
#endif
        {
            thkAssert(pto->pphHolder);
            pto->pphHolder = NULL;
            flFreeList16.FreeElement((DWORD)vpv);
        }
    }

    // Release the VDM pointer
    RELVDMPTR(vpv);

    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CanGetNewProxy3216
//
//  Synopsis:   checks if new proxy is available
//
//  Arguments:  [iidx] - Custom interface or known index
//
//  Returns:    Preallocated proxy or NULL
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
THUNK3216OBJ *CThkMgr::CanGetNewProxy3216(IIDIDX iidx)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn CanGetNewProxy3216(%s)\n",
                 NestingLevelString(), IidIdxString(iidx)));

    LPVOID pvoid;

    pvoid = (LPVOID)flFreeList32.AllocElement();
    if ( pvoid == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: CThkMgr::CanGetNewProxy3216, "
                     "AllocElement failed\n"));
        return NULL;
    }

    // check if the proxy is requested for a no-thop-interface
    if (pvoid && IIDIDX_IS_IID(iidx))
    {
        // add the request for the unknown interface
        if ( !AddIIDRequest(*IIDIDX_IID(iidx)) )
        {
            flFreeList32.FreeElement( (DWORD)pvoid );
            pvoid = NULL;
        }
    }

    thkDebugOut((DEB_THUNKMGR, "%sOut CanGetNewProxy3216: %p \n",
                 NestingLevelString(), pvoid));

    return (THUNK3216OBJ *)pvoid;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FreeNewProxy3216
//
//  Synopsis:   frees previous reserved proxy
//
//  Arguments:  [pto] - Proxy
//              [iidx] - Custom interface or known index
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void CThkMgr::FreeNewProxy3216(THUNK3216OBJ *pto, IIDIDX iidx)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn FreeNewProxy3216(%p, %s)\n",
                 NestingLevelString(), pto, IidIdxString(iidx)));

    thkAssert(pto != NULL);

    if (IIDIDX_IS_IID(iidx))
    {
        // add the request for the unknown interface
        RemoveIIDRequest(*IIDIDX_IID(iidx));
    }

    thkAssert(pto != NULL);
    flFreeList32.FreeElement( (DWORD)pto );

    thkDebugOut((DEB_THUNKMGR, "%sOut FreeNewProxy3216\n",
                 NestingLevelString()));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsProxy3216
//
//  Synopsis:   checks if the given object is a 32/16 proxy
//
//  Arguments:  [punk] -- punk of 32 bit object
//
//  Returns:    16-bit interface being proxied or NULL
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
VPVOID CThkMgr::IsProxy3216(IUnknown *punkThis32)
{
    // Local variables
    THUNK3216OBJ *ptoThis32;
    VPVOID vpvThis16 = NULL;

    // Check if the pointer points to valid memory of 3216 proxy type
    if(!IsBadWritePtr(punkThis32, sizeof(THUNK3216OBJ))) {
        ptoThis32 = (THUNK3216OBJ *) punkThis32;
        // Check its vtable
        if(*((void **)ptoThis32->pfnVtbl) == ::QueryInterfaceProxy3216 &&
           *((void **)ptoThis32->pfnVtbl + 1) == ::AddRefProxy3216 &&
           *((void **)ptoThis32->pfnVtbl + 2) == ::ReleaseProxy3216) {
            // Check whether it is alive
            if(ptoThis32->pphHolder) {
                // Assert that the given proxy is indeed alive
                thkAssert(ptoThis32->dwSignature == PSIG3216);

#if DBG==1
                // In debug builds, ensure that proxy is under its holder
                // and that there is atleast one active proxy under the holder
                BOOL fFound = FALSE, fActive = FALSE;
                CProxy *pProxy;
                PROXYPTR PrxCur, PrxPrev;

	        PrxCur = ptoThis32->pphHolder->pprxProxies;
                while(!(fFound && fActive) && !PprxIsNull(PrxCur)) {
	            // Remember the proxy and resolve its reference
                    PrxPrev = PrxCur;
                    pProxy = ResolvePprx(&PrxCur);

                    // Assert that the holders match
                    thkAssert(ptoThis32->pphHolder == pProxy->pphHolder);

                    if(PrxCur.wType == PPRX_32) {
                        // Assert that the current 3216 proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG3216);

                        // Check if the given and current proxies are same
                        if(PrxCur.dwPtrVal == (DWORD) punkThis32)
                            fFound = TRUE;
                    }
                    else {
                        // Assert that the current proxy is 1632 proxy
                        thkAssert(PrxCur.wType == PPRX_16);

                        // Assert that the current proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG1632);
                    }

                    // Check if the current proxy is active
                    if(pProxy->cRefLocal)
                        fActive = TRUE;

                    // Obtain the next proxy under this identity
                    PrxCur = pProxy->pprxObject;
                    ReleasePprx(&PrxPrev);
                }

                thkAssert(fFound && fActive);
#endif
                // Initialize the return value
                vpvThis16 = ptoThis32->vpvThis16;
            }
        }
    }

    return vpvThis16;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CreateOuter32
//
//  Synopsis:   Generates a new 3216 proxy for a given 16-bit outer IUnknown
//              If the given 16-bit IUnknown itself is a proxy, returns
//              the actual 32-bit interface
//
//  Arguments:  [vpvOuter16] -- Outer IUnknown
//              [ppAggHolder] -- Pointer to the proxy holder returned here
//              [pfst]       -- Proxy type is returned here
//
//  Returns:    3216 proxy or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation
//              Feb 11, 98  MPrabhu     Change to pass back pUnkOuter's holder
//
//----------------------------------------------------------------------------
IUnknown *CThkMgr::CreateOuter32(VPVOID vpvOuter16, PROXYHOLDER **ppAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  CreateOuter32(%p)\n",
                 NestingLevelString(), vpvOuter16));
    DebugIncrementNestingLevel();

    // Local variables
    IUnknown *punkOuter32;
    THUNK1632OBJ UNALIGNED *Id1632;
    THUNK3216OBJ *Id3216;
    PROXYHOLDER *pph = NULL;
    DWORD fst = FST_ERROR;
    BOOL fFail = FALSE;

    if(punkOuter32 = IsProxy1632(vpvOuter16)) {
        // The given 16-bit interface itself is a proxy to a 32-bit interface
        Id1632 = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
        pph = Id1632->pphHolder;
        RELVDMPTR(vpvOuter16);

    /* rm: nested aggregation
        if(pph->dwFlags & PH_AGGREGATEE) {
            // Nested aggregation
            thkAssert(pph->unkProxy.wType == PPRX_16);
            thkAssert(!"Nested aggregation case");

            // If proxies for PUNKOUTER and PUNKINNER are modfied to coordinate
            // transfer of references during QI calls on PUNKINNER, creation of
            // proxy to a proxy can be avoided for nested aggreagtion

            // Ensure that the user passed the true identity
            if(pph->unkProxy.dwPtrVal != vpvOuter16) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                vpvOuter16 = pph->unkProxy.dwPtrVal;
            }

            // Reset the return value to create a identity proxy
            punkOuter32 = NULL;
        }
        else {
    */
            // Aggregation through delegation
            thkAssert(!"Aggregation through delegation");
            punkOuter32->AddRef();

            // Initialize return value
            fst = FST_SHORTCUT;
    /* rm: nested aggregation
        }
    */
    }
    else if(Id3216 = LookupProxy3216(vpvOuter16)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sCreateOuter32 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), vpvOuter16, Id3216));

        // Validate the proxy
        DebugValidateProxy3216(Id3216);

        // Obtain its holder
        pph = Id3216->pphHolder;

        // Assert that the holder represents a 16-bit identity
        thkAssert(pph->unkProxy.wType == PPRX_32);
        thkAssert(pph->dwFlags & PH_NORMAL);

        // Ensure that the user passed the true identity
        if(pph->unkProxy.dwPtrVal != (DWORD) Id3216) {
            // Identity needs to be switched
            thkAssert(!"Switching to True Identity for Aggregation");

            // Obtain the true identity
            vpvOuter16 = Id3216->vpvThis16;
        }
    }
    else {
        // No interface on the identity has crossed thunking layer
        // Ensure that the user passed the true identity
        SCODE scRet;
        VPVOID vpvUnk;

        scRet = QueryInterfaceOnObj16(vpvOuter16, IID_IUnknown, (void **)&vpvUnk);
        if(SUCCEEDED(scRet) && vpvUnk) {
            // Fix up the reference count
            ReleaseOnObj16(vpvOuter16);

            // Switch the identity if needed
            if(vpvOuter16 != vpvUnk) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                vpvOuter16 = vpvUnk;
            }
        }
        else {
            // This is pretty nasty.
            Win4Assert(!"QI for IUnknown on the 16-bit interface failed");
            Win4Assert(!vpvUnk);

            // But I am allowing the behavior as some 16-bit apps like
            // VB4.0 pass interfaces that do not respond to QI for
            // IUnknown
        }
    }

    // Create a new 1632 proxy
    if(!punkOuter32 && vpvOuter16)  {
        Id3216 = (THUNK3216OBJ *) flFreeList32.AllocElement();
        if(Id3216) {
            // AddRef the 16-bit IUnknown
            AddRefOnObj16(vpvOuter16);

            // Update proxy fields
            Id3216->pfnVtbl = (DWORD) athopiInterfaceThopis[THI_IUnknown].pt3216fn;
            Id3216->cRefLocal = 1;
            Id3216->cRef = 1;
            Id3216->iidx = THI_IUnknown;
            Id3216->vpvThis16 = vpvOuter16;
            Id3216->grfFlags = PROXYFLAG_PUNKOUTER;
            PprxNull(Id3216->pprxObject);
            Id3216->pphHolder = NULL;
#if DBG == 1
            Id3216->dwSignature = PSIG3216;
#endif

            // Create a new AGGREGATE holder
            pph = NewHolder((DWORD)Id3216, PROXYPTR((DWORD)Id3216, PPRX_32),
                             PH_AGGREGATEE);
            if(pph) {
                // Initialize the return values
                fst = FST_CREATED_NEW;
                punkOuter32 = (IUnknown *) Id3216;
            }
            else {
                flFreeList32.FreeElement((DWORD) Id3216);
                ReleaseOnObj16(vpvOuter16);
            }
        }
    }

    // Set the return value
    if(pfst)
        *pfst = fst;

    if (pph)
        *ppAggHolder = pph;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut CreateOuter32(%p)->%p\n",
                 NestingLevelString(), punkOuter32, vpvOuter16));

    // This may be a proxy or a real 16-bit interface
    return punkOuter32;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CreateOuter16
//
//  Synopsis:   Generates a new 1632 proxy for a given 32-bit outer IUnknown
//              If the given 32-bit IUnknown itself is a proxy, returns
//              the actual 16-bit interface
//
//  Arguments:  [punkOuter32] -- Outer IUnknown
//              [ppAggHolder] -- Pointer to the proxy holder returned here
//              [pfst]       -- Proxy type is returned here
//
//  Returns:    1632 proxy or the actual 16-bit Interface
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation
//              Feb 11, 98  MPrabhu     Change to pass back pUnkOuter's holder
//
//----------------------------------------------------------------------------
VPVOID CThkMgr::CreateOuter16(IUnknown *punkOuter32, PROXYHOLDER **ppAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  CreateOuter16(%p)\n",
                 NestingLevelString(), punkOuter32));
    DebugIncrementNestingLevel();

    // Local variables
    VPVOID vpvOuter16;
    THUNK1632OBJ UNALIGNED *Id1632;
    PROXYHOLDER *pph = NULL;
    DWORD fst = FST_ERROR;

    if(vpvOuter16 = IsProxy3216(punkOuter32)) {
        // The given 32-bit interface itself is a proxy to a 16-bit interface
        pph = ((THUNK3216OBJ *) punkOuter32)->pphHolder;

    /* rm: nested aggregation
        if(pph->dwFlags & PH_AGGREGATEE) {
            // Nested aggregation
            thkAssert(pph->unkProxy.wType == PPRX_32);
            thkAssert(!"Nested aggregation case");

            // If proxies for PUNKOUTER and PUNKINNER are modfied to coordinate
            // transfer of references during QI calls on PUNKINNER, creation of
            // proxy to a proxy can be avoided for nested aggreagtion

            // Ensure that the user passed the true identity
            if(pph->unkProxy.dwPtrVal != (DWORD) punkOuter32) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                punkOuter32 = (IUnknown *) pph->unkProxy.dwPtrVal;
            }

            // Reset the return value to create a identity proxy
            vpvOuter16 = NULL;
        }
        else {
    */
            // Aggregation through delegation
            thkAssert(!"Aggregation through delegation");
            AddRefOnObj16(vpvOuter16);

            // Initialize return value
            fst = FST_SHORTCUT;
    /* rm: nested aggregation
        }
    */
    }
    else if(vpvOuter16 = LookupProxy1632(punkOuter32)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sCreateOuter16 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), punkOuter32, vpvOuter16));

        // Validate the proxy
        DebugValidateProxy1632(vpvOuter16);

        // Obtain its holder
        Id1632 = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
        pph = Id1632->pphHolder;
        RELVDMPTR(vpvOuter16);

        // Assert that the holder represents a 32-bit identity
        thkAssert(pph->unkProxy.wType == PPRX_16);
        thkAssert(pph->dwFlags & PH_NORMAL);

        // Ensure that the user passed the true identity
        if(pph->unkProxy.dwPtrVal != vpvOuter16) {
            // Identity needs to be switched
            thkAssert(!"Switching to True Identity for Aggregation");

            // Obtain the true identity
            Id1632 = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            punkOuter32 = Id1632->punkThis32;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }

        // Reset the return value to create a identity proxy
        vpvOuter16 = NULL;
    }
    else {
        // No interface on the identity has crossed thunking layer
        // Ensure that the user passed the true identity
        SCODE scRet;
        IUnknown *pUnk;

        scRet = punkOuter32->QueryInterface(IID_IUnknown, (void **) &pUnk);
        if(SUCCEEDED(scRet) && pUnk) {
            // Fix up the reference count
            punkOuter32->Release();

            // Switch the identity if needed
            if(punkOuter32 != pUnk) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                punkOuter32 = pUnk;
            }
        }
        else {
            // This is pretty nasty.
            Win4Assert(!"QI for IUnknown on the 32-bit interface failed");
            Win4Assert(!pUnk);
            punkOuter32 = NULL;
        }
    }

    // Create a new 1632 proxy
    if(!vpvOuter16 && punkOuter32) {
        vpvOuter16 = flFreeList16.AllocElement();
        if(vpvOuter16) {
            // AddRef the 32-bit IUnknown
            punkOuter32->AddRef();

            Id1632 = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
            thkAssert(Id1632);

            // Update proxy fields
            Id1632->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
            Id1632->cRefLocal = 1;
            Id1632->cRef = 1;
            Id1632->iidx = THI_IUnknown;
            Id1632->punkThis32 = punkOuter32;
            Id1632->grfFlags = PROXYFLAG_PUNKOUTER;
            PprxNull(Id1632->pprxObject);
            Id1632->pphHolder = NULL;
#if DBG == 1
            Id1632->dwSignature = PSIG1632;
#endif
            RELVDMPTR(vpvOuter16);

            // Create a new AGGREGATEE holder
            pph = NewHolder(vpvOuter16, PROXYPTR(vpvOuter16, PPRX_16), PH_AGGREGATEE);
            if(pph) {
                // Initialize return value
                fst = FST_CREATED_NEW;
            }
            else {
                flFreeList16.FreeElement(vpvOuter16);
                punkOuter32->Release();

                // Initialize the return value
                vpvOuter16 = NULL;
            }
        }
    }

    // Set the return value
    if(pfst)
        *pfst = fst;

    if (pph)
        *ppAggHolder = pph;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut CreateOuter16(%p)->%p\n",
                 NestingLevelString(), punkOuter32, vpvOuter16));

    // This may be a 1632 proxy or a real 16-bit interface
    return vpvOuter16;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::Object32Identity
//
//  Synopsis:   Finds/Creates a 32/16 IUnknown proxy on a given 16-bit object
//              to establish its identity.
//
//  Arguments:  [punkThis32] -- 32-bit Object
//              [pProxy]     -- Proxy representing Identity
//              [pfst]       -- Search result is returned here
//
//  Returns:    Proxy representing object identity. In addition, the
//              returned proxy is AddRefed only if it represents a
//              16-bit identity
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::Object32Identity(IUnknown *punkThis32, PROXYPTR *pProxy, DWORD *pfst)
{
    // Local variables
    DWORD fst = FST_ERROR;
    SCODE scRet;
    VPVOID vpvProxy = NULL;
    IUnknown *pUnk;
    THUNK1632OBJ UNALIGNED *ptoProxy;
    PROXYHOLDER *pph = NULL;

    // QI for IUnknown on the 32-bit interface
    scRet = punkThis32->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(SUCCEEDED(scRet) && pUnk) {
        // Lookup the indentity
        if(_pHolderTbl->Lookup((VPVOID) pUnk, (void *&)pph)) {
            // Identity exists for IUnknown
            thkAssert(pph);
			if (pph)
			{
				thkAssert(pph->unkProxy.dwPtrVal);
				if(pph->dwFlags & PH_AGGREGATEE) {
					thkAssert(pph->unkProxy.wType == PPRX_32);
					DebugValidateProxy3216((THUNK3216OBJ *) pph->unkProxy.dwPtrVal);
				}
				else {
					thkAssert(pph->unkProxy.wType == PPRX_16);
					DebugValidateProxy1632(pph->unkProxy.dwPtrVal);
				}

				// Fix up the reference count
				pUnk->Release();

				// Initialize return values
				*pProxy = pph->unkProxy;
				fst = FST_USED_EXISTING;
			}
			else
			{
				scRet = E_FAIL;
				fst = FST_ERROR;
			}
        }
        else {
            // Identity does not exist for IUnknown which means that
            // the IUnknown is indeed a 32-bit interface that has
            // not been seen till now. Establish its identity
            thkAssert(!pph);

            // Create the proxy for 32-bit IUnknown
            vpvProxy = flFreeList16.AllocElement();
            if(vpvProxy) {
                // Put the new proxy in the proxy list
                if(_pProxyTbl1632->SetAt((DWORD) pUnk, (void *)vpvProxy)) {
                    ptoProxy = FIXVDMPTR(vpvProxy, THUNK1632OBJ);
                    thkAssert(ptoProxy);

                    // Update proxy fields
                    ptoProxy->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
                    ptoProxy->cRefLocal = 1;
                    ptoProxy->cRef = 1;
                    ptoProxy->iidx = THI_IUnknown;
                    ptoProxy->punkThis32 = pUnk;
                    ptoProxy->grfFlags = PROXYFLAG_PUNK;
                    PprxNull(ptoProxy->pprxObject);
                    ptoProxy->pphHolder = NULL;
#if DBG == 1
                    ptoProxy->dwSignature = PSIG1632;
#endif
                    RELVDMPTR(vpvProxy);

                    // Initialize return value
                    pProxy->dwPtrVal = vpvProxy;
                    pProxy->wType = PPRX_16;

                    // Create a new NONAGGREGATE holder
                    pph = NewHolder((VPVOID) pUnk, *pProxy, PH_NORMAL);
                    if(pph) {
                        // Initialize return value
                        fst = FST_CREATED_NEW;
                    }
                    else {
                        // Remove the key from the 1632 proxy table
#if DBG==1
                        thkAssert(_pProxyTbl1632->RemoveKey((DWORD) pUnk));
#else
                        _pProxyTbl1632->RemoveKey((DWORD) pUnk);
#endif
                    }
                }
            }
        }
    }
    else {
        // This is pretty nasty.
        Win4Assert(!"QI for IUnknown on the 32-bit interface failed");
        Win4Assert(!pUnk);
    }

    // Cleanup if something has gone wrong
    if(fst == FST_ERROR) {
        if(vpvProxy) {
            flFreeList16.FreeElement(vpvProxy);
        }
        if(pUnk) {
            pUnk->Release();
            scRet = E_OUTOFMEMORY;
        }

        // Reset return value
        pProxy->dwPtrVal = NULL;
        pProxy->wType = PPRX_NONE;
    }
    else {
        scRet = NOERROR;
    }

    // Indicate the type being returned
    if(pfst)
        *pfst = fst;

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::Object16Identity
//
//  Synopsis:   Finds/Creates a 32/16 IUnknown proxy on a given 16-bit object
//              to establish its identity.
//
//  Arguments:  [vpvThis16] -- 16-bit Object
//              [pProxy]     -- Proxy representing Identity
//              [pfst]      -- Search result is returned here
//
//  Returns:    Proxy representing object identity. In addition, the
//              returned proxy is AddRefed only if it represents a
//              16-bit identity
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::Object16Identity(VPVOID vpvThis16, PROXYPTR *pProxy, DWORD *pfst, BOOL bCallQI, BOOL bExtraAddRef)
{
    // Local variables
    DWORD fst = FST_ERROR;
    SCODE scRet;
    THUNK3216OBJ *punkProxy = NULL;
    VPVOID vpvUnk = NULL;
    PROXYHOLDER *pph = NULL;

    if (bCallQI) {
        // QI for IUnknown on the 16-bit interface
        scRet = QueryInterfaceOnObj16(vpvThis16, IID_IUnknown, (void **)&vpvUnk);
    }
    else {
        scRet = E_FAIL; // this will force the QI workaround below
    }

    if(FAILED(scRet)) {
        // This is pretty nasty.
        Win4Assert(!"QI for IUnknown on the 16-bit interface failed");
        Win4Assert(!vpvUnk);

        // But I am allowing the behavior as VB4.0 16-bit passes an
        // IStorage to WriteClassStg api that does not respond to QI
        // for IUnknown. See NT Raid Bug #82195
        scRet = NOERROR;
        vpvUnk = vpvThis16;

        // AddRef the 16-bit interface
        AddRefOnObj16(vpvUnk);
    }
    else {
        // Assert that identity has been established
        Win4Assert(vpvUnk);
    }


    // Lookup the indentity
    if(_pHolderTbl->Lookup(vpvUnk, (void *&)pph)) {
        // Identity exists for IUnknown
        thkAssert(pph);
		if (pph)
		{
			thkAssert(pph->unkProxy.dwPtrVal);
			if(pph->dwFlags & PH_AGGREGATEE) {
				thkAssert(pph->unkProxy.wType == PPRX_16);
				DebugValidateProxy1632(pph->unkProxy.dwPtrVal);
			}
			else {
				thkAssert(pph->unkProxy.wType == PPRX_32);
				DebugValidateProxy3216((THUNK3216OBJ *) pph->unkProxy.dwPtrVal);
			}

			// Fix up the reference count
			ReleaseOnObj16(vpvUnk);

			// Initialize return values
			*pProxy = pph->unkProxy;
			fst = FST_USED_EXISTING;
		}
		else
		{
			fst = FST_ERROR;
			scRet = E_FAIL;
		}
    }
    else {
        // Identity does not exist for IUnknown which means that
        // the IUnknown is indeed a 16-bit interface that has
        // not been seen till now. Establish its identity
        thkAssert(!pph);

        // Create the proxy for 16-bit IUnknown
        punkProxy = (THUNK3216OBJ *) flFreeList32.AllocElement();
        if(punkProxy) {
            // Put the new proxy in the proxy list
            if(_pProxyTbl3216->SetAt(vpvUnk, punkProxy)) {
                // Update proxy fields
                punkProxy->pfnVtbl = (DWORD)athopiInterfaceThopis[THI_IUnknown].pt3216fn;
                punkProxy->cRefLocal = 1;
                punkProxy->cRef = 1;
                punkProxy->iidx = THI_IUnknown;
                punkProxy->vpvThis16 = vpvUnk;
                punkProxy->grfFlags = PROXYFLAG_PUNK;
                PprxNull(punkProxy->pprxObject);
                punkProxy->pphHolder = NULL;
#if DBG == 1
                punkProxy->dwSignature = PSIG3216;
#endif

                // Initialize return value
                pProxy->dwPtrVal = (DWORD) punkProxy;
                pProxy->wType = PPRX_32;

                // Create a new NONAGGREGATE holder
                pph = NewHolder(vpvUnk, *pProxy, PH_NORMAL);
                if(pph) {
                    // Initialize return value
                    fst = FST_CREATED_NEW;
                    if (bExtraAddRef) {         //Hack
                        AddRefOnObj16(vpvUnk);
                    }
                }
                else {
                    // Remove the key from the 3216 proxy table
#if DBG==1
                    thkAssert(_pProxyTbl3216->RemoveKey(vpvUnk));
#else
                    _pProxyTbl3216->RemoveKey(vpvUnk);
#endif
                }
            }
        }
    }

    // Cleanup if something has gone wrong
    if(fst == FST_ERROR) {
        if(punkProxy) {
            flFreeList32.FreeElement((DWORD) punkProxy);
        }
        if(vpvUnk) {
            ReleaseOnObj16(vpvUnk);
            scRet = E_OUTOFMEMORY;
        }

        // Reset return value
        pProxy->dwPtrVal = NULL;
        pProxy->wType = PPRX_NONE;
    }
    else {
        scRet = NOERROR;
    }

    // Indicate the type being returned
    if(pfst)
        *pfst = fst;

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindProxy3216
//
//  Synopsis:   Finds/Creates a 32/16 proxy for a given 16-bit interface.
//              If the given 16-bit interface itself is a proxy, returns
//              the actual 32-bit Interface
//
//  Arguments:  [vpvPrealloc] -- Preallocated 32/16 proxy
//              [vpvThis16]   -- 16-bit Interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    32/16 proxy object or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
IUnknown *CThkMgr::FindProxy3216(THUNK3216OBJ *ptoPrealloc, VPVOID vpvThis16,
                                 PROXYHOLDER *pgHolder, IIDIDX iidx,
                                 BOOL bExtraAddRef, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindProxy3216(%p, %p, %s)\n",
                 NestingLevelString(), ptoPrealloc, vpvThis16, IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK3216OBJ *pto = NULL, *punkProxy = NULL;
    IUnknown *pProxy;
    DWORD fst, Fail = FALSE;

    // Validation checks
    thkAssert(vpvThis16);
#if DBG == 1
    // Ensure that the preallocated proxy is not in use
    if(ptoPrealloc) {
        if(ptoPrealloc->grfFlags & PROXYFLAG_TEMPORARY)
            thkAssert(ptoPrealloc->cRefLocal == 0 && ptoPrealloc->cRef == 0);
    }
#endif

    // Initialize the fst value
    fst = FST_ERROR;

    // If proxy was preallocated for this IID using CanGetNewProxy, it would
    // have added it to the requested IID list.
    if (ptoPrealloc != 0 && IIDIDX_IS_IID(iidx))
        RemoveIIDRequest(*IIDIDX_IID(iidx));

    if(pto = LookupProxy3216(vpvThis16)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy3216 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), vpvThis16, pto));

        // Assert that the holders match
        thkAssert(pto->pphHolder);
        thkAssert(!(pto->grfFlags & PROXYFLAG_PUNKINNER));
        if(pgHolder && pto->pphHolder!=pgHolder) {
            thkAssert(pto->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Check the proxy IID against the given IID. If the server has passed
        // the same 32-bit interface pointer against another IID, it is possible
        // for the IID's to be different. If the Interface2 derives from Interface1,
        // the interface pointers for them would be the same in C or C++. An
        // excellant example would be IPersistStorage deriving from IPersist.

        // IIDIDXs are related to interfaces in thunk tables, which are organized
        // such that more derived interfaces have higher indices than the less
        // derived ones. Custom interfaces have an IID rather than an index, and
        // consequently are not affected by the following statement.
        if(IIDIDX_IS_INDEX(iidx)) {
            // Check if the new IID is more derived than the existing one
            if(IIDIDX_INDEX(iidx) > IIDIDX_INDEX(pto->iidx)) {
                // Change the vtable pointer to the more derived interface
                pto->pfnVtbl = (DWORD)athopiInterfaceThopis[IIDIDX_INDEX(iidx)].pt3216fn;
                pto->iidx = iidx;
            }
        }

        // AddRef the proxy
        AddRefProxy3216(pto);

        // Set return values
        fst = FST_USED_EXISTING;
        pProxy = (IUnknown *)pto;
    }
    else if(pProxy = IsProxy1632(vpvThis16)) {
        // The given 16-bit interface itself is a proxy to a 32-bit
        // interface
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy3216 shortcut proxy,(%p)->%p\n",
                     NestingLevelString(), vpvThis16, pProxy));
        THUNK1632OBJ UNALIGNED *pProxy1632;

        // Fix the VDM pointer
        pProxy1632 = FIXVDMPTR(vpvThis16, THUNK1632OBJ);

        // Assert that the holders match
        thkAssert(pProxy1632->pphHolder);
        thkAssert(!(pProxy1632->grfFlags & PROXYFLAG_PUNKINNER));
        if(pgHolder && pProxy1632->pphHolder!=pgHolder) {
            thkAssert(pProxy1632->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Release the VDM pointer
        RELVDMPTR(vpvThis16);

        // Avoid creating a proxie to another proxie
        THKSTATE thkstate;

        // Remember the current thunk state
        thkstate = GetThkState();

        // Set the thunk state to THKSTATE_NOCALL
        SetThkState(THKSTATE_NOCALL);

        // AddRef actual the 32-bit interface
        pProxy->AddRef();

        // Restore previous thunk state. Remember the Excel Hack
        SetThkState(thkstate);

        // Set the type of proxy being returned
        fst = FST_SHORTCUT;
    }
    else {
        // An existing proxy has not been found and the interface to proxied
        // is a real 16-bit interface.

        // Check if holder has not been given
        if(!pgHolder) {
            // This interface is being obtained through a method call
            PROXYPTR unkPPtr;
            SCODE error;
            BOOL bCallQI = TRUE;

            if((TlsThkGetAppCompatFlags() & OACF_CRLPNTPERSIST) &&
               (iidx==THI_IPersistStorage)) {
                thkDebugOut((DEB_WARN,"CorelPaint Hack Used\n"));
                bCallQI = FALSE;
            }

            // Obtain the identity of 16-bit object
            error = Object16Identity(vpvThis16, &unkPPtr, &fst, bCallQI, bExtraAddRef);
            if(error == NOERROR) {
                // Check for aggregation case
                if(unkPPtr.wType==PPRX_32) {
                    // Check if vpvThis16 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // Initialize the return value
                        pProxy = (IUnknown *) unkPPtr.dwPtrVal;

                        // Check if the identity has been switched
                        if(fst == FST_USED_EXISTING) {
                            // The IUnknown identity has already been established
                            // The app was trying to pass someother 16-bit interface
                            // as IUnknown.
                            thkDebugOut((DEB_WARN, "Switched to correct Identity\n"));

                            // AddRef the proxy being returned
                            AddRefProxy3216((THUNK3216OBJ *) pProxy);
                        }
                        else {
                            thkAssert(fst == FST_CREATED_NEW);
                        }
                    }
                    else {
                        THUNK3216OBJ *Id3216 = (THUNK3216OBJ *) unkPPtr.dwPtrVal;

                        // Check if the identity has just been established
                        if(fst == FST_CREATED_NEW) {
                            // Check if the Identity and current IID share the same
                            // interface pointer
                            if(Id3216->vpvThis16==vpvThis16) {
                                // Check if the new IID is more derived than the existing one
                                if(IIDIDX_IS_INDEX(iidx) && iidx>Id3216->iidx) {
                                    // Change the vtable pointer to the more derived interface
                                    Id3216->pfnVtbl = (DWORD)athopiInterfaceThopis[iidx].pt3216fn;
                                    Id3216->iidx = iidx;
                                }

                                // Initialize the return value
                                pProxy = (IUnknown *) Id3216;
                            }
                            else {
                                // We need to release the IUnknown proxy after adding
                                // the proxy representing vpvThis16 to the its holder
                                punkProxy = Id3216;
                            }
                        }
                        else {
                            thkAssert(fst == FST_USED_EXISTING);
                        }

                        // Obtain the holder of the identity
                        pgHolder = Id3216->pphHolder;
                    }
                }
                else {
                    // Obtain the holder of the identity
                    THUNK1632OBJ UNALIGNED *Id1632;
                    IUnknown *punkTemp;

                    Id1632 = FIXVDMPTR(unkPPtr.dwPtrVal, THUNK1632OBJ);
                    pgHolder = Id1632->pphHolder;
                    punkTemp = Id1632->punkThis32;
                    RELVDMPTR(unkPPtr.dwPtrVal);

                    // Sanity checks
                    thkAssert(fst == FST_USED_EXISTING);
                    thkAssert(pgHolder->dwFlags & PH_AGGREGATEE);

                    // Check if vpvThis16 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // The IUnknown identity has already been established
                        // The app was trying to pass someother 16-bit interface
                        // as IUnknown. Switch to correct identity
                        thkAssert(!"Switched to correct Identity");

                        // Initialize the return value
                        pProxy = punkTemp;

                        // AddRef the actual 32-bit interface being returned
                        pProxy->AddRef();
                    }
                }
            }
            else {
                // Failed to obtain the identity
                Fail = TRUE;
            }
        }
    }

    if(!pProxy && !Fail) {
        // Assert that we have holder
        thkAssert(pgHolder);
        // Reset the fst value
        fst = FST_ERROR;

        // Obtain either a preallocated or a new proxy
        if(ptoPrealloc) {
            // Use the preallocated proxy
            pto = ptoPrealloc;
            ptoPrealloc = NULL;
        }
        else {
            // Create a new proxy
            pto = (THUNK3216OBJ *) flFreeList32.AllocElement();
        }

        // Ensure that we have a proxy
        if(pto) {
            // Put the new proxy in the proxy list
            if(_pProxyTbl3216->SetAt(vpvThis16, pto)) {
                // Convert a custom IID to THI_IUnknown as we thunk
                // only its IUnknown methods
                if(IIDIDX_IS_IID(iidx))
                    iidx = INDEX_IIDIDX(THI_IUnknown);

                // AddRef the 16-bit interface
                AddRefOnObj16(vpvThis16);

                // Update proxy fields
                pto->pfnVtbl = (DWORD)athopiInterfaceThopis[iidx].pt3216fn;
                pto->cRefLocal = 1;
                pto->cRef = 1;
                pto->iidx = iidx;
                pto->vpvThis16 = vpvThis16;
                pto->grfFlags = PROXYFLAG_PIFACE;
                PprxNull(pto->pprxObject);
                pto->pphHolder = NULL;
                AddProxyToHolder(pgHolder, pto, Pprx32(pto));
#if DBG == 1
                pto->dwSignature = PSIG3216;
#endif
                thkDebugOut((DEB_THUNKMGR,
                             "%sFindProxy3216 added new proxy, %s (%p)->%p (%d,%d)\n",
                             NestingLevelString(), inInterfaceNames[pto->iidx].pszInterface,
                             vpvThis16, pto, pto->cRefLocal, pto->cRef));

                // Set the return values
                pProxy = (IUnknown *) pto;
                fst = FST_CREATED_NEW;
            }
            else {
                // Cleanup the proxy only if it was newly created
                if(fst == FST_CREATED_NEW)
                    flFreeList32.FreeElement((DWORD) pto);
                pProxy = NULL;
                fst = 0;
            }
        }
    }
    else {
        if(Fail) {
            thkAssert(pProxy == NULL && fst == FST_ERROR);
        }
    }

    // Cleanup the allocated proxy if it has not been used
    if(ptoPrealloc)
        flFreeList32.FreeElement((DWORD)ptoPrealloc);

    // Release the IUnknown proxy. If it was newly created for establishing
    // the identity of the given 16-bit interface , the following release
    // would be the last release on the IUnknown proxy and consequently,
    // would destroy it along with its holder
    if(punkProxy)
        ReleaseProxy3216(punkProxy);

    // Set the return value
    if(pfst)
        *pfst = fst;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindProxy3216: (%p)->%p\n",
                 NestingLevelString(), vpvThis16, pProxy));

    return pProxy;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindAggregate3216
//
//  Synopsis:   Finds/Generates a 32/16 proxy for a given 16-bit interface
//              that is aggregated with the given outer unknown.
//              If the given 16-bit interface itself is a proxy, returns
//              the actual 32-bit Interface
//
//  Arguments:  [ptoPrealloc] -- Preallocated proxy or NULL
//              [vpvOuter16]  -- controlling unknown that was passed to
//                               16-bit world
//              [vpvThis16]   -- 16-bit interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pAggHolder]  -- Proxy holder of pUnkOuter
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    32/16 proxy object or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//              Feb 11, 98  MPrabhu     Change to use pUnkOuter's holder
//----------------------------------------------------------------------------
IUnknown *CThkMgr::FindAggregate3216(THUNK3216OBJ *ptoPrealloc, VPVOID vpvOuter16,
                                    VPVOID vpvThis16, IIDIDX iidx, PROXYHOLDER *pAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindAggregate3216(%p, %p, %p, %s)\n",
                 NestingLevelString(), ptoPrealloc, vpvOuter16, vpvThis16,
                 IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *p1632ProxyOuter;
    THUNK3216OBJ *p3216ProxyOuter;
    PROXYHOLDER *pph;
    IUnknown *pUnk = NULL;
    DWORD fstPrx = FST_ERROR;

    // Validation checks
    thkAssert(vpvThis16 != NULL && vpvOuter16 != NULL);

    // Obtain the identity holder
    // Check if the outer IUnknown is a 32-bit interface
#if DBG == 1
    if(IsProxy1632(vpvOuter16)) {
        // The outer IUnknown is a 32-bit interface
        p1632ProxyOuter = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
        pph = p1632ProxyOuter->pphHolder;
        thkAssert(pph == pAggHolder);

        // Ensure that the holder is marked PH_AGGREGATEE
        thkAssert(pph);
        thkAssert(pph->dwFlags & PH_AGGREGATEE);
        RELVDMPTR(vpvOuter16);
    }
#endif
    // Aggregation through delegation.
    pph = pAggHolder;

    // Find/Generate the proxy for the given 16-bit interface
    pUnk = FindProxy3216(ptoPrealloc, vpvThis16, pph, iidx, FALSE, &fstPrx);

    // Initialize the return value
    if(pfst)
        *pfst = fstPrx;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindAggregate3216,(%p)->%p\n",
                 NestingLevelString(), vpvThis16, pUnk));

    // This may be a proxy or a real 32-bit interface
    return(pUnk);
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindAggregate1632
//
//  Synopsis:   Finds/Generates a 16/32 proxy for a given 32-bit interface
//              that is aggregated with the given outer unknown.
//              If the given 32-bit interface itself is a proxy, returns
//              the actual 16-bit Interface
//
//  Arguments:  [ptoPrealloc] -- Preallocated proxy or NULL
//              [punkOuter32] -- controlling unknown that was passed to
//                               32-bit world
//              [punkThis32]  -- 16-bit interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pAggHolder]  -- Proxy holder of pUnkOuter
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    32/16 proxy object or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//              Feb 11, 98  MPrabhu     Change to use pUnkOuter's holder
//----------------------------------------------------------------------------
VPVOID CThkMgr::FindAggregate1632(VPVOID vpvPrealloc, IUnknown *punkOuter32,
                                  IUnknown *punkThis32, IIDIDX iidx, PROXYHOLDER *pAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindAggregate1632(%p, %p, %p, %s)\n",
                 NestingLevelString(), vpvPrealloc, punkOuter32, punkThis32,
                 IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *p1632ProxyOuter;
    THUNK3216OBJ *p3216ProxyOuter;
    PROXYHOLDER *pph;
    VPVOID vpvProxy = NULL;
    DWORD fstPrx = FST_ERROR;

    // Validation checks
    thkAssert(punkThis32 != NULL && punkOuter32 != NULL);

    // Obtain the identity holder
    // Check if the outer IUnknown is a 16-bit interface
#if DBG == 1
    if(IsProxy3216(punkOuter32)) {
        // The outer IUnknown is a 16-bit interface
        p3216ProxyOuter = (THUNK3216OBJ *) punkOuter32;
        pph = p3216ProxyOuter->pphHolder;
        thkAssert(pph == pAggHolder);

        // Ensure that the holder is marked PH_AGGREGATEE
        thkAssert(pph);
        thkAssert(pph->dwFlags & PH_AGGREGATEE);
    }
#endif
    // Aggregation through delegation.
    // The outer IUnknown must be a 32-bit interface
    pph = pAggHolder;

    // Find/Generate the proxy for the given 32-bit interface
    vpvProxy = FindProxy1632(vpvPrealloc, punkThis32, pph, iidx, &fstPrx);

    // Initialize the return value
    if(pfst)
        *pfst = fstPrx;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindAggregate1632,(%p)->%p\n",
                 NestingLevelString(), punkThis32, vpvProxy));

    // This may be a proxy or a real 16-bit interface
    return(vpvProxy);
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::QueryInterfaceProxy3216
//
//  Synopsis:   QueryInterface on the  given proxy
//
//  Arguments:  [ptoThis] -- Proxy to a 16-bit interface
//              [refiid]  -- Interface IID
//              [ppv]     -- Place where the new interface is returned
//
//  Returns:    HRESULT
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::QueryInterfaceProxy3216(THUNK3216OBJ *ptoThis, REFIID refiid,
                                       LPVOID *ppv)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn QueryInterfaceProxy3216(%p)\n",
                 NestingLevelString(), ptoThis));
    DebugIncrementNestingLevel();

    // Local variables
    SCODE scRet = S_OK;
    IUnknown *punkProxy;
    PROXYHOLDER *pph;
    VPVOID vpvUnk;
    DWORD fst;

    // Validation checks
    DebugValidateProxy3216(ptoThis);

    // Initialize the return value
    *ppv = NULL;

    // Convert interface IID to an IIDIDX
    IIDIDX iidx = IidToIidIdx(refiid);

    // Check if a custom interface has been requested
    if(IIDIDX_IS_IID(iidx)) {
        thkDebugOut((DEB_THUNKMGR, "%sQueryInterfaceProxy3216: unknown iid %s\n",
                     NestingLevelString(), IidIdxString(iidx)));

        // Add the request for the unknown interface
        if(!AddIIDRequest(refiid))
            return E_OUTOFMEMORY;
    }
    thkAssert(ptoThis->vpvThis16);

    // Ensure that the aggregatee identity gets correctly established
    if(ptoThis->grfFlags & PROXYFLAG_PUNKOUTER && iidx == THI_IUnknown) {
        // QI by the aggregatee for identity
        thkAssert(ptoThis->pphHolder->unkProxy.dwPtrVal == (DWORD) ptoThis);

        // AddRef and return outer proxy
        AddRefProxy3216(ptoThis);
        *ppv = (void *) ptoThis;
    }
    else {
        // Execute the QI on the 16-bit interface
        scRet = QueryInterfaceOnObj16(ptoThis->vpvThis16, refiid, (void **)&vpvUnk);
        if(SUCCEEDED(scRet)) {
            if(vpvUnk) {
                // Obtain the identity holder
                pph = ptoThis->pphHolder;

                // Check if this is a QI on an interface on the aggregatee
                if(pph->dwFlags & PH_AGGREGATEE) {
                    if(ptoThis->grfFlags & PROXYFLAG_PIFACE) {
                        // QI on an interface on the aggregatee which
                        // delegates to the aggregator

                        // Note the above QI call can be short circuited as
                        // an optimization. It will be carried out in future
                        // after ensuring that apps do not break due to such
                        // short circuiting
                        thkAssert(pph->unkProxy.wType == PPRX_16);
                    }
                    else if(ptoThis->grfFlags & PROXYFLAG_PUNKOUTER) {
                        // QI by the aggregatee on aggregator
                        thkAssert(pph->unkProxy.dwPtrVal == (DWORD) ptoThis);
                    }
                    else {
                        // QI by the aggregator on the aggregatee
                        thkAssert(ptoThis->grfFlags & PROXYFLAG_PUNKINNER);
                        thkAssert(pph->unkProxy.wType == PPRX_16);
                    }

                    // As aggregation is involved, we cannot be certain of
                    // identity of the returned interface
                    pph = NULL;
                }

                // Set the thunk status
                SetThkState(THKSTATE_INVOKETHKOUT32);

                punkProxy = FindProxy3216(NULL, vpvUnk, pph, iidx, FALSE, &fst);

                if(punkProxy) {
                    // Set the return value
                    *ppv = punkProxy;
#if DBG==1
                    if(pph) {
                        // Ensure that the given and new proxies either have the same
                        // holder or point to same identity
                        if(fst & FST_PROXY_STATUS) {
                            THUNK3216OBJ *ptoNew = (THUNK3216OBJ *) punkProxy;

                            thkAssert(ptoNew->pphHolder == ptoThis->pphHolder);
                        }
                        else {
                            THUNK1632OBJ UNALIGNED *ptoNew;

                            ptoNew = FIXVDMPTR(vpvUnk, THUNK1632OBJ);
                            thkAssert(fst == FST_SHORTCUT);
                            thkAssert(ptoNew->pphHolder != ptoThis->pphHolder);
                            thkAssert(ptoNew->pphHolder->dwFlags & PH_AGGREGATEE);
                            thkAssert(ptoNew->pphHolder->unkProxy.wType == PPRX_32);
                            RELVDMPTR(vpvUnk);
                        }
                    }
#endif
                }
                else {
                    scRet = E_OUTOFMEMORY;
                }

                // As the new interface is an OUT parameter, release the actual
                // 16-bit interface. This would counter the AddRef made by
                // a successfull FindProxy3216, else it would clean up the
                // reference count
                ReleaseOnObj16(vpvUnk);

                // Reset thunk status
                SetThkState(THKSTATE_NOCALL);
            }
            else {
                // Corel draw returns NOERROR while setting returned interface to NULL
                // We modify the returned value to suit 32-bit QI semantics.
                scRet = E_NOINTERFACE;
            }
        }
    }

    if(IIDIDX_IS_IID(iidx)) {
        // Clean up custom interface request
        RemoveIIDRequest(refiid);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut QueryInterfaceProxy3216(%p) => %p, 0x%08lX\n",
                 NestingLevelString(), ptoThis, *ppv, scRet));

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::AddRefProxy3216
//
//  Synopsis:   addref on the given object - can addref the real object
//
//  Arguments:  [ptoThis] -- proxy object
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
DWORD CThkMgr::AddRefProxy3216(THUNK3216OBJ *ptoThis)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn AddRefProxy3216(%p)\n",
                 NestingLevelString(), ptoThis));
    DebugIncrementNestingLevel();

    // Validation checks
    DebugValidateProxy3216(ptoThis);
    thkAssert(ptoThis->pphHolder);

    // Increment local refcount
    thkAssert(ptoThis->cRefLocal >= 0);
    ptoThis->cRefLocal++;

    // Check for the need to AddRef the holder
    if(ptoThis->cRefLocal == 1) {
        // Assert that an aggregatee is not being revived
        thkAssert(!(ptoThis->grfFlags & PROXYFLAG_PUNKINNER));

        // AddRef the holder
        AddRefHolder(ptoThis->pphHolder);

        // Mark the proxy as revived
        ptoThis->grfFlags |= PROXYFLAG_REVIVED;
    }

    // Check for the need to forward AddRef to the actual 16-bit interface
    if(ptoThis->cRefLocal==1 || (ptoThis->pphHolder->dwFlags & PH_AGGREGATEE)) {
#if DBG==1
        DWORD refsBefore, refsAfter;
        PROXYHOLDER *pph;
        THUNK1632OBJ UNALIGNED *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 32-bit world
            thkAssert(pph->unkProxy.wType == PPRX_16);

            // Obtain the references on the outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif
        // Increment before calling the actual 16-bit interface
        ptoThis->cRef++;

        // AddRef the actual 16-bit interface
        AddRefOnObj16(ptoThis->vpvThis16);

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above AddRef translated to a AddRef on the
            // outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter-1);
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif
    }

    DebugValidateProxy3216(ptoThis);
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut AddRefProxy3216(%p),(%ld,%ld)\n",
                 NestingLevelString(), ptoThis, ptoThis->cRefLocal,
                 ptoThis->cRef));

    return ptoThis->cRefLocal;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::ReleaseProxy3216
//
//  Synopsis:   release on the proxy or aggregate
//
//  Arguments:  [ptoThis] -- proxy object
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
DWORD CThkMgr::ReleaseProxy3216(THUNK3216OBJ *ptoThis)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn ReleaseProxy3216(%p)\n",
                 NestingLevelString(), ptoThis));
    DebugIncrementNestingLevel();

    // Local variables
    DWORD dwLocalRefs, dwRefs;
    DWORD ProxyType;

    // Validation checks
    DebugValidateProxy3216(ptoThis);
    thkAssert(ptoThis->pphHolder);

    // Check for the need to forward the release to the actual
    // 16-bit interface
    if(ptoThis->cRef == ptoThis->cRefLocal) {
#if DBG==1
        DWORD refsBefore, refsAfter;
        PROXYHOLDER *pph;
        THUNK1632OBJ UNALIGNED *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 32-bit world
            thkAssert(pph->unkProxy.wType == PPRX_16);

            // Obtain the references on the outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif

        // Release the actual 16-bit interface
        thkAssert(ptoThis->cRef);
        ReleaseOnObj16(ptoThis->vpvThis16);

        // Decrement after calling the actual 16-bit interface
        --ptoThis->cRef;

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above release translated to a release on the
            // outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter+1);
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif
    }

    // Decrement the local refcount
    thkAssert(ptoThis->cRefLocal > 0);
    dwLocalRefs = --ptoThis->cRefLocal;
    dwRefs = ptoThis->cRef;
    ProxyType = ptoThis->grfFlags & PROXYFLAG_TYPE;

    // Check if the proxy needs to be cleaned up
    if(dwLocalRefs == 0) {
        // Debug dump
        thkAssert(dwRefs == 0);
        DBG_DUMP(DebugDump3216());

        // Release the holder. If this is the last release on
        // the holder, the proxy would be destroyed. Hence,
        // we should not use any member variables hereafter.
        ReleaseHolder(ptoThis->pphHolder, ProxyType);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut ReleaseProxy3216(%p) => %ld,%ld\n",
                 NestingLevelString(), ptoThis, dwLocalRefs, dwRefs));

    return dwLocalRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::RemoveProxy3216, public
//
//  Synopsis:   Destroys the given proxy
//
//  Arguments:  [pto] - Flat proxy pointer
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
void CThkMgr::RemoveProxy3216(THUNK3216OBJ *pto)
{
    // Revoke the assosiation between the proxy and
    // the 16-bit interface
    if(!(pto->grfFlags & PROXYFLAG_PUNKOUTER)) {
#if DBG==1
        thkAssert(_pProxyTbl3216->RemoveKey(pto->vpvThis16));
#else
        _pProxyTbl3216->RemoveKey(pto->vpvThis16);
#endif
    }

    // Release the holder if needed
    if(pto->cRefLocal > 0)
        ReleaseHolder(pto->pphHolder, PROXYFLAG_NONE);

    // Check if the proxy is locked
    if(!(pto->grfFlags & PROXYFLAG_LOCKED)) {
#if DBG == 1
        // In debug builds, mark the proxy dead
        pto->dwSignature = PSIG3216DEAD;

        // Return the proxy to free list
        if (!fSaveProxy)
#endif
        {
            thkAssert(pto->pphHolder);
            pto->pphHolder = NULL;
            flFreeList32.FreeElement((DWORD)pto);
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::PrepareForCleanup, public
//
//  Synopsis:   Marks the 3216 Proxies so that OLE32 cannot call them.
//
//  Arguments:  -none-
//
//  History:    24-Aug-94       BobDay  Created
//
//----------------------------------------------------------------------------

void CThkMgr::PrepareForCleanup( void )
{
    POSITION pos;
    DWORD dwKey;
    THUNK3216OBJ *pto3216;

    //
    // CODEWORK: OLE32 should be setup so that it doesn't callback while the
    // thread is detaching.  Then this function becomes obsolete.
    //

    // Check if callbacks were disabled earlier
    if(AreCallbacksAllowed())
    {
        // Disable callbacks on this thread as the 16-bit TASK state has
        // been reclaimed by NTVDM by now
        DisableCallbacks();

        // delete the 3216 proxy table
        pos = _pProxyTbl3216->GetStartPosition();

        while (pos)
        {
			pto3216 = NULL;

            _pProxyTbl3216->GetNextAssoc(pos, dwKey, (void FAR* FAR&) pto3216);

			if (pto3216 != NULL)
			{
				thkDebugOut((DEB_IWARN, "Preparing 3216 Proxy for cleanup: "
							 "%08lX %08lX %s\n",
							 pto3216,
							 pto3216->vpvThis16,
							 IidIdxString(pto3216->iidx)));

				pto3216->grfFlags |= PROXYFLAG_CLEANEDUP;
			}
        }
    }
}

#if DBG == 1
void CThkMgr::DebugDump3216()
{
    THUNK3216OBJ *pto3216;
    DWORD dwKey;
    POSITION pos;

    thkDebugOut((DEB_THUNKMGR, "%s DebugDump3216\n",NestingLevelString()));

    pos = _pProxyTbl3216->GetStartPosition();
    while (pos)
    {
        _pProxyTbl3216->GetNextAssoc(pos, dwKey, (void FAR* FAR&) pto3216);
        thkDebugOut((DEB_THUNKMGR,
                     "%s Proxy3216:Key:%p->%p, (%s) (%d,%d)\n",
                     NestingLevelString(), dwKey, pto3216,
                     IidIdxString(pto3216->iidx), pto3216->cRefLocal,
                     pto3216->cRef));
    }
}


void CThkMgr::DebugDump1632()
{
    THUNK1632OBJ UNALIGNED *pto1632;
    DWORD dwKey;
    VPVOID vpv;
    POSITION pos;

    thkDebugOut((DEB_THUNKMGR, "%s DebugDump1632\n",NestingLevelString()));

    pos = _pProxyTbl1632->GetStartPosition();
    while (pos)
    {
        _pProxyTbl1632->GetNextAssoc(pos, dwKey, (void FAR* FAR&) vpv);
        pto1632 = FIXVDMPTR(vpv, THUNK1632OBJ);
        thkDebugOut((DEB_THUNKMGR,
                     "%s Proxy1632:key:%p->%p, (%s) (%d,%d)\n",
                     NestingLevelString(), dwKey, pto1632,
                     IidIdxString(pto1632->iidx), pto1632->cRefLocal,
                     pto1632->cRef));
        RELVDMPTR(vpv);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\dbgitbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dbgitbl.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "dbgint.cxx"
#if DBG == 1

INTERFACENAMES inInterfaceNames[] =
{
    "IUnknown", apszIUnknownNames
,    "IClassFactory", apszIClassFactoryNames
,    "IMarshal", apszIMarshalNames
,    "IStdMarshalInfo", apszIStdMarshalInfoNames
,    "IMessageFilter", apszIMessageFilterNames
,    "IExternalConnection", apszIExternalConnectionNames
,    "IEnumString", apszIEnumStringNames
,    "IEnumUnknown", apszIEnumUnknownNames
,    "IEnumSTATSTG", apszIEnumSTATSTGNames
,    "ILockBytes", apszILockBytesNames
,    "IStream", apszIStreamNames
,    "IStorage", apszIStorageNames
,    "IRootStorage", apszIRootStorageNames
,    "IEnumFORMATETC", apszIEnumFORMATETCNames
,    "IEnumSTATDATA", apszIEnumSTATDATANames
,    "IDataObject", apszIDataObjectNames
,    "IViewObject", apszIViewObjectNames
,    "IViewObject2", apszIViewObject2Names
,    "IAdviseSink", apszIAdviseSinkNames
,    "IAdviseSink2", apszIAdviseSink2Names
,    "IDataAdviseHolder", apszIDataAdviseHolderNames
,    "IOleCache", apszIOleCacheNames
,    "IOleCache2", apszIOleCache2Names
,    "IOleCacheControl", apszIOleCacheControlNames
,    "IDropTarget", apszIDropTargetNames
,    "IDropSource", apszIDropSourceNames
,    "IPersist", apszIPersistNames
,    "IPersistStorage", apszIPersistStorageNames
,    "IPersistStream", apszIPersistStreamNames
,    "IPersistFile", apszIPersistFileNames
,    "IBindCtx", apszIBindCtxNames
,    "IMoniker", apszIMonikerNames
,    "IRunningObjectTable", apszIRunningObjectTableNames
,    "IEnumMoniker", apszIEnumMonikerNames
,    "IEnumOLEVERB", apszIEnumOLEVERBNames
,    "IOleObject", apszIOleObjectNames
,    "IOleClientSite", apszIOleClientSiteNames
,    "IRunnableObject", apszIRunnableObjectNames
,    "IParseDisplayName", apszIParseDisplayNameNames
,    "IOleContainer", apszIOleContainerNames
,    "IOleItemContainer", apszIOleItemContainerNames
,    "IOleAdviseHolder", apszIOleAdviseHolderNames
,    "IOleLink", apszIOleLinkNames
,    "IOleWindow", apszIOleWindowNames
,    "IOleInPlaceObject", apszIOleInPlaceObjectNames
,    "IOleInPlaceActiveObject", apszIOleInPlaceActiveObjectNames
,    "IOleInPlaceUIWindow", apszIOleInPlaceUIWindowNames
,    "IOleInPlaceFrame", apszIOleInPlaceFrameNames
,    "IOleInPlaceSite", apszIOleInPlaceSiteNames
,    "IRpcChannelBuffer", apszIRpcChannelBufferNames
,    "IRpcProxyBuffer", apszIRpcProxyBufferNames
,    "IRpcStubBuffer", apszIRpcStubBufferNames
,    "IPSFactoryBuffer", apszIPSFactoryBufferNames
,    "IRpcChannel", apszIRpcChannelNames
,    "IRpcProxy", apszIRpcProxyNames
,    "IRpcStub", apszIRpcStubNames
,    "IPSFactory", apszIPSFactoryNames
};

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\dbgapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dbgapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#if DBG == 1

char *apszApiNames[] =
{
    "CoInitialize"
,    "CoUninitialize"
,    "CoGetClassObject"
,    "CoRegisterClassObject"
,    "CoRevokeClassObject"
,    "CoMarshalInterface"
,    "CoUnmarshalInterface"
,    "CoReleaseMarshalData"
,    "CoDisconnectObject"
,    "CoLockObjectExternal"
,    "CoGetStandardMarshal"
,    "CoIsHandlerConnected"
,    "CoFreeAllLibraries"
,    "CoFreeUnusedLibraries"
,    "CoCreateInstance"
,    "CLSIDFromString"
,    "CoIsOle1Class"
,    "ProgIDFromCLSID"
,    "CLSIDFromProgID"
,    "CoCreateGuid"
,    "CoFileTimeToDosDateTime"
,    "CoDosDateTimeToFileTime"
,    "CoFileTimeNow"
,    "CoRegisterMessageFilter"
,    "CoGetTreatAsClass"
,    "CoTreatAsClass"
,    "DllGetClassObject"
,    "StgCreateDocfile"
,    "StgCreateDocfileOnILockBytes"
,    "StgOpenStorage"
,    "StgOpenStorageOnILockBytes"
,    "StgIsStorageFile"
,    "StgIsStorageILockBytes"
,    "StgSetTimes"
,    "CreateDataAdviseHolder"
,    "CreateDataCache"
,    "BindMoniker"
,    "MkParseDisplayName"
,    "MonikerRelativePathTo"
,    "MonikerCommonPrefixWith"
,    "CreateBindCtx"
,    "CreateGenericComposite"
,    "GetClassFile"
,    "CreateFileMoniker"
,    "CreateItemMoniker"
,    "CreateAntiMoniker"
,    "CreatePointerMoniker"
,    "GetRunningObjectTable"
,    "ReadClassStg"
,    "WriteClassStg"
,    "ReadClassStm"
,    "WriteClassStm"
,    "WriteFmtUserTypeStg"
,    "ReadFmtUserTypeStg"
,    "OleInitialize"
,    "OleUninitialize"
,    "OleQueryLinkFromData"
,    "OleQueryCreateFromData"
,    "OleCreate"
,    "OleCreateFromData"
,    "OleCreateLinkFromData"
,    "OleCreateStaticFromData"
,    "OleCreateLink"
,    "OleCreateLinkToFile"
,    "OleCreateFromFile"
,    "OleLoad"
,    "OleSave"
,    "OleLoadFromStream"
,    "OleSaveToStream"
,    "OleSetContainedObject"
,    "OleNoteObjectVisible"
,    "RegisterDragDrop"
,    "RevokeDragDrop"
,    "DoDragDrop"
,    "OleSetClipboard"
,    "OleGetClipboard"
,    "OleFlushClipboard"
,    "OleIsCurrentClipboard"
,    "OleCreateMenuDescriptor"
,    "OleSetMenuDescriptor"
,    "OleDestroyMenuDescriptor"
,    "OleDraw"
,    "OleRun"
,    "OleIsRunning"
,    "OleLockRunning"
,    "CreateOleAdviseHolder"
,    "OleCreateDefaultHandler"
,    "OleCreateEmbeddingHelper"
,    "OleRegGetUserType"
,    "OleRegGetMiscStatus"
,    "OleRegEnumFormatEtc"
,    "OleRegEnumVerbs"
,    "OleConvertIStorageToOLESTREAM"
,    "OleConvertOLESTREAMToIStorage"
,    "OleConvertIStorageToOLESTREAMEx"
,    "OleConvertOLESTREAMToIStorageEx"
,    "OleDoAutoConvert"
,    "OleGetAutoConvert"
,    "OleSetAutoConvert"
,    "GetConvertStg"
,    "SetConvertStg"
,    "ReadOleStg"
,    "WriteOleStg"
};

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\apinot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       apinot.cxx
//
//  Contents:   Implementation of non-API thunks
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <thunkapi.hxx>
#include <wownt32.h>
#include "olethk32.hxx"
#include "apinot.hxx"
#include "tlsthk.hxx"

//
// The following is a global static used by OLE32 to call back into
// this DLL. There is no static data associated with the static, so
// it merely defines a virtual interface that OLE32 can use.
//

OleThunkWOW g_thkOleThunkWOW;

//
// The following API is exported from WOW32.DLL. There is no global include
// file that it exists in yet.
//
extern "C" BOOL WINAPI WOWFreeMetafile( HANDLE h32 );

//+---------------------------------------------------------------------------
//
//  Function:   CoInitializeNot, public
//
//  Synopsis:   Thunks for the 16-bit applications call to CoInitialize
//
//  Arguments:  [lpmalloc] - Parameter from the 16-bit world
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) CoInitializeNot( LPMALLOC lpMalloc )
{
    HRESULT     hresult;

    hresult = CoInitializeWOW( lpMalloc, &g_thkOleThunkWOW );

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   OleInitializeNot, public
//
//  Synopsis:   Thunks for the 16-bit applications call to OleInitialize
//
//  Arguments:  [lpmalloc] - Parameter from the 16-bit world
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) OleInitializeNot( LPMALLOC lpMalloc )
{
    HRESULT     hresult;

    hresult = OleInitializeWOW( lpMalloc, &g_thkOleThunkWOW );

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDelayedClassFactories
//
//  Synopsis:   This function is called to actually do the registration of
//		the delayed class factories.
//
//  Effects:    When the application specific 'trigger' is hit
//		(ie OleRegGetUserType for WordPerfect), this routine is
//		called to actually do all of the delayed class factory
//		registrations.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:	nothing
//
//  History:    4-18-95   kevinro   Created
//
//----------------------------------------------------------------------------
void RegisterDelayedClassFactories()
{
    thkDebugOut((DEB_ITRACE,
		 "_IN RegisterDelayedClassFactories()\n"));

    PThreadData pdata;
    IUnknown *punk;
    HRESULT hr;
    DelayedRegistrationTable *pTable = NULL;
    DelayRegistration *pdelayed;
    DWORD dwReg;

    int i;
    //
    // Get the thread specific data and table to determine if there are
    // any delayed registrations. If not, just call the real routine.
    //
    pdata = TlsThkGetData();

    if (pdata == NULL)
    {
	goto exitRtn;
    }

    if ((pTable = pdata->pDelayedRegs) == NULL)
    {
	goto exitRtn;
    }

    //
    //
    //
    for (i = 0 ; i < MAX_DELAYED_REGISTRATIONS ; i++)
    {
	pdelayed = &(pTable->_Entries[i]);

	if((pdelayed->_punk != NULL) && (pdelayed->_dwRealKey == 0))
	{
	    hr    = CoRegisterClassObject(pdelayed->_clsid,
					  pdelayed->_punk,
					  pdelayed->_dwClsContext,
					  pdelayed->_flags,
					  &(pdelayed->_dwRealKey));
            if (FAILED(hr))
	    {
		thkDebugOut((DEB_ERROR,
			     "RegisterDelayedClassFactory gets %x\n",hr));
	    }
	}
    }

exitRtn:

    thkDebugOut((DEB_ITRACE,
		 "OUT RegisterDelayedClassFactories()\n"));

}
//+---------------------------------------------------------------------------
//
//  Function:   CoRevokeClassObjectNot
//
//  Synopsis:   Unregisters a class object that might have been delayed
//
//  Effects:	The 16-bit API CoRevokeClassObject has been directed to this
//		routine. This routine will check the list of interfaces that
//		have been registered, and will try to determine if the key
//		needs to be translated.
//
//  Arguments:  [dwKey] -- Key to revoke
//
//  History:    4-18-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CoRevokeClassObjectNot( DWORD dwKey)
{
    thkDebugOut((DEB_ITRACE,
		 "_IN CoRevokeClassObjectNot(dwKey = %x)\n",
		 dwKey));

    PThreadData pdata;
    IUnknown *punk;
    HRESULT hr;
    DelayedRegistrationTable *pTable = NULL;

    DWORD dwReg = ~dwKey;

    //
    // Get the thread specific data and table to determine if there are
    // any delayed registrations. If not, just call the real routine.
    //
    pdata = TlsThkGetData();

    if (pdata == NULL)
    {
	goto exitRtn;
    }

    if ((pTable = pdata->pDelayedRegs) == NULL)
    {
	goto exitRtn;
    }

    //
    // the 'fake' key is really the bitwise not of the index
    //

    if ( dwReg >= MAX_DELAYED_REGISTRATIONS)
    {
	goto exitRtn;
    }

    if(pTable->_Entries[dwReg]._punk != NULL)
    {
	punk = pTable->_Entries[dwReg]._punk;
	pTable->_Entries[dwReg]._punk = NULL;

	dwKey = pTable->_Entries[dwReg]._dwRealKey;
	pTable->_Entries[dwReg]._dwRealKey = 0;

	//
	// The class object table normally does an addref on the class factory.
	// We are also holding an addref on the punk. Release it.
	//
	if (punk != NULL)
	{
	    punk->Release();

	    //
	    // If the real key is zero, then we never did actually finish
	    // the registration. In this case, we return S_OK, because we
	    // are faking the app out anyway. This might happen if the app
	    // decides to shutdown for some reason without triggering the
	    // operation that causes us to register its class objects
	    //
	    if (dwKey == 0)
	    {
		hr = S_OK;
                goto exitNow;
	    }
	}
    }

exitRtn:

    hr = CoRevokeClassObject(dwKey);

exitNow:
    thkDebugOut((DEB_ITRACE,"OUT CoRevokeClassObjectNot():%x\n",hr));
    return(hr);

}
//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObjectDelayed
//
//  Synopsis:   Delay the registration of class objects. Some applications,
//		such as Word Perfect 6.1, register their class objects then
//		do peek message operations BEFORE they are fully initialized.
//		This causes problems because we can call in and do
//		CreateInstance calls before they are ready for them. This
//		wonderful hack will delay the registration of class objects
//		until someone calls RegisterClassObjectsNow(), which is
//		called when we know it is safe.
//
//		Novell knows about this hack, and promised not to change
//		the 16-bit code on us.
//
//  Effects:	Store all of the registration information in an array, and
//		return a special key value.
//		
//
//  Arguments:  ( Same as CoRegisterClassObject)
//
//  Requires:	The associated routine CoUnregisterClassObjectDelayed needs
//		to be called in the CoRevokeClassObject path to check to see
//		if the key being passed in is a special key. That way we
//		can translate the key before calling the real routine.
//
//		The special key value is not of the key
//
//  Returns:	S_OK or E_UNEXPECTED
//
//  History:    4-14-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CoRegisterClassObjectDelayed( REFCLSID refclsid, LPUNKNOWN punk,
                                  DWORD dwClsContext, DWORD flags, DWORD *pdwReg)
{
    thkDebugOut((DEB_ITRACE,"_IN CoRegisterClassObjectDelayed\n"));
    PThreadData pdata;
    int i;
    DelayedRegistrationTable *pTable = NULL;

    //
    // Assume this is going to fail
    //
    HRESULT hr = E_UNEXPECTED;
    *pdwReg = 0;

    pdata = TlsThkGetData();
    if (pdata == NULL)
    {
	goto exitRtn;
    }

    if ((pTable = pdata->pDelayedRegs) == NULL)
    {
	pTable = pdata->pDelayedRegs = new DelayedRegistrationTable();
    }

    if (pTable != NULL)
    {
	for (i = 0 ; i < MAX_DELAYED_REGISTRATIONS ; i++)
	{
	    if(pTable->_Entries[i]._punk == NULL)
	    {
		pTable->_Entries[i]._punk = punk;
		pTable->_Entries[i]._clsid = refclsid;
		pTable->_Entries[i]._dwClsContext = dwClsContext;
		pTable->_Entries[i]._flags = flags;
		//
		// The class object table normally does an
		// addref on the class factory. We will hang on to this
		// to keep the class factory and the 3216 proxy alive
		//
		punk->AddRef();
		*pdwReg = ~i;
		hr = S_OK;
		break;
	    }
	}
    }

exitRtn:
    thkDebugOut((DEB_ITRACE,"OUT CoRegisterClassObjectDelayed() : %x\n",hr));
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObjectNot, public
//
//  Synopsis:   Thunks for the 16-bit applications call CoRegisterClassObject
//              Here we check for the registered class objects to set the
//              thread's compatability bits.
//
//  Arguments:  [refclsid] - CLSID for the class to register
//              [punk]     - ClassFactory interface
//              [dwClsContext] - Class context
//              [flags]        - flags
//              [lpdwreg]      - register
//
//  Returns:    Appropriate status code
//
//  History:    18-Jul-94   BobDay  Created
//
//----------------------------------------------------------------------------

EXTERN_C const CLSID CDECL CLSID_EXCEL5_WORKSHEET =
     { 0x020810, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46}};

EXTERN_C const CLSID CDECL CLSID_WORD6_DOCUMENT =
     { 0x020900, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46}};

EXTERN_C const CLSID CDECL CLSID_WPWIN61 =
     { 0x89FE3FE3, 0x9FF6, 0x101B, {0xB6, 0x78, 0x04, 0x02, 0x1C, 0x00, 0x70, 0x02}};

EXTERN_C const CLSID CDECL CLSID_WPWIN61_FILE =
     { 0x1395F281, 0x4326, 0x101b, {0x8B, 0x9A, 0xCE, 0x29, 0x3E, 0xF3, 0x84, 0x49}};

EXTERN_C const CLSID CDECL CLSID_IKITARO_130 =
     { 0x02B501, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46}};


DEFINE_OLEGUID(CLSID_EXCEL5_WORKSHEET, 0x20810, 0, 0);



STDAPI_(DWORD) CoRegisterClassObjectNot( REFCLSID refclsid, LPUNKNOWN punk,
                                         DWORD dwClsContext, DWORD flags,
                                         LPDWORD lpdwreg )
{
    //
    // Excel didn't AddRef the IOleObjectClientSite returned from
    // the IOleObject::GetClientSite method.
    //
    if ( IsEqualCLSID(refclsid,CLSID_EXCEL5_WORKSHEET) )
    {
        DWORD   dw;

        dw = TlsThkGetAppCompatFlags();
        TlsThkSetAppCompatFlags(dw | OACF_CLIENTSITE_REF);

        thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_CLIENTSITE_REF enabled\n"));
    }

    //
    // WinWord didn't call OleSetMenuDescriptor(NULL) during
    // IOleInPlaceFrame::RemoveMenus.  We do it for them.
    //
    // Also WinWord thinks GDI objects like palettes and bitmaps can be
    // transferred on HGLOBALs during GetData calls.  In order to thunk
    // them properly, we need to patch up the STGMEDIUMS given to use
    // by word.  This is controlled by OACF_USEGDI.
    //
    // YAWC: Word chokes and dies because it fails to disconnect some of its
    // objects. During shutdown of a link, for example, cleaning up the stdid
    // table causes WORD to fault.
    //
    else if ( IsEqualCLSID(refclsid,CLSID_WORD6_DOCUMENT) )
    {
        DWORD   dw;

        dw = TlsThkGetAppCompatFlags();
        TlsThkSetAppCompatFlags(dw | OACF_RESETMENU | OACF_USEGDI | OACF_NO_UNINIT_CLEANUP);

        thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_RESETMENU enabled\n"));
	thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_USEGDI enabled\n"));
	thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_NO_UNINIT_CLEANUP enabled\n"));
    }
    else if ( IsEqualCLSID(refclsid,CLSID_WPWIN61) )
    {
        thkDebugOut((DEB_WARN,"WordPerfect hack triggered\n"));
        thkDebugOut((DEB_WARN,"Intercepting CoRegisterClassObject(WPWIN61)\n"));

	return CoRegisterClassObjectDelayed( refclsid,punk,dwClsContext,flags,lpdwreg);

    }
    else if ( IsEqualCLSID(refclsid,CLSID_WPWIN61_FILE) )
    {
        thkDebugOut((DEB_WARN,"WordPerfect hack triggered\n"));
        thkDebugOut((DEB_WARN,"Intercepting CoRegisterClassObject(WPWIN61_FILE)\n"));
	return CoRegisterClassObjectDelayed( refclsid,punk,dwClsContext,flags,lpdwreg);
    }
    else if ( IsEqualCLSID(refclsid,CLSID_IKITARO_130) )
    {
	// Note: Ikitaro queries for IViewObject and uses it as IViewObject2
        DWORD   dw = TlsThkGetAppCompatFlags();
        thkDebugOut((DEB_WARN,"Ikitaro hack triggered\n"));
        TlsThkSetAppCompatFlags(dw | OACF_IVIEWOBJECT2);
    }

    return (DWORD)CoRegisterClassObject( refclsid, punk, dwClsContext,
                                     flags, lpdwreg );
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegGetUserTypeNot
//
//  Synopsis:	Adds a hook for a WordPerfect hack. Check out the functions
//		CoRegisterClassObjectDelayed and
//		RegisterDelayedClassFactories for details. In essence, when
//		this function is called for the WPWIN61 classID, we know
//		that it is safe to register all of the delayed class objects.
//		This determination was done by debugging Wordperfect. When
//		they call this API, then are actually done initializing the
//		internals of their app.
//
//  Effects:
//
//  History:    4-18-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(DWORD)
OleRegGetUserTypeNot(REFCLSID clsid,DWORD dwFormOfType,LPOLESTR *pszUserType)
{
    //
    // Wordperfect has a bug. When they call OleRegGetUserType for their
    // classid, we know that it is safe to register their class objects for
    // real.
    //
    // See CoRegisterClassObjectDelayed for details
    //
    if ( IsEqualCLSID(clsid,CLSID_WPWIN61) )
    {
	thkDebugOut((DEB_WARN,"Registering WordPerfects class objects\n"));
	RegisterDelayedClassFactories();
    }
    return OleRegGetUserType(clsid,dwFormOfType,pszUserType);
}
//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::LoadProcDll, public
//
//  Synopsis:   Callback function for 32-bit OLE to load a 16-bit DLL
//
//  Arguments:  [pszDllName] - Name of 16-bit DLL
//              [lpvpfnGetClassObject] - returned 16:16 address of
//                                                      "DllGetClassObject"
//              [lpvpfnCanUnloadNow] - returned 16:16 address of
//                                                      "DllCanUnloadNow"
//              [lpvhmodule] - returned 16-bit hmodule
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
OleThunkWOW::LoadProcDll(
    LPCTSTR pszDllName,
    LPDWORD lpvpfnGetClassObject,
    LPDWORD lpvpfnCanUnloadNow,
    LPDWORD lpvhmodule
)
{
    HRESULT hr;
    UINT    uiSize;
    VPSTR   vpstr16;
    VPVOID  vplpds16;
    LOADPROCDLLSTRUCT UNALIGNED *lplpds16;
    char string[256];

    // Ensure that Interop is enabled
    Win4Assert(gfIteropEnabled);
    // Ensure that callbacks are allowed on this thread
    Win4Assert(TlsThkGetThkMgr()->AreCallbacksAllowed());

    uiSize = lstrlen(pszDllName) + 1;

    vpstr16 = STACKALLOC16(uiSize*sizeof(TCHAR));
    if (vpstr16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = Convert_LPOLESTR_to_VPSTR(pszDllName, vpstr16,
                                   uiSize, uiSize*sizeof(TCHAR));
    if (FAILED(hr))
    {
        goto EH_vpstr16;
    }

    vplpds16 = STACKALLOC16(sizeof(LOADPROCDLLSTRUCT));
    if (vplpds16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto EH_vpstr16;
    }

    lplpds16 = FIXVDMPTR(vplpds16, LOADPROCDLLSTRUCT);

    lplpds16->vpDllName          = vpstr16;
    lplpds16->vpfnGetClassObject = 0;
    lplpds16->vpfnCanUnloadNow   = 0;
    lplpds16->vhmodule           = 0;

    RELVDMPTR(vplpds16);

    hr = CallbackTo16( gdata16Data.fnLoadProcDll, vplpds16 );

    if (SUCCEEDED(hr))
    {
        lplpds16 = FIXVDMPTR(vplpds16, LOADPROCDLLSTRUCT);
        *lpvpfnGetClassObject = lplpds16->vpfnGetClassObject;
        *lpvpfnCanUnloadNow = lplpds16->vpfnCanUnloadNow;
        *lpvhmodule = lplpds16->vhmodule;
        RELVDMPTR(vplpds16);
        thkDebugOut((DEB_WARN, "Loaded COM DLL: %ws with HMODULE: 0x%x\n",
                     pszDllName, *lpvhmodule));
    }
    else
    {
        hr = CO_E_DLLNOTFOUND;
    }

    STACKFREE16(vplpds16, sizeof(LOADPROCDLLSTRUCT));

 EH_vpstr16:
    STACKFREE16(vpstr16,uiSize*sizeof(TCHAR));

 Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::UnloadProcDll, public
//
//  Synopsis:   Callback function for 32-bit OLE to unload a 16-bit DLL
//
//  Arguments:  [vhmodule] - 16-bit hmodule
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
OleThunkWOW::UnloadProcDll(
    HMODULE   vhmodule
)
{
    HRESULT hr = S_OK;

    // Ensure that Interop is enabled and callbacks are 
    // not allowed on this thread
    if(gfIteropEnabled && TlsThkGetThkMgr()->AreCallbacksAllowed())
        hr = CallbackTo16(gdata16Data.fnUnloadProcDll, HandleToUlong(vhmodule));

    return(hr); 
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::CallGetClassObject, public
//
//  Synopsis:   Callback function for 32-bit OLE to call 16-bit
//              DllGetClassObject
//
//  Arguments:  [vpfnGetClassObject] - 16:16 address of DllGetClassObject
//              [rclsid] - CLSID of object
//              [riid] - IID of interface on object
//              [ppv] - returned object interface
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
OleThunkWOW::CallGetClassObject(
    DWORD       vpfnGetClassObject,
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID FAR *ppv
)
{
    DWORD       dwResult;
    VPVOID      vpcgcos16;
    CALLGETCLASSOBJECTSTRUCT UNALIGNED *lpcgcos16;
    VPVOID      iface16;
    IIDIDX      iidx;
    IUnknown    *punkThis32;
    CThkMgr     *pThkMgr;
    ThreadData  *ptd;

    // Ensure that Interop is enabled
    Win4Assert(gfIteropEnabled);
    // Ensure that callbacks are allowed on this thread
    Win4Assert(TlsThkGetThkMgr()->AreCallbacksAllowed());

    ptd = TlsThkGetData();
    if (ptd == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: CallGetClassObject refused\n"));

        dwResult = (DWORD)E_FAIL;
        goto Exit;
    }
    pThkMgr = ptd->pCThkMgr;

    vpcgcos16 = STACKALLOC16(sizeof(CALLGETCLASSOBJECTSTRUCT));
    if (vpcgcos16 == 0)
    {
        dwResult = (DWORD)E_OUTOFMEMORY;
        goto Exit;
    }

    lpcgcos16 = FIXVDMPTR(vpcgcos16, CALLGETCLASSOBJECTSTRUCT);

    lpcgcos16->vpfnGetClassObject = vpfnGetClassObject;
    lpcgcos16->clsid              = rclsid;
    lpcgcos16->iid                = riid;
    lpcgcos16->iface              = 0;

    RELVDMPTR(vpcgcos16);

    dwResult = CallbackTo16( gdata16Data.fnCallGetClassObject, vpcgcos16 );


    if ( SUCCEEDED(dwResult) )
    {
        lpcgcos16 = FIXVDMPTR(vpcgcos16, CALLGETCLASSOBJECTSTRUCT);
        iface16 = lpcgcos16->iface;

        iidx = IidToIidIdx(riid);

        // We're on the way out creating a proxy so set the state
        // appropriately
        pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT32);

        // Get a 32-bit proxy object for the 16-bit object
        punkThis32 = pThkMgr->FindProxy3216(NULL, iface16, NULL, iidx, FALSE, NULL);

        pThkMgr->SetThkState(THKSTATE_NOCALL);

        // Set the out param
        *(IUnknown **)ppv = punkThis32;

        // As this is an OUT parameter, release the actual 16-bit interface
        // This could be the last release on the 16-bit interface, if the
        // proxy was not successfully created
        ReleaseOnObj16(iface16);

        if(punkThis32 == NULL) {
            dwResult = (DWORD)E_OUTOFMEMORY;
        }

        RELVDMPTR(vpcgcos16);
    }
    else {  // need to map dwResult only for failure cases (see hmMappings)
        dwResult = TransformHRESULT_1632( dwResult );
    }

    STACKFREE16(vpcgcos16, sizeof(CALLGETCLASSOBJECTSTRUCT));

 Exit:
    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::CallCanUnloadNow, public
//
//  Synopsis:   Callback function for 32-bit OLE to call 16-bit
//              CanUnloadNow
//
//  Arguments:  [vpfnCanUnloadNow] - 16:16 address of DllCanUnloadNow
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP OleThunkWOW::CallCanUnloadNow(
    DWORD       vpfnCanUnloadNow)
{
    HRESULT hr = S_OK;

    // Ensure that Interop is enabled and callbacks are 
    // not allowed on this thread
    if(gfIteropEnabled && TlsThkGetThkMgr()->AreCallbacksAllowed())
        hr = CallbackTo16(gdata16Data.fnCallCanUnloadNow, vpfnCanUnloadNow);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::GetThunkManager, public
//
//  Synopsis:   Callback function for 32-bit OLE to retrieve the thunkmanager
//
//  Arguments:  [ppThkMgr] - Thunk manager return
//
//  Returns:    Appropriate status code
//
//  History:    11-May-94   JohannP  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP OleThunkWOW::GetThunkManager(IThunkManager **ppThkMgr)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn OleThunkWOW::GetThunkManager\n",
                 NestingLevelString()));

    thkAssert(ppThkMgr != NULL);

    IUnknown *pUnk = TlsThkGetThkMgr();
    thkAssert(pUnk && "Invalid Thunkmanager");

    *ppThkMgr = (IThunkManager *)pUnk;
    pUnk->AddRef();

    thkDebugOut((DEB_THUNKMGR, "%sOut OleThunkWOW::GetThunkManager: (%p)\n",
                 NestingLevelString(), pUnk));

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::WinExec16, public
//
//  Synopsis:   Callback function for 32-bit OLE to run an application
//
//  Arguments:  [pszCommandLine] - command line for WinExec
//              [usShow] - fShow for WinExec
//
//  Returns:    Appropriate status code
//
//  History:    27-Jul-94   AlexT   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP OleThunkWOW::WinExec16(
    LPCOLESTR pszCommandLine,
    USHORT usShow
)
{
    HRESULT hr;
    UINT    uiSize;
    VPSTR   vpstr16;
    VPVOID  vplpds16;
    WINEXEC16STRUCT UNALIGNED *lpwes16;
    ULONG   ulRet;

    // Ensure that Interop is enabled
    Win4Assert(gfIteropEnabled);
    // Ensure that callbacks are allowed on this thread
    Win4Assert(TlsThkGetThkMgr()->AreCallbacksAllowed());

    uiSize = lstrlenW(pszCommandLine) + 1;

    vpstr16 = STACKALLOC16(uiSize*2);
    if (vpstr16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = Convert_LPOLESTR_to_VPSTR(pszCommandLine, vpstr16,
                                   uiSize, uiSize*2);
    if (FAILED(hr))
    {
        goto EH_vpstr16;
    }

    vplpds16 = STACKALLOC16(sizeof(WINEXEC16STRUCT));
    if (vplpds16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto EH_vpstr16;
    }

    lpwes16 = FIXVDMPTR(vplpds16, WINEXEC16STRUCT);

    lpwes16->vpCommandLine       = vpstr16;
    lpwes16->vusShow             = usShow;

    RELVDMPTR(vplpds16);

    ulRet = CallbackTo16( gdata16Data.fnWinExec16, vplpds16 );
    thkDebugOut((DEB_ITRACE,
                 "CallbackTo16(WinExec16) returned %ld\n", ulRet));

    //  According to the Windows spec, return values greater than 31 indicate
    //  success.

    if (ulRet > 31)
    {
        hr = S_OK;
    }
    else if (0 == ulRet)
    {
        //  0 indicates lack of some kind of resource
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ulRet);
    }

    STACKFREE16(vplpds16, sizeof(WINEXEC16STRUCT));

 EH_vpstr16:
    STACKFREE16(vpstr16, uiSize*2);

 Exit:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::ConvertHwndToFullHwnd
//
//  Synopsis:   Converts a 16 bit HWND into a 32-bit HWND
//
//  Effects:    Since OLE32 doesn't directly link to WOW, this function allows
//		the DDE layer to access the routine that maps 16 bit HWND to
//		full 32-bit HWND's.
//
//  Arguments:  [hwnd] -- HWND to convert
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(HWND) OleThunkWOW::ConvertHwndToFullHwnd(HWND hwnd)
{
    return(FULLHWND_32((USHORT)hwnd));
}

//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::FreeMetaFile
//
//  Synopsis:   Calls wow to delete a metafile that has memory reserved in
//		the 16 bit address space
//
//  Effects:    Since OLE32 doesn't directly link to WOW, this function allows
//		the DDE layer to access the routine in WOW
//
//  Arguments:  [hmf] -- HANDLE to delete
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) OleThunkWOW::FreeMetaFile(HANDLE hmf)
{
    return(WOWFreeMetafile(hmf));
}



//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::YieldTask16, public
//
//  Synopsis:   Callback function for 32-bit OLE to yield
//
//  History:    08-Aug-94   Ricksa  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP OleThunkWOW::YieldTask16(void)
{
    WOWYield16();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	OleThunkWOW::DirectedYield, public
//
//  Synopsis:	Does a directed yield in the VDM.
//
//  History:	08-Aug-94   Rickhi  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP OleThunkWOW::DirectedYield(DWORD dwCalleeTID)
{
    WORD hTask16 = WOWHandle16((void *)dwCalleeTID, WOW_TYPE_HTASK);

    thkDebugOut((DEB_ITRACE, "WOWDirectedYield16(%x)\n", hTask16));

    WOWDirectedYield16(hTask16);

    thkDebugOut((DEB_ITRACE, "WOWDirectedYield16() returned\n"));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::PrepareForCleanup
//
//  Synopsis:   Prepares OLETHK32 for OLE32.DLL's cleanup.
//
//  Effects:    It does this by taking all of the remaining 3216 proxies
//              and marking them such that no callbacks into the 16-bit
//              world are possible.
//
//  Arguments:  -none-
//
//  History:    24-Aug-94   bobday    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(void) OleThunkWOW::PrepareForCleanup(void)
{
    CThkMgr *pcthkmgr;

    if ( TlsThkGetData() != NULL )
    {
        pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();

        //
        // Tell the thkmgr to prepare for cleaning itself up
        //
        pcthkmgr->PrepareForCleanup();
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::GetAppCompatibilityFlags
//
//  Synopsis:   Used to return the current THK app compatibility flags to
//		OLE32.DLL
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:    Flags defined in ih\thunkapi.hxx
//
//  History:    1-11-96   kevinro   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) OleThunkWOW::GetAppCompatibilityFlags(void)
{
    return(TlsThkGetAppCompatFlags());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\freelist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	freelist.cxx
//
//  Contents:	CFreeList implementations
//
//  History:	07-Jul-94	BobDay	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//
// Each element, when it is free, has a pointer stored within it that
// points to the next free element.  We can do this because we know that
// the element is free, all of its data is unused. These pointers are used
// as DWORDs since they can be virtual pointers (16:16).
//
#define CALC_NEXTPTR(lpElement) \
            ((LPDWORD)((DWORD)(lpElement) + m_iNextPtrOffset))

//
// Each block of elements has a pointer to the next block of elements. We
// allocate extra room for this pointer just after all of the elements within
// the block.  These pointers are used as DWORDs since they can be virtual
// pointers (16:16).

#define CALC_BLOCKNEXTPTR(lpBlock,dwElementSectionSize) \
            ((LPDWORD)((DWORD)(lpBlock) + (dwElementSectionSize)))

//
// Here are our global free lists, created on DLL load
// The block sizes are generally -1 to allow space for block
// list overhead
//
CFreeList flFreeList16(       // THUNK1632OBJ free list
    &mmodel16Public,
    sizeof(THUNK1632OBJ),
    63,
    FIELD_OFFSET(THUNK1632OBJ, pphHolder));

CFreeList flFreeList32(       // THUNK3216OBJ free list
    &mmodel32,
    sizeof(THUNK3216OBJ),
    63,
    FIELD_OFFSET(THUNK3216OBJ, pphHolder));

CFreeList flHolderFreeList(   // PROXYHOLDER free list
    &mmodel32,
    sizeof(PROXYHOLDER),
    63,
    FIELD_OFFSET(PROXYHOLDER, dwFlags));

CFreeList flRequestFreeList(  // IID request free list
    &mmodel32,
    sizeof(IIDNODE),
    7,
    FIELD_OFFSET(IIDNODE, pNextNode));

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::CFreeList
//
//  Arguments:  pmm - Memory model to use
//              iElementSize - The size of the structure being made into a
//                             free list. e.g. sizeof THUNK1632OBJ
//              iElementsPerBlock - How many elements to allocate at a time
//                                  (a block contains this many elements).
//              iNextPtrOffset - Offset within the element's structure for
//                               the place to store the free list's next
//                               element pointer.  Sometimes (for debugging,
//                               etc.) it is desirable to make this NOT 0
//                               (the beginning of the element structure).
//
//  Synopsis:   constructor for CFreeList class
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//              7-05-94   BobDay (Bob Day)   Changed it to be list based
//
//----------------------------------------------------------------------------
CFreeList::CFreeList( CMemoryModel *pmm,
                      UINT iElementSize,
                      UINT iElementsPerBlock,
                      UINT iNextPtrOffset )
{
    //
    // Save away the allocator information
    //
    m_pmm = pmm;
    m_iElementSize = iElementSize;
    m_iElementsPerBlock = iElementsPerBlock;
    m_iNextPtrOffset = iNextPtrOffset;

    //
    // Set the list of elements to empty
    //
    m_dwHeadElement = 0;
    m_dwTailElement = 0;

    //
    // Set the list of blocks to empty
    //
    m_dwHeadBlock  = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::AllocElement
//
//  Synopsis:   Allocates an element from the various blocks of elements
//              and allocates a new block if necessary.
//
//  Returns:    0 if failed to alloc an element,
//              otherwise the DWORD representing the alloc'd element.
//
//  History:    7-05-94   BobDay (Bob Day) Created
//
//----------------------------------------------------------------------------
DWORD CFreeList::AllocElement( void )
{
    DWORD   dwNewHeadBlock;
    DWORD   dwElementSectionSize;
    DWORD   dwBlockSize;
    LPVOID  lpBlock;
    UINT    iCnt;
    DWORD   dwElement;
    LPVOID  lpElement;
    LPDWORD lpElementNextPtr;

    //
    // If the list of available elements is empty, callback to the derived
    // class and make them add an entire new block of elements.
    //
    if ( m_dwHeadElement == 0 )
    {
        //
        // Allocate a new block
        //
        iCnt = m_iElementsPerBlock;
        dwElementSectionSize = m_iElementSize * m_iElementsPerBlock;

        //
        // Here we allocate an extra DWORD so that we can store in the block
        // the address of the next block.  In this way we have a list of
        // blocks so that when the time comes to free them, we can find them
        // all.
        //
        dwBlockSize = dwElementSectionSize + sizeof(DWORD);

        dwNewHeadBlock = m_pmm->AllocMemory( dwBlockSize );

        if ( dwNewHeadBlock == 0 )
        {
            //
            // Yikes, the block allocator failed!
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::AllocElement, AllocMemory failed\n"));
            return 0;
        }
        //
        // Now initialize the block and link it into the block list.
        //

        lpBlock = m_pmm->ResolvePtr( dwNewHeadBlock, dwBlockSize );
        if ( lpBlock == NULL )
        {
            //
            // Couldn't get a pointer to the block, some memory mapping
            // problem?
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::AllocElement, "
                         "ResolvePtr for block failed "
                         "for address %08lX, size %08lX\n",
                         dwNewHeadBlock, dwBlockSize ));
            // Try to return bad block to pool
            m_pmm->FreeMemory( dwNewHeadBlock );
            return 0;
        }

#if DBG == 1
        // 0xDE = Alloc'd but not init'd
        memset( lpBlock, 0xDE, dwBlockSize );
#endif

        //
        // Make this block point to the previous block
        //
        *CALC_BLOCKNEXTPTR(lpBlock,dwElementSectionSize) = m_dwHeadBlock;
        m_dwHeadBlock = dwNewHeadBlock;     // Update block list

        m_pmm->ReleasePtr(dwNewHeadBlock);

        //
        // Now initialize all of the elements within the block to be free.
        //
        // The below loop skips the first element, free's all of the remaining
        // ones.  This way we can return the first one and all of the rest will
        // be in accending order; The order doesn't really matter, but its
        // nice.
        //
        dwElement = dwNewHeadBlock;

        while ( iCnt > 1 )              // Free n-1 items (we skip the first)
        {
            --iCnt;
            dwElement += m_iElementSize;    // Skip to next one (miss 1st one)

            FreeElement( dwElement );
        }

        dwElement = dwNewHeadBlock;     // Use the first one as our alloc'd one
    }
    else
    {
        // We better have some blocks by now
        thkAssert( m_dwHeadBlock != 0 );

        // Better have a "end of list" too!
        thkAssert( m_dwTailElement != 0 );

        //
        // Grab an available element off the top (head) of the list.
        //
        dwElement = m_dwHeadElement;

        lpElement = m_pmm->ResolvePtr( dwElement, m_iElementSize );
        if ( lpElement == NULL )
        {
            //
            // Yikes, we weren't able to get a pointer to the element!
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::AllocElement, "
                         "ResolvePtr for element failed "
                         "for address %08lX, size %08lX\n",
                         dwElement, m_iElementSize ));
            return 0;
        }

        //
        // Update the list to reflect the fact that we just removed the head
        // and replace it with the one which was pointed to by the head.
        //
        lpElementNextPtr = CALC_NEXTPTR(lpElement);
        m_dwHeadElement = *lpElementNextPtr;

        m_pmm->ReleasePtr(dwElement);

        //
        // Also, if we are now at the end of the list, then the tail element
        // should point to nowhere (i.e. there is nothing to insert after).
        //
        if ( m_dwHeadElement == 0 )
        {
            m_dwTailElement = 0;
        }
    }

#if DBG == 1
    // Erase the memory being returned to highlight reuse of dead values

    lpElement = m_pmm->ResolvePtr( dwElement, m_iElementSize );
    memset( lpElement, 0xED, m_iElementSize );
    m_pmm->ReleasePtr(dwElement);

    thkDebugOut((DEB_ITRACE,
                 "CFreeList::AllocElement, allocated element at %08lX\n",
                 dwElement ));
#endif

    return dwElement;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::FreeElement
//
//  Synopsis:   Un-Allocates an element from the various blocks of elements,
//              basically put the element back on the free list.
//
//  Arguments:  dwElement - Element to free
//
//  Returns:    -none-  Asserts if failed.
//
//  History:    7-05-94   BobDay (Bob Day) Created
//
//----------------------------------------------------------------------------
void CFreeList::FreeElement( DWORD dwElement )
{
    LPVOID  lpElement;
    LPDWORD lpElementNextPtr;
    DWORD   dwResolved;

    //
    // First, make sure we can set this new element's next element pointer
    // to zero (he's going to be a the end of the list).
    //
    lpElement = m_pmm->ResolvePtr( dwElement, m_iElementSize );
    if ( lpElement == NULL )
    {
        //
        // Yikes, we couldn't get a pointer to this element's place to store
        // its next pointer.
        //
        thkDebugOut((DEB_ERROR,
                     "CFreeList::FreeElement, "
                     "ResolvePtr failed for free'd element\n"
                     "for address %08lX, size %08lX\n",
                     dwElement, m_iElementSize ));
        thkAssert(FALSE && "CFreeList::FreeElement, "
                  "Resolve Ptr failed for free'd element\n");
        return;
    }

#if DBG == 1
    // Fill memory so its values can't be reused
    if ( fZapProxy )        // Not doing this is important for
                            // the "PrepareForCleanup" processing the OLE32
                            // does on thread detach.  ZapProxy can be used
                            // to turn it back on.
    {
        memset(lpElement, 0xDD, m_iElementSize);
    }
#endif

    lpElementNextPtr = CALC_NEXTPTR(lpElement);

    *lpElementNextPtr = 0;  // Zap his next pointer since he'll be on the end

    m_pmm->ReleasePtr(dwElement);

    //
    // Add this element back onto the end (tail) of the list.
    //
    if ( m_dwTailElement == 0 )
    {
        //
        // Well, the list was empty, time to set it up
        //
        thkAssert( m_dwHeadElement == 0 );

        lpElementNextPtr = &m_dwHeadElement;
        dwResolved = 0;
    }
    else
    {
        //
        // Ok, the list wasn't empty, so we add this new one onto the end.
        //
        thkAssert( m_dwHeadElement != 0 );

        dwResolved = m_dwTailElement;
        lpElement = m_pmm->ResolvePtr( m_dwTailElement, m_iElementSize );
        if ( lpElement == NULL )
        {
            //
            // Oh no, we couldn't get a pointer to the next element pointer for
            // the guy who is currently the tail of the list.
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::FreeElement, "
                         "ResolvePtr failed for last element\n"
                         "for address %08lX, size %08lX\n",
                         m_dwTailElement, m_iElementSize ));
            thkAssert(FALSE && "CFreeList::FreeElement, "
                               "Resolve Ptr failed for last element\n");
            return;
        }

        lpElementNextPtr = CALC_NEXTPTR(lpElement);
    }

    //
    // Update our tail pointer to point to our newly free'd guy.
    //
    m_dwTailElement = dwElement;

    //
    // Make the last guy point to this newly free'd guy
    //
    *lpElementNextPtr = dwElement;

    if (dwResolved != 0)
    {
        m_pmm->ReleasePtr(dwResolved);
    }

    thkDebugOut((DEB_ITRACE,
                 "CFreeList::FreeElement, free'd element at %08lX\n",
                 dwElement ));
}

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::FreeMemoryBlocks
//
//  Arguments:  -none-
//
//  Returns:    -nothing-
//
//  Synopsis:   Called by derived destructors to allow them to free up their
//              contents before going away.
//
//  History:    7-05-94   BobDay (Bob Day)   Created it
//
//----------------------------------------------------------------------------

void CFreeList::FreeMemoryBlocks( void )
{
    DWORD   dwBlock;
    DWORD   dwElementSectionSize;
    DWORD   dwBlockSize;
    DWORD   dwNextBlock;
    LPVOID  lpBlock;

    //
    // Compute some constants for this list ahead of time
    //
    dwElementSectionSize = m_iElementSize * m_iElementsPerBlock;

    //
    // Add room for that extra DWORD, block next pointer. (See comment in
    // AllocElement where it allocates an extra DWORD)
    //
    dwBlockSize = dwElementSectionSize + sizeof(DWORD);

    //
    // Iterate through the list of blocks free'ing them
    //
    dwBlock = m_dwHeadBlock;

    while( dwBlock != 0 )
    {
        //
        // Find the next block ptr
        //
        lpBlock = m_pmm->ResolvePtr( dwBlock, dwBlockSize );
        if ( lpBlock == NULL )
        {
            //
            // If we get an error here, we just drop out of loop
            //
            dwNextBlock = 0;
        }
        else
        {
            dwNextBlock = *CALC_BLOCKNEXTPTR(lpBlock,dwElementSectionSize);

#if DBG == 1
            memset(lpBlock, 0xEE, dwBlockSize);
#endif

            m_pmm->ReleasePtr(dwBlock);
            m_pmm->FreeMemory( dwBlock );
        }
        dwBlock = dwNextBlock;
    }

    m_dwHeadElement = 0;
    m_dwTailElement = 0;
    m_dwHeadBlock = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\dllentry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dllentry.cxx
//
//  Contents:	DLL entry point code
//
//  History:	24-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

extern "C"
{
BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);
BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);
};

extern "C" BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason,
                                         LPVOID lpReserved)
{
    BOOL fRc;

    if ((dwReason == DLL_PROCESS_ATTACH) || (dwReason == DLL_THREAD_ATTACH))
    {
        // If this is an attach, initialize the Cruntimes first
        if (fRc = _CRT_INIT(hDll, dwReason, lpReserved))
        {
            fRc = LibMain(hDll, dwReason, lpReserved);
        }
    }
    else
    {
        // This is a detach so call the Cruntimes second
        LibMain(hDll, dwReason, lpReserved);
        fRc = _CRT_INIT(hDll, dwReason, lpReserved);
    }

    return fRc;
}

extern "C" BOOL __stdcall DllMain (HANDLE hDll, DWORD dwReason,
                                         LPVOID lpReserved)
{
    //  This is not currently used...but must be present to avoid
    //  an undefined symbol

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       headers.cxx
//
//  Contents:   Precompiled headers file
//
//  History:    21-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

extern "C" {
#include <malloc.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wownt32.h>
}

#include <ole2.h>
#include <olecoll.h>
#include <privguid.h>
#include <ole2sp.h>
#include <ole2com.h>
#include <utils.h>
#include <memapi.hxx>

#include <interop.hxx>
#include <wow32fn.h>
#include <thunkapi.hxx>
#include <stksw.hxx>
#include "mmodel.hxx"
#include "stalloc.hxx"
#include "nest.hxx"
#include "olethk32.hxx"
#include "map_kv.h"
#include "map_dwp.h"
#include "obj16.hxx"
#include "thkmgr.hxx"
#include "freelist.hxx"
#include "cthkmgr.hxx"

#include "tlsthk.hxx"
#include "thop.hxx"
#include "thi.hxx"
#include "the.hxx"
#include "thopapi.hxx"
#include "thopint.hxx"
#include "inv16.hxx"
#include "alias.hxx"
#include "thoputil.hxx"
#include "apinot.hxx"

#if DBG == 1
#include "dbginv.hxx"
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\inv32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       inv32.cxx
//
//  Contents:   Implementation of InvokeOn32
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

STDAPI_(BOOL) IsValidInterface( void FAR* pv );

#include <apilist.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   InvokeOn32, public
//
//  Synopsis:   Sets up the THUNKINFO and starts thunking for a 16->32 call
//
//  Arguments:  [dw1] - Ignored
//              [dwMethod] - Method index
//              [pvStack32] - 32-bit stack
//
//  Returns:    Appropriate status code
//
//  History:    18-Dec-93       JohannP Created
//              21-Feb-94       DrewB   Modified
//		09-Dec-94	JohannP added stack switching
//
//  Note:	On WIN95 this function get is executed on the 32 bit stack.
//
//----------------------------------------------------------------------------

#if DBG == 1
extern "C"
{
ULONG InvokeOn32_count = 0;
ULONG InvokeOn32_break = 0;

int _iInvokeOn32BreakIidx = -1;
int _iInvokeOn32BreakMethod = -1;
};
#endif


// InvokeOn32 uses a lot of local variables so allocate its locals
// rather than declaring them on the stack.  This saves roughly
// 150 bytes of stack per call

struct INVOKE32RECORD
{
    THOP CONST  *pThop;
    THOP CONST  * CONST *ppThop;
    UINT        uiThop;
    VTBLFN CONST *pvfnVtbl;
    VTBLFN CONST * CONST *ppvfnThis32;
    DWORD       dwStack32[MAX_PARAMS];
    THUNKINFO   ti;
    VPVOID      vpvThis16;
    THUNK1632OBJ UNALIGNED *pto;
    IIDIDX      iidx;
    ThreadData  *ptd;
};

STDAPI_(DWORD) SSAPI(InvokeOn32)(DWORD dw1, DWORD dwMethod, LPVOID pvStack16)
{
    // NOTE: Do not declare local variables in this routine
    // except for debug builds
    INVOKE32RECORD *pir;
    DWORD dwResult;

#if DBG == 1
    ULONG ulInvokeOn32_count = ++InvokeOn32_count;

    if (InvokeOn32_count == InvokeOn32_break)
    {
	DebugBreak();
    }

    thkDebugOut((DEB_ITRACE, "%sInvokeOn32(0x%08x, %p)\n",
                 NestingLevelString(),
                 dwMethod, pvStack16));
#endif // DBG

    if(!TlsThkGetData())
        return(CO_E_NOTINITIALIZED);

    pir = (INVOKE32RECORD *)STACKALLOC32(sizeof(INVOKE32RECORD));
    if (pir == NULL)
    {
        // This error isn't guaranteed to mean anything for
        // this call.  Not much else we can do, though
        return (DWORD)E_OUTOFMEMORY;
    }

    // pvStack16 is the pointer to the first parameter of the 16-bit
    // routine.  The compiler will adjust it appropriately according
    // to the calling convention of the routine so for PASCAL APIs
    // it will be high and for CDECL methods it will be low

    pir->ti.s16.pbStart = (BYTE *)pvStack16;
    pir->ti.s16.pbCurrent = pir->ti.s16.pbStart;

    pir->ti.s32.pbStart = (BYTE *)pir->dwStack32;
    pir->ti.s32.pbCurrent = pir->ti.s32.pbStart;

    pir->ti.scResult = S_OK;
    pir->ti.fResultThunked = FALSE;

    if (dwMethod >= THK_API_BASE)
    {
        dwMethod -= THK_API_BASE;
        pir->iidx = IIDIDX_INVALID;

        // APIs are handled as if there were a giant interface which
        // contains all the APIs as methods.
        pir->ppThop = apthopsApiThops;
        pir->uiThop = THK_API_COUNT;

        pir->pvfnVtbl = apfnApiFunctions;

        // APIs are pascal so we need to move downward in memory to
        // get to the next parameter
        pir->ti.s16.iDir = -1;

        pir->ti.dwCallerProxy = 0;
    }
    else
    {
        // For each interface there is an array of thop strings, one for
        // each method.  The IUnknown methods don't have thop strings so
        // bias the thop string pointer to account for that

        thkAssert(dwMethod >= SMI_COUNT);

        // Methods are cdecl so we need to move upwards in memory to
        // get to the next parameter
        pir->ti.s16.iDir = 1;

        // We need to look up the appropriate method pointer by
        // looking in the 32-bit object's vtable
        GET_STACK16(&pir->ti, pir->vpvThis16, VPVOID);

        thkDebugOut((DEB_INVOKES,
                     "InvokeOn32: vpvThis16 = %08lX\n", pir->vpvThis16 ));

        pir->pto = FIXVDMPTR(pir->vpvThis16, THUNK1632OBJ);
        if (pir->pto == NULL)
        {
            STACKFREE32(pir, sizeof(INVOKE32RECORD));
            return (DWORD)E_INVALIDARG;
        }

        if ((pir->pto->grfFlags & PROXYFLAG_TEMPORARY) == 0)
        {
            // Make sure proxy is still valid.
            // After PPC/Win95 we might want to look at using
            // a signiture for validating this rather than IsValidInterface
            // because it will speed this code path up.
            if (!IsValidInterface(pir->pto->punkThis32))
            {
                thkDebugOut((
                    DEB_ERROR, "InvokeOn32: %p: Invalid proxied object %p\n",
                         pir->vpvThis16, pir->pto->punkThis32));
                STACKFREE32(pir, sizeof(INVOKE32RECORD));
                RELVDMPTR(pir->vpvThis16);
                return (DWORD)E_INVALIDARG;
            }

            DebugValidateProxy1632(pir->vpvThis16);

            pir->ppvfnThis32 = (VTBLFN CONST * CONST*)pir->pto->punkThis32;
        }
        else
        {
            // Temporary proxies cannot be validated

            // A temporary proxy's this pointer is actually a pointer
            // to the real this pointer, so indirect through the this
            // pointer to retrieve the real this pointer
            pir->ppvfnThis32 = (VTBLFN CONST * CONST *)*(void **)pir->pto->punkThis32;
            thkAssert(pir->ppvfnThis32 != NULL);
            thkDebugOut((DEB_WARN, "WARNING: InvokeOn32 on temporary "
                         "%s proxy for %p\n", IidIdxString(pir->pto->iidx),
                         pir->ppvfnThis32));
        }

        pir->iidx = pir->pto->iidx;
        RELVDMPTR(pir->vpvThis16);

        if (pir->ppvfnThis32 == NULL)
        {
            STACKFREE32(pir, sizeof(INVOKE32RECORD));
            return (DWORD)E_FAIL;
        }

        pir->ti.dwCallerProxy = pir->vpvThis16;

        thkAssert(pir->iidx < THI_COUNT);

        pir->ppThop = athopiInterfaceThopis[pir->iidx].ppThops-SMI_COUNT;
        pir->uiThop = athopiInterfaceThopis[pir->iidx].uiSize;

        pir->pvfnVtbl = *pir->ppvfnThis32;

        // Push the 32-bit this pointer on the stack first
        TO_STACK32(&pir->ti, pir->ppvfnThis32, VTBLFN CONST * CONST*);
    }

    thkAssert(dwMethod < pir->uiThop);

    pir->pThop = pir->ppThop[dwMethod];

    thkAssert(pir->pThop != NULL);

    pir->ti.pThop = pir->pThop;
    pir->ti.pvfn  = pir->pvfnVtbl[dwMethod];
    pir->ti.iidx  = pir->iidx;
    pir->ti.dwMethod = dwMethod;

    pir->ptd = TlsThkGetData();
    if (pir->ptd == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: InvokeOn32: Call refused\n"));

        STACKFREE32(pir, sizeof(INVOKE32RECORD));
        return (DWORD)E_FAIL;
    }

    pir->ti.pThkMgr = pir->ptd->pCThkMgr;
    thkAssert(pir->ti.pThkMgr != NULL);

#if DBG == 1
    if (pir->iidx == IIDIDX_INVALID)
    {
        thkDebugOut((DEB_INVOKES, "%s#(%04X):InvokeOn32 on %p, %s\n",
                     NestingLevelString(), ulInvokeOn32_count,
                     pir->ti.pvfn, apszApiNames[dwMethod]));
    }
    else
    {
        thkDebugOut((DEB_INVOKES, "%s#(%04X):InvokeOn32 on %p:%p, %s::%s (0x%0x:0x%0x)\n",
                     NestingLevelString(), ulInvokeOn32_count,
                     pir->ppvfnThis32, pir->ti.pvfn,
                     inInterfaceNames[pir->iidx].pszInterface,
                     inInterfaceNames[pir->iidx].ppszMethodNames[dwMethod],
		     pir->iidx,
		     dwMethod));
    }
#endif

    DebugIncrementNestingLevel();
    // save and set the new thunk state

    pir->ti.pThkMgr->SetThkState(THKSTATE_INVOKETHKIN32);

#if DBG == 1
    if ((_iInvokeOn32BreakIidx > 0 &&
         _iInvokeOn32BreakIidx == (int)pir->iidx) &&
        (_iInvokeOn32BreakMethod < 0 ||
         _iInvokeOn32BreakMethod == (int)dwMethod))
    {
        DebugBreak();
    }
#endif

#if DBG == 1
    SStackRecord sr;

    RecordStackState16(&sr);
#endif

#if DBG == 1
    if (fStabilizeProxies)
#endif
    {
        // HACK HACK HACK
        // Because of changes in the way refcounting rules work between
        // 16 and 32-bits, we have to stabilize this pointers for
        // 16->32 calls.  To effect this, we do a purely local AddRef
        //
        // Temporary proxies are not valid proxies so they cannot
        // be stabilized
        if (pir->iidx != IIDIDX_INVALID)
        {
            DWORD dwFlags;

            pir->pto = FIXVDMPTR(pir->vpvThis16, THUNK1632OBJ);
            dwFlags = pir->pto->grfFlags;
            RELVDMPTR(pir->vpvThis16);

            if ((dwFlags & PROXYFLAG_TEMPORARY) == 0)
            {
                pir->ti.pThkMgr->AddRefProxy1632(pir->vpvThis16);
            }
        }
    }

    dwResult = EXECUTE_THOP1632(&pir->ti);

#if DBG == 1
    if (fStabilizeProxies)
#endif
    {
        // Remove our stabilization reference
        // Note that we don't really know whether the proxy is
        // still valid, so we're just crossing our fingers here
        // and hoping that things continue to work
        if (pir->iidx != IIDIDX_INVALID)
        {
            DWORD dwFlags;

            pir->pto = FIXVDMPTR(pir->vpvThis16, THUNK1632OBJ);
            dwFlags = pir->pto->grfFlags;
            RELVDMPTR(pir->vpvThis16);

            if ((dwFlags & PROXYFLAG_TEMPORARY) == 0)
            {
                DebugValidateProxy1632(pir->vpvThis16);
                pir->ti.pThkMgr->ReleaseProxy1632(pir->vpvThis16);
            }
        }
    }

#if DBG == 1

    if ( !pir->ti.fResultThunked && FAILED(dwResult) )
    {
        if (pir->iidx == IIDIDX_INVALID)
        {
            thkDebugOut((DEB_FAILURES,
                         "InvokeOn32 probable failure %s sc = %08lX\n",
                         apszApiNames[dwMethod],
                         dwResult));
        }
        else
        {
            thkDebugOut((DEB_FAILURES,
                         "InvokeOn32 probable failure %s::%s sc = %08lX\n",
                         inInterfaceNames[pir->iidx].pszInterface,
                         inInterfaceNames[pir->iidx].ppszMethodNames[dwMethod],
                         dwResult));
        }
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }

    CheckStackState16(&sr);

#endif

    pir->ti.pThkMgr->SetThkState(THKSTATE_NOCALL);

    DebugDecrementNestingLevel();

    if ( !pir->ti.fResultThunked )
    {
        dwResult = TransformHRESULT_3216( dwResult );
    }

#if DBG == 1
    if (pir->iidx == IIDIDX_INVALID)
    {
        thkDebugOut((DEB_INVOKES,
                     "%s#(%04X):InvokeOn32 on %p, %s returns 0x%08lX\n",
                     NestingLevelString(), ulInvokeOn32_count, pir->ti.pvfn,
                     apszApiNames[dwMethod], dwResult ));
    }
    else
    {
        thkDebugOut((DEB_INVOKES,
                     "%s#(%04X):InvokeOn32 on %p:%p, %s::%s returns 0x%08lX\n",
                     NestingLevelString(), ulInvokeOn32_count,
                     pir->ppvfnThis32,
                     pir->ti.pvfn, inInterfaceNames[pir->iidx].pszInterface,
                     inInterfaceNames[pir->iidx].ppszMethodNames[dwMethod],
                     dwResult));
    }
#endif

    STACKFREE32(pir, sizeof(INVOKE32RECORD));

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\iidtothi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	iidtothi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <coguid.h>
#include <oleguid.h>
IIDTOTHI CONST aittIidToThi[] =
{
    &IID_IUnknown, THI_IUnknown
,    &IID_IClassFactory, THI_IClassFactory
,    &IID_IMarshal, THI_IMarshal
,    &IID_IStdMarshalInfo, THI_IStdMarshalInfo
,    &IID_IMessageFilter, THI_IMessageFilter
,    &IID_IExternalConnection, THI_IExternalConnection
,    &IID_IEnumString, THI_IEnumString
,    &IID_IEnumUnknown, THI_IEnumUnknown
,    &IID_IEnumSTATSTG, THI_IEnumSTATSTG
,    &IID_ILockBytes, THI_ILockBytes
,    &IID_IStream, THI_IStream
,    &IID_IStorage, THI_IStorage
,    &IID_IRootStorage, THI_IRootStorage
,    &IID_IEnumFORMATETC, THI_IEnumFORMATETC
,    &IID_IEnumSTATDATA, THI_IEnumSTATDATA
,    &IID_IDataObject, THI_IDataObject
,    &IID_IViewObject, THI_IViewObject
,    &IID_IViewObject2, THI_IViewObject2
,    &IID_IAdviseSink, THI_IAdviseSink
,    &IID_IAdviseSink2, THI_IAdviseSink2
,    &IID_IDataAdviseHolder, THI_IDataAdviseHolder
,    &IID_IOleCache, THI_IOleCache
,    &IID_IOleCache2, THI_IOleCache2
,    &IID_IOleCacheControl, THI_IOleCacheControl
,    &IID_IDropTarget, THI_IDropTarget
,    &IID_IDropSource, THI_IDropSource
,    &IID_IPersist, THI_IPersist
,    &IID_IPersistStorage, THI_IPersistStorage
,    &IID_IPersistStream, THI_IPersistStream
,    &IID_IPersistFile, THI_IPersistFile
,    &IID_IBindCtx, THI_IBindCtx
,    &IID_IMoniker, THI_IMoniker
,    &IID_IRunningObjectTable, THI_IRunningObjectTable
,    &IID_IEnumMoniker, THI_IEnumMoniker
,    &IID_IEnumOLEVERB, THI_IEnumOLEVERB
,    &IID_IOleObject, THI_IOleObject
,    &IID_IOleClientSite, THI_IOleClientSite
,    &IID_IRunnableObject, THI_IRunnableObject
,    &IID_IParseDisplayName, THI_IParseDisplayName
,    &IID_IOleContainer, THI_IOleContainer
,    &IID_IOleItemContainer, THI_IOleItemContainer
,    &IID_IOleAdviseHolder, THI_IOleAdviseHolder
,    &IID_IOleLink, THI_IOleLink
,    &IID_IOleWindow, THI_IOleWindow
,    &IID_IOleInPlaceObject, THI_IOleInPlaceObject
,    &IID_IOleInPlaceActiveObject, THI_IOleInPlaceActiveObject
,    &IID_IOleInPlaceUIWindow, THI_IOleInPlaceUIWindow
,    &IID_IOleInPlaceFrame, THI_IOleInPlaceFrame
,    &IID_IOleInPlaceSite, THI_IOleInPlaceSite
,    &IID_IRpcChannelBuffer, THI_IRpcChannelBuffer
,    &IID_IRpcProxyBuffer, THI_IRpcProxyBuffer
,    &IID_IRpcStubBuffer, THI_IRpcStubBuffer
,    &IID_IPSFactoryBuffer, THI_IPSFactoryBuffer
,    &IID_IRpcChannel, THI_IRpcChannel
,    &IID_IRpcProxy, THI_IRpcProxy
,    &IID_IRpcStub, THI_IRpcStub
,    &IID_IPSFactory, THI_IPSFactory
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\heap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       heap.cxx
//
//  Contents:   memory management
//
//  Classes:
//
//  Functions:  operator new
//              operator delete
//
//  History:    5-Dec-95 JeffE    Created
//
//--------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   operator new, public
//
//  Synopsis:   Global operator new which does not throw exceptions.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:	A pointer to the allocated memory.  Is *NOT* initialized to 0!
//
//  Notes:	We override new to make delete easier.
//
//----------------------------------------------------------------------------
void* __cdecl
operator new (size_t size)
{
    return(CoTaskMemAlloc(size));
}


//+-------------------------------------------------------------------------
//
//  Function:	::operator delete
//
//  Synopsis:	Free a block of memory
//
//  Arguments:	[lpv] - block to free.
//
//  History:	18-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------

void __cdecl operator delete(void FAR* lpv)
{
    CoTaskMemFree (lpv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\fntomthd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	fntomthd.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

BYTE CONST ftmIClassFactory[] =
{
    3,
    4
};
BYTE CONST ftmIMarshal[] =
{
    6,
    0,
    0,
    0,
    8,
    7,
    0,
    3,
    4,
    5
};
BYTE CONST ftmIStdMarshalInfo[] =
{
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIMessageFilter[] =
{
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    5
};
BYTE CONST ftmIExternalConnection[] =
{
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4
};
BYTE CONST ftmIEnumString[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIEnumUnknown[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIEnumSTATSTG[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3
};
BYTE CONST ftmILockBytes[] =
{
    0,
    0,
    9,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    3,
    4,
    6,
    7,
    8
};
BYTE CONST ftmIStream[] =
{
    4,
    0,
    12,
    0,
    13,
    8,
    9,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    6,
    11,
    10,
    5,
    7
};
BYTE CONST ftmIStorage[] =
{
    0,
    0,
    13,
    15,
    12,
    9,
    10,
    0,
    0,
    6,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    4,
    5,
    8,
    11,
    14,
    16,
    17
};
BYTE CONST ftmIRootStorage[] =
{
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIEnumFORMATETC[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIEnumSTATDATA[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIDataObject[] =
{
    0,
    0,
    6,
    11,
    10,
    5,
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    4,
    3,
    8
};
BYTE CONST ftmIViewObject[] =
{
    8,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    4,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIViewObject2[] =
{
    8,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    4,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    5,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIAdviseSink[] =
{
    0,
    0,
    0,
    0,
    0,
    5,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    3,
    0,
    7
};
BYTE CONST ftmIAdviseSink2[] =
{
    0,
    0,
    0,
    0,
    8,
    5,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    3,
    0,
    6
};
BYTE CONST ftmIDataAdviseHolder[] =
{
    0,
    0,
    0,
    0,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIOleCache[] =
{
    7,
    0,
    0,
    6,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIOleCache2[] =
{
    7,
    9,
    0,
    6,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8
};
BYTE CONST ftmIOleCacheControl[] =
{
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0
};
BYTE CONST ftmIDropTarget[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    3,
    4,
    6
};
BYTE CONST ftmIDropSource[] =
{
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersist[] =
{
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersistStorage[] =
{
    0,
    8,
    0,
    6,
    5,
    3,
    9,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    4,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersistStream[] =
{
    0,
    0,
    0,
    7,
    5,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    4,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersistFile[] =
{
    0,
    0,
    0,
    8,
    7,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    0,
    4,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIBindCtx[] =
{
    0,
    7,
    0,
    6,
    4,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    10,
    9,
    0,
    5,
    0,
    0,
    0,
    0,
    8,
    11,
    12
};
BYTE CONST ftmIMoniker[] =
{
    16,
    22,
    19,
    17,
    14,
    13,
    0,
    0,
    0,
    0,
    0,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    21,
    10,
    9,
    8,
    18,
    12,
    6,
    0,
    4,
    11,
    0,
    0,
    0,
    7,
    5,
    3,
    20
};
BYTE CONST ftmIRunningObjectTable[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    8,
    7,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    5,
    4,
    0
};
BYTE CONST ftmIEnumMoniker[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    6,
    4,
    3
};
BYTE CONST ftmIEnumOLEVERB[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    6,
    4,
    3
};
BYTE CONST ftmIOleObject[] =
{
    0,
    21,
    16,
    20,
    15,
    12,
    14,
    0,
    0,
    11,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    10,
    7,
    5,
    0,
    13,
    9,
    0,
    0,
    0,
    6,
    4,
    3,
    8,
    17,
    18,
    19,
    22,
    23
};
BYTE CONST ftmIOleClientSite[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    4,
    0,
    0,
    0,
    0,
    5,
    8
};
BYTE CONST ftmIRunnableObject[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    4,
    0,
    0,
    0,
    0,
    6,
    3,
    5
};
BYTE CONST ftmIParseDisplayName[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIOleContainer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    5,
    0
};
BYTE CONST ftmIOleItemContainer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    7,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    4,
    5,
    0
};
BYTE CONST ftmIOleAdviseHolder[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    0,
    0,
    0,
    0,
    3,
    4,
    7
};
BYTE CONST ftmIOleLink[] =
{
    0,
    0,
    0,
    13,
    11,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    7,
    6,
    4,
    0,
    0,
    0,
    9,
    5,
    3,
    10
};
BYTE CONST ftmIOleWindow[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    0
};
BYTE CONST ftmIOleInPlaceObject[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    7,
    3,
    5
};
BYTE CONST ftmIOleInPlaceActiveObject[] =
{
    0,
    0,
    0,
    0,
    9,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    4,
    8,
    0,
    0,
    0,
    0,
    3,
    0
};
BYTE CONST ftmIOleInPlaceUIWindow[] =
{
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    4,
    0,
    0,
    0,
    0,
    8,
    3,
    0
};
BYTE CONST ftmIOleInPlaceFrame[] =
{
    0,
    13,
    0,
    12,
    11,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    4,
    10,
    0,
    0,
    9,
    8,
    3,
    0,
    14
};
BYTE CONST ftmIOleInPlaceSite[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    14,
    10,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    5,
    0,
    9,
    11,
    12,
    13
};
BYTE CONST ftmIRpcChannelBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    4,
    3,
    5,
    0,
    0,
    0,
    0,
    0,
    7
};
BYTE CONST ftmIRpcProxyBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    4
};
BYTE CONST ftmIRpcStubBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    8,
    6,
    0,
    0,
    0,
    0,
    5,
    3,
    0,
    0,
    0,
    0,
    7,
    4
};
BYTE CONST ftmIPSFactoryBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIRpcChannel[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    6
};
BYTE CONST ftmIRpcProxy[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    4
};
BYTE CONST ftmIRpcStub[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    7,
    4
};
BYTE CONST ftmIPSFactory[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\olethunk\olethk32\inv16.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       inv16.cxx
//
//  Contents:   32->16 Call thunking
//
//  History:    25-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "..\..\ole232\inc\le2int.h"        // Include le2int.h before inplace.h
#include "..\..\ole232\inplace\inplace.h"   // We need CFrameFilter for
                                            // WinWord 6 Hack

//+---------------------------------------------------------------------------
//
//  Function:   InvokeOn16, public
//
//  Synopsis:   Sets up the THUNKINFO and starts thunking for a 32->16 call
//
//  Arguments:  [iidx] - Custom interface or known interface index
//              [dwMethod] - Method index
//              [pvStack32] - 32-bit stack
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
extern "C"
{
ULONG InvokeOn16_count = 0;
ULONG InvokeOn16_break = 0;

int _iInvokeOn16BreakIidx = -1;
int _iInvokeOn16BreakMethod = -1;
};
#endif

// InvokeOn16 uses a lot of local variables so allocate its locals
// rather than declaring them on the stack.  This saves roughly
// 150 bytes of stack per call

struct INVOKE16RECORD
{
    THOP CONST        *pThop;
    THOP CONST        * CONST *ppThop;
    UINT        uiThop;
    VTBLFN UNALIGNED CONST *pvfnVtbl;
    VPVOID      vpvThis16;
    VPVOID      vpvVtbl16;
    VPVOID UNALIGNED CONST *pvpvThis16;
    DWORD       dwStack16[MAX_PARAMS];
    THUNKINFO   ti;
    THUNK3216OBJ *ptoThis3