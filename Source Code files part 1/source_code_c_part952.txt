include <atlbase.h>

extern CComModule _Module;

#include <MPC_config.h>
#include <MPC_streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\configuration\test_configuration.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    test_ParentChild.cpp

Abstract:
    This file contains the unit test for Parent-Child COM Templates.

Revision History:
    Davide Massarenti   (Dmassare)  10/12/99
        created

******************************************************************************/

#include "stdafx.h"
#include <iostream>

/////////////////////////////////////////////////////////////////////////////

class SubTest1 : public MPC::Config::TypeConstructor
{
	DECLARE_CONFIG_MAP(SubTest1);

public:
    float        m_float;
    DATE         m_DATE;
	MPC::wstring m_Value;

	SubTest1()
	{
		m_float = 0;
		m_DATE  = 0;
	}

	////////////////////////////////////////
	//
	// MPC::Config::TypeConstructor
	//
	DEFINE_CONFIG_DEFAULTTAG();
	DECLARE_CONFIG_METHODS();
	//
	////////////////////////////////////////
};

CFG_BEGIN_FIELDS_MAP(SubTest1)
	CFG_ATTRIBUTE( L"ATTRIB3", float  , m_float),
	CFG_ATTRIBUTE( L"ATTRIB4", DATE   , m_DATE ),
	CFG_VALUE    (             wstring, m_Value),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(SubTest1)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(SubTest1,L"SUBTEST1_TAG")

DEFINE_CONFIG_METHODS__NOCHILD(SubTest1)

/////////////////////////////////////////////////////////////////////////////

class Test : public MPC::Config::TypeConstructor
{
	DECLARE_CONFIG_MAP(Test);
public:

	typedef std::list<SubTest1> List1;
	typedef List1::iterator     List1Iter;

    int          m_i1;
    MPC::wstring m_str2; bool m_fStr2;
	List1        m_lst1;

	Test()
	{
		m_i1 = 0;
	}

	~Test()
	{
		for(List1Iter it=m_lst1.begin(); it != m_lst1.end(); it++)
		{
			SubTest1& res = *it;
		}
	}

	////////////////////////////////////////
	//
	// MPC::Config::TypeConstructor
	//
	DEFINE_CONFIG_DEFAULTTAG();
	DECLARE_CONFIG_METHODS();
	//
	////////////////////////////////////////

	HRESULT Load( /*[in]*/ LPCWSTR szFile )
	{
		return MPC::Config::LoadFile( this, szFile );
	}

	HRESULT Save( /*[in]*/ LPCWSTR szFile )
	{
		return MPC::Config::SaveFile( this, szFile );
	}
};

CFG_BEGIN_FIELDS_MAP(Test)
	CFG_ATTRIBUTE		 ( L"ATTRIB1", int    , m_i1            ),
	CFG_ELEMENT__TRISTATE( L"ATTRIB2", wstring, m_str2, m_fStr2 ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(Test)
	CFG_CHILD(SubTest1)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(Test,L"TEST_TAG")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(Test,tag,defSubType)

	if(tag == _cfg_table_tags[0])
	{
		defSubType = &(*(m_lst1.insert( m_lst1.end() )));
		return S_OK;
	}

DEFINE_CONFIG_METHODS_SAVENODE_SECTION(Test,xdn)

	hr = MPC::Config::SaveList( m_lst1, xdn );

DEFINE_CONFIG_METHODS_END(Test)

/////////////////////////////////////////////////////////////////////////////

extern "C" int WINAPI wWinMain( HINSTANCE hInstance     ,
                                HINSTANCE hPrevInstance ,
                                LPWSTR    lpCmdLine     ,
                                int       nShowCmd      )
{
    lpCmdLine = ::GetCommandLineW(); //this line necessary for _ATL_MIN_CRT

    HRESULT hRes = ::CoInitialize(NULL);
    _ASSERTE(SUCCEEDED(hRes));

    hRes = MPC::_MPC_Module.Init();
    _ASSERTE(SUCCEEDED(hRes));

	{
		Test            test;
		Test::List1Iter it;

		hRes = test.Load( L"c:\\tmp\\test.xml" );

		test.m_i1    = 123;
		test.m_fStr2 = false;

		it = test.m_lst1.insert( test.m_lst1.end() );
		it->m_DATE  = 12.0;
		it->m_Value = L"Test value";

		hRes = test.Save( L"c:\\tmp\\testOut.xml" );

		
		//
		// From object to registry.
		//
		{
			CComPtr<IStream> stream;

			if(SUCCEEDED(hRes = MPC::Config::SaveStream( &test, &stream )))
			{
				MPC::XmlUtil xml;
				MPC::RegKey  reg;
				bool         fFound;
				bool         fLoaded;

				if(SUCCEEDED(hRes = reg.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS     )) &&
				   SUCCEEDED(hRes = reg.Attach ( L"SOFTWARE\\Microsoft\\PCHealth\\Test" ))  )
				{
					if(SUCCEEDED(hRes = xml.LoadAsStream( stream, NULL, fLoaded, &fFound )))
					{
						hRes = MPC::ConvertFromXMLToRegistry( xml, reg );
					}
				}
			}
		}

		//
		// From registry to XML to object.
		//
		{
			CComPtr<IUnknown> unk;
			CComPtr<IStream>  stream;
			MPC::XmlUtil 	  xml;
			MPC::RegKey  	  reg;

			if(SUCCEEDED(hRes = reg.SetRoot( HKEY_LOCAL_MACHINE                     )) &&
			   SUCCEEDED(hRes = reg.Attach ( L"SOFTWARE\\Microsoft\\PCHealth\\Test" ))  )
			{
				if(SUCCEEDED(hRes = MPC::ConvertFromRegistryToXML( reg, xml )))
				{
					hRes = xml.Save( L"c:\\tmp\\testFromReg.xml" );
				}
			}

			if(SUCCEEDED(hRes))
			{
				if(SUCCEEDED(hRes = xml.SaveAsStream  ( &unk    )) &&
				   SUCCEEDED(hRes = unk.QueryInterface( &stream ))  )
				{
					Test test2;

					hRes = MPC::Config::LoadStream( &test2, stream );
				}
			}
		}

		//
		// In Memory Serializer test
		//
		{
			MPC::Serializer_IStream stream;

			{
				DWORD        	 test1( 112      );
				MPC::wstring 	 test2( L"prova" );
				MPC::WStringList lst;

				lst.push_back( L"test" );

				hRes = stream << test1;
				hRes = stream << test2;
				hRes = stream << lst;
			}

			hRes = stream.Reset();

			{
				DWORD        	 test1_b;
				MPC::wstring 	 test2_b;
				MPC::WStringList lst_b;
				
				hRes = stream >> test1_b;
				hRes = stream >> test2_b;
				hRes = stream >> lst_b;
			}
		}
	}

    MPC::_MPC_Module.Term();

    ::CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\filesystemobject\test_filesystemobject.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UploadManager.cpp

Abstract:
    This file contains the initialization portion of the Upload Manager

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"
#include <iostream>

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI wWinMain( HINSTANCE hInstance     ,
								HINSTANCE hPrevInstance ,
								LPWSTR    lpCmdLine     ,
								int       nShowCmd      )
{
    lpCmdLine = ::GetCommandLineW(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = ::CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    HRESULT hRes = ::CoInitialize( NULL );
#endif

    _ASSERTE( SUCCEEDED(hRes) );

	{
        HRESULT                          hr;
		MPC::FileSystemObject            fso( L"C:\\WINNT\\PCHEALTH" );
		MPC::FileSystemObject            fso2;
		MPC::FileSystemObject::List      lst;
		MPC::FileSystemObject::IterConst it;
		WIN32_FILE_ATTRIBUTE_DATA        wfadInfo;
		MPC::wstring                     str;

		if(SUCCEEDED(fso.EnumerateFolders( lst )))
		{
			for(it=lst.begin(); it != lst.end(); it++)
			{
				MPC::FileSystemObject* obj = *it;

				obj->get_Path( str );

				wprintf( L"Dir: %s\n", str.c_str() );
			}
		}

		if(SUCCEEDED(fso.EnumerateFiles( lst )))
		{
			for(it=lst.begin(); it != lst.end(); it++)
			{
				MPC::FileSystemObject* obj = *it;

				obj->get_Path( str );

				wprintf( L"File: %s\n", str.c_str() );
			}

			std::cout.flush();
		}

		fso  = MPC::FileSystemObject( L"C:\\temp\\test1" );
		fso2 = MPC::FileSystemObject( L"C:\\temp\\test2" );

		hr = fso.Delete( false );
		if(SUCCEEDED(hr))
		{
		}

		hr = fso.Delete( true );
		if(SUCCEEDED(hr))
		{
		}
	}

	{
		__MPC_FUNC_ENTRY( COMMONID, "Test Register" );

		HRESULT     hr;
		MPC::RegKey rkBase;
		CComVariant vValue;
		bool        fFound;

		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS     ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Attach ( L"Software\\Microsoft\\PCHealth\\Test" ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Create (                                        ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, L"Test1" ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.put_Value( vValue,         L"Test2" ));

		hr = S_OK;


		__MPC_FUNC_CLEANUP;
	}

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\logging\test_logging.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    test_Logging.cpp

Abstract:
    Unit test for Logging classes.

Revision History:
    Davide Massarenti   (Dmassare)  05/27/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI wWinMain( HINSTANCE hInstance     ,
								HINSTANCE hPrevInstance ,
								LPWSTR    lpCmdLine     ,
								int       nShowCmd      )
{
    lpCmdLine = ::GetCommandLineW(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = ::CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    HRESULT hRes = ::CoInitialize( NULL );
#endif

    _ASSERTE( SUCCEEDED(hRes) );

    {
        HRESULT      hr;
        MPC::FileLog flLog;

        if(SUCCEEDED(hr = flLog.SetLocation( L"C:\\TEMP\\filelog.txt" )))
        {
            hr = flLog.LogRecord( "Test1\n"              );
            hr = flLog.LogRecord( "Test2 %d\n", 23       );
            hr = flLog.LogRecord( "Test3 %s\n", "string" );
        }

        if(SUCCEEDED(hr = flLog.Rotate()))
        {
            hr = flLog.LogRecord( "Test1\n"              );
            hr = flLog.LogRecord( "Test2 %d\n", 23       );
            hr = flLog.LogRecord( "Test3 %s\n", "string" );
        }

        if(SUCCEEDED(hr = flLog.Rotate()))
        {
            hr = flLog.LogRecord( "Test1\n"              );
            hr = flLog.LogRecord( "Test2 %d\n", 23       );
            hr = flLog.LogRecord( "Test3 %s\n", "string" );
        }
    }

    {
        HRESULT      hr;
        MPC::NTEvent neLog;

        if(SUCCEEDED(hr = neLog.Init( L"Test_NT_Event" )))
        {
            hr = neLog.LogEvent( EVENTLOG_ERROR_TYPE      , 0, L"String1"                         );
            hr = neLog.LogEvent( EVENTLOG_WARNING_TYPE    , 0, L"String1", L"String2"             );
            hr = neLog.LogEvent( EVENTLOG_INFORMATION_TYPE, 0, L"String1", L"String2", L"String3" );
        }
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\logging\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_logging.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\parentchild\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_com.h>
#include <MPC_utils.h>
#include <MPC_xml.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\encryption\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the unit test for the Encryption stream.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#include "StdAfx.h"

CComModule _Module;

////////////////////////////////////////////////////////////////////////////////

static HRESULT OpenStreamForRead( /*[in]*/  LPCWSTR   szFile ,
								  /*[out]*/ IStream* *pVal   )
{
    __MPC_FUNC_ENTRY( COMMONID, "OpenStreamForRead" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;
	MPC::wstring             szFileFull( szFile ); MPC::SubstituteEnvVariables( szFileFull );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szFile);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead( szFileFull.c_str() ));


    //
    // Return the stream to the caller.
    //
    *pVal = stream.Detach();
    hr    = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

static HRESULT OpenStreamForWrite( /*[in]*/  LPCWSTR   szFile ,
								   /*[out]*/ IStream* *pVal   )
{
    __MPC_FUNC_ENTRY( COMMONID, "OpenStreamForWrite" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;
	MPC::wstring             szFileFull( szFile ); MPC::SubstituteEnvVariables( szFileFull );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szFile);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForWrite( szFileFull.c_str() ));


    //
    // Return the stream to the caller.
    //
    *pVal = stream.Detach();
    hr    = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT Encrypt( LPCWSTR szIn       , 
						LPCWSTR szOut      , 
						LPCWSTR szPassword )
{
    __MPC_FUNC_ENTRY( COMMONID, "Encrypt" );

    HRESULT                       hr;
    CComPtr<MPC::EncryptedStream> stream;
	CComPtr<IStream>              streamPlain;
	CComPtr<IStream>              streamEncrypted;


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForRead ( szIn , &streamPlain     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForWrite( szOut, &streamEncrypted ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEncrypted, szPassword ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamPlain, stream ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr)
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT Decrypt( LPCWSTR szIn       , 
						LPCWSTR szOut      , 
						LPCWSTR szPassword )
{
    __MPC_FUNC_ENTRY( COMMONID, "Encrypt" );

    HRESULT                       hr;
    CComPtr<MPC::EncryptedStream> stream;
	CComPtr<IStream>              streamEncrypted;
	CComPtr<IStream>              streamPlain;


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForRead ( szIn , &streamEncrypted ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForWrite( szOut, &streamPlain     ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEncrypted, szPassword ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( stream, streamPlain ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr)
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT RunTests( int argc, WCHAR **argv )
{
	__MPC_FUNC_ENTRY( COMMONID, "RunTests" );

	HRESULT hr;


	if(argc >= 5 && !_wcsicmp( argv[1], L"ENCRYPT"))
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, Encrypt( argv[2], argv[3], argv[4] ));
	}
	else if(argc >= 5 && !_wcsicmp( argv[1], L"DECRYPT"))
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, Decrypt( argv[2], argv[3], argv[4] ));
	}

	hr = S_OK;


	__MPC_FUNC_CLEANUP;

	__MPC_FUNC_EXIT(hr);
}

int __cdecl wmain( int argc, WCHAR **argv, WCHAR **envp)
{
    HRESULT  hr;

    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
		hr = RunTests( argc, argv );

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\parentchild\test_parentchild.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    test_ParentChild.cpp

Abstract:
    This file contains the unit test for Parent-Child COM Templates.

Revision History:
    Davide Massarenti   (Dmassare)  10/12/99
        created

******************************************************************************/

#include "stdafx.h"
#include <iostream>

#include <initguid.h>

#include <test_ParentChild.h>
#include <test_ParentChild_i.c>


/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CTestParent :
	public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
	public MPC::CComParentCoClass<CTestParent, &CLSID_TestParent>,
	public MPC::CComObjectRootParentBase,
	public ITestParent
{
	CComPtr<ITestChild> m_Child;

public:
DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTestParent)
	COM_INTERFACE_ENTRY(ITestParent)
END_COM_MAP()

	CTestParent()
	{
	}

	virtual ~CTestParent()
	{
	}

	HRESULT FinalConstruct();

	void Passivate()
	{
		m_Child.Release();
	}


// ITestParent
public:
	STDMETHOD(CallTestParent)()
	{
		if(m_Child) m_Child->CallTestChild();

		return S_OK;
	}

	STDMETHOD(GetChild)( ITestChild* *pVal )
	{
		if((*pVal = m_Child))
		{
			(*pVal)->AddRef();
		}

		return S_OK;
	}
};

typedef MPC::CComObjectParent<CTestParent> CTestParent_Object;


class ATL_NO_VTABLE CTestChild :
	public MPC::CComObjectRootChildEx<MPC::CComSafeMultiThreadModel,CTestParent>,
	public CComCoClass<CTestChild, &CLSID_TestChild>,
	public ITestChild
{
public:
DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTestChild)
	COM_INTERFACE_ENTRY(ITestChild)
END_COM_MAP()

	CTestChild()
	{
	}

	virtual ~CTestChild()
	{
	}


// ITestChild
public:
	STDMETHOD(CallTestChild)()
	{
		int i = 1;

		return S_OK;
	}

	STDMETHOD(GetParent)( ITestParent* *pVal )
	{
		CTestParent *p;

		Child_GetParent( &p );
		if(p)
		{
			p->QueryInterface( IID_ITestParent, (void**)pVal );
			p->Release();
		}
		else
		{
			*pVal = NULL;
		}

		return S_OK;
	}
};

HRESULT CTestParent::FinalConstruct()
{
	CComObject<CTestChild> *obj;
	HRESULT                 hr;
	
	if(SUCCEEDED(hr = CreateChild( this, &obj )))
	{
		obj->QueryInterface( IID_ITestChild, (void**)&m_Child );
		obj->Release();
	}

	return hr;
}



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_TestParent, CTestParent )
    OBJECT_ENTRY(CLSID_TestChild , CTestChild  )
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain( HINSTANCE hInstance     ,
                                 HINSTANCE hPrevInstance ,
                                 LPTSTR    lpCmdLine     ,
                                 int       nShowCmd      )
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    HRESULT hRes = ::CoInitialize(NULL);
    _ASSERTE(SUCCEEDED(hRes));

    _Module.Init( ObjectMap, hInstance );

	hRes = MPC::_MPC_Module.Init();
    _ASSERTE(SUCCEEDED(hRes));

	hRes = _Module.RegisterClassObjects( CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE );
    _ASSERTE(SUCCEEDED(hRes));


	while(1)
	{
		CComPtr<ITestParent> parent;
		CComPtr<ITestChild>  child;

		if(FAILED(hRes = ::CoCreateInstance( CLSID_TestParent, NULL, CLSCTX_ALL, IID_ITestParent, (void**)&parent ))) break;

		if(FAILED(hRes = parent->CallTestParent())) break;

		if(FAILED(hRes = parent->GetChild( &child ))) break;

		if(FAILED(hRes = child->CallTestChild())) break;

		//		parent.Release();

		if(FAILED(hRes = child->CallTestChild())) break;

		break;
	}


	MPC::_MPC_Module.Term();

    _Module.Term();

    ::CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\pchsvc\safhelper.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    safhelper.cpp

Abstract:
    Redirector for ISAFRemoteDesktopServerHost.

Revision History:
    Davide Massarenti   (Dmassare)  02/27/2001
        created

******************************************************************************/

#include "stdafx.h"

#include <initguid.h>

#include <HelpServiceTypeLib.h>
#include <rdshost_i.c>
#include <HelpServiceTypeLib_i.c>
#include "wtsapi32.h"
#include "winsta.h"
#include "rassistance.h"
#include "rassistance_i.c"

#define WINDOWS_SYSTEM         	   	 	   L"%WINDIR%\\System32"

extern HRESULT RDSHost_HACKED_CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj );

////////////////////////////////////////////////////////////////////////////////

static const WCHAR s_location_HELPCTR [] = HC_ROOT_HELPSVC_BINARIES L"\\HelpCtr.exe";
static const WCHAR s_location_HELPSVC [] = HC_ROOT_HELPSVC_BINARIES L"\\HelpSvc.exe";
static const WCHAR s_location_HELPHOST[] = HC_ROOT_HELPSVC_BINARIES L"\\HelpHost.exe";
static const WCHAR s_location_RCIMLBY [] = WINDOWS_SYSTEM L"\\RCIMLby.exe";

static const LPCWSTR s_include_Generic[] =
{
    s_location_HELPCTR ,
    s_location_HELPSVC ,
    s_location_HELPHOST,
	s_location_RCIMLBY ,
    NULL
};


HRESULT CreateObject_RemoteDesktopSession( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                           /*[in]         */ long                          lTimeout            ,
                                           /*[in]         */ BSTR                          bstrConnectionParms ,
                                           /*[in]         */ BSTR                          bstrUserHelpBlob    ,
                                           /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               )
{
    __MPC_FUNC_ENTRY( COMMONID, "CPCHUtility::CreateObject_RemoteDesktopSession" );

    HRESULT                              hr;
    CComPtr<ISAFRemoteDesktopServerHost> pSAFRDServer;
    BOOL                                 fEnableSessRes = TRUE;
    PSID                                 pSid           = NULL;
    CComBSTR                             bstrUser;
    LONG                                 lSessionID;


    if(!ppRCS) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::VerifyCallerIsTrusted( s_include_Generic ));

//	  // Create an instance of ISAFRemoteDesktopServerHost in order to create a RDSSession.
//	  __MPC_EXIT_IF_METHOD_FAILS(hr, pSAFRDServer.CoCreateInstance( CLSID_SAFRemoteDesktopServerHost ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, RDSHost_HACKED_CreateInstance( NULL, IID_ISAFRemoteDesktopServerHost, (void**)&pSAFRDServer ));

    //
    // Get the Caller SID and get the Session ID to invoke CreateRemoteDesktopSessionEx().
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetCallerPrincipal( /*fImpersonate*/true, bstrUser ));

    // Now get the Session ID
    {
        MPC::Impersonation imp;
        ULONG              ulReturnLength;

        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize());

        //
        // Use the _HYDRA_ extension to GetTokenInformation to
        // return the SessionId from the token.
        //
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetTokenInformation( (HANDLE)imp, /*Token Type */TokenSessionId, &lSessionID, sizeof(lSessionID), &ulReturnLength ));
    }

    // We have the Caller SID and the Session ID, so we are ready to call CreateRemoteDesktopSessionEx().

    // Decide whether we need to create a new session or open an existing session.
    if(::SysStringLen( bstrConnectionParms ) == 0)
    {
        // Call Create RDSSession Method of ISAFRemoteDesktopServerHost.
        __MPC_EXIT_IF_METHOD_FAILS(hr, pSAFRDServer->CreateRemoteDesktopSessionEx( sharingClass, fEnableSessRes, lTimeout, bstrUserHelpBlob, lSessionID, bstrUser, ppRCS ));

    }
    else
    {
        // Call Open RDSSession Method of ISAFRemoteDesktopServerHost.
        __MPC_EXIT_IF_METHOD_FAILS(hr, pSAFRDServer->OpenRemoteDesktopSession( bstrConnectionParms, ppRCS ));
    }

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT ConnectToExpert(/* [in]          */ BSTR bstrExpertConnectParm,
                        /* [in]          */ LONG lTimeout,
                        /* [retval][out] */ LONG *lSafErrorCode)
{
    __MPC_FUNC_ENTRY( COMMONID, "CPCHUtility::ConnectToExpert" );

    HRESULT                              hr;
    CComPtr<ISAFRemoteDesktopServerHost> pSAFRDServer;


    BOOL                                 fEnableSessRes = TRUE;
    PSID                                 pSid           = NULL;
    CComBSTR                             bstrUser;
    LONG                                 lSessionID;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::VerifyCallerIsTrusted( s_include_Generic ));

//	  // Create an instance of ISAFRemoteDesktopServerHost in order to invoke ConnectToExpert.
//	  __MPC_EXIT_IF_METHOD_FAILS(hr, pSAFRDServer.CoCreateInstance( CLSID_SAFRemoteDesktopServerHost ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, RDSHost_HACKED_CreateInstance( NULL, IID_ISAFRemoteDesktopServerHost, (void**)&pSAFRDServer ));

    // Call ConnectToExpert Method of ISAFRemoteDesktopServerHost.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pSAFRDServer->ConnectToExpert( bstrExpertConnectParm, lTimeout, lSafErrorCode));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT SwitchDesktopMode(/* [in]*/ int nMode, 
	                      /* [in]*/ int nRAType)
{
    __MPC_FUNC_ENTRY( COMMONID, "SAFHelper::SwitchDesktopMode" );

    HRESULT                  hr=E_FAIL;
	WINSTATIONSHADOW         WinStationShadow;
	bool                     fSuccess;
	CComPtr<IRARegSetting>   pRARegSetting;
	BOOL                     fAllowFullControl;
    DWORD                    dwSessionId;
    ULONG                    ReturnLength;
    MPC::Impersonation       imp;

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::VerifyCallerIsTrusted( s_include_Generic ));

	switch(nMode)
	{
		case 0:
			// View Only Mode
			// Shadow_EnableNoInputNotify(=3) or Shadow_EnableNoInputNoNotify(=4)
			WinStationShadow.ShadowClass = Shadow_EnableNoInputNoNotify;
			break;
		case 1:
			// Full Control Mode
			//  Shadow_EnableInputNotify(=1) or     Shadow_EnableInputNoNotify(=2)

			// Check the policy settings to see whether Remote Control is allowed, if not give an Access Denied error.

			// Create the RARegSetting Class.
			__MPC_EXIT_IF_METHOD_FAILS(hr, pRARegSetting.CoCreateInstance( CLSID_RARegSetting, NULL, CLSCTX_INPROC_SERVER ));

			// Based on nRAType (representing Solicited or Unsolicited RA) read the corresponding setting.

			switch(nRAType)
			{
			case 0:
			    // Solicited RA 
    			// Call get_AllowFullControl() Method of IRARegSetting.
			    __MPC_EXIT_IF_METHOD_FAILS(hr, pRARegSetting->get_AllowFullControl(&fAllowFullControl));
                break;

			case 1:
				// UnSolicited RA 
    			// Call get_AllowUnsolicitedFullControl() Method of IRARegSetting.
			    __MPC_EXIT_IF_METHOD_FAILS(hr, pRARegSetting->get_AllowUnSolicitedFullControl(&fAllowFullControl));
                break;

			default:
				__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
			}
		    if(fAllowFullControl)
			{
			    WinStationShadow.ShadowClass = Shadow_EnableInputNoNotify;
			}
			else
			{
				__MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
			}
			break;
		default:
			__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    if (!GetTokenInformation((HANDLE)imp, TokenSessionId, &dwSessionId, sizeof(dwSessionId), &ReturnLength))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }

    imp.RevertToSelf();

	__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::WinStationSetInformation(WTS_CURRENT_SERVER,
                                                                    dwSessionId, //WTS_CURRENT_SESSION,
									WinStationShadowInfo,     // Use the WinStationShadowInfo enum type for WINSTATIONINFOCLASS
									&WinStationShadow,
									sizeof(WinStationShadow)));  



    hr = S_OK;

    __MPC_FUNC_CLEANUP;


    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\pchsvc\helpsvc.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    helpsvc.cpp

Abstract:
    Housekeeping for the HelpSvc service.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2001
        created

******************************************************************************/

#include "stdafx.h"

#include <idletask.h>

////////////////////////////////////////////////////////////////////////////////

static const WCHAR s_szRoot          [] = HC_REGISTRY_PCHSVC;
static const WCHAR s_szStartItSrv    [] = L"StartItSrv";
static const WCHAR s_szDataCollection[] = L"DataCollection";

typedef MPC::SmartLockGeneric<MPC::CComSafeAutoCriticalSection> LocalSmartLock;

////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
static void StartIdleTaskServer()
{
    MPC::wstring strValue;
    bool         fFound;

    if(SUCCEEDED(MPC::RegKey_Value_Read( strValue, fFound, s_szRoot, s_szStartItSrv )) && fFound)
    {
        PROCESS_INFORMATION piProcessInformation;
        STARTUPINFOW        siStartupInfo;
        BOOL                fStarted;

        MPC::SubstituteEnvVariables( strValue );

        ::ZeroMemory( (PVOID)&piProcessInformation, sizeof( piProcessInformation ) );
        ::ZeroMemory( (PVOID)&siStartupInfo       , sizeof( siStartupInfo        ) ); siStartupInfo.cb = sizeof( siStartupInfo );

        fStarted = ::CreateProcessW( NULL                    ,
                                     (LPWSTR)strValue.c_str(),
                                     NULL                    ,
                                     NULL                    ,
                                     FALSE                   ,
                                     NORMAL_PRIORITY_CLASS   ,
                                     NULL                    ,
                                     NULL                    ,
                                     &siStartupInfo          ,
                                     &piProcessInformation   );


        if(piProcessInformation.hProcess) ::CloseHandle( piProcessInformation.hProcess );
        if(piProcessInformation.hThread ) ::CloseHandle( piProcessInformation.hThread  );
    }
}
#endif

////////////////////////////////////////////////////////////////////////////////

ServiceHandler_HelpSvc::ServiceHandler_HelpSvc( /*[in]*/ LPCWSTR szServiceName, /*[in]*/ CComRedirectorFactory* rgClasses ) :
    ServiceHandler 	 ( szServiceName, rgClasses                         ),
    m_svc_Timer    	 ( this, ServiceShutdownCallback                    ),
    m_batch_Event  	 ( this, BatchCallback                              ),
    m_batch_Timer  	 ( this, BatchCallback2                             ),
    m_dc_Timer     	 ( this, DataCollectionCallback                     ),
    m_dc_TimerRestart( this, DataCollectionRestartCallback              ),
    m_dc_EventStart	 ( this, IdleStartCallback     , WT_EXECUTEONLYONCE ),
    m_dc_EventStop 	 ( this, IdleStopCallback      , WT_EXECUTEONLYONCE )
{
                                 				 // MPC::CComSafeAutoCriticalSection m_cs;
                                 				 // CComPtr<IPCHService>             m_svc;
                                 				 // LocalTimer                       m_svc_Timer;
                                 				 //
    m_batch_Notification = INVALID_HANDLE_VALUE; // HANDLE                           m_batch_Notification;
                                 				 // LocalEvent                       m_batch_Event;
                                 				 // LocalTimer                       m_batch_Timer;
                                 				 //
                                 				 // LocalTimer                       m_dc_Timer;
                                 				 // LocalTimer 			             m_dc_TimerRestart;
                                 				 //
    m_dc_IdleHandle      = NULL; 				 // HANDLE                           m_dc_IdleHandle;
    m_dc_IdleStart       = NULL; 				 // HANDLE                           m_dc_IdleStart;
    m_dc_IdleStop        = NULL; 				 // HANDLE                           m_dc_IdleStop;
                                 				 // LocalEvent                       m_dc_EventStart;
                                 				 // LocalEvent                       m_dc_EventStop;
}

HRESULT ServiceHandler_HelpSvc::Initialize()
{
    __MPC_FUNC_ENTRY( COMMONID, "ServiceHandler_HelpSvc::Initialize" );

    const DWORD s_dwNotify = FILE_NOTIFY_CHANGE_FILE_NAME  |
                             FILE_NOTIFY_CHANGE_DIR_NAME   |
                             FILE_NOTIFY_CHANGE_ATTRIBUTES |
                             FILE_NOTIFY_CHANGE_SIZE       |
                             FILE_NOTIFY_CHANGE_CREATION;


    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ServiceHandler::Initialize());

	try
	{
		{
			MPC::wstring strBatch( HC_ROOT_HELPSVC_BATCH ); MPC::SubstituteEnvVariables( strBatch );
	
			m_batch_Notification = ::FindFirstChangeNotificationW( strBatch.c_str(), TRUE, s_dwNotify );
			if(m_batch_Notification != INVALID_HANDLE_VALUE)
			{
				m_batch_Event.Attach( m_batch_Notification );
				m_batch_Event.Set   ( INFINITE             );
			}
		}

		DataCollection_Queue();
	}
	catch(...)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

void ServiceHandler_HelpSvc::Cleanup()
{
	try
	{
		m_svc_Timer      .Reset();

		m_dc_Timer       .Reset();
		m_dc_TimerRestart.Reset();

		IdleTask_Cleanup();

		////////////////////

		if(m_batch_Notification != INVALID_HANDLE_VALUE)
		{
			m_batch_Event.Attach( NULL );

			::FindCloseChangeNotification( m_batch_Notification );

			m_batch_Notification = INVALID_HANDLE_VALUE;
		}

		////////////////////

		//
		// Find the HelpSvc class factory and force a shutdown.
		//
		{
			CComRedirectorFactory* classes;

			for(classes=m_rgClasses; classes->m_pclsid; classes++)
			{
				IPCHService* svc;

				if(SUCCEEDED(classes->GetServer( NULL, __uuidof( IPCHService ), (void**)&svc )))
				{
					(void)svc->PrepareForShutdown();

					svc->Release();

					::Sleep( 3000 ); // Give some time to shutdown code.
				}
			}
		}
	}
	catch(...)
	{
	}

    ServiceHandler::Cleanup();
}

////////////////////////////////////////

HRESULT ServiceHandler_HelpSvc::IdleTask_Initialize()
{
    __MPC_FUNC_ENTRY( COMMONID, "ServiceHandler_HelpSvc::IdleTask_Initialize" );

	HRESULT hr;


	{
		LocalSmartLock lock( &m_cs );

		if(!m_dc_IdleHandle)
		{
			try
			{
				DWORD dwErr = ::RegisterIdleTask( ItHelpSvcDataCollectionTaskId, &m_dc_IdleHandle, &m_dc_IdleStart, &m_dc_IdleStop );
				
#ifdef DEBUG
				if(dwErr != ERROR_SUCCESS)
				{
					StartIdleTaskServer();
					
					dwErr = ::RegisterIdleTask( ItHelpSvcDataCollectionTaskId, &m_dc_IdleHandle, &m_dc_IdleStart, &m_dc_IdleStop );
				}
#endif
				__MPC_EXIT_IF_METHOD_FAILS(hr, HRESULT_FROM_WIN32(dwErr));

				lock = NULL; // Release lock before going into the Event code!!!

				m_dc_EventStart.Attach( m_dc_IdleStart );
				m_dc_EventStop .Attach( m_dc_IdleStop  );
				
				m_dc_EventStart.Set( INFINITE );
			}
			catch(...)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
			}
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

void ServiceHandler_HelpSvc::IdleTask_Cleanup()
{
	try
	{
		m_dc_EventStart.Attach( NULL );
		m_dc_EventStop .Attach( NULL );

		{
			LocalSmartLock lock( &m_cs );

			if(m_dc_IdleHandle)
			{
				::UnregisterIdleTask( m_dc_IdleHandle, m_dc_IdleStart, m_dc_IdleStop );

				m_dc_IdleHandle = NULL;
				m_dc_IdleStart  = NULL;
				m_dc_IdleStop   = NULL;
			}
		}
	}
	catch(...)
	{
	}
}

////////////////////////////////////////

HRESULT ServiceHandler_HelpSvc::DataCollection_Queue()
{
    __MPC_FUNC_ENTRY( COMMONID, "ServiceHandler_HelpSvc::DataCollection_Queue" );

    MPC::wstring strValue;
    bool         fFound;
	DWORD        dwDelay = 10 * 1000;

    if(SUCCEEDED(MPC::RegKey_Value_Read( strValue, fFound, s_szRoot, s_szDataCollection )) && fFound)
    {
		DATE dDate;

		if(SUCCEEDED(MPC::ConvertStringToDate( strValue, dDate, /*fGMT*/false, /*fCIM*/true, 0 )))
		{
			const DATE c_OneDay           = 1.0;
			const DATE c_MillisecInOneDay = 24.0 * 60.0 * 60.0 * 1000.0;

			DATE dDiff = c_OneDay - (MPC::GetLocalTime() - dDate);

			//
			// Wait at least six hours between DC.
			//
			if(dDiff > 0) dwDelay = dDiff * c_MillisecInOneDay;
		}
	}

	m_dc_Timer.Set( dwDelay, 0 );

    return S_OK;
}

HRESULT ServiceHandler_HelpSvc::DataCollection_Execute( /*[in]*/ bool fCancel )
{
	if(!fCancel) ConnectToServer();

	{
		LocalSmartLock lock( &m_cs );

		if(m_svc)
		{
			m_svc->TriggerScheduledDataCollection( fCancel ? VARIANT_FALSE : VARIANT_TRUE );

			lock = NULL; // Release lock before going into the Timer code!!!

			m_svc_Timer.Set( 60 * 1000, 0 );
		}
	}

	m_dc_TimerRestart.Set( 1 * 1000, 0 );

    return S_OK;
}


////////////////////////////////////////

void ServiceHandler_HelpSvc::ConnectToServer()
{
	{
		LocalSmartLock lock( &m_cs );

		if(!m_svc)
		{
			m_svc.CoCreateInstance( CLSID_PCHService );
		}
	}

	m_svc_Timer.Set( 60 * 1000, 0 );
}

////////////////////////////////////////

HRESULT ServiceHandler_HelpSvc::ServiceShutdownCallback( /*[in]*/ BOOLEAN TimerOrWaitFired )
{
	{
		LocalSmartLock lock( &m_cs );

		m_svc.Release();
	}

	DataCollection_Queue();

	return S_OK;
}


HRESULT ServiceHandler_HelpSvc::BatchCallback( /*[in]*/ BOOLEAN TimerOrWaitFired )
{
    m_batch_Timer.Set( 5000, 0 );

	{
		LocalSmartLock lock( &m_cs );

		::FindNextChangeNotification( m_batch_Notification );
	}

    return S_OK;
}

HRESULT ServiceHandler_HelpSvc::BatchCallback2( /*[in]*/ BOOLEAN TimerOrWaitFired )
{
    //
    // If not already running, start it.
    //
	ConnectToServer();

    return S_OK;
}

////////////////////////////////////////

HRESULT ServiceHandler_HelpSvc::DataCollectionCallback( /*[in]*/ BOOLEAN TimerOrWaitFired )
{
    MPC::wstring strDate;

	if(FAILED(IdleTask_Initialize()))
	{
		DataCollection_Execute( /*fCancel*/false );
	}

	if(SUCCEEDED(MPC::ConvertDateToString( MPC::GetLocalTime(), strDate, /*fGMT*/false, /*fCIM*/true, 0 )))
	{
		(void)MPC::RegKey_Value_Write( strDate, s_szRoot, s_szDataCollection );
	}

    return S_OK;
}

HRESULT ServiceHandler_HelpSvc::DataCollectionRestartCallback( /*[in]*/ BOOLEAN TimerOrWaitFired )
{
	DataCollection_Queue();

    return S_OK;
}

HRESULT ServiceHandler_HelpSvc::IdleStartCallback( /*[in]*/ BOOLEAN TimerOrWaitFired )
{
    m_dc_EventStart.Reset(          );
    m_dc_EventStop .Set  ( INFINITE );

	DataCollection_Execute( /*fCancel*/false );


	IdleTask_Cleanup();

    return S_OK;
}

HRESULT ServiceHandler_HelpSvc::IdleStopCallback( /*[in]*/ BOOLEAN TimerOrWaitFired )
{
    m_dc_EventStop .Reset(          );
    m_dc_EventStart.Set  ( INFINITE );

	DataCollection_Execute( /*fCancel*/true );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\shuttle\cdescrip.cpp ===
//#---------------------------------------------------------------
//  File:       CDescrip.cpp
//        
//  Synopsis:   This file implements the CDescriptor class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu t-alexwe
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE   __szTraceSourceFile

#include    <windows.h>
#include    <stdio.h>
#include    "cdescrip.h"
#include    "cobjid.h"
#include    "cpool.h"
#include    "dbgtrace.h"

static DWORD			g_dwUniqueIdFactory = 1;
static CRITICAL_SECTION	g_critFactory;
static BOOL				g_bUseUniqueIDs = FALSE;

//+---------------------------------------------------------------
//
//  Function:   InitializeUniqueIDs
//
//  Synopsis:   Called to enable unique IDs inside CDescriptor's
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
void InitializeUniqueIDs( void )
{
	InitializeCriticalSection( &g_critFactory );
	g_bUseUniqueIDs = TRUE;
}


//+---------------------------------------------------------------
//
//  Function:   TerminateUniqueIDs
//
//  Synopsis:   Called to cleanup unique IDs inside CDescriptor's
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
void TerminateUniqueIDs( void )
{
	g_bUseUniqueIDs = FALSE;
	DeleteCriticalSection( &g_critFactory );
}


//+---------------------------------------------------------------
//
//  Function:   CDescriptor
//
//  Synopsis:   constructor is never called due to virtual array alloc
//                  Rather a void * will be cast to a CDescriptor *
//  Arguments:  void
//
//  Returns:    void
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
CDescriptor::CDescriptor( DWORD dwSignature ) : m_dwSignature( dwSignature )
{
    TraceFunctEnter( "CDescriptor::CDescriptor" );

	StateTrace((LPARAM) this, "m_eState = DESCRIPTOR_INUSE");

    m_eState = DESCRIPTOR_INUSE;

	if ( g_bUseUniqueIDs == TRUE )
	{
		EnterCriticalSection( &g_critFactory );
		m_dwUniqueObjectID = g_dwUniqueIdFactory++;
		LeaveCriticalSection( &g_critFactory );
	}

    TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:   ~CDescriptor
//
//  Synopsis:   destructor should never be called.  We just decommit 
//              virtual array
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
CDescriptor::~CDescriptor(
    void 
    )
{
    TraceFunctEnter( "CDescriptor::~CDescriptor" );
	_ASSERT( m_eState == DESCRIPTOR_INUSE );

	StateTrace((LPARAM) this, "m_eState = DESCRIPTOR_FREE");

    m_eState = DESCRIPTOR_FREE;
	m_dwUniqueObjectID = 0;

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\pchsvc\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_

#pragma once

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <comcat.h>
#include <stddef.h>

#include <tchar.h>
#include <malloc.h>

#include <olectl.h>
#include <winreg.h>

#include <atlbase.h>

extern CComModule _Module;

#include <mpc_trace.h>
#include <mpc_com.h>
#include <mpc_main.h>
#include <mpc_utils.h>
#include <mpc_security.h>

#include <ProjectConstants.h>

#include <initguid.h>

#include <HelpServiceTypeLib.h>
#include <Uploadmanager.h>

////////////////////////////////////////////////////////////////////////////////

struct CComRedirectorFactory : public IClassFactory, public IDispatchImpl<IPCHUtility, &IID_IPCHUtility, &LIBID_HelpServiceTypeLib>
{
    const CLSID*     m_pclsid;
    const CLSID*     m_pclsidReal;
    const IID*       m_piidDirecty;
    LPCWSTR          m_szExecutable;
    DWORD            m_dwRegister;
    CRITICAL_SECTION m_sec;


    CComRedirectorFactory( const CLSID* pclsid       ,
                           const CLSID* pclsidReal   ,
                           const IID*   piidDirecty  ,
                           LPCWSTR      szExecutable );

    ////////////////////////////////////////////////////////////////////////////////

    bool GetCommandLine( /*[out]*/ WCHAR* rgCommandLine, /*[in]*/ DWORD dwSize, /*[out]*/ bool& fProfiling );

    HRESULT GetServer  ( LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj );
    HRESULT StartServer( LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj );

    HRESULT Register  ();
    void    Unregister();

    ////////////////////////////////////////

public:
    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    ////////////////////////////////////////

    // IClassFactory
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);

    ////////////////////////////////////////

    // IPCHUtility
    STDMETHOD(get_UserSettings)( /*[out, retval]*/ IPCHUserSettings*     *pVal ) { return E_NOTIMPL; }
    STDMETHOD(get_Channels    )( /*[out, retval]*/ ISAFReg*              *pVal ) { return E_NOTIMPL; }
    STDMETHOD(get_Security    )( /*[out, retval]*/ IPCHSecurity*         *pVal ) { return E_NOTIMPL; }
    STDMETHOD(get_Database    )( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal ) { return E_NOTIMPL; }


    STDMETHOD(FormatError)( /*[in]*/ VARIANT vError, /*[out, retval]*/ BSTR *pVal ) { return E_NOTIMPL; }

    STDMETHOD(CreateObject_SearchEngineMgr)(                                                          /*[out, retval]*/ IPCHSEManager*      *ppSE ) { return E_NOTIMPL; }
    STDMETHOD(CreateObject_DataCollection )(                                                          /*[out, retval]*/ ISAFDataCollection* *ppDC ) { return E_NOTIMPL; }
    STDMETHOD(CreateObject_Cabinet        )(                                                          /*[out, retval]*/ ISAFCabinet*        *ppCB ) { return E_NOTIMPL; }
    STDMETHOD(CreateObject_Encryption     )(                                                          /*[out, retval]*/ ISAFEncrypt*        *ppEn ) { return E_NOTIMPL; }
    STDMETHOD(CreateObject_Channel        )( /*[in]*/ BSTR bstrVendorID, /*[in]*/ BSTR bstrProductID, /*[out, retval]*/ ISAFChannel*        *ppCh ) { return E_NOTIMPL; }

	STDMETHOD(CreateObject_RemoteDesktopConnection)( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC               ) { return E_NOTIMPL; }
	STDMETHOD(CreateObject_RemoteDesktopSession   )( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                                     /*[in]         */ long 						 lTimeout            ,
                                                     /*[in]         */ BSTR 						 bstrConnectionParms ,
													 /*[in]         */ BSTR 						 bstrUserHelpBlob    ,
													 /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               );


    STDMETHOD(ConnectToExpert)( /*[in]*/ BSTR bstrExpertConnectParm, /*[in]*/ LONG lTimeout, /*[out, retval]*/ LONG *lSafErrorCode );

	STDMETHOD(SwitchDesktopMode)( /*[in]*/ int nMode, /* [in]*/ int nRAType );
};

////////////////////////////////////////////////////////////////////////////////

struct ServiceHandler
{
    LPCWSTR                m_szServiceName;
    CComRedirectorFactory* m_rgClasses;

    HANDLE                 m_hShutdownEvent;

	bool                   m_fComInitialized;

    SERVICE_STATUS_HANDLE  m_hServiceStatus;
    SERVICE_STATUS         m_status;

    ServiceHandler( /*[in]*/ LPCWSTR szServiceName, /*[in]*/ CComRedirectorFactory* rgClasses );

    DWORD HandlerEx( DWORD  dwControl   ,  // requested control code
                     DWORD  dwEventType ,  // event type
                     LPVOID lpEventData ); // user-defined context data

    void Run();

    void SetServiceStatus( DWORD dwState );

	virtual HRESULT Initialize      ();
	void            WaitUntilStopped();
	virtual void    Cleanup         ();
};

struct ServiceHandler_HelpSvc : public ServiceHandler
{
	friend class LocalEvent;
	friend class LocalTimer;

	typedef HRESULT (ServiceHandler_HelpSvc::*METHOD)(BOOLEAN);

	class LocalEvent : public MPC::Pooling::Event
	{
		ServiceHandler_HelpSvc* m_Parent;
		METHOD                  m_Method;

	public:
		LocalEvent( /*[in]*/ ServiceHandler_HelpSvc* pParent, /*[in]*/ METHOD pMethod, /*[in]*/ DWORD dwFlags = WT_EXECUTEDEFAULT )
			: MPC::Pooling::Event( dwFlags ), m_Parent(pParent), m_Method(pMethod)
		{
		}
 
		HRESULT Signaled( /*[in]*/ BOOLEAN TimerOrWaitFired )
		{
			HRESULT hr;

			AddRef();

			hr = (m_Parent->*m_Method)( TimerOrWaitFired );

			Release();

			return hr;
		}
	};

	class LocalTimer : public MPC::Pooling::Timer
	{
		ServiceHandler_HelpSvc* m_Parent;
		METHOD                  m_Method;

	public:
		LocalTimer( /*[in]*/ ServiceHandler_HelpSvc* pParent, /*[in]*/ METHOD pMethod ) : m_Parent(pParent), m_Method(pMethod) {}
 
		HRESULT Execute( /*[in]*/ BOOLEAN TimerOrWaitFired )
		{
			HRESULT hr;

			AddRef();

			hr = (m_Parent->*m_Method)( TimerOrWaitFired );

			Release();

			return hr;
		}
	};

	MPC::CComSafeAutoCriticalSection m_cs;
	CComPtr<IPCHService>             m_svc;
	LocalTimer 			             m_svc_Timer;
						             
    HANDLE     			             m_batch_Notification;
	LocalEvent 			             m_batch_Event;
	LocalTimer 			             m_batch_Timer;
		  				             
	LocalTimer 			             m_dc_Timer;
	LocalTimer 			             m_dc_TimerRestart;
		  				             
	HANDLE     			             m_dc_IdleHandle;
	HANDLE     			             m_dc_IdleStart;
	HANDLE     			             m_dc_IdleStop;
	LocalEvent 			             m_dc_EventStart;
	LocalEvent 			             m_dc_EventStop;

	////////////////////

    ServiceHandler_HelpSvc( /*[in]*/ LPCWSTR szServiceName, /*[in]*/ CComRedirectorFactory* rgClasses );

	virtual HRESULT Initialize();
	virtual void    Cleanup   ();

	////////////////////

	void ConnectToServer();

	HRESULT ServiceShutdownCallback		 ( /*[in]*/ BOOLEAN TimerOrWaitFired );
	  
	HRESULT BatchCallback          		 ( /*[in]*/ BOOLEAN TimerOrWaitFired );
	HRESULT BatchCallback2         		 ( /*[in]*/ BOOLEAN TimerOrWaitFired );
 	   
	HRESULT IdleStartCallback	   		 ( /*[in]*/ BOOLEAN TimerOrWaitFired );
	HRESULT IdleStopCallback 	   		 ( /*[in]*/ BOOLEAN TimerOrWaitFired );
	HRESULT DataCollectionCallback 		 ( /*[in]*/ BOOLEAN TimerOrWaitFired );
	HRESULT DataCollectionRestartCallback( /*[in]*/ BOOLEAN TimerOrWaitFired );

	////////////////////

	HRESULT IdleTask_Initialize();
	void    IdleTask_Cleanup   ();

	HRESULT DataCollection_Queue  (                       );
	HRESULT DataCollection_Execute( /*[in]*/ bool fCancel );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\pchsvc\dllmain.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    dllmain.cpp

Abstract:
    Implementation of DLL Exports.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "stdafx.h"

CComModule _Module;

////////////////////////////////////////////////////////////////////////////////

HRESULT CreateObject_RemoteDesktopSession( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                           /*[in]         */ long                          lTimeout            ,
                                           /*[in]         */ BSTR                          bstrConnectionParms ,
                                           /*[in]         */ BSTR                          bstrUserHelpBlob    ,
                                           /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               );

HRESULT ConnectToExpert(/* [in]          */ BSTR bstrExpertConnectParm,
                        /* [in]          */ LONG lTimeout,
                        /* [retval][out] */ LONG *lSafErrorCode);

HRESULT SwitchDesktopMode(/* [in]*/ int nMode, 
	                      /* [in]*/ int nRAType);


////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
#define LAUNCH_TIMEOUT (600) // 1 minute.
#else
#define LAUNCH_TIMEOUT (300) // 10 seconds.
#endif

////////////////////////////////////////////////////////////////////////////////

static const CLSID* pCLSID_PCHUpdate         = &__uuidof( PCHUpdate         );
static const CLSID* pCLSID_PCHUpdateReal     = &__uuidof( PCHUpdateReal     );
static const CLSID* pCLSID_PCHService        = &__uuidof( PCHService        );
static const CLSID* pCLSID_PCHServiceReal    = &__uuidof( PCHServiceReal    );
static const CLSID* pCLSID_MPCConnection     = &__uuidof( MPCConnection     );
static const CLSID* pCLSID_MPCConnectionReal = &__uuidof( MPCConnectionReal );
static const CLSID* pCLSID_MPCUpload         = &__uuidof( MPCUpload         );
static const CLSID* pCLSID_MPCUploadReal     = &__uuidof( MPCUploadReal     );

static const IID*   pIID_IPCHService         = &__uuidof( IPCHService       );

static const WCHAR s_szRegKey   [] = L"SOFTWARE\\Microsoft\\PCHealth\\PchSvc\\Profile";

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

static const WCHAR s_szCmd_HelpSvc   [] = L"\"%WINDIR%\\PCHealth\\HelpCtr\\Binaries\\HelpSvc.exe\" /Embedding";
static const WCHAR s_szCmd_UploadMgr [] = L"\"%WINDIR%\\PCHealth\\UploadLB\\Binaries\\UploadM.exe\" /Embedding";

static CComRedirectorFactory s_HelpSvc[] =
{
    CComRedirectorFactory( pCLSID_PCHService, pCLSID_PCHServiceReal, pIID_IPCHService, s_szCmd_HelpSvc ),
    CComRedirectorFactory( pCLSID_PCHUpdate , pCLSID_PCHUpdateReal , NULL            , s_szCmd_HelpSvc ),
    CComRedirectorFactory( NULL             , NULL                 , NULL            , NULL            ),
};

static CComRedirectorFactory s_UploadMgr[] =
{
    CComRedirectorFactory( pCLSID_MPCUpload    , pCLSID_MPCUploadReal    , NULL, s_szCmd_UploadMgr ),
    CComRedirectorFactory( pCLSID_MPCConnection, pCLSID_MPCConnectionReal, NULL, s_szCmd_UploadMgr ),
    CComRedirectorFactory( NULL                , NULL                    , NULL, NULL              ),
};

static ServiceHandler* s_Services[2];

////////////////////////////////////////////////////////////////////////////////

static const WCHAR s_szCmd_RDSHost   [] = L"\"%WINDIR%\\system32\\RDSHOST.exe\"";

static CComRedirectorFactory g_RDSHost( NULL, &CLSID_SAFRemoteDesktopServerHost, &IID_ISAFRemoteDesktopServerHost, s_szCmd_RDSHost );

HRESULT RDSHost_HACKED_CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj )
{
    return g_RDSHost.CreateInstance( pUnkOuter, riid, ppvObj );
}

////////////////////////////////////////////////////////////////////////////////

CComRedirectorFactory::CComRedirectorFactory( const CLSID* pclsid       ,
                                              const CLSID* pclsidReal   ,
                                              const IID*   piidDirecty  ,
                                              LPCWSTR      szExecutable )
{
    m_pclsid       = pclsid;
    m_pclsidReal   = pclsidReal;
    m_piidDirecty  = piidDirecty;
    m_szExecutable = szExecutable;
    m_dwRegister   = 0;
}

////////////////////

STDMETHODIMP_(ULONG) CComRedirectorFactory::AddRef()
{
    return 1;
}

STDMETHODIMP_(ULONG) CComRedirectorFactory::Release()
{
    return 1;
}

STDMETHODIMP CComRedirectorFactory::QueryInterface(REFIID iid, void ** ppvObject)
{
    if(ppvObject == NULL) return E_POINTER;

    *ppvObject = NULL;

    if(InlineIsEqualGUID( IID_IUnknown     , iid ) ||
       InlineIsEqualGUID( IID_IClassFactory, iid )  )
    {
        *ppvObject = (IClassFactory*)this; // No AddRef, these objects are static...
        return S_OK;
    }
    else if(InlineIsEqualGUID( IID_IDispatch  , iid ) ||
            InlineIsEqualGUID( IID_IPCHUtility, iid )  )
    {
        *ppvObject = (IPCHUtility*)this; // No AddRef, these objects are static...
        return S_OK;
    }
    else if(m_piidDirecty && InlineIsEqualGUID( *m_piidDirecty, iid ))
    {
        return GetServer( NULL, iid, ppvObject );
    }

    return E_NOINTERFACE;
}

////////////////////

STDMETHODIMP CComRedirectorFactory::CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj )
{
    return StartServer( pUnkOuter, riid, ppvObj );
}

STDMETHODIMP CComRedirectorFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

////////////////////

STDMETHODIMP CComRedirectorFactory::CreateObject_RemoteDesktopSession( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                                                       /*[in]         */ long                          lTimeout            ,
                                                                       /*[in]         */ BSTR                          bstrConnectionParms ,
                                                                       /*[in]         */ BSTR                          bstrUserHelpBlob    ,
                                                                       /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               )
{
    return ::CreateObject_RemoteDesktopSession( sharingClass        ,
                                                lTimeout            ,
                                                bstrConnectionParms ,
                                                bstrUserHelpBlob    ,
                                                ppRCS               );
}

////////////////////

STDMETHODIMP CComRedirectorFactory::ConnectToExpert(/* [in]          */ BSTR bstrExpertConnectParm,
                                                    /* [in]          */ LONG lTimeout,
                                                    /* [retval][out] */ LONG *lSafErrorCode)

{
    return ::ConnectToExpert( bstrExpertConnectParm,
                              lTimeout,
                              lSafErrorCode);

}

////////////////////

STDMETHODIMP CComRedirectorFactory::SwitchDesktopMode(/* [in]*/ int nMode, 
	                                                   /* [in]*/ int nRAType)

{
    return ::SwitchDesktopMode(nMode, nRAType);

}

////////////////////

HRESULT CComRedirectorFactory::GetServer( LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj )
{
    return ::CoCreateInstance( *m_pclsidReal, pUnkOuter, CLSCTX_LOCAL_SERVER, riid, ppvObj );
}

bool CComRedirectorFactory::GetCommandLine( /*[out]*/ WCHAR* rgCommandLine, /*[in]*/ DWORD dwSize, /*[out]*/ bool& fProfiling )
{
    fProfiling = false;

    //
    // If there's a string value in the registry for this CLSID, prepend the command line with it.
    //
    {
        WCHAR rgGUID[128];

        if(::StringFromGUID2 ( *m_pclsid, rgGUID, MAXSTRLEN(rgGUID) ) > 0)
        {
            HKEY hKey;

            if(::RegOpenKeyExW( HKEY_LOCAL_MACHINE, s_szRegKey, 0, KEY_READ, &hKey ) == ERROR_SUCCESS)
            {
                WCHAR rgVALUE[MAX_PATH*3];
                DWORD dwVALUE = sizeof(rgVALUE)-1;
                DWORD dwType;

                if(::RegQueryValueExW( hKey, rgGUID, NULL, &dwType, (BYTE*)rgVALUE, &dwVALUE ) == ERROR_SUCCESS && dwType == REG_SZ)
                {
                    rgVALUE[dwVALUE/sizeof(WCHAR)] = 0;

                    if((dwVALUE = ::ExpandEnvironmentStringsW( rgVALUE, rgCommandLine, dwSize )))
                    {
                        rgCommandLine[dwVALUE-1] = ' '; // Padding space.

                        rgCommandLine += dwVALUE;
                        dwSize        -= dwVALUE;

                        fProfiling = true;
                    }
                }

                ::RegCloseKey( hKey );
            }
        }
    }

    //
    // Prepare the command line.
    //
    if(::ExpandEnvironmentStringsW( m_szExecutable, rgCommandLine, dwSize ))
    {
        return true;
    }

    return false;
}

HRESULT CComRedirectorFactory::StartServer( LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj )
{
    HRESULT hr;

    if(FAILED(hr = GetServer( pUnkOuter, riid, ppvObj )))
    {
        WCHAR   rgCommandLine[MAX_PATH*3];
        bool    fProfiling;

        ::EnterCriticalSection( &m_sec );

        //
        // Prepare the command line.
        //
        if(GetCommandLine( rgCommandLine, MAXSTRLEN(rgCommandLine), fProfiling ))
        {
            PROCESS_INFORMATION piProcessInformation;
            STARTUPINFOW        siStartupInfo;
            BOOL                fStarted;

            ::ZeroMemory( (PVOID)&piProcessInformation, sizeof( piProcessInformation ) );
            ::ZeroMemory( (PVOID)&siStartupInfo       , sizeof( siStartupInfo        ) ); siStartupInfo.cb = sizeof( siStartupInfo );

            //
            // Start the process, changing the WinStation to the console one in case of profiling.
            //
            {
                if(fProfiling)
                {
                    //                  siStartupInfo.lpDesktop = L"WinSta0\\Default";
                }

                fStarted = ::CreateProcessW( NULL                  ,
                                             rgCommandLine         ,
                                             NULL                  ,
                                             NULL                  ,
                                             FALSE                 ,
                                             NORMAL_PRIORITY_CLASS ,
                                             NULL                  ,
                                             NULL                  ,
                                             &siStartupInfo        ,
                                             &piProcessInformation );
            }

            if(fStarted)
            {
                int iCount = LAUNCH_TIMEOUT;

                if(fProfiling) iCount *= 10; // Give more time to start.

                while(iCount-- > 0)
                {
                    if(::WaitForSingleObject( piProcessInformation.hProcess, 100 ) != WAIT_TIMEOUT) break; // Process bailed out.

                    if(SUCCEEDED(hr = GetServer( pUnkOuter, riid, ppvObj ))) break;
                }

                if(FAILED(hr))
                {
                    ::TerminateProcess( piProcessInformation.hProcess, 0 );
                }
            }

            if(piProcessInformation.hProcess) ::CloseHandle( piProcessInformation.hProcess );
            if(piProcessInformation.hThread ) ::CloseHandle( piProcessInformation.hThread  );
        }

        ::LeaveCriticalSection( &m_sec );
    }

    return hr;
}

HRESULT CComRedirectorFactory::Register()
{
    ::InitializeCriticalSection( &m_sec );

    if(!m_pclsid) return S_OK;

    return ::CoRegisterClassObject( *m_pclsid                                  ,
                                    (IClassFactory*)this                       ,
                                    CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ,
                                    REGCLS_MULTIPLEUSE                         ,
                                    &m_dwRegister                              );
}

void CComRedirectorFactory::Unregister()
{
    if(m_dwRegister)
    {
        ::CoRevokeClassObject( m_dwRegister );

        m_dwRegister = 0;
    }

    ::DeleteCriticalSection( &m_sec );
}

////////////////////////////////////////////////////////////////////////////////

ServiceHandler::ServiceHandler( /*[in]*/ LPCWSTR szServiceName, /*[in]*/ CComRedirectorFactory* rgClasses )
{
    m_szServiceName   = szServiceName; // LPCWSTR                m_szServiceName;
    m_rgClasses       = rgClasses;     // CComRedirectorFactory* m_rgClasses;
                    				   //
	m_fComInitialized = false;         // bool                   m_fComInitialized;
                    		 		   //
    m_hShutdownEvent  = NULL;          // HANDLE                 m_hShutdownEvent;
                    		 		   //
                    	 			   // SERVICE_STATUS_HANDLE  m_hServiceStatus;
                    				   // SERVICE_STATUS         m_status;

    ::ZeroMemory( &m_status, sizeof( m_status ) );

    m_status.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    m_status.dwCurrentState            = SERVICE_STOPPED;
    m_status.dwControlsAccepted        = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode           = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint              = 0;
    m_status.dwWaitHint                = 0;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if(dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init( NULL, hInstance, NULL );

        DisableThreadLibraryCalls( hInstance );

		s_Services[0] = new ServiceHandler_HelpSvc( L"HelpSvc"  , s_HelpSvc   );
		s_Services[1] = new ServiceHandler        ( L"UploadMgr", s_UploadMgr );

        g_RDSHost.Register();
    }
    else if(dwReason == DLL_PROCESS_DETACH)
    {
		delete s_Services[0];
		delete s_Services[1];

        g_RDSHost.Unregister();

        _Module.Term();
    }

    return TRUE;    // ok
}

DWORD WINAPI _HandlerEx( DWORD  dwControl   , // requested control code
                         DWORD  dwEventType , // event type
                         LPVOID lpEventData , // event data
                         LPVOID lpContext   ) // user-defined context data
{
    ServiceHandler* handler = static_cast<ServiceHandler*>(lpContext);

    return handler->HandlerEx( dwControl   , // requested control code
                               dwEventType , // event type
                               lpEventData ); // user-defined context data
}

void WINAPI ServiceMain( DWORD dwArgc, LPWSTR* lpszArgv )
{
#if 0
    BOOL fWait = true;

    while(fWait)
    {
        Sleep(1000);
    }
#endif

    LPWSTR           szName = lpszArgv[0];
    ServiceHandler** ph     = s_Services;
	int              i;

	for(i=0; i<ARRAYSIZE(s_Services); i++)
	{
		ServiceHandler* h = *ph++;

        if(h && !_wcsicmp( h->m_szServiceName, szName ))
        {
            h->Run(); break;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////

DWORD ServiceHandler::HandlerEx( DWORD  dwControl   , // requested control code
                                 DWORD  dwEventType , // event type
                                 LPVOID lpEventData ) // event data
{
    switch(dwControl)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus( SERVICE_STOP_PENDING );

        if(m_hShutdownEvent) ::SetEvent( m_hShutdownEvent );
        break;

    case SERVICE_CONTROL_PAUSE:
        break;

    case SERVICE_CONTROL_CONTINUE:
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        break;

    default:
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return NO_ERROR;
}


HRESULT ServiceHandler::Initialize()
{
    __MPC_FUNC_ENTRY( COMMONID, "ServiceHandler::Initialize" );

	HRESULT hr;


	m_status.dwWin32ExitCode = S_OK;
	m_status.dwCheckPoint    = 0;
	m_status.dwWaitHint      = 0;
	
	try
	{
		CComRedirectorFactory* classes;


		__MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hServiceStatus = ::RegisterServiceCtrlHandlerExW( m_szServiceName, _HandlerEx, this )));

		SetServiceStatus( SERVICE_START_PENDING );

		////////////////////

		__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoInitializeEx( NULL, COINIT_MULTITHREADED ));
		m_fComInitialized = true;

		for(classes=m_rgClasses; SUCCEEDED(hr) && classes->m_pclsid; classes++)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, classes->Register());
		}

		////////////////////

		__MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hShutdownEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL )));

		SetServiceStatus( SERVICE_RUNNING );
	}
	catch(...)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
	}

	hr = S_OK;


	__MPC_FUNC_CLEANUP;

	__MPC_FUNC_EXIT(hr);
}

void ServiceHandler::WaitUntilStopped()
{
	if(m_hShutdownEvent) ::WaitForSingleObject( m_hShutdownEvent, INFINITE );
}

void ServiceHandler::Cleanup()
{
	if(m_hShutdownEvent)
	{
		::CloseHandle( m_hShutdownEvent );
		
		m_hShutdownEvent = NULL;
	}

	try
	{
		if(m_fComInitialized)
		{
			CComRedirectorFactory* classes;

			for(classes=m_rgClasses; classes->m_pclsid; classes++)
			{
				classes->Unregister();
			}

			::CoUninitialize();
			m_fComInitialized = false;
		}
	}
	catch(...)
	{
	}

	if(m_hServiceStatus)
	{
		SetServiceStatus( SERVICE_STOPPED );
        m_hServiceStatus = NULL;
    }
}


void ServiceHandler::Run()
{
	//
	// When the Run function returns, the service has been stopped.
	//

	if(SUCCEEDED(Initialize()))
	{
		WaitUntilStopped();
	}

	Cleanup();
}

void ServiceHandler::SetServiceStatus( DWORD dwState )
{
    m_status.dwCurrentState = dwState;

    ::SetServiceStatus( m_hServiceStatus, &m_status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\rwnh\src\rwintrnl.cpp ===
/*++

	rwintrnl.cpp

	This file contains classes and methods only for use within 
	the reader/writer locks defined in rw.h

--*/

#include	<windows.h>
#include	<stdio.h>
#include	"rwnew.h"


HANDLE	CWaitingThread::g_rghHandlePool[ POOL_HANDLES ] ;
CRITICAL_SECTION	DebugCrit ;

CHandleInfo	CHandleInfo::s_Head ;
CRITICAL_SECTION	CHandleInfo::s_InUseList ;
CHandleInfo	CHandleInfo::s_FreeHead ;
DWORD	CHandleInfo::s_cFreeList = 0 ;


void	
CHandleInfo::InsertAtHead( CHandleInfo*	pHead	)		{

	CHandleInfo*	pNext = pHead->m_pNext ;
	m_pNext = pNext ;
	m_pPrev = pHead ;
	pNext->m_pPrev = this ;
	pHead->m_pNext = this ;
}

CHandleInfo*
CHandleInfo::RemoveList( ) {
	CHandleInfo*	pNext = m_pNext ;
	CHandleInfo*	pPrev = m_pPrev ;
	pNext->m_pPrev = pPrev ;
	pPrev->m_pNext = pNext ;
	m_pNext = 0 ;
	m_pPrev = 0 ;
	return	this ;
}


void*
CHandleInfo::operator	new(	size_t size ) {
/*++

Routine Description : 

	Allocate memory for a CHandleInfo structure from the system heap !

Arguments : 

	Size of the object, should always be sizeof( CHandleInfo ) !

Return Value : 

	Pointer to allocated memory !

--*/



	_ASSERT( size == sizeof( CHandleInfo ) ) ;
	return	HeapAlloc( GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, size ) ;
}

void
CHandleInfo::operator	delete( void*	pv ) {
/*++

Routine Description : 

	Release memory for a CHandleInfo structure to the system heap !

Arguments : 

	Memory to be freed

Return Value : 

	Nothing !

--*/


	HeapFree( GetProcessHeap(), 0, pv ) ;
}

CHandleInfo::CHandleInfo() : 	
	m_dwSignature( SIGNATURE ), 
	m_pNext( 0 ),
	m_pPrev( 0 ), 
	m_hSemaphore( 0 )
	{
/*++

Routine Description : 

	Construct a CHandleInfo object !

Arguments : 

	Memory to be freed

Return Value : 

	Nothing !

--*/

	m_hSemaphore= CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

}

CHandleInfo::~CHandleInfo() {
/*++

Routine Description : 

	Release memory for a CHandleInfo structure to the system heap !

Arguments : 

	Memory to be freed

Return Value : 

	Nothing !

--*/

	_ASSERT( m_dwSignature == SIGNATURE ) ;
	m_dwSignature = 0 ;

	_ASSERT( m_pNext == 0 || (this == &s_Head || this == &s_FreeHead)) ;
	_ASSERT( m_pPrev == 0 || (this == &s_Head || this == &s_FreeHead)) ;

	if( m_hSemaphore != 0 ) {

		CloseHandle( m_hSemaphore) ;
	}
	m_hSemaphore = 0 ;
}


BOOL
CHandleInfo::InitClass()	{
/*++

Routine Description : 

	Initialize our handle tracking data structures.

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	s_Head.m_pPrev = s_Head.m_pNext = &s_Head ;
	s_FreeHead.m_pPrev = s_FreeHead.m_pNext = &s_FreeHead ;

	InitializeCriticalSection( &s_InUseList ) ;

	EnterCriticalSection( &s_InUseList ) ;

	for( DWORD i=0; i < INITIAL_FREE; i++ ) {

		CHandleInfo*	p = new CHandleInfo() ;
		if( !p ) {
			break ;
		}	else	{
			p->InsertAtHead( &s_FreeHead ) ;
			s_cFreeList ++ ;
		}
	}
	LeaveCriticalSection( &s_InUseList ) ;
	return	i == INITIAL_FREE ;
}

void
CHandleInfo::TermClass()	{
/*++

Routine Description : 

	Destroy our handle tracking structures and release all handles !

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	DeleteCriticalSection( &s_InUseList ) ;

	while( 	s_FreeHead.m_pNext != &s_FreeHead ) {
		CHandleInfo*	p = s_FreeHead.m_pNext->RemoveList() ;
		delete	p ;
	}
	while( 	s_Head.m_pNext != &s_Head ) {
		CHandleInfo*	p = s_Head.m_pNext->RemoveList() ;
		delete	p ;
	}
}

CHandleInfo*
CHandleInfo::AllocHandleInfo()	{
/*++

Routine Description : 

	Allocate an object to hold Handle Information !

Arguments : 

	None.

Return Value : 

	Pointer to a CHandleInfo structure !

--*/

	EnterCriticalSection( &s_InUseList ) ;

	CHandleInfo* p = s_FreeHead.m_pNext ;
	if( p != &s_FreeHead ) {
		p->RemoveList() ;
		p->InsertAtHead( &s_Head ) ;
		s_cFreeList -- ;
	}	else	{
		p = new CHandleInfo() ;
		p->InsertAtHead( &s_Head ) ;
	}
	LeaveCriticalSection( &s_InUseList ) ;

	if( p->m_hSemaphore == 0 ) {
		p->m_hSemaphore = CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

	}
	return	p ;
}

void
CHandleInfo::ReleaseHandleInfo( CHandleInfo* p ) {
/*++

Routine Description : 

	Allocate an object to hold Handle Information !

Arguments : 

	None.

Return Value : 

	Pointer to a CHandleInfo structure !

--*/

	EnterCriticalSection( &s_InUseList ) ;

	p->RemoveList() ;
	if( s_cFreeList < MAX_FREE ) {
		p->InsertAtHead( &s_FreeHead ) ;
		s_cFreeList ++ ;
		p = 0 ;
	}	
	LeaveCriticalSection( &s_InUseList ) ;

	if( p )	{
		delete	p ;
	}
}


BOOL	WINAPI
DllEntryPoint( 
			HINSTANCE	hinstDll,	
			DWORD		dwReason,	
			LPVOID		lpvReserved ) {

	BOOL	fRtn = TRUE ;

	switch( dwReason ) {

		case	DLL_PROCESS_ATTACH :

//DebugBreak() ;

			InitializeCriticalSection( &DebugCrit ) ;

			fRtn &= CHandleInfo::InitClass() ;
			fRtn &= CWaitingThread::InitClass() ;
			CWaitingThread::ThreadEnter() ;

			return	fRtn ;
			break ;


		case	DLL_THREAD_ATTACH : 
			CWaitingThread::ThreadEnter() ;
			break ;

		case	DLL_THREAD_DETACH : 
			CWaitingThread::ThreadExit() ;
			break ;

		case	DLL_PROCESS_DETACH : 

			CWaitingThread::TermClass() ;
			CHandleInfo::TermClass() ;
			break ;

	}
	return	TRUE ;
}


BOOL	WINAPI
DllMain(	HANDLE	hInst,
			ULONG	dwReason,
			LPVOID	lpvReserve )	{

	return	DllEntryPoint( (HINSTANCE)hInst, dwReason, lpvReserve ) ;

}
	


DWORD	CWaitingThread::g_dwThreadHandle = 0 ;

BOOL
CWaitingThread::InitClass()	{

	g_dwThreadHandle = TlsAlloc() ;

	ZeroMemory( g_rghHandlePool, sizeof( g_rghHandlePool ) ) ;

	for( int i=0; i< (sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] )) / 2; i++ )	{
		g_rghHandlePool[i] = 			CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

	}

	return	g_dwThreadHandle != 0xFFFFFFFF ;
}

BOOL
CWaitingThread::TermClass()	{

	for( int i=0; i< (sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] )); i++ )	{

		CloseHandle( g_rghHandlePool[i] ) ;
	}


	return	TlsFree( g_dwThreadHandle ) ;

}

void
CWaitingThread::ThreadEnter()	{

#if 0 
	HANDLE	hSema4 = 
		CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

	TlsSetValue( g_dwThreadHandle, (LPVOID) hSema4 ) ;
#else
	CHandleInfo*	pInfo = CHandleInfo::AllocHandleInfo() ;
	_ASSERT( pInfo != 0 ) ;
	_ASSERT( pInfo->m_hSemaphore != 0 ) ;
	_ASSERT( pInfo->IsValid() ) ;
	TlsSetValue( g_dwThreadHandle, (LPVOID)pInfo ) ;
#endif

}

void
CWaitingThread::ThreadExit()	{

#if 0 
	HANDLE	hSema4 = (HANDLE)TlsGetValue( g_dwThreadHandle ) ;

	if( hSema4 != 0 ) {
		CloseHandle( hSema4 ) ;
	}
#else
	CHandleInfo*	pInfo = (CHandleInfo*)	TlsGetValue( g_dwThreadHandle ) ;
	if( pInfo ) {
	    _ASSERT( pInfo->IsValid() ) ;
	    CHandleInfo::ReleaseHandleInfo( pInfo ) ;
	}
#endif

	TlsSetValue( g_dwThreadHandle, (LPVOID)0 ) ;
}

#if 0 
CWaitingThread::CWaitingThread() : 
		m_hSemaphore( (HANDLE)TlsGetValue( g_dwThreadHandle ) ),
		m_dwError( 0 )	{

	if( m_hSemaphore == 0 ) {
		for( int i=0; 
				m_hSemaphore == 0 && 
				i < sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] );
				i++ ) {
			m_hSemaphore = (HANDLE)InterlockedExchange( (long*)&g_rghHandlePool[i], 0 ) ;
		}

		if( m_hSemaphore == 0 )	{
			m_hSemaphore = 
				CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;
		}
		TlsSetValue( g_dwThreadHandle, (LPVOID)m_hSemaphore ) ;
	}

#ifdef	DEBUG
	m_dwThreadId = GetCurrentThreadId() ;


	long	lPrev = 0 ;
	ReleaseSemaphore( m_hSemaphore, 1, &lPrev ) ;
	_ASSERT( lPrev == 0 ) ;
	DWORD	dw = WaitForSingleObject( m_hSemaphore, 0 ) ;
	_ASSERT( dw == WAIT_OBJECT_0 ) ;
#endif

}
#else
CWaitingThread::CWaitingThread() :
		m_pInfo( (CHandleInfo*)TlsGetValue( g_dwThreadHandle ) ), 
		m_dwError( 0 ) {
	
	if( m_pInfo == 0 ) {
		m_pInfo = CHandleInfo::AllocHandleInfo() ;
		TlsSetValue( g_dwThreadHandle, (LPVOID)m_pInfo ) ;
	}
	if( m_pInfo->m_hSemaphore == 0 ) {
		for( int i=0; 
				m_pInfo->m_hSemaphore == 0 && 
				i < sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] );
				i++ ) {
			m_pInfo->m_hSemaphore = (HANDLE)InterlockedExchange( (long*)&g_rghHandlePool[i], 0 ) ;
		}

		if( m_pInfo->m_hSemaphore == 0 )	{
			m_pInfo->m_hSemaphore = 
				CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

		}
	}

#ifdef	DEBUG
	m_dwThreadId = GetCurrentThreadId() ;


	long	lPrev = 0 ;
	ReleaseSemaphore( m_pInfo->m_hSemaphore, 1, &lPrev ) ;
	_ASSERT( lPrev == 0 ) ;
	DWORD	dw = WaitForSingleObject( m_pInfo->m_hSemaphore, 0 ) ;
	_ASSERT( dw == WAIT_OBJECT_0 ) ;
#endif

}
#endif




CEventQueue::CEventQueue( long	cInitial ) : 
	m_WaitingThreads( cInitial > 0 ), 
	m_ReleaseCount( cInitial  )	{
}

BOOL
CEventQueue::ResumeThreads(	CWaitingThread*	pMyself	)	{

	BOOL	fRtn = FALSE ;
	CWaitingThread*	pThread = m_WaitingThreads.RemoveAndRelease() ;
	long	sign = 1 ;

	while( pThread ) {

		sign = InterlockedDecrement( &m_ReleaseCount ) ;

		if( pThread != pMyself ) {
			_VERIFY( pThread->Release() ) ;
		}	else	{
			fRtn = TRUE ;
		}

		if( sign <= 0 ) {
			break ;
		}

		pThread = m_WaitingThreads.RemoveAndRelease() ;

	}
	return	fRtn ;
}

void
CEventQueue::Release(	long	ReleaseCount )	{

	InterlockedExchangeAdd( &m_ReleaseCount, ReleaseCount ) ;

	ResumeThreads( 0 ) ;

}

void
CEventQueue::Reset()	{

	m_WaitingThreads.Reset() ;

}


void
CEventQueue::WaitForIt(	CWaitingThread&	myself ) {

	if( m_WaitingThreads.Append( &myself ) ) {

		if( !ResumeThreads( &myself ) ) {

			_VERIFY( myself.Wait() ) ;
		}

	}	else	{

		_VERIFY( myself.Wait() ) ;

	}
}

void
CEventQueue::WaitForIt()	{

	CWaitingThread	myself ;

	WaitForIt( myself ) ;
}

CEventQueue::~CEventQueue()	{
}





CSingleReleaseQueue::CSingleReleaseQueue( 
		BOOL	IsSignalled 
		) : 
	m_Waiting( IsSignalled )	{
}

void
CSingleReleaseQueue::WaitForIt(
		CWaitingThread&	myself 
		)	{

	if(	m_Waiting.Append( &myself ) ) {
		CWaitingThread*	pThread = m_Waiting.RemoveAndRelease() ;
		if( !pThread ) {
			_VERIFY( myself.Wait() ) ;
		}	else	if( pThread != &myself ) {

			_VERIFY( pThread->Release() ) ;
			_VERIFY( myself.Wait() ) ;
	
		}
	}	else	{

		_VERIFY( myself.Wait() ) ;

	}
}

void
CSingleReleaseQueue::WaitForIt()	{

	CWaitingThread	myself ;

	WaitForIt( myself ) ;
}

void
CSingleReleaseQueue::Release( ) {

	CWaitingThread*	pThread = m_Waiting.RemoveAndRelease() ;
	if( pThread ) {

#ifdef	DEBUG
		m_ThreadIdNext = pThread->m_dwThreadId ;
#endif

		_VERIFY( pThread->Release() ) ;

	}	else	{

		pThread = (CWaitingThread*)0 ;

	}
}


void	
CCritSection::Enter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( m_hOwner == myself.GetThreadHandle() ) {
		m_RecursionCount ++ ;
	}	else	{

		if( InterlockedIncrement( &m_lock ) == 0 ) {

		}	else	{
			m_queue.WaitForIt(	myself ) ;
		}
		m_hOwner = myself.GetThreadHandle() ;
		m_RecursionCount = 1 ;

#ifdef	DEBUG
		m_dwThreadOwner = GetCurrentThreadId() ;
#endif

		//	_ASSERT( m_RecursionCount == 0 ) ;
	}
}

BOOL
CCritSection::TryEnter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Attempt to acquire the critical section, don't wait
	if somebody else is in the lock !

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( m_hOwner == myself.GetThreadHandle() ) {
		m_RecursionCount ++ ;
	}	else	{

		if( InterlockedCompareExchangePointer( (void**)&m_lock, 0, (void*)-1 ) != (void*)-1 ) {
			return	FALSE ;
		}
		m_hOwner = myself.GetThreadHandle() ;
		m_RecursionCount = 1 ;

#ifdef	DEBUG
		m_dwThreadOwner = GetCurrentThreadId() ;
#endif
		//	_ASSERT( m_RecursionCount == 0 ) ;
	}
	return	TRUE ;
}



void	
CCritSection::Enter( )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

	CWaitingThread	myself ;

	Enter( myself ) ;
}


void	
CCritSection::Leave()		{
/*++

Routine Description : 

	Release the critical section !

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

#ifdef	DEBUG
	_ASSERT( m_dwThreadOwner == GetCurrentThreadId() ) ;
	CWaitingThread	myself ;
	_ASSERT( myself.GetThreadHandle() == m_hOwner ) ;
#endif

	m_RecursionCount -- ;
	if( m_RecursionCount == 0 ) {

		m_hOwner = INVALID_HANDLE_VALUE ;

		if( InterlockedDecrement( &m_lock ) >= 0 ) {
			m_queue.Release() ;
		}
	}
}


void	
CSimpleCritSection::Enter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( InterlockedIncrement( &m_lock ) != 0 ) {
		m_queue.WaitForIt(	myself ) ;
	}
}

BOOL
CSimpleCritSection::TryEnter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Attempt to acquire the critical section, don't wait
	if somebody else is in the lock !

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( InterlockedCompareExchangePointer( (void**)&m_lock, 0, (void*)-1 ) != (void*)-1 ) {
		return	FALSE ;
	}
	return	TRUE ;
}



void	
CSimpleCritSection::Enter( )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

	CWaitingThread	myself ;

	Enter( myself ) ;
}


void	
CSimpleCritSection::Leave()		{
/*++

Routine Description : 

	Release the critical section !

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

	if( InterlockedDecrement( &m_lock ) >= 0 ) {
		m_queue.Release() ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\rwnh\src\rwv3.cpp ===
/*++

	rwv3.cpp

	This file defines another version of reader/writer locks that
	attempt to use no handles !


--*/


#include	<windows.h>
#include	"rwnew.h"
#include	"rwexport.h"

long	const	BlockValue = (-LONG_MAX) / 2; 


CShareLockNH::CShareLockNH()	: 
	m_cReadLock( 0 ),
	m_cOutReaders( 0 ),
	m_cOutAcquiringReaders( 0 ),
	m_hWaitingReaders( 0 ),
	m_hWaitingWriters( 0 )	{

}

#ifdef	DEBUG
extern	CRITICAL_SECTION	DebugCrit ;
#endif


void
CShareLockNH::ShareLock()	{
	if( InterlockedIncrement( (long*)&m_cReadLock ) < 0 ) {
		ShareLockInternal() ;
	}
}

void
CShareLockNH::ShareUnlock()	{
	if( InterlockedDecrement( (long*)&m_cReadLock ) < 0 ) {
		ShareUnlockInternal() ;
	}
}


void
CShareLockNH::ShareLockInternal()	{
/*++

Routine Description : 

	Acquire the lock in shared mode.
	If there is a writer trying to enter the lock, then we will
	have to wait, in which case we have to block on a semaphore handle
	that we or another reader provide.
	In the writer waiting case, we also have to carefully track which
	waiting reader thread is the LAST to be wakened up and return to 
	the caller so we can properly manage the HANDLE used by all the
	reader threads.

Arguments : 
	
	None.

Return Value : 

	None.


--*/



#if 0 
	//
	//	This part of the logic is implemented by ShareLock() - 
	//	which is an inline function !!
	//
	if( InterlockedIncrement( &m_cReadLock ) < 0 ) {
#endif

		//
		//	There is a writer who either owns the lock or is waiting
		//	to acquire the lock - either way he gets to go first and
		//	this thread should be blocked !
		//
		CWaitingThread	myself ;

		//
		//	Get the handle we've saved for this thread !
		//
		HANDLE	h = myself.GetThreadHandle() ;

		//
		//	If we are the first reader here, this function will return
		//	0, otherwise we'll get the handle of the first reader to 
		//	save his handle !
		//
		HANDLE	hBlockOn = InterlockedCompareExchangePointer( (void**)&m_hWaitingReaders, (void*)h, 0 ) ;

		if( hBlockOn == 0 ) {
			hBlockOn= h;
		}

		//
		//	Wait for the writer to release the lock !
		//
		WaitForSingleObject( hBlockOn, INFINITE ) ;


		//
		//	We need to figure out whether we should do anything about
		//	the m_hWaitingReaders value - it needs to be set to 0 before
		//	another reader comes through this path !
		//

		long	l = InterlockedDecrement( (long*)&m_cOutAcquiringReaders ) ;
		_ASSERT( l>=0 ) ;

		if( l == 0 ) {


			//
			//	We are the last reader who was waiting ! 
			//	we can safely manipulate m_hWaitingReaders with no consequences !
			//	If it's our handle, then we'll do nothing with it, 
			//	if it's not our handle we'll return it to the pool of handles !
			//

			m_hWaitingReaders = 0 ;

			if( hBlockOn != h ) {
				myself.PoolHandle( hBlockOn ) ;
			}

			//
			//	A Writer held the lock, and then relinquished it to us readers, 
			//	but he didn't release the Exclusive Lock that let him keep other writers
			//	out.  We do that for him !!!
			//

			m_lock.Leave() ;

		}	else	{
		
			//
			//	Our handle was left in the lock, we need to get rid of our
			//	reference to it, the last reader will return to the pool !
			//
			if( hBlockOn == h ) {

				myself.ClearHandle( h ) ;
			}
		}
#if 0 
	}
#endif
}

void
CShareLockNH::ShareUnlockInternal()	{
/*++

Routine Description : 

	Release the lock from shared mode.
	If a writer is waiting we need to figure out if we're
	the last reader to leave, in which case we wake the writer !

Arguments : 
	
	None.

Return Value : 

	None.


--*/

#if 0 
	//
	//	This portion of the function is moved into an inline function !
	//
	if( InterlockedDecrement( &m_cReadLock ) < 0 ) {
#endif

		//
		//	There is a writer waiting to enter the lock, 
		//	(we assume he's waiting because the thread calling
		//	this presumably had a readlock !)
		//

		//
		//	Restore the count of the number of readers who are 
		//	waiting for the writer to leave !
		//
		InterlockedIncrement( (long*)&m_cReadLock ) ;


		//
		//	Are we the last reader to leave the lock ? 
		//
		if( InterlockedDecrement( (long*)&m_cOutReaders ) == 0 ) {

			//
			//	Yes, we were the last reader - signal the writer !
			//
			long	junk ;
			ReleaseSemaphore( m_hWaitingWriters, 1, &junk ) ;

		}
#if 0 
	}
#endif
}

void
CShareLockNH::ExclusiveLock( )	{
/*++

Routine Description : 

	Acquire the reader/writer lock exclusively.
	Note that we must set up the handle we are to block on if readers
	are in the lock, and clear it up when we leave !

Arguments : 
	
	None.

Return Value : 

	None.

--*/



	CWaitingThread	myself ;

	//
	//	Only one writer in here at a time - grab this lock exclusively !
	//
	m_lock.Enter( myself ) ;

	//
	//	Everytime m_cOutCounter is used, by the time anybody is done with
	//	it, it should be back to zero !
	//
	_ASSERT( m_cOutReaders == 0 ) ;

	//
	//	Set this handle before we do anything to signal readers
	//	that we are waiting 
	//
	m_hWaitingWriters = myself.GetThreadHandle() ;

	long	oldsign = InterlockedExchange( (long*)&m_cReadLock, BlockValue ) ;

	//
	//	oldsign now contains the number of readers who have entered the 
	//	lock and have not yet left it !
	//

	//
	//	Do this as an add, to determine how many readers are still left !
	//

	long	value = InterlockedExchangeAdd( (long*)&m_cOutReaders, oldsign ) + oldsign ;

	//
	//	If value is 0, either there was no readers in the lock when we 
	//	exchanged with m_cReadLock, or they all left (and decremented m_cOutCounter)
	//	before we managed to call InterlockedExchangeAdd !!
	//
	if( value != 0 ) {
		//
		//	A reader will have to signal us !
		//
		WaitForSingleObject( m_hWaitingWriters, INFINITE ) ;
	}
	
	//
	//	There are no longer any writers waiting so no need for this handle !
	//
	m_hWaitingWriters = 0 ;
}


void	inline
CShareLockNH::WakeReaders()		{
/*++

Routine Description : 

	This function awakens the readers who may have been waiting for the
	lock when a writer left the lock.

Arguments : 

	None.

Return Value : 

	None.

--*/

	//
	//	If there were any readers waiting we need to wake them up !
	//
	if( m_cOutAcquiringReaders > 0 ) {

		//
		//	There are readers in the lock, but they may not have setup their
		//	blocking handle yet, so we take part in that !!!
		//
		CWaitingThread	myself ;

		//
		//	Get the handle we've saved for this thread !
		//
		HANDLE	h = myself.GetThreadHandle() ;

		//
		//	If we are the first thread to set the m_hWaitingReaders value we'll get
		//	a 0 back !
		//
		HANDLE	hBlockOn = InterlockedCompareExchangePointer( (void**)&m_hWaitingReaders, (void*)h, 0 ) ;

		if( hBlockOn == 0 ) {
			hBlockOn= h;
		}

		//
		//	Release those readers from the lock 
		//
		long	junk;
		ReleaseSemaphore( hBlockOn, m_cOutAcquiringReaders, &junk ) ;

		//
		//	Our handle was left in the lock, we need to get rid of our
		//	reference to it, the last reader will return to the pool !
		//
		if( hBlockOn == h ) {
			myself.ClearHandle( h ) ;
		}

		//
		//	NOTE : All those readers we just woke up should decrement 
		//	m_cOutCounter to 0 !!
		//
	}	else	{

		m_lock.Leave() ;

	}

}


void
CShareLockNH::ExclusiveUnlock()	{
/*++

Routine Description : 

	Release our exclusive lock on the reader/writer lock.
	Note that we must get an accurate count of waiting readers
	so that the readers we awaken can manage the m_hWaitingReaders value.

Arguments : 
	
	None.

Return Value : 

	None.

--*/


	//
	//	Get the number of readers waiting to enter the lock !
	//	This Addition automatically leaves m_cReadLock with the number
	//	of readers who had been waiting !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, -BlockValue ) - BlockValue ;

	WakeReaders() ;

	//
	//	Let other writers have a shot !!
	//
	//m_lock.Leave() ;
}

void
CShareLockNH::ExclusiveToShared()	{
/*++

Routine Description : 

	Release our exclusive lock on the reader/writer lock, in exchange
	for a read lock.  This cannot fail !

Arguments : 
	
	None.

Return Value : 

	None.

--*/




	//
	//	Get the number of readers waiting to enter the lock !
	//	Note that we add one onto m_cReadLock for our hold on the reader lock, 
	//	but we don't add this to m_cOutCounter, as the number of readers waiting is one smaller !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, 1-BlockValue ) -BlockValue ;

	WakeReaders() ;
	
}

BOOL
CShareLockNH::SharedToExclusive()	{
/*++

Routine Description : 
	
	If there is only one reader in the lock, (and therefore we assume
	that reader is the calling thread), acquire the lock exclusive !!

Arguments :

	None.

Return Value : 

	TRUE if we acquired it exclusive
	If we return FALSE, we still have the lock shared !!


--*/

	//
	//	Try to get the critical section first !
	//
	if( m_lock.TryEnter() ) {

		//
		//	If there is only one reader in the lock we can get this exclusive !!
		//
		if( InterlockedCompareExchange( (long*)&m_cReadLock, BlockValue, 1 ) == 1 ) {
			return	TRUE ;
		}
		m_lock.Leave() ;

	}
	return	FALSE ;
}

BOOL
CShareLockNH::TryShareLock()	{
/*++

Routine Description : 

	Get the lock shared if nobody else is in the lock

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	//
	//	get the initial number of readers in the lock !
	//
	long	temp = m_cReadLock ; 

	while( temp >= 0 ) {

		long	result = InterlockedCompareExchange( 
								(long*)&m_cReadLock, 
								(temp+1),	
								temp 
								) ;
		//
		//	Did we manage to add 1 ? 
		//
		if( result == temp ) {
			return	TRUE ;
		}
		temp = result ;
	}
	//
	//	Writer has or wants the lock - we should go away !
	//
	return	FALSE ;
}

BOOL
CShareLockNH::TryExclusiveLock()	{
/*++

Routine Description : 

	Get the lock exclusively if nobody else is in the lock

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	//
	//
	//

	if( m_lock.TryEnter()	)	{

		if( InterlockedCompareExchange( (long*)&m_cReadLock, 
										BlockValue, 
										0 ) == 0 ) {
			return	TRUE;
		}
		m_lock.Leave() ;
	}
	return	FALSE ;
}


void*
operator	new( size_t size,	DWORD*	pdw )	{
	return	LPVOID(pdw) ;
}


CShareLockExport::CShareLockExport()	{
	m_dwSignature = SIGNATURE ;
	new( m_dwReserved )	CShareLockNH() ;
}

CShareLockExport::~CShareLockExport()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->CShareLockNH::~CShareLockNH() ;
}

void
CShareLockExport::ShareLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ShareLock() ;
}

void
CShareLockExport::ShareUnlock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ShareUnlock() ;
}

void
CShareLockExport::ExclusiveLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveLock() ;
}

void
CShareLockExport::ExclusiveUnlock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveUnlock() ;
}

void
CShareLockExport::ExclusiveToShared()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveToShared() ;
}

BOOL
CShareLockExport::SharedToExclusive()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->SharedToExclusive() ;
}

BOOL
CShareLockExport::TryShareLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->TryShareLock() ;
}

BOOL
CShareLockExport::TryExclusiveLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->TryExclusiveLock() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\shuttle\cobjid.cpp ===
//#---------------------------------------------------------------
//  File:		CObjID.cpp
//        
//	Synopsis:	This file implements the CObjectID class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------
#ifdef	THIS_FILE
#undef	THIS_FILE
#endif
static	char		__szTraceSourceFile[] = __FILE__;
#define	THIS_FILE	__szTraceSourceFile

#include	<windows.h>
#include	"cobjid.h"
#include	"dbgtrace.h"
//+---------------------------------------------------------------
//
//  Function:	CObjectID
//
//  Synopsis:	constructor
//
//  Arguments:	void
//
//  Returns:	void
//
//  History:	HowardCu	Created			8 May 1995
//
//----------------------------------------------------------------
CObjectID::CObjectID( void )
{
	TraceFunctEnter( "CObjectID::CObjectID" );
	m_dwObjectID = INITIALOBJECTID;
	InitializeCriticalSection( &m_ObjIDCritSect );
	TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:	~CObjectID
//
//  Synopsis:	destructor
//
//  Arguments:	void
//
//  Returns:	void
//
//  History:	HowardCu	Created			8 May 1995
//
//----------------------------------------------------------------
CObjectID::~CObjectID( void )
{
	TraceFunctEnter( "CObjectID::~CObjectID" );
	DeleteCriticalSection( &m_ObjIDCritSect );
	TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:	GetUniqueID
//
//  Synopsis:	generate the next object ID
//
//  Arguments:	void
//
//  Returns:	next object ID
//
//  History:	HowardCu	Created			8 May 1995
//
//----------------------------------------------------------------
DWORD 
CObjectID::GetUniqueID( 
	void
	)
{
	DWORD	dwReturnValue;

	TraceFunctEnter( "CObjectID::GetUniqueID" );
	EnterCriticalSection( &m_ObjIDCritSect );
	m_dwObjectID += OBJECTIDINCREMENT;
	if( m_dwObjectID == 0 )
	{
		m_dwObjectID = INITIALOBJECTID;
	}
	dwReturnValue = m_dwObjectID;
	LeaveCriticalSection( &m_ObjIDCritSect );
	DebugTrace( m_dwObjectID, "New object ID assigned 0x%08lx.", m_dwObjectID );
	TraceFunctLeave();
	return dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\shuttle\cpool.cpp ===
//#---------------------------------------------------------------
//  File:       CPool.cpp
//        
//  Synopsis:   This file implements the CPool class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

#include    <windows.h>
#include    "cpool.h"
#include    "dbgtrace.h"

#define     PREAMBLE    (BYTE)'H'
#define     POSTAMBLE   (BYTE)'C'
#define     FILLER      (BYTE)0xCC


//
// Define internal Debug structs designed to help find over/underwrites
//
#ifdef DEBUG
#ifndef DISABLE_CPOOL_DEBUG
#define	CPOOL_DEBUG
#endif
#endif

#ifdef CPOOL_DEBUG

#define	HEAD_SIGNATURE	(DWORD)'daeH'
#define	TAIL_SIGNATURE	(DWORD)'liaT'

#define	FREE_STATE		(DWORD)'eerF'
#define	USED_STATE		(DWORD)'desU'

//
// forward declaration
//
class CPoolDebugTail;

//
// Prefix for CPool instances when in debug mode
//
class CPoolDebugHead {

	public:
		//
		// declared so normal CPool free list can clobber this member
		//
		void*	m_pLink;

		CPoolDebugHead();
		~CPoolDebugHead( void );

	    void *operator new( size_t cSize, void *pInstance )
			{ return	pInstance; };

	    void operator delete (void *pInstance) {};

		//
		// Function to mark the instance in use
		//
		void MarkInUse( DWORD m_dwSignature, DWORD m_cInstanceSize );

		//
		// Function to mark the instance free
		//
		void MarkFree( DWORD m_dwSignature, DWORD m_cInstanceSize );

		//
		// class signature 
		//
		DWORD	m_dwSignature;

		//
		// state; either FREE_STATE or USED_STATE
		//
		DWORD	m_dwState;

		//
		// time of allocation
		//
		SYSTEMTIME	m_time;

		//
		// ThreadID which alloc'd/free'd memory
		//
		DWORD	m_dwThreadID;

		//
		// tail pointer used to find the end
		//
		CPoolDebugTail UNALIGNED	*m_pTailDebug;

		//
		// parent CPool signature
		//
		DWORD	m_dwPoolSignature;

		//
		// parent CPool Fragment
		//
		LPVOID	m_PoolFragment;
};


//
// Suffix for CPool instances when in debug mode
//
class CPoolDebugTail {

	public:
		CPoolDebugTail();
		~CPoolDebugTail( void );

	    void *operator new( size_t cSize, void *pInstance )
			{ return	pInstance; };

	    void operator delete (void *pInstance) {};

		//
		// routine to validate the integrity of the instance
		//
		void	IsValid( DWORD dwPoolSignature, DWORD cInstanceSize );

		//
		// class signature 
		//
		DWORD	m_dwSignature;

		//
		// tail pointer used to find the end
		//
		CPoolDebugHead UNALIGNED	*m_pHeadDebug;
};

//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead
//
//  Synopsis:   constructor; extra init done in def'n
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugHead::CPoolDebugHead( void ) :
					m_dwState( FREE_STATE ),
					m_dwSignature( HEAD_SIGNATURE ),
					m_pTailDebug( NULL )
{
	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}

//+---------------------------------------------------------------
//
//  Function:   ~CPoolDebugHead
//
//  Synopsis:   destructor; only used to assert error conditions
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugHead::~CPoolDebugHead( void )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );
}

//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead::MarkInUse
//
//  Synopsis:   Called when instance is allocated
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugHead::MarkInUse( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );
 	_ASSERT( m_dwState == FREE_STATE );

 	m_dwState = USED_STATE;

	//
	// validate that the application portion is not tampered with
	//
	for (	LPBYTE pb = (LPBYTE)(this+1);
			pb < (LPBYTE)m_pTailDebug;
			pb++ )
	{
		_ASSERT( *pb == FILLER );
	}

	//
	// check the validity of the entire instance
	//
	m_pTailDebug->IsValid( dwPoolSignature, cInstanceSize );

	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}


//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead::MarkFree
//
//  Synopsis:   Called when instance is freed
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugHead::MarkFree( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );

	//
	// Check and set the state
	//
 	_ASSERT( m_dwState == USED_STATE );
 	m_dwState = FREE_STATE;

	//
	// check enough to call IsValid
	//
	_ASSERT( m_pTailDebug != 0 );
	_ASSERT( (DWORD_PTR)m_pTailDebug > (DWORD_PTR)this );

	_ASSERT( m_dwThreadID != 0 ) ;

	//
	// check the validity of the entire instance
	//
	m_pTailDebug->IsValid( dwPoolSignature, cInstanceSize );

	//
	// set the application data to filler
	//
	FillMemory( (LPBYTE)(this+1),
				(DWORD)((LPBYTE)m_pTailDebug - (LPBYTE)(this+1)),
				FILLER );

	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}


//+---------------------------------------------------------------
//
//  Function:   CPoolDebugTail
//
//  Synopsis:   constructor; extra init done in def'n
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugTail::CPoolDebugTail( void ) :
					m_dwSignature( TAIL_SIGNATURE ),
					m_pHeadDebug( NULL )
{
}

//+---------------------------------------------------------------
//
//  Function:   ~CPoolDebugTail
//
//  Synopsis:   destructor; only used to assert error conditions
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugTail::~CPoolDebugTail( void )
{
	_ASSERT( m_dwSignature == TAIL_SIGNATURE );
}


//+---------------------------------------------------------------
//
//  Function:   IsValid
//
//  Synopsis:   check validity of instance
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugTail::IsValid( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == TAIL_SIGNATURE );

	//
	// validate that the head is offset at the correct location
	//
	_ASSERT( m_pHeadDebug != NULL );
	_ASSERT( (UINT_PTR)m_pHeadDebug == (UINT_PTR)(this+1) - cInstanceSize );

	//
	// validate the head structure
	//
	_ASSERT( m_pHeadDebug->m_dwSignature == HEAD_SIGNATURE );
	_ASSERT( m_pHeadDebug->m_dwPoolSignature == dwPoolSignature );
	_ASSERT( m_pHeadDebug->m_pTailDebug == this );
	_ASSERT( m_pHeadDebug->m_dwState == FREE_STATE ||
			 m_pHeadDebug->m_dwState == USED_STATE );
}


#endif

//+---------------------------------------------------------------
//
//  Function:   CPool
//
//  Synopsis:   constructor
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    gordm	Created         5 Jul 1995
//
//----------------------------------------------------------------
CPool::CPool( DWORD dwSignature ) : m_dwSignature( dwSignature )
{
    TraceFunctEnter( "CPool::CPool" );

    m_pFreeList = NULL;
    m_pExtraFreeLink = NULL;

	//
	// Debug variables to help catch heap bugs
	//
	m_pLastAlloc = NULL;
	m_pLastExtraAlloc = NULL;

	m_cTotalFrees = 0;
	m_cTotalAllocs = 0;
	m_cTotalExtraAllocs = 0;

	m_cInstanceSize = 0;

	//
	// Avail + InUse should equal Committed if we're not
	// in grow/alloc or free.  Diagnostic and admin only
	// This will keep code in critsec as small as possible
	//
	m_cNumberAvail = 0;
	m_cNumberInUse = 0;
	m_cNumberCommitted = 0;

    InitializeCriticalSection( &m_PoolCriticalSection );

	//
	// initialize the fragment member variables
	//
	m_cFragmentInstances = 0;
	m_cFragments = 0;
	ZeroMemory( m_pFragments, sizeof(m_pFragments) );

    TraceFunctLeave();
}


//+---------------------------------------------------------------
//
//  Function:   ~CPool
//
//  Synopsis:   destructor
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
CPool::~CPool( void )
{
    TraceFunctEnter( "CPool::~CPool" );

    _ASSERT( m_cNumberInUse == 0 );

	for ( int i=0; i<MAX_CPOOL_FRAGMENTS; i++ )
	{
		_ASSERT( m_pFragments[i] == NULL );
	}

    DebugTrace( (LPARAM)this,
                "CPool: %x  EntryCount: %d   ContentionCount: %d, Allocs: %d, Frees: %d",
                m_dwSignature,
                GetEntryCount(),
                GetContentionCount(),
                GetTotalAllocCount(),
                GetTotalFreeCount() );

    DeleteCriticalSection( &m_PoolCriticalSection );

    TraceFunctLeave();
}


//+---------------------------------------------------------------
//
//  Function:   Alloc
//
//  Synopsis:   Allocates a new instance from the pool
//
//  Arguments:  void
//
//  Returns:    pointer to the new instance
//
//  History:    gordm		Created			5 Jul 1995
//
//----------------------------------------------------------------
void* CPool::Alloc( void )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::Alloc" );
#endif

    Link* pAlloc;

    IsValid();

	//
	// moved outside of the critsec because it should not be necessary
	// to protect this variable.  inc before the alloc so this var wraps
	// the actual allocation
	//
	InterlockedIncrement( (LPLONG)&m_cNumberInUse );

	//
	// check the extra pointer to avoid the critsec path if
	// possible.  big wins because we can potentially avoid
	// the extra code and the wait on semaphore
	//
	pAlloc = (Link*)InterlockedExchangePointer( (PVOID*)&m_pExtraFreeLink, NULL );
	if ( pAlloc == NULL )
	{

    	EnterCriticalSection( &m_PoolCriticalSection );

	    //
    	// commit more memory if the list is empty
	    //
    	if ( (m_pFreeList == NULL) && (m_cNumberCommitted < m_cMaxInstances) )
	    {
			GrowPool();
		}

    	//
	    // try to allocate a Descriptor from the free list
    	//
	    if ( (pAlloc = m_pFreeList) != NULL )
		{
			m_pFreeList = pAlloc->pNext;
		}

		m_pLastAlloc = pAlloc;
	    LeaveCriticalSection( &m_PoolCriticalSection );
	}
	else
	{
		m_pLastExtraAlloc = pAlloc;
	    m_cTotalExtraAllocs++;
	}

	//
	// alloc failed
	//	
	if ( pAlloc == NULL )
	{
		InterlockedDecrement( (LPLONG)&m_cNumberInUse );
	}
	else
	{
		//
		// debug/admin use only - ok to do outside of critsec
		//
	    m_cTotalAllocs++;

#ifdef CPOOL_DEBUG
		CPoolDebugHead*	pHead = (CPoolDebugHead*)pAlloc;

		//
		// validate that the address in the range
		//
		_ASSERT( (char*)pAlloc >= pHead->m_PoolFragment );
		_ASSERT( (char*)pAlloc <  (char*)pHead->m_PoolFragment +
								  m_cNumberCommitted*m_cInstanceSize );

		pHead->MarkInUse( m_dwSignature, m_cInstanceSize );
		pAlloc = (Link*)(pHead+1);
#endif

	}

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Alloc: 0x%08X", pAlloc );
    TraceFunctLeave();
#endif
    return	(void*)pAlloc;
}


//+---------------------------------------------------------------
//
//  Function:   Free
//
//  Synopsis:   frees the instances
//
//  Arguments:  pInstance - a pointer to the CDescriptor
//
//  Returns:    void
//
//  History:    gordm    Created         5 Jul 1995
//
//----------------------------------------------------------------
void CPool::Free( void* pInstance )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::Free" );
#endif

#ifdef CPOOL_DEBUG
		CPoolDebugHead*	pHead = ((CPoolDebugHead*)pInstance) - 1;

		//
		// validate that the address in the range
		//
		_ASSERT( (char*)pInstance >=pHead->m_PoolFragment);
		_ASSERT( (char*)pInstance < (char*)pHead->m_PoolFragment +
									m_cNumberCommitted*m_cInstanceSize );

		pHead->MarkFree( m_dwSignature, m_cInstanceSize );
		pInstance = (void*)pHead;
#endif

    IsValid();

    _ASSERT(m_cNumberInUse > 0);

	pInstance = InterlockedExchangePointer( (LPVOID *)&m_pExtraFreeLink, pInstance );
	//
	// free the previous extra pointer if one existed
	//
	if ( pInstance != NULL )
	{
	    EnterCriticalSection( &m_PoolCriticalSection );

		((Link*)pInstance)->pNext = m_pFreeList;
		 m_pFreeList = (Link*)pInstance;

    	LeaveCriticalSection( &m_PoolCriticalSection );
	}

	//
	// moved outside of the critsec because it should not be necessary
	// to protect this variable. We'll think this list is empty only
	// when we get to this point.  This var is inc'd before entering
	// the critsec and is dec'd if the operation fails.
	//
	InterlockedDecrement( (LPLONG)&m_cNumberInUse );

	//
	// debug/admin use only - ok to do outside of critsec - deletes don't fail
	//
    m_cTotalFrees++;

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Freed: 0x%08X", pInstance );
    TraceFunctLeave();
#endif
}



//
// setup a const DWORD for size manipulation
//
const DWORD	KB = 1024;

//+---------------------------------------------------------------
//
//  Function:   ReserveMemory
//
//  Synopsis:   Initializes the pool
//
//  Arguments:  NumDescriptors - the number of total descriptors in the pool
//              DescriptorSize - the size of any one descriptor
//              Signature      - object signature
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
BOOL CPool::ReserveMemory(	DWORD MaxInstances,
							DWORD InstanceSize,
							DWORD IncrementSize )
{
    TraceFunctEnter( "CPool::ReserveMemory" );

	DWORD cFragments;
	DWORD cFragmentInstances;
	DWORD cIncrementInstances;

	_ASSERT( MaxInstances != 0 );
	_ASSERT( InstanceSize >= sizeof(struct Link) );

#ifdef CPOOL_DEBUG
	InstanceSize += sizeof( CPoolDebugHead ) + sizeof( CPoolDebugTail );
#endif

	if ( IncrementSize == DEFAULT_ALLOC_INCREMENT )
	{
		//
		// ensure we go to the OS for at least 8 instances at a time
		//
		if ( InstanceSize <= 4*KB / 8 )
		{
			cIncrementInstances = 4*KB / InstanceSize;
		}
		else if ( InstanceSize <= 64*KB / 8 )
		{
			cIncrementInstances = 64*KB / InstanceSize;
		}
		else
		{
			cIncrementInstances = min( MaxInstances, 8 );
		}
	}
	else
	{
		cIncrementInstances = IncrementSize;
	}

	//
	// now calculate the number larger fragments
	//
	if ( cIncrementInstances > MaxInstances )
	{
		//
		// no need for CPool; but we shouldn't alloc more than necessary
		//
		cFragmentInstances = cIncrementInstances = MaxInstances;
		cFragments = 1;
	}
	else
	{
		//
		// Round up MaxInstances to a integral number of IncrementSize
		//
	    MaxInstances += cIncrementInstances - 1;
    	MaxInstances /= cIncrementInstances;
    	MaxInstances *= cIncrementInstances;

		//
		// as an initial attempt divide the number of instances by max frags
		//
		cFragmentInstances = (MaxInstances + MAX_CPOOL_FRAGMENTS - 1) /
						MAX_CPOOL_FRAGMENTS;

		if ( cFragmentInstances == 0 )
		{
			cFragmentInstances = MaxInstances;
			cFragments = 1;
		}
		else
		{
			//
			// round up the number of instances in a fragment to an
			// integral number of IncrementSizes
			//
			cFragmentInstances += cIncrementInstances - 1;
			cFragmentInstances /= cIncrementInstances;
			cFragmentInstances *= cIncrementInstances;

			//
			// recalculate the number of fragments required based on the integral
			// number of IncrementSizes ( last one may no longer be required )
			//
			cFragments = (MaxInstances + cFragmentInstances - 1) /
						cFragmentInstances;
		}
	}

	_ASSERT( cFragments > 0 );
	_ASSERT( cFragments*cFragmentInstances >= MaxInstances );

	m_cInstanceSize = InstanceSize;
	m_cMaxInstances = MaxInstances;
	m_cFragments    = cFragments;

	m_cFragmentInstances  = cFragmentInstances;
	m_cIncrementInstances = cIncrementInstances;

	TraceFunctLeave();
	return	TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   ReleaseMemory
//
//  Synopsis:   Releases the pool
//
//  Arguments:  none
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
BOOL CPool::ReleaseMemory( void )
{
    TraceFunctEnter( "CPool::ReleaseMemory" );

	BOOL	bFree = TRUE;
	DWORD	i, cStart;

    EnterCriticalSection( &m_PoolCriticalSection );

	for ( i=cStart=0; i<m_cFragments; i++, cStart += m_cFragmentInstances )
	{
		LPVOID	pHeap = m_pFragments[i];
		if ( pHeap != NULL )
		{
			_ASSERT( cStart < m_cNumberCommitted );

			DWORD	cSize = min( m_cFragmentInstances, m_cNumberCommitted-cStart );

			_VERIFY( bFree = VirtualFree( pHeap, cSize*m_cInstanceSize, MEM_DECOMMIT ) );
			_VERIFY( bFree &=VirtualFree( pHeap, 0, MEM_RELEASE ) );

			if ( bFree == FALSE )
			{
				ErrorTrace( (LPARAM)this, "VirtualFree failed: err %d", GetLastError() );
				break;
			}	

			m_pFragments[i] = NULL;
		}
		else
		{
			break;
		}
	}
    LeaveCriticalSection( &m_PoolCriticalSection );

	//
	// zero out important data fields
	//
    m_pFreeList = NULL;
    m_pExtraFreeLink = NULL;

	m_cNumberCommitted = 0;

	return	bFree;
}

#ifdef CPOOL_DEBUG
//+---------------------------------------------------------------
//
//  Function:   InitDebugInstance
//
//  Synopsis:   sets up the appropriate debug class variables
//
//  Arguments:  void* pInstance: the new instance
//				DWORD dwPoolSignature: parent Pool signature
//				DWORD cInstanceSize: size of the enlarged instance
//
//  Returns:    void
//
//  History:    gordm		Created			11 Jan 1996
//
//----------------------------------------------------------------
void InitDebugInstance(
	char* pInstance,
	DWORD dwPoolSignature,
	DWORD cInstanceSize,
	LPVOID pPoolFragment
	)
{
	CPoolDebugHead* pHead = new( pInstance ) CPoolDebugHead();
	CPoolDebugTail* pTail = new( pInstance +
								 cInstanceSize -
								 sizeof(CPoolDebugTail) ) CPoolDebugTail();

	pHead->m_pTailDebug = pTail;
	pTail->m_pHeadDebug = pHead;

	//
	// helps with debugging to see the parent CPool signature
	//
	pHead->m_dwPoolSignature = dwPoolSignature;

	//
	// helps with asserts for valid ranges
	//
	pHead->m_PoolFragment = pPoolFragment;

	//
	// fake out the state before calling mark Free
	//
	pHead->m_dwState = USED_STATE;
	pHead->MarkFree( dwPoolSignature, cInstanceSize );
}
#endif


//+---------------------------------------------------------------
//
//  Function:   GrowPool
//
//  Synopsis:   grows the number of committed instances in the pool
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    gordm		Created			5 Jul 1995
//
//----------------------------------------------------------------
void CPool::GrowPool( void )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::GrowPool" );
#endif

	DWORD	cFragment = m_cNumberCommitted / m_cFragmentInstances;
	DWORD	cStart = m_cNumberCommitted % m_cFragmentInstances;
	DWORD   cbSize = (cStart+m_cIncrementInstances) * m_cInstanceSize;

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Expanding the pool to %d descriptors",
				cNewCommit );
#endif

	//
	// if we're starting a new fragment
	//
	if ( cStart == 0 )
	{
		//
		// if we are at a boundary of a fragment Reserve the next fragment
		m_pFragments[cFragment] = VirtualAlloc(
									NULL,
									m_cFragmentInstances*m_cInstanceSize,
									MEM_RESERVE | MEM_TOP_DOWN,
									PAGE_NOACCESS
									);

		if ( m_pFragments[cFragment] == NULL )
		{
#ifdef	ALLOC_TRACING
			ErrorTrace( (LPARAM)this,
						"Could not reserve more memory: error = %d",
						GetLastError() );
#endif
			return;
		}

	}

	LPVOID	pHeap = m_pFragments[cFragment];

	if ( VirtualAlloc(  pHeap,
						cbSize,
						MEM_COMMIT,
						PAGE_READWRITE ) != NULL )
	{
        char* pStart = (char*)pHeap + cStart*m_cInstanceSize;
        char* pLast =  (char*)pHeap + cbSize - m_cInstanceSize;

		//
		// run the list joining the next pointers
		// possible because we own the critsec
		//
        for ( char* p=pStart; p<pLast; p+=m_cInstanceSize)
        {

#ifdef CPOOL_DEBUG
			InitDebugInstance( p, m_dwSignature, m_cInstanceSize, pHeap );
#endif
			//
			// statement works for CPOOL_DEBUG as well because
			// we reserve the first 4 bytes of CPoolDebugHead
			//
			((Link*)p)->pNext = (Link*)(p+m_cInstanceSize);
		}

		//
		// terminate and then set the head to beginning of new list
		//
#ifdef CPOOL_DEBUG
		InitDebugInstance( pLast, m_dwSignature, m_cInstanceSize, pHeap );
#endif

		((Link*)pLast)->pNext = NULL;
		m_pFreeList = (Link*)pStart;

		m_cNumberCommitted += m_cIncrementInstances;
	}

#ifdef	ALLOC_TRACING
	else
	{
		ErrorTrace( (LPARAM)this,
					"Could not commit another descriptor: error = %d",
					GetLastError() );
	}
    TraceFunctLeave();
#endif

}


//+---------------------------------------------------------------
//
//  Function:   GetContentionCount
//
//  Synopsis:   Returns the contention count on the alloc/free
//				critsec
//
//  Arguments:  void
//
//  Returns:    the actual count
//
//----------------------------------------------------------------
DWORD CPool::GetContentionCount( void )
{
	return	m_PoolCriticalSection.DebugInfo != NULL ?
			m_PoolCriticalSection.DebugInfo->ContentionCount :
			0 ;
}

//+---------------------------------------------------------------
//
//  Function:   GetEntryCount
//
//  Synopsis:   Returns the entry count on the alloc/free
//				critsec
//
//  Arguments:  void
//
//  Returns:    the actual count
//
//----------------------------------------------------------------
DWORD CPool::GetEntryCount( void )
{
	return	m_PoolCriticalSection.DebugInfo != NULL ?
			m_PoolCriticalSection.DebugInfo->EntryCount :
			0 ;
}



//+---------------------------------------------------------------
//
//  Function:   GetInstanceSize
//
//  Synopsis:   Returns the application's instance size
//
//  Arguments:  void
//
//  Returns:    the instance size of the app
//
//----------------------------------------------------------------
DWORD CPool::GetInstanceSize( void )
{
#ifdef CPOOL_DEBUG
	return	m_cInstanceSize - sizeof(CPoolDebugHead) - sizeof(CPoolDebugTail);
#else
	return	m_cInstanceSize;
#endif
}



#ifdef DEBUG
//+---------------------------------------------------------------
//
//  Function:   IsValid
//
//  Synopsis:   Validates the pool signature
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
inline void CPool::IsValid( void )
{
	_ASSERT( m_cMaxInstances != 0 );
	_ASSERT( m_cInstanceSize >= sizeof(struct Link) );
	_ASSERT( m_cIncrementInstances != 0 );
	_ASSERT( m_dwSignature != 0 );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\shuttle\pxpacket.cpp ===
//#---------------------------------------------------------------
//  File:       pxpacket.cpp
//        
//  Synopsis:   This class contains the implementation of the 
//				CProxyPacket class.
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    t-alexwe
//----------------------------------------------------------------

#include <windows.h>
#include <winsock.h>
#include "dbgtrace.h"
#include "pxpacket.h"

//+----------------------------------------------------------------------
//
//	Function: 	PProxyPacket
//
//	Synopsis: 	constructor
//	
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
CProxyPacket::CProxyPacket() 
{
	clear();
}

//+----------------------------------------------------------------------
//
//	Function: 	~ProxyConnector
//
//	Synopsis: 	destructor
//	
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
CProxyPacket::~CProxyPacket()
{
	clear();
}

//+----------------------------------------------------------------------
//
//	Function: 	addMessage
//
//	Synopsis: 	Adds a message to the packet.  the message data is assumed
//				to have been written to the area returned by 
//				getNextDataPointer().  cData must be <= getAvailableSpace()
//	
//	Arguments:	wCommand	  - the message command
//				cData		  - number of bytes of data
//
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
void CProxyPacket::addMessage(	WORD		wCommand,
								WORD		cData	)
{
	TraceFunctEnter("CProxyPacket::AddMessage");

	_ASSERT(cData <= getAvailableSpace());
	_ASSERT(cMessages < MAXMSGSPERPACKET);

	DebugTrace((LPARAM) this, "adding message: wCommand = 0x%x  cData = %i",
		wCommand, cData);

	pMessages[cMessages].wCommand = wCommand;
	pMessages[cMessages].cOffset = cLength - PACKETHDRSIZE;
	pMessages[cMessages].cData = cData;
	cLength += cData;
	cMessages++;

	TraceFunctLeave();
}

//+----------------------------------------------------------------------
//
//	Function: 	getMessage
//
//	Synopsis: 	Gets the data pointer, size of data, and command from
//				a message in a packet.  
//	
//	Arguments:	wIndex		  - the message index in the packet
//				pwCommand	  - returned: the message command
//				cData		  - returned: the size of the data buffer
//
//	Returns:	pointer to the data buffer, or NULL on error.
//
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
PVOID CProxyPacket::getMessage(	WORD		wIndex,
								PWORD		pwCommand,
								PWORD		pcData	)
{
	TraceFunctEnter("CProxyPacket::GetMessage");
	WORD cOffset = pMessages[wIndex].cOffset;

	_ASSERT(wIndex < getMessageCount());

	*pcData = pMessages[wIndex].cData;
	//
	// make sure that the data length is valid
	//
	// algorithm:  if this is the last message then make sure that
	// the data count is the same as the amount of space left in the
	// packet data area.  if this is not the last message make sure
	// that the space in the packet data area (marked by the messages
	// cOffset and the next messages cOffset) is the same size as
	// the messages cData.
	//
	if (!(((wIndex == cMessages - 1) &&
		  (*pcData == cLength - PACKETHDRSIZE - cOffset)) ||
		 (*pcData == pMessages[wIndex + 1].cOffset - cOffset))) 
	{
		TraceFunctLeave();
		return NULL;
	} else
	{
		*pwCommand = pMessages[wIndex].wCommand;
		DebugTrace((LPARAM) this, "getting msg: wCommand = 0x%x  cData = %i",
			*pwCommand, *pcData);
		TraceFunctLeave();
		return &(pData[pMessages[wIndex].cOffset]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\symres\utest\stdatl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\symres\symres.cpp ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    symres.cpp

Abstract:
    Symbol translator main file
    implements symbol translator function in DLL
    takes a callstack entry as input, and resolves symbol name

Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/29/99 - Created
********************************************************************/

#include <windows.h>
#include <dbgtrace.h>
#include <traceids.h>
#include <list>
#include "symdef.h"
#include <imagehlp.h>

// for trace output to include filename
#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[]=__FILE__;
#define THIS_FILE __szTraceSourceFile

#define TRACE_ID SYMRESMAINID

// global variable that stores thread local storage index
DWORD   g_dwTlsIndex;

// location of sym files repository and log file
WCHAR   g_szwSymDir[MAX_PATH];
WCHAR   g_szwLogFile[MAX_PATH];


// strip off path and extension from filename
void
SplitExtension(
        LPWSTR szwFullname,         // [in] full name
        LPWSTR szwName,             // [out] name part
        LPWSTR szwExt               // [out] extension part
        )
{
    LPWSTR  plast = NULL;
    LPWSTR  pfront = NULL;

    TraceFunctEnter("SplitExtension");

    if (pfront = wcsrchr(szwFullname, L'\\')) 
    {
        pfront++;
        lstrcpyW(szwName,pfront);
    }
    else 
    {
        lstrcpyW(szwName,szwFullname);
    }

    if (plast = wcsrchr(szwName, L'.')) 
    {
        *plast = L'\0';
        plast++;
        lstrcpyW(szwExt,plast);
    }
    else
    {
        lstrcpyW(szwExt, L"");
    }

    TraceFunctLeave();
}



// undecorate symbol name 
void                         
UndecorateSymbol(
        LPTSTR szSymbol         // [in] [out] function name undecorated in place
        )
{
    TCHAR            szTemp[MAX_PATH];
    PIMAGEHLP_SYMBOL pihsym;
    DWORD            dwSize;
   
    TraceFunctEnter("UndecorateSymbol");

    dwSize = sizeof(IMAGEHLP_SYMBOL)+MAX_PATH;
    pihsym = (IMAGEHLP_SYMBOL *) new BYTE[dwSize];
    if (pihsym)
    {
        pihsym->SizeOfStruct = dwSize;
        pihsym->Address = 0;
        pihsym->Flags = 0;
        pihsym->MaxNameLength = MAX_PATH;
        lstrcpy(pihsym->Name,szSymbol);
        SymUnDName(pihsym,szTemp,MAX_PATH);
        lstrcpy(szSymbol,szTemp);
        delete [] pihsym;
    }
    else 
    {
        ErrorTrace(TRACE_ID, "Cannot allocate memory");
    }

    TraceFunctLeave();
}


// select file from list of open files, or open and add to list
// maintain files in usage order, least recently used at end of list
OPENFILE*                                           // pointer to open file info
GetFile(
        LPWSTR szwModule                            // [in] name of file
        )
{
    OPENFILE*                       pFile = NULL;
    OPENFILE*                       pLast = NULL;
    MAPDEF                          map;
    DWORD                           dwCread;
    std::list<OPENFILE *> *         pOpenFilesList = NULL;
    std::list<OPENFILE *>::iterator it;
    TCHAR                           szTarget[MAX_PATH + MAX_PATH];


    TraceFunctEnter("GetFile");

    // get file list pointer from thread local storage
    pOpenFilesList = (std::list<OPENFILE *> *) TlsGetValue(g_dwTlsIndex);

    if (NO_ERROR != GetLastError() || !pOpenFilesList)
    {
        ErrorTrace(TRACE_ID, "Error reading TLS");
        goto exit;
    }

    // search open list to see if file is already open
    it = pOpenFilesList->begin();
    while (it != pOpenFilesList->end())
    {
        if (!lstrcmpiW((*it)->szwName,szwModule))
        {
            // move the file to the beginning of list
            // so that the LRU file is at the end
            pFile = *it;
            pOpenFilesList->erase(it);
            pOpenFilesList->push_front(pFile);
            break;
        }
        it++;
    }


    if (it == pOpenFilesList->end())  // not open, so open and store handle
    {
        pFile = new OPENFILE;
        if (!pFile)
        {
            ErrorTrace(TRACE_ID, "Cannot allocate memory");
            goto exit;
        }

        // open SYM file
        pFile->hfFile = CreateFileW(szwModule,
                                   GENERIC_READ,
                                   FILE_SHARE_READ, 
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL, 
                                   NULL);

        if (INVALID_HANDLE_VALUE == pFile->hfFile)
        {
            ErrorTrace(TRACE_ID,"Error opening file %ls",szwModule);
            delete pFile;
            pFile = NULL;
            goto exit;
        }

        // copy filename and version into pFile node
        lstrcpyW(pFile->szwName, szwModule);

        // read map definition
        ReadFile(pFile->hfFile, &map, sizeof(MAPDEF)-1, &dwCread, NULL);

        if (dwCread != sizeof(MAPDEF)-1)
        {
            ErrorTrace(TRACE_ID, "Error reading file");
            delete pFile;
            pFile = NULL;
            goto exit;
        }

        pFile->ulFirstSeg = map.md_spseg*16;
        pFile->nSeg = map.md_cseg;
        pFile->psCurSymDefPtrs = NULL;

        pOpenFilesList->push_front(pFile);
    }


    // maintain at most MAXOPENFILES open files
    if (pOpenFilesList->size() > MAXOPENFILES)
    {
        // close last file in list
        pLast = pOpenFilesList->back();
        if (pLast)
        {
            CloseHandle(pLast->hfFile);
            if (pLast->psCurSymDefPtrs)
            {
                delete [] pLast->psCurSymDefPtrs;
                pLast->psCurSymDefPtrs = NULL;
            }
            delete pLast;
            pOpenFilesList->pop_back();
        }
        else     // something is amiss here
        {
            FatalTrace(TRACE_ID,"Error reading open files list");
            goto exit;
        }
    }

exit:
    TraceFunctLeave();
    return pFile;
}


// read segment defintion for dwSection 
ULONG                                   // return offset of segment definition, 0 if failed
GetSegDef(
        OPENFILE*     pFile,            // [in] pointer to open file info
        DWORD         dwSection,        // [in] section number
        SEGDEF*       pSeg              // [out] pointer to segment definition
        )
{
    ULONG   ulCurSeg = pFile->ulFirstSeg;
    int     iSectionIndex = 0;
    DWORD   dwCread;

    TraceFunctEnter("GetSegDef");

    // step through segments
    while (iSectionIndex < pFile->nSeg)
    {
        // go to segment beginning
        if (SetFilePointer(pFile->hfFile, ulCurSeg, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            ErrorTrace(TRACE_ID, "Cannot set file pointer");
            ulCurSeg = 0;
            break;
        }

        // read seg defn
        if (!ReadFile(pFile->hfFile, pSeg, sizeof(SEGDEF)-1, &dwCread, NULL))
        {
            ErrorTrace(TRACE_ID, "Cannot read segment definition");
            ulCurSeg = 0;
            break;
        }

        iSectionIndex++;
        if (iSectionIndex == dwSection)   // gotcha
        {
            break;
        }

        // go to next segment definition
        ulCurSeg = pSeg->gd_spsegnext*16;
    }

    // found our section and it's non-empty?
    if (iSectionIndex != dwSection || !pSeg->gd_csym) // no
    {
        ulCurSeg = 0;
    }

    TraceFunctLeave();
    return ulCurSeg;
}


// parse sym file to resolve address
void 
GetNameFromAddr(
        LPWSTR      szwModule,           // [in] name of symbol file
        DWORD       dwSection,           // [in] section part of address to resolve
        UINT_PTR    offset,              // [in] offset part of address to resolve
        LPWSTR      szwFuncName          // [out] resolved function name, 
        )                                //       "<no symbols>" otherwise
{
    SEGDEF              seg;
    DWORD               dwSymAddr;
    LPTSTR              szMapName;
    LPTSTR              szSegName;
    TCHAR               szSymName[MAX_NAME+1];
    TCHAR               szPrevName[MAX_NAME+1];
    TCHAR               sztFuncName[MAX_NAME+1];
    int                 i;
    int                 j;
    int                 nNameLen;
    DWORD               dwCread;
    int                 iSectionIndex;
    int                 nToRead;
    unsigned char       cName;
    ULONG               ulCurSeg;
    ULONG               ulSymNameOffset;
    ULONG               ulPrevNameOffset;
    OPENFILE*           pFile = NULL;
    HANDLE              hfFile;
    FILE*               fDump = NULL;
    BOOL                fSuccess = FALSE;
    HANDLE              hfLogFile = NULL;
    DWORD               dwWritten;
    TCHAR               szWrite[MAX_PATH + 50];
    DWORD               dwArrayOffset;
    DWORD               dwSymOffset;

    TraceFunctEnter("GetNameFromAddr");

    // be pessimistic
    lstrcpy(sztFuncName,TEXT("<no symbol>"));

    // get file from open list, or open file
    pFile = GetFile(szwModule);
    if (!pFile)
    {
        ErrorTrace(TRACE_ID, "Error opening file");
        goto exit;
    }

    hfFile = pFile->hfFile;                 // for easy access

    if (!(ulCurSeg = GetSegDef(pFile,dwSection,&seg)))
    {
        ErrorTrace(TRACE_ID, "Cannot find section");
        goto exit;
    }


    // have we already read in the symbol definition offsets for this section?
    if (dwSection != pFile->dwCurSection || !pFile->psCurSymDefPtrs)  // no
    {
        // free up previously read symdef pointers
        if (pFile->psCurSymDefPtrs)
        {
            delete [] pFile->psCurSymDefPtrs;
            pFile->psCurSymDefPtrs = NULL;
        }

        // big symbols?
        if (seg.gd_type & MSF_BIGSYMDEF)
        {
            dwArrayOffset = seg.gd_psymoff * 16;
            pFile->psCurSymDefPtrs = new BYTE[seg.gd_csym*3];
        }
        else
        {
            dwArrayOffset = seg.gd_psymoff;
            pFile->psCurSymDefPtrs = new BYTE[seg.gd_csym*2];
        }

        if (!pFile->psCurSymDefPtrs)
        {
            ErrorTrace(TRACE_ID, "Cannot allocate memory");
            goto exit;
        }

        if (SetFilePointer(hfFile,
                           ulCurSeg + dwArrayOffset,
                           NULL,
                           FILE_BEGIN)
                           == 0xFFFFFFFF)
        {
            ErrorTrace(TRACE_ID, "Cannot set file pointer");
            delete [] pFile->psCurSymDefPtrs;
            pFile->psCurSymDefPtrs = NULL;
            goto exit;
        }

        // read symbol definition pointers array 
        if (!ReadFile(hfFile,
                      pFile->psCurSymDefPtrs,
                      seg.gd_csym * ((seg.gd_type & MSF_BIGSYMDEF)?3:2),
                      &dwCread,
                      NULL))
        {
            ErrorTrace(TRACE_ID, "Cannot read sym pointers array");
            delete [] pFile->psCurSymDefPtrs;
            pFile->psCurSymDefPtrs = NULL;
            goto exit;
        }

        // save this section 
        pFile->dwCurSection = dwSection;

    }



    // read symbols
    for (i = 0; i < seg.gd_csym; i++)
    {
        // go to offset of sym defintion 
        if (seg.gd_type & MSF_BIGSYMDEF)
        {
            dwSymOffset = pFile->psCurSymDefPtrs[i*3+0]
                          + pFile->psCurSymDefPtrs[i*3+1]*256
                          + pFile->psCurSymDefPtrs[i*3+2]*65536;
        }
        else
        {
            dwSymOffset = pFile->psCurSymDefPtrs[i*2+0]
                          + pFile->psCurSymDefPtrs[i*2+1]*256;
        }

        if (SetFilePointer(hfFile,
                           ulCurSeg + dwSymOffset,
                           NULL,
                           FILE_BEGIN) == 0xFFFFFFFF)
        {
            ErrorTrace(TRACE_ID, "Cannot set file pointer");
            goto exit;
        }

        // read symbol address DWORD 
        if (!ReadFile(hfFile,&dwSymAddr,sizeof(DWORD),&dwCread,NULL))
        {
            ErrorTrace(TRACE_ID, "Cannot read symbol definition");
            goto exit;
        }

        // symbol address is 1 word or two?
        nToRead = sizeof(SHORT) + ((seg.gd_type & MSF_32BITSYMS) * sizeof(SHORT));

        // calculate offset of symbol name 
        ulSymNameOffset = ulCurSeg + dwSymOffset + nToRead;

        // use just lower word of address if 16-bit symbol
        if (!(seg.gd_type & MSF_32BITSYMS))
        {
            dwSymAddr = dwSymAddr & 0x0000FFFF;
        }

        // do we have our function?
        // if current address is greater than offset, then since we are 
        // traversing in the increasing order of addresses, the previous 
        // symbol must be our quarry
        if (dwSymAddr > offset) break;
    
        // store previous name offset
        ulPrevNameOffset = ulSymNameOffset;
    }   


    // did we get our function?
    // BUGBUG: cannot resolve the last symbol in a section, because we don't know
    // the size of the function code
    // if offset > dwSymAddr of last symbol, then we cannot decide if offset belonged
    // to last symbol or was beyond it - so assume <no symbol>
    if (i < seg.gd_csym) 
    {
        // go to name offset
        if (SetFilePointer(hfFile,
                           ulPrevNameOffset,
                           NULL,
                           FILE_BEGIN)
                           == 0xFFFFFFFF)
        {
            ErrorTrace(TRACE_ID, "Error setting file pointer");
            goto exit;
        }

        // read length of name
        if (!ReadFile(hfFile,&cName,sizeof(TCHAR),&dwCread,NULL))
        {
            ErrorTrace(TRACE_ID, "Error reading length of name");
            goto exit;
        }

        nNameLen = (int) cName;

        // read symbol name
        if (!ReadFile(hfFile,sztFuncName,nNameLen,&dwCread,NULL))
        {
            ErrorTrace(TRACE_ID, "Error reading name");
            goto exit;
        }

        sztFuncName[nNameLen] = TCHAR('\0');
        UndecorateSymbol(sztFuncName);
        fSuccess = TRUE;
    }


exit:
    if (!MultiByteToWideChar(CP_ACP, 0, sztFuncName, -1, szwFuncName, MAX_PATH))
    {
        lstrcpyW(szwFuncName, L"<no symbol>");
    }


    // log unresolved symbols to log file (filename read from registry)
    // file write operation is not wrapped in a mutex
    // for speed considerations 
    if (!fSuccess)
    {
        hfLogFile = CreateFileW(g_szwLogFile,
                                GENERIC_WRITE,
                                0, 
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, 
                                NULL);

        if (INVALID_HANDLE_VALUE != hfLogFile)
        {
            wsprintf(szWrite, "\n%ls %04X:%08X", szwModule, dwSection, offset);
            if (SetFilePointer(hfLogFile, 0, NULL, FILE_END) != 0xFFFFFFFF)
            {
                WriteFile(hfLogFile, szWrite, lstrlen(szWrite), &dwWritten, NULL);
            }
            CloseHandle(hfLogFile);
        }    
    }

    TraceFunctLeave();
}


// cleanup memory 
void
Cleanup()
{
    std::list<OPENFILE *>*              pOpenFilesList = NULL;
    std::list<OPENFILE *>::iterator     it;

    TraceFunctEnter("Cleanup");

    pOpenFilesList = (std::list<OPENFILE *> *) TlsGetValue(g_dwTlsIndex);
    if (!pOpenFilesList)
    {
        goto exit;
    }

    for (it = pOpenFilesList->begin(); it != pOpenFilesList->end(); it++)
    {
        if (*it)
	{
	    if ((*it)->psCurSymDefPtrs)
            {
                delete [] (*it)->psCurSymDefPtrs;
            }
            if ((*it)->hfFile && (*it)->hfFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle((*it)->hfFile);
	    }
            delete *it;
	}
    }
    delete pOpenFilesList;

exit:
    TraceFunctLeave();
}



BOOL
HandleProcessAttach()
{
    std::list<OPENFILE *> *     pOpenFilesList = NULL; 
    BOOL                        fRc = FALSE;
    DWORD                       dwType;
    DWORD                       dwSize;
    ULONG                       lResult;
    HKEY                        hKey;

    TraceFunctEnter("HandleProcessAttach");


    // allocate thread local storage
    if ((g_dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF)
    {
        ErrorTrace(TRACE_ID, "Cannot get TLS index");
        goto exit;
    }

    // create a new list of open sym files
    pOpenFilesList = new std::list<OPENFILE *>;
    if (!pOpenFilesList) 
    {
        ErrorTrace(TRACE_ID, "Out of memory");
        goto exit;
    }

    // store pointer to list in TLS
    if (!TlsSetValue(g_dwTlsIndex, (PVOID) pOpenFilesList))
    {
        ErrorTrace(TRACE_ID, "Cannot write to TLS");
        delete pOpenFilesList;
        pOpenFilesList = NULL;
        goto exit;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\PCHealth\\Symbols"), 
            0, 
            KEY_QUERY_VALUE,
            &hKey);

    // read symbol files location and name of log file from registry
    if(lResult == ERROR_SUCCESS)
    {
        dwSize = MAX_PATH;
        RegQueryValueExW(hKey,
                         L"SymDir",
                         NULL,
                         NULL,
                         (LPBYTE) g_szwSymDir,
                         &dwSize);

        dwSize = MAX_PATH;
        RegQueryValueExW(hKey,
                         L"LogFile",
                         NULL,
                         NULL,
                         (LPBYTE) g_szwLogFile,
                         &dwSize);

        RegCloseKey(hKey);
        fRc = TRUE;
    }

exit:
    TraceFunctLeave();
    return fRc;
}



// Dll entry point 
// allocates TLS 
// initializes list of open sym files - one list per client thread 
// cleans up after itself
BOOL APIENTRY 
DllMain(
        HANDLE hDll,                // [in] handle to Dll
        DWORD dwReason,             // [in] why DllMain is called
        LPVOID lpReserved           // [in] ignored
        )
{
    BOOL    fRc = TRUE;
    std::list<OPENFILE*>*   pOpenFilesList = NULL;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // initial thread of process that loaded us
        fRc = HandleProcessAttach();
        break;

    case DLL_THREAD_ATTACH:
        // if list already exists, do nothing
        if (TlsGetValue(g_dwTlsIndex))
        {
            break;
        }

        // create new list for every new thread
        pOpenFilesList = new std::list<OPENFILE *>;
        if (!pOpenFilesList) 
        {
            ErrorTrace(TRACE_ID, "Out of memory");
            fRc = FALSE;
            break;
        }

        // store pointer to list in TLS
        if (!TlsSetValue(g_dwTlsIndex, (PVOID) pOpenFilesList))
        {
            ErrorTrace(TRACE_ID, "Cannot write to TLS");
            delete pOpenFilesList;
            pOpenFilesList = NULL;
            fRc = FALSE;
        }
        break;

    case DLL_THREAD_DETACH:
        Cleanup();
        break;

    case DLL_PROCESS_DETACH:
        // free TLS 
        TlsFree(g_dwTlsIndex);
        break;

    default:
        break;
    }

    return fRc;
}



// exported function
// called by clients to resolve a single callstack entry
extern "C" void APIENTRY
ResolveSymbols(
        LPWSTR      szwFilename,
        LPWSTR      szwVersion,
        DWORD       dwSection,
        UINT_PTR    Offset,
        LPWSTR      szwFuncName
        )
{
    WCHAR      szwName[MAX_PATH] = L"";
    WCHAR      szwSymFile[MAX_PATH+MAX_PATH] = L"";
    WCHAR      szwExt[MAX_PATH] = L"";

    TraceFunctEnter("ResolveSymbols");

    // sanity check
    if (!szwFilename || !szwVersion)
    {
        ErrorTrace(TRACE_ID, "No module name/version");
        goto exit;
    }

    // get sym file name
    SplitExtension(szwFilename, szwName, szwExt);
    wsprintfW(szwSymFile, 
              L"%s\\%s\\%s_%s_%s.SYM",
              g_szwSymDir, szwName, szwName, szwExt, szwVersion);

    // resolve symbol name
    GetNameFromAddr(szwSymFile, 
                    dwSection, 
                    Offset,
                    szwFuncName);

exit:
    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\symres\utest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__603DAD7E_DE40_11D2_B9BC_00C04F79E399__INCLUDED_)
#define AFX_STDAFX_H__603DAD7E_DE40_11D2_B9BC_00C04F79E399__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
#include <dbgtrace.h>
#include <traceids.h>
#include <list>


#endif // !defined(AFX_STDAFX_H__603DAD7E_DE40_11D2_B9BC_00C04F79E399__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\symrep\symrep.c ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    fhmain.c

Abstract:
    This file is a utility to copy .sym files from a source dir to a dest dir
    Program should be run on a Win98 machine only

Revision History:

    Brijesh Krishnaswami (brijeshk) - 05/10/99 - Created

********************************************************************/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <winver.h>
#include <process.h>


BOOL
GetFileVersion(
        LPTSTR szFile,              // [in] file to get info for
        LPTSTR szValue)             // [out] file info obtained
{
    DWORD   dwSize;
    DWORD   dwScratch;
    DWORD*  pdwLang = NULL;
    DWORD   dwLang;
    BYTE*   pFileInfo = NULL;
    TCHAR   szLang[MAX_PATH] = TEXT("");
    TCHAR   szLocalValue[MAX_PATH] = TEXT("");
    TCHAR   szLocalFile[MAX_PATH] = TEXT("");
    LPTSTR  szLocal;
    BOOL    fSuccess = FALSE;
    FILE    *fTemp = NULL;
    TCHAR   szCmd[MAX_PATH];

    lstrcpy(szValue,TEXT(""));

    // get the file location first
    wsprintf(szCmd, "cd \\&dir /s /b %s > temp.txt", szFile);
    system(szCmd);

    fTemp = (FILE *) fopen("\\temp.txt", "r");
    if (NULL == fTemp)
    {
        goto exit;        
    }
 
    // read the full path name of the file
    if (!_fgetts(szLocalFile, MAX_PATH, fTemp))
    {
        goto exit;
    }

    // null terminate the path 
    szLocalFile[lstrlen(szLocalFile)-1]=TEXT('\0');

    fclose(fTemp);
    
    // get fileinfo data size
    dwSize = GetFileVersionInfoSize(szLocalFile,&dwScratch);
    if (!dwSize)
    {
        goto exit;
    }

    // get fileinfo data
    pFileInfo = (BYTE *) malloc(dwSize);
    if (!pFileInfo)
    {
        goto exit;
    }

    if (!GetFileVersionInfo(szLocalFile,0,dwSize,(PVOID) pFileInfo))
    {
        goto exit;
    }

    // set default language to english
    dwLang = 0x040904E4;
    pdwLang = &dwLang;

    // read language identifier and code page of file
    if (VerQueryValue(pFileInfo,
                       TEXT("\\VarFileInfo\\Translation"),
                       (PVOID *) &pdwLang,
                       (UINT *) &dwScratch)) 
    {
        // prepare query string 
        _stprintf(szLang, 
                  TEXT("\\StringFileInfo\\%04X%04X\\FileVersion"),
                  LOWORD(*pdwLang),
                  HIWORD(*pdwLang));

        szLocal = szLocalValue;

        // query for the value using codepage from file
        if (VerQueryValue(pFileInfo, 
                           szLang, 
                           (PVOID *) &szLocal, 
                           (UINT *) &dwScratch))
        {
            lstrcpy(szValue,szLocal);
            fSuccess = TRUE;
            goto exit;
        }
    }

    // if that fails, try Unicode 
    _stprintf(szLang,
              TEXT("\\StringFileInfo\\%04X04B0\\FileVersion"),
              GetUserDefaultLangID());

    if (!VerQueryValue(pFileInfo, 
                        szLang, 
                        (PVOID *) &szLocal, 
                        (UINT *) &dwScratch))
    {
        // if that fails too, try Multilingual
        _stprintf(szLang,
                  TEXT("\\StringFileInfo\\%04X04E4\\FileVersion"),
                  GetUserDefaultLangID());

        if (!VerQueryValue(pFileInfo, 
                            szLang,
                            (PVOID *) &szLocal, 
                            (UINT *) &dwScratch))
        {
            // and if that fails as well, try nullPage
            _stprintf(szLang,
                      TEXT("\\StringFileInfo\\%04X0000\\FileVersion"),
                      GetUserDefaultLangID());

            if (!VerQueryValue(pFileInfo, 
                                szLang,
                                (PVOID *) &szLocal, 
                                (UINT *) &dwScratch))
            {
                // giving up
                goto exit;
            }
        }
    }

    // successful; copy to return string
    lstrcpy(szValue,szLocal);
    fSuccess =  TRUE;
    
exit:
    if (pFileInfo)
    {
        free(pFileInfo);
    }
    return fSuccess;
}


void _cdecl
main(int argc, char *argv[])
{
    TCHAR szTarget[MAX_PATH]="";
    TCHAR szFile[MAX_PATH]="";
    TCHAR szOrig[MAX_PATH]="";
    TCHAR szVer[MAX_PATH]="";
    TCHAR szFile2[MAX_PATH]="";
    TCHAR szSrc[MAX_PATH+MAX_PATH]="";
    TCHAR szDest[MAX_PATH+MAX_PATH]="";
    FILE* f = NULL;
    WIN32_FIND_DATA FD;
    BOOL  fFound = FALSE;
    BOOL  fTryExe = TRUE;
    BOOL  fTryDll = TRUE;
    
    printf("PCHealth Sym Repository Maker\n");
    if (argc < 4 || argc > 5)
    {
        printf("\nUsage: symrep <sourcesyms> <sourcesymdir> <destsymdir> [EXE|DLL]");
        printf("\nsourcesyms   : file containing .SYM files (no path) to copy, one file/line");
        printf("\nsourcesymdir : fullpathname of source symbol dir");
        printf("\ndestsymdir   : fullpathname of destination symbol dir");
        printf("\n[EXE|DLL]    : binary extension to search for (default is both)");
        goto exit;
    }

    // open file containing list of sym files to copy (no path)
    f=(FILE *) fopen(argv[1],"r");
    if (!f) 
    {
        printf("\nCannot open %s", argv[1]);
        goto exit;
    }

    if (argc == 5)
    {
        if (0 == lstrcmpi(argv[4], TEXT("EXE")))
        {
            fTryDll = FALSE;
        }

        if (0 == lstrcmpi(argv[4], TEXT("DLL")))
        {
            fTryExe = FALSE;
        }
    }                
                
    while (fscanf(f,"%s",szFile) == 1)
    {
        // remove .SYM extension
        lstrcpy(szOrig,szFile);
        szFile[lstrlen(szFile)-4]='\0';

        fFound = FALSE;

        // search if the exe exists on the machine
        if (fTryExe)
        {
            lstrcpy(szFile2, szFile);
            lstrcat(szFile2, TEXT(".EXE"));
            if (GetFileVersion(szFile2, szVer))
            {
                fFound = TRUE;
            }
        }
        
        // search if the dll exists on the machine
        if (!fFound && fTryDll)
        {
            lstrcpy(szFile2, szFile);
            lstrcat(szFile2, TEXT(".DLL"));
            if (GetFileVersion(szFile2, szVer))
            {
                fFound = TRUE;
            }
        }            

        // if file not found, skip the symbol file
        if (!fFound)
        {
            continue;
        }

        // make folder in dest dir (folder name = sym file name without extension)
        _stprintf(szTarget,TEXT("%s\\%s"),argv[3],szFile);
        CreateDirectory(szTarget,NULL);

        // make source and destination strings
        // dest filename is filename_extension_version.sym
        _stprintf(szSrc,TEXT("%s\\%s"),argv[2],szOrig);

        szFile2[lstrlen(szFile2)-4] = TEXT('_');
        _stprintf(szDest,
                  TEXT("%s\\%s_%s.SYM"),
                  szTarget,szFile2,szVer);

        printf("Creating %s...",szDest);

        // if file exists, don't copy
        if (FindFirstFile(szDest, &FD) == INVALID_HANDLE_VALUE)
        {
            if (CopyFile(szSrc,szDest,TRUE))
            {
                printf("done\n");
            }
            else
            {
                printf("error\n");
            }
        }
        else printf("file already exists\n");
    }

exit:
    if (f) 
    {
        fclose(f);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\symres\symdef.h ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    symdef.h

Abstract:
    SYM file structures header

Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/29/99 - Created
********************************************************************/

#ifndef _SYMDEF_H
#define _SYMDEF_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


// SYM File Structures

#pragma pack(1)                     // pack all data structures declared here 


// For each map within a symbol file (MAPDEF)

struct mapdef_s {
    unsigned short md_spmap;        // 16 bit SEG ptr to next map (0 if end) 
    unsigned char  md_abstype;      //  8 bit map/abs sym flags 
    unsigned char  md_pad;          //  8 bit pad 
    unsigned short md_segentry;     // 16 bit entry point segment value 
    unsigned short md_cabs;         // 16 bit count of constants in map 
    unsigned short md_pabsoff;      // 16 bit ptr to constant offsets 
    unsigned short md_cseg;         // 16 bit count of segments in map 
    unsigned short md_spseg;        // 16 bit SEG ptr to segment chain 
    unsigned char  md_cbnamemax;    //  8 bit maximum symbol name length 
    unsigned char  md_cbname;       //  8 bit symbol table name length 
    unsigned char  md_achname[1];   // <n> name of symbol table (.sym ) 
};

//#define CBMAPDEF    FIELDOFFSET(struct mapdef_s, md_achname)

struct endmap_s {
    unsigned short em_spmap;        // end of map chain (SEG ptr 0) 
    unsigned char  em_rel;          // release 
    unsigned char  em_ver;          // version 
};




// For each segment/group within a symbol table: (SEGDEF)


struct segdef_s {
    unsigned short gd_spsegnext;    // 16 bit SEG ptr to next segdef (0 if end),
                                    //  relative to mapdef 
    unsigned short gd_csym;         // 16 bit count of symbols in sym list 
    unsigned short gd_psymoff;      // 16 bit ptr to symbol offsets array,
                                    // 16 bit SEG ptr if MSF_BIG_GROUP set,
                                    //  either relative to segdef 
    unsigned short gd_lsa;          // 16 bit Load Segment address 
    unsigned short gd_in0;          // 16 bit instance 0 physical address 
    unsigned short gd_in1;          // 16 bit instance 1 physical address 
    unsigned short gd_in2;          // 16 bit instance 2 physical address 
    unsigned char  gd_type;         // 16 or 32 bit symbols in group 
    unsigned char  gd_pad;          // pad byte to fill space for gd_in3 
    unsigned short gd_spline;       // 16 bit SEG ptr to linedef,
                                    //  relative to mapdef 
    unsigned char  gd_fload;        // 8 bit boolean 0 if seg not loaded 
    unsigned char  gd_curin;        // 8 bit current instance 
    unsigned char  gd_cbname;       // 8 bit Segment name length 
    unsigned char  gd_achname[1];   // <n>  name of segment or group 
};

// values for md_abstype, gd_type 
#define MSF_32BITSYMS   0x01        // 32-bit symbols 
#define MSF_ALPHASYMS   0x02        // symbols sorted alphabetically, too 


// values for gd_type only 
#define MSF_BIGSYMDEF   0x04        // bigger than 64K of symdefs 


// values for md_abstype only 
#define MSF_ALIGN32 0x10            // 2MEG max symbol file, 32 byte alignment 
#define MSF_ALIGN64 0x20            // 4MEG max symbol file, 64 byte alignment 
#define MSF_ALIGN128    0x30        // 8MEG max symbol file, 128 byte alignment 
#define MSF_ALIGN_MASK  0x30





//  Followed by a list of SYMDEF's..
//  for each symbol within a segment/group: (SYMDEF)
 
struct symdef16_s {
    unsigned short sd_val;          // 16 bit symbol addr or const 
    unsigned char  sd_cbname;       //  8 bit symbol name length 
    unsigned char  sd_achname[1];   // <n> symbol name 
};


struct symdef_s {
    unsigned long sd_lval;          // 32 bit symbol addr or const 
    unsigned char sd_cbname;        //  8 bit symbol name length 
    unsigned char sd_achname[1];    // <n> symbol name 
};




#pragma pack()            // stop packing 


typedef struct mapdef_s MAPDEF;
typedef struct segdef_s SEGDEF;


// SYM file info for open files
typedef struct _osf {
    WCHAR   szwName[MAX_PATH];         // file name
    WCHAR   szwVersion[MAX_PATH];      // version
    DWORD   dwCheckSum;                 // checksum
    HANDLE  hfFile;                     // file handle 
    ULONG   ulFirstSeg;                 // first section's offset
    int     nSeg;                       // number of sections
    DWORD   dwCurSection;               // section for which symbol defintion ptrs are already available
    BYTE*  psCurSymDefPtrs;            // pointer to array of symbol defintion offsets
}   OPENFILE;


#define MAXOPENFILES 10
#define MAX_NAME 256


#ifdef __cplusplus
}
#endif  // __cplusplus


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\trace\freeq.cpp ===
//#---------------------------------------------------------------
//        
//  File:       FreeQ.cpp
//        
//  Synopsis:   interface between CPool object and asynctrc.c
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    gordm
//        
//----------------------------------------------------------------

#include <windows.h>
#include <cpool.h>
#include "traceint.h"

//
// global pointer to CPool to avoid pulling in the C runtime
// to call the con/destrustors
//
CPool*	g_pFreePool = NULL;


//+---------------------------------------------------------------
//
//  Function:   InitTraceBuffers
//
//  Synopsis:   external "C" function to init the CPool
//
//  Arguments:  DWORD: Maximum number of pending traces
//				DWORD: Increment size for the CPool
//
//  Returns:    BOOL: successful or not
//
//----------------------------------------------------------------
BOOL WINAPI InitTraceBuffers( DWORD dwThresholdCount, DWORD dwIncrement )
{
	g_pFreePool = new CPool( TRACE_SIGNATURE );

	return	g_pFreePool != NULL &&
			g_pFreePool->ReserveMemory(	dwThresholdCount,
										sizeof(TRACEBUF),
										dwIncrement );
}


//+---------------------------------------------------------------
//
//  Function:   TermTraceBuffers
//
//  Synopsis:   cleanup 
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
void WINAPI TermTraceBuffers( void )
{
	CPool*	pPool = (CPool*)InterlockedExchangePointer((LPVOID *)&g_pFreePool, NULL);
	if ( pPool != NULL )
	{
		pPool->ReleaseMemory();
		delete	pPool;
	}
}


//+---------------------------------------------------------------
//
//  Function:   GetTraceBuffer
//
//  Synopsis:   external "C" function to get a CPool buffer 
//
//  Arguments:  void
//
//  Returns:    LPTRACEBUF: allocated buffer
//
//----------------------------------------------------------------
LPTRACEBUF WINAPI GetTraceBuffer( void )
{
	LPTRACEBUF	lpBuf;

	//
	// don't let the number of traces exceed the size 
	// of the file
	//
	if ( PendQ.dwCount >= PendQ.dwThresholdCount )
	{
		INT_TRACE( "Alloc flush: %u\n", PendQ.dwCount );
		INTERNAL__FlushAsyncTrace();
	}

	lpBuf = (LPTRACEBUF)g_pFreePool->Alloc();

   	if ( lpBuf != NULL )
	{
		lpBuf->pNext = NULL;
		lpBuf->dwSignature = TRACE_SIGNATURE;
	}
	return	lpBuf;
}



//+---------------------------------------------------------------
//
//  Function:   FreeTraceBuffer
//
//  Synopsis:   external "C" function to free a CPool buffer 
//
//  Arguments:  LPTRACEBUF: the buffer to free
//
//  Returns:    void
//
//----------------------------------------------------------------
void WINAPI FreeTraceBuffer( LPTRACEBUF lpBuf )
{
	ASSERT( lpBuf != NULL );
	ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

	g_pFreePool->Free( (void*)lpBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\symres\utest\symtest.cpp ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    pchfh.h

Abstract:
    Unit test for symbol resolver

Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/01/99 - Created
********************************************************************/

#include <stdafx.h>
#include <symres.h>

// for trace output to include filename
#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[]=__FILE__;
#define THIS_FILE __szTraceSourceFile

#define TRACE_ID 1

typedef struct _CallStack {
    WCHAR       szFilename[MAX_PATH];
    WCHAR       szVersion[MAX_PATH];
    DWORD       dwCheckSum;
    DWORD       dwSection;
    UINT_PTR    Offset;
    WCHAR       szFuncName[MAX_PATH];
}  CALLSTACK;

// reads callstack list from file
void
MakeList(
        LPTSTR szCSFile,
        std::list<CALLSTACK *>& CallStackList
        )
{
    FILE*       fCS = NULL; 
    CALLSTACK*  pCallStack = NULL; 
    TCHAR       szVersion[MAX_PATH];
    TCHAR       szFilename[MAX_PATH];

    TraceFunctEnter("MakeList");

    fCS = (FILE *) fopen(szCSFile, "r");
    if (!fCS)
    {
        ErrorTrace(TRACE_ID, "Error opening file");
        goto exit;
    }

    pCallStack = (CALLSTACK *) malloc(sizeof(CALLSTACK));
    if (!pCallStack)
    {
        ErrorTrace(TRACE_ID, "malloc failed");
        goto exit;
    }

    // read from file
    while (fscanf(fCS,
                  "%s %s %X %X", 
                  szFilename,
                  szVersion,
                  &(pCallStack->dwSection),
                  &(pCallStack->Offset)) == 4)
    {
        MultiByteToWideChar(CP_ACP,0,szFilename,-1,pCallStack->szFilename,MAX_PATH);
        if (!lstrcmp(szVersion,TEXT("-")))
        {
            lstrcpyW(pCallStack->szVersion,L"");
        }
        else
        {
            MultiByteToWideChar(CP_ACP,0,szVersion,-1,pCallStack->szVersion,MAX_PATH);
        }

        CallStackList.push_back(pCallStack);
        pCallStack = (CALLSTACK *) malloc(sizeof(CALLSTACK));
        if (!pCallStack)
        {
            ErrorTrace(TRACE_ID, "malloc failed");
            goto exit;
        }
    }

    // free unused node
    if (pCallStack)
    {
        free(pCallStack);
    }

exit:
    if (fCS)
    {
        fclose(fCS);
    }

    TraceFunctLeave();
    return;
}



void _cdecl
main(int argc, char *argv[])
{
    HMODULE                             hSym = NULL;
    std::list<CALLSTACK *>              CallStackList;
    std::list<CALLSTACK *>::iterator    it;

    TraceFunctEnter("main");

#ifndef NOTRACE
    InitAsyncTrace();
#endif

    MakeList(argv[1], CallStackList);

    for (it = CallStackList.begin(); it != CallStackList.end(); it++)
    {
        ResolveSymbols((*it)->szFilename,
                       (*it)->szVersion,
                       (*it)->dwSection, 
                       (*it)->Offset,
                       (*it)->szFuncName);
        printf("\n%S %S %04X:%08X %S", 
               (*it)->szFilename,
               (*it)->szVersion,
               (*it)->dwSection, 
               (*it)->Offset,
               (*it)->szFuncName);
    }


    TraceFunctLeave();
    TermAsyncTrace();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\trace\asynctrc.c ===
/*----------------------------------------------------------------------
    ASYNCTRC.C
        Implementation of the async tracing library

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>


typedef BOOL (WINAPI * INITIALIZE_SECURITY_DESCRIPTOR_FN) (
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD dwRevision );

typedef BOOL (WINAPI * SET_SECURITY_DESCRIPTOR_DACL_FN) (
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL bDaclPresent,
    IN PACL pDacl,
    IN BOOL bDaclDefaulted );


INITIALIZE_SECURITY_DESCRIPTOR_FN g_pfnInitializeSecurityDescriptor=NULL;
SET_SECURITY_DESCRIPTOR_DACL_FN g_pfnSetSecurityDescriptorDacl=NULL;
HINSTANCE g_hinst_AdvapiDll = NULL;


//
// #define  TRACE_ENABLED
//
#include "traceint.h"

//
// Per Process global variables
//
PENDQ   PendQ;
BOOL    fInitialized;
HANDLE  hShutdownEvent;
DWORD   dwInitializations = 0;

//
// critical section to protect reentracy on Write routine
// Also used by the signal thread to ensure that no threads
// are using hFile as it dynamically opens and closes trace file.
// During Async mode the background thread will be able to grab
// this critSec each time without waiting unless we're in the
// process of shutting down.
//
CRITICAL_SECTION critSecWrite;


//
// critical section to protect reentracy on Flush routine
//
CRITICAL_SECTION critSecFlush;


//
// exported trace flag used by trace macros to determine if the trace
// statement should be executed
//
DWORD   INTERNAL__dwEnabledTracesDefault = 0;
DWORD*  INTERNAL__dwEnabledTraces        = &INTERNAL__dwEnabledTracesDefault;

DWORD   dwMaxFileSize;
DWORD   dwNumTraces;
DWORD   dwTraceOutputType;
DWORD   dwAsyncTraceFlag;
int     nAsyncThreadPriority;
DWORD   dwIncrementSize;

DWORD   dwTlsIndex = 0xFFFFFFFF;

//
// pointer to the previous top level exception handler
//
LPTOP_LEVEL_EXCEPTION_FILTER    lpfnPreviousFilter = NULL;


//
// Internal Function to debugger tracing if DEBUG is defined.
// see traceint.h for the INT_TRACE macro which can be
// inserted at the appropriate point and has the same
// parameters as printf.
//

#ifdef TRACE_ENABLED

void CDECL InternalTrace( const char *s, ... )
{
    char    sz[256];
    va_list marker;

    va_start( marker, s );

    wvsprintf( sz, s, marker );
    OutputDebugString( sz );

    va_end( marker );
}

#endif



//+---------------------------------------------------------------
//
//  Function:   TopLevelExceptionFilter
//
//  Synopsis:   exception handler to flush the PendQ before hitting
//              the debugger
//
//  Arguments:  see Win32 help file
//
//  Returns:    always returns EXCEPTION_CONTINUE_SEARCH
//
//----------------------------------------------------------------
LONG WINAPI TopLevelExceptionFilter( EXCEPTION_POINTERS *lpExceptionInfo )
{
    DWORD   dwLastError = GetLastError();

    //
    // flush the background queue; ignore the ret code
    //
    INTERNAL__FlushAsyncTrace();

    //
    // restore the overwritten last error code
    //
    SetLastError( dwLastError );

    //
    // chain the ret code if there is a previous exception handler
    // else continue the search
    //
    return  lpfnPreviousFilter != NULL ?
            (*lpfnPreviousFilter)( lpExceptionInfo ) :
            EXCEPTION_CONTINUE_SEARCH ;
}




//+---------------------------------------------------------------
//
//  Function:   SetTraceBufferInfo
//
//  Synopsis:   used to set the non-sprintf trace variables
//
//  Arguments:  LPTRACEBUF: target buffer
//              int:        line number of the exception
//              LPCSTR:     source file of the exception
//              LPCSTR:     function name of the exception
//              DWORD:      type of trace
//
//  Returns:    void
//
//----------------------------------------------------------------
__inline void SetTraceBufferInfo(
        LPTRACEBUF  lpBuf,
        int         iLine,
        LPCSTR      pszFile,
        LPCSTR      pszFunction,
        DWORD       dwTraceMask,
        DWORD       dwError )
{
    LPCSTR   psz;
    WORD     wVariableOffset = 0;
    PFIXEDTR pFixed = &lpBuf->Fixed;

    lpBuf->dwLastError = dwError;

    pFixed->wSignature = 0xCAFE;
    pFixed->wLength = sizeof(FIXEDTRACE);
    pFixed->wLine = LOWORD( iLine );
    pFixed->dwTraceMask = dwTraceMask;
    pFixed->dwThreadId = GetCurrentThreadId();
    pFixed->dwProcessId = PendQ.dwProcessId;

    GetLocalTime( &pFixed->TraceTime );

    if ( pszFile )
    {
        if ( (psz = strrchr( pszFile, '\\' )) != NULL )
        {
            psz++;  // fully qualified path name - strip path
        }
        else
        {
            psz = pszFile;  // simple file name
        }

        lstrcpyn( lpBuf->Buffer, psz, MAX_FILENAME_SIZE );
        pFixed->wFileNameOffset = sizeof(FIXEDTRACE) + wVariableOffset;
        wVariableOffset = lstrlen( psz ) + 1;
    }
    else
    {
        pFixed->wFileNameOffset = 0;
    }

    if ( pszFunction != NULL )
    {
        lstrcpyn( lpBuf->Buffer + wVariableOffset, pszFunction, MAX_FUNCTNAME_SIZE );

        pFixed->wFunctNameOffset = sizeof(FIXEDTRACE) + wVariableOffset;
        wVariableOffset += lstrlen( pszFunction ) + 1;
    }
    else
    {
        pFixed->wFunctNameOffset = 0;
    }

    //
    // set the current offset into the variable buffer
    //
    pFixed->wVariableLength = wVariableOffset;
}


//+---------------------------------------------------------------
//
//  Function:   CommitTraceBuffer
//
//  Synopsis:   deal with the buffer; either sync write or async queue
//
//  Arguments:  LPTRACEBUF lpBuf: the buffer to commit
//
//  Returns:    void
//
//----------------------------------------------------------------
__inline void CommitTraceBuffer( LPTRACEBUF lpBuf )
{
    DWORD   dwError = lpBuf->dwLastError;

    if ( dwAsyncTraceFlag == 0 )
    {
        WriteTraceBuffer( lpBuf );
        FreeTraceBuffer( lpBuf );
    }
    else
    {
        QueueAsyncTraceBuffer( lpBuf );
    }

    //
    // restore last error before initial Trace call
    //
    SetLastError( dwError );
}


BOOL GetProcAddresses()
{
     //note that advapi32.dll may already be loaded here. 
    g_hinst_AdvapiDll = LoadLibrary(TEXT("advapi32.dll"));
    
    if (NULL == g_hinst_AdvapiDll)
    {
        INT_TRACE( "Not able to load advapi32.dll\n" );
        _ASSERT(0);
        goto cleanup;                
    }


    g_pfnInitializeSecurityDescriptor = (INITIALIZE_SECURITY_DESCRIPTOR_FN) 
        GetProcAddress(g_hinst_AdvapiDll, "InitializeSecurityDescriptor");
    
    if (NULL == g_pfnInitializeSecurityDescriptor)
    {
        INT_TRACE( "Not able to find InitializeSecurityDescriptor\n");
        _ASSERT(0);
        goto cleanup;                
    }

    g_pfnSetSecurityDescriptorDacl = (SET_SECURITY_DESCRIPTOR_DACL_FN) 
        GetProcAddress(g_hinst_AdvapiDll, "SetSecurityDescriptorDacl");
    
    if (NULL == g_pfnSetSecurityDescriptorDacl)
    {
        INT_TRACE( "Not able to find SetSecurityDescriptorDacl\n");
        _ASSERT(0);
        goto cleanup;                
    }    

    return TRUE;
    
cleanup:
    return FALSE;
}


/* This function determines whether the OS is Windows NT or
   Windows 9.x */
BOOL IsWindowsNT()
{
    OSVERSIONINFO VersionInformation;
    DWORD dwError;
    
    VersionInformation.dwOSVersionInfoSize  = sizeof(OSVERSIONINFO);
    
    if (FALSE == GetVersionEx(&VersionInformation))  // pointer to version
                                                    // information structure
    {

        dwError = GetLastError();
        
        INT_TRACE( "GetVersionEx Failed %d\n", dwError );
        dwError = dwError + 1;
        
        ASSERT(0);
         // assume NT
        return TRUE;
    }
    
    if (VER_PLATFORM_WIN32_NT == VersionInformation.dwPlatformId )
    {
        return TRUE;
    }
    
    return FALSE;
}


//+---------------------------------------------------------------
//
//  Function:   GetWorldSecurityAttributes
//
//  Synopsis:   code is cut and pasted from the Win32 SDK help files
//              AshishS: This code used the SetSecurityDescriptorDacl and 
//              InitializeSecurityDescriptor in Windows NT. However, these
//              functions are not implemented in windows 98, so we have to
//              do special handling for windows 98.
//
//
//  Arguments:  void
//
//  Returns:    static security attributes for Everyone access
//
//----------------------------------------------------------------
LPSECURITY_ATTRIBUTES GetWorldSecurityAttributes()
{
static SECURITY_ATTRIBUTES SecurityAttrib;
static SECURITY_DESCRIPTOR SecurityDesc;

    FillMemory( (char*)&SecurityDesc, sizeof(SECURITY_DESCRIPTOR), 0 );
    
    if (IsWindowsNT())
    {
        if (g_pfnSetSecurityDescriptorDacl == NULL || 
            g_pfnInitializeSecurityDescriptor == NULL)
        {
            if (GetProcAddresses() == FALSE)
            {
                _ASSERT(FALSE);
                goto done;
            }
        }
        
        if ( g_pfnInitializeSecurityDescriptor( &SecurityDesc, 
                                                SECURITY_DESCRIPTOR_REVISION) )
        {
             //
             // Add a NULL disc. ACL to the security descriptor.
             //
            if ( g_pfnSetSecurityDescriptorDacl(&SecurityDesc, 
                                                TRUE,// specifying a disc. ACL
                                                (PACL)NULL, 
                                                FALSE))//not a default disc.ACL
            {
                SecurityAttrib.nLength = sizeof(SECURITY_ATTRIBUTES);
                SecurityAttrib.lpSecurityDescriptor = &SecurityDesc;
                SecurityAttrib.bInheritHandle = FALSE;
                
                return  &SecurityAttrib;
            }
        }
    }
    else
    {
        SecurityAttrib.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttrib.bInheritHandle = TRUE;
        return  &SecurityAttrib;
    }

done:    
    return  (LPSECURITY_ATTRIBUTES) NULL;
} 






//+---------------------------------------------------------------
//
//  Function:   DllEntryPoint
//
//  Synopsis:   only relevence is allocating thread local storage var
//
//  Arguments:  see Win32 SDK
//
//  Returns:    see Win32 SDK
//
//----------------------------------------------------------------
BOOL WINAPI DllEntryPoint( HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved )
{
    //
    // InitAsyncTrace and TermAsyncTrace cannot be called from this entrypoint
    // because they create and interact with background threads
    // See CreateThread in Win32 Help file for more info
    //
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            return  TRUE;
//          return  InitAsyncTrace();

        case DLL_THREAD_ATTACH:
            TlsSetValue( dwTlsIndex, (LPVOID)NULL );
            break;

        case DLL_PROCESS_DETACH:
//          TermAsyncTrace();
            if (NULL != g_hinst_AdvapiDll)
            {
                g_pfnSetSecurityDescriptorDacl = NULL;
                g_pfnInitializeSecurityDescriptor = NULL;
                FreeLibrary(g_hinst_AdvapiDll);
            }
            
            return  FALSE;
    }
    return  TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   INTERNAL__SetAsyncTraceParams
//
//  Synopsis:   exported function to setup trace buffer with
//              required fields
//              
//              This is the first call for a trace statement.
//              Second call is different for strings or binary
//
//  Arguments:  LPCSTR:     source file of the exception
//              int:        line number of the exception
//              LPCSTR:     function name of the exception
//              DWORD:      type of trace
//
//  Returns:    returns a BOOL 1 if successful; 0 on failure
//
//----------------------------------------------------------------
int WINAPI INTERNAL__SetAsyncTraceParams( LPCSTR pszFile     ,
										  int    iLine       ,
										  LPCSTR pszFunction ,
										  DWORD  dwTraceMask )
{
    LPTRACEBUF  lpBuf;
    DWORD       dwError = GetLastError();

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( lpBuf = GetTraceBuffer() )
    {

        SetTraceBufferInfo( lpBuf, iLine, pszFile, pszFunction, dwTraceMask, dwError );
        TlsSetValue( dwTlsIndex, (LPVOID)lpBuf );

        return  1;
    }
    else    return  0;
}



//+---------------------------------------------------------------
//
//  Function:   INTERNAL__AsyncStringTrace
//
//  Synopsis:   exported function to finish setting up trace buffer
//              with optional fields for sprintf style traces
//
//  Arguments:  LPARAM:     32bit trace param used app level filtering
//              LPCSTR:     format string
//              va_list:    marker for vsprintf functions
//
//  Returns:    returns length of the trace statement
//
//----------------------------------------------------------------
int WINAPI INTERNAL__AsyncStringTrace( LPARAM  lParam   ,
									   LPCSTR  szFormat ,
									   va_list marker   )
{
    LPTRACEBUF  lpBuf;
    PFIXEDTR    pFixed;
    int         iLength;
    int         iMaxLength;

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( (lpBuf = (LPTRACEBUF)TlsGetValue( dwTlsIndex )) != NULL )
    {
        TlsSetValue( dwTlsIndex, NULL );

        pFixed = &lpBuf->Fixed;
        iMaxLength = MAX_VARIABLE_SIZE - pFixed->wVariableLength;
        iLength =
            _vsnprintf( lpBuf->Buffer + pFixed->wVariableLength,
                        iMaxLength,
                        szFormat,
                        marker ) + 1;

        if ( iLength == 0 || iLength == iMaxLength + 1 )
        {
            iLength = iMaxLength;
            lpBuf->Buffer[MAX_VARIABLE_SIZE-1] = '\0';
        }

        _ASSERT( iLength <= iMaxLength );

        pFixed->wBinaryOffset = sizeof(FIXEDTRACE) + pFixed->wVariableLength;
        pFixed->wVariableLength += LOWORD( (DWORD)iLength );
        pFixed->wBinaryType = TRACE_STRING;
        pFixed->dwParam = (DWORD)(DWORD_PTR)lParam;

        //
        // this is a specific area where the app can overwrite
        // data.  Could have used vnsprintf to avoid the overwrite
        // but this woudl have dragged in the C runtime and
        // introduced its overhead and own critical sections
        //
        ASSERT( pFixed->wVariableLength <= MAX_VARIABLE_SIZE );

        CommitTraceBuffer( lpBuf );

        //
        // need to use dwLength since we relinquish lpBuf
        // after we return from QueueAsyncTraceBuffer which
        // cannot fail
        //
        return  iLength;
    }
    else    return  0;
}



//+---------------------------------------------------------------
//
//  Function:   INTERNAL__AsyncBinaryTrace
//
//  Synopsis:   exported function to finish setting up trace buffer
//              with optional fields for binary traces
//
//  Arguments:  LPARAM:     32bit trace param used app level filtering
//              DWORD:      type of binary data ( ie Message, User... )
//              LPBYTE:     ptr to the data
//              DWORD:      length of the data
//
//  Returns:    returns length of the trace statement
//
//----------------------------------------------------------------
int WINAPI INTERNAL__AsyncBinaryTrace( LPARAM  lParam      ,
									   DWORD   dwBinaryType,
									   LPBYTE  pbData      ,
									   DWORD   cbData      )
{
    LPTRACEBUF  lpBuf;
    WORD        wLength;
    PFIXEDTR    pFixed;

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( (lpBuf = (LPTRACEBUF)TlsGetValue( dwTlsIndex )) != NULL )
    {
        TlsSetValue( dwTlsIndex, NULL );

        pFixed = &lpBuf->Fixed;

        wLength = LOWORD( min( cbData, MAX_BUFFER_SIZE ) );
        CopyMemory( lpBuf->Buffer + pFixed->wVariableLength, pbData, wLength );

        pFixed->wBinaryOffset = sizeof(FIXEDTRACE) + pFixed->wVariableLength;
        pFixed->wVariableLength += wLength;
        pFixed->wBinaryType = LOWORD( dwBinaryType );
        pFixed->dwParam = (DWORD)(DWORD_PTR)lParam;

        CommitTraceBuffer( lpBuf );

        //
        // need to use dwLength since we relinquish lpBuf
        // after we return from QueueAsyncTraceBuffer which
        // cannot fail
        //
        return  (int)wLength;
    }
    else    return  0;
}



//+---------------------------------------------------------------
//
//  Function:   INTERNAL__FlushAsyncTrace
//
//  Synopsis:   exported function to empty the pending queue.  All
//              threads which call this function block until the
//              queue is empty
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL WINAPI INTERNAL__FlushAsyncTrace( void )
{
static long lPendingFlushs = -1;

    if ( fInitialized == FALSE )
    {
        return  FALSE;
    }
    else
    {
        EnterCriticalSection( &critSecFlush );

        if ( PendQ.dwCount > 0 )
        {
            SetEvent( PendQ.hFlushEvent );

            if ( nAsyncThreadPriority < THREAD_PRIORITY_ABOVE_NORMAL )
            {
                SetThreadPriority(  PendQ.hWriteThread,
                                    THREAD_PRIORITY_ABOVE_NORMAL );
            }

            WaitForSingleObject( PendQ.hFlushedEvent, INFINITE );

            if ( nAsyncThreadPriority < THREAD_PRIORITY_ABOVE_NORMAL )
            {
                SetThreadPriority(  PendQ.hWriteThread,
                                    nAsyncThreadPriority );
            }
            ResetEvent( PendQ.hFlushedEvent );
        }
        LeaveCriticalSection( &critSecFlush );
        return  TRUE;
    }
}




//+---------------------------------------------------------------
//
//  Function:   INTERNAL__InitAsyncTrace
//
//  Synopsis:   exported required function to rev things up.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL WINAPI INTERNAL__InitAsyncTrace( DWORD* pdwEnabledTraces )
{
static BOOL bInitializing = FALSE;
    BOOL    bRC = FALSE;
    DWORD   dwThreadId;

    if ( fInitialized )
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );
        return  TRUE;
    }

    if ( InterlockedExchange( (LPLONG)&bInitializing, (LONG)TRUE ) )
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );
        return  TRUE;
    }

    // will read from registry later
    //
	INTERNAL__dwEnabledTraces = pdwEnabledTraces;
    dwNumTraces = 0;

    PendQ.dwProcessId = GetCurrentProcessId();
    PendQ.hFile = INVALID_HANDLE_VALUE;
    PendQ.cbBufferEnd = 0;
    PendQ.dwThresholdCount = DEFAULT_MAX_FILE_SIZE / AVERAGE_TRACE_SIZE;

    __try {

        InitializeCriticalSection( &PendQ.critSecTail );
        InitializeCriticalSection( &critSecWrite );
        InitializeCriticalSection( &critSecFlush );

        if ( (dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
        {
            return  FALSE;
        }

        if ( GetTraceFlagsFromRegistry() == FALSE )
        {
            return  FALSE;
        }

        //
        // Initialize the pool of trace buffers
        // must happen after reading the registy
        //
        if ( InitTraceBuffers( PendQ.dwThresholdCount, dwIncrementSize ) == FALSE )
        {
            return  FALSE;
        }

        PendQ.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( PendQ.hEvent == NULL )
        {
            return  FALSE;
        }

        //
        // PendQ.hFlushedEvent is manual reset so multiple threads can wait
        //
        PendQ.hFlushedEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( PendQ.hFlushedEvent == NULL )
        {
            return  FALSE;
        }

        PendQ.hFlushEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( PendQ.hFlushEvent == NULL )
        {
            return  FALSE;
        }
        
        //
        // hShutdownEvent is manual reset so multiple threads can be awaken
        //
        hShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( hShutdownEvent == NULL )
        {
            return  FALSE;
        }

        //
        // hFileMutex is only owned when write to the local file
        // First we need to create a security descriptor
        //
        PendQ.hFileMutex = CreateMutex( GetWorldSecurityAttributes(),
                                        FALSE,
                                        "MSN-Shuttle-TraceFile" );
        if ( PendQ.hFileMutex == NULL )
        {
            return  FALSE;
        }

        ASSERT( PendQ.hRegNotifyThread == NULL );

        PendQ.hRegNotifyThread =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)RegNotifyThread,
                            NULL,
                            0,
                            &dwThreadId );

        if ( PendQ.hRegNotifyThread == NULL )
        {
            return  FALSE;
        }
        else
        {
            //
            // bumping the priority onthis almost always dorminate thread
            // ensures that trace changes are applied soon after the
            // registry changes
            //
            SetThreadPriority( PendQ.hRegNotifyThread, THREAD_PRIORITY_ABOVE_NORMAL );
        }

        ASSERT( PendQ.hWriteThread == NULL );

        PendQ.hWriteThread =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)WriteTraceThread,
                            NULL,
                            0,
                            &dwThreadId );

        if ( PendQ.hWriteThread == NULL )
        {
            return  FALSE;
        }
        else
        {
            //
            // setting the priority on this thread ensures that the
            // physical writing of the traces will not impact performance
            // of the main application task. Default is BELOW_NORMAL although
            // its controlled by a reg entry
            //
            SetThreadPriority( PendQ.hWriteThread, nAsyncThreadPriority );
        }

        PendQ.pHead = PendQ.pTail = (LPTRACEBUF)&PendQ.Special; 

        //
        // set our top level exception handler
        //
        lpfnPreviousFilter = SetUnhandledExceptionFilter( TopLevelExceptionFilter );

        fInitialized = TRUE;
        InterlockedExchange( (LPLONG)&bInitializing, (LONG)FALSE );

        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );

        bRC = TRUE;
    }
    __finally
    {
        if ( bRC == FALSE )
        {
            DWORD   dwLastError = GetLastError();

            AsyncTraceCleanup();

            SetLastError( dwLastError );
        }
    }
    return  bRC;
}



//+---------------------------------------------------------------
//
//  Function:   INTERNAL__TermAsyncTrace
//
//  Synopsis:   exported required function to wind things down.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL WINAPI INTERNAL__TermAsyncTrace( void )
{
    if ( fInitialized )
    {
        if ( InterlockedDecrement( &dwInitializations ) == 0 )
        {
            return  AsyncTraceCleanup();
        }
        return  TRUE;
    }
    else
    {
        return  FALSE;
    }
}



//+---------------------------------------------------------------
//
//  Function:   INTERNAL__DebugAssert
//
//  Synopsis:   exported required function for enhanced asserts
//
//  Arguments:  DWORD  dwLine:       source code line of the _ASSERT
//              LPCSTR lpszFunction  source code filename of the _ASSERT
//              LPCSTR lpszExpression stringized version of _ASSERT param
//
//  Returns:    void
//
//----------------------------------------------------------------
void DebugAssert(  DWORD  dwLine,
				   LPCSTR lpszFunction,
				   LPCSTR lpszExpression )
{
	INTERNAL__DebugAssert( dwLine, lpszFunction, lpszExpression );
}
	 
char  szAssertOutput[512];
void WINAPI INTERNAL__DebugAssert(  DWORD  dwLine,
                                    LPCSTR lpszFunction,
                                    LPCSTR lpszExpression )
{
    DWORD   dwError = GetLastError();

    wsprintf( szAssertOutput, "\nASSERT: %s,\n File: %s,\n Line: %d\n Error: %d\n\n",
            lpszExpression, lpszFunction, dwLine, dwError );

    OutputDebugString( szAssertOutput );

    SetLastError( dwError );

    DebugBreak();
}



//+---------------------------------------------------------------
//
//  Function:   QueueAsyncTraceBuffer
//
//  Synopsis:   Routine to implement the appending of TRACEBUF to
//              the FIFO PendQ
//
//  Arguments:  LPTRACEBUF: the buffer
//
//  Returns:    void
//
//----------------------------------------------------------------
void QueueAsyncTraceBuffer( LPTRACEBUF lpBuf )
{
    LPTRACEBUF  pPrevTail;

    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    lpBuf->pNext = NULL;

    EnterCriticalSection( &PendQ.critSecTail );

    //
    // number of buffers on the queue can only decrease while
    // in this critical section since WriteTraceThread can continue
    // to pull buffers from the queue.
    //
    // WriteAsyncThread will not write this buffer until it has
    // been appended to the queue by incrementing PendQ.dwCount
    //
    // PendQ.pTail is only modified here and in a special case on the
    // background writer thread.  The special case is when Special needs
    // to be moved from the Head of the queue to the Tail.  Only during 
    // this brief special case can both the background writer and the
    // foreground appender thread be operating on the same trace buffer.
    //

    pPrevTail = PendQ.pTail;
    pPrevTail->pNext = PendQ.pTail = lpBuf;

    LeaveCriticalSection( &PendQ.critSecTail );

    InterlockedIncrement( &PendQ.dwCount );

    //
    // wake up WriteTraceThread if necessary. It may not be since
    // WriteTraceThread will always empty its queue before sleeping
    // 
    SetEvent( PendQ.hEvent );
}



//+---------------------------------------------------------------
//
//  Function:   DequeueAsyncTraceBuffer
//
//  Synopsis:   Routine to dequeue the top Trace Buffer from
//              the FIFO PendQ
//
//  Arguments:  void
//
//  Returns:    LPTRACEBUF: the buffer
//
//----------------------------------------------------------------
LPTRACEBUF  DequeueAsyncTraceBuffer( void )
{
    LPTRACEBUF  lpBuf;
    LPTRACEBUF  pPrevTail;

    //
    // check to see if Special is at the head of the queue. If so, move
    // it to the end of the queue
    //
    if ( PendQ.pHead == (LPTRACEBUF)&PendQ.Special )
    {
        //
        // need to NULL Special.pNext before the Exchange so the list 
        // is terminated as soon as we do the exchange.  We can lazily
        // set the old Tails next pointer since we're the only thread
        // that would dereference this pointer once its not the last
        // buffer in the FIFO
        //
        PendQ.pHead = PendQ.Special.pNext;
        PendQ.Special.pNext = NULL;

        EnterCriticalSection( &PendQ.critSecTail );
        //
        // see comment in QueueAsyncTraceBuffer to describe why we
        // to grab the Tail critical section here.  If we did not 
        // include this Special buffer then we would have to grab
        // the critSec each time.
        //
        pPrevTail = PendQ.pTail;
        pPrevTail->pNext = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;

        LeaveCriticalSection( &PendQ.critSecTail );         
    }

    //
    // again no critical section required since we're the only thread
    // accessing these PendQ.pHead.  This needs to be remembered if we
    // were to add integratity checking to the queues at a later date
    // since this queue is effectively in a corrupt state.
    //
    lpBuf = PendQ.pHead;
    PendQ.pHead = lpBuf->pNext;
    InterlockedDecrement( &PendQ.dwCount );

    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    return  lpBuf;
}



//+---------------------------------------------------------------
//
//  Function:   AsyncTraceCleanup
//
//  Synopsis:   internla routine to clean things up
//              the FIFO PendQ
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL AsyncTraceCleanup( void )
{
    HANDLE  hThreads[2];
    int     nObjects = 0;
    DWORD   dw;
    
    INT_TRACE( "AsyncTraceCleanup Enter\n" );

    if ( InterlockedExchange( &PendQ.fShutdown, TRUE ) == TRUE )
    {
        return  FALSE;
    }

    if ( dwTlsIndex != 0xFFFFFFFF )
    {
        TlsFree( dwTlsIndex );
    }

    //
    // restore the initial Exception filter; NULL signifies use the default
    //
    SetUnhandledExceptionFilter( lpfnPreviousFilter );

    if ( hShutdownEvent != NULL )
    {
        INT_TRACE( "AsyncTraceCleanup Calling SetEvent( hShutdownEvent )\n" );
        SetEvent( hShutdownEvent );
        INT_TRACE( "AsyncTraceCleanup Called SetEvent: Error: 0x%X\n", GetLastError() );
    }

    if ( PendQ.hWriteThread != NULL )
    {
        hThreads[nObjects++] = PendQ.hWriteThread;
    }

    if ( PendQ.hRegNotifyThread != NULL )
    {
        hThreads[nObjects++] = PendQ.hRegNotifyThread;
    }

    //
    // allow background threads forever to shutdown
    //
    if ( nObjects != 0 )
    {
        INT_TRACE( "AsyncTraceCleanup Calling WFMO\n" );
        dw = WaitForMultipleObjects(nObjects,
                                    hThreads,
                                    TRUE,
                                    INFINITE );
        INT_TRACE( "AsyncTraceCleanup Called WFMO: dw: 0x%X  Error: 0x%X\n",
                    dw, GetLastError() );
    }

    if ( PendQ.hWriteThread != NULL )
    {
        CloseHandle( PendQ.hWriteThread );
        PendQ.hWriteThread = NULL;
    }

    if ( PendQ.hRegNotifyThread != NULL )
    {
        CloseHandle( PendQ.hRegNotifyThread );
        PendQ.hRegNotifyThread = NULL;
    }

    if ( PendQ.hEvent != NULL )
    {
        CloseHandle( PendQ.hEvent );
        PendQ.hEvent = NULL;
    }

    if ( PendQ.hFlushEvent != NULL )
    {
        CloseHandle( PendQ.hFlushEvent );
        PendQ.hFlushEvent = NULL;
    }

    if ( PendQ.hFlushedEvent != NULL )
    {
        CloseHandle( PendQ.hFlushedEvent );
        PendQ.hFlushedEvent = NULL;
    }

    if ( hShutdownEvent != NULL )
    {
        CloseHandle( hShutdownEvent );
        hShutdownEvent = NULL;
    }

    if ( PendQ.hFileMutex != NULL )
    {
        CloseHandle( PendQ.hFileMutex );
        PendQ.hFileMutex = NULL;
    }

#if FALSE

    INT_TRACE( "TailCritSec  - Contention: %d, Entry: %d\n",
                PendQ.critSecTail.DebugInfo->ContentionCount,
                PendQ.critSecTail.DebugInfo->EntryCount );

    INT_TRACE( "WriteCritSec - Contention: %d, Entry: %d\n",
                critSecWrite.DebugInfo->ContentionCount,
                critSecWrite.DebugInfo->EntryCount );

    INT_TRACE( "FlushCritSec - Contention: %d, Entry: %d\n",
                critSecFlush.DebugInfo->ContentionCount,
                critSecFlush.DebugInfo->EntryCount );
#endif

    DeleteCriticalSection( &PendQ.critSecTail );
    DeleteCriticalSection( &critSecWrite );
    DeleteCriticalSection( &critSecFlush );

    if ( PendQ.hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( PendQ.hFile );
    }

    PendQ.pHead = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;
    PendQ.Special.pNext = (LPTRACEBUF)NULL;

    //
    // free up the trace buffer CPool
    //
    TermTraceBuffers();

    INT_TRACE( "Total number of traces: %d\n", dwNumTraces );

    InterlockedExchange( &PendQ.fShutdown, FALSE );
    fInitialized = FALSE;

    return  TRUE;
}


//+---------------------------------------------------------------
//
//  Function:   FlushBufferedWrites
//
//  Synopsis:   internal routine to write the PendQ temporary buffer
//              to disk.  Used to avoid multiple OS calls and increase
//              the write buffers.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL FlushBufferedWrites( void )
{
    BOOL        b = TRUE;
    DWORD       dwBytes;
    BOOL        bRetry = TRUE;

    //
    // need to lock the file since multiple process on multiple machines
    // may be tracing the same file and both writes have to complete as one.
    //

    WaitForSingleObject( PendQ.hFileMutex, INFINITE );

    if ( PendQ.cbBufferEnd )
    {
        DWORD dwOffset;

        ASSERT( PendQ.cbBufferEnd < MAX_WRITE_BUFFER_SIZE );

        dwOffset = SetFilePointer( PendQ.hFile, 0, 0, FILE_END );

        //
        // if the file is too big then we need to truncate it
        //
        if (dwOffset > dwMaxFileSize) 
        {
            SetFilePointer(PendQ.hFile, 0, 0, FILE_BEGIN);
            SetEndOfFile(PendQ.hFile);
        }
try_again:
        b = WriteFile(  PendQ.hFile,
                        PendQ.Buffer,
                        PendQ.cbBufferEnd,
                        &dwBytes,
                        NULL );

        if ( b == FALSE || dwBytes != PendQ.cbBufferEnd )
        {
            DWORD   dwError = GetLastError();

            if( dwError && bRetry )
            {
                bRetry = FALSE;
                Sleep( 100 );
                goto try_again;
            }
//          ASSERT( FALSE );
            INT_TRACE( "Error writing to file: %d, number of bytes %d:%d\n",
                        dwError,
                        PendQ.cbBufferEnd,
                        dwBytes );
        }
    }

    ReleaseMutex( PendQ.hFileMutex );
    PendQ.cbBufferEnd = 0;

    return  b;
}


//+---------------------------------------------------------------
//
//  Function:   WriteTraceBuffer
//
//  Synopsis:   internal routine to route the trace info to the
//              appropriate trace log
//
//  Arguments:  LPTRACEBUF: the buffer to write
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL WriteTraceBuffer( LPTRACEBUF lpBuf )
{
    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    InterlockedIncrement( &dwNumTraces );

    EnterCriticalSection( &critSecWrite );

    if ( IsTraceFile( dwTraceOutputType ) && PendQ.hFile != INVALID_HANDLE_VALUE )
    {
        DWORD   dwWrite;

        //
        // assert must be handled inside critical section
        //
        ASSERT( PendQ.cbBufferEnd+MAX_TRACE_ENTRY_SIZE < MAX_WRITE_BUFFER_SIZE );

        CopyMemory( PendQ.Buffer + PendQ.cbBufferEnd,
                    (char *)&lpBuf->Fixed,
                    dwWrite = sizeof(FIXEDTRACE) + lpBuf->Fixed.wVariableLength );

        PendQ.cbBufferEnd += dwWrite;

        if ( PendQ.cbBufferEnd + MAX_TRACE_ENTRY_SIZE >= MAX_WRITE_BUFFER_SIZE ||
            dwAsyncTraceFlag == 0 )
        {
            FlushBufferedWrites();
        }

    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_DEBUG )
    {
        char    szThread[16];
        LPCSTR  lpsz;

        EnterCriticalSection( &critSecWrite );

        wsprintf( szThread, "0x%08X: ", lpBuf->Fixed.dwThreadId );
        OutputDebugString( szThread );

        switch( lpBuf->Fixed.wBinaryType )
        {
        case TRACE_STRING:
            //
            // lstrcat may appear wasteful here; but it is less expensive than an
            // additional call to OutputDebugString( "\r\n" ); which works by
            // raising an exception.
            //
            // although appending \r\n on already full buffer is even worse
            //
            lpsz = lpBuf->Buffer + lpBuf->Fixed.wBinaryOffset - sizeof(FIXEDTRACE);
            OutputDebugString( lpsz );
            OutputDebugString( "\r\n" );
            break;

        case TRACE_BINARY:
            OutputDebugString( "Binary Trace\r\n" );
            break;

        case TRACE_MESSAGE:
            OutputDebugString( "Message Trace\r\n" );
            break;
        }

        LeaveCriticalSection( &critSecWrite );
    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_DISCARD )
    {
        //
        // fastest way to remove buffers. Used to find
        // deadlocks and race conditions
        //
    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_INVALID )
    {
        InterlockedDecrement( &dwNumTraces );
        //
        // unknown trace output type
        //
        ASSERT( FALSE );
    }

    LeaveCriticalSection( &critSecWrite );

    return  TRUE;
}




//+---------------------------------------------------------------
//
//  Function:   FlushAsyncPendingQueue
//
//  Synopsis:   internal routine to empty the PendQ queue from the
//              background thread
//              Assumes it is not called re-entrantly: actually the
//              FIFO queue assumes only one thread dequeues buffers
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
void FlushAsyncPendingQueue( void )
{
    LPTRACEBUF  lpBuf;

    while( PendQ.dwCount > 0 )
    {
        lpBuf = DequeueAsyncTraceBuffer();

        //
        // if we've buffered more than we'll write before
        // truncating the file then throw away the trace
        //
        if ( PendQ.dwCount < PendQ.dwThresholdCount )
        {
            WriteTraceBuffer( lpBuf );
        }
        else
        {
            INT_TRACE( "Discarding traces: %u\n", PendQ.dwCount );
        }

        FreeTraceBuffer( lpBuf );
    }
    FlushBufferedWrites();
}


#define NUM_WRITE_THREAD_OBJECTS    3

//+---------------------------------------------------------------
//
//  Function:   WriteTraceThread
//
//  Synopsis:   background thread routine for pulling and writing
//              trace buffers from PendQ FIFO queue.
//
//  Arguments:  see Win32 SDK - ignored here
//
//  Returns:    DWORD: 0 if we exitted gracefully
//
//----------------------------------------------------------------
DWORD WriteTraceThread( LPDWORD lpdw )
{
    HANDLE      Handles[NUM_WRITE_THREAD_OBJECTS];
    DWORD       dw;

    //
    // preference given to Shutdown, FlushEvent and then the
    // normal buffer event.  This ensures that provide a quick
    // response on both shutdown and to a lesser extent Flush
    // since other threads are waiting for this thread to respond.
    //
    Handles[0] = hShutdownEvent;
    Handles[1] = PendQ.hFlushEvent;
    Handles[2] = PendQ.hEvent;

    INT_TRACE( "WriteTraceThreadId 0x%X\n", GetCurrentThreadId() );

    for ( ;; )
    {
        dw = WaitForMultipleObjects(NUM_WRITE_THREAD_OBJECTS,
                                    Handles,
                                    FALSE,
                                    INFINITE );

        switch( dw )
        {
        //
        // normal signalled event
        //
        case WAIT_OBJECT_0+2:
            FlushAsyncPendingQueue();
            break;

        //
        // signalled by a foreground thread to flush our Q
        //
        case WAIT_OBJECT_0+0:
        case WAIT_OBJECT_0+1:
            FlushAsyncPendingQueue();

            if ( dw == WAIT_OBJECT_0+1 )
            {
                SetEvent( PendQ.hFlushedEvent );
            }
            else
            {
                INT_TRACE( "Exiting WriteTraceThread for hShutdownEvent\n" );
                return  0;
            }
            break;

        default:
            GetLastError();
            ASSERT( FALSE );
        }
    }
    INT_TRACE( "Exiting WriteTraceThread abnormally\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\trace\registry.c ===
/*----------------------------------------------------------------------
	REGISTRY.C
		Async tracing Registry reading routines

	Copyright (C) 1994 Microsoft Corporation
	All rights reserved.

	Authors:
		gordm          Gord Mangione

	History:
		01/30/95 gordm		Created.
----------------------------------------------------------------------*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "traceint.h"



char	szTraceFileName[MAX_PATH];
char 	szDebugAsyncTrace[] = "SOFTWARE\\Microsoft\\MosTrace\\CurrentVersion\\DebugAsyncTrace";


__inline BOOL GetRegDword( HKEY hKey, LPSTR pszValue, LPDWORD pdw )
{
	DWORD	cbData = sizeof( DWORD );
	DWORD	dwType = REG_DWORD;

	return	RegQueryValueEx(hKey,
							pszValue,
							NULL,
							&dwType,
							(LPBYTE)pdw,
							&cbData ) == ERROR_SUCCESS && dwType == REG_DWORD;
}



__inline BOOL GetRegString( HKEY hKey, LPSTR pszValue, LPBYTE buf, LPDWORD lpcbData )
{
	DWORD	dwType = REG_SZ;

	return	RegQueryValueEx(hKey,
							pszValue,
							NULL,
							&dwType,
							buf,
							lpcbData ) == ERROR_SUCCESS && dwType == REG_SZ;
}





BOOL GetTraceFlagsFromRegistry( void )
{
static char	szNewTraceFileName[MAX_PATH];
	DWORD	dwNewEnabledTraces;
	DWORD	dwNewTraceOutputType;
	DWORD	dwNewAsyncTraceFlag;
	DWORD	dwNewHeapIncrementCount;
	int		nNewThreadPriority;
	HKEY	hkConfig = NULL;
	BOOL	bRC = FALSE;
	DWORD	cbData;

	__try
	{
		if ( RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
							szDebugAsyncTrace,
							0,
							KEY_READ,
							&hkConfig ) == ERROR_SUCCESS )
		{
			if ( GetRegDword(	hkConfig,
								"MaxTraceFileSize",
								&dwMaxFileSize ) == FALSE )
			{
				dwMaxFileSize = DEFAULT_MAX_FILE_SIZE;
			}

			//
			// determine threshold count based on how we can fit in the file
			//
			PendQ.dwThresholdCount = dwMaxFileSize / AVERAGE_TRACE_SIZE;
			INT_TRACE( "PendQ.dwThresholdCount: %d\n", PendQ.dwThresholdCount );
						
			if ( GetRegDword(	hkConfig,
								"EnabledTraces",
								&dwNewEnabledTraces ) == FALSE )
			{
				INT_TRACE( "GetRegDword: EnabledTraces failed: %d\n", GetLastError() );
				return	bRC = FALSE;
			}
						
			if ( GetRegDword(	hkConfig,
								"OutputTraceType",
								&dwNewTraceOutputType ) == FALSE )
			{
				INT_TRACE( "GetRegDword: OutputTraceType failed: %d\n", GetLastError() );
				return	bRC = FALSE;
			}
						
			if ( GetRegDword(	hkConfig,
								"AsyncTraceFlag",
								&dwNewAsyncTraceFlag ) == FALSE )
			{
				INT_TRACE( "GetRegDword: AsyncTraceFlag failed: %d\n", GetLastError() );
				return	bRC = FALSE;
			}
						
			if (GetRegDword(hkConfig,
							"HeapIncrementCount",
							(LPDWORD)&dwNewHeapIncrementCount ) == FALSE || 
				dwNewHeapIncrementCount == 0 )
			{
				//
				// optional reg entry
				// default is the number buffers in 64KB
				//
				dwNewHeapIncrementCount = 0x10000 / sizeof(TRACEBUF);
			}
			InterlockedExchange( (long *)&dwIncrementSize, (long)dwNewHeapIncrementCount );


			if ( GetRegDword(	hkConfig,
								"AsyncThreadPriority",
								(LPDWORD)&nNewThreadPriority ) == FALSE )
			{
			//
			// optional reg entry
			//
				nNewThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
			}
			else switch( nNewThreadPriority )
			{
			//
			// if successful verify the resulting value
			//
			case THREAD_PRIORITY_IDLE:
			case THREAD_PRIORITY_BELOW_NORMAL:
			case THREAD_PRIORITY_NORMAL:
			case THREAD_PRIORITY_ABOVE_NORMAL:
			case THREAD_PRIORITY_HIGHEST:
				break;

			default:
				ASSERT( FALSE );
				nNewThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
			}
						
			cbData = sizeof(szNewTraceFileName);
			if ( GetRegString(	hkConfig,
								"TraceFile",
								szNewTraceFileName,
								&cbData ) == FALSE )
			{	
				//
				// Only fail if user specifies FILE based tracing
				//
				if ( dwNewTraceOutputType & TRACE_OUTPUT_FILE )
				{
					INT_TRACE( "GetRegString: TraceFile failed: %d\n", GetLastError() );
					return	bRC = FALSE;
				}
			}
			bRC = TRUE;
		}
	}
	__finally
	{
		//
		// preserve the original error code
		//
		DWORD	dwLastError = GetLastError();
		BOOL	fLeaveCritSec = FALSE;

		if ( bRC == TRUE )
		{
			BOOL	bNewFileName = lstrcmpi( szNewTraceFileName, szTraceFileName ) != 0;
			BOOL	bNewTraces = dwNewEnabledTraces != *INTERNAL__dwEnabledTraces;
			BOOL	bNewFlags = dwNewAsyncTraceFlag != dwAsyncTraceFlag;
			BOOL	bNewOutput = dwNewTraceOutputType != dwTraceOutputType;

			INT_TRACE( "GetTraceFlags... 0x%08X, 0x%08X, 0x%08X, %s\n",
						dwNewAsyncTraceFlag,
						dwNewEnabledTraces,
						dwNewTraceOutputType,
						szNewTraceFileName );

			INT_TRACE( "bNewFileName:%d bNewTraces:%d bNewOutput:%d bNewFlags:%d\n",
						bNewFileName,
						bNewTraces,
						bNewOutput,
						bNewFlags );

			if ( bNewFileName || bNewTraces || bNewOutput || bNewFlags )
			{
				if ( *INTERNAL__dwEnabledTraces )
				{
					//
					// not the initial time thru
					//

					fLeaveCritSec = TRUE;

					if ( dwAsyncTraceFlag )
					{
						INTERNAL__FlushAsyncTrace();
					}
					EnterCriticalSection( &critSecWrite );
				}

				if ( PendQ.hFile !=	INVALID_HANDLE_VALUE )
				{
					//
					// if the file name changed or tracing was disabled or the
					// file tracing disabled, then close the currently open file
					//
					if(	bNewFileName ||
						dwNewEnabledTraces == 0 ||
						IsTraceFile( dwNewTraceOutputType ) == FALSE )
					{
						BOOL	bSuccess;

						EnterCriticalSection( &critSecWrite );
						bSuccess = CloseHandle( PendQ.hFile );
						INT_TRACE( "CloseHandle: %d, GetLastError: %d\n",
									bSuccess, GetLastError() );
						PendQ.hFile = INVALID_HANDLE_VALUE;
						LeaveCriticalSection( &critSecWrite );
					}
				}

				if ( IsTraceFile( dwNewTraceOutputType ) )
				{
					if (bNewFileName ||
						IsTraceFile( dwTraceOutputType ) == FALSE ||
						dwNewEnabledTraces != 0 &&
						PendQ.hFile == INVALID_HANDLE_VALUE )
					{
						PendQ.hFile = CreateFile(szNewTraceFileName,
												GENERIC_WRITE,
												FILE_SHARE_READ|FILE_SHARE_WRITE,
												NULL,
												OPEN_ALWAYS,
												FILE_ATTRIBUTE_NORMAL,
												NULL );

						if ( PendQ.hFile != INVALID_HANDLE_VALUE )
						{
							lstrcpy( szTraceFileName, szNewTraceFileName );
						}
						else
						{
							INT_TRACE( "CreateFile failed for %s 0x%X\n",
										szNewTraceFileName,
										GetLastError() );
						}
					}
				}

				//
				// set the new priority for the writer thread
				//
				if ( nNewThreadPriority != nAsyncThreadPriority )
				{
					nAsyncThreadPriority = nNewThreadPriority;
					SetThreadPriority( PendQ.hWriteThread, nAsyncThreadPriority );
				}

				dwTraceOutputType = dwNewTraceOutputType;
				dwAsyncTraceFlag = dwNewAsyncTraceFlag;

				InterlockedExchange( INTERNAL__dwEnabledTraces, dwNewEnabledTraces );

				if ( fLeaveCritSec )
				{
					//
					// not the initial time thru
					//
					LeaveCriticalSection( &critSecWrite );
				}
			}
		}

		if ( hkConfig != NULL )
		{
			RegCloseKey( hkConfig );
		}

		SetLastError( dwLastError );

    }

    return  bRC;
}




#define	NUM_REG_THREAD_OBJECTS	2

DWORD RegNotifyThread( LPDWORD lpdw )
{
	HANDLE	Handles[NUM_REG_THREAD_OBJECTS];
	HKEY	   hKey;
	DWORD	dw;

	Handles[0] = hShutdownEvent;

	INT_TRACE( "RegNotifyThread 0x%X\n", GetCurrentThreadId() );

	Handles[1] = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( Handles[1] == NULL )
	{
		ASSERT( FALSE );
		INT_TRACE( "RegNotifyThread CreateEvent failed 0x%X\n", GetLastError() );
		return	1;
	}

	if ( RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
						szDebugAsyncTrace,
						0,
						KEY_READ,
						&hKey ) != ERROR_SUCCESS )
	{
		INT_TRACE( "RegNotifyThread RegOpenKeyEx failed 0x%X\n", GetLastError() );
		CloseHandle( Handles[1] );
		return	1;
	}

	for ( ;; )
	{
		if ( RegNotifyChangeKeyValue(hKey,
									FALSE,
									REG_NOTIFY_CHANGE_ATTRIBUTES |
									REG_NOTIFY_CHANGE_LAST_SET,
									Handles[1],
									TRUE ) != ERROR_SUCCESS )
		{
			INT_TRACE( "RegNotifyThread RegNotify... failed 0x%X\n", GetLastError() );
			RegCloseKey( hKey );
			CloseHandle( Handles[1] );
			return	1;
		}

		dw = WaitForMultipleObjects(NUM_REG_THREAD_OBJECTS,
									Handles,
									FALSE,
									INFINITE );

		switch( dw )
		{
		//
		// normal signalled event
		//
		case WAIT_OBJECT_0:
			RegCloseKey( hKey );
			CloseHandle( Handles[1] );
			INT_TRACE( "Exiting RegNotifyThread for hShutdownEvent\n" );
			return	0;

		//
		// signalled that our registry keys have changed
		//
		case WAIT_OBJECT_0+1:
			GetTraceFlagsFromRegistry();
			break;

		default:
			INT_TRACE( "RegNotifyThread WFMO: dw: 0x%X, Error: 0x%X\n", dw, GetLastError() );
			ASSERT( FALSE );
			RegCloseKey( hKey );
			CloseHandle( Handles[1] );
			return	1;
		}
	}

	INT_TRACE( "Exiting RegNotifyThread abnormally\n" );
	RegCloseKey( hKey );
	CloseHandle( Handles[1] );

	return	2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\trace\utest\tracetest.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:	tracetest.cpp
//
//  Contents:	Unit test for tracing
//
//  Functions:	main
//
//  History:	4/6/99		AshishS created
//
//-----------------------------------------------------------------------------


//
// System Includes
//

extern "C" {
#include <windows.h>
};


//
// Project Includes
//

#include <dbgtrace.h>

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

int TestFunction()
{
    TraceFunctEnter("TestFunction");
    for (int i=0; i < 10; i++)
    {
        DebugTrace(1, "Hope this works %d",i);
    }
    TraceFunctLeave();
    return(0);    
}

int _cdecl main(int argc, CHAR ** argv)
{    
    int i;

#if !NOTRACE
    InitAsyncTrace();
#endif
    
    TestFunction();
    
    TermAsyncTrace();
    
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\trace\traceint.h ===
//
// TRACEINT.H
//
// Async tracing internal include file
//

#include "dbgtrace.h"
#include "dbgfile.h"

#ifdef __cplusplus
extern "C" {
#endif


#ifndef ASSERT
#define	ASSERT( x )	(x) ? 1 : DebugBreak()
#endif

#define	MAX_BUFFER_SIZE		160
#define	MAX_FILENAME_SIZE	16
#define	MAX_FUNCTNAME_SIZE	32

#define	TRACE_SIGNATURE		(DWORD)'carT'

//
// +2 == potential CR+LF
//
#define	MAX_VARIABLE_SIZE	(MAX_FILENAME_SIZE + MAX_FUNCTNAME_SIZE + MAX_BUFFER_SIZE)
#define	MAX_TRACE_ENTRY_SIZE (sizeof(FIXEDTRACE) + MAX_VARIABLE_SIZE)

typedef struct tagSPECIALBUF
{
	DWORD	dwSignature;
	struct tagTRACEBUF *pNext;
} SPECIALBUF, * LPSPECIALBUF;


typedef struct tagTRACEBUF
{
	DWORD		dwSignature;
	struct tagTRACEBUF *pNext;
	DWORD		dwLastError;

	//
	// fixed buffer committed to permanent storage ( ie disk )
	//
#pragma pack(2)

	FIXEDTRACE	Fixed;
	char		Buffer[MAX_VARIABLE_SIZE];

#pragma pack()

} TRACEBUF, * LPTRACEBUF;

#define	MAX_WRITE_BUFFER_SIZE	16*1024

typedef struct tagPENDQ
{
	LPTRACEBUF	pHead;
	LPTRACEBUF	pTail;
	SPECIALBUF	Special;
	HANDLE		hEvent;
	HANDLE		hFlushEvent;
	HANDLE		hFlushedEvent;
	DWORD		dwCount;
	DWORD		dwThresholdCount;
	DWORD		dwProcessId;
	BOOL		fShutdown;
	HANDLE		hWriteThread;
	HANDLE		hRegNotifyThread;
	HANDLE		hFile;
	CRITICAL_SECTION critSecTail;
	HANDLE		hFileMutex;
	DWORD		cbBufferEnd;
	char		Buffer[MAX_WRITE_BUFFER_SIZE];
} PENDQ, * LPPENDQ;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// These are the real functions for tracing.
//
extern DWORD* INTERNAL__dwEnabledTraces;

BOOL WINAPI INTERNAL__InitAsyncTrace ( DWORD* dwEnabledTraces );
BOOL WINAPI INTERNAL__TermAsyncTrace ( void );
BOOL WINAPI INTERNAL__FlushAsyncTrace( void );

void WINAPI INTERNAL__DebugAssert( DWORD dwLine, LPCSTR lpszFunction, LPCSTR lpszExpression );

int WINAPI INTERNAL__SetAsyncTraceParams( LPCSTR pszFile, int iLine, LPCSTR szFunction, DWORD dwTraceMask );

int WINAPI INTERNAL__AsyncStringTrace( LPARAM lParam, LPCSTR szFormat    , va_list marker               );
int WINAPI INTERNAL__AsyncBinaryTrace( LPARAM lParam, DWORD  dwBinaryType, LPBYTE  pbData, DWORD cbData );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


//
// Internal Function declarations
//

extern BOOL WINAPI InitTraceBuffers( DWORD dwThresholdCount, DWORD dwIncrement );
extern void WINAPI TermTraceBuffers( void );
extern LPTRACEBUF WINAPI GetTraceBuffer( void );
extern void WINAPI FreeTraceBuffer( LPTRACEBUF lpBuf );

extern LPTRACEBUF DequeueAsyncTraceBuffer( void );
extern void QueueAsyncTraceBuffer( LPTRACEBUF lpBuf );
extern DWORD WriteTraceThread( LPDWORD lpdw );
extern BOOL WriteTraceBuffer( LPTRACEBUF lpBuf );
extern BOOL AsyncTraceCleanup( void );

extern BOOL GetTraceFlagsFromRegistry( void );
extern DWORD RegNotifyThread( LPDWORD lpdw );



extern	PENDQ	PendQ;
extern	BOOL	fInitialized;
extern	HANDLE	hShutdownEvent;
extern	DWORD	dwNumTraces;
extern	DWORD	dwTraceOutputType;
extern	DWORD	dwAsyncTraceFlag;
extern	int		nAsyncThreadPriority;
extern 	DWORD	dwMaxFileSize;
extern 	DWORD	dwIncrementSize;

#define DEFAULT_MAX_FILE_SIZE 1024*1024*5 	// 5 megabytes
#define	AVERAGE_TRACE_SIZE	( sizeof(FIXEDTRACE) + 64 )

extern	CRITICAL_SECTION critSecWrite;

#ifdef	TRACE_ENABLED

extern void CDECL InternalTrace( const char *s, ... );

	#define	INT_TRACE		InternalTrace

#else

__inline void CDECL InternalTrace( const char *s, ... ) {}

	#define	INT_TRACE	1 ? (void)0 : InternalTrace

#endif


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\trace_stub\trace_stub.c ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    trace_stub.c

Abstract:
    This is the static stub linked with all the programs that want to support tracing.

Revision History:
    Davide Massarenti   (Dmassare)  10/27/2000
        created

******************************************************************************/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include <dbgtrace.h>

////////////////////////////////////////////////////////////////////////////////

char szDebugAsyncTrace[] = "SOFTWARE\\Microsoft\\MosTrace\\CurrentVersion\\DebugAsyncTrace";

////////////////////////////////////////////////////////////////////////////////

DWORD __dwEnabledTraces = 0;

static HINSTANCE g_hTRACE;

typedef BOOL (WINAPI *pfnINTERNAL__InitAsyncTrace)( DWORD* dwEnabledTraces );
typedef BOOL (WINAPI *pfnINTERNAL__TermAsyncTrace)( void );
typedef BOOL (WINAPI *pfnINTERNAL__FlushAsyncTrace)( void );

typedef void (WINAPI *pfnINTERNAL__DebugAssert)( DWORD dwLine, LPCSTR lpszFunction, LPCSTR lpszExpression );

typedef int (WINAPI *pfnINTERNAL__SetAsyncTraceParams)( LPCSTR pszFile, int iLine, LPCSTR szFunction, DWORD dwTraceMask );

typedef int (WINAPI *pfnINTERNAL__AsyncStringTrace)( LPARAM lParam, LPCSTR szFormat    , va_list marker               );
typedef int (WINAPI *pfnINTERNAL__AsyncBinaryTrace)( LPARAM lParam, DWORD  dwBinaryType, LPBYTE  pbData, DWORD cbData );

static pfnINTERNAL__InitAsyncTrace      INTERNAL__InitAsyncTrace      = NULL;
static pfnINTERNAL__TermAsyncTrace      INTERNAL__TermAsyncTrace      = NULL;
static pfnINTERNAL__FlushAsyncTrace     INTERNAL__FlushAsyncTrace     = NULL;

static pfnINTERNAL__DebugAssert         INTERNAL__DebugAssert         = NULL;

static pfnINTERNAL__SetAsyncTraceParams INTERNAL__SetAsyncTraceParams = NULL;

static pfnINTERNAL__AsyncStringTrace    INTERNAL__AsyncStringTrace    = NULL;
static pfnINTERNAL__AsyncBinaryTrace    INTERNAL__AsyncBinaryTrace    = NULL;

////////////////////////////////////////////////////////////////////////////////

BOOL InitAsyncTrace( void )
{
    if(g_hTRACE == NULL)
    {
        HKEY hkConfig = NULL;

        __try
        {
            if(RegOpenKeyEx( HKEY_LOCAL_MACHINE, szDebugAsyncTrace, 0, KEY_READ, &hkConfig ) == ERROR_SUCCESS)
            {
                DWORD cbData = sizeof( DWORD );
                DWORD dwType = REG_DWORD;

                (void)RegQueryValueEx( hkConfig, "EnabledTraces", NULL, &dwType, (LPBYTE)&__dwEnabledTraces, &cbData );
            }
        }
        __finally
        {
            if(hkConfig != NULL) RegCloseKey( hkConfig );
        }

        if(__dwEnabledTraces)
        {
            if(!(g_hTRACE = LoadLibraryW( L"atrace.dll" ))) return FALSE;

            if(!(INTERNAL__InitAsyncTrace      = (pfnINTERNAL__InitAsyncTrace     )GetProcAddress( g_hTRACE, "INTERNAL__InitAsyncTrace"      ))) return FALSE;
            if(!(INTERNAL__TermAsyncTrace      = (pfnINTERNAL__TermAsyncTrace     )GetProcAddress( g_hTRACE, "INTERNAL__TermAsyncTrace"      ))) return FALSE;
            if(!(INTERNAL__FlushAsyncTrace     = (pfnINTERNAL__FlushAsyncTrace    )GetProcAddress( g_hTRACE, "INTERNAL__FlushAsyncTrace"     ))) return FALSE;

            if(!(INTERNAL__DebugAssert         = (pfnINTERNAL__DebugAssert        )GetProcAddress( g_hTRACE, "INTERNAL__DebugAssert"         ))) return FALSE;

            if(!(INTERNAL__SetAsyncTraceParams = (pfnINTERNAL__SetAsyncTraceParams)GetProcAddress( g_hTRACE, "INTERNAL__SetAsyncTraceParams" ))) return FALSE;

            if(!(INTERNAL__AsyncStringTrace    = (pfnINTERNAL__AsyncStringTrace   )GetProcAddress( g_hTRACE, "INTERNAL__AsyncStringTrace"    ))) return FALSE;
            if(!(INTERNAL__AsyncBinaryTrace    = (pfnINTERNAL__AsyncBinaryTrace   )GetProcAddress( g_hTRACE, "INTERNAL__AsyncBinaryTrace"    ))) return FALSE;
        }
    }

    return INTERNAL__InitAsyncTrace ? INTERNAL__InitAsyncTrace( &__dwEnabledTraces ) : TRUE;
}

BOOL TermAsyncTrace( void )
{
    return INTERNAL__TermAsyncTrace ? INTERNAL__TermAsyncTrace() : TRUE;
}

BOOL FlushAsyncTrace( void )
{
    return INTERNAL__FlushAsyncTrace ? INTERNAL__FlushAsyncTrace() : TRUE;
}

void DebugAssert( DWORD dwLine, LPCSTR lpszFunction, LPCSTR lpszExpression )
{
    if(INTERNAL__DebugAssert) INTERNAL__DebugAssert( dwLine, lpszFunction, lpszExpression );
}

int SetAsyncTraceParams( LPCSTR pszFile, int iLine, LPCSTR szFunction, DWORD dwTraceMask )
{
    return INTERNAL__SetAsyncTraceParams ? INTERNAL__SetAsyncTraceParams( pszFile, iLine, szFunction, dwTraceMask ) : 0;
}

int AsyncStringTrace( LPARAM lParam, LPCSTR szFormat, va_list marker )
{
    return INTERNAL__AsyncStringTrace ? INTERNAL__AsyncStringTrace( lParam, szFormat, marker ) : 0;
}

int AsyncBinaryTrace( LPARAM lParam, DWORD  dwBinaryType, LPBYTE  pbData, DWORD cbData )
{
    return INTERNAL__AsyncBinaryTrace ? INTERNAL__AsyncBinaryTrace( lParam, dwBinaryType, pbData, cbData ) : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\bugrept\brp_sysinfo\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\bugrept\brp_sysinfo\bugrepsysinfo.h ===
// BugRepSysInfo.h : Declaration of the CBugRepSysInfo

#ifndef __BUGREPSYSINFO_H_
#define __BUGREPSYSINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CBugRepSysInfo
class ATL_NO_VTABLE CBugRepSysInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CBugRepSysInfo, &CLSID_BugRepSysInfo>,
	public IDispatchImpl<IBugRepSysInfo, &IID_IBugRepSysInfo, &LIBID_BRP_SYSINFOLib>
{
public:
	CBugRepSysInfo()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_BUGREPSYSINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBugRepSysInfo)
	COM_INTERFACE_ENTRY(IBugRepSysInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IBugRepSysInfo
public:
	STDMETHOD(GetActiveCP)(/*[out,retval]*/ UINT *pnACP);
	STDMETHOD(GetUserDefaultLCID)(DWORD *pdwLCID);
	STDMETHOD(GetOSVersionString)(/*[out,retval]*/ BSTR* pbstrOSVersion);
	STDMETHOD(GetLanguageID)(/*[out,retval]*/ INT* pintLanguage);
};

#endif //__BUGREPSYSINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\bugrept\brp_sysinfo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by brp_sysinfo.rc
//
#define IDS_PROJNAME                    100
#define IDR_BUGREPSYSINFO               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\bugrept\brp_sysinfo\brp_sysinfo.cpp ===
// brp_sysinfo.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f brp_sysinfops.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "brp_sysinfo.h"

#include "brp_sysinfo_i.c"
#include "BugRepSysInfo.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_BugRepSysInfo, CBugRepSysInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_BRP_SYSINFOLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\bugrept\brp_sysinfo\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8AC69ACD_7738_42BC_BA57_AF81DA40D7E2__INCLUDED_)
#define AFX_STDAFX_H__8AC69ACD_7738_42BC_BA57_AF81DA40D7E2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8AC69ACD_7738_42BC_BA57_AF81DA40D7E2__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\bugrept\brp_sysinfo\bugrepsysinfo.cpp ===
/*
 ***************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 * 
 * Module Name: BugRepSysInfo.c
 * 
 * Abstract   : Gets language and OS information for bug reporting pages
 *
 * 
 * Revision History:
 *
 * 1999-09-30 : aarvind  : Created the file, my first Windows program
 *
 ***************************************************************************
 */


// BugRepSysInfo.cpp : Implementation of CBugRepSysInfo
#include "stdafx.h"
#include "Brp_sysinfo.h"
#include "BugRepSysInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CBugRepSysInfo

static WORD GetLanguageFromFile(const TCHAR* pszFileName, const TCHAR* pszPath);


/*
 ***************************************************************************
 *
 *	GetLanguageString
 *
 *  Returns the language found from a file and using the user default
 *  settings
 *
 ***************************************************************************
 */
STDMETHODIMP CBugRepSysInfo::GetLanguageID(INT *pintLanguage)
{
	WORD  wLanguage;
	TCHAR szSystemPath[MAX_PATH];

	// Get the original language from a system file. 
	if ( !GetSystemDirectory(szSystemPath, MAX_PATH)) 
	{
		//
		// Handle failure of this function to get system directory
		//
		return E_FAIL ;
	};

	//
	// Gets the language id, returns zero if a failure occurs
	//
    if (wLanguage = GetLanguageFromFile(TEXT("user.exe"), szSystemPath))
    {
        *pintLanguage = (INT) wLanguage ;
    }
	else {
		//
		// Handle failure of this function to get language or file information
		//
		return E_FAIL ;
	}


	return S_OK;
}

/*
 ***************************************************************************
 *
 *	GetOSVersionString
 * 
 *  Gets the version information of the operating system
 *
 ***************************************************************************
 */
STDMETHODIMP CBugRepSysInfo::GetOSVersionString(BSTR *pbstrOSVersion)
{

	OSVERSIONINFO OSVersionInfo;
	DWORD         dwPlatformID;
	DWORD         dwMajorVersion;
	DWORD         dwMinorVersion;
	DWORD         dwBuildNumber;
	TCHAR         szCSDVersion[200];
	TCHAR         szOSVersion[200];

	USES_CONVERSION;

	// Get Windows version
    OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);

    if ( GetVersionEx(&OSVersionInfo) )
	{

		dwMajorVersion = OSVersionInfo.dwMajorVersion;
		dwMinorVersion = OSVersionInfo.dwMinorVersion;
		dwBuildNumber  = OSVersionInfo.dwBuildNumber;
	    dwPlatformID   = OSVersionInfo.dwPlatformId;

		lstrcpy(szCSDVersion, OSVersionInfo.szCSDVersion);

		//
		// Create system information string
		//
		wsprintf(szOSVersion,"%d.%d.%d %s",dwMajorVersion,dwMinorVersion,LOWORD(dwBuildNumber),szCSDVersion);

		*pbstrOSVersion = SysAllocString(T2COLE(szOSVersion));
	}
	else {

		//
		// Function to get OS Version failed so do something
		//
		// Use GetLastError to return error code to script
		//
		return E_FAIL ;

	}

	return S_OK;
}

/*
 ***************************************************************************
 *
 *	GetLanguageFromFile
 *
 ***************************************************************************
 */
static WORD GetLanguageFromFile(const TCHAR* pszFileName, const TCHAR* pszPath)
{
	BYTE				FileVersionBuffer[4096];
	DWORD			   *pdwCharSet;
	UINT				cb;
	DWORD				dwHandle;
	TCHAR				szFileAndPath[MAX_PATH];
	WORD				wLanguage;
  
	lstrcpy(szFileAndPath, pszPath);
	lstrcat(szFileAndPath, TEXT("\\"));
	lstrcat(szFileAndPath, pszFileName);
	memset(&FileVersionBuffer, 0, sizeof FileVersionBuffer);

	//
	// Set default language value
	//
	wLanguage = 0;
	
	if (cb = GetFileVersionInfoSize(szFileAndPath, &dwHandle/*ignored*/))
	{
		cb = (cb <= sizeof FileVersionBuffer ? cb : sizeof FileVersionBuffer);

		if (GetFileVersionInfo(szFileAndPath, 0, cb, &FileVersionBuffer))
		{
			pdwCharSet = 0;

			if (VerQueryValue(&FileVersionBuffer, TEXT("\\VarFileInfo\\Translation"), (void**)&pdwCharSet, &cb)
				&& pdwCharSet && cb) 
			{
				wLanguage = LOWORD(*pdwCharSet);
			}
		}
	}	 

	return wLanguage;
}


STDMETHODIMP CBugRepSysInfo::GetUserDefaultLCID(DWORD *pdwLCID)
{
	
	*pdwLCID = ::GetUserDefaultLCID();

	return S_OK;
}

STDMETHODIMP CBugRepSysInfo::GetActiveCP(UINT *pnACP)
{
	
	*pnACP = ::GetACP();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\bugrept\whistler\makefile.inc ===
gocab:
	del bugrept.cab
	cabarc -s 6144 n bugrept.cab *.htm bugrep.css errcodes.vbs brreadme.txt *.xml *.gif *.jpg 
	notepad signcab.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\disasm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		disasm.cpp
//	Author:		Doug Brubacher
//
//	Detours for binary functions.  Version 1.2. (Build 35)
//  Includes support for all x86 chips prior to the Pentium III.
//
//	Copyright 1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

#include "stdafx.h"

#include <imagehlp.h>

#undef ASSERT
#define ASSERT(x)

//////////////////////////////////////////////////////////////////////////////
//
//  Function:
//      DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget)
//  Purpose:
//      Copy a single instruction from pbSrc to pbDst.
//  Arguments:
//      pbDst:
//          Destination address for the instruction.  May be NULL in which
//          case DetourCopyInstruction is used to measure an instruction.
//          If not NULL then the source instruction is copied to the
//          destination instruction and any relative arguments are adjusted.
//      pbSrc:
//          Source address of the instruction.
//      ppbTarget:
//          Out parameter for any target instruction address pointed to by
//          the instruction.  For example, a branch or a jump insruction has
//          a target, but a load or store instruction doesn't.  A target is
//          another instruction that may be executed as a result of this
//          instruction.  ppbTarget may be NULL.
//		plExtra:
//			Out parameter for the number of extra bytes needed by the
//			instruction to reach the target.  For example, lExtra = 3 if the
//			instruction had an 8-bit relative offset, but needs a 32-bit
//			relative offset.
//  Returns:
//      Returns the address of the next instruction (following in the source)
//      instruction.  By subtracting pbSrc from the return value, the caller
//      can determinte the size of the instruction copied.
//  Comments:
//      By following the pbTarget, the caller can follow alternate
//      instruction streams.  However, it is not always possible to determine
//      the target based on static analysis.  For example, the destination of
//      a jump relative to a register cannot be determined from just the
//      instruction stream.  The output value, pbTarget, can have any of the
//      following outputs:
//			DETOUR_INSTRUCTION_TARGET_NONE:
//          	The instruction has no targets.
//			DETOUR_INSTRUCTION_TARGET_DYNAMIC:
//          	The instruction has a non-deterministic (dynamic) target.
//				(i.e. the jump is to an address held in a register.)
//          Address:   The instruction has the specified target.
//
//      When copying instructions, DetourCopyInstruction insures that any
//      targets remain constant.  It does so by adjusting any IP relative
//      offsets.
//
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
									 PBYTE pbSrc,
									 PBYTE *ppbTarget,
									 LONG *plExtra)
{
	CDetourDis oDetourDisasm(ppbTarget, plExtra);
	return oDetourDisasm.CopyInstruction(pbDst, pbSrc);
}

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget)
{
	CDetourDis oDetourDisasm(ppbTarget, NULL);
	return oDetourDisasm.CopyInstruction(pbDst, pbSrc);
}

/////////////////////////////////////////////////////////// Disassembler Code.
//
CDetourDis::CDetourDis(PBYTE *ppbTarget, LONG *plExtra)
{
	Set32BitOperand();
	Set32BitAddress();

	m_ppbTarget = ppbTarget ? ppbTarget : &m_pbScratchTarget;
	m_plExtra = plExtra ? plExtra : &m_lScratchExtra;

	*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_NONE;
	*m_plExtra = 0;
}

VOID CDetourDis::Set16BitOperand()
{
	m_b16BitOperand = TRUE;
}

VOID CDetourDis::Set32BitOperand()
{
	m_b16BitOperand = FALSE;
}

VOID CDetourDis::Set16BitAddress()
{
	m_b16BitAddress = TRUE;
}

VOID CDetourDis::Set32BitAddress()
{
	m_b16BitAddress = FALSE;
}

PBYTE CDetourDis::CopyInstruction(PBYTE pbDst, PBYTE pbSrc)
{
	// Configure scratch areas if real areas are not available.
	if (NULL == pbDst) {
		pbDst = m_rbScratchDst;
	}
	if (NULL == pbSrc) {
		// We can't copy a non-existent instruction.
		SetLastError(ERROR_INVALID_DATA);
		return NULL;
	}
	
	// Figure out how big the instruction is, do the appropriate copy,
	// and figure out what the target of the instruction is if any.
	//
	REFCOPYENTRY pEntry = &s_rceCopyTable[pbSrc[0]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
	LONG nBytesFixed = (pEntry->nFlagBits & ADDRESS)
		? (m_b16BitAddress ? pEntry->nFixedSize16 : pEntry->nFixedSize)
		: (m_b16BitOperand ? pEntry->nFixedSize16 : pEntry->nFixedSize);
	LONG nBytes = nBytesFixed;
	if (pEntry->nModOffset > 0) {
		BYTE bModRm = pbSrc[pEntry->nModOffset];
		BYTE bFlags = s_rbModRm[bModRm];
		
		if (bFlags & SIB) {
			BYTE bSib = pbSrc[pEntry->nModOffset + 1];
			
			if ((bSib & 0x07) == 0x05) {
				if ((bModRm & 0xc0) == 0x00) {
					nBytes += 4;
				}
				else if ((bModRm & 0xc0) == 0x40) {
					nBytes += 1;
				}
				else if ((bModRm & 0xc0) == 0x80) {
					nBytes += 4;
				}
			}
		}
		nBytes += bFlags & NOTSIB;
	}
	CopyMemory(pbDst, pbSrc, nBytes);

	if (pEntry->nRelOffset) {
		*m_ppbTarget = AdjustTarget(pbDst, pbSrc, nBytesFixed, pEntry->nRelOffset);
	}
	if (pEntry->nFlagBits & NOENLARGE) {
		*m_plExtra = -*m_plExtra;
	}
	if (pEntry->nFlagBits & DYNAMIC) {
		*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_DYNAMIC;
	}
	return pbSrc + nBytes;
}

PBYTE CDetourDis::CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	CopyBytes(pEntry, pbDst, pbSrc);
	
	pEntry = &s_rceCopyTable[pbSrc[1]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::AdjustTarget(PBYTE pbDst, PBYTE pbSrc, LONG cbOp, LONG cbTargetOffset)
{
	LONG cbTargetSize = cbOp - cbTargetOffset;
	PBYTE pbTarget = NULL;
	PVOID pvTargetAddr = &pbDst[cbTargetOffset];
	LONG nOldOffset = 0;
	
	switch (cbTargetSize) {
	  case 1:
		nOldOffset = (LONG)*(PCHAR&)pvTargetAddr;
		*m_plExtra = 3;
		break;
	  case 2:
		nOldOffset = (LONG)*(PSHORT&)pvTargetAddr;
		*m_plExtra = 2;
		break;
	  case 4:
		nOldOffset = (LONG)*(PLONG&)pvTargetAddr;
		*m_plExtra = 0;
		break;
	  default:
		ASSERT(!"cbTargetSize is invalid.");
		break;
	}
	
	pbTarget = pbSrc + cbOp + nOldOffset;
	LONG nNewOffset = nOldOffset - (pbDst - pbSrc);
	
	switch (cbTargetSize) {
	  case 1:
		*(PCHAR&)pvTargetAddr = (CHAR)nNewOffset;
		break;
	  case 2:
		*(PSHORT&)pvTargetAddr = (SHORT)nNewOffset;
		break;
	  case 4:
		*(PLONG&)pvTargetAddr = (LONG)nNewOffset;
		break;
	}
	ASSERT(pbDst + cbOp + nNewOffset == pbTarget);
	return pbTarget;
}

PBYTE CDetourDis::Invalid(REFCOPYENTRY /*pEntry*/, PBYTE /*pbDst*/, PBYTE pbSrc) 
{
	ASSERT(!"Invalid Instruction");
	return pbSrc + 1;
}

////////////////////////////////////////////////////// Individual Bytes Codes.
//
PBYTE CDetourDis::Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
	CopyBytes(pEntry, pbDst, pbSrc);
	
	pEntry = &s_rceCopyTable0F[pbSrc[1]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// Operand-size override prefix
	Set16BitOperand();
	return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// Address size override prefix
	Set16BitAddress();
	return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF6(REFCOPYENTRY /*pEntry*/, PBYTE pbDst, PBYTE pbSrc) 
{
	// TEST BYTE /0
	if (0x00 == (0x38 & pbSrc[1])) {	// reg(bits 543) of ModR/M == 0
		const COPYENTRY ce = { 0xf6, ENTRY_CopyBytes2Mod1 };
		return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
	}
	// DIV /6
	// IDIV /7
	// IMUL /5
	// MUL /4
	// NEG /3
	// NOT /2
	
	const COPYENTRY ce = { 0xf6, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF7(REFCOPYENTRY /*pEntry*/, PBYTE pbDst, PBYTE pbSrc) 
{
	// TEST WORD /0
	if (0x00 == (0x38 & pbSrc[1])) {	// reg(bits 543) of ModR/M == 0
		const COPYENTRY ce = { 0xf7, ENTRY_CopyBytes2ModOperand };
		return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
	}
	
	// DIV /6
	// IDIV /7
	// IMUL /5
	// MUL /4
	// NEG /3
	// NOT /2
	const COPYENTRY ce = { 0xf7, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyFF(REFCOPYENTRY /*pEntry*/, PBYTE pbDst, PBYTE pbSrc) 
{	// CALL /2
	// CALL /3
	// INC /0
	// JMP /4
	// JMP /5
	// PUSH /6

	if (0x15 == pbSrc[1] || 0x25 == pbSrc[1]) {			// CALL [], JMP []
		PBYTE *ppbTarget = *(PBYTE**) &pbSrc[2];
		*m_ppbTarget = *ppbTarget;
	}
	else if (0x10 == (0x38 & pbSrc[1]) || // CALL /2 --> reg(bits 543) of ModR/M == 010
			 0x18 == (0x38 & pbSrc[1]) || // CALL /3 --> reg(bits 543) of ModR/M == 011
			 0x20 == (0x38 & pbSrc[1]) || // JMP /4 --> reg(bits 543) of ModR/M == 100
			 0x28 == (0x38 & pbSrc[1])    // JMP /5 --> reg(bits 543) of ModR/M == 101
			 ) {
		*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_DYNAMIC;
	}
	const COPYENTRY ce = { 0xff, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

///////////////////////////////////////////////////////// Disassembler Tables.
//
const BYTE CDetourDis::s_rbModRm[256] = {
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 0x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 1x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 2x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 3x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 4x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 5x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 6x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 7x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// 8x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// 9x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// Ax
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// Bx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Cx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Dx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Ex
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0					// Fx
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable[257] =
{ 
	{ 0x00, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x01, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x02, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x03, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x04, ENTRY_CopyBytes2 },							// ADD ib
	{ 0x05, ENTRY_CopyBytes3Or5 },						// ADD iw
	{ 0x06, ENTRY_CopyBytes1 },							// PUSH
	{ 0x07, ENTRY_CopyBytes1 },							// POP
	{ 0x08, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x09, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0A, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0B, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0C, ENTRY_CopyBytes2 },							// OR ib
	{ 0x0D, ENTRY_CopyBytes3Or5 },						// OR iw
	{ 0x0E, ENTRY_CopyBytes1 },							// PUSH
	{ 0x0F, ENTRY_Copy0F },								// Extension Ops 
	{ 0x10, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x11, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x12, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x13, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x14, ENTRY_CopyBytes2 },							// ADC ib
	{ 0x15, ENTRY_CopyBytes3Or5 },						// ADC id
	{ 0x16, ENTRY_CopyBytes1 },							// PUSH
	{ 0x17, ENTRY_CopyBytes1 },							// POP
	{ 0x18, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x19, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1A, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1B, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1C, ENTRY_CopyBytes2 },							// SBB ib
	{ 0x1D, ENTRY_CopyBytes3Or5 },						// SBB id
	{ 0x1E, ENTRY_CopyBytes1 },							// PUSH
	{ 0x1F, ENTRY_CopyBytes1 },							// POP
	{ 0x20, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x21, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x22, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x23, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x24, ENTRY_CopyBytes2 },							// AND ib
	{ 0x25, ENTRY_CopyBytes3Or5 },						// AND id
	{ 0x26, ENTRY_CopyBytesPrefix },					// ES prefix 
	{ 0x27, ENTRY_CopyBytes1 },							// DAA
	{ 0x28, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x29, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2A, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2B, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2C, ENTRY_CopyBytes2 },							// SUB ib
	{ 0x2D, ENTRY_CopyBytes3Or5 },						// SUB id
	{ 0x2E, ENTRY_CopyBytesPrefix },					// CS prefix 
	{ 0x2F, ENTRY_CopyBytes1 },							// DAS
	{ 0x30, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x31, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x32, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x33, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x34, ENTRY_CopyBytes2 },							// XOR ib
	{ 0x35, ENTRY_CopyBytes3Or5 },						// XOR id
	{ 0x36, ENTRY_CopyBytesPrefix },					// SS prefix 
	{ 0x37, ENTRY_CopyBytes1 },							// AAA
	{ 0x38, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x39, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3A, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3B, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3C, ENTRY_CopyBytes2 },							// CMP ib
	{ 0x3D, ENTRY_CopyBytes3Or5 },						// CMP id
	{ 0x3E, ENTRY_CopyBytesPrefix },					// DS prefix 
	{ 0x3F, ENTRY_CopyBytes1 },							// AAS
	{ 0x40, ENTRY_CopyBytes1 },							// INC
	{ 0x41, ENTRY_CopyBytes1 },							// INC
	{ 0x42, ENTRY_CopyBytes1 },							// INC
	{ 0x43, ENTRY_CopyBytes1 },							// INC
	{ 0x44, ENTRY_CopyBytes1 },							// INC
	{ 0x45, ENTRY_CopyBytes1 },							// INC
	{ 0x46, ENTRY_CopyBytes1 },							// INC
	{ 0x47, ENTRY_CopyBytes1 },							// INC
	{ 0x48, ENTRY_CopyBytes1 },							// DEC
	{ 0x49, ENTRY_CopyBytes1 },							// DEC
	{ 0x4A, ENTRY_CopyBytes1 },							// DEC
	{ 0x4B, ENTRY_CopyBytes1 },							// DEC
	{ 0x4C, ENTRY_CopyBytes1 },							// DEC
	{ 0x4D, ENTRY_CopyBytes1 },							// DEC
	{ 0x4E, ENTRY_CopyBytes1 },							// DEC
	{ 0x4F, ENTRY_CopyBytes1 },							// DEC
	{ 0x50, ENTRY_CopyBytes1 },							// PUSH
	{ 0x51, ENTRY_CopyBytes1 },							// PUSH
	{ 0x52, ENTRY_CopyBytes1 },							// PUSH
	{ 0x53, ENTRY_CopyBytes1 },							// PUSH
	{ 0x54, ENTRY_CopyBytes1 },							// PUSH
	{ 0x55, ENTRY_CopyBytes1 },							// PUSH
	{ 0x56, ENTRY_CopyBytes1 },							// PUSH
	{ 0x57, ENTRY_CopyBytes1 },							// PUSH
	{ 0x58, ENTRY_CopyBytes1 },							// POP
	{ 0x59, ENTRY_CopyBytes1 },							// POP
	{ 0x5A, ENTRY_CopyBytes1 },							// POP
	{ 0x5B, ENTRY_CopyBytes1 },							// POP
	{ 0x5C, ENTRY_CopyBytes1 },							// POP
	{ 0x5D, ENTRY_CopyBytes1 },							// POP
	{ 0x5E, ENTRY_CopyBytes1 },							// POP
	{ 0x5F, ENTRY_CopyBytes1 },							// POP
	{ 0x60, ENTRY_CopyBytes1 },							// PUSHAD
	{ 0x61, ENTRY_CopyBytes1 },							// POPAD
	{ 0x62, ENTRY_CopyBytes2Mod },						// BOUND /r
	{ 0x63, ENTRY_CopyBytes2Mod },						// ARPL /r
	{ 0x64, ENTRY_CopyBytesPrefix },					// FS prefix 
	{ 0x65, ENTRY_CopyBytesPrefix },					// GS prefix 
	{ 0x66, ENTRY_Copy66 },								// Operand Prefix 
	{ 0x67, ENTRY_Copy67 },								// Address Prefix 
	{ 0x68, ENTRY_CopyBytes3Or5 },						// PUSH
	{ 0x69, ENTRY_CopyBytes2ModOperand },				// 
	{ 0x6A, ENTRY_CopyBytes2 },							// PUSH
	{ 0x6B, ENTRY_CopyBytes2Mod1 },						// IMUL /r ib 
	{ 0x6C, ENTRY_CopyBytes1 },							// INS
	{ 0x6D, ENTRY_CopyBytes1 },							// INS
	{ 0x6E, ENTRY_CopyBytes1 },							// OUTS/OUTSB
	{ 0x6F, ENTRY_CopyBytes1 },							// OUTS/OUTSW
	{ 0x70, ENTRY_CopyBytes2Jump },						// JO
	{ 0x71, ENTRY_CopyBytes2Jump },						// JNO
	{ 0x72, ENTRY_CopyBytes2Jump },						// JB/JC/JNAE
	{ 0x73, ENTRY_CopyBytes2Jump },						// JAE/JNB/JNC
	{ 0x74, ENTRY_CopyBytes2Jump },						// JE/JZ
	{ 0x75, ENTRY_CopyBytes2Jump },						// JNE/JNZ
	{ 0x76, ENTRY_CopyBytes2Jump },						// JBE/JNA
	{ 0x77, ENTRY_CopyBytes2Jump },						// JA/JNBE
	{ 0x78, ENTRY_CopyBytes2Jump },						// JS
	{ 0x79, ENTRY_CopyBytes2Jump },						// JNS
	{ 0x7A, ENTRY_CopyBytes2Jump },						// JP/JPE
	{ 0x7B, ENTRY_CopyBytes2Jump },						// JNP/JPO
	{ 0x7C, ENTRY_CopyBytes2Jump },						// JL/JNGE
	{ 0x7D, ENTRY_CopyBytes2Jump },						// JGE/JNL
	{ 0x7E, ENTRY_CopyBytes2Jump },						// JLE/JNG
	{ 0x7F, ENTRY_CopyBytes2Jump },						// JG/JNLE
	{ 0x80, ENTRY_CopyBytes2Mod1 },						// ADC/2 ib, etc.s 
	{ 0x81, ENTRY_CopyBytes2ModOperand },				// 
	{ 0x82, ENTRY_CopyBytes2 },							// MOV al,x
	{ 0x83, ENTRY_CopyBytes2Mod1 },						// ADC/2 ib, etc. 
	{ 0x84, ENTRY_CopyBytes2Mod },						// TEST /r
	{ 0x85, ENTRY_CopyBytes2Mod },						// TEST /r
	{ 0x86, ENTRY_CopyBytes2Mod },						// XCHG /r @todo 
	{ 0x87, ENTRY_CopyBytes2Mod },						// XCHG /r @todo 
	{ 0x88, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x89, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8A, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8B, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8C, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8D, ENTRY_CopyBytes2Mod },						// LEA /r
	{ 0x8E, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8F, ENTRY_CopyBytes2Mod },						// POP /0
	{ 0x90, ENTRY_CopyBytes1 },							// NOP
	{ 0x91, ENTRY_CopyBytes1 },							// XCHG
	{ 0x92, ENTRY_CopyBytes1 },							// XCHG
	{ 0x93, ENTRY_CopyBytes1 },							// XCHG
	{ 0x94, ENTRY_CopyBytes1 },							// XCHG
	{ 0x95, ENTRY_CopyBytes1 },							// XCHG
	{ 0x96, ENTRY_CopyBytes1 },							// XCHG
	{ 0x97, ENTRY_CopyBytes1 },							// XCHG
	{ 0x98, ENTRY_CopyBytes1 },							// CWDE
	{ 0x99, ENTRY_CopyBytes1 },							// CDQ
	{ 0x9A, ENTRY_CopyBytes5Or7Dynamic },				// CALL cp 
	{ 0x9B, ENTRY_CopyBytes1 },							// WAIT/FWAIT
	{ 0x9C, ENTRY_CopyBytes1 },							// PUSHFD
	{ 0x9D, ENTRY_CopyBytes1 },							// POPFD
	{ 0x9E, ENTRY_CopyBytes1 },							// SAHF
	{ 0x9F, ENTRY_CopyBytes1 },							// LAHF
	{ 0xA0, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA1, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA2, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA3, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA4, ENTRY_CopyBytes1 },							// MOVS
	{ 0xA5, ENTRY_CopyBytes1 },							// MOVS/MOVSD
	{ 0xA6, ENTRY_CopyBytes1 },							// CMPS/CMPSB
	{ 0xA7, ENTRY_CopyBytes1 },							// CMPS/CMPSW
	{ 0xA8, ENTRY_CopyBytes2 },							// TEST
	{ 0xA9, ENTRY_CopyBytes3Or5 },						// TEST
	{ 0xAA, ENTRY_CopyBytes1 },							// STOS/STOSB
	{ 0xAB, ENTRY_CopyBytes1 },							// STOS/STOSW
	{ 0xAC, ENTRY_CopyBytes1 },							// LODS/LODSB
	{ 0xAD, ENTRY_CopyBytes1 },							// LODS/LODSW
	{ 0xAE, ENTRY_CopyBytes1 },							// SCAS/SCASB
	{ 0xAF, ENTRY_CopyBytes1 },							// SCAS/SCASD
	{ 0xB0, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB1, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB2, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB3, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB4, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB5, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB6, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB7, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB8, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xB9, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBA, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBB, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBC, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBD, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBE, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBF, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xC0, ENTRY_CopyBytes2Mod1 },						// RCL/2 ib, etc. 
	{ 0xC1, ENTRY_CopyBytes2Mod1 },						// RCL/2 ib, etc. 
	{ 0xC2, ENTRY_CopyBytes3 },							// RET
	{ 0xC3, ENTRY_CopyBytes1 },							// RET
	{ 0xC4, ENTRY_CopyBytes2Mod },						// LES
	{ 0xC5, ENTRY_CopyBytes2Mod },						// LDS
	{ 0xC6, ENTRY_CopyBytes2Mod1 },						// MOV 
	{ 0xC7, ENTRY_CopyBytes2ModOperand },				// MOV
	{ 0xC8, ENTRY_CopyBytes4 },							// ENTER
	{ 0xC9, ENTRY_CopyBytes1 },							// LEAVE
	{ 0xCA, ENTRY_CopyBytes3Dynamic },					// RET
	{ 0xCB, ENTRY_CopyBytes1Dynamic },					// RET
	{ 0xCC, ENTRY_CopyBytes1Dynamic },					// INT 3
	{ 0xCD, ENTRY_CopyBytes2Dynamic },					// INT ib
	{ 0xCE, ENTRY_CopyBytes1Dynamic },					// INTO
	{ 0xCF, ENTRY_CopyBytes1Dynamic },					// IRET
	{ 0xD0, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD1, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD2, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD3, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD4, ENTRY_CopyBytes2 },							// AAM
	{ 0xD5, ENTRY_CopyBytes2 },							// AAD
	{ 0xD6, ENTRY_Invalid },							// 
	{ 0xD7, ENTRY_CopyBytes1 },							// XLAT/XLATB
	{ 0xD8, ENTRY_CopyBytes2Mod },						// FADD, etc. 
	{ 0xD9, ENTRY_CopyBytes2Mod },						// F2XM1, etc.
	{ 0xDA, ENTRY_CopyBytes2Mod },						// FLADD, etc. 
	{ 0xDB, ENTRY_CopyBytes2Mod },						// FCLEX, etc. 
	{ 0xDC, ENTRY_CopyBytes2Mod },						// FADD/0, etc. 
	{ 0xDD, ENTRY_CopyBytes2Mod },						// FFREE, etc. 
	{ 0xDE, ENTRY_CopyBytes2Mod },						// FADDP, etc. 
	{ 0xDF, ENTRY_CopyBytes2Mod },						// FBLD/4, etc. 
	{ 0xE0, ENTRY_CopyBytes2CantJump },					// LOOPNE cb
	{ 0xE1, ENTRY_CopyBytes2CantJump },					// LOOPE cb
	{ 0xE2, ENTRY_CopyBytes2CantJump },					// LOOP cb
	{ 0xE3, ENTRY_CopyBytes2Jump },						// JCXZ/JECXZ
	{ 0xE4, ENTRY_CopyBytes2 },							// IN ib
	{ 0xE5, ENTRY_CopyBytes2 },							// IN id
	{ 0xE6, ENTRY_CopyBytes2 },							// OUT ib
	{ 0xE7, ENTRY_CopyBytes2 },							// OUT ib
	{ 0xE8, ENTRY_CopyBytes3Or5Target },				// CALL cd
	{ 0xE9, ENTRY_CopyBytes3Or5Target },				// JMP cd
	{ 0xEA, ENTRY_CopyBytes5Or7Dynamic },				// JMP cp
	{ 0xEB, ENTRY_CopyBytes2Jump },						// JMP cb
	{ 0xEC, ENTRY_CopyBytes1 },							// IN ib
	{ 0xED, ENTRY_CopyBytes1 },							// IN id
	{ 0xEE, ENTRY_CopyBytes1 },							// OUT
	{ 0xEF, ENTRY_CopyBytes1 },							// OUT
	{ 0xF0, ENTRY_CopyBytesPrefix },					// LOCK prefix 
	{ 0xF1, ENTRY_Invalid },							// 
	{ 0xF2, ENTRY_CopyBytesPrefix },					// REPNE prefix 
	{ 0xF3, ENTRY_CopyBytesPrefix },					// REPE prefix 
	{ 0xF4, ENTRY_CopyBytes1 },							// HLT
	{ 0xF5, ENTRY_CopyBytes1 },							// CMC
	{ 0xF6, ENTRY_CopyF6 },								// TEST/0, DIV/6 
	{ 0xF7, ENTRY_CopyF7 },								// TEST/0, DIV/6 
	{ 0xF8, ENTRY_CopyBytes1 },							// CLC
	{ 0xF9, ENTRY_CopyBytes1 },							// STC
	{ 0xFA, ENTRY_CopyBytes1 },							// CLI
	{ 0xFB, ENTRY_CopyBytes1 },							// STI
	{ 0xFC, ENTRY_CopyBytes1 },							// CLD
	{ 0xFD, ENTRY_CopyBytes1 },							// STD
	{ 0xFE, ENTRY_CopyBytes2Mod },						// DEC/1,INC/0
	{ 0xFF, ENTRY_CopyFF },								// CALL/2
	{ 0, ENTRY_End },
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable0F[257] =
{
	{ 0x00, ENTRY_CopyBytes2Mod },						// LLDT/2, etc. 
	{ 0x01, ENTRY_CopyBytes2Mod },						// INVLPG/7, etc. 
	{ 0x02, ENTRY_CopyBytes2Mod },						// LAR/r 
	{ 0x03, ENTRY_CopyBytes2Mod },						// LSL/r 
	{ 0x04, ENTRY_Invalid },							// _04 
	{ 0x05, ENTRY_Invalid },							// _05 
	{ 0x06, ENTRY_CopyBytes2 },							// CLTS 
	{ 0x07, ENTRY_Invalid },							// _07 
	{ 0x08, ENTRY_CopyBytes2 },							// INVD 
	{ 0x09, ENTRY_CopyBytes2 },							// WBINVD 
	{ 0x0A, ENTRY_Invalid },							// _0A 
	{ 0x0B, ENTRY_CopyBytes2 },							// UD2 
	{ 0x0C, ENTRY_Invalid },							// _0C 
	{ 0x0D, ENTRY_Invalid },							// _0D 
	{ 0x0E, ENTRY_Invalid },							// _0E 
	{ 0x0F, ENTRY_Invalid },							// _0F 
	{ 0x10, ENTRY_Invalid },							// _10 
	{ 0x11, ENTRY_Invalid },							// _11 
	{ 0x12, ENTRY_Invalid },							// _12 
	{ 0x13, ENTRY_Invalid },							// _13 
	{ 0x14, ENTRY_Invalid },							// _14 
	{ 0x15, ENTRY_Invalid },							// _15 
	{ 0x16, ENTRY_Invalid },							// _16 
	{ 0x17, ENTRY_Invalid },							// _17 
	{ 0x18, ENTRY_Invalid },							// _18 
	{ 0x19, ENTRY_Invalid },							// _19 
	{ 0x1A, ENTRY_Invalid },							// _1A 
	{ 0x1B, ENTRY_Invalid },							// _1B 
	{ 0x1C, ENTRY_Invalid },							// _1C 
	{ 0x1D, ENTRY_Invalid },							// _1D 
	{ 0x1E, ENTRY_Invalid },							// _1E 
	{ 0x1F, ENTRY_Invalid },							// _1F 
	{ 0x20, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x21, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x22, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x23, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x24, ENTRY_Invalid },							// _24 
	{ 0x25, ENTRY_Invalid },							// _25 
	{ 0x26, ENTRY_Invalid },							// _26 
	{ 0x27, ENTRY_Invalid },							// _27 
	{ 0x28, ENTRY_Invalid },							// _28 
	{ 0x29, ENTRY_Invalid },							// _29 
	{ 0x2A, ENTRY_Invalid },							// _2A 
	{ 0x2B, ENTRY_Invalid },							// _2B 
	{ 0x2C, ENTRY_Invalid },							// _2C 
	{ 0x2D, ENTRY_Invalid },							// _2D 
	{ 0x2E, ENTRY_Invalid },							// _2E 
	{ 0x2F, ENTRY_Invalid },							// _2F 
	{ 0x30, ENTRY_CopyBytes2 },							// WRMSR 
	{ 0x31, ENTRY_CopyBytes2 },							// RDTSC 
	{ 0x32, ENTRY_CopyBytes2 },							// RDMSR 
	{ 0x33, ENTRY_CopyBytes2 },							// RDPMC 
	{ 0x34, ENTRY_CopyBytes2 },							// SYSENTER 
	{ 0x35, ENTRY_CopyBytes2 },							// SYSEXIT 
	{ 0x36, ENTRY_Invalid },							// _36 
	{ 0x37, ENTRY_Invalid },							// _37 
	{ 0x38, ENTRY_Invalid },							// _38 
	{ 0x39, ENTRY_Invalid },							// _39 
	{ 0x3A, ENTRY_Invalid },							// _3A 
	{ 0x3B, ENTRY_Invalid },							// _3B 
	{ 0x3C, ENTRY_Invalid },							// _3C 
	{ 0x3D, ENTRY_Invalid },							// _3D 
	{ 0x3E, ENTRY_Invalid },							// _3E 
	{ 0x3F, ENTRY_Invalid },							// _3F 
	{ 0x40, ENTRY_CopyBytes2Mod },						// CMOVO (0F 40) 
	{ 0x41, ENTRY_CopyBytes2Mod },						// CMOVNO (0F 41) 
	{ 0x42, ENTRY_CopyBytes2Mod },						// CMOVB & CMOVNE (0F 42) 
	{ 0x43, ENTRY_CopyBytes2Mod },						// CMOVAE & CMOVNB (0F 43) 
	{ 0x44, ENTRY_CopyBytes2Mod },						// CMOVE & CMOVZ (0F 44) 
	{ 0x45, ENTRY_CopyBytes2Mod },						// CMOVNE & CMOVNZ (0F 45) 
	{ 0x46, ENTRY_CopyBytes2Mod },						// CMOVBE & CMOVNA (0F 46) 
	{ 0x47, ENTRY_CopyBytes2Mod },						// CMOVA & CMOVNBE (0F 47) 
	{ 0x48, ENTRY_CopyBytes2Mod },						// CMOVS (0F 48) 
	{ 0x49, ENTRY_CopyBytes2Mod },						// CMOVNS (0F 49) 
	{ 0x4A, ENTRY_CopyBytes2Mod },						// CMOVP & CMOVPE (0F 4A) 
	{ 0x4B, ENTRY_CopyBytes2Mod },						// CMOVNP & CMOVPO (0F 4B) 
	{ 0x4C, ENTRY_CopyBytes2Mod },						// CMOVL & CMOVNGE (0F 4C) 
	{ 0x4D, ENTRY_CopyBytes2Mod },						// CMOVGE & CMOVNL (0F 4D) 
	{ 0x4E, ENTRY_CopyBytes2Mod },						// CMOVLE & CMOVNG (0F 4E) 
	{ 0x4F, ENTRY_CopyBytes2Mod },						// CMOVG & CMOVNLE (0F 4F) 
	{ 0x50, ENTRY_Invalid },							// _50 
	{ 0x51, ENTRY_Invalid },							// _51 
	{ 0x52, ENTRY_Invalid },							// _52 
	{ 0x53, ENTRY_Invalid },							// _53 
	{ 0x54, ENTRY_Invalid },							// _54 
	{ 0x55, ENTRY_Invalid },							// _55 
	{ 0x56, ENTRY_Invalid },							// _56 
	{ 0x57, ENTRY_Invalid },							// _57 
	{ 0x58, ENTRY_Invalid },							// _58 
	{ 0x59, ENTRY_Invalid },							// _59 
	{ 0x5A, ENTRY_Invalid },							// _5A 
	{ 0x5B, ENTRY_Invalid },							// _5B 
	{ 0x5C, ENTRY_Invalid },							// _5C 
	{ 0x5D, ENTRY_Invalid },							// _5D 
	{ 0x5E, ENTRY_Invalid },							// _5E 
	{ 0x5F, ENTRY_Invalid },							// _5F 
	{ 0x60, ENTRY_CopyBytes2Mod },						// PUNPCKLBW/r 
	{ 0x61, ENTRY_Invalid },							// _61 
	{ 0x62, ENTRY_CopyBytes2Mod },						// PUNPCKLWD/r 
	{ 0x63, ENTRY_CopyBytes2Mod },						// PACKSSWB/r 
	{ 0x64, ENTRY_CopyBytes2Mod },						// PCMPGTB/r 
	{ 0x65, ENTRY_CopyBytes2Mod },						// PCMPGTW/r 
	{ 0x66, ENTRY_CopyBytes2Mod },						// PCMPGTD/r 
	{ 0x67, ENTRY_CopyBytes2Mod },						// PACKUSWB/r 
	{ 0x68, ENTRY_CopyBytes2Mod },						// PUNPCKHBW/r 
	{ 0x69, ENTRY_CopyBytes2Mod },						// PUNPCKHWD/r 
	{ 0x6A, ENTRY_CopyBytes2Mod },						// PUNPCKHDQ/r 
	{ 0x6B, ENTRY_CopyBytes2Mod },						// PACKSSDW/r 
	{ 0x6C, ENTRY_Invalid },							// _6C 
	{ 0x6D, ENTRY_Invalid },							// _6D 
	{ 0x6E, ENTRY_CopyBytes2Mod },						// MOVD/r 
	{ 0x6F, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x70, ENTRY_Invalid },							// _70 
	{ 0x71, ENTRY_CopyBytes2Mod1 },						// PSLLW/6 ib,PSRAW/4 ib,PSRLW/2 ib 
	{ 0x72, ENTRY_CopyBytes2Mod1 },						// PSLLD/6 ib,PSRAD/4 ib,PSRLD/2 ib 
	{ 0x73, ENTRY_CopyBytes2Mod1 },						// PSLLQ/6 ib,PSRLQ/2 ib 
	{ 0x74, ENTRY_CopyBytes2Mod },						// PCMPEQB/r 
	{ 0x75, ENTRY_CopyBytes2Mod },						// PCMPEQW/r 
	{ 0x76, ENTRY_CopyBytes2Mod },						// PCMPEQD/r 
	{ 0x77, ENTRY_CopyBytes2 },							// EMMS 
	{ 0x78, ENTRY_Invalid },							// _78 
	{ 0x79, ENTRY_Invalid },							// _79 
	{ 0x7A, ENTRY_Invalid },							// _7A 
	{ 0x7B, ENTRY_Invalid },							// _7B 
	{ 0x7C, ENTRY_Invalid },							// _7C 
	{ 0x7D, ENTRY_Invalid },							// _7D 
	{ 0x7E, ENTRY_CopyBytes2Mod },						// MOVD/r 
	{ 0x7F, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x80, ENTRY_CopyBytes3Or5Target },				// JO 
	{ 0x81, ENTRY_CopyBytes3Or5Target },				// JNO 
	{ 0x82, ENTRY_CopyBytes3Or5Target },				// JB,JC,JNAE 
	{ 0x83, ENTRY_CopyBytes3Or5Target },				// JAE,JNB,JNC 
	{ 0x84, ENTRY_CopyBytes3Or5Target },				// JE,JZ,JZ 
	{ 0x85, ENTRY_CopyBytes3Or5Target },				// JNE,JNZ 
	{ 0x86, ENTRY_CopyBytes3Or5Target },				// JBE,JNA 
	{ 0x87, ENTRY_CopyBytes3Or5Target },				// JA,JNBE 
	{ 0x88, ENTRY_CopyBytes3Or5Target },				// JS 
	{ 0x89, ENTRY_CopyBytes3Or5Target },				// JNS 
	{ 0x8A, ENTRY_CopyBytes3Or5Target },				// JP,JPE 
	{ 0x8B, ENTRY_CopyBytes3Or5Target },				// JNP,JPO 
	{ 0x8C, ENTRY_CopyBytes3Or5Target },				// JL,NGE 
	{ 0x8D, ENTRY_CopyBytes3Or5Target },				// JGE,JNL 
	{ 0x8E, ENTRY_CopyBytes3Or5Target },				// JLE,JNG 
	{ 0x8F, ENTRY_CopyBytes3Or5Target },				// JG,JNLE 
	{ 0x90, ENTRY_CopyBytes2Mod },						// CMOVO (0F 40) 
	{ 0x91, ENTRY_CopyBytes2Mod },						// CMOVNO (0F 41) 
	{ 0x92, ENTRY_CopyBytes2Mod },						// CMOVB & CMOVC & CMOVNAE (0F 42) 
	{ 0x93, ENTRY_CopyBytes2Mod },						// CMOVAE & CMOVNB & CMOVNC (0F 43) 
	{ 0x94, ENTRY_CopyBytes2Mod },						// CMOVE & CMOVZ (0F 44) 
	{ 0x95, ENTRY_CopyBytes2Mod },						// CMOVNE & CMOVNZ (0F 45) 
	{ 0x96, ENTRY_CopyBytes2Mod },						// CMOVBE & CMOVNA (0F 46) 
	{ 0x97, ENTRY_CopyBytes2Mod },						// CMOVA & CMOVNBE (0F 47) 
	{ 0x98, ENTRY_CopyBytes2Mod },						// CMOVS (0F 48) 
	{ 0x99, ENTRY_CopyBytes2Mod },						// CMOVNS (0F 49) 
	{ 0x9A, ENTRY_CopyBytes2Mod },						// CMOVP & CMOVPE (0F 4A) 
	{ 0x9B, ENTRY_CopyBytes2Mod },						// CMOVNP & CMOVPO (0F 4B) 
	{ 0x9C, ENTRY_CopyBytes2Mod },						// CMOVL & CMOVNGE (0F 4C) 
	{ 0x9D, ENTRY_CopyBytes2Mod },						// CMOVGE & CMOVNL (0F 4D) 
	{ 0x9E, ENTRY_CopyBytes2Mod },						// CMOVLE & CMOVNG (0F 4E) 
	{ 0x9F, ENTRY_CopyBytes2Mod },						// CMOVG & CMOVNLE (0F 4F) 
	{ 0xA0, ENTRY_CopyBytes2 },							// PUSH 
	{ 0xA1, ENTRY_CopyBytes2 },							// POP 
	{ 0xA2, ENTRY_CopyBytes2 },							// CPUID 
	{ 0xA3, ENTRY_CopyBytes2Mod },						// BT  (0F A3)   
	{ 0xA4, ENTRY_CopyBytes2Mod1 },						// SHLD  
	{ 0xA5, ENTRY_CopyBytes2Mod },						// SHLD  
	{ 0xA6, ENTRY_Invalid },							// _A6 
	{ 0xA7, ENTRY_Invalid },							// _A7 
	{ 0xA8, ENTRY_CopyBytes2 },							// PUSH 
	{ 0xA9, ENTRY_CopyBytes2 },							// POP 
	{ 0xAA, ENTRY_CopyBytes2 },							// RSM 
	{ 0xAB, ENTRY_CopyBytes2Mod },						// BTS (0F AB) 
	{ 0xAC, ENTRY_CopyBytes2Mod1 },						// SHRD  
	{ 0xAD, ENTRY_CopyBytes2Mod },						// SHRD  
	{ 0xAE, ENTRY_CopyBytes2Mod },						// FXRSTOR/1,FXSAVE/0 
	{ 0xAF, ENTRY_CopyBytes2Mod },						// IMUL (0F AF) 
	{ 0xB0, ENTRY_CopyBytes2Mod },						// CMPXCHG (0F B0) 
	{ 0xB1, ENTRY_CopyBytes2Mod },						// CMPXCHG (0F B1) 
	{ 0xB2, ENTRY_CopyBytes2Mod },						// LSS/r 
	{ 0xB3, ENTRY_CopyBytes2Mod },						// BTR (0F B3) 
	{ 0xB4, ENTRY_CopyBytes2Mod },						// LFS/r 
	{ 0xB5, ENTRY_CopyBytes2Mod },						// LGS/r 
	{ 0xB6, ENTRY_CopyBytes2Mod },						// MOVZX/r 
	{ 0xB7, ENTRY_CopyBytes2Mod },						// MOVZX/r 
	{ 0xB8, ENTRY_Invalid },							// _B8 
	{ 0xB9, ENTRY_Invalid },							// _B9 
	{ 0xBA, ENTRY_CopyBytes2Mod1 },						// BT & BTC & BTR & BTS (0F BA) 
	{ 0xBB, ENTRY_CopyBytes2Mod },						// BTC (0F BB) 
	{ 0xBC, ENTRY_CopyBytes2Mod },						// BSF (0F BC) 
	{ 0xBD, ENTRY_CopyBytes2Mod },						// BSR (0F BD) 
	{ 0xBE, ENTRY_CopyBytes2Mod },						// MOVSX/r 
	{ 0xBF, ENTRY_CopyBytes2Mod },						// MOVSX/r 
	{ 0xC0, ENTRY_CopyBytes2Mod },						// XADD/r 
	{ 0xC1, ENTRY_CopyBytes2Mod },						// XADD/r 
	{ 0xC2, ENTRY_Invalid },							// _C2 
	{ 0xC3, ENTRY_Invalid },							// _C3 
	{ 0xC4, ENTRY_Invalid },							// _C4 
	{ 0xC5, ENTRY_Invalid },							// _C5 
	{ 0xC6, ENTRY_Invalid },							// _C6 
	{ 0xC7, ENTRY_CopyBytes2Mod },						// CMPXCHG8B (0F C7) 
	{ 0xC8, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xC9, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCA, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCB, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCC, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCD, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCE, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCF, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xD0, ENTRY_Invalid },							// _D0 
	{ 0xD1, ENTRY_CopyBytes2Mod },						// PSRLW/r 
	{ 0xD2, ENTRY_CopyBytes2Mod },						// PSRLD/r 
	{ 0xD3, ENTRY_CopyBytes2Mod },						// PSRLQ/r 
	{ 0xD4, ENTRY_Invalid },							// _D4 
	{ 0xD5, ENTRY_CopyBytes2Mod },						// PMULLW/r 
	{ 0xD6, ENTRY_Invalid },							// _D6 
	{ 0xD7, ENTRY_Invalid },							// _D7 
	{ 0xD8, ENTRY_CopyBytes2Mod },						// PSUBUSB/r 
	{ 0xD9, ENTRY_CopyBytes2Mod },						// PSUBUSW/r 
	{ 0xDA, ENTRY_Invalid },							// _DA 
	{ 0xDB, ENTRY_CopyBytes2Mod },						// PAND/r 
	{ 0xDC, ENTRY_CopyBytes2Mod },						// PADDUSB/r 
	{ 0xDD, ENTRY_CopyBytes2Mod },						// PADDUSW/r 
	{ 0xDE, ENTRY_Invalid },							// _DE 
	{ 0xDF, ENTRY_CopyBytes2Mod },						// PANDN/r 
	{ 0xE0, ENTRY_Invalid },							// _E0 
	{ 0xE1, ENTRY_CopyBytes2Mod },						// PSRAW/r 
	{ 0xE2, ENTRY_CopyBytes2Mod },						// PSRAD/r 
	{ 0xE3, ENTRY_Invalid },							// _E3 
	{ 0xE4, ENTRY_Invalid },							// _E4 
	{ 0xE5, ENTRY_CopyBytes2Mod },						// PMULHW/r 
	{ 0xE6, ENTRY_Invalid },							// _E6 
	{ 0xE7, ENTRY_Invalid },							// _E7 
	{ 0xE8, ENTRY_CopyBytes2Mod },						// PSUBB/r 
	{ 0xE9, ENTRY_CopyBytes2Mod },						// PSUBW/r 
	{ 0xEA, ENTRY_Invalid },							// _EA 
	{ 0xEB, ENTRY_CopyBytes2Mod },						// POR/r 
	{ 0xEC, ENTRY_CopyBytes2Mod },						// PADDSB/r 
	{ 0xED, ENTRY_CopyBytes2Mod },						// PADDSW/r 
	{ 0xEE, ENTRY_Invalid },							// _EE 
	{ 0xEF, ENTRY_CopyBytes2Mod },						// PXOR/r 
	{ 0xF0, ENTRY_Invalid },							// _F0 
	{ 0xF1, ENTRY_CopyBytes2Mod },						// PSLLW/r 
	{ 0xF2, ENTRY_CopyBytes2Mod },						// PSLLD/r 
	{ 0xF3, ENTRY_CopyBytes2Mod },						// PSLLQ/r 
	{ 0xF4, ENTRY_Invalid },							// _F4 
	{ 0xF5, ENTRY_CopyBytes2Mod },						// PMADDWD/r 
	{ 0xF6, ENTRY_Invalid },							// _F6 
	{ 0xF7, ENTRY_Invalid },							// _F7 
	{ 0xF8, ENTRY_CopyBytes2Mod },						// PSUBB/r 
	{ 0xF9, ENTRY_CopyBytes2Mod },						// PSUBW/r 
	{ 0xFA, ENTRY_CopyBytes2Mod },						// PSUBD/r 
	{ 0xFB, ENTRY_Invalid },							// _FB 
	{ 0xFC, ENTRY_CopyBytes2Mod },						// PADDB/r 
	{ 0xFD, ENTRY_CopyBytes2Mod },						// PADDW/r 
	{ 0xFE, ENTRY_CopyBytes2Mod },						// PADDD/r 
	{ 0xFF, ENTRY_Invalid },							// _FF 
	{ 0, ENTRY_End },
};

BOOL CDetourDis::SanityCheckSystem()
{
	for (ULONG n = 0; n < 256; n++) {
		REFCOPYENTRY pEntry = &s_rceCopyTable[n];

		if (n != pEntry->nOpcode) {
			ASSERT(n == pEntry->nOpcode);
			return FALSE;
		}
	}
	if (s_rceCopyTable[256].pfCopy != NULL) {
		ASSERT(!"Missing end marker.");
		return FALSE;
	}
	
	for (n = 0; n < 256; n++) {
		REFCOPYENTRY pEntry = &s_rceCopyTable0F[n];

		if (n != pEntry->nOpcode) {
			ASSERT(n == pEntry->nOpcode);
			return FALSE;
		}
	}
	if (s_rceCopyTable0F[256].pfCopy != NULL) {
		ASSERT(!"Missing end marker.");
		return FALSE;
	}
	
	return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\detours.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		detours.cpp
//	Author:		Galen Hunt
//
//	Detours for binary functions.  Version 1.2. (Build 35)
//
//	Copyright 1995-1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

//#include <ole2.h>
#include "stdafx.h"

#include <imagehlp.h>

//////////////////////////////////////////////////////////////////////////////
//
enum {
	OP_JMP_DS		= 0x25,
	OP_JA			= 0x77,
	OP_NOP 			= 0x90,
	OP_CALL			= 0xe8,
	OP_JMP 			= 0xe9,
	OP_PREFIX 		= 0xff,
	OP_MOV_EAX		= 0xa1,
	OP_SET_EAX		= 0xb8,
	OP_JMP_EAX		= 0xe0,
	OP_RET_POP		= 0xc2,
	OP_RET			= 0xc3,
	OP_BRK			= 0xcc,

	SIZE_OF_JMP		= 5,
	SIZE_OF_NOP		= 1,
	SIZE_OF_BRK		= 1,
	SIZE_OF_TRP_OPS	= SIZE_OF_JMP /* + SIZE_OF_BRK */,
};

class CEnableWriteOnCodePage
{
public:
	CEnableWriteOnCodePage(PBYTE pbCode, LONG cbCode = DETOUR_TRAMPOLINE_SIZE)
	{
		m_pbCode = pbCode;
		m_cbCode = cbCode;
		m_dwOldPerm = 0;
		m_hProcess = GetCurrentProcess();

		if (m_pbCode && m_cbCode) {
			if (!FlushInstructionCache(m_hProcess, pbCode, cbCode)) {
				return;
			}
			if (!VirtualProtect(pbCode,
								cbCode,
								PAGE_EXECUTE_READWRITE,
								&m_dwOldPerm)) {
				return;
			}
		}
	}

	~CEnableWriteOnCodePage()
	{
		if (m_dwOldPerm && m_pbCode && m_cbCode) {
			DWORD dwTemp = 0;
			if (!FlushInstructionCache(m_hProcess, m_pbCode, m_cbCode)) {
				return;
			}
			if (!VirtualProtect(m_pbCode, m_cbCode, m_dwOldPerm, &dwTemp)) {
				return;
			}
		}
	}

	BOOL SetPermission(DWORD dwPerms)
	{
		if (m_dwOldPerm && m_pbCode && m_cbCode) {
			m_dwOldPerm = dwPerms;
			return TRUE;
		}
		return FALSE;
	}

	BOOL IsValid(VOID)
	{
		return m_pbCode && m_cbCode && m_dwOldPerm;
	}

private:
	HANDLE	m_hProcess;
	PBYTE 	m_pbCode;
	LONG	m_cbCode;
	DWORD	m_dwOldPerm;
};

//////////////////////////////////////////////////////////////////////////////
//
static BOOL detour_insert_jump(PBYTE pbCode, PBYTE pbDest, LONG cbCode)
{
	if (cbCode < SIZE_OF_JMP)
		return FALSE;
	
	*pbCode++ = OP_JMP;
	LONG offset = (LONG)pbDest - (LONG)(pbCode + 4);
	*((PDWORD&)pbCode)++ = offset;
	for (cbCode -= SIZE_OF_JMP; cbCode > 0; cbCode--)
		*pbCode++ = OP_BRK;
	return TRUE;
}

static BOOL detour_insert_detour(PBYTE pbTarget,
								 PBYTE pbTrampoline,
								 PBYTE pbDetour)
{
	if (pbTarget[0] == OP_NOP)
		return FALSE;
	if (pbTarget[0] == OP_JMP)							// Already has a detour.
		return FALSE;
	
	PBYTE pbCont = pbTarget;
	for (LONG cbTarget = 0; cbTarget < SIZE_OF_TRP_OPS;) {
		BYTE bOp = *pbCont;
		pbCont = DetourCopyInstruction(NULL, pbCont, NULL);
		cbTarget = pbCont - pbTarget;

		if (bOp == OP_JMP ||
			bOp == OP_JMP_DS ||
			bOp == OP_JMP_EAX ||
			bOp == OP_RET_POP ||
			bOp == OP_RET) {

			break;
		}
	}
	if (cbTarget  < SIZE_OF_TRP_OPS) {
		// Too few instructions.
		return FALSE;
	}
	if (cbTarget > (DETOUR_TRAMPOLINE_SIZE - SIZE_OF_JMP - SIZE_OF_NOP - 1)) {
		// Too many instructions.
		return FALSE;
	}

	//////////////////////////////////////////////////////// Finalize Reroute.
	//
	CEnableWriteOnCodePage ewTrampoline(pbTrampoline, DETOUR_TRAMPOLINE_SIZE);
	CEnableWriteOnCodePage ewTarget(pbTarget, cbTarget);
	if (!ewTrampoline.SetPermission(PAGE_EXECUTE_READWRITE))
		return FALSE;
	if (!ewTarget.IsValid())
		return FALSE;
	
	pbTrampoline[0] = OP_NOP;

	PBYTE pbSrc = pbTarget;
	PBYTE pbDst = pbTrampoline + SIZE_OF_NOP;
	for (LONG cbCopy = 0; cbCopy < cbTarget;) {
		pbSrc = DetourCopyInstruction(pbDst, pbSrc, NULL);
		cbCopy = pbSrc - pbTarget;
		pbDst = pbTrampoline + SIZE_OF_NOP + cbCopy;
	}
	if (cbCopy != cbTarget)								// Count came out different!
		return FALSE;

	pbCont = pbTarget + cbTarget;
	if (!detour_insert_jump(pbTrampoline + 1 + cbTarget, pbCont, SIZE_OF_JMP))
		return FALSE;

	pbTrampoline[DETOUR_TRAMPOLINE_SIZE-1] = (BYTE)cbTarget;

	if (!detour_insert_jump(pbTarget, pbDetour, cbTarget))
		return FALSE;
	
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI DetourRemoveWithTrampoline(PBYTE pbTrampoline,
									   PBYTE pbDetour)
{
	pbTrampoline = DetourFindFinalCode(pbTrampoline);
	pbDetour = DetourFindFinalCode(pbDetour);

	////////////////////////////////////// Verify that Trampoline is in place.
	//
	if (pbTrampoline[0] != OP_NOP) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}

	LONG cbTarget = pbTrampoline[DETOUR_TRAMPOLINE_SIZE-1];
	if (cbTarget == 0 || cbTarget >= DETOUR_TRAMPOLINE_SIZE - 1) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}

	if (pbTrampoline[cbTarget + SIZE_OF_NOP] != OP_JMP) {
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}
		
	LONG offset = *((PDWORD)&pbTrampoline[cbTarget + SIZE_OF_NOP + 1]);
	PBYTE pbTarget = pbTrampoline +
		SIZE_OF_NOP + cbTarget + SIZE_OF_JMP + offset - cbTarget;

	if (pbTarget[0] != OP_JMP) {						// Missing detour.
		SetLastError(ERROR_INVALID_BLOCK);
		return FALSE;
	}

	offset = *((PDWORD)&pbTarget[1]);
	PBYTE pbTargetDetour = pbTarget + SIZE_OF_JMP + offset;
	if (pbTargetDetour != pbDetour) {
		SetLastError(ERROR_INVALID_ACCESS);
		return FALSE;
	}

	/////////////////////////////////////////////////////// Remove the Detour.
	CEnableWriteOnCodePage ewTarget(pbTarget, cbTarget);
	
	PBYTE pbSrc = pbTrampoline + SIZE_OF_NOP;
	PBYTE pbDst = pbTarget;
	for (LONG cbCopy = 0; cbCopy < cbTarget; pbDst = pbTarget + cbCopy) {
		pbSrc = DetourCopyInstruction(pbDst, pbSrc, NULL);
		cbCopy = pbSrc - (pbTrampoline + SIZE_OF_NOP);
	}
	if (cbCopy != cbTarget) {							// Count came out different!
		SetLastError(ERROR_INVALID_DATA);
		return FALSE;
	}
	return TRUE;
}

PBYTE WINAPI DetourFunction(PBYTE pbTarget,
							PBYTE pbDetour)
{
	PBYTE pbTrampoline = new BYTE [DETOUR_TRAMPOLINE_SIZE];
	if (pbTrampoline == NULL)
		return NULL;

	pbTarget = DetourFindFinalCode(pbTarget);
	pbDetour = DetourFindFinalCode(pbDetour);

	if (detour_insert_detour(pbTarget, pbTrampoline, pbDetour))
		return pbTrampoline;

	delete[] pbTrampoline;
	return NULL;
}

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
											  PBYTE pbTarget,
											  PBYTE pbDetour)
{
	return DetourFunctionWithEmptyTrampolineEx(pbTrampoline, pbTarget, pbDetour,
											   NULL, NULL, NULL);
}

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
												PBYTE pbTarget,
												PBYTE pbDetour,
												PBYTE *ppbRealTrampoline,
												PBYTE *ppbRealTarget,
												PBYTE *ppbRealDetour)
{
	pbTrampoline = DetourFindFinalCode(pbTrampoline);
	pbTarget = DetourFindFinalCode(pbTarget);
	pbDetour = DetourFindFinalCode(pbDetour);
	
	if (ppbRealTrampoline)
		*ppbRealTrampoline = pbTrampoline;
	if (ppbRealTarget)
		*ppbRealTarget = pbTarget;
	if (ppbRealDetour)
		*ppbRealDetour = pbDetour;
	
	if (pbTrampoline == NULL || pbDetour == NULL || pbTarget == NULL)
		return FALSE;
	
	if (pbTrampoline[0] == OP_NOP && pbTrampoline[1] != OP_NOP) {
		// Already Patched.
		return 2;
	}
	if (pbTrampoline[0] != OP_NOP ||
		pbTrampoline[1] != OP_NOP) {
		
		return FALSE;
	}
	
	return detour_insert_detour(pbTarget, pbTrampoline, pbDetour);
}

BOOL WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
										 PBYTE pbDetour)
{
	return DetourFunctionWithTrampolineEx(pbTrampoline, pbDetour, NULL, NULL);
}

BOOL WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
										   PBYTE pbDetour,
										   PBYTE *ppbRealTrampoline,
										   PBYTE *ppbRealTarget)
{
	PBYTE pbTarget = NULL;

	pbTrampoline = DetourFindFinalCode(pbTrampoline);
	pbDetour = DetourFindFinalCode(pbDetour);
	
	if (ppbRealTrampoline)
		*ppbRealTrampoline = pbTrampoline;
	if (ppbRealTarget)
		*ppbRealTarget = NULL;
	
	if (pbTrampoline == NULL || pbDetour == NULL)
		return FALSE;

	if (pbTrampoline[0] == OP_NOP && pbTrampoline[1] != OP_NOP) {
		// Already Patched.
		return 2;
	}
	if (pbTrampoline[0] != OP_NOP 	||
		pbTrampoline[1] != OP_NOP 	||
		pbTrampoline[2] != OP_CALL 	||
		pbTrampoline[7] != OP_PREFIX 	||
		pbTrampoline[8] != OP_JMP_EAX) {
		
		return FALSE;
	}

	PVOID (__fastcall * pfAddr)(VOID);

	pfAddr = (PVOID (__fastcall *)(VOID))(pbTrampoline +
										  SIZE_OF_NOP + SIZE_OF_NOP + SIZE_OF_JMP +
										  *(LONG *)&pbTrampoline[3]);

	pbTarget = DetourFindFinalCode((PBYTE)(*pfAddr)());
	if (ppbRealTarget)
		*ppbRealTarget = pbTarget;

	return detour_insert_detour(pbTarget, pbTrampoline, pbDetour);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
//
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
									   IN LPSTR UserSearchPath,
									   IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef BOOL (NTAPI *PF_SymLoadModule)(IN HANDLE hProcess,
									   IN HANDLE hFile,
									   IN PSTR ImageName,
									   IN PSTR ModuleName,
									   IN DWORD BaseOfDll,
									   IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo)(IN HANDLE hProcess,
										  IN DWORD dwAddr,
										  OUT PIMAGEHLP_MODULE ModuleInfo);
typedef BOOL (NTAPI *PF_SymGetSymFromName)(IN HANDLE hProcess,
										   IN LPSTR Name,
										   OUT PIMAGEHLP_SYMBOL Symbol);
typedef BOOL (NTAPI *PF_BindImage)(IN LPSTR pszImageName,
								   IN LPSTR pszDllPath,
								   IN LPSTR pszSymbolPath);

static HANDLE 					s_hProcess = NULL;
static HINSTANCE				s_hImageHlp = NULL;
static PF_ImagehlpApiVersionEx	s_pfImagehlpApiVersionEx = NULL;
static PF_SymInitialize			s_pfSymInitialize = NULL;
static PF_SymSetOptions			s_pfSymSetOptions = NULL;
static PF_SymGetOptions			s_pfSymGetOptions = NULL;
static PF_SymLoadModule			s_pfSymLoadModule = NULL;
static PF_SymGetModuleInfo		s_pfSymGetModuleInfo = NULL;
static PF_SymGetSymFromName		s_pfSymGetSymFromName = NULL;
static PF_BindImage				s_pfBindImage = NULL;

static BOOL LoadImageHlp(VOID)
{
	if (s_hImageHlp)
		return TRUE;
	
	if (s_hProcess == NULL) {
		s_hProcess = GetCurrentProcess();

		s_hImageHlp = LoadLibraryA("imagehlp.dll");
		if (s_hImageHlp == NULL)
			return FALSE;

		s_pfImagehlpApiVersionEx
			= (PF_ImagehlpApiVersionEx)GetProcAddress(s_hImageHlp,
													  "ImagehlpApiVersionEx");
		s_pfSymInitialize
			= (PF_SymInitialize)GetProcAddress(s_hImageHlp, "SymInitialize");
		s_pfSymSetOptions
			= (PF_SymSetOptions)GetProcAddress(s_hImageHlp, "SymSetOptions");
		s_pfSymGetOptions
			= (PF_SymGetOptions)GetProcAddress(s_hImageHlp, "SymGetOptions");
		s_pfSymLoadModule
			= (PF_SymLoadModule)GetProcAddress(s_hImageHlp, "SymLoadModule");
		s_pfSymGetModuleInfo
			= (PF_SymGetModuleInfo)GetProcAddress(s_hImageHlp, "SymGetModuleInfo");
		s_pfSymGetSymFromName
			= (PF_SymGetSymFromName)GetProcAddress(s_hImageHlp, "SymGetSymFromName");
		s_pfBindImage
			= (PF_BindImage)GetProcAddress(s_hImageHlp, "BindImage");

		API_VERSION av;
		ZeroMemory(&av, sizeof(av));
		av.MajorVersion = API_VERSION_NUMBER;
			
		if (s_pfImagehlpApiVersionEx) {
			(*s_pfImagehlpApiVersionEx)(&av);
		}

		if (s_pfImagehlpApiVersionEx == NULL || av.MajorVersion < API_VERSION_NUMBER) {
			FreeLibrary(s_hImageHlp);
			s_hImageHlp = NULL;
			return FALSE;
		}
		
		if (s_pfSymInitialize) {
			(*s_pfSymInitialize)(s_hProcess, NULL, FALSE);
		}
		
		if (s_pfSymGetOptions && s_pfSymSetOptions) {
			DWORD dw = (*s_pfSymGetOptions)();
			dw &= (SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);
			(*s_pfSymSetOptions)(dw);
		}
		
		return TRUE;
	}
	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
PBYTE WINAPI DetourFindFinalCode(PBYTE pbCode)
{
	if (pbCode == NULL)
		return NULL;
	
	//BUGBUG PBYTE pbTemp = pbCode;
	if (pbCode[0] == OP_JMP) {							// Reference passed.
		pbCode = pbCode + SIZE_OF_JMP + *(LONG *)&pbCode[1];
	}
	else if (pbCode[0] == OP_PREFIX && pbCode[1] == OP_JMP_DS) {
		pbCode = *(PBYTE *)&pbCode[2];
		pbCode = *(PBYTE *)pbCode;
	}
	return pbCode;
}

PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction)
{
	/////////////////////////////////////////////// First, Try GetProcAddress.
	//
	HINSTANCE hInst = LoadLibraryA(pszModule);
	if (hInst == NULL) {
		return NULL;
	}

	PBYTE pbCode = (PBYTE)GetProcAddress(hInst, pszFunction);
	if (pbCode) {
		return pbCode;
	}

	////////////////////////////////////////////////////// Then Try ImageHelp.
	//
	if (!LoadImageHlp() || 
		s_pfSymLoadModule == NULL ||
		s_pfSymGetModuleInfo == NULL ||
		s_pfSymGetSymFromName == NULL) {

		return NULL;
	}
	
	(*s_pfSymLoadModule)(s_hProcess, NULL, pszModule, NULL, (DWORD)hInst, 0);

	IMAGEHLP_MODULE modinfo;
	ZeroMemory(&modinfo, sizeof(modinfo));
	if (!(*s_pfSymGetModuleInfo)(s_hProcess, (DWORD)hInst, &modinfo)) {
		return NULL;
	}

	CHAR szFullName[512];
	strcpy(szFullName, modinfo.ModuleName);
	strcat(szFullName, "!");
	strcat(szFullName, pszFunction);
	
	//BUGBUG DWORD nDisplacement = 0;
	struct CFullSymbol : IMAGEHLP_SYMBOL {
		CHAR szRestOfName[512];
	} symbol;
	ZeroMemory(&symbol, sizeof(symbol));
	symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
	symbol.MaxNameLength = sizeof(symbol.szRestOfName)/sizeof(0);

	if (!(*s_pfSymGetSymFromName)(s_hProcess, szFullName, &symbol)) {
		return NULL;
	}

	return (PBYTE)symbol.Address;
}

//////////////////////////////////////////////////// Instance Image Functions.
//
HINSTANCE WINAPI DetourEnumerateInstances(HINSTANCE hinstLast)
{
	PBYTE pbLast;
	
	if (hinstLast == NULL) {
		pbLast = (PBYTE)0x10000;
	}
	else {
		pbLast = (PBYTE)hinstLast + 0x10000;
	}

	MEMORY_BASIC_INFORMATION mbi;
	ZeroMemory(&mbi, sizeof(mbi));
	
	for (;; pbLast = (PBYTE)mbi.BaseAddress + mbi.RegionSize) {
		if (VirtualQuery((PVOID)pbLast, &mbi, sizeof(mbi)) <= 0) {
			return NULL;
		}

		if (mbi.State != MEM_COMMIT)
			continue;
		
		__try {
			PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pbLast;
			if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
				continue;
			}

			PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
															  pDosHeader->e_lfanew);
			if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
				continue;
			}

			return (HINSTANCE)pDosHeader;
		} __except(EXCEPTION_EXECUTE_HANDLER) {
			/* nothing. */
		}
	}
	return NULL;
}

PBYTE WINAPI DetourFindEntryPointForInstance(HINSTANCE hInst)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hInst;
	if (hInst == NULL) {
		pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
	}
	
	__try {
		if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
			SetLastError(ERROR_BAD_EXE_FORMAT);
			return NULL;
		}
		
		PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
														  pDosHeader->e_lfanew);
		if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
			SetLastError(ERROR_INVALID_EXE_SIGNATURE);
			return NULL;
		}
		if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
			SetLastError(ERROR_EXE_MARKED_INVALID);
			return NULL;
		}
		return (PBYTE)pNtHeader->OptionalHeader.AddressOfEntryPoint +
			pNtHeader->OptionalHeader.ImageBase;
	} __except(EXCEPTION_EXECUTE_HANDLER) {
	}
	SetLastError(ERROR_EXE_MARKED_INVALID);
	
	return NULL;
}

static inline PBYTE RvaAdjust(HINSTANCE hInst, DWORD raddr)
{
	if (raddr != NULL) {
		return (PBYTE)hInst + raddr;
	}
	return NULL;
}

BOOL WINAPI DetourEnumerateExportsForInstance(HINSTANCE hInst,
											  PVOID pContext,
											  PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hInst;
	if (hInst == NULL) {
		pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
	}
	
	__try {
		if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
			SetLastError(ERROR_BAD_EXE_FORMAT);
			return NULL;
		}
		
		PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
														  pDosHeader->e_lfanew);
		if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
			SetLastError(ERROR_INVALID_EXE_SIGNATURE);
			return FALSE;
		}
		if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
			SetLastError(ERROR_EXE_MARKED_INVALID);
			return FALSE;
		}

		PIMAGE_EXPORT_DIRECTORY pExportDir
			= (PIMAGE_EXPORT_DIRECTORY)
			RvaAdjust(hInst,
					  pNtHeader->OptionalHeader
					  .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
		//BUGBUG ULONG cbExportDir = pNtHeader->OptionalHeader
		//BUGBUG 	.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
		
		if (pExportDir == NULL) {
			SetLastError(ERROR_EXE_MARKED_INVALID);
			return FALSE;
		}

		//BUGBUG PCHAR pszName = (PCHAR)RvaAdjust(hInst, pExportDir->Name);
		PDWORD pdwFunctions = (PDWORD)RvaAdjust(hInst, pExportDir->AddressOfFunctions);
		PDWORD pdwNames = (PDWORD)RvaAdjust(hInst, pExportDir->AddressOfNames);
		PWORD pwOrdinals = (PWORD)RvaAdjust(hInst, pExportDir->AddressOfNameOrdinals);

		for (DWORD nFunc = 0; nFunc < pExportDir->NumberOfFunctions; nFunc++) {
			PBYTE pbCode = (PBYTE)RvaAdjust(hInst, pdwFunctions[nFunc]);
			PCHAR pszName = (nFunc < pExportDir->NumberOfNames) ?
				(PCHAR)RvaAdjust(hInst, pdwNames[nFunc]) : NULL;
			ULONG nOrdinal = pExportDir->Base + pwOrdinals[nFunc];

			if (!(*pfExport)(pContext, nOrdinal, pszName, pbCode)) {
				break;
			}
		}
		SetLastError(NO_ERROR);
		return TRUE;
	} __except(EXCEPTION_EXECUTE_HANDLER) {
	}
	SetLastError(ERROR_EXE_MARKED_INVALID);
	return FALSE;
}

PDETOUR_LOADED_BINARY WINAPI DetourBinaryFromInstance(HINSTANCE hInst)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hInst;
	if (hInst == NULL) {
		pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
	}
	
	__try {
		if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
			SetLastError(ERROR_BAD_EXE_FORMAT);
			return NULL;
		}
		
		PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
														  pDosHeader->e_lfanew);
		if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
			SetLastError(ERROR_INVALID_EXE_SIGNATURE);
			return NULL;
		}
		if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
			SetLastError(ERROR_EXE_MARKED_INVALID);
			return NULL;
		}
		
		PIMAGE_SECTION_HEADER pSectionHeaders
			= (PIMAGE_SECTION_HEADER)((PBYTE)pNtHeader
									  + sizeof(pNtHeader->Signature)
									  + sizeof(pNtHeader->FileHeader)
									  + pNtHeader->FileHeader.SizeOfOptionalHeader);

		for (DWORD n = 0; n < pNtHeader->FileHeader.NumberOfSections; n++) {
			if (strcmp((PCHAR)pSectionHeaders[n].Name, ".detour") == 0) {
				if (pSectionHeaders[n].VirtualAddress == 0 ||
					pSectionHeaders[n].SizeOfRawData == 0) {

					break;
				}
					
				PBYTE pbData = (PBYTE)pDosHeader + pSectionHeaders[n].VirtualAddress;
				DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pbData;
				if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
					pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {
					
					break;
				}

				if (pHeader->nDataOffset == 0) {
					pHeader->nDataOffset = pHeader->cbHeaderSize;
				}
				return (PBYTE)pHeader;
			}
		}
	} __except(EXCEPTION_EXECUTE_HANDLER) {
	}
	SetLastError(ERROR_EXE_MARKED_INVALID);
	
	return NULL;
}

DWORD WINAPI DetourGetSizeOfBinary(PDETOUR_LOADED_BINARY pBinary)
{
	__try {
		DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
		if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
			pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {
			
			SetLastError(ERROR_INVALID_HANDLE);
			return 0;
		}
		return pHeader->cbDataSize;
	} __except(EXCEPTION_EXECUTE_HANDLER) {
		SetLastError(ERROR_INVALID_HANDLE);
		return 0;
	}
	SetLastError(ERROR_INVALID_HANDLE);
	return 0;
}

PBYTE WINAPI DetourFindPayloadInBinary(PDETOUR_LOADED_BINARY pBinary,
									   REFGUID rguid,
									   DWORD * pcbData)
{
	PBYTE pbData = NULL;
	//BUGBUG DWORD cbData = 0;
	if (pcbData) {
		*pcbData = 0;
	}

	if (pBinary == NULL) {
		pBinary = DetourBinaryFromInstance(NULL);
	}
	
	__try {
		DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
		if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
			pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {

			SetLastError(ERROR_INVALID_EXE_SIGNATURE);
			return NULL;
		}
		
		PBYTE pbBeg = ((PBYTE)pHeader) + pHeader->nDataOffset;
		PBYTE pbEnd = ((PBYTE)pHeader) + pHeader->cbDataSize;
		
		for (pbData = pbBeg; pbData < pbEnd;) {
			DETOUR_SECTION_RECORD *pSection = (DETOUR_SECTION_RECORD *)pbData;
			
			if (pSection->guid == rguid) {
				if (pcbData) {
					*pcbData = pSection->cbBytes - sizeof(*pSection);
					return (PBYTE)(pSection + 1);
				}
				
			}
			
			pbData = (PBYTE)pSection + pSection->cbBytes;
		}
	} __except(EXCEPTION_EXECUTE_HANDLER) {
		SetLastError(ERROR_INVALID_HANDLE);
		return NULL;
	}
	SetLastError(ERROR_INVALID_HANDLE);
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath)
{
	if (!LoadImageHlp()) {
		SetLastError(ERROR_MOD_NOT_FOUND);
		return FALSE;
	}
	if (s_pfBindImage) {
		return (*s_pfBindImage)(pszFile, pszDll ? pszDll : ".", pszPath ? pszPath : ".");
	}
	SetLastError(ERROR_INVALID_FUNCTION);
	return FALSE;
}

static void UnicodeToOem(PWCHAR pwzIn, PCHAR pszOut, INT cbOut)
{
	cbOut = WideCharToMultiByte(CP_OEMCP, 0,
								pwzIn, lstrlenW(pwzIn),
								pszOut, cbOut-1,
								NULL, NULL);
	pszOut[cbOut] = '\0';
}

BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath)
{
	if (!LoadImageHlp()) {
		SetLastError(ERROR_MOD_NOT_FOUND);
		return FALSE;
	}
	
	CHAR szFile[MAX_PATH];
	CHAR szDll[MAX_PATH];
	CHAR szPath[MAX_PATH];

	UnicodeToOem(pwzFile, szFile, sizeof(szFile));
	UnicodeToOem(pwzDll, szDll, sizeof(szDll));
	UnicodeToOem(pwzPath, szPath, sizeof(szPath));

	if (s_pfBindImage) {
		return (s_pfBindImage)(szFile, szDll, szPath);
	}
	SetLastError(ERROR_INVALID_FUNCTION);
	return FALSE;
}

//  End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		detours.h
//	Author:		Galen Hunt
//
//	Detours for binary functions.  Version 1.2. (Build 35)
//
//	Copyright 1995-1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
enum {
	DETOUR_TRAMPOLINE_SIZE			= 32,
	DETOUR_SECTION_HEADER_SIGNATURE = 0x00727444,	// "Dtr\0"
};

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
	return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
	__asm { call _Detours_GetVA_##target };\
    __asm {	jmp eax };\
    __asm {	ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_WO_TARGET(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
	__asm { xor eax, eax };\
	__asm { mov eax, [eax] };\
    __asm {	ret };\
    __asm {	nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE			((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC		((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
	DWORD		cbHeaderSize;
	DWORD		nSignature;
	DWORD		nDataOffset;
	DWORD		cbDataSize;
	
	DWORD		nOriginalImportVirtualAddress;
	DWORD		nOriginalImportSize;
	DWORD		nOriginalBoundImportVirtualAddress;
	DWORD		nOriginalBoundImportSize;
	
	DWORD		nOriginalIatVirtualAddress;
	DWORD		nOriginalIatSize;
	DWORD		nOriginalSizeOfImage;
	DWORD		nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
	DWORD		cbBytes;
	DWORD		nReserved;
	GUID		guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
	  sizeof(DETOUR_SECTION_HEADER),\
	  DETOUR_SECTION_HEADER_SIGNATURE,\
	  sizeof(DETOUR_SECTION_HEADER),\
	  (cbSectionSize),\
	  \
	  0,\
	  0,\
	  0,\
	  0,\
	  \
	  0,\
	  0,\
	  0,\
	  0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
														 PCHAR pszFile,
														 PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
														PCHAR pszOrigFile,
														PCHAR pszFile,
														PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
														  DWORD nOrdinal,
														  PCHAR pszOrigSymbol,
														  PCHAR pszSymbol,
														  PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
														  DWORD nOrdinal,
														  PCHAR pszName,
														  PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
							PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
											  PBYTE pbTarget,
											  PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
												PBYTE pbTarget,
												PBYTE pbDetour,
												PBYTE *ppbRealTrampoline,
												PBYTE *ppbRealTarget,
												PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
										  PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
											PBYTE pbDetour,
											PBYTE *ppbRealTrampoline,
											PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemoveWithTrampoline(PBYTE pbTrampoline,
										PBYTE pbDetour);

PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourFindFinalCode(PBYTE pbCode);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
									 PBYTE pbSrc,
									 PBYTE *ppbTarget,
									 LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HINSTANCE WINAPI DetourEnumerateInstances(HINSTANCE hinstLast);
PBYTE WINAPI DetourFindEntryPointForInstance(HINSTANCE hInst);
BOOL WINAPI DetourEnumerateExportsForInstance(HINSTANCE hInst,
											  PVOID pContext,
											  PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PDETOUR_LOADED_BINARY WINAPI DetourBinaryFromInstance(HINSTANCE hInst);
PBYTE WINAPI DetourFindPayloadInBinary(PDETOUR_LOADED_BINARY pBinary,
									   REFGUID rguid,
									   DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfBinary(PDETOUR_LOADED_BINARY pBinary);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
										   GUID *pGuid,
										   DWORD *pcbData,
										   DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
									 REFGUID rguid,
									 DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
									REFGUID rguid,
									PBYTE pbData,
									DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayload(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
									PVOID pContext,
									PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
									PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
									PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
									PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

///////////////////////////////////////// Symbolic Debug Information Creation.
//
enum {
	DETOUR_SYNTH_HEADERSIZE	= 512,
};

typedef VOID * PDETOUR_SYNTH;

PDETOUR_SYNTH WINAPI DetourSynthCreate();

PDETOUR_SYNTH WINAPI DetourSynthCreatePseudoFile(PCHAR pszBinPath,
												 PVOID pvBase);

BOOL WINAPI DetourSynthAddSymbol(PDETOUR_SYNTH pSynth,
								 PVOID pvSymbol,
								 PCSTR pszSymbol);

BOOL WINAPI DetourSynthAddSource(PDETOUR_SYNTH pSynth,
								 PVOID pvSource,
								 DWORD cbSource,
								 PCSTR pszFile,
								 DWORD nLine);

BOOL WINAPI DetourSynthAddOpcode(PDETOUR_SYNTH pSynth,
								 PVOID pvCode,
								 DWORD cbCode);

BOOL WINAPI DetourSynthWriteToFile(PDETOUR_SYNTH pSynth,
								   HANDLE hFile,
								   WORD Machine,
								   WORD Characteristics,
								   DWORD TimeDateStamp,
								   DWORD CheckSum,
								   DWORD ImageBase,
								   DWORD SizeOfImage,
								   DWORD SectionAlignment,
								   PIMAGE_SECTION_HEADER pSections,
								   DWORD nSections);

DWORD WINAPI DetourSynthAppendToFile(PDETOUR_SYNTH pBinary,
									 HANDLE hFile,
									 DWORD ImageBase,
									 PIMAGE_SECTION_HEADER pSections,
									 DWORD nSections,
									 PIMAGE_DEBUG_DIRECTORY pDir);

BOOL WINAPI DetourSynthFlushPseudoFile(PDETOUR_SYNTH pSynth);

BOOL WINAPI DetourSynthClose(PDETOUR_SYNTH pSynth);

DWORD WINAPI DetourSynthLoadMissingSymbols(VOID);
VOID WINAPI DetourSynthNotifyDebuggerOfLoad(PBYTE pbData, PCSTR pszDllPath);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PCREATE_PROCESS_ROUTINEA)
	(LPCSTR lpApplicationName,
	 LPSTR lpCommandLine,
	 LPSECURITY_ATTRIBUTES lpProcessAttributes,
	 LPSECURITY_ATTRIBUTES lpThreadAttributes,
	 BOOL bInheritHandles,
	 DWORD dwCreationFlags,
	 LPVOID lpEnvironment,
	 LPCSTR lpCurrentDirectory,
	 LPSTARTUPINFOA lpStartupInfo,
	 LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PCREATE_PROCESS_ROUTINEW)
	(LPCWSTR lpApplicationName,
	 LPWSTR lpCommandLine,
	 LPSECURITY_ATTRIBUTES lpProcessAttributes,
	 LPSECURITY_ATTRIBUTES lpThreadAttributes,
	 BOOL bInheritHandles,
	 DWORD dwCreationFlags,
	 LPVOID lpEnvironment,
	 LPCWSTR lpCurrentDirectory,
	 LPSTARTUPINFOW lpStartupInfo,
	 LPPROCESS_INFORMATION lpProcessInformation);
								  
BOOL WINAPI CreateProcessWithDllA(LPCSTR lpApplicationName,
								  LPSTR lpCommandLine,
								  LPSECURITY_ATTRIBUTES lpProcessAttributes,
								  LPSECURITY_ATTRIBUTES lpThreadAttributes,
								  BOOL bInheritHandles,
								  DWORD dwCreationFlags,
								  LPVOID lpEnvironment,
								  LPCSTR lpCurrentDirectory,
								  LPSTARTUPINFOA lpStartupInfo,
								  LPPROCESS_INFORMATION lpProcessInformation,
								  LPCSTR lpDllName,
								  PCREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI CreateProcessWithDllW(LPCWSTR lpApplicationName,
								  LPWSTR lpCommandLine,
								  LPSECURITY_ATTRIBUTES lpProcessAttributes,
								  LPSECURITY_ATTRIBUTES lpThreadAttributes,
								  BOOL bInheritHandles,
								  DWORD dwCreationFlags,
								  LPVOID lpEnvironment,
								  LPCWSTR lpCurrentDirectory,
								  LPSTARTUPINFOW lpStartupInfo,
								  LPPROCESS_INFORMATION lpProcessInformation,
								  LPCWSTR lpDllName,
								  PCREATE_PROCESS_ROUTINEW pfCreateProcessW);
				  
#ifdef UNICODE
#define CreateProcessWithDll  		CreateProcessWithDllW
#define PCREATE_PROCESS_ROUTINE		PCREATE_PROCESS_ROUTINEW
#else
#define CreateProcessWithDll  		CreateProcessWithDllA
#define PCREATE_PROCESS_ROUTINE		PCREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI ContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI ContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define ContinueProcessWithDll  		ContinueProcessWithDllW
#else
#define ContinueProcessWithDll  		ContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus
#endif // _DETOURS_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\disasm.h ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		disasm.h
//	Author:		Doug Brubacher
//
//	Detours for binary functions.  Version 1.2. (Build 35)
//  Includes support for all x86 chips prior to the Pentium III.
//
//	Copyright 1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DISASM_H_
#define _DISASM_H_

class CDetourDis
{
  public:
	CDetourDis(PBYTE *ppbTarget, LONG *plExtra);
	
	PBYTE 	CopyInstruction(PBYTE pbDst, PBYTE pbSrc);
	static BOOL	SanityCheckSystem();

  public:
	struct COPYENTRY;
	typedef const COPYENTRY * REFCOPYENTRY;

	typedef PBYTE (CDetourDis::* COPYFUNC)(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

	enum {
		DYNAMIC 	= 0x1u,
		ADDRESS 	= 0x2u,
		NOENLARGE	= 0x4u,

		SIB			= 0x10u,
		NOTSIB		= 0x0fu,
	};
	struct COPYENTRY 
	{
		ULONG 		nOpcode 		: 8;				// Opcode
		ULONG		nFixedSize 		: 3;				// Fixed size of opcode
		ULONG		nFixedSize16 	: 3;				// Fixed size when 16 bit operand
		ULONG		nModOffset 		: 3;				// Offset to mod/rm byte (0=none)
		LONG		nRelOffset 		: 3;				// Offset to relative target.
		ULONG		nFlagBits		: 4;				// Flags for DYNAMIC, etc.
		COPYFUNC	pfCopy;								// Function pointer.
	};

  protected:
#define ENTRY_CopyBytes1			1, 1, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes1Dynamic		1, 1, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes2			2, 2, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Jump		2, 2, 0, 1, 0, CopyBytes
#define ENTRY_CopyBytes2CantJump	2, 2, 0, 1, NOENLARGE, CopyBytes
#define ENTRY_CopyBytes2Dynamic		2, 2, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3			3, 3, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Dynamic		3, 3, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3Or5			5, 3, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Or5Target	5, 3, 0, 1, 0, CopyBytes
#define ENTRY_CopyBytes5Or7Dynamic	7, 5, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3Or5Address	5, 3, 0, 0, ADDRESS, CopyBytes
#define ENTRY_CopyBytes4			4, 4, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes5			5, 5, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes7			7, 7, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Mod			2, 2, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Mod1		3, 3, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes2ModOperand	6, 4, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Mod			3, 3, 2, 0, 0, CopyBytes
#define ENTRY_CopyBytesPrefix		1, 1, 0, 0, 0, CopyBytesPrefix
#define ENTRY_Copy0F				1, 1, 0, 0, 0, Copy0F
#define ENTRY_Copy66				1, 1, 0, 0, 0, Copy66
#define ENTRY_Copy67				1, 1, 0, 0, 0, Copy67
#define ENTRY_CopyF6				0, 0, 0, 0, 0, CopyF6
#define ENTRY_CopyF7				0, 0, 0, 0, 0, CopyF7
#define ENTRY_CopyFF				0, 0, 0, 0, 0, CopyFF
#define ENTRY_Invalid				1, 1, 0, 0, 0, Invalid
#define ENTRY_End					0, 0, 0, 0, 0, NULL
	
	PBYTE CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	
	PBYTE Invalid(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

	PBYTE AdjustTarget(PBYTE pbDst, PBYTE pbSrc, LONG cbOp, LONG cbTargetOffset);
	
	VOID	Set16BitOperand();
	VOID	Set32BitOperand();
	VOID	Set16BitAddress();
	VOID	Set32BitAddress();
	
  protected:
	PBYTE Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyF6(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyF7(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyFF(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

  protected:	
	static const COPYENTRY	s_rceCopyTable[257];
	static const COPYENTRY	s_rceCopyTable0F[257];
	static const BYTE 		s_rbModRm[256];

  protected:
	BOOL				m_b16BitOperand;
	BOOL				m_b16BitAddress;

	PBYTE *				m_ppbTarget;
	LONG *				m_plExtra;
	
	LONG				m_lScratchExtra;
	PBYTE				m_pbScratchTarget;
	BYTE				m_rbScratchDst[64];
};

#endif //_DISASM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\perf.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Perf.cpp

Abstract:
    This file contains debugging stuff.

Revision History:
    Davide Massarenti   (dmassare) 01/17/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

#ifdef HSS_PERFORMANCEDUMP

#include <ProjectConstants.h>
#include <MPC_utils.h>

////////////////////////////////////////////////////////////////////////////////

class PerfLog
{
public:
    MPC::string   szText;
    LARGE_INTEGER liTime;
    DWORDLONG     ullTotal;
};

typedef std::list< PerfLog >        PerfResults;
typedef PerfResults::iterator       PerfResultsIter;
typedef PerfResults::const_iterator PerfResultsIterConst;

////////////////////////////////////////////////////////////////////////////////

static PerfResults                      s_lst;
static LARGE_INTEGER                    s_liStartOfPerf;
static LARGE_INTEGER                    s_liAdjust;
static MPC::CComSafeAutoCriticalSection s_csec;

////////////////////////////////////////////////////////////////////////////////

#define DEBUG_PERF_EVENTS DEBUG_PERF_EVENTS_IN | DEBUG_PERF_EVENTS_OUT

static const MPC::StringToBitField s_arrMap[] =
{
    { L"BASIC"        , DEBUG_PERF_BASIC        , DEBUG_PERF_BASIC        , -1 },
    { L"PROTOCOL"     , DEBUG_PERF_PROTOCOL     , DEBUG_PERF_PROTOCOL     , -1 },
    { L"PROTOCOL_READ", DEBUG_PERF_PROTOCOL_READ, DEBUG_PERF_PROTOCOL_READ, -1 },
    { L"MARS"         , DEBUG_PERF_MARS         , DEBUG_PERF_MARS         , -1 },
    { L"EVENTS_IN"    , DEBUG_PERF_EVENTS_IN    , DEBUG_PERF_EVENTS_IN    , -1 },
    { L"EVENTS_OUT"   , DEBUG_PERF_EVENTS_OUT   , DEBUG_PERF_EVENTS_OUT   , -1 },
    { L"EVENTS"       , DEBUG_PERF_EVENTS       , DEBUG_PERF_EVENTS       , -1 },
    { L"PROXIES"      , DEBUG_PERF_PROXIES      , DEBUG_PERF_PROXIES      , -1 },
    { L"QUERIES"      , DEBUG_PERF_QUERIES      , DEBUG_PERF_QUERIES      , -1 },

    { L"CACHE_L1"     , DEBUG_PERF_CACHE_L1     , DEBUG_PERF_CACHE_L1     , -1 },
    { L"CACHE_L2"     , DEBUG_PERF_CACHE_L2     , DEBUG_PERF_CACHE_L2     , -1 },

    { L"HELPSVC"      , DEBUG_PERF_HELPSVC      , DEBUG_PERF_HELPSVC      , -1 },
    { L"HELPHOST"     , DEBUG_PERF_HELPHOST     , DEBUG_PERF_HELPHOST     , -1 },

    { L"ALL"          , -1                      , -1                      , -1 },
    { NULL                                                                     }
};

static const WCHAR s_Key  [] = HC_REGISTRY_BASE L"\\Perf";
static const WCHAR s_Value[] = L"Mask";

////////////////////////////////////////////////////////////////////////////////

static DWORD         s_mode;
static LARGE_INTEGER s_liEnter;
static LARGE_INTEGER s_liExit;
static CHAR          s_rgLineA[4096];
static WCHAR         s_rgLineW[4096];

static void StopCounter()
{
    s_csec.Lock();

    ::QueryPerformanceCounter( &s_liEnter );
    if(s_liStartOfPerf.QuadPart == 0)
    {
        bool fFound;

        s_liStartOfPerf = s_liEnter;
        s_mode          = DEBUG_PERF_BASIC;

        if(FAILED(MPC::RegKey_Value_Read( s_mode, fFound, s_Key, s_Value )) || fFound == false)
        {
            MPC::wstring szValue;

            if(SUCCEEDED(MPC::RegKey_Value_Read( szValue, fFound, s_Key, s_Value )) && fFound)
            {
                DWORD dwMode;

                if(SUCCEEDED(MPC::ConvertStringToBitField( szValue.c_str(), dwMode, s_arrMap, true )) && dwMode)
                {
                    s_mode = dwMode;
                }
            }
        }
    }
}

static void RestartCounter()
{
    ::QueryPerformanceCounter( &s_liExit );

    s_liAdjust.QuadPart += s_liExit.QuadPart - s_liEnter.QuadPart;

    s_csec.Unlock();
}


static void DEBUG_AppendPerf( LPCSTR szMessage )
{
    PerfResultsIter it;
    DWORDLONG       ullTotal = 0;

    {
        HANDLE pHeaps[256];
        DWORD  dwNumberOfHeaps = ::GetProcessHeaps( ARRAYSIZE(pHeaps), pHeaps );

        for(DWORD i=0; i<dwNumberOfHeaps; i++)
        {
            PROCESS_HEAP_ENTRY entry; entry.lpData = NULL;

            while(::HeapWalk( pHeaps[i], &entry ))
            {
                if(entry.wFlags & PROCESS_HEAP_ENTRY_BUSY)
                {
                    //
                    // Allocated block. Add both it's size and its overhead to the total
                    // We want the overhead since it figures into the total required
                    // commitment.
                    //
                    ullTotal += (entry.cbData + entry.cbOverhead);
                }
            }
        }
    }
    it = s_lst.insert( s_lst.end() );

    it->szText          = szMessage;
    it->liTime.QuadPart = s_liEnter.QuadPart - s_liStartOfPerf.QuadPart - s_liAdjust.QuadPart;

    it->ullTotal = ullTotal;
}

void DEBUG_AppendPerf( DWORD  mode         ,
                       LPCSTR szMessageFmt ,
                       ...                 )
{
    StopCounter();

    if(mode & s_mode)
    {
        va_list arglist;
        int     iLen;

        //
        // Format the log line.
        //
        va_start( arglist, szMessageFmt );
        iLen = _vsnprintf( s_rgLineA, MAXSTRLEN(s_rgLineA), szMessageFmt, arglist );
        va_end( arglist );

        //
        // Is the arglist too big for us?
        //
        if(iLen < 0)
        {
            iLen = MAXSTRLEN(s_rgLineA);
        }
        s_rgLineA[iLen] = 0;


        DEBUG_AppendPerf( s_rgLineA );
    }

    RestartCounter();
}

void DEBUG_AppendPerf( DWORD   mode         ,
                       LPCWSTR szMessageFmt ,
                       ...                  )
{
    StopCounter();

    if(mode & s_mode)
    {
        USES_CONVERSION;

        va_list arglist;
        int     iLen;

        //
        // Format the log line.
        //
        va_start( arglist, szMessageFmt );
        iLen = _vsnwprintf( s_rgLineW, MAXSTRLEN(s_rgLineW), szMessageFmt, arglist );
        va_end( arglist );

        //
        // Is the arglist too big for us?
        //
        if(iLen < 0)
        {
            iLen = MAXSTRLEN(s_rgLineW);
        }
        s_rgLineW[iLen] = 0;


        DEBUG_AppendPerf( W2A(s_rgLineW) );
    }

    RestartCounter();
}

void DEBUG_DumpPerf( LPCWSTR szFile )
{
    HANDLE          hFile;
    SYSTEMTIME      st;
    DWORD           dwWritten;
    LARGE_INTEGER   liFreq;
    LARGE_INTEGER*  pliPrev = NULL;
    MPC::wstring    strFile = szFile; MPC::SubstituteEnvVariables( strFile );
    PerfResultsIter it;
    int             len;
    double          scale;


    ::QueryPerformanceFrequency( &liFreq ); scale = (double)liFreq.QuadPart / 1E6;

    //
    // Calc max entry length.
    //
    for(len=0,it=s_lst.begin(); it!=s_lst.end(); it++)
    {
        if(len < it->szText.size())
        {
            len = it->szText.size();
        }
    }


    hFile = ::CreateFileW( strFile.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
    if(hFile == INVALID_HANDLE_VALUE) goto end;
    ::SetFilePointer( hFile, 0, NULL, FILE_END );

    //
    // Prepend current time.
    //
    ::GetLocalTime( &st );

    sprintf( s_rgLineA, "Performance Dump: %04u/%02u/%02u %02u:%02u:%02u\n", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond );
    if(::WriteFile( hFile, s_rgLineA, strlen( s_rgLineA ), &dwWritten, NULL ) == FALSE) goto end;

    sprintf( s_rgLineA, "=====================================\n" );
    if(::WriteFile( hFile, s_rgLineA, strlen( s_rgLineA ), &dwWritten, NULL ) == FALSE) goto end;

    //
    // Dump all the entries.
    //
    for(it=s_lst.begin(); it!=s_lst.end(); )
    {
        PerfLog& pl = *it++;
        double   t0 =                      (double)pl. liTime.QuadPart          ;
        double   dT = it != s_lst.end() ? ((double)it->liTime.QuadPart - t0) : 0;

        sprintf( s_rgLineA, "%-*s : %9ld us  dT: %9ld us (Mem: %9ld)\n", len, pl.szText.c_str(), (long)(t0 / scale), (long)(dT / scale), (long)pl.ullTotal );

        if(::WriteFile( hFile, s_rgLineA, strlen( s_rgLineA ), &dwWritten, NULL ) == FALSE) goto end;
    }

    sprintf( s_rgLineA, "\n\n\n" );
    if(::WriteFile( hFile, s_rgLineA, strlen( s_rgLineA ), &dwWritten, NULL ) == FALSE) goto end;

end:

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#pragma warning(disable:4192)

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

//////

#include <detours.h>
#include <disasm.h>

#include <Debug.h>

//////

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\logging.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Logging.cpp

Abstract:
    This file contains debugging stuff.

Revision History:
    Davide Massarenti   (dmassare) 10/31/99
        created

******************************************************************************/

#include "stdafx.h"

#define BUFFER_LINE_LENGTH (1024)

#ifdef DEBUG

void DebugLog( LPCSTR szMessageFmt ,
			   ...                 )
{
    CHAR    rgLine[BUFFER_LINE_LENGTH+1];
    va_list arglist;
    int     iLen;
    BOOL    bRetVal = TRUE;


    //
    // Format the log line.
    //
    va_start( arglist, szMessageFmt );
    iLen = _vsnprintf( rgLine, BUFFER_LINE_LENGTH, szMessageFmt, arglist );
    va_end( arglist );

    //
    // Is the arglist too big for us?
    //
    if(iLen < 0)
    {
        iLen = BUFFER_LINE_LENGTH;
    }
    rgLine[iLen] = 0;

    ::OutputDebugStringA( rgLine );
}

void DebugLog( LPCWSTR szMessageFmt ,
			   ...                  )
{
    WCHAR   rgLine[BUFFER_LINE_LENGTH+1];
    va_list arglist;
    int     iLen;
    BOOL    bRetVal = TRUE;


    //
    // Format the log line.
    //
    va_start( arglist, szMessageFmt );
    iLen = _vsnwprintf( rgLine, BUFFER_LINE_LENGTH, szMessageFmt, arglist );
    va_end( arglist );

    //
    // Is the arglist too big for us?
    //
    if(iLen < 0)
    {
        iLen = BUFFER_LINE_LENGTH;
    }
    rgLine[iLen] = 0;

    ::OutputDebugStringW( rgLine );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\debug\windowdetours.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WindowDetours.cpp

Abstract:
    This file contains the trampolines for the detour of System functions.

Revision History:
    Davide Massarenti   (dmassare) 10/31/99
        created

******************************************************************************/

#include "stdafx.h"


////////////////////////////////////////////////////////////////////////////////////////

typedef std::map<HWND, DWORD> WindowsMap;
typedef WindowsMap::iterator  WindowsIter;

static WindowsMap s_mapWindows;

////////////////////////////////////////////////////////////////////////////////////////

DETOUR_TRAMPOLINE( HWND WINAPI Trampoline_CreateWindowExA( DWORD  ,
														   LPCSTR ,
                                                           LPCSTR ,
                                                           DWORD  ,
                                                           int    ,
                                                           int    ,
                                                           int    ,
                                                           int    ,
                                                           HWND   ,
                                                           HMENU  ,
                                                           HANDLE ,
                                                           LPVOID ), CreateWindowExA );

HWND WINAPI Detour_CreateWindowExA( DWORD  dwExStyle   ,
								   	LPCSTR lpClassName , // pointer to registered class name
								   	LPCSTR lpWindowName, // pointer to window name
								   	DWORD  dwStyle     , // window style
								   	int    x           , // horizontal position of window
								   	int    y           , // vertical position of window
								   	int    nWidth      , // window width
								   	int    nHeight     , // window height
								   	HWND   hWndParent  , // handle to parent or owner window
								   	HMENU  hMenu       , // menu handle or child identifier
								   	HANDLE hInstance   , // handle to application instance
								   	LPVOID lpParam     ) // window-creation data
{
	HWND hwnd;

	hwnd = Trampoline_CreateWindowExA( dwExStyle   ,
									   lpClassName ,
									   lpWindowName,
									   dwStyle     ,
									   x           ,
									   y           ,
									   nWidth      ,
									   nHeight     ,
									   hWndParent  ,
									   hMenu       ,
									   hInstance   ,
									   lpParam     );

	DebugLog( "%%%% CreateWindowExA  %08lx : '%s'\n", hwnd, lpWindowName ? lpWindowName : "" );

	if(hwnd)
	{
		s_mapWindows[hwnd] = ::GetCurrentThreadId();
	}

	return hwnd;
}

////////////////////////////////////////////////////////////////////////////////////////

DETOUR_TRAMPOLINE( HWND WINAPI Trampoline_CreateWindowExW( DWORD   ,
														   LPCWSTR ,
                                                           LPCWSTR ,
                                                           DWORD   ,
                                                           int     ,
                                                           int     ,
                                                           int     ,
                                                           int     ,
                                                           HWND    ,
                                                           HMENU   ,
                                                           HANDLE  ,
                                                           LPVOID  ), CreateWindowExW );

HWND WINAPI Detour_CreateWindowExW( DWORD   dwExStyle   ,
								   	LPCWSTR lpClassName , // pointer to registered class name
								   	LPCWSTR lpWindowName, // pointer to window name
								   	DWORD   dwStyle     , // window style
								   	int     x           , // horizontal position of window
								   	int     y           , // vertical position of window
								   	int     nWidth      , // window width
								   	int     nHeight     , // window height
								   	HWND    hWndParent  , // handle to parent or owner window
								   	HMENU   hMenu       , // menu handle or child identifier
								   	HANDLE  hInstance   , // handle to application instance
								   	LPVOID  lpParam     ) // window-creation data
{
	HWND hwnd;

	hwnd = Trampoline_CreateWindowExW( dwExStyle   ,
									   lpClassName ,
									   lpWindowName,
									   dwStyle     ,
									   x           ,
									   y           ,
									   nWidth      ,
									   nHeight     ,
									   hWndParent  ,
									   hMenu       ,
									   hInstance   ,
									   lpParam     );

	DebugLog( L"%%%% CreateWindowExW  %08lx : '%s'\n", hwnd, lpWindowName ? lpWindowName : L"" );

	if(hwnd)
	{
		s_mapWindows[hwnd] = ::GetCurrentThreadId();
	}

	return hwnd;
}

////////////////////////////////////////////////////////////////////////////////

DETOUR_TRAMPOLINE( BOOL WINAPI Trampoline_DestroyWindow( HWND ), DestroyWindow );

BOOL WINAPI Detour_DestroyWindow( HWND hWnd ) // handle to window to destroy
{
	BOOL        res;
	WindowsIter it;

	DebugLog( "%%%% DestroyWindow    %08lx\n", hWnd );

	it = s_mapWindows.find( hWnd );
	if(it != s_mapWindows.end())
	{
		if(it->second != ::GetCurrentThreadId())
		{
			// Window destroyed from the wrong thread!!
			DebugBreak();
		}

		s_mapWindows.erase( it );
	}
	else
	{
		// Window already destroyed!!
		DebugBreak();
	}

	res = Trampoline_DestroyWindow( hWnd );

	return res;
}

////////////////////////////////////////////////////////////////////////////////

void WindowDetours_Setup()
{
    DetourFunctionWithTrampoline( (PBYTE)Trampoline_CreateWindowExA, (PBYTE)Detour_CreateWindowExA );
    DetourFunctionWithTrampoline( (PBYTE)Trampoline_CreateWindowExW, (PBYTE)Detour_CreateWindowExW );

    DetourFunctionWithTrampoline( (PBYTE)Trampoline_DestroyWindow  , (PBYTE)Detour_DestroyWindow   );
}

void WindowDetours_Remove()
{
    DetourRemoveWithTrampoline( (PBYTE)Trampoline_CreateWindowExA, (PBYTE)Detour_CreateWindowExA );
    DetourRemoveWithTrampoline( (PBYTE)Trampoline_CreateWindowExW, (PBYTE)Detour_CreateWindowExW );

    DetourRemoveWithTrampoline( (PBYTE)Trampoline_DestroyWindow  , (PBYTE)Detour_DestroyWindow   );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\client\dllmain.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    dllmain.cpp

Abstract:
    Implementation of DLL Exports.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "stdafx.h"
#include <initguid.h>

#include <HelpCenterTypeLib_i.c>
#include <HCApi_i.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PCHLaunch, CPCHLaunch)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if(dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HCLaunchLIB);

        DisableThreadLibraryCalls( hInstance );
    }
    else if(dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\client\impl.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    impl.cpp

Abstract:
    This file contains the implementation of the CPCHLaunch class.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////

CPCHLaunch::CPCHLaunch()
{
	// HCAPI::CmdData m_data;
	// HCAPI::Locator m_loc;
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHLaunch::SetMode( /*[in]*/ DWORD dwFlags )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::SetMode" );


	m_data.m_fMode   = true;
	m_data.m_dwFlags = dwFlags;


	__HCP_FUNC_EXIT(S_OK);
}


STDMETHODIMP CPCHLaunch::SetParentWindow( /*[in]*/ HWND hwndParent )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::SetParentWindow" );


	m_data.m_fWindow    = true;
	m_data.m_hwndParent = hwndParent;


	__HCP_FUNC_EXIT(S_OK);
}


STDMETHODIMP CPCHLaunch::SetSizeInfo( /*[in]*/ LONG lX, /*[in]*/ LONG lY, /*[in]*/ LONG lWidth, /*[in]*/ LONG lHeight )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::SetSizeInfo" );


	m_data.m_fSize   = true;
	m_data.m_lX      = lX;
	m_data.m_lY      = lY;
	m_data.m_lWidth  = lWidth;
	m_data.m_lHeight = lHeight;


	__HCP_FUNC_EXIT(S_OK);
}


STDMETHODIMP CPCHLaunch::SetContext( /*[in]*/ BSTR bstrCtxName, /*[in]*/ BSTR bstrCtxInfo )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::SetContext" );


	m_data.m_fCtx        = true;
	m_data.m_bstrCtxName = bstrCtxName;
	m_data.m_bstrCtxInfo = bstrCtxInfo;


	__HCP_FUNC_EXIT(S_OK);
}


STDMETHODIMP CPCHLaunch::DisplayTopic( /*[in]*/ BSTR bstrURL )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::DisplayTopic" );

	HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
	__MPC_PARAMCHECK_END();


	m_data.m_fURL    = true;
	m_data.m_bstrURL = bstrURL;

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_loc.ExecCommand( m_data ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHLaunch::DisplayError( /*[in]*/ REFCLSID rclsid )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::DisplayError" );

	HRESULT hr;


	m_data.m_fError     = true;
	m_data.m_clsidError = rclsid;

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_loc.ExecCommand( m_data ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHLaunch::IsOpen( /*[out]*/ BOOL *pVal )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::IsOpen" );

	HRESULT hr;
	bool    fOpen;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,FALSE);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_loc.IsOpen( fOpen, &m_data.m_clsidCaller ));

	*pVal = fOpen ? TRUE : FALSE;
	hr    = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
			  
STDMETHODIMP CPCHLaunch::PopUp()
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::PopUp" );

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_loc.PopUp());

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHLaunch::Close()
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::Close" );

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_loc.Close());

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHLaunch::WaitForTermination( /*[in]*/ DWORD dwTimeout )
{
	__HCP_FUNC_ENTRY( "CPCHLaunch::WaitForTermination" );

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_loc.WaitForTermination( dwTimeout ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\client\resource.h ===
//******************************************************************************
// 
// Copyright (c) 2000 Microsoft Corporation
// 
// Module Name:
// 	   resource.h
// 
// Abstract:
// 	   Resource file for Help Center Launch API.
// 
// Revision History:
// 	   Davide Massarenti   (Dmassare)  03/14/2000
// 		   created
// 
//******************************************************************************

#define IDR_HCAPI 100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\client\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>

extern CComModule _Module;

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <resource.h>


#include <HCApiLib.h>


class ATL_NO_VTABLE CPCHLaunch : // Hungarian: pchl
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
	public CComCoClass<CPCHLaunch, &CLSID_PCHLaunch>,
    public IPCHLaunch
{
	HCAPI::CmdData m_data;
	HCAPI::Locator m_loc;

public:
DECLARE_REGISTRY_RESOURCEID(IDR_HCAPI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHLaunch)
    COM_INTERFACE_ENTRY(IPCHLaunch)
END_COM_MAP()

public:
    CPCHLaunch();
 
    // IPCHLaunch
	STDMETHOD(SetMode)( /*[in]*/ DWORD dwFlags );

	STDMETHOD(SetParentWindow)( /*[in]*/ HWND hwndParent );

	STDMETHOD(SetSizeInfo)( /*[in]*/ LONG lX, /*[in]*/ LONG lY, /*[in]*/ LONG lWidth, /*[in]*/ LONG lHeight );

	STDMETHOD(SetContext)( /*[in]*/ BSTR bstrCtxName, /*[in]*/ BSTR bstrCtxInfo );

	STDMETHOD(DisplayTopic)( /*[in]*/ BSTR     bstrURL );
	STDMETHOD(DisplayError)( /*[in]*/ REFCLSID rclsid  );

	////////////////////

	STDMETHOD(IsOpen)( /*[out]*/ BOOL *pVal );
			  
	STDMETHOD(PopUp)();
	STDMETHOD(Close)();

	STDMETHOD(WaitForTermination)( /*[in]*/ DWORD dwTimeout );
};

#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\unittest\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the unit test for the Security objects.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#include "StdAfx.h"

#include <initguid.h>

#include "HCApi_i.c"

////////////////////////////////////////////////////////////////////////////////

static HRESULT Create( IPCHLaunch* *obj )
{
	return ::CoCreateInstance( CLSID_PCHLaunch, NULL, CLSCTX_ALL, IID_IPCHLaunch, (void**)obj );
}

static HRESULT SimpleOpen()
{
	__HCP_FUNC_ENTRY( "SimpleOpen" );

	HRESULT             hr;
	CComPtr<IPCHLaunch> obj;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Create( &obj ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, obj->PopUp());

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

static HRESULT OpenWithSizeAndContext( LPCWSTR ctx )
{
	__HCP_FUNC_ENTRY( "OpenWithSizeAndContext" );

	HRESULT             hr;
	CComPtr<IPCHLaunch> obj;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Create( &obj ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, obj->SetSizeInfo( 20, 20, 300, 300 ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, obj->DisplayTopic( CComBSTR( ctx ) ));


	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

static HRESULT OpenOnTop( LPCWSTR ctx, LPCWSTR win )
{
	__HCP_FUNC_ENTRY( "OpenOnTop" );

	HRESULT             hr;
	CComPtr<IPCHLaunch> obj;
	HWND                hwnd;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Create( &obj ));

	hwnd = ::FindWindowW( win, NULL );

	__MPC_EXIT_IF_METHOD_FAILS(hr, obj->SetParentWindow( hwnd ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, obj->DisplayTopic( CComBSTR( ctx ) ));


	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

static HRESULT WaitUntilExit()
{
	__HCP_FUNC_ENTRY( "WaitUntilExit" );

	HRESULT             hr;
	CComPtr<IPCHLaunch> obj;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Create( &obj ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, obj->WaitForTermination( INFINITE ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT RunTests( int argc, WCHAR **argv )
{
	__HCP_FUNC_ENTRY( "RunTests" );

	HRESULT hr;
	int     i;

	for(i=1; i<argc;)
	{
		LPCWSTR szArg = argv[i++];

		if(!_wcsicmp( szArg, L"SimpleOpen" ))
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, SimpleOpen());
		}
		else if(!_wcsicmp( szArg, L"OpenWithSizeAndContext" ))
		{
			LPCWSTR ctx = (i<argc) ? argv[i++] : L"hcp://system/index.htm";

			__MPC_EXIT_IF_METHOD_FAILS(hr, OpenWithSizeAndContext( ctx ));
		}
		else if(!_wcsicmp( szArg, L"OpenOnTop" ))
		{
			LPCWSTR win = (i<argc) ? argv[i++] : L"Notepad";
			LPCWSTR ctx = (i<argc) ? argv[i++] : L"hcp://system/homepage.htm";

			__MPC_EXIT_IF_METHOD_FAILS(hr, OpenOnTop( ctx, win ));
		}
		else if(!_wcsicmp( szArg, L"WaitUntilExit" ))
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, WaitUntilExit());
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

int __cdecl wmain( int argc, WCHAR **argv, WCHAR **envp)
{
    HRESULT  hr;

    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
		hr = RunTests( argc, argv );

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\include\hcapilib.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HCAPIlib.h

Abstract:
    This file contains the declaration of the common code for the
	Help Center Launch API.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HCAPILIB_H___)
#define __INCLUDED___PCH___HCAPILIB_H___

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// From HCApi.idl
//
#include <HCApi.h>


namespace HCAPI
{
	// BUILD BREAK
	interface IPCHHelpCenterIPC : public IUnknown
	{
	};

	class CmdData
	{
	public:
		CLSID    m_clsidCaller;

		////////////////////

		bool     m_fMode;
		DWORD 	 m_dwFlags;
			     
		////////////////////

		bool     m_fWindow;
		HWND  	 m_hwndParent;
			     
		////////////////////

		bool     m_fSize;
		LONG  	 m_lX;
		LONG  	 m_lY;
		LONG  	 m_lWidth;
		LONG  	 m_lHeight;
			     
		////////////////////

		bool     m_fCtx;
		CComBSTR m_bstrCtxName;
		CComBSTR m_bstrCtxInfo;

		////////////////////
			     
		bool     m_fURL;
		CComBSTR m_bstrURL;

		////////////////////
			     
		bool     m_fError;
		CLSID    m_clsidError;

		////////////////////

		CmdData();

		HRESULT Serialize  ( /*[out]*/       CComBSTR& bstrBLOB );
		HRESULT Unserialize( /*[in ]*/ const CComBSTR& bstrBLOB );
	};

	class Locator
	{
		CComPtr<IPCHHelpCenterIPC>   m_ipc;
		CComPtr<IRunningObjectTable> m_rt;
		CComPtr<IMoniker>            m_moniker;
		DWORD                        m_dwRegister;

	public:
		Locator();
		~Locator();

		void Cleanup();

		HRESULT Init( /*[in]*/ REFCLSID clsid, /*[in]*/ IPCHHelpCenterIPC* ipc = NULL );

		HRESULT Register();
		HRESULT Revoke  ();


		HRESULT IsOpen( /*[out]*/ bool& fOpen, /*[in]*/ CLSID* pclsid = NULL );

		HRESULT ExecCommand( /*[out]*/ CmdData& cd );

		HRESULT PopUp();
		HRESULT Close();

		HRESULT WaitForTermination( /*[in]*/ DWORD dwTimeout );
	};
};

#endif // !defined(__INCLUDED___PCH___HCAPILIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\lib\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  04/07/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>
#include <MPC_logging.h>


//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// From HCApi.h
//
#include <HCApi.h>


#include <HCApiLib.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\unittest\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <Debug.h>

//////

#include <HCApiLib.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi\lib\lib.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HCApiLib.cpp

Abstract:
    This file contains the implementation of the HCApi Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_HelpCtr[] = HC_ROOT_HELPSVC_BINARIES L"\\HelpCtr.exe";

////////////////////////////////////////////////////////////////////////////////

HCAPI::CmdData::CmdData()
{
// BUILD BREAK    m_clsidCaller = CLSID_PCHHelpCenterIPC; // CLSID    m_clsidCaller;
                                            //
    m_fSize       = false;                  // bool     m_fSize;
    m_lX          = 0;                      // LONG     m_lX;
    m_lY          = 0;                      // LONG     m_lY;
    m_lWidth      = 0;                      // LONG     m_lWidth;
    m_lHeight     = 0;                      // LONG     m_lHeight;
                                            //
    m_fMode       = false;                  // bool     m_fMode;
    m_dwFlags     = 0;                      // DWORD    m_dwFlags;
                                            //
    m_fWindow     = false;                  // bool     m_fWindow;
    m_hwndParent  = NULL;                   // HWND     m_hwndParent;
                                            //
    m_fCtx        = false;                  // bool     m_fCtx;
                                            // CComBSTR m_bstrCtx;
                                            //
    m_fURL        = false;                  // bool     m_fURL;
                                            // CComBSTR m_bstrURL;
                                            //
    m_fError      = false;                  // bool     m_fError;
    m_clsidError  = CLSID_NULL;             // CLSID    m_clsidError;
}

HRESULT HCAPI::CmdData::Serialize( /*[out]*/ CComBSTR& bstrBLOB )
{
    __HCP_FUNC_ENTRY( "HCAPI::CmdData::Serialize" );

    HRESULT                hr;
    MPC::Serializer_Memory streamMem;
    MPC::Serializer&       stream = streamMem;
    HGLOBAL                hg     = NULL;


    //
    // Dump the state of the object into the serializer.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_clsidCaller );
	 	  
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_fMode       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_dwFlags     );
	 	  
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_fWindow     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream.HWND_write( m_hwndParent ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_fSize       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_lX          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_lY          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_lWidth      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_lHeight     );
	 	  
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_fCtx        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_bstrCtxName );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_bstrCtxInfo );
 	 	  
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_fURL        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_bstrURL     );
 	 	  
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_fError      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << 	 	  m_clsidError  );


    //
    // Copy data into an HGLOBAL.
    //
    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hg = ::GlobalAlloc( GMEM_FIXED, streamMem.GetSize() )));

    ::CopyMemory( hg, streamMem.GetData(), streamMem.GetSize() );


    //
    // Convert to string.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHGlobalToHex( hg, bstrBLOB ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCAPI::CmdData::Unserialize( /*[in]*/ const CComBSTR& bstrBLOB )
{
    __HCP_FUNC_ENTRY( "HCAPI::CmdData::Unserialize" );

    HRESULT                hr;
    MPC::Serializer_Memory streamMem;
    MPC::Serializer&       stream = streamMem;
    HGLOBAL                hg     = NULL;


    //
    // Convert from string.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHexToHGlobal( bstrBLOB, hg ));

    //
    // Copy data from an HGLOBAL.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamMem.SetSize(                     ::GlobalSize( hg ) ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamMem.write  ( ::GlobalLock( hg ), ::GlobalSize( hg ) ));


    //
    // Read the state of the object from the serializer.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_clsidCaller );
		 
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_fMode       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_dwFlags     );
		 
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_fWindow     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream.HWND_read( m_hwndParent ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_fSize       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_lX          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_lY          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_lWidth      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_lHeight     );
		 
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_fCtx        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_bstrCtxName );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_bstrCtxInfo );
		 
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_fURL        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_bstrURL     );
		 
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_fError      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> 		 m_clsidError  );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HCAPI::Locator::Locator()
{
                        // CComPtr<IPCHHelpCenterIPC>   m_ipc;
                        // CComPtr<IRunningObjectTable> m_rt;
                        // CComPtr<IMoniker>            m_moniker;
    m_dwRegister = 0;   // DWORD                        m_dwRegister;
}

HCAPI::Locator::~Locator()
{
    Cleanup();
}

////////////////////

void HCAPI::Locator::Cleanup()
{
    if(m_rt)
    {
        if(m_dwRegister)
        {
            (void)m_rt->Revoke( m_dwRegister );

            m_dwRegister = NULL;
        }
    }

    m_ipc    .Release();
    m_rt     .Release();
    m_moniker.Release();
}

HRESULT HCAPI::Locator::Init( /*[in]*/ REFCLSID clsid, /*[in]*/ IPCHHelpCenterIPC* ipc )
{
    __HCP_FUNC_ENTRY( "HCAPI::Locator::Init" );

    HRESULT hr;


    Cleanup();

    //
    // Get a pointer to the ROT and create a class moniker.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::GetRunningObjectTable( 0, &m_rt ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateClassMoniker( clsid, &m_moniker ));

    //
    // If IPC != NULL, register as provider, otherwise look for a provider.
    //
    if(ipc)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rt->Register( ROTFLAGS_REGISTRATIONKEEPSALIVE, ipc, m_moniker, &m_dwRegister ));
    }
    else
    {
        CComPtr<IUnknown> obj;

        if(SUCCEEDED(m_rt->GetObject( m_moniker, &obj )) && obj)
        {
// BUILD BREAK            __MPC_EXIT_IF_METHOD_FAILS(hr, obj->QueryInterface( IID_IPCHHelpCenterIPC, (void**)&m_ipc ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT HCAPI::Locator::IsOpen( /*[out]*/ bool& fOpen, /*[in]*/ CLSID* pclsid )
{
    __HCP_FUNC_ENTRY( "HCAPI::Locator::IsOpen" );

    HRESULT hr;


    fOpen = false;

    if(m_ipc == NULL)
    {
// BUILD BREAK        __MPC_EXIT_IF_METHOD_FAILS(hr, Init( pclsid ? *pclsid : CLSID_PCHHelpCenterIPC ));
    }

// BUILD BREAK	  if(m_ipc && SUCCEEDED(m_ipc->Ping()))
// BUILD BREAK	  {
// BUILD BREAK		  fOpen = true;
// BUILD BREAK	  }

    hr = S_OK;


// BUILD BREAK    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCAPI::Locator::ExecCommand( /*[out]*/ CmdData& cd )
{
    __HCP_FUNC_ENTRY( "HCAPI::Locator::ExecCommand" );

    HRESULT             hr;
    PROCESS_INFORMATION piProcessInformation;
    STARTUPINFOW        siStartupInfo;
    MPC::NamedMutex     nm( L"PCH_COMSERVER" );
    CComBSTR            bstrBLOB;
    bool                fOpen;


    ::ZeroMemory( (PVOID)&piProcessInformation, sizeof( piProcessInformation ) );
    ::ZeroMemory( (PVOID)&siStartupInfo       , sizeof( siStartupInfo        ) ); siStartupInfo.cb = sizeof( siStartupInfo );


    __MPC_EXIT_IF_METHOD_FAILS(hr, cd.Serialize( bstrBLOB ));


    //
    // Before entrying this section, let's acquire the shared mutex, so only one instance of HelpCtr at a time will execute it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, nm.Acquire( 0 ));

    if(cd.m_fMode)
    {
        if(cd.m_dwFlags & HCAPI_MODE_NEW_INSTANCE)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateGuid( &cd.m_clsidCaller ));
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, IsOpen( fOpen, &cd.m_clsidCaller ));
    if(fOpen)
    {
		//        __MPC_EXIT_IF_METHOD_FAILS(hr, m_ipc->Navigate( bstrBLOB ));
    }
    else
    {
        MPC::wstring strExe( c_HelpCtr ); MPC::SubstituteEnvVariables( strExe );
        int          iRetries = 100;

        strExe += L" -cmd ";
        strExe += SAFEBSTR( bstrBLOB );

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateProcessW(         NULL                 ,
                                                               (LPWSTR)strExe.c_str()       ,
                                                                       NULL                 ,
                                                                       NULL                 ,
                                                                       FALSE                ,
                                                                       NORMAL_PRIORITY_CLASS,
                                                                       NULL                 ,
                                                                       NULL                 ,
                                                                      &siStartupInfo        ,
                                                                      &piProcessInformation ));

        while(iRetries--)
        {
            ::Sleep( 100 );

            if(SUCCEEDED(Init( cd.m_clsidCaller ))) break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, IsOpen( fOpen, &cd.m_clsidCaller ));
    }

    //
    // If successful, clean the command, but not the caller, it's used to located the same instance of the Help Center.
    //
    cd.m_fSize   = false;
    cd.m_fMode   = false;
    cd.m_fWindow = false;
    cd.m_fCtx    = false;
    cd.m_fURL    = false;
    cd.m_fError  = false;
    hr           = S_OK;


    __HCP_FUNC_CLEANUP;

    if(piProcessInformation.hProcess) ::CloseHandle( piProcessInformation.hProcess );
    if(piProcessInformation.hThread ) ::CloseHandle( piProcessInformation.hThread  );

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCAPI::Locator::PopUp()
{
    __HCP_FUNC_ENTRY( "HCAPI::Locator::PopUp" );

    HRESULT hr;
    bool    fOpen;


    __MPC_EXIT_IF_METHOD_FAILS(hr, IsOpen( fOpen ));
    if(fOpen == false)
    {
        CmdData cd;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ExecCommand( cd ));
    }

// BUILD BREAK    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ipc->Popup());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCAPI::Locator::Close()
{
    __HCP_FUNC_ENTRY( "HCAPI::Locator::Close" );

    HRESULT hr;
    bool    fOpen;


    __MPC_EXIT_IF_METHOD_FAILS(hr, IsOpen( fOpen ));
    if(fOpen)
    {
// BUILD BREAK        __MPC_EXIT_IF_METHOD_FAILS(hr, m_ipc->Close());

        m_ipc.Release();
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCAPI::Locator::WaitForTermination( /*[in]*/ DWORD dwTimeout )
{
    __HCP_FUNC_ENTRY( "HCAPI::Locator::WaitForTermination" );

    HRESULT hr;
    bool    fOpen;


    //
    // Polling implementation...
    //
    while(1)
    {
		DWORD dwWait;

        __MPC_EXIT_IF_METHOD_FAILS(hr, IsOpen( fOpen ));

        if(fOpen == false) break;

		if(dwTimeout == 0)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_TIMEOUT);
		}

		if(dwTimeout == INFINITE)
		{
			::Sleep( 100 );
		}
		else
		{
			dwWait = min( dwTimeout, 10 );

			::Sleep( dwWait );

			dwTimeout -= dwWait;
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\client\resource.h ===
//******************************************************************************
// 
// Copyright (c) 2000 Microsoft Corporation
// 
// Module Name:
// 	   resource.h
// 
// Abstract:
// 	   Resource file for Help Center Launch API.
// 
// Revision History:
// 	   Davide Massarenti   (Dmassare)  03/14/2000
// 		   created
// 
//******************************************************************************

#define IDR_HCAPI 100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\lib\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  04/07/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>
#include <MPC_logging.h>


//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// From HCApi.h
//
#include <HCApi.h>


#include <HCApiLib.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\client\helphostproxy.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpHostProxy.h

Abstract:
    This file contains the declaration of the classes for the IHelpHost*.

Revision History:
    Davide Massarenti   (dmassare) 11/03/2000
        modified

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPHOSTPROXY_H___)
#define __INCLUDED___PCH___HELPHOSTPROXY_H___

/////////////////////////////////////////////////////////////////////////////

#include <dispex.h>
#include <ocmm.h>

namespace HelpHostProxy
{
    //
    // Forward declarations.
    //
    class Main;
    class Panes;
    class Pane;
    class Window;

    ////////////////////////////////////////////////////////////////////////////////

    class ATL_NO_VTABLE Main :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public CComCoClass<Main, &CLSID_PCHHelpHost>,
        public IDispatchImpl<IHelpHost, &IID_IHelpHost, &LIBID_HCLaunchLIB>
    {
    public:
        CComPtr<IPCHHelpHost>         	 m_real;
   
        CComPtr<Window>               	 m_subWindow;
        CComPtr<Panes>                	 m_subPanes;

        CComQIPtr<IPCHHelpHostEvents>    m_Events;
        CComQIPtr<IPCHHelpHostNavEvents> m_EventsNav;

    public:
	DECLARE_REGISTRY_RESOURCEID(IDR_HCAPI)

	DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(Main)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHelpHost)
    END_COM_MAP()

        Main();
        virtual ~Main();

		HRESULT FinalConstruct();
		void    FinalRelease  ();

        HRESULT Initialize();
        void    Passivate ();

        ////////////////////

        STDMETHOD(put_FilterName)( /*[in]         */ BSTR   Value );
        STDMETHOD(get_FilterName)( /*[out, retval]*/ BSTR *pValue );

        STDMETHOD(get_Namespace       )( /*[out, retval]*/ BSTR             *pValue );
        STDMETHOD(get_Session         )( /*[out, retval]*/ IDispatch*       *pValue );
        STDMETHOD(get_FilterExpression)( /*[out, retval]*/ BSTR             *pValue );
        STDMETHOD(get_CurrentUrl      )( /*[out, retval]*/ BSTR             *pValue );

        STDMETHOD(get_Panes           )( /*[out, retval]*/ IHelpHostPanes*  *pValue );
        STDMETHOD(get_HelpHostWindow  )( /*[out, retval]*/ IHelpHostWindow* *pValue );

        STDMETHOD(OpenNamespace)( /*[in]*/ BSTR newNamespace, /*[in]*/ BSTR filterName );

        STDMETHOD(DisplayTopicFromURL)( /*[in]*/ BSTR url, /*[in]*/ VARIANT options );

        STDMETHOD(DisplayResultsFromQuery)( /*[in]*/ BSTR query, /*[in]*/ BSTR navMoniker, /*[in]*/ VARIANT options );

        STDMETHOD(ShowPane)( /*[in]*/ BSTR paneName, /*[in]*/ BSTR query, /*[in]*/ BSTR navMoniker, /*[in]*/ VARIANT options );

        STDMETHOD(Terminate)();


        //
        // Methods on the stub.
        //
        //STDMETHOD(PRIV_Init)( /*[in]*/ IUnknown* pCaller );
    };

    ////////////////////////////////////////////////////////////////////////////////

    class ATL_NO_VTABLE Window :
        public CComObjectRootEx<CComSingleThreadModel>,
        public IDispatchImpl<IHelpHostWindow, &IID_IHelpHostWindow, &LIBID_HCLaunchLIB>
    {
    public:
        CComPtr<IPCHHelpHostWindow> m_real;

        Main* 						m_Main;
        long  						m_ParentWindow;

    public:
    BEGIN_COM_MAP(Window)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHelpHostWindow)
    END_COM_MAP()

        Window();
        virtual ~Window();

        HRESULT Initialize( /*[in]*/ Main* parent );
        void    Passivate (                       );

        ////////////////////

        STDMETHOD(put_ParentWindow)( /*[in         ]*/ long   hWND );
        STDMETHOD(get_ParentWindow)( /*[out, retval]*/ long *phWND );

        STDMETHOD(put_UILanguage)( /*[in         ]*/ long           LCID  );
        STDMETHOD(get_UILanguage)( /*[out, retval]*/ long         *pLCID  );

        STDMETHOD(put_Visible   )( /*[in         ]*/ VARIANT_BOOL   Value );
        STDMETHOD(get_Visible   )( /*[out, retval]*/ VARIANT_BOOL *pValue );

        STDMETHOD(get_OriginX)( /*[out, retval]*/ long *pValue );
        STDMETHOD(get_OriginY)( /*[out, retval]*/ long *pValue );
        STDMETHOD(get_Width  )( /*[out, retval]*/ long *pValue );
        STDMETHOD(get_Height )( /*[out, retval]*/ long *pValue );

        STDMETHOD(MoveWindow)( /*[in]*/ long originX, /*[in]*/ long originY, /*[in]*/ long width, /*[in]*/ long height );

        STDMETHOD(WaitForTermination)( /*[in]*/ long timeOut );


        //
        // Methods on the stub.
        //
        // STDMETHOD(get_PRIV_Window)( /*[out, retval]*/ long *phWND );
    };

    ////////////////////////////////////////////////////////////////////////////////

    typedef MPC::CComCollection<IHelpHostPanes, &LIBID_HCLaunchLIB, CComSingleThreadModel> BasePanes;

    class ATL_NO_VTABLE Panes :
        public BasePanes
    {
    public:
        typedef BasePanes            super;
        typedef std::list< Pane* >   List;
        typedef List::iterator       Iter;
        typedef List::const_iterator IterConst;

        CComPtr<IPCHHelpHostPanes> m_real;

        Main* 					   m_Main;
        List  					   m_Panes;

    public:
    BEGIN_COM_MAP(Panes)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHelpHostPanes)
    END_COM_MAP()

        Panes();
        virtual ~Panes();

        HRESULT Initialize( /*[in]*/ Main* parent );
        void    Passivate (                       );

        HRESULT GetPane( /*[in]*/ LPCWSTR szName, /*[out]*/ Pane* *pVal );

        ////////////////////

        //
        // This is a trick!
        //
        // MPC::CComCollection defined a "get_Item" method that has a different signature from the
        // one in IHelpHostPanes, so it's not callable from scripting. Instead, this method will
        // be called.
        //
        STDMETHOD(get_Item)( /*[in]*/ VARIANT Index, /*[out]*/ VARIANT* pvar );
    };

    ////////////////////////////////////////////////////////////////////////////////

    class ATL_NO_VTABLE Pane :
        public CComObjectRootEx<CComSingleThreadModel>,
        public IDispatchImpl<IHelpHostPane, &IID_IHelpHostPane, &LIBID_HCLaunchLIB>
    {
    public:
        CComPtr<IPCHHelpHostPane> m_real;

        Main*         			  m_Main;
        CComBSTR      			  m_bstrName;
        CComBSTR      			  m_bstrMoniker;
        VARIANT_BOOL  			  m_fVisible;

    public:
    BEGIN_COM_MAP(Pane)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHelpHostPane)
    END_COM_MAP()

        Pane();
        virtual ~Pane();

        HRESULT Initialize( /*[in]*/ Main* parent );
        void    Passivate (                       );

        ////////////////////

        STDMETHOD(put_Visible   )( /*[in         ]*/ VARIANT_BOOL   Value );
        STDMETHOD(get_Visible   )( /*[out, retval]*/ VARIANT_BOOL *pValue );

        STDMETHOD(put_NavMoniker)( /*[in         ]*/ BSTR   Value );
        STDMETHOD(get_NavMoniker)( /*[out, retval]*/ BSTR *pValue );

        STDMETHOD(get_Name      )( /*[out, retval]*/ BSTR         *pValue );
        STDMETHOD(get_CurrentUrl)( /*[out, retval]*/ BSTR         *pValue );
        STDMETHOD(get_WebBrowser)( /*[out, retval]*/ IDispatch*   *pValue );

        STDMETHOD(DisplayTopicFromURL)( /*[in]*/ BSTR url, /*[in]*/ VARIANT options );

        STDMETHOD(DisplayResultsFromQuery)( /*[in]*/ BSTR query, /*[in]*/ VARIANT options );

        STDMETHOD(Sync)( /*[in]*/ BSTR url, /*[in]*/ VARIANT options );
    };
};

#endif // !defined(__INCLUDED___PCH___HELPHOSTPROXY_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\client\impl.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    impl.cpp

Abstract:
    This file contains the implementation of the CPCHLaunch class.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////

HelpHostProxy::Main::Main()
{
    // CComPtr<IPCHHelpHost>            m_real;
    //
    // CComPtr<Window>                  m_subWindow;
    // CComPtr<Panes>                   m_subPanes;
    //
    // CComQIPtr<IPCHHelpHostEvents>    m_Events;
    // CComQIPtr<IPCHHelpHostNavEvents> m_EventsNav;
}


HelpHostProxy::Main::~Main()
{
    Passivate();
}

HRESULT HelpHostProxy::Main::FinalConstruct()
{
    return Initialize();
}

void HelpHostProxy::Main::FinalRelease()
{
    Passivate();
}

////////////////////

HRESULT HelpHostProxy::Main::Initialize()
{
    __HCP_FUNC_ENTRY( "HelpHostProxy::Main::Initialize" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, HCAPI::OpenConnection( m_real ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_subWindow )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_subWindow->Initialize( this ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_subPanes  )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_subPanes ->Initialize( this ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void HelpHostProxy::Main::Passivate()
{
    if(m_subPanes ) { m_subPanes ->Passivate(); m_subPanes .Release(); }
    if(m_subWindow) { m_subWindow->Passivate(); m_subWindow.Release(); }

    m_Events   .Release();
    m_EventsNav.Release();

    m_real     .Release();
}

////////////////////

STDMETHODIMP HelpHostProxy::Main::put_FilterName( /*[in] */ BSTR Value )
{
    return m_real ? m_real->put_FilterName( Value ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::get_FilterName( /*[out, retval]*/ BSTR *pValue )
{
    if(pValue) *pValue = NULL;

    return m_real ? m_real->get_FilterName( pValue ) : E_FAIL;
}


STDMETHODIMP HelpHostProxy::Main::get_Namespace( /*[out, retval]*/ BSTR *pValue )
{
    if(pValue) *pValue = NULL;

    return m_real ? m_real->get_Namespace( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::get_Session( /*[out, retval]*/ IDispatch* *pValue )
{
    if(pValue) *pValue = NULL;

    return m_real ? m_real->get_Session( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::get_FilterExpression( /*[out, retval]*/ BSTR *pValue )
{
    if(pValue) *pValue = NULL;

    return m_real ? m_real->get_FilterExpression( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::get_CurrentUrl( /*[out, retval]*/ BSTR *pValue )
{
    if(pValue) *pValue = NULL;

    return m_real ? m_real->get_CurrentUrl( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::get_Panes( /*[out, retval]*/ IHelpHostPanes* *pValue )
{
    if(pValue) *pValue = NULL;

    return m_subPanes ? m_subPanes.QueryInterface( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::get_HelpHostWindow( /*[out, retval]*/ IHelpHostWindow* *pValue )
{
    if(pValue) *pValue = NULL;

    return m_subWindow ? m_subWindow.QueryInterface( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::OpenNamespace( /*[in]*/ BSTR newNamespace, /*[in]*/ BSTR filterName )
{
    return m_real ? m_real->OpenNamespace( newNamespace, filterName ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::DisplayTopicFromURL( /*[in]*/ BSTR url, /*[in]*/ VARIANT options )
{
    return m_real ? m_real->DisplayTopicFromURL( url, options ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::DisplayResultsFromQuery( /*[in]*/ BSTR query, /*[in]*/ BSTR navMoniker, /*[in]*/ VARIANT options )
{
    return m_real ? m_real->DisplayResultsFromQuery( query, navMoniker, options ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::ShowPane( /*[in]*/ BSTR paneName, /*[in]*/ BSTR query, /*[in]*/ BSTR navMoniker, /*[in]*/ VARIANT options )
{
    return m_real ? m_real->ShowPane( paneName, query, navMoniker, options ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Main::Terminate()
{
    return m_real ? m_real->Terminate() : E_FAIL;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HelpHostProxy::Window::Window()
{
                           // CComPtr<IPCHHelpHostWindow> m_real;
                           //
    m_Main         = NULL; // Main*                       m_Main;
    m_ParentWindow = 0;    // long                        m_ParentWindow;
}

HelpHostProxy::Window::~Window()
{
    Passivate();
}

HRESULT HelpHostProxy::Window::Initialize( /*[in]*/ Main* main )
{
    m_Main = main;

    return S_OK;
}

void HelpHostProxy::Window::Passivate()
{
	m_real.Release();

    m_Main         = NULL;
    m_ParentWindow = 0;
}

////////////////////

STDMETHODIMP HelpHostProxy::Window::put_ParentWindow( /*[in]*/ long hWND )
{
    m_ParentWindow = hWND;

    return m_real ? m_real->put_ParentWindow( hWND ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Window::get_ParentWindow( /*[out, retval]*/ long *phWND )
{
    if(phWND == NULL) return E_POINTER;

    *phWND = m_ParentWindow;

    return S_OK;
}


STDMETHODIMP HelpHostProxy::Window::put_UILanguage( /*[in]*/ long LCID )
{
    return m_real ? m_real->put_UILanguage( LCID ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Window::get_UILanguage( /*[out, retval]*/ long *pLCID )
{
	if(pLCID) *pLCID = 0;

    return m_real ? m_real->get_UILanguage( pLCID ) : E_FAIL;
}


STDMETHODIMP HelpHostProxy::Window::put_Visible( /*[in]*/ VARIANT_BOOL Value )
{
    return m_real ? m_real->put_Visible( Value ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Window::get_Visible( /*[out, retval]*/ VARIANT_BOOL *pValue )
{
    if(pValue) *pValue = VARIANT_FALSE;

    return m_real ? m_real->get_Visible( pValue ) : E_FAIL;
}


STDMETHODIMP HelpHostProxy::Window::get_OriginX( /*[out, retval]*/ long *pValue )
{
    if(pValue) *pValue = 0;

    return m_real ? m_real->get_OriginX( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Window::get_OriginY( /*[out, retval]*/ long *pValue )
{
    if(pValue) *pValue = 0;

    return m_real ? m_real->get_OriginY( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Window::get_Width( /*[out, retval]*/ long *pValue )
{
    if(pValue) *pValue = 0;

    return m_real ? m_real->get_Width( pValue ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Window::get_Height( /*[out, retval]*/ long *pValue )
{
    if(pValue) *pValue = 0;

    return m_real ? m_real->get_Height( pValue ) : E_FAIL;
}


STDMETHODIMP HelpHostProxy::Window::MoveWindow( /*[in]*/ long originX, /*[in]*/ long originY, /*[in]*/ long width, /*[in]*/ long height )
{
    return m_real ? m_real->MoveWindow( originX, originY, width, height ) : E_FAIL;
}

STDMETHODIMP HelpHostProxy::Window::WaitForTermination( /*[in]*/ long timeOut )
{
	return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////

HelpHostProxy::Panes::Panes()
{
    m_Main = NULL; // Main* m_Main;
                     // List  m_Panes;
}

HelpHostProxy::Panes::~Panes()
{
    Passivate();
}

HRESULT HelpHostProxy::Panes::Initialize( /*[in]*/ Main* main )
{
    __HCP_FUNC_ENTRY( "HelpHostProxy::Panes::Initialize" );

    HRESULT hr;
    int     i;


    m_Main = main;

//	  for(i=0; i<ARRAYSIZE(c_Panes); i++)
//	  {
//		  Pane* pVal;
//
//		  __MPC_EXIT_IF_METHOD_FAILS(hr, c_Panes[i].pfn( pVal ) ); m_Panes.push_back( pVal );
//
//		  pVal->m_bstrName = c_Panes[i].szName;
//
//		  __MPC_EXIT_IF_METHOD_FAILS(hr, pVal->Initialize( m_Main ));
//
//		  __MPC_EXIT_IF_METHOD_FAILS(hr, AddItem( pVal ));
//	  }

    hr = S_OK;


	//    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void HelpHostProxy::Panes::Passivate()
{
    MPC::ReleaseAll( m_Panes );
}

HRESULT HelpHostProxy::Panes::GetPane( /*[in]*/ LPCWSTR szName, /*[out]*/ Pane* *pVal )
{
    __HCP_FUNC_ENTRY( "HelpHostProxy::Panes::GetPane" );

    HRESULT hr;
    Iter    it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    for(it=m_Panes.begin(); it!=m_Panes.end(); it++)
    {
        Pane* pane = *it;

        if(!MPC::StrICmp( szName, pane->m_bstrName ))
        {
            *pVal = pane; pane->AddRef();
            break;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP HelpHostProxy::Panes::get_Item( /*[in]*/ VARIANT Index, /*[out]*/ VARIANT* pvar )
{
    __HCP_FUNC_ENTRY( "HelpHostProxy::Panes::get_Item" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pvar);
    __MPC_PARAMCHECK_END();

    if(Index.vt == VT_BSTR)
    {
        CComPtr<Pane> pane;
        CComVariant   v;

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetPane( Index.bstrVal, &pane ));

        v = pane;

        __MPC_EXIT_IF_METHOD_FAILS(hr, v.Detach( pvar ));
    }
    else if(Index.vt == VT_I4)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, super::get_Item( Index.iVal, pvar ));
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HelpHostProxy::Pane::Pane()
{
    m_Main   = NULL;          // Main*         m_Main;
                                //
                                // CComBSTR      m_bstrName;
                                // CComBSTR      m_bstrMoniker;
    m_fVisible = VARIANT_FALSE; // VARIANT_BOOL  m_fVisible;
}

HelpHostProxy::Pane::~Pane()
{
    Passivate();
}

HRESULT HelpHostProxy::Pane::Initialize( /*[in]*/ Main* main )
{
    m_Main = main;

    return S_OK;
}

void HelpHostProxy::Pane::Passivate()
{
}

////////////////////

STDMETHODIMP HelpHostProxy::Pane::put_Visible( /*[in]*/ VARIANT_BOOL Value )
{
    return S_FALSE;
}

STDMETHODIMP HelpHostProxy::Pane::get_Visible( /*[out, retval]*/ VARIANT_BOOL *pValue )
{
    if(pValue == NULL) return E_POINTER;

    *pValue = m_fVisible;

    return S_OK;
}


STDMETHODIMP HelpHostProxy::Pane::put_NavMoniker( /*[in]*/ BSTR Value )
{
    m_bstrMoniker = Value;

    return S_OK;
}

STDMETHODIMP HelpHostProxy::Pane::get_NavMoniker( /*[out, retval]*/ BSTR *pValue )
{
    return MPC::GetBSTR( m_bstrMoniker, pValue );
}


STDMETHODIMP HelpHostProxy::Pane::get_Name( /*[out, retval]*/ BSTR *pValue )
{
    return MPC::GetBSTR( m_bstrName, pValue );
}

STDMETHODIMP HelpHostProxy::Pane::get_CurrentUrl( /*[out, retval]*/ BSTR *pValue )
{
    return MPC::GetBSTR( NULL, pValue );
}

STDMETHODIMP HelpHostProxy::Pane::get_WebBrowser( /*[out, retval]*/ IDispatch* *pValue )
{
    if(pValue == NULL) return E_POINTER;

    *pValue = NULL;

    return S_OK;
}


STDMETHODIMP HelpHostProxy::Pane::DisplayTopicFromURL( /*[in]*/ BSTR url, /*[in]*/ VARIANT options )
{
    return S_FALSE;
}

STDMETHODIMP HelpHostProxy::Pane::DisplayResultsFromQuery( /*[in]*/ BSTR query, /*[in]*/ VARIANT options )
{
    return S_FALSE;
}

STDMETHODIMP HelpHostProxy::Pane::Sync( /*[in]*/ BSTR url, /*[in]*/ VARIANT options )
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\client\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>

extern CComModule _Module;

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <resource.h>


#include <HCApiLib.h>

#include <HelpHostProxy.h>

#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\client\dllmain.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    dllmain.cpp

Abstract:
    Implementation of DLL Exports.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "stdafx.h"
#include <initguid.h>

#include <HelpCenterTypeLib_i.c>
#include <HCApi_i.c>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PCHHelpHost, HelpHostProxy::Main)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if(dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HCLaunchLIB);

        DisableThreadLibraryCalls( hInstance );
    }
    else if(dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\include\hcapilib.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HCAPIlib.h

Abstract:
    This file contains the declaration of the common code for the
	Help Center Launch API.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HCAPILIB_H___)
#define __INCLUDED___PCH___HCAPILIB_H___

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// From HCApi.idl
//
#include <HCApi.h>

namespace HCAPI
{
	HRESULT OpenConnection( /*[out]*/ CComPtr<IPCHHelpHost>& ipc );
};

#endif // !defined(__INCLUDED___PCH___HCAPILIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcdetect\hcdetect.h ===
/////////////////////////////////////////////////////////////////////////////
// WUDetect.h
//
// Copyright (C) Microsoft Corp. 1998
// All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
//
// Description:
//   Global Header
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <ole2.h>
#include <objbase.h>
#include <io.h>

#include <inseng.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcdetect\hcdetect.cpp ===
/////////////////////////////////////////////////////////////////////////////
// HCDetect.cpp
//
// Copyright (C) Microsoft Corp. 1999
// All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
//
// Description:
//   DLL loaded by the install engine that exposes entry points
//   that can determines the installation status of legacy or complex
//   components.  The dll name and entry points are specified for a
//   component in the CIF file.
/////////////////////////////////////////////////////////////////////////////

#include <atlbase.h>
#include "hcdetect.h"
#include <initguid.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>
#include <HelpServiceTypeLib_i.c>

//
// Defines
//
#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')
#define MAX_ID      1024

/////////////////////////////////////////////////////////////////////////////

HRESULT getVersion( BSTR      bstrVendorID  ,
                    BSTR      bstrProductID ,
                    CComBSTR& bstrValue     )
{
    TCHAR                     szWinDir[MAX_PATH];
    CComVariant               cvVersionPathname;
    CComPtr <IXMLDOMDocument> pXMLDoc;
    CComPtr <IXMLDOMElement>  pXMLRootElem;
    CComPtr <IXMLDOMNode>     pXMLVersionNode;

    //
    // get windows directory
    //
    if(::GetWindowsDirectory( szWinDir, MAX_PATH ) == 0)
    {
        return E_FAIL;
    }

    _tcscat( szWinDir, "\\pchealth\\helpctr\\config\\pchver.xml" );

    if(SUCCEEDED(::CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&pXMLDoc )))
    {
        CComVariant  cvVersionPathname = szWinDir;
        VARIANT_BOOL vBool;

        if(SUCCEEDED(pXMLDoc->load( cvVersionPathname, &vBool )) && vBool == VARIANT_TRUE)
        {
            if(SUCCEEDED(pXMLDoc->get_documentElement( &pXMLRootElem )) && pXMLRootElem)
            {
                CComBSTR bstrQuery;

                bstrQuery.Append( "VENDORS/VENDOR[@ID=\"" );
                bstrQuery.Append( bstrVendorID            );
                bstrQuery.Append( "\"]/PRODUCT[@ID=\""    );
                bstrQuery.Append( bstrProductID           );
                bstrQuery.Append( "\"]/VERSION"           );

                if(SUCCEEDED(pXMLRootElem->selectSingleNode( bstrQuery, &pXMLVersionNode )))
                {
                    CComQIPtr<IXMLDOMElement> elem = pXMLVersionNode;
                    CComVariant               vValue;

                    if(elem && SUCCEEDED(elem->getAttribute( CComBSTR("VALUE"), &vValue )))
                    {
                        vValue.ChangeType( VT_BSTR );
                        bstrValue = vValue.bstrVal;
                        return S_OK;
                    }
                }
            }
        }
    }

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// fCompareVersion
//
// Returns: 1,0,-1 depending on whether dwVersion1 is greater than, equal, or
// less than dwVersion2.
/////////////////////////////////////////////////////////////////////////////

inline int nCompareVersion(IN  DWORD dwVer1,
                           IN  DWORD dwBuild1,
                           IN  DWORD dwVer2,
                           IN  DWORD dwBuild2)
{
    int nResult = 0;

    if ( dwVer1 > dwVer2 )
    {
        nResult = 1;
    }
    else if ( dwVer1 < dwVer2 )
    {
        nResult = -1;
    }
    else if ( dwBuild1 > dwBuild2 ) // dwVer1 == dwVer2
    {
        nResult = 1;
    }
    else if ( dwBuild1 < dwBuild2 ) // dwVer1 == dwVer2
    {
        nResult = -1;
    }

    return nResult;
}

/////////////////////////////////////////////////////////////////////////////
// ConvertDotVersionStrToDwords
/////////////////////////////////////////////////////////////////////////////
bool fConvertDotVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
    DWORD grVerFields[4] = {0,0,0,0};
    char *pch = pszVer;

    if (!pszVer || !pdwVer || !pdwBuild)
        return false;

    grVerFields[0] = atol(pch);

    for ( int index = 1; index < 4; index++ )
    {
        while ( IsDigit(*pch) && (*pch != '\0') )
            pch++;

        if ( *pch == '\0' )
            break;
        pch++;

        grVerFields[index] = atol(pch);
   }

   *pdwVer = (grVerFields[0] << 16) + grVerFields[1];
   *pdwBuild = (grVerFields[2] << 16) + grVerFields[3];

   return true;
}

/////////////////////////////////////////////////////////////////////////////
// GetCifEntry
//   Get an entry from the CIF file.
//
// Comments :
//   We get the value differently depending on whether we are being
//   called by IE 4 or IE 5 Active Setup.
/////////////////////////////////////////////////////////////////////////////

inline bool FGetCifEntry(DETECTION_STRUCT *pDetection,
                         char *pszParamName,
                         char *pszParamValue,
                         DWORD cbParamValue)
{
    return (ERROR_SUCCESS == pDetection->pCifComp->GetCustomData(pszParamName,
                                                        pszParamValue,
                                                        cbParamValue));
}


/////////////////////////////////////////////////////////////////////////////
// RegKeyExists (EXPORT)
//   This API will determine if an application exists based on the
//   existence of a registry key and perhaps a value.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI HelpPkgVersion(DETECTION_STRUCT *pDetection)
{
    USES_CONVERSION;
    HRESULT     hr;
    DWORD       dwInstallStatus = DET_INSTALLED;
    TCHAR       szVendorID[MAX_ID];
    TCHAR       szProductID[MAX_ID];
    TCHAR       szVersion[MAX_PATH];
    IPCHUpdate  *pPCHUpdate = NULL;

    //
    // Initialize COM just in case
    //
    ::CoInitialize(NULL);

    //
    // make sure the struct is of the expected size
    //
    if ((pDetection->dwSize >= sizeof(DETECTION_STRUCT)))
    {
        CComBSTR    bstrLatestVersion;
        DWORD       dwCurrVersion, dwCurrBuild;
        DWORD       dwLatestVersion, dwLatestBuild;

        //
        // get the version number from the components section of the CIF file.
        //
        if (!((FGetCifEntry(pDetection, "VendorID", szVendorID, sizeof(szVendorID))) &&
            (FGetCifEntry(pDetection, "ProductID", szProductID, sizeof(szProductID))) &&
            (FGetCifEntry(pDetection, "Version", szVersion, sizeof(szVersion)))))
        {
            goto end;
        }

        //
        // Convert it to build and version number
        //
        fConvertDotVersionStrToDwords(szVersion, &dwCurrVersion, &dwCurrBuild);

//		  //
//		  // create the IPCHUpdate object
//		  //
//		  if (FAILED(hr = CoCreateInstance(CLSID_PCHUpdate, NULL, CLSCTX_LOCAL_SERVER, IID_IPCHUpdate, (void**)&pPCHUpdate)))
//		  {
//			  goto end;
//		  }
//
//		  //
//		  // call to get the version number
//		  //
//		  if (FAILED(pPCHUpdate->LatestVersion(CComBSTR(szVendorID), CComBSTR(szProductID), &bstrLatestVersion)))
//		  {
//			  goto end;
//		  }
		if(FAILED(getVersion( CComBSTR( szVendorID ), CComBSTR( szProductID ), bstrLatestVersion )))
		{
            dwInstallStatus = DET_NOTINSTALLED;
			goto end;
		}

        //
        // check if there is a version number, if not, return as not installed
        //
        if (bstrLatestVersion.Length() == 0)
        {
            dwInstallStatus = DET_NOTINSTALLED;
            goto end;
        }

        //
        // Convert it to build and version number
        //
        fConvertDotVersionStrToDwords(OLE2A(bstrLatestVersion), &dwLatestVersion, &dwLatestBuild);

        //
        // Compare versions, recommend that it is not installed only if current version
        // is greater than latest version installed on the client machine
        //
        if (nCompareVersion(dwCurrVersion, dwCurrBuild, dwLatestVersion, dwLatestBuild) == 1)
        {
            dwInstallStatus = DET_NOTINSTALLED;
        }
    }

end:
    //
    // Cleanup
    //
    if (pPCHUpdate)
        pPCHUpdate->Release();

    ::CoUninitialize();

    return dwInstallStatus;
}

//DWORD WINAPI Test()
//{
//	  CComBSTR bstrVendorID  = "CN=Microsoft Corporation,L=Redmond,S=Washington,C=US";
//	  CComBSTR bstrProductID = "Microsoft Core Help Center Content";
//	  CComBSTR bstrValue;
//	  HRESULT  hr;
//
//	  ::CoInitialize(NULL);
//
//	  hr = getVersion( bstrVendorID, bstrProductID, bstrValue );
//
//	  ::CoUninitialize();
//
//	  return hr;
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcapi2\lib\lib.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    lib.cpp

Abstract:
    This file contains the implementation of the HCApi Library.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_HelpCtr[] = HC_ROOT_HELPSVC_BINARIES L"\\HelpCtr.exe";

////////////////////////////////////////////////////////////////////////////////

HRESULT HCAPI::OpenConnection( /*[out]*/ CComPtr<IPCHHelpHost>& ipc )
{
    __HCP_FUNC_ENTRY( "HCAPI::OpenConnection" );

    HRESULT             hr;
    PROCESS_INFORMATION piProcessInformation;
    STARTUPINFOW        siStartupInfo;
	CLSID               clsidCaller;


    ::ZeroMemory( (PVOID)&piProcessInformation, sizeof( piProcessInformation ) );
    ::ZeroMemory( (PVOID)&siStartupInfo       , sizeof( siStartupInfo        ) ); siStartupInfo.cb = sizeof( siStartupInfo );


	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateGuid( &clsidCaller ));


	//
	// Create the process, passing the clsid to locate the IPCHHelpHost object. Try contacting the process for 10 seconds, then quit.
	//
	{
		CComBSTR     bstrCaller( clsidCaller );
        MPC::wstring strExe    ( c_HelpCtr ); MPC::SubstituteEnvVariables( strExe );
        int          iRetries = 100;

        strExe += L" -Controlled ";
        strExe += SAFEBSTR( bstrCaller );

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateProcessW(         NULL                 ,
                                                               (LPWSTR)strExe.c_str()       ,
                                                                       NULL                 ,
                                                                       NULL                 ,
                                                                       FALSE                ,
                                                                       NORMAL_PRIORITY_CLASS,
                                                                       NULL                 ,
                                                                       NULL                 ,
                                                                      &siStartupInfo        ,
                                                                      &piProcessInformation ));

        while(iRetries--)
        {
			CComPtr<IRunningObjectTable> rt;
			CComPtr<IMoniker>            moniker;
			CComPtr<IUnknown>            obj;

            ::Sleep( 100 );

			__MPC_EXIT_IF_METHOD_FAILS(hr, ::GetRunningObjectTable( 0, &rt                ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateClassMoniker   ( clsidCaller, &moniker ));

			if(SUCCEEDED(rt->GetObject( moniker, &obj )) && obj)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, obj.QueryInterface( &ipc ));
			}
        }

    }

    hr = REGDB_E_CLASSNOTREG;


    __HCP_FUNC_CLEANUP;

    if(piProcessInformation.hProcess) ::CloseHandle( piProcessInformation.hProcess );
    if(piProcessInformation.hThread ) ::CloseHandle( piProcessInformation.hThread  );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\include\debug.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Debug.h

Abstract:
    This file contains the declaration of debugging stuff.

Revision History:
    Davide Massarenti   (dmassare) 10/31/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___DEBUG_H___)
#define __INCLUDED___PCH___DEBUG_H___

#ifdef DEBUG
#undef  HSS_PERFORMANCEDUMP
#define HSS_PERFORMANCEDUMP
#endif


#define DEBUG_PERF_BASIC         0x00000001
#define DEBUG_PERF_PROTOCOL      0x00000002
#define DEBUG_PERF_PROTOCOL_READ 0x00000004
#define DEBUG_PERF_MARS          0x00000008
#define DEBUG_PERF_EVENTS_IN     0x00000010
#define DEBUG_PERF_EVENTS_OUT    0x00000020
#define DEBUG_PERF_PROXIES       0x00000040
#define DEBUG_PERF_QUERIES       0x00000080
#define DEBUG_PERF_CACHE_L1      0x00000100
#define DEBUG_PERF_CACHE_L2      0x00000200
#define DEBUG_PERF_HELPSVC       0x00000400
#define DEBUG_PERF_HELPHOST      0x00000800

#ifdef HSS_PERFORMANCEDUMP

void DEBUG_AppendPerf( DWORD mode, LPCSTR  szMessageFmt, ... );
void DEBUG_AppendPerf( DWORD mode, LPCWSTR szMessageFmt, ... );

void DEBUG_DumpPerf  ( LPCWSTR szFile );

#else

inline void DEBUG_AppendPerf( DWORD mode, LPCSTR  szMessageFmt, ... ) {};
inline void DEBUG_AppendPerf( DWORD mode, LPCWSTR szMessageFmt, ... ) {};

inline void DEBUG_DumpPerf( LPCWSTR szFile ) {};

#endif

////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

void DebugLog( LPCSTR  szMessageFmt, ... );
void DebugLog( LPCWSTR szMessageFmt, ... );

#else

inline void DebugLog( LPCSTR  szMessageFmt, ... ) {}
inline void DebugLog( LPCWSTR szMessageFmt, ... ) {}

#endif

void WindowDetours_Setup ();
void WindowDetours_Remove();

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___DEBUG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\hcdetect\test\hcdettest.cpp ===
// Test.cpp : Defines the entry point for the console application.
//

#include <stdio.h>
#include <windows.h>
#include <ole2.h>
#include <inseng.h>

#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')

//--------------------------------------------------------------------------
// ConvertDotVersionStrToDwords
//--------------------------------------------------------------------------

bool fConvertDotVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
	DWORD grVerFields[4] = {0,0,0,0};
    char *pch = pszVer;

	grVerFields[0] = atol(pch);

	for ( int index = 1; index < 4; index++ )
	{
		while ( IsDigit(*pch) && (*pch != '\0') )
			pch++;

		if ( *pch == '\0' )
			break;
		pch++;
	
		grVerFields[index] = atol(pch);
   }

   *pdwVer = (grVerFields[0] << 16) + grVerFields[1];
   *pdwBuild = (grVerFields[2] << 16) + grVerFields[3];

   return true;
}

//--------------------------------------------------------------------------
// GetStringField2
//--------------------------------------------------------------------------

#define WHITESPACE " \t"
DWORD GetStringField2(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if ( (cBufSize == 0) || (szStr == NULL) || (szBuf == NULL) )
   {
       return 0;
   }

   szBuf[0] = '\0';

   // look for fields based on commas but handle quotes.
   for ( ;i < uField; i++ )
   {
		// skip spaces
	   pszBegin += strspn(pszBegin, WHITESPACE);
	
	   // handle quotes
	   if ( *pszBegin == '"' )
	   {
		   pszBegin = strchr(++pszBegin, '"');

		   if ( pszBegin == NULL )
		   {
			   return 0; // invalid string
		   }
			pszBegin++; // skip trailing quote
			// find start of next string
	   	    pszBegin += strspn(pszBegin, WHITESPACE);
			if ( *pszBegin != ',' )
			{
				return 0;
			}
	   }
	   else
	   {
		   pszBegin = strchr(++pszBegin, ',');
		   if ( pszBegin == NULL )
		   {
			   return 0; // field isn't here
		   }
	   }
	   pszBegin++;
   }


	// pszBegin points to the start of the desired string.
	// skip spaces
	pszBegin += strspn(pszBegin, WHITESPACE);
	
   // handle quotes
   if ( *pszBegin == '"' )
   {
	   pszEnd = strchr(++pszBegin, '"');

	   if ( pszEnd == NULL )
	   {
		   return 0; // invalid string
	   }
   }
   else
   {
	   pszEnd = pszBegin + 1 + strcspn(pszBegin + 1, ",");
	   while ( (pszEnd > pszBegin) && 
			   ((*(pszEnd - 1) == ' ') || (*(pszEnd - 1) == '\t')) )
	   {
		   pszEnd--;
	   }
   }

   dwToCopy = pszEnd - pszBegin + 1;
   
   if ( dwToCopy > cBufSize )
   {
      dwToCopy = cBufSize;
   }

   lstrcpynA(szBuf, pszBegin, dwToCopy);
   
   return dwToCopy - 1;
}


void Usage(char *pszExeName);

class FakeICifComponent : public ICifComponent 
{
public:
	FakeICifComponent(LPSTR pszCIFFile, LPSTR pszID)
		: m_pszCIFFile(pszCIFFile),
		  m_pszID(pszID)
	{}

	STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize)
	{ return E_NOTIMPL; }

    STDMETHOD(GetGUID)(THIS_ LPSTR pszGUID, DWORD dwSize)
	{ return (GetPrivateProfileString(m_pszID, "GUID", "", pszGUID, dwSize, m_pszCIFFile) != 0 ) ? S_OK : E_FAIL; }
    
	STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetUrl)(THIS_ UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetFileExtractList)(THIS_ UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetUrlCheckRange)(THIS_ UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetCommand)(THIS_ UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches,
                         DWORD dwSwitchSize, LPDWORD pdwType)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetVersion)(THIS_ LPDWORD pdwVersion, LPDWORD pdwBuild)
	{
		char szBuf[100];
		
		if ( GetPrivateProfileString(m_pszID, "VERSION", "", szBuf, sizeof(szBuf), m_pszCIFFile) == 0 )
			return E_FAIL;
		fConvertDotVersionStrToDwords(szBuf, pdwVersion, pdwBuild);
		return S_OK;
	}
    
	STDMETHOD(GetLocale)(THIS_ LPSTR pszLocale, DWORD dwSize)
	{ return (GetPrivateProfileString(m_pszID, "LOCALE", "", pszLocale, dwSize, m_pszCIFFile) != 0 ) ? S_OK : E_FAIL; }
    
	STDMETHOD(GetUninstallKey)(THIS_ LPSTR pszKey, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetInstalledSize)(THIS_ LPDWORD pdwWin, LPDWORD pdwApp)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, GetDownloadSize)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, GetExtractSize)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetSuccessKey)(THIS_ LPSTR pszKey, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetProgressKeys)(THIS_ LPSTR pszProgress, DWORD dwProgSize,
                              LPSTR pszCancel, DWORD dwCancelSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(IsActiveSetupAware)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(IsRebootRequired)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(RequiresAdminRights)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, GetPriority)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetDependency)(THIS_ UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, GetPlatform)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetMode)(THIS_ UINT uModeNum, LPSTR pszMode, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetGroup)(THIS_ LPSTR pszID, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(IsUIVisible)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetPatchID)(THIS_ LPSTR pszID, DWORD dwSize)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetDetVersion)(THIS_ LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize)
	{
		HRESULT hr = S_OK;
		char szBuf[100];

		if ( (GetPrivateProfileString(m_pszID, "DetectVersion", "", szBuf, sizeof(szBuf), m_pszCIFFile) == 0 ) ||
			 (GetStringField2(szBuf, 0, pszDLL, dwdllSize) == 0) ||
			 (GetStringField2(szBuf, 1, pszEntry, dwentSize) == 0) )
		{
			hr = E_FAIL;
		}
		return hr;
	}
    
	STDMETHOD(GetTreatAsOneComponents)(THIS_ UINT uNum, LPSTR pszID, DWORD dwBuf)
	{ return E_NOTIMPL; }
    
	STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize)
	{
		char szBuf[100];
		lstrcpy(szBuf, "_");
		lstrcat(szBuf, pszKey);
		return (GetPrivateProfileString(m_pszID, szBuf, "", pszData, dwSize, m_pszCIFFile) != 0 ) ? S_OK : E_FAIL;
	}
    
    // access to state
    STDMETHOD_(DWORD, IsComponentInstalled)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(IsComponentDownloaded)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, IsThisVersionInstalled)(THIS_ DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, GetInstallQueueState)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(SetInstallQueueState)(THIS_ DWORD dwState)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, GetActualDownloadSize)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD_(DWORD, GetCurrentPriority)(THIS)
	{ return E_NOTIMPL; }
    
	STDMETHOD(SetCurrentPriority)(THIS_ DWORD dwPriority)
	{ return E_NOTIMPL; }

private:
	LPSTR m_pszCIFFile;
	LPSTR m_pszID;
};

//--------------------------------------------------------------------------
// main
//--------------------------------------------------------------------------
int __cdecl main(int argc, char* argv[])
{
	HRESULT hr = E_FAIL;
	HINSTANCE hLib;
	DETECTVERSION fpDetVer;
	DETECTION_STRUCT Det;
    DWORD dwInstalledVer = 1;
    DWORD dwInstalledBuild = 1;
	char szDll[MAX_PATH];
	char szEntryPoint[MAX_PATH];
	char szCIFFile[MAX_PATH];
	LPSTR pszCIFFile;
	LPSTR pszID;
	char szGUID[100];
	char szLocale[100];

	// check args
	if ( argc != 3 )
	{
		Usage(argv[0]);
		return 1;
	}

    pszCIFFile      = _fullpath(szCIFFile, argv[1], sizeof(szCIFFile));
	if ( pszCIFFile == NULL )
	{
		printf("Cannot find file %s.\n", argv[1]);
		return 1;
	}
    pszID           = argv[2];

    memset(&Det, 0, sizeof(Det));
    Det.dwSize = sizeof(DETECTION_STRUCT);
    Det.pdwInstalledVer = &dwInstalledVer;
    Det.pdwInstalledBuild = &dwInstalledBuild;
    
    // load this information from the CIF file
    FakeICifComponent FakeCifComp(pszCIFFile, pszID);

	/*
	if ( FAILED(FakeCifComp.GetGUID(szGUID, sizeof(szGUID))) )
	{
		printf("Cannot find GUID in CIF file.\n");
		return 1;
	}
    Det.pszGUID = szGUID;

	if ( FAILED(FakeCifComp.GetLocale(szLocale, sizeof(szLocale))) )
	{
		printf("Cannot find Locale in CIF file.\n");
		return 1;
	}
	Det.pszLocale = szLocale;

	if ( FAILED(FakeCifComp.GetVersion(&Det.dwAskVer, &Det.dwAskBuild)) )
	{
		printf("Cannot find Version in CIF file.\n");
		return 1;
	}
*/

	if ( FAILED(FakeCifComp.GetDetVersion(szDll, sizeof(szDll), szEntryPoint, sizeof(szEntryPoint))) )
	{
		printf("Cannot find DetectVersion in CIF file.\n");
		return 1;
	}

	Det.pCifComp = &FakeCifComp;

    hLib = LoadLibrary(szDll);

	if ( hLib == NULL )
	{
		printf("Could not load detection library.\n");
	}
	else
	{
		fpDetVer = (DETECTVERSION)GetProcAddress(hLib, szEntryPoint);
	 
		if ( fpDetVer != NULL )
		{
			DWORD dwStatus = fpDetVer(&Det);

			switch ( dwStatus )
			{
			   case DET_NOTINSTALLED:
				  printf("Detection Status : ICI_NOTINSTALLED\n");
				  break;

			   case DET_INSTALLED:
				  printf("Detection Status : ICI_INSTALLED\n");
				  break;

			   case DET_NEWVERSIONINSTALLED:
				  printf("Detection Status : ICI_OLDVERSIONAVAILABLE\n");
				  break;

			   case DET_OLDVERSIONINSTALLED:
				  printf("Detection Status : ICI_NEWVERSIONAVAILABLE\n");
				  break;

			   default:
				  printf("Detection Status : unknown status %d\n", dwStatus);
				  break;
			}
		}
		FreeLibrary(hLib);
	}

   return hr;
}

//--------------------------------------------------------------------------
// Usage
//--------------------------------------------------------------------------

void Usage(char *pszExeName)
{
	printf("Usage:\n\n");
	printf("%s <CIF file> <CIF section>\n", pszExeName);
	printf("\n");
	printf("e.g. %s wu.cif chrome\n", pszExeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\include\hcappres.h ===
//******************************************************************************
// 
// Copyright (c) 2000 Microsoft Corporation
// 
// Module Name:
// 	   HCAppRes.h
// 
// Abstract:
// 	   IDs for localizable resources.
// 
// Revision History:
// 	   Davide Massarenti   (Dmassare)  05/27/2000
// 		   created
// 
//******************************************************************************

#define IDS_MAINWND_TITLE                           2048

// SAF messages
#define IDS_RECORD_EXIST                            2049
#define IDS_RECORD_NOT_FOUND                        2050
#define IDS_RECORD_NOT_CLOSED                       2051

// UnsolicitedRC  Messages
#define IDS_NOPOLICY                                2052

// HCP friendly name.
#define IDS_HELPCTR_HCP_DISPLAYNAME                 2100

// HelpCtr messages
#define IDS_HELPCTR_DLG_ERROR                       2200
#define IDS_HELPCTR_DLG_USAGE                       2201

#define IDS_HELPCTR_MARSCORE_INCORRECT_VERSION      2210
#define IDS_HELPCTR_MARSCORE_NOT_FOUND              2211
#define IDS_HELPCTR_SVC_MISSING                     2212

#define IDS_HELPCTR_PRINT_TITLE                     2213

#define IDS_HELPCTR_TAXO_UNKNOWN_NODE               2214
#define IDS_HELPCTR_HIST_NOTITLE                    2215
#define IDS_HELPCTR_SYSMENU_GOTO                    2216



////////////////////////////////////////////////////////////////////////////////

// HelpSvc strings

#define IDS_HELPSVC_DISPLAYNAME                     2500
#define IDS_HELPSVC_DESCRIPTION                     2501
#define IDS_HELPSVC_GROUPNAME                       2502
#define IDS_HELPSVC_GROUPCOMMENT                    2503
#define IDS_HELPSVC_USERCOMMENT                     2504

#define IDS_HELPSVC_TASKNAME                        2510
#define IDS_HELPSVC_TASKCOMMENT                     2511

#define IDS_HELPSVC_UNKNOWNERROR                    2512

#define IDS_HELPSVC_SEMGR_OWNER                     2520
		
#define IDS_HELPSVC_SEMGR_FTS_NAME                  2521
#define IDS_HELPSVC_SEMGR_FTS_DESC                  2522
		
#define IDS_HELPSVC_SEMGR_KW_NAME                   2523
#define IDS_HELPSVC_SEMGR_KW_DESC                   2524

#define IDS_HELPSVC_TITLE_ONLY                      2525
#define IDS_HELPSVC_STEMMING                        2526


// News strings
// Update Headlines provider name
#define IDS_NEWS_UPDATEBLOCK_NAME	   				2700
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\include\locres.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    LocRes.h

Abstract:
    This file contains the declaration of the functions used to localize strings.

Revision History:
    Davide Massarenti   (Dmassare)  07/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___INCLUDE___LOCRES_H___)
#define __INCLUDED___INCLUDE___LOCRES_H___

#include <HCAppRes.h>

#include <NTEventMsg.h>

#include <MPC_main.h>

#endif // !defined(__INCLUDED___INCLUDE___LOCRES_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\include\hcp_trace.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HCP_trace.h

Abstract:
    This file contains the declaration of Tracing Macrons for the Help Center.

Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(__INCLUDED___HELPCENTER___TRACE_H___)
#define __INCLUDED___HELPCENTER___TRACE_H___

#include <MPC_trace.h>

/////////////////////////////////////////////////////////////////////////

#define __HCP_FUNC_ENTRY(x)     __MPC_FUNC_ENTRY(HELPCENTERID,x)
#define __HCP_FUNC_LEAVE        __MPC_FUNC_LEAVE
#define __HCP_FUNC_CLEANUP      __MPC_FUNC_CLEANUP
#define __HCP_FUNC_EXIT(x)      __MPC_FUNC_EXIT(x)

/////////////////////////////////////////////////////////////////////////

#define __HCP_BEGIN_PROPERTY_GET0(func,hr,pVal)               __MPC_BEGIN_PROPERTY_GET0(HELPCENTERID,func,hr,pVal)               
#define __HCP_BEGIN_PROPERTY_GET0__NOLOCK(func,hr,pVal)       __MPC_BEGIN_PROPERTY_GET0__NOLOCK(HELPCENTERID,func,hr,pVal)  
#define __HCP_BEGIN_PROPERTY_GET(func,hr,pVal)                __MPC_BEGIN_PROPERTY_GET(HELPCENTERID,func,hr,pVal)               
#define __HCP_BEGIN_PROPERTY_GET__NOLOCK(func,hr,pVal)        __MPC_BEGIN_PROPERTY_GET__NOLOCK(HELPCENTERID,func,hr,pVal)  
#define __HCP_BEGIN_PROPERTY_GET2(func,hr,pVal,value)         __MPC_BEGIN_PROPERTY_GET2(HELPCENTERID,func,hr,pVal,value) 
#define __HCP_BEGIN_PROPERTY_GET2__NOLOCK(func,hr,pVal,value) __MPC_BEGIN_PROPERTY_GET2__NOLOCK(HELPCENTERID,func,hr,pVal,value) 
#define __HCP_BEGIN_PROPERTY_PUT(func,hr)                     __MPC_BEGIN_PROPERTY_PUT(HELPCENTERID,func,hr)       
#define __HCP_BEGIN_PROPERTY_PUT__NOLOCK(func,hr)             __MPC_BEGIN_PROPERTY_PUT__NOLOCK(HELPCENTERID,func,hr) 
#define __HCP_END_PROPERTY(hr)                                __MPC_END_PROPERTY(hr) 

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___HELPCENTER___TRACE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\include\msscript.h ===
//=--------------------------------------------------------------------------=
// MSScript.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//
// Declarations for Microsoft-provided script engines that support ActiveX Scripting.
//

#include "windows.h"
#include "ole2.h"

#ifndef MSSCRIPT_H
#define MSSCRIPT_H


//=--------------------------------------------------------------------------=
// 
// GUID declarations
//
//=--------------------------------------------------------------------------=

//
// Class identifiers
//

// The GUID used to identify the coclass of the VB Script engine
// {B54F3741-5B07-11cf-A4B0-00AA004A55E8}
#define szCLSID_VBScript "{B54F3741-5B07-11cf-A4B0-00AA004A55E8}"
DEFINE_GUID(CLSID_VBScript, 0xb54f3741, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8);

// The GUID used to identify the coclass for VB Script authoring
// {B54F3742-5B07-11cf-A4B0-00AA004A55E8}
#define szCLSID_VBScriptAuthor "{B54F3742-5B07-11cf-A4B0-00AA004A55E8}"
DEFINE_GUID(CLSID_VBScriptAuthor, 0xb54f3742, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8);

// The GUID used to identify the coclass for VB Script Encode engine
// {B54F3743-5B07-11cf-A4B0-00AA004A55E8}
#define szCLSID_VBScriptEncode "{B54F3743-5B07-11cf-A4B0-00AA004A55E8}"
DEFINE_GUID(CLSID_VBScriptEncode, 0xb54f3743, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8);

// The GUID used to identify the coclass of the JavaScript engine
// {F414C260-6AC0-11CF-B6D1-00AA00BBBB58}
#define szCLSID_JScript "{F414C260-6AC0-11CF-B6D1-00AA00BBBB58}"
DEFINE_GUID(CLSID_JScript, 0xf414c260, 0x6ac0, 0x11cf, 0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58);

// The GUID used to identify the coclass for JavaScript authoring
// {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}
#define szCLSID_JScriptAuthor "{f414c261-6ac0-11cf-b6d1-00aa00bbbb58}"
DEFINE_GUID(CLSID_JScriptAuthor, 0xf414c261, 0x6ac0, 0x11cf, 0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58);

// The GUID used to identify the coclass for JavaScript encode engine
// {f414c262-6ac0-11cf-b6d1-00aa00bbbb58}
#define szCLSID_JScriptEncode "{f414c262-6ac0-11cf-b6d1-00aa00bbbb58}"
DEFINE_GUID(CLSID_JScriptEncode, 0xf414c262, 0x6ac0, 0x11cf, 0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58);

// The GUID used to identify the coclass of the File System Object
// {0D43FE01-F093-11CF-8940-00A0C9054228} 
#define szCLSID_FileSystemObject "{0D43FE01-F093-11CF-8940-00A0C9054228}"
DEFINE_GUID(CLSID_FileSystemObject, 0x0D43FE01L, 0xF093, 0x11CF, 0x89, 0x40, 0x00, 0xA0, 0xC9, 0x05, 0x42, 0x28);

// The GUID used to identify the coclass of the Dictionary
// {EE09B103-97E0-11CF-978F-00A02463E06F}
#define szCLSID_Dictionary "{EE09B103-97E0-11CF-978F-00A02463E06F}"
DEFINE_GUID(CLSID_Dictionary, 0xEE09B103L, 0x97E0, 0x11CF, 0x97, 0x8F, 0x00, 0xA0, 0x24, 0x63, 0xE0, 0x6F);

//
// Interface identifiers
//

// The GUID used to identify the IJScriptDispatch interface
// {A0AAC450-A77B-11CF-91D0-00AA00C14A7C}
#define szIID_IJScriptDispatch "{A0AAC450-A77B-11CF-91D0-00AA00C14A7C}"
DEFINE_GUID(IID_IJScriptDispatch,  0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);

// The GUID used to identify the IFileSystemObject interface
// {33E10B81-F012-11CF-8940-00A0C9054228}
#define szIID_IFileSystemObject "{33E10B81-F012-11CF-8940-00A0C9054228}"
DEFINE_GUID(IID_IFileSystemObject, 0x33E10B81L, 0xF012, 0x11CF, 0x89, 0x40, 0x00, 0xA0, 0xC9, 0x05, 0x42, 0x28);

// The GUID used to identify the ITextStream interface
// {53BAD8C1-E718-11CF-893D-00A0C9054228"
#define szIID_ITextStream "{53BAD8C1-E718-11CF-893D-00A0C9054228}"
DEFINE_GUID(IID_ITextStream, 0x53BAD8C1L, 0xE718, 0x11CF, 0x89, 0x3D, 0x00, 0xA0, 0xC9, 0x05, 0x42, 0x28);

// The GUID used to identify the IDictionary interface
// {42C642C1-97E1-11CF-978F-00A02463E06F}
#define szIID_IDictionary "{42C642C1-97E1-11CF-978F-00A02463E06F}"
DEFINE_GUID(IID_IDictionary, 0x42C642C1L, 0x97E1, 0x11CF, 0x97, 0x8F, 0x00, 0xA0, 0x24, 0x63, 0xE0, 0x6F);

//
// Library identifiers
//

// The GUID used to identify the Scripting library
// {420B2830-E718-11CF-893D-00A0C9054228}
#define szLIBID_Scripting "{420B2830-E718-11CF-893D-00A0C9054228}"
DEFINE_GUID(LIBID_Scripting, 0x420B2830L, 0xE718, 0x11CF, 0x89, 0x3D, 0x00, 0xA0, 0xC9, 0x05, 0x42, 0x28);

//=--------------------------------------------------------------------------=
// 
// Interface declarations 
//
//=--------------------------------------------------------------------------=

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

//
// IJScriptDispatch
//
// This is the interface for the extensible IDispatch objects used by Microsoft JScript.
// Notable differences between standard Automation IDispatch objects and IJScriptDispatch
// objects are:
//
// * case sensitive method names
// * indexing functionality
// * dynamic addition of properties
// * enumeration of dispIDs and member names
//

#undef INTERFACE
#define INTERFACE IJScriptDispatch

DECLARE_INTERFACE_(IJScriptDispatch, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS
	/* IUnknown methods */
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IDispatch methods */
	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

	STDMETHOD(GetTypeInfo)(
	  THIS_
	  UINT itinfo,
	  LCID lcid,
	  ITypeInfo FAR* FAR* pptinfo) PURE;

	STDMETHOD(GetIDsOfNames)(
	  THIS_
	  REFIID riid,
	  OLECHAR FAR* FAR* rgszNames,
	  UINT cNames,
	  LCID lcid,
	  DISPID FAR* rgdispid) PURE;

	STDMETHOD(Invoke)(
	  THIS_
	  DISPID dispidMember,
	  REFIID riid,
	  LCID lcid,
	  WORD wFlags,
	  DISPPARAMS FAR* pdispparams,
	  VARIANT FAR* pvarResult,
	  EXCEPINFO FAR* pexcepinfo,
	  UINT FAR* puArgErr) PURE;
#endif

	/* IJScriptDispatch methods */
	STDMETHOD(GetIDsOfNamesEx)(THIS_ REFIID riid, OLECHAR FAR * FAR * prgpsz, UINT cpsz, LCID lcid, DISPID FAR * prgid, DWORD grfdex) PURE;
	STDMETHOD(GetNextDispID)(THIS_ DISPID id, DISPID FAR * pid, BSTR FAR * pbstrName) PURE;
};

//
// Scripting library interfaces
//
// These are the interfaces for the scripting library objects:
// IDictionary, IFileSystemObject and ITextStream.
//

interface IFileSystemObject;

interface ITextStream;

typedef enum CompareMethod {
	BinaryCompare = 0,
	TextCompare = 1,
	DatabaseCompare = 2
} CompareMethod;

typedef enum IOMode {
	ForReading = 1,
	ForWriting = 2,
	ForAppending = 8
} IOMode;

typedef enum Tristate {
	TristateTrue = -1,
	TristateFalse = 0,
	TristateUseDefault = -2,
	TristateMixed = -2
} Tristate;

//
// IFileSystemObject 
//

#undef INTERFACE
#define INTERFACE IFileSystemObject

DECLARE_INTERFACE_(IFileSystemObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

	/* IUnknown methods */
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IDispatch methods */
	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

	STDMETHOD(GetTypeInfo)(
	  THIS_
	  UINT itinfo,
	  LCID lcid,
	  ITypeInfo FAR* FAR* pptinfo) PURE;

	STDMETHOD(GetIDsOfNames)(
	  THIS_
	  REFIID riid,
	  OLECHAR FAR* FAR* rgszNames,
	  UINT cNames,
	  LCID lcid,
	  DISPID FAR* rgdispid) PURE;

	STDMETHOD(Invoke)(
	  THIS_
	  DISPID dispidMember,
	  REFIID riid,
	  LCID lcid,
	  WORD wFlags,
	  DISPPARAMS FAR* pdispparams,
	  VARIANT FAR* pvarResult,
	  EXCEPINFO FAR* pexcepinfo,
	  UINT FAR* puArgErr) PURE;
#endif

	/* IFileSystemObject methods */
	STDMETHOD(CreateTextFile)(THIS_ BSTR FileName, IOMode IOMode, VARIANT_BOOL Overwrite, VARIANT_BOOL Unicode, ITextStream FAR* FAR* ppts) PURE;
	STDMETHOD(OpenTextFile)(THIS_ BSTR FileName, IOMode IOMode, VARIANT_BOOL Create, Tristate Format, ITextStream FAR* FAR* ppts) PURE;
};

//
// ITextStream 
//

#undef INTERFACE
#define INTERFACE ITextStream

DECLARE_INTERFACE_(ITextStream, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

	/* IUnknown methods */
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IDispatch methods */
	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

	STDMETHOD(GetTypeInfo)(
	  THIS_
	  UINT itinfo,
	  LCID lcid,
	  ITypeInfo FAR* FAR* pptinfo) PURE;

	STDMETHOD(GetIDsOfNames)(
	  THIS_
	  REFIID riid,
	  OLECHAR FAR* FAR* rgszNames,
	  UINT cNames,
	  LCID lcid,
	  DISPID FAR* rgdispid) PURE;

	STDMETHOD(Invoke)(
	  THIS_
	  DISPID dispidMember,
	  REFIID riid,
	  LCID lcid,
	  WORD wFlags,
	  DISPPARAMS FAR* pdispparams,
	  VARIANT FAR* pvarResult,
	  EXCEPINFO FAR* pexcepinfo,
	  UINT FAR* puArgErr) PURE;
#endif

	/* ITextStream methods */
	STDMETHOD(get_Line)(THIS_ long FAR* Line) PURE;
	STDMETHOD(get_Column)(THIS_ long FAR* Column) PURE;
	STDMETHOD(get_AtEndOfStream)(THIS_ VARIANT_BOOL FAR* EOS) PURE;
	STDMETHOD(get_AtEndOfLine)(THIS_ VARIANT_BOOL FAR* EOL) PURE;
	STDMETHOD(Read)(THIS_ long Characters, BSTR FAR* Text) PURE;
	STDMETHOD(ReadLine)(THIS_ BSTR FAR* Text) PURE;
	STDMETHOD(ReadAll)(THIS_ BSTR FAR* Text) PURE;
	STDMETHOD(Write)(THIS_ BSTR Text) PURE;
	STDMETHOD(WriteLine)(THIS_ BSTR Text) PURE;
	STDMETHOD(WriteBlankLines)(THIS_ long Lines) PURE;
	STDMETHOD(Skip)(THIS_ long Characters) PURE;
	STDMETHOD(SkipLine)(THIS) PURE;
	STDMETHOD(Close)(THIS) PURE;
};


//
// IDictionary
//

#undef INTERFACE
#define INTERFACE IDictionary

DECLARE_INTERFACE_(IDictionary, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

	/* IUnknown methods */
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IDispatch methods */
	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

	STDMETHOD(GetTypeInfo)(
	  THIS_
	  UINT itinfo,
	  LCID lcid,
	  ITypeInfo FAR* FAR* pptinfo) PURE;

	STDMETHOD(GetIDsOfNames)(
	  THIS_
	  REFIID riid,
	  OLECHAR FAR* FAR* rgszNames,
	  UINT cNames,
	  LCID lcid,
	  DISPID FAR* rgdispid) PURE;

	STDMETHOD(Invoke)(
	  THIS_
	  DISPID dispidMember,
	  REFIID riid,
	  LCID lcid,
	  WORD wFlags,
	  DISPPARAMS FAR* pdispparams,
	  VARIANT FAR* pvarResult,
	  EXCEPINFO FAR* pexcepinfo,
	  UINT FAR* puArgErr) PURE;
#endif

	/* IDictionary methods */
    STDMETHOD(putref_Item)(THIS_ VARIANT FAR* Key, VARIANT FAR* pItem) PURE;
	STDMETHOD(put_Item)(THIS_ VARIANT FAR* Key, VARIANT FAR* pItem) PURE;
	STDMETHOD(get_Item)(THIS_ VARIANT FAR* Key, VARIANT FAR* pRetItem) PURE;
	STDMETHOD(Add)(THIS_ VARIANT FAR* Key, VARIANT FAR* Item) PURE;
	STDMETHOD(get_Count)(THIS_ long FAR* pCount) PURE;
	STDMETHOD(Exists)(THIS_ VARIANT FAR* Key, VARIANT_BOOL FAR* pExists) PURE;
	STDMETHOD(Items)(THIS_ VARIANT FAR* pItemsArray) PURE;
	STDMETHOD(put_Key)(THIS_ VARIANT FAR* Key, VARIANT FAR* NewKey) PURE;
	STDMETHOD(Keys)(THIS_ VARIANT FAR* pKeysArray) PURE;
	STDMETHOD(Remove)(THIS_ VARIANT FAR* Key) PURE;
	STDMETHOD(RemoveAll)(THIS) PURE;
	STDMETHOD(put_CompareMode)(THIS_ CompareMethod comp) PURE;
	STDMETHOD(get_CompareMode)(THIS_ CompareMethod FAR* pcomp) PURE;
	STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppunk) PURE;
	STDMETHOD(get_HashVal)(THIS_ VARIANT FAR* Key, VARIANT FAR* HashVal) PURE;
};


#endif // MSSCRIPT_H

// End of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\pss\content\makefile.inc ===
PSS_FILES=Connection.htm \
          GArrow.gif \
          GRect.gif \
          Info_Icon.gif \
          OfflineDC.htm \
          OfflineOptions.htm \
          package_description.xml \
          PSS.css \
          pss.xml \
          pss_getting_worldwide_help.htm \
          pssmachinesnapshot-less.xml \
          pssmachinesnapshot-wo-com.xml \
          pssmachinesnapshot.xml \
          r1_c1.gif \
          r1_c2.gif \
          r1_c3.gif \
          r3_c2.gif \
          spacer.gif \
          status_ok.gif


gocab: $O\PSS.cab


$O\PSS.cab: $(PSS_FILES)
    cabarc -m NONE n $O\PSS.cab $(PSS_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\include\projectconstants.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ProjectConstants.h

Abstract:
    This file contains contants common to the whole project.

Revision History:
    Davide Massarenti   (Dmassare)  03/20/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___PROJECTCONSTANTS_H___)
#define __INCLUDED___PCH___PROJECTCONSTANTS_H___

#ifndef DEBUG
#undef  NOJETBLUECOM
#define NOJETBLUECOM
#endif

////////////////////////////////////////////////////////////////////////////////

#define HC_ROOT         	   	 	   L"%WINDIR%\\PCHealth"
#define HC_ROOT_HELPSVC 	   	 	   HC_ROOT L"\\HelpCtr"

#define HC_ROOT_HELPSVC_BINARIES 	   HC_ROOT_HELPSVC L"\\Binaries"
#define HC_ROOT_HELPSVC_CONFIG   	   HC_ROOT_HELPSVC L"\\Config"
#define HC_ROOT_HELPSVC_BATCH    	   HC_ROOT_HELPSVC L"\\Batch"
#define HC_ROOT_HELPSVC_DATACOLL 	   HC_ROOT_HELPSVC L"\\DataColl"
#define HC_ROOT_HELPSVC_LOGS     	   HC_ROOT_HELPSVC L"\\Logs"
#define HC_ROOT_HELPSVC_TEMP     	   HC_ROOT_HELPSVC L"\\Temp"
#define HC_ROOT_HELPSVC_OFFLINECACHE   HC_ROOT_HELPSVC L"\\OfflineCache"
#define HC_ROOT_HELPSVC_PKGSTORE       HC_ROOT_HELPSVC L"\\PackageStore"
  
#define HC_HELPSET_ROOT 	   	 	   HC_ROOT_HELPSVC L"\\"
#define HC_HELPSET_SUB_INSTALLEDSKUS   L"InstalledSKUs"
  
#define HC_HELPSET_SUB_DATABASE 	   L"Database"
#define HC_HELPSET_SUB_INDEX    	   L"Indices"
#define HC_HELPSET_SUB_SYSTEM   	   L"System"
#define HC_HELPSET_SUB_SYSTEM_OEM  	   L"System_OEM"
#define HC_HELPSET_SUB_VENDORS  	   L"Vendors"
#define HC_HELPSET_SUB_HELPFILES  	   L"HelpFiles"

#define HC_HELPSET_SUBSUB_DATAARCHIVE  L"pchdata.cab"
#define HC_HELPSET_SUBSUB_DATABASEFILE L"hcdata.edb"
#define HC_HELPSET_SUBSUB_INDEXFILE	   L"merged.hhk"

#define HC_HELPSVC_HELPFILES_DEFAULT   L"%WINDIR%\\Help"


// This is relative to CSIDL_LOCAL_APPDATA (i.e: C:\Documents and Settings\<username>\Local Settings\Application Data)
#define HC_ROOT_HELPCTR L"Microsoft\\HelpCtr"

#define HC_REGISTRY_BASE     	  L"SOFTWARE\\Microsoft\\PCHealth"
#define HC_REGISTRY_HELPSVC  	  HC_REGISTRY_BASE L"\\HelpSvc"
#define HC_REGISTRY_HELPHOST 	  HC_REGISTRY_BASE L"\\HelpHost"
#define HC_REGISTRY_HELPCTR  	  HC_REGISTRY_BASE L"\\HelpCtr"
#define HC_REGISTRY_PCHSVC  	  HC_REGISTRY_BASE L"\\PchSvc"

#define HC_REGISTRY_HELPCTR_USER  HC_REGISTRY_HELPCTR L"\\UserSettings"
#define HC_REGISTRY_HELPCTR_IE    HC_REGISTRY_HELPCTR L"\\IESettings"

////////////////////////////////////////

#define HC_HELPSVC_STORE_TRUSTEDCONTENTS   HC_ROOT_HELPSVC_CONFIG 	L"\\Cntstore.bin"
#define HC_HELPSVC_STORE_CHANNELS          HC_ROOT_HELPSVC_CONFIG 	L"\\SAFStore.xml"
#define HC_HELPSVC_STORE_INCIDENTITEMS     HC_ROOT_HELPSVC_CONFIG 	L"\\incstore.bin"
#define HC_HELPSVC_STORE_SKUS              HC_ROOT_HELPSVC_PKGSTORE	L"\\SkuStore.bin"
  
#define HC_HCUPDATE_LOGNAME                HC_ROOT_HELPSVC_LOGS   	L"\\hcupdate.log"
#define HC_HCUPDATE_STORE_PACKAGES         HC_ROOT_HELPSVC_PKGSTORE L"\\pchver.xml"
#define HC_HCUPDATE_STORE_SE		       HC_ROOT_HELPSVC_CONFIG 	L"\\sereg.xml"
  
#define HC_SEMGR_LOGNAME                   HC_ROOT_HELPSVC_LOGS   	L"\\semgr.log"

////////////////////////////////////////

// OLD
#define HC_HELPSVC_STORE_USERS             HC_ROOT_HELPSVC_CONFIG 	L"\\UsersStore.cxml"

////////////////////////////////////////

#define HC_HELPSVC_NAME 	   	 L"helpsvc"

#define HC_MICROSOFT_DN          L"CN=Microsoft Corporation,L=Redmond,S=Washington,C=US"

////////////////////////////////////////

#define HC_TIMEOUT_NETWORKALIVE            3000
#define HC_TIMEOUT_DESTINATIONREACHABLE    3000

#define HC_TIMEOUT_CONNECTIONCHECK        15000

#define HC_TIMEOUT_LINKCHECKER_FOREGROUND 15000
#define HC_TIMEOUT_LINKCHECKER_BACKGROUND 25000

////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___PROJECTCONSTANTS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\pss\notiflag\notiflag.cpp ===
// Notiflag.cpp : Defines the entry point for the application.
//***********************************************************************
// Reads a local XML file, hits the given url and gets back xml string 
// with another url, places an icon in system tray and links it to the url..
// Copyright : Microsoft Corporation. PSSODEV team. 
// 
// Author : K J Babu (v-kjbad)
//			Pramod Walvekar (v-pramwa)
// 
//***********************************************************************
 
//includes
#include "stdafx.h"
#include "resource.h"
#include "Notiflag.h"
#include <crtdbg.h>
//#define _WIN32_IE 0x0500
#include <shellapi.h>
#include <shlwapi.h>
#include <wininet.h>
#include <ole2.h>
#include <initguid.h>
#include <mstask.h>
#include <wchar.h>
#include <prsht.h>
#include <MPC_main.h>


//#include <atlbase.h> //defined in notiflag.h

//#define WM_ICON WM_USER+333
#define WM_ICON 0xBFFF
#define ID_MYICON 5

// Global Variables:
HINSTANCE g_hInst;					// current instance
WCHAR szTitle[_MAX_PATH + 1];		// title bar text
WCHAR szTaskName[_MAX_PATH + 1];
WCHAR szWindowClass[_MAX_PATH + 1];	// window class name
WCHAR szURL[_MAX_PATH + 1];			// URL to call if user clicks on the icon
HRESULT hr = ERROR_SUCCESS;
HWND g_Hwnd;


//******************************************************************
// Main function 
//
// checks for the program instance
// reads the client's incident list xml file
// makes a call to remoteURL and reads the returned xml
// adds program's executable path in the registry and 
// loads the icon in system area (tray)
// waits for the single click on the icon and on single click
// removes the entry from the registry, load the IE window with URL
// and exits.
//******************************************************************
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{ 	
	MSG msg;
	int tmpDbgFlag;
	int nNumArgs = 0;
	LPCTSTR *cmdArgs = (LPCTSTR*)CommandLineToArgvW(GetCommandLineW(), &nNumArgs);
#ifdef _DEBUG
	MessageBox(0, cmdArgs[0], L"app path", 0);
#endif

	LoadString(hInstance, IDS_APP_TITLE, szTitle, _MAX_PATH);
	// check the previous instance of the program here
	// return if program is already running.
	HANDLE hMutex = CreateMutex(NULL,TRUE,szTitle);
	if(ERROR_ALREADY_EXISTS == GetLastError())
		return 0;
	/*
     * Set the debug-heap flag to keep freed blocks in the
     * heap's linked list - This will allow us to catch any
     * inadvertent use of freed memory
     */

    tmpDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    tmpDbgFlag |= _CRTDBG_DELAY_FREE_MEM_DF;
    tmpDbgFlag |= _CRTDBG_LEAK_CHECK_DF;
    _CrtSetDbgFlag(tmpDbgFlag);

	
	// check if there are any command line parameters
	if (nNumArgs > 1)
	{
		// check if the first parameter is either /t or -t, which indicates AddNotiTask
		if((_tcscmp(cmdArgs[1], L"/t") == 0)||(_tcscmp(cmdArgs[1], L"-t") == 0))
		{
			// as first argument is /t or -t, run the AddNotiTask component
			hr = CallAddNotiTask(hInstance, cmdArgs, lpCmdLine);
			if(FAILED(hr))
				goto endMain;
		}
	}
	else
	{
 		hr = CallNotiflag(hInstance);
		if(FAILED(hr))
			goto endMain;

		//*** change the priorty of the program
		SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);

		// ***** All house keeping work done. start the program now...
		// Perform application initialization:
		if (!InitInstance (hInstance, nCmdShow)) 
			goto endMain;

	#ifdef _DEBUG
		MessageBox(0, L"Loading Icon...", L"NotiFlag: msg", 0);
	#endif

		// add the icon in system tray
		HICON hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_FLAGICON));
		
		if(hIcon != NULL)
		{
			BOOL bRet = MyTaskBarAddIcon(g_Hwnd, ID_MYICON, hIcon);
			DestroyIcon(hIcon);
			if (bRet == FALSE)// failed to create the system icon				
				goto endMain;
		}
	#ifdef _DEBUG
		MessageBox(0, L"Icon loaded! waiting for click", L"NotiFlag: msg", 0);
	#endif
		
		// main message loop
		while (GetMessage(&msg, NULL, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

	#ifdef _DEBUG
		MessageBox(0, L"closing NotiFlag program", L"NotiFlag: msg", 0);
	#endif

		// remove the icon from system tray and do other cleaning, exit.
		//
	}	
	CloseHandle(hMutex);	
	return (int)msg.wParam;	
endMain:	
	CloseHandle(hMutex);	
	return -1;		
}


//*********************************************************************************
//  MyRegisterClass
//
//  PURPOSE: Registers the window class.
//*********************************************************************************
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	USES_CONVERSION;
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_FLAGICON);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCTSTR)IDC_NOTIFLAG;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_FLAGICON );
	
	return RegisterClassEx(&wcex);
}

//*********************************************************************************
//   InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//*********************************************************************************
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	// create the window with no display 
	g_Hwnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

	return (g_Hwnd)?TRUE:FALSE;
}

//*********************************************************************************
//  WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//*********************************************************************************
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	
	switch (message) 
	{
		case WM_COMMAND:		
			switch(LOWORD(wParam))
			{				
				case IDC_DISABLE:	// if user chose to disable task
					hr = DisableTask();  // disable the task
					if (FAILED(hr))
					#ifdef _DEBUG
						MessageBox(hWnd,L"Failed to disable task",L"PSSIncidentNotification",MB_OK);
					#endif
					MyTaskBarDeleteIcon(g_Hwnd,ID_MYICON); // remove icon from tray
					DestroyWindow(g_Hwnd);  // end application
					break;
				case IDC_SETFREQUENCY:	// if user chose to change the frequency of the task
					hr = EditTask();  // display task schedule settings so user can change it
					if (FAILED(hr))
						#ifdef _DEBUG
							MessageBox(hWnd,L"No Changes in task",L"PSSIncidentNotification",MB_OK);
						#endif
					break;
				default:
					break;
			}
		break;
		
		
		case WM_ICON:	
			{	
				if ((UINT)lParam == WM_LBUTTONDOWN)
				{
					// Show new Browser window with the given URL
					ShellExecute(g_Hwnd, L"open", szURL, NULL, NULL, SW_SHOWNORMAL);
					MyTaskBarDeleteIcon(g_Hwnd,ID_MYICON);
					DestroyWindow(g_Hwnd);
				}
				//if(((UINT)lParam == 0x204) ||  ((UINT)lParam == 0x205)) 
				if ((UINT)lParam == WM_RBUTTONDOWN) // if user clicks right button
				{
					POINT sPoint;
					HMENU hMenu=LoadMenu(g_hInst,MAKEINTRESOURCE(IDC_NOTIFLAG)); // load menu
					if(hMenu!=NULL)
					{
						HMENU hSubMenu=GetSubMenu(hMenu,0);
						GetCursorPos(&sPoint); // get location of mouse
						SetForegroundWindow(hWnd);
						TrackPopupMenu(hSubMenu,TPM_LEFTALIGN|TPM_TOPALIGN|TPM_RIGHTBUTTON ,sPoint.x,sPoint.y,0,hWnd,NULL); // track the menu						
						PostMessage(hWnd, WM_NULL, 0, 0);
						DestroyMenu(hMenu);
					}
				}		
				break;
			}
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}


//****************************************************************************
// MyTaskBarAddIcon
//
// adds an icon to system tray. 
// Returns : TRUE if successful, or FALSE otherwise. 
//****************************************************************************
BOOL MyTaskBarAddIcon(HWND hwnd, UINT uID, HICON hicon) 
{
	NOTIFYICONDATA tnid={0}; 
	// Find out what version of the shell we are using for tray icon stuff
	HINSTANCE hShellDll;
	DLLGETVERSIONPROC pDllGetVersion;
	DLLVERSIONINFO dvi;
	BOOL bUseTrayBalloon = FALSE;

	// balloon tooltip is supported only in shell32.dll 5.0, so check the version
	hShellDll = LoadLibrary(L"Shell32.dll");
	if(hShellDll != NULL)
	{
		// enable balloon tooltip if IE version is greater than 5
		pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hShellDll, "DllGetVersion");
		dvi.cbSize = sizeof(dvi);
		if(pDllGetVersion != NULL && SUCCEEDED((*pDllGetVersion)(&dvi)))
			if(dvi.dwMajorVersion >= 5) bUseTrayBalloon = TRUE;
		FreeLibrary(hShellDll);
	}
	
	//fill icon structure
	tnid.cbSize = sizeof(NOTIFYICONDATA); 
	tnid.hWnd = hwnd; 
	tnid.uID = uID; 
	tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP; 
	tnid.uCallbackMessage = WM_ICON; 
	tnid.hIcon = hicon; 
	LoadString(g_hInst, IDS_TOOLTIP, tnid.szTip, MAXSTRLEN(tnid.szTip));
	if (bUseTrayBalloon) // if IE version supports this then...
	{
		tnid.uFlags |= NIF_INFO;
		tnid.uTimeout = 60000; // in milliseconds
		tnid.dwInfoFlags = NIIF_INFO;
		LoadString(g_hInst, IDS_BALLOONTITLE, tnid.szInfoTitle, MAXSTRLEN(tnid.szInfoTitle));
		LoadString(g_hInst, IDS_BALLOONTIP, tnid.szInfo, MAXSTRLEN(tnid.szInfo));
	}

	return Shell_NotifyIcon(NIM_ADD, &tnid); 
} 

//****************************************************************************
// MyTaskBarDeleteIcon 
//
// deletes an icon from the taskbar status area. 
// Returns : TRUE if successful, or FALSE otherwise. 
//****************************************************************************
BOOL MyTaskBarDeleteIcon(HWND hwnd, UINT uID) 
{
	NOTIFYICONDATA tnid; 

	tnid.cbSize = sizeof(NOTIFYICONDATA); 
	tnid.hWnd = hwnd; 
	tnid.uID = uID; 
     
	return Shell_NotifyIcon(NIM_DELETE, &tnid); 
} 

//****************************************************************************
// LoadThisXml
//
// Load the given file in XMLDOM object and returns that pointer
// Returns : XMLDom pointer 
//***************************************************************************
CComPtr<IXMLDOMDocument> LoadThisXml(const WCHAR *csFileName)
{	
	// get smart pointer to IXMLDOMDocument interface
	CComPtr<IXMLDOMDocument> pXmlDoc;
	VARIANT vFile;
	CComVariant vtest;
	VARIANT_BOOL vb=1;
	HRESULT hr;
	CComBSTR bstrVal(csFileName); // this has the output file
	//initialize the variant
	VariantInit(&vFile);
	vFile.vt = VT_BSTR; //specify that it contains a string

	hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&pXmlDoc);
	if (FAILED(hr))
		return NULL;

	//increase ref count, else pointer will be released twice before CoUnInitialize() and 
	// will throw exception
	pXmlDoc.p->AddRef();
	V_BSTR(&vFile) = bstrVal;
	pXmlDoc->put_async(VARIANT_FALSE);
	hr = pXmlDoc->load(vFile, &vb);
	if (FAILED (hr) || vb == 0)
		return NULL;
	
	VariantClear(&vFile);

	return pXmlDoc;	
}

//****************************************************************************
// LoadHTTPRequestXml
//
// Makes the request to the asp page and gets the XML out of Response.
// Returns : XMLDom pointer 
//****************************************************************************
CComPtr<IXMLDOMDocument> LoadHTTPRequestXml(WCHAR *csURL, CComPtr<IXMLDOMDocument> pDoc)
{		
	CComPtr<IXMLDOMDocument> pXmlDoc;
	CComPtr<IXMLHttpRequest> pRequest;
	CComPtr<IDispatch> pDispRes;
	CComPtr<IDispatch> pDisp;
	HRESULT hr;
	
	// create an instance of XMLHTTPRequest and open the connection
	hr = CoCreateInstance(CLSID_XMLHTTPRequest, NULL, CLSCTX_INPROC_SERVER, IID_IXMLHttpRequest, (void**)&pRequest);
	if (FAILED(hr))
		goto endRequestXml;

	//hr = pRequest->open(CComBSTR(L("POST")), CComBSTR(csURL), _variantL(VARIANT_FALSE));
	hr = pRequest->open( CComBSTR( L"POST" ), CComBSTR( csURL ), CComVariant(VARIANT_FALSE), CComVariant(), CComVariant());
	if(FAILED(hr))
		goto endRequestXml;

	hr = pRequest->setRequestHeader(CComBSTR(L"ACCEPT_LANGUAGE"),CComBSTR(L"en-us"));
	if(FAILED(hr))
		goto endRequestXml;

	// send the xml now. Get the Dispatch pointer of XML
	hr = pDoc->QueryInterface(IID_IDispatch, (void **)&pDisp);
	if (FAILED(hr))
		goto endRequestXml;
	
#ifdef _DEBUG
	MessageBox(0, L"calling send", L"NotiFlag: LoadHTTPRequestXml", 0);
#endif

	// call send
	VARIANT varDisp;
	varDisp.vt = VT_DISPATCH;
	varDisp.pdispVal = pDisp;
	hr = pRequest->send(varDisp);
	if (FAILED(hr))
		goto endRequestXml;
	VariantClear(&varDisp);

#ifdef _DEBUG
	MessageBox(0, L"calling getxmlresponse", L"NotiFlag: LoadHTTPRequestXml", 0);
#endif
	// Read the response
	hr = pRequest->get_responseXML(&pDispRes);
	if (FAILED(hr))
		goto endRequestXml;
	
	// get the XMLDom pointer from iDispatch 
	hr = pDispRes->QueryInterface(IID_IXMLDOMDocument, (void **)&pXmlDoc);
	if (FAILED(hr))
		goto endRequestXml;

	return pXmlDoc;
endRequestXml:
	return NULL;
}


//***********************************************************************************
// GetNodeValue
//
// Reads the node value from the given XMLDOMDocument and copies into csValue.
// Returns : 0 = success & -ve = error.
//***********************************************************************************
int GetNodeValue(CComPtr<IXMLDOMDocument> pXmlDoc,const WCHAR *csNode, WCHAR *csValue)
{	
 	CComPtr<IXMLDOMNode> pNode;
	CComBSTR bstrIdValue(csNode);
	CComVariant vIdValue;
	HRESULT hr;
	
	// get to the node
	hr = pXmlDoc->selectSingleNode(bstrIdValue, &pNode);

	if (FAILED(hr) || pNode == NULL)
		return -1;
	
	// read the value of the specified tag
	hr = pNode->get_nodeValue(&vIdValue);
	
	if (FAILED(hr))
		return -1;
	{
		USES_CONVERSION;
		wcscpy( csValue,  vIdValue.bstrVal );
	}
	return 0;
}


//***********************************************************************************
// CallNotiflag
//
// Loads local xml file and extracts url from it, hits the url, retrieves xml string
// Loads the retrieved xml string, checks a few conditions and if met, 
// loads an icon in the system tray and when the user clicks on the icon, 
// it takes him to that url in the HSS browser
// Returns : S_OK for success, E_FAIL for failure
//***********************************************************************************
HRESULT CallNotiflag(HINSTANCE hInstance)
{
	#ifdef _DEBUG
			MessageBox(0, L"Notiflag is active", L"Active", 0);			
		#endif		
		
		// Initialize global strings
		LoadString(hInstance, IDS_APP_TITLE, szTitle, _MAX_PATH);
		LoadString(hInstance, IDC_NOTIFLAG, szWindowClass, _MAX_PATH);
		MyRegisterClass(hInstance);
	
	
		
		hr = CoInitialize(NULL);
		if (FAILED(hr))
			goto endNoti;
		{
			//*** to read the xml file info

			//declare smart pointers to XMLDOMDocument Interface 
			CComPtr<IXMLDOMDocument> pSvrXmlDoc;
			CComPtr<IXMLDOMDocument> pUserXmlDoc;

			//string variables to hold xml file path and node text
			WCHAR csXmlFilePath[_MAX_PATH + 1];
			WCHAR csUserXmlFile[_MAX_PATH + 1];
			WCHAR csNode[_MAX_PATH + 1];
			WCHAR csValue[1024];
			WCHAR csUserProfile[_MAX_PATH + 1];
			
			csValue[0] = '\0';

			// get the user profile path
			LoadString(hInstance, IDS_USERPROFILE, csUserProfile, _MAX_PATH);
	 		GetEnvironmentVariable(csUserProfile, csUserXmlFile, _MAX_PATH);
		
			//concatenate the xml file name to the profile path
			LoadString(hInstance, IDS_XMLFILEPATH, csXmlFilePath, _MAX_PATH);
			_tcscat(csUserXmlFile, csXmlFilePath);
		
	#ifdef _DEBUG
		MessageBox(0, csUserXmlFile, L"NotiFlag: client xml", 0);
	#endif

			// load this xml file 
			if ((pUserXmlDoc = LoadThisXml(csUserXmlFile)) == NULL)
				goto endNoti;
			
			//get the value of the node "IncidentID"
			LoadString(hInstance, IDS_INCIDENTID, csNode, _MAX_PATH);
			if (GetNodeValue(pUserXmlDoc, csNode, csValue))
				goto endNoti;	

			if (csValue[0] != '\0')
			{	
				//get the value of the node "RemoteURL"
				LoadString(hInstance, IDS_REMOTEURL, csNode, _MAX_PATH);			
				if (GetNodeValue(pUserXmlDoc, csNode, csValue))
					goto endNoti;
			}

	#ifdef _DEBUG
		MessageBox(0, L"calling the asp file", L"NotiFlag: msg", 0);
	#endif

			// load the server ASP page and load returned XML string in XMLDOM
			if ((pSvrXmlDoc = LoadHTTPRequestXml(csValue, pUserXmlDoc)) == NULL)
				goto endNoti;
			
			_tcscpy(csValue, L"\0");

			//get the value of the node "ResponseCount"
			LoadString(hInstance, IDS_RESPONSECOUNT, csNode, _MAX_PATH);
			if (GetNodeValue(pSvrXmlDoc, csNode, csValue))
				goto endNoti;
			if ((atoi((const char *)csValue)) <= 0)
				goto endNoti;
			
			// else proceed 
	#ifdef _DEBUG
		MessageBox(0, L"reading values", L"NotiFlag: main", 0);
	#endif

			// load the URL to hit
			LoadString(hInstance, IDS_LOCATIONTOHIT, csNode, _MAX_PATH);
			if (GetNodeValue(pSvrXmlDoc, csNode, szURL) || szURL == NULL)
				goto endNoti;
			
			// load the serverdatetime
			LoadString(hInstance, IDS_SERVERDATETIME, csNode, _MAX_PATH);
			if (GetNodeValue(pSvrXmlDoc, csNode, csValue))
				goto endNoti;
			
	#ifdef _DEBUG
		MessageBox(0, L"putting date and saving client xml", L"NotiFlag: main", 0);
	#endif
		}
		//Close the COM library and release resources
		CoUninitialize();		
		return hr=S_OK;
endNoti:
	CoUninitialize();		
	return hr=E_FAIL;
}


//***********************************************************************************
// CallAddNotiTask
//
// Creates a new task in the scheduler
// Returns : S_OK for success, E_FAIL for failure
//***********************************************************************************
HRESULT CallAddNotiTask(HINSTANCE hInstance, LPCTSTR *cmdArgs,LPTSTR lpCmdLine)
{
#ifdef _DEBUG
	MessageBox(0, L"AddNotiTask is Active", L"Active", 0);			
	MessageBox(0, cmdArgs[1], L"First argument", 0);			
#endif
	hr = CoInitialize(NULL);
	if (FAILED(hr))
		goto endAddNotiTask;			
	{
		// smart interface pointers
		CComPtr<ITaskScheduler> pITS;
		CComPtr<IUnknown> pITaskUnknown;
		CComPtr<IScheduledWorkItem> pIScheduledWorkItem;
		CComPtr<ITaskTrigger> pITaskTrigger;
		CComPtr<ITask> pITask;
		
		CComBSTR bstrAccName(lpCmdLine);
		CComBSTR bstrVal;
		WCHAR szUserName[_MAX_PATH + 1];
		WCHAR szRegEntry[_MAX_PATH + 1];
		DWORD cchUserName = MAXSTRLEN(szUserName);

		if ( !GetUserName( szUserName, &cchUserName ) ) 
			goto endAddNotiTask;

			
		BOOL bTaskExists=FALSE;

		// Create a Task Schedular object ...
		hr = CoCreateInstance(CLSID_CTaskScheduler,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_ITaskScheduler,
							(void **) &pITS);
		if (FAILED(hr))
			goto endAddNotiTask;
		
		////////////////////////////////////////////////////////
		// Check/Create a work item/Task 
		////////////////////////////////////////////////////////
		LoadString(hInstance, IDS_TASKNAME, szTaskName, _MAX_PATH);
		
		// check if the work item already exists
		if(SUCCEEDED(pITS->Activate((LPCWSTR)szTaskName, IID_ITask, &pITaskUnknown)))
		{
			bTaskExists = TRUE;
			hr = pITaskUnknown.QueryInterface(&pITask);
			goto endAddNotiTask;
		}
		else
		{
			// create a new work item
			hr = pITS->NewWorkItem(szTaskName,     // Name of task
							CLSID_CTask,            // Class identifier 
							IID_ITask,              // Interface identifier
							(IUnknown**)&pITask);   // Address of task interface
		}
	
		if (FAILED(hr))
			goto endAddNotiTask;
		
		
		// set the account information 
				
		hr = pITask->QueryInterface(IID_IScheduledWorkItem, (void**)&pIScheduledWorkItem);
		if (FAILED(hr) || pIScheduledWorkItem==NULL)
			goto endAddNotiTask;
		
		hr = pIScheduledWorkItem->SetFlags(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON|TASK_FLAG_INTERACTIVE); // TASK_FLAG_RUN_ONLY_IF_LOGGED_ON);
		if (FAILED(hr))
			goto endAddNotiTask;
		
		hr = pIScheduledWorkItem->SetAccountInformation((LPCWSTR)szUserName, NULL);
		if (FAILED(hr))
			goto endAddNotiTask;
		
		
		// get the exe path ... 
		{ 		
			bstrVal = cmdArgs[0];
			hr = pITask->SetApplicationName(bstrVal);
			if (FAILED (hr))
				goto endAddNotiTask;			
		}

		///////////////////////////////////////////////////////////////////
		// Define TASK_TRIGGER structure. 
		// Check/Create the new trigger.
		///////////////////////////////////////////////////////////////////
		
		TASK_TRIGGER pTrigger;
		ZeroMemory(&pTrigger, sizeof (TASK_TRIGGER));
		pTrigger.cbTriggerSize = sizeof (TASK_TRIGGER); 		

		if (bTaskExists)
		{
			hr = pIScheduledWorkItem->GetTrigger(0, &pITaskTrigger);
			if (FAILED(hr) || pITaskTrigger == NULL)
				goto endAddNotiTask;
			
			hr = pITaskTrigger->GetTrigger(&pTrigger);
			if (FAILED(hr))
				goto endAddNotiTask;
		}
		else
		{
			WORD piNewTrigger;
			hr = pIScheduledWorkItem->CreateTrigger(&piNewTrigger, &pITaskTrigger);
			if (FAILED(hr))
				goto endAddNotiTask;
		}	
		if (FAILED(hr) || pITaskTrigger == NULL)
			goto endAddNotiTask;
		
		// add the entry in the registry
		{				
			TCHAR szExePath[_MAX_PATH + 1];			
			HKEY hKey;
			
			if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\PSS\\Notification", 0, KEY_ALL_ACCESS, &hKey))
			{
			#ifdef _DEBUG
				MessageBox(0, L"no registry entry", L"notitask", 0);
			#endif
				// if key doesnt exist, use default values
				pTrigger.wStartHour = 2;				// start from the 1st hour
				pTrigger.wStartMinute = 0;
				pTrigger.MinutesDuration = 1440;		// for 24 hours
				pTrigger.MinutesInterval = 15;			// every 1 hour
			
				// Note that wBeginDay, wBeginMonth, and wBeginYear must 
				// be set to a valid day, month, and year respectively.
				pTrigger.wBeginDay = 1;					// Required  - 1st
				pTrigger.wBeginMonth = 12;				// Required  - December
				pTrigger.wBeginYear = 2000;				// Required  - 2000
			}
			else
			{
			#ifdef _DEBUG
				MessageBox(0, L"registry entry exists", L"notitask", 0);
			#endif
				// if key exists, read from registry

				DWORD lpType = 4;       // type buffer
				DWORD lpData=0;        // data buffer
				DWORD lpcbData=sizeof(DWORD);      // size of data buffer
		
				LoadString(NULL, IDS_WSTARTHOUR, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, szRegEntry,0, &lpType, (LPBYTE)&lpData, &lpcbData ))
					return -1;									
				pTrigger.wStartHour = (WORD)lpData;				// start from the 1st hour
				
				LoadString(NULL, IDS_WSTARTMINUTE, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, szRegEntry,0, &lpType, (LPBYTE)&lpData, &lpcbData ))
					return -1;									
				pTrigger.wStartMinute = (WORD)lpData;	
				
				LoadString(NULL, IDS_MINUTESDURATION, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, szRegEntry,0, &lpType, (LPBYTE)&lpData, &lpcbData ))
					return -1;
				pTrigger.MinutesDuration = (WORD)lpData;		// for 24 hours
				
				LoadString(NULL, IDS_FREQUENCY, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, szRegEntry,0, &lpType, (BYTE *)&lpData, &lpcbData ))
					return -1;
				pTrigger.MinutesInterval = (WORD)lpData;		// for 24 hours
				
				LoadString(NULL, IDS_WBEGINDAY, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, szRegEntry,0, &lpType, (BYTE *)&lpData, &lpcbData ))
					return -1;
				pTrigger.wBeginDay = (WORD)lpData;		// date of the month
				
				LoadString(NULL, IDS_WBEGINMONTH, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, szRegEntry,0, &lpType, (BYTE *)&lpData, &lpcbData ))
					return -1;
				pTrigger.wBeginMonth = (WORD)lpData;    // month
				
				LoadString(NULL, IDS_WBEGINYEAR, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, szRegEntry,0, &lpType, (BYTE *)&lpData, &lpcbData ))
					return -1;
				pTrigger.wBeginYear = (WORD)lpData;		// year
			}

			pTrigger.TriggerType = TASK_TIME_TRIGGER_DAILY;			
			pTrigger.Type.Daily.DaysInterval = 1;	// daily!! 

			// get the application's executable path
			::GetModuleFileName(hInstance, szExePath, _MAX_PATH);
			
			if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\PSS\\Notification", 0, KEY_ALL_ACCESS, &hKey))
			{
				DWORD dwDisposition;
				DWORD szwStartHour = 1;
				DWORD szwStartMinute = 0;
				DWORD szMinutesDuration=1440;
				DWORD szMinutesInterval =15;
				
				DWORD szwBeginDay = 1;
				DWORD szwBeginMonth = 12;
				DWORD szwBeginYear = 2000;


				LoadString(NULL, IDS_REGKEY, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, szRegEntry, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition))
					return -1;
				LoadString(NULL, IDS_WSTARTHOUR, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwStartHour, sizeof(szwStartHour)))
					return -1;
				LoadString(NULL, IDS_WSTARTMINUTE, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwStartMinute, sizeof(szwStartMinute)))
					return -1;
				LoadString(NULL, IDS_MINUTESDURATION, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szMinutesDuration, sizeof(szMinutesDuration)))
					return -1;
                LoadString(NULL, IDS_FREQUENCY, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szMinutesInterval, sizeof(szMinutesInterval)))
					return -1;
				LoadString(NULL, IDS_WBEGINDAY, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwBeginDay, sizeof(szwBeginDay)))
					return -1;
				LoadString(NULL, IDS_WBEGINMONTH, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwBeginMonth, sizeof(szwBeginMonth)))
					return -1;
				LoadString(NULL, IDS_WBEGINYEAR, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwBeginYear, sizeof(szwBeginYear)))
					return -1;
			}
					
			RegCloseKey(hKey);
		}

		// Call ITaskTrigger::SetTrigger to set trigger criteria.
		hr = pITaskTrigger->SetTrigger (&pTrigger);		
		if (FAILED(hr))
			goto endAddNotiTask;

		/////////////////////////////////////////////////////////////////
		// Call IUnknown::QueryInterface to get a pointer to 
		// IPersistFile and IPersistFile::Save to save 
		// the new task to disk.
		/////////////////////////////////////////////////////////////////
		
		CComPtr<IPersistFile> pIPersistFile;
		hr = pITask->QueryInterface(IID_IPersistFile,
								(void **)&pIPersistFile);

		if (FAILED(hr) || pIPersistFile == NULL)
			goto endAddNotiTask;
		
		hr = pIPersistFile->Save(NULL, FALSE);
		if (FAILED(hr))
			goto endAddNotiTask;
	}
	CoUninitialize();	
	return hr = S_OK;

endAddNotiTask:
	CoUninitialize();
	return hr=E_FAIL;
}

HRESULT DisableTask()
{		
 	hr = CoInitialize(NULL);
	if (FAILED(hr))
		goto endDisable;
	{
		CComPtr<ITaskScheduler> pITS;
		CComPtr<IUnknown> pITaskUnknown;
		CComPtr<IScheduledWorkItem> pIScheduledWorkItem;
		CComPtr<ITaskTrigger> pITaskTrigger;
		CComPtr<ITask> pITask;

		WCHAR szUserName[_MAX_PATH + 1];		
		DWORD cchUserName = MAXSTRLEN(szUserName);

		if ( !GetUserName( szUserName, &cchUserName ) ) 
			goto endDisable;

		hr = CoCreateInstance(CLSID_CTaskScheduler,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_ITaskScheduler,
							(void **) &pITS);
		if (FAILED(hr))
			goto endDisable;
	
		LoadString(NULL, IDS_TASKNAME, szTaskName, _MAX_PATH);
		
		if(SUCCEEDED(pITS->Activate((LPCWSTR)szTaskName, IID_ITask, &pITaskUnknown)))
		{
			hr = pITaskUnknown.QueryInterface(&pITask);
			if (FAILED(hr))
				goto endDisable;
		}

		hr = pITask->QueryInterface(IID_IScheduledWorkItem, (void**)&pIScheduledWorkItem);
		if (FAILED(hr) || pIScheduledWorkItem==NULL)
			goto endDisable;
		
		//set the flags to disable the task
		hr = pIScheduledWorkItem->SetFlags(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON|TASK_FLAG_INTERACTIVE|TASK_FLAG_DISABLED); // TASK_FLAG_RUN_ONLY_IF_LOGGED_ON);
		if (FAILED(hr))
			goto endDisable;
		
		// set the account information 
		hr = pIScheduledWorkItem->SetAccountInformation((LPCWSTR)szUserName, NULL);
		if (FAILED(hr))
			goto endDisable;
		
		

		/////////////////////////////////////////////////////////////////
		// Call IUnknown::QueryInterface to get a pointer to 
		// IPersistFile and IPersistFile::Save to save 
		// the new task to disk.
		/////////////////////////////////////////////////////////////////
		
		CComPtr<IPersistFile> pIPersistFile;
		hr = pITask->QueryInterface(IID_IPersistFile,
								(void **)&pIPersistFile);

		if (FAILED(hr) || pIPersistFile == NULL)
			goto endDisable;
		
		hr = pIPersistFile->Save(NULL, FALSE);
		if (FAILED(hr))
			goto endDisable;		
	}
	CoUninitialize();
	return hr=S_OK;

endDisable:
		CoUninitialize();
		return hr=E_FAIL;
}

HRESULT EditTask()
{		
	hr = CoInitialize(NULL);
	if (FAILED(hr))
		goto endEdit;
	{
		CComPtr<ITaskScheduler> pITS;
		CComPtr<ITask> pITask;
		CComPtr<ITaskTrigger> pITaskTrigger;

		hr = CoCreateInstance(CLSID_CTaskScheduler,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_ITaskScheduler,
								(void **) &pITS);
		if (FAILED(hr))
			goto endEdit;
	
		LoadString(NULL, IDS_TASKNAME, szTaskName, _MAX_PATH);
		hr = pITS->Activate(szTaskName,
							IID_ITask,
							(IUnknown**) &pITask);

		if (FAILED(hr))
			goto endEdit;

		  ///////////////////////////////////////////////////////////////////
		  // Call ITask::QueryInterface to retrieve the IProvideTaskPage 
		  // interface, and call IProvideTaskPage::GetPage to retrieve the 
		  // task page.
		  ///////////////////////////////////////////////////////////////////
		  TASKPAGE tpType = TASKPAGE_SCHEDULE;
		  BOOL fPersistChanges = TRUE;
		  HPROPSHEETPAGE phPage; 

		  CComPtr<IProvideTaskPage> pIProvTaskPage;

		  hr = pITask->QueryInterface(IID_IProvideTaskPage,
									  (void **)&pIProvTaskPage);
			  
		  if (FAILED(hr))
			goto endEdit;
		  
		  hr = pIProvTaskPage->GetPage(tpType,
									   fPersistChanges,
									   &phPage);
		  if (FAILED(hr))
			  goto endEdit;
		  
		   
		  
		  //////////////////////////////////////////////////////////////////
		  // Display the page using additional code
		  //////////////////////////////////////////////////////////////////
		  
		  PROPSHEETHEADER psh;
		  ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
		  psh.dwSize = sizeof(PROPSHEETHEADER);
		  psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
		  psh.phpage = &phPage;
		  psh.nPages = 1;

		  INT_PTR psResult = PropertySheet(&psh);
		  if (psResult <= 0)
			goto endEdit;		  

		  ///////////////////////////////////////////////////////////////////
		// Define TASK_TRIGGER structure. 
		// Check/Create the new trigger.
		///////////////////////////////////////////////////////////////////
		
		TASK_TRIGGER pTrigger;
		ZeroMemory(&pTrigger, sizeof (TASK_TRIGGER));
		pTrigger.cbTriggerSize = sizeof (TASK_TRIGGER); 		

		hr = pITask->GetTrigger(0, &pITaskTrigger);
		if (FAILED(hr) || pITaskTrigger == NULL)
			goto endEdit;
		
		hr = pITaskTrigger->GetTrigger(&pTrigger);
		if (FAILED(hr))
			goto endEdit;

		// add the entry in the registry
		{
			DWORD szwStartHour = 1;
			DWORD szwStartMinute = 0;
			DWORD szMinutesDuration = 1440;
			DWORD szMinutesInterval =15;
			
			DWORD szwBeginDay = 1;
			DWORD szwBeginMonth = 12;
			DWORD szwBeginYear = 2000;
			WCHAR szRegEntry[_MAX_PATH + 1];
			HKEY hKey;

			
			szwStartHour = pTrigger.wStartHour;
			szwStartMinute = pTrigger.wStartMinute;
			szMinutesInterval = pTrigger.MinutesInterval;
			szMinutesDuration = pTrigger.MinutesDuration;			
		
			szwBeginDay = pTrigger.wBeginDay;
			szwBeginMonth = pTrigger.wBeginMonth;
			szwBeginYear = pTrigger.wBeginYear;

			LoadString(NULL, IDS_REGKEY, szRegEntry, _MAX_PATH);
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegEntry, 0, KEY_ALL_ACCESS, &hKey))
			{
				LoadString(NULL, IDS_WSTARTHOUR, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwStartHour, sizeof(szwStartHour)))
					goto endEdit;
				LoadString(NULL, IDS_WSTARTMINUTE, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwStartMinute, sizeof(szwStartMinute)))
					goto endEdit;
				LoadString(NULL, IDS_MINUTESDURATION, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szMinutesDuration, sizeof(szMinutesDuration)))
					goto endEdit;
				LoadString(NULL, IDS_FREQUENCY, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szMinutesInterval, sizeof(szMinutesInterval)))
					goto endEdit;
				LoadString(NULL, IDS_WBEGINDAY, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwBeginDay, sizeof(szwBeginDay)))
					goto endEdit;
				LoadString(NULL, IDS_WBEGINMONTH, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwBeginMonth, sizeof(szwBeginMonth)))
					goto endEdit;
				LoadString(NULL, IDS_WBEGINYEAR, szRegEntry, _MAX_PATH);
				if (ERROR_SUCCESS != RegSetValueEx(hKey, szRegEntry, 0, REG_DWORD, (const BYTE *)&szwBeginYear, sizeof(szwBeginYear)))
					goto endEdit;
			}					
			RegCloseKey(hKey);
		}
	}
	CoUninitialize();
	return hr=S_OK;

endEdit:
		CoUninitialize();
		return hr=E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\pss\notiflag\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <atlbase.h>
#include <msxml.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\pss\notiflag\notiflag.h ===
#if !defined(AFX_NOTIFLAG_H__A1CBDB74_B5CA_11D4_BE14_00A0CC65A72D__INCLUDED_)
#define AFX_NOTIFLAG_H__A1CBDB74_B5CA_11D4_BE14_00A0CC65A72D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"
#include <atlbase.h>

int GetNodeValue(CComPtr<IXMLDOMDocument> pXmlDoc, const WCHAR *csNode, WCHAR *csValue);
CComPtr<IXMLDOMDocument> LoadThisXml(const WCHAR *csFileName);
CComPtr<IXMLDOMDocument> LoadHTTPRequestXml(WCHAR *csURL,CComPtr<IXMLDOMDocument> pDoc); 

BOOL MyTaskBarAddIcon(HWND hwnd, UINT uID, HICON hicon);
BOOL MyTaskBarDeleteIcon(HWND hwnd, UINT uID);
HRESULT CallNotiflag(HINSTANCE hInstance);
HRESULT CallAddNotiTask(HINSTANCE hInstance, LPCTSTR *cmdArgs,LPTSTR lpCmdLine);
HRESULT DisableTask();
HRESULT EditTask();

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);



#endif // !defined(AFX_NOTIFLAG_H__A1CBDB74_B5CA_11D4_BE14_00A0CC65A72D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\pss\notiflag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Notiflag.rc
//
#define IDC_MYICON                      2
#define IDD_NOTIFLAG_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   104
#define IDM_ABOUT                       105
#define IDS_BALLOONTITLE                106
#define IDM_EXIT                        107
#define IDS_XMLFILEPATH                 108
#define IDS_HELLO                       109
#define IDS_USERPROFILE                 110
#define IDI_SMALL                       111
#define IDS_INCIDENTID                  112
#define IDC_NOTIFLAG                    113
#define IDS_TOOLTIP                     114
#define IDS_BALLOONTIP                  115
#define IDS_REMOTEURL                   116
#define IDS_RESPONSECOUNT               117
#define IDS_LOCATIONTOHIT               118
#define IDS_SERVERDATETIME              119
#define IDS_NOTIFLAG                    120
#define IDS_TASKNAME                    121
#define IDS_WSTARTHOUR                  122
#define IDS_WSTARTMINUTE                123
#define IDS_MINUTESDURATION             124
#define IDS_FREQUENCY                   125
#define IDS_WBEGINDAY                   126
#define IDS_WBEGINMONTH                 127
#define IDS_WBEGINYEAR                  128
#define IDS_REGKEY                      129
#define IDR_MAINFRAME                   130
#define IDI_FLAGICON                    131
#define IDB_NOTIICON                    132
#define IDC_DISABLE                     133
#define IDC_SETFREQUENCY                134
#define IDI_SMNOTI                      135
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        139
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\auth.cpp ===
#include "stdafx.h"
#include "auth.h"
#include "md5.h"


const CHAR g_cszADVAPI32DllName[] =		"ADVAPI32.DLL";

const CHAR  g_cszCryptAcquireContextA[] =	"CryptAcquireContextA";

const CHAR g_cszCryptCreateHash[] =			"CryptCreateHash";
const CHAR g_cszCryptHashData[] =			"CryptHashData";
const CHAR g_cszCryptGetHashParam[] =		"CryptGetHashParam";
const CHAR g_cszCryptDestroyHash[] =		"CryptDestroyHash";
const CHAR g_cszCryptReleaseContext[] =		"CryptReleaseContext";

const CHAR g_rgchHexNumMap[] =
{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

const int MD5_HASH_LEN =	16;

void
hmac_md5(
unsigned char*  text,                /* pointer to data stream */
int             text_len,            /* length of data stream */
unsigned char*  key,                 /* pointer to authentication key */
int             key_len,             /* length of authentication key */
BYTE         digest[16])              /* caller digest to be filled in */

{
        MD5_CTX context;
        memset(&context, 0, sizeof(context));

        unsigned char k_ipad[65];    /* inner padding -
                                      * key XORd with ipad
                                      */
        unsigned char k_opad[65];    /* outer padding -
                                      * key XORd with opad
                                      */
        int i;
        /* if key is longer than 64 bytes reset it to key=MD5(key) */
        if (key_len > 64) {

                MD5_CTX      tctx;
                memset(&tctx, 0, sizeof(tctx));

                MD5Init(&tctx);
                MD5Update(&tctx, key, key_len);
                MD5Final(&tctx);

                key = tctx.digest;
                key_len = 16;
        }

        /*
         * the HMAC_MD5 transform looks like:
         *
         * MD5(K XOR opad, MD5(K XOR ipad, text))
         *
         * where K is an n byte key
         * ipad is the byte 0x36 repeated 64 times

         * opad is the byte 0x5c repeated 64 times
         * and text is the data being protected
         */

        /* start out by storing key in pads */
        ZeroMemory( k_ipad, sizeof k_ipad);
        ZeroMemory( k_opad, sizeof k_opad);
        CopyMemory( k_ipad, key, key_len);
        CopyMemory( k_opad, key, key_len);

        /* XOR key with ipad and opad values */
        for (i=0; i<64; i++) {
                k_ipad[i] ^= 0x36;
                k_opad[i] ^= 0x5c;
        }
        /*
         * perform inner MD5
         */
        MD5Init(&context);                   /* init context for 1st
                                              * pass */
        MD5Update(&context, k_ipad, 64);     /* start with inner pad */
        MD5Update(&context, text, text_len); /* then text of datagram */
        MD5Final(&context);          /* finish up 1st pass */

		CopyMemory(digest, context.digest, 16);
							 
		/*
         * perform outer MD5
         */
        MD5Init(&context);                   /* init context for 2nd
                                              * pass */
        MD5Update(&context, k_opad, 64);     /* start with outer pad */
        MD5Update(&context, digest, 16);     /* then results of 1st
                                              * hash */
        MD5Final(&context);          /* finish up 2nd pass */
		CopyMemory(digest, context.digest, 16);
}

//------------------------------------------------------------------------------------
//
// Initialize the static class members.
//
//------------------------------------------------------------------------------------
CAuthentication* CAuthentication::m_spAuthentication = NULL;

PSTR CAuthentication::GetHMACMD5Result(PSTR pszChallengeInfo, PSTR pszPassword)
{
	MD5_CTX MD5Buffer;
    memset(&MD5Buffer, 0, sizeof(MD5Buffer));

	MD5Init(&MD5Buffer);
	MD5Update(&MD5Buffer, (const unsigned char*)pszPassword, lstrlenA(pszPassword));
	MD5Final(&MD5Buffer);

	BYTE pbHash[16];
	
	PBYTE pbHexHash = NULL;		// The MD5 result in hex string format
	pbHexHash = new BYTE[MD5DIGESTLEN * 2 + 1];
	if (pbHexHash)
	{
		hmac_md5((unsigned char *) pszChallengeInfo, lstrlenA(pszChallengeInfo), MD5Buffer.digest, sizeof(MD5Buffer.digest), pbHash);

		PBYTE pCurrent = pbHexHash;

		// Convert the hash data to hex string.
		for (int i = 0; i < MD5DIGESTLEN; i++)
		{
			*pCurrent++ = g_rgchHexNumMap[pbHash[i]/16];
			*pCurrent++ = g_rgchHexNumMap[pbHash[i]%16];
		}

		*pCurrent = '\0';
	}

	return (PSTR) pbHexHash;
}


//------------------------------------------------------------------------------------
//
//	Method: 	CAuthentication::GetMD5Key()
//
//	Synopsis:	Construct the MD5 hash key based on the ChallengeInfo and password.
//
//				Append the password to the ChallengeInfo.
//
//------------------------------------------------------------------------------------
PSTR
CAuthentication::GetMD5Key(PSTR pszChallengeInfo, PSTR pszPassword)
{
	int cbChallengeInfo = lstrlenA(pszChallengeInfo);
	int cbPassword = lstrlenA(pszPassword);

	PBYTE pbData = new BYTE[cbChallengeInfo + cbPassword + 1];
	
	if (!pbData)
	{
		//WARNING_OUT(("CAuthentication::GetMD5Key> Out of memory"));
		return NULL;
	}

	PBYTE pCurrent = pbData;

	::CopyMemory(pCurrent, pszChallengeInfo, cbChallengeInfo);
	pCurrent += cbChallengeInfo;
	::CopyMemory(pCurrent, pszPassword, cbPassword);
	pCurrent += cbPassword;
	*pCurrent = '\0';

	return (PSTR)pbData;
}


//------------------------------------------------------------------------------------
//
//  Method:     CAuthentication::GetMD5Result()
//
//  Synposis:  Compute the MD5 hash result based on the clear text.
//
//------------------------------------------------------------------------------------
PSTR
CAuthentication::GetMD5Result(PCSTR pszClearText)
{
    PBYTE pbHexHash = NULL;
    if (pszClearText)
    {
        MD5_CTX MD5Buffer;
        MD5Init(&MD5Buffer);
        MD5Update(&MD5Buffer, (const unsigned char*)pszClearText, lstrlenA(pszClearText));
        MD5Final(&MD5Buffer);

        PBYTE pbHash = MD5Buffer.digest;

        pbHexHash = new BYTE[MD5DIGESTLEN * 2 + 1];
        if (pbHexHash)
        {
            PBYTE pCurrent = pbHexHash;

            // Convert the hash data to hex string.
            for (int i = 0; i < MD5DIGESTLEN; i++)
            {
                *pCurrent++ = g_rgchHexNumMap[pbHash[i]/16];
                *pCurrent++ = g_rgchHexNumMap[pbHash[i]%16];
            }

            *pCurrent = '\0';
        }
        else
        {
            //WARNING_OUT(("CAuthentication::GetMD5Result> Out of memory"));
        }
    }
    return (PSTR)pbHexHash;
}


//------------------------------------------------------------------------------------
//
//	Method: 	CAuthentication::GetMD5Result()
//
//	Synopsis:	Compute the MD5 hash result based on the ChallengeInfo and password.
//
//------------------------------------------------------------------------------------
PSTR 
CAuthentication::GetMD5Result(PSTR pszChallengeInfo, PSTR pszPassword)
{
	PSTR pbHexHash = NULL;		// The MD5 result in hex string format
	PSTR pMD5Key = GetMD5Key(pszChallengeInfo, pszPassword);

	pbHexHash = GetMD5Result(pMD5Key);
	delete pMD5Key;

	return pbHexHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\connection.h ===
// Connection.h : Declaration of the CConnection

#ifndef __CONNECTION_H_
#define __CONNECTION_H_

#include "resource.h"       // main symbols
#include "dplobby.h"


/////////////////////////////////////////////////////////////////////////////
// CConnection
class ATL_NO_VTABLE CConnection : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CConnection, &CLSID_Connection>,
	public IDispatchImpl<IConnection, &IID_IConnection, &LIBID_RCBDYCTLLib>
{
public:
	CConnection();
	~CConnection();

DECLARE_REGISTRY_RESOURCEID(IDR_CONNECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CConnection)
	COM_INTERFACE_ENTRY(IConnection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IConnection
public:
	STDMETHOD(SendDataFromFile)(BSTR bstrFile);
	STDMETHOD(SendData)(BSTR bstrData);
	STDMETHOD(get_ReceivedData)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(NotifyStub)();

private:
    HANDLE m_hEventStub;
};

#endif //__CONNECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\display.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Display.cpp

Abstract:
    This class is used to increase RA performance by down to 256 colors.

Revision History:
    created     steveshi      02/19/01
    
*/

#include "stdafx.h"
#include "rcbdyctl.h"
#include "Display.h"
#include "uxthemep.h"
#include "uxtheme.h"
/////////////////////////////////////////////////////////////////////////////
// CDisplay

CDisplay::CDisplay()
{
}

CDisplay::~CDisplay()
{
}

STDMETHODIMP CDisplay::get_PixBits(LONG *pVal)
{
    HRESULT hr = S_OK;
    DEVMODE DevMode;

    if (EnumDisplaySettings(NULL,
                        ENUM_CURRENT_SETTINGS,
                        &DevMode))
    {
        *pVal = DevMode.dmBitsPerPel;
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
                             
}

STDMETHODIMP CDisplay::put_PixBits(LONG lVal)
{
    // check if the new lVal is supported.
    HRESULT hr = E_INVALIDARG;
    DWORD iNumMode = 0;

    // Get the current settings:
    DEVMODE oldDevMode, DevMode;

    if (EnumDisplaySettings(NULL,
                            ENUM_CURRENT_SETTINGS,
                            &oldDevMode))
    {
        if (oldDevMode.dmBitsPerPel == lVal)
            return S_OK;
    }
    else
        return HRESULT_FROM_WIN32(GetLastError()); // Couldn't get default settings


    while (EnumDisplaySettings(NULL,
                               iNumMode++,
                               &DevMode))
    {
        if (DevMode.dmPelsWidth == oldDevMode.dmPelsWidth &&
            DevMode.dmPelsHeight == oldDevMode.dmPelsHeight &&
            DevMode.dmDisplayFrequency == oldDevMode.dmDisplayFrequency &&
            DevMode.dmBitsPerPel == lVal)
        {
            if (ChangeDisplaySettings(&DevMode, CDS_TEST) == DISP_CHANGE_SUCCESSFUL &&
                ChangeDisplaySettings(&DevMode, 0) == DISP_CHANGE_SUCCESSFUL)
            {
                hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

STDMETHODIMP CDisplay::put_WallPaper(BOOL fOn)
{
    HRESULT hr = S_OK;

    if (!fOn)
    {
        // Turn off wall paper
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, "", SPIF_SENDWININICHANGE);
        // Turn off theme
        ClassicTheme(TRUE);
    }
    else
    {
        // Set it back to default wall paper.
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, SETWALLPAPER_DEFAULT , SPIF_SENDWININICHANGE);
        // Turn the theme back on
        ClassicTheme(FALSE);
    }
    return S_OK;
}

HRESULT CDisplay::ClassicTheme(BOOL fOn)
{
    HRESULT hr=S_OK;
    static WCHAR szNameBuff[MAX_PATH] = {0};
    static WCHAR szColorBuff[MAX_PATH] = {0};
    static WCHAR szSizeBuff[MAX_PATH] = {0};
    DWORD dwMaxNameChars = MAX_PATH - 1;

    if (fOn) // Change to classic theme
    {
        szNameBuff[0] = L'\0';
        hr = GetCurrentThemeName(&szNameBuff[0], dwMaxNameChars, 
                                 &szColorBuff[0], dwMaxNameChars,
                                 &szSizeBuff[0], dwMaxNameChars);
        if (SUCCEEDED(hr))
            ApplyTheme(NULL, AT_NOREGUPDATE, NULL);
    }
    else // Switch to default theme
    {
        if (szNameBuff[0] != L'\0')
        {
            HTHEMEFILE hThemeFile;
            hr = OpenThemeFile(szNameBuff, szColorBuff, szSizeBuff, &hThemeFile, TRUE);
            if (SUCCEEDED(hr))
            {
                ApplyTheme(hThemeFile, AT_NOREGUPDATE, NULL);
                CloseThemeFile(hThemeFile);
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\connection.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Connection.cpp

Abstract:
    This class is used to support IM scenario.

Revision History:
    created     steveshi      11/5/00
    
*/

#include "stdafx.h"
#include "rcbdyctl.h"
#include "Connection.h"

#define EVENT_STUB  TEXT("MutexToCommunicateRemoteAssistance_Stub")

/////////////////////////////////////////////////////////////////////////////
// CConnection

CConnection::CConnection()
{
    m_hEventStub = NULL;
}

CConnection::~CConnection()
{
    if (m_hEventStub)
        CloseHandle(m_hEventStub);
}

STDMETHODIMP CConnection::NotifyStub()
{
    if (!m_hEventStub) 
    {
        m_hEventStub =  CreateEvent(NULL, FALSE, FALSE, EVENT_STUB);
        if(!m_hEventStub)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    SetEvent(m_hEventStub);
	return S_OK;
}

STDMETHODIMP CConnection::get_ReceivedData(BSTR *pVal)
{
	//Goto Registry to fetch data
    HRESULT hr = E_FAIL;
    CRegKey cKey;
    LONG lRet;
    BOOL bRet = FALSE;
    TCHAR szBuf[2001];
    DWORD dwCount = 2000;
    lRet = cKey.Open(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\PCHealth\\RemoteAssistance"));
    if (lRet == ERROR_SUCCESS)
    {
        lRet = cKey.QueryValue(szBuf, TEXT("TransferString"), &dwCount);
        if (lRet == ERROR_SUCCESS)
        {
            *pVal = (BSTR)CComBSTR(szBuf).Copy();
            bRet = TRUE;
        }
        else if (dwCount > 2000) // Assume buffer too small
        {
            TCHAR *pBuf = (TCHAR*)malloc(sizeof(TCHAR) * (dwCount + 1));
            if (pBuf)
            {
                lRet = cKey.QueryValue(pBuf, TEXT("TransferString"), &dwCount);
                if (lRet == ERROR_SUCCESS)
                {
                    *pVal = (BSTR)CComBSTR(pBuf).Copy();
                    bRet = TRUE;
                }

                free(pBuf);
            }
        }
        cKey.Close();
    }

	return S_OK;
}

STDMETHODIMP CConnection::SendData(BSTR bstrData)
{
    HRESULT hr = E_FAIL;
    CRegKey cKey;
    LONG lRet;
    BOOL bRet = FALSE;
    DWORD dwCount = 2000;
    USES_CONVERSION;
    lRet = cKey.Create(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\PCHealth\\RemoteAssistance"));
    if (lRet == ERROR_SUCCESS)
    {
        lRet = cKey.SetValue(W2T(bstrData), TEXT("TransferString"));
        if (lRet == ERROR_SUCCESS)
        {
            bRet = TRUE;
        }
        cKey.Close();
    }


	return S_OK;
}

STDMETHODIMP CConnection::SendDataFromFile(BSTR bstrFile)
{
    HRESULT hr = E_FAIL;
    CRegKey cKey;
    LONG lRet;
    BOOL bRet = FALSE;
    BYTE szBuf[258];
    DWORD dwCount = 2000;
    CComBSTR bstrBlob;
    HANDLE hFile = CreateFile(
        bstrFile, 
        GENERIC_READ, 
        FILE_SHARE_READ, 
        NULL, 
        OPEN_EXISTING, 
        FILE_ATTRIBUTE_TEMPORARY, 
        NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    while (ReadFile(hFile,
                szBuf,
                256,
                &dwCount,
                NULL))
    {
        if (dwCount == 0)
            break;

        *(WCHAR*)((WCHAR*)&szBuf + (dwCount>>1)) = L'\0';        
        bstrBlob.Append((LPCTSTR)&szBuf[0]);
    }

    lRet = cKey.Create(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\PCHealth\\RemoteAssistance"));
    if (lRet == ERROR_SUCCESS)
    {
        lRet = cKey.SetValue(bstrBlob, TEXT("TransferString"));
        if (lRet == ERROR_SUCCESS)
        {
            bRet = TRUE;
        }
        cKey.Close();
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\auth.h ===
#ifndef _AUTHENTICATION_H_
#define _AUTHENTICATION_H_


class CAuthentication
{
public:
	CAuthentication();
	~CAuthentication();

	static CAuthentication* GetAuthentication();

	static PSTR GetMD5Result(PCSTR pszClearText);

	static PSTR GetMD5Result(PSTR pszChallengeInfo, PSTR pszPassword);

	static PSTR GetHMACMD5Result(PSTR pszChallengeInfo, PSTR pszPassword);

private:

	static PSTR GetMD5Key(PSTR pszChallengeInfo, PSTR pszPassword);

	static CAuthentication* m_spAuthentication;

};


inline
CAuthentication::CAuthentication()
{
	// Make sure that the singleton object is not instantiated multiple times.
	_ASSERT(NULL == m_spAuthentication);
	m_spAuthentication = this;
}


inline
CAuthentication::~CAuthentication()
{
	m_spAuthentication = NULL;
}


inline CAuthentication* 
CAuthentication::GetAuthentication()
{
	return m_spAuthentication;
}

#endif //  _AUTHENTICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\display.h ===
// DISPLAY.h : Declaration of the CDisplay

#ifndef __DISPLAY_H_
#define __DISPLAY_H_

#include "resource.h"       // main symbols
#include "dplobby.h"


/////////////////////////////////////////////////////////////////////////////
// CDisplay
class ATL_NO_VTABLE CDisplay : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDisplay, &CLSID_Display>,
	public IDispatchImpl<IDisplay, &IID_IDisplay, &LIBID_RCBDYCTLLib>
{
public:
	CDisplay();
	~CDisplay();

DECLARE_REGISTRY_RESOURCEID(IDR_DISPLAY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDisplay)
	COM_INTERFACE_ENTRY(IDisplay)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDisplay
public:
	STDMETHOD(get_PixBits)(/*[out, retval]*/ LONG *lVal);
	STDMETHOD(put_PixBits)(/*[in]*/ LONG lVal);
	STDMETHOD(put_WallPaper)(/*[in]*/ BOOL fOn);

private:
    HRESULT ClassicTheme(BOOL fOn);
};

#endif //__DISPLAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\enumrecipient.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    EnumRecipient.cpp

Abstract:
    Helper object to support Recipients enumeration.

Revision History:
    created     steveshi      08/23/00
    
*/

#include "stdafx.h"
#include "rcbdyctl.h"
#include "EnumRecipient.h"
#include "Recipients.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP EnumRecipient::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEnumVARIANT,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP EnumRecipient::Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched)
{
	HRESULT		hr = 0;
	ULONG		cFetched = 0;
	VARIANT *	pv = rgvar;
	IRecipient*	pItem = NULL;

	// _ASSERT(m_pIncidents);

	for (; cFetched < celt; cFetched++, pv++)
	{
		pItem = NULL;
		if (hr = m_pRecipients->get_Item( m_iCurr++,  &pItem))
			break;

		pv->pdispVal = pItem;
		V_VT(pv) = VT_DISPATCH;
	}

	// OLE Auto spec says that we can return only S_OK/S_FALSE
	if (hr  ||  cFetched < celt)
		hr = S_FALSE;

//done:
	if (pceltFetched)
		*pceltFetched = cFetched;

	return hr;
}

STDMETHODIMP EnumRecipient::Skip(ULONG celt)
{
	HRESULT	hr = S_OK;
	LONG	lcount = 0;

	_ASSERT(m_pRecipients);

    m_iCurr+=celt;

	hr = m_pRecipients->get_Count(&lcount);
	if (FAILED(hr))
        goto done;

	if (m_iCurr > (ULONG)lcount)
        m_iCurr = lcount;

done:
    return FAILED(hr) ? S_FALSE : S_OK;
}

STDMETHODIMP EnumRecipient::Reset()
{
	m_iCurr = 0;

	return S_OK;
}

STDMETHODIMP EnumRecipient::Clone(IEnumVARIANT** ppenum)
{
	HRESULT		hr = S_OK;
	CComObject<EnumRecipient>*	pEnum;

    if (hr = CComObject<EnumRecipient>::CreateInstance(&pEnum))
		goto done;

    pEnum->AddRef();
	if (hr = pEnum->Init(m_pRecipients))
	{
		pEnum->Release();
		goto done;
	}
	*ppenum = (IEnumVARIANT * )pEnum;
	
done:
	return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\enumrecipient.h ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    EnumRecipient.h

Abstract:
    Definition of the EnumRecipient class

Revision History:
    created     steveshi      08/23/00
    
*/
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMRECIPIENT_H__9B5349B2_CEC0_4C95_89D9_C29776CD54B8__INCLUDED_)
#define AFX_ENUMRECIPIENT_H__9B5349B2_CEC0_4C95_89D9_C29776CD54B8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// EnumRecipient

class EnumRecipient : 
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_RCBDYCTLLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	EnumRecipient() { m_pRecipients = NULL; m_iCurr=0; }
BEGIN_COM_MAP(EnumRecipient)
	COM_INTERFACE_ENTRY2(IDispatch, IEnumVARIANT)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(EnumRecipient) 

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEnumRecipient
public:
	STDMETHOD(Next)(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched);
	STDMETHOD(Clone)(IEnumVARIANT** ppenum);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(ULONG celt);

public:
	HRESULT Init(Recipients* p){ m_pRecipients = p; return S_OK; }

protected:
	Recipients* m_pRecipients;
	ULONG		m_iCurr;
};

#endif // !defined(AFX_ENUMRECIPIENT_H__9B5349B2_CEC0_4C95_89D9_C29776CD54B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\helper.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    Helper.cpp

Abstract:

    Various funtion encapsulate HELP user account
    validation, creating.

Author:

    HueiWang    2/17/2000

--*/

#include "stdafx.h"
#include <time.h>
#include <stdio.h>

#ifndef __WIN9XBUILD__

#include <windows.h>
#include <ntsecapi.h>
#include <lmcons.h>
#include <lm.h>
#include <sspi.h>
#include <wtsapi32.h>
#include <winbase.h>
#include <security.h>
#include <wincrypt.h>

#endif

#include "Helper.h"

#ifndef __WIN9XBUILD__

#if DBG

void
DebugPrintf(
    IN LPCTSTR format, ...
    )
/*++

Routine Description:

    sprintf() like wrapper around OutputDebugString().

Parameters:

    hConsole : Handle to console.
    format : format string.

Returns:

    None.

Note:

    To be replace by generic tracing code.

++*/
{
    TCHAR  buf[8096];   // max. error text
    DWORD  dump;
    va_list marker;
    va_start(marker, format);

    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    try {

        memset(
                buf, 
                0, 
                sizeof(buf)
            );

        _sntprintf(
                buf,
                sizeof(buf)/sizeof(buf[0]),
                _TEXT(" %d [%d:%d:%d:%d:%d.%d] : "),
                GetCurrentThreadId(),
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond,
                sysTime.wMilliseconds
            );

        _vsntprintf(
                buf + lstrlen(buf),
                sizeof(buf)/sizeof(buf[0]) - lstrlen(buf),
                format,
                marker
            );

        OutputDebugString(buf);
    }
    catch(...) {
    }

    va_end(marker);
    return;
}
#endif

#endif


void
UnixTimeToFileTime(
    time_t t,
    LPFILETIME pft
    )
{
    LARGE_INTEGER li;

    li.QuadPart = Int32x32To64(t, 10000000) + 116444736000000000;

    pft->dwHighDateTime = li.HighPart;
    pft->dwLowDateTime = li.LowPart;
}


#ifndef __WIN9XBUILD__

/*----------------------------------------------------------------------------
Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


Note : Code modified from 5.0 \\rastaman\ntwin\src\base\advapi\security.c
----------------------------------------------------------------------------*/
BOOL
TLSCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    DWORD  Status = ERROR_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = { STANDARD_RIGHTS_READ,
                                       STANDARD_RIGHTS_EXECUTE,
                                       STANDARD_RIGHTS_WRITE,
                                       STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //
    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    BOOL AccessStatus = FALSE;
    PACL Dacl = NULL;

    #define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //
    if (TokenHandle != NULL)
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        if(!OpenThreadToken(GetCurrentThread(),
                            TOKEN_QUERY,
                            FALSE,              // don't open as self
                            &EffectiveToken))
        {
            //
            // if there is no thread token, try the process token
            //
            if((Status=GetLastError()) == ERROR_NO_TOKEN)
            {
                if(!OpenProcessToken(GetCurrentProcess(),
                                     TOKEN_QUERY | TOKEN_DUPLICATE,
                                     &ProcessToken))
                {
                    Status = GetLastError();
                }

                //
                // If we have a process token, we need to convert it to an
                // impersonation token
                //
                if (Status == ERROR_SUCCESS)
                {
                    BOOL Result;
                    Result = DuplicateToken(ProcessToken,
                                            SecurityImpersonation,
                                            &EffectiveToken);
                    CloseHandle(ProcessToken);
                    if (!Result)
                    {
                        return(FALSE);
                    }
                }
            }

            if (Status != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * GetLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    InitializeSecurityDescriptor(SecDesc, SECURITY_DESCRIPTOR_REVISION);

    //
    // Fill in fields of security descriptor
    //
    SetSecurityDescriptorOwner(SecDesc, SidToCheck, FALSE);
    SetSecurityDescriptorGroup(SecDesc, SidToCheck, FALSE);

    if(!InitializeAcl(  Dacl,
                        SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                        ACL_REVISION))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AddAccessAllowedAce(Dacl, ACL_REVISION, MEMBER_ACCESS, SidToCheck))
    {
        Status=GetLastError();  
        goto Cleanup;
    }

    if(!SetSecurityDescriptorDacl(SecDesc, TRUE, Dacl, FALSE))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AccessCheck(SecDesc,
                    EffectiveToken,
                    MEMBER_ACCESS,
                    &GenericMapping,
                    PrivilegeSet,
                    &PrivilegeSetLength,
                    &AccessGranted,
                    &AccessStatus))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //
    if ((AccessStatus == TRUE) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }


Cleanup:
    if (TokenHandle == NULL && EffectiveToken != NULL)
    {
        CloseHandle(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    return (Status == ERROR_SUCCESS) ? TRUE : FALSE;
}


/*------------------------------------------------------------------------

 BOOL IsUserAdmin(BOOL)

  returns TRUE if user is an admin
          FALSE if user is not an admin
------------------------------------------------------------------------*/
DWORD 
IsUserAdmin(
    BOOL* bMember
    )
{
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD dwStatus=ERROR_SUCCESS;

    do {
        if(!AllocateAndInitializeSid(&siaNtAuthority, 
                                     2, 
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &psidAdministrators))
        {
            dwStatus=GetLastError();
            continue;
        }

        // assume that we don't find the admin SID.
        if(!TLSCheckTokenMembership(NULL,
                                   psidAdministrators,
                                   bMember))
        {
            dwStatus=GetLastError();
        }

        FreeSid(psidAdministrators);

    } while(FALSE);

    return dwStatus;
}

#endif

//-----------------------------------------------------
DWORD
GetRandomNum(
    VOID
    )
/*++

Routine Description:

    Routine to generate a random number.

Parameters:

    None.

Return:

    A random number.

Note:

    Code Modified from winsta\server\wstrpc.c

--*/
{
    FILETIME fileTime;
    FILETIME ftThreadCreateTime;
    FILETIME ftThreadExitTime;
    FILETIME ftThreadKernelTime;
    FILETIME ftThreadUserTime;
    int r1,r2,r3;

    //
    // Generate 3 pseudo-random numbers using the Seed parameter, the
    // system time, and the user-mode execution time of this process as
    // random number generator seeds.
    //
    GetSystemTimeAsFileTime(&fileTime);

    GetThreadTimes(
                GetCurrentThread(),
                &ftThreadCreateTime,
                &ftThreadExitTime,
                &ftThreadKernelTime,
                &ftThreadUserTime
            );

    //
    //  Don't bother with error conditions, as this function will return
    //  as random number, the sum of the 3 numbers generated.
    //
    srand(GetCurrentThreadId());
    r1 = ((DWORD)rand() << 16) + (DWORD)rand();

    srand(fileTime.dwLowDateTime);
    r2 = ((DWORD)rand() << 16) + (DWORD)rand();

    srand(ftThreadKernelTime.dwLowDateTime);
    r3 = ((DWORD)rand() << 16) + (DWORD)rand();

    return(DWORD)( r1 + r2 + r3 );
}

DWORD
GetRandomNumber( 
    HCRYPTPROV hProv
    )
/*++

--*/
{
    DWORD random_number = 0;
    
    if( !hProv || !CryptGenRandom(hProv, sizeof(random_number), (PBYTE)&random_number) )
    {
        //
        // Almost impossbile to fail CryptGenRandom()/CryptAcquireContext()
        //
        random_number = GetRandomNum();
    }
 
    return random_number; 
}

//-----------------------------------------------------

VOID
ShuffleCharArray(
    IN HCRYPTPROV hProv,
    IN int iSizeOfTheArray,
    IN OUT TCHAR *lptsTheArray
    )
/*++

Routine Description:

    Random shuffle content of a char. array.

Parameters:

    iSizeOfTheArray : Size of array.
    lptsTheArray : On input, the array to be randomly shuffer,
                   on output, the shuffled array.

Returns:

    None.
                   
Note:

    Code Modified from winsta\server\wstrpc.c

--*/
{
    int i;
    int iTotal;

    iTotal = iSizeOfTheArray / sizeof(TCHAR);
    for (i = 0; i < iTotal; i++)
    {
        DWORD RandomNum = GetRandomNumber(hProv);
        TCHAR c;

        c = lptsTheArray[i];
        lptsTheArray[i] = lptsTheArray[RandomNum % iTotal];
        lptsTheArray[RandomNum % iTotal] = c;
    }
}

//-----------------------------------------------------

DWORD
GenerateRandomBytes(
    IN DWORD dwSize,
    IN OUT LPBYTE pbBuffer
    )
/*++

Description:

    Generate fill buffer with random bytes.

Parameters:

    dwSize : Size of buffer pbBuffer point to.
    pbBuffer : Pointer to buffer to hold the random bytes.

Returns:

    TRUE/FALSE

--*/
{
    HCRYPTPROV hProv = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !CryptGenRandom(hProv, dwSize, pbBuffer) )
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:    

    if( NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}


DWORD
GenerateRandomString(
    IN DWORD dwSizeRandomSeed,
    IN OUT LPTSTR* pszRandomString
    )
/*++


--*/
{
    PBYTE lpBuffer = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    DWORD cbConvertString = 0;

    if( 0 == dwSizeRandomSeed || NULL == pszRandomString )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        //MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = NULL;

    lpBuffer = (PBYTE)LocalAlloc( LPTR, dwSizeRandomSeed );  
    if( NULL == lpBuffer )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = GenerateRandomBytes( dwSizeRandomSeed, lpBuffer );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Convert to string
    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                0,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = (LPTSTR)LocalAlloc( LPTR, (cbConvertString+1)*sizeof(TCHAR) );
    if( NULL == *pszRandomString )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                *pszRandomString,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        if( (*pszRandomString)[cbConvertString - 1] == '\n' &&
            (*pszRandomString)[cbConvertString - 2] == '\r' )
        {
            (*pszRandomString)[cbConvertString - 2] = 0;
        }
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != *pszRandomString )
        {
            LocalFree(*pszRandomString);
        }
    }

    if( NULL != lpBuffer )
    {
        LocalFree(lpBuffer);
    }

    return dwStatus;
}

VOID
CreatePassword(
    OUT TCHAR *pszPassword
    )
/*++

Routine Description:

    Routine to randomly create a password.

Parameters:

    pszPassword : Pointer to buffer to received a randomly generated
                  password, buffer must be at least 
                  MAX_HELPACCOUNT_PASSWORD+1 characters.

Returns:

    None.

Note:

    Code copied from winsta\server\wstrpc.c

--*/
{
    HCRYPTPROV hProv = NULL;

    int   nLength = MAX_HELPACCOUNT_PASSWORD;
    int   iTotal = 0;
    DWORD RandomNum = 0;
    int   i;
    time_t timeVal;

    TCHAR six2pr[64] = 
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'),
        _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'),
        _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'),
        _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z'), _T('a'), _T('b'),
        _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'),
        _T('j'), _T('k'), _T('l'), _T('m'), _T('n'), _T('o'), _T('p'),
        _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'),
        _T('x'), _T('y'), _T('z'), _T('0'), _T('1'), _T('2'), _T('3'),
        _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9'), _T('*'),
        _T('_')
    };

    TCHAR something1[12] = 
    {
        _T('!'), _T('@'), _T('#'), _T('$'), _T('^'), _T('&'), _T('*'),
        _T('('), _T(')'), _T('-'), _T('+'), _T('=')
    };

    TCHAR something2[10] = 
    {
        _T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'),
        _T('7'), _T('8'), _T('9')
    };

    TCHAR something3[26] = 
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'),
        _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'),
        _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'),
        _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z')
    };

    TCHAR something4[26] = 
    {
        _T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'),
        _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'), _T('n'),
        _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'),
        _T('v'), _T('w'), _T('x'), _T('y'), _T('z')
    };

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        hProv = NULL;
    }

    //
    //  Seed the random number generation for rand() call in GetRandomNum().
    //

    time(&timeVal);
    srand((unsigned int)timeVal + rand() );

    //
    //  Shuffle around the six2pr[] array.
    //

    ShuffleCharArray(hProv, sizeof(six2pr), six2pr);

    //
    //  Assign each character of the password array.
    //

    iTotal = sizeof(six2pr) / sizeof(TCHAR);
    for (i=0; i<nLength; i++) 
    {
        RandomNum=GetRandomNumber(hProv);
        pszPassword[i]=six2pr[RandomNum%iTotal];
    }

    //
    //  In order to meet a possible policy set upon passwords, replace chars
    //  2 through 5 with these:
    //
    //  1) something from !@#$%^&*()-+=
    //  2) something from 1234567890
    //  3) an uppercase letter
    //  4) a lowercase letter
    //

    ShuffleCharArray(hProv, sizeof(something1), (TCHAR*)&something1);
    ShuffleCharArray(hProv, sizeof(something2), (TCHAR*)&something2);
    ShuffleCharArray(hProv, sizeof(something3), (TCHAR*)&something3);
    ShuffleCharArray(hProv, sizeof(something4), (TCHAR*)&something4);

    RandomNum = GetRandomNumber(hProv);
    iTotal = sizeof(something1) / sizeof(TCHAR);
    pszPassword[2] = something1[RandomNum % iTotal];

    RandomNum = GetRandomNumber(hProv);
    iTotal = sizeof(something2) / sizeof(TCHAR);
    pszPassword[3] = something2[RandomNum % iTotal];

    RandomNum = GetRandomNumber(hProv);
    iTotal = sizeof(something3) / sizeof(TCHAR);
    pszPassword[4] = something3[RandomNum % iTotal];

    RandomNum = GetRandomNumber(hProv);
    iTotal = sizeof(something4) / sizeof(TCHAR);
    pszPassword[5] = something4[RandomNum % iTotal];

    pszPassword[nLength] = _T('\0');

    if( NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return;
}

//--------------------------------------------------------
#ifndef __WIN9XBUILD__


BOOL
LookupAliasFromRid(
    LPWSTR pTargetComputer,
    DWORD Rid,
    LPWSTR pName,
    PDWORD cchName
    )
{
    BOOL fRet;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SidIdentifierAuthority = SECURITY_NT_AUTHORITY;
    SID_NAME_USE SidNameUse;
    ULONG cchDomainName;
    WCHAR szDomainName[256];

    //
    //  Sid is the same regardless of machine, since the well-known
    //  BUILTIN domain is referenced.
    //

    fRet = AllocateAndInitializeSid(
                                &SidIdentifierAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                Rid,
                                0, 0, 0, 0, 0, 0,
                                &pSid
                            );

    if (fRet)
    {
        cchDomainName = sizeof(szDomainName)/sizeof(szDomainName);

        fRet = LookupAccountSidW(
                            pTargetComputer,
                            pSid,
                            pName,
                            cchName,
                            szDomainName,
                            &cchDomainName,
                            &SidNameUse
                        );

        FreeSid(pSid);
    }

    return(fRet);
}


DWORD
IsUserInLocalGroup(
    IN PBYTE pbUserSid,
    IN LPCTSTR pszLocalGroup,
    OUT BOOL* pbInGroup
    )
/*++

Routine Description:

    Check if user is member of specific local group.

Parameters:

    pbUserSid : SID of user to be verified.
    pszLocalGroup : Name of local group.
    pbInGroup : Return TRUE if user is in group, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code, membership is returned via pbInGroup
    parameter.
    
Note:

    If 'everyone' is member of the specfied group, routine will 
    immediately return SUCCESS.

--*/
{
    NET_API_STATUS netErr;
    LOCALGROUP_MEMBERS_INFO_0* pBuf=NULL;

    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID pEveryoneSID = NULL;
    DWORD dwEntries;
    DWORD dwTotal;

    *pbInGroup = FALSE;
    //
    // By default add everyone to the group
    //
    if(AllocateAndInitializeSid(  &SIDAuthWorld, 1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pEveryoneSID) )
    {
        //
        // Retrieve group member.
        //
        netErr = NetLocalGroupGetMembers(
                                    NULL,
                                    pszLocalGroup,
                                    0,
                                    (LPBYTE *)&pBuf,
                                    MAX_PREFERRED_LENGTH,
                                    &dwEntries,
                                    &dwTotal,
                                    NULL
                                );

        if( NERR_Success == netErr )
        {
            for(DWORD index=0; index < dwEntries; index++ )
            {
                if(TRUE == EqualSid( pEveryoneSID, pBuf[index].lgrmi0_sid) )
                {
                    *pbInGroup = TRUE;
                    break;
                }

                if(NULL != pbUserSid && TRUE == EqualSid( pbUserSid, pBuf[index].lgrmi0_sid) )
                {
                    *pbInGroup = TRUE;
                    break;
                }
            }

            NetApiBufferFree( pBuf );
        }

        FreeSid( pEveryoneSID );
    }
    else
    {
        netErr = GetLastError();
    }

    return netErr;
}

BOOL
IsLocalGroupExists(
    IN LPWSTR pszGroupName
    )
/*++

Routine Description:

    Verify if local group exist on machine.

Parameter:

    pszGroupName : Name of the group to be checked.

Returns:

    TRUE/FALSE

--*/
{
    LOCALGROUP_INFO_1* pGroupInfo1;
    NET_API_STATUS netStatus;
    BOOL bGroupExists;

    //
    // Check to see if group exists
    //
    netStatus = NetLocalGroupGetInfo(
                            NULL,
                            pszGroupName,
                            1,
                            (PBYTE *)&pGroupInfo1
                        );

    if( NERR_Success == netStatus )
    {
        NetApiBufferFree(pGroupInfo1);
    }
    else
    {
        SetLastError( netStatus );
    }

    return ( NERR_Success == netStatus );
}

//---------------------------------------------------------

DWORD
CreateLocalGroup(
    IN LPWSTR pszGroupName,
    IN LPWSTR pszGroupDesc,
    IN BOOL bAddEveryone
    )
/*++

Routine Description:

    Create a group on local machine.

Parameters:

    pszGroupName : Group name.
    pszGroupDesc : Group desc.
    bAddEveryone : TRUE if add 'everyone' to the group, FALSE
                   otherwise.

Returns:
    
    ERROR_SUCCESS or error code

--*/
{
    NET_API_STATUS netStatus;
    LOCALGROUP_INFO_1 GroupInfo;
    DWORD dwParmErr;

    GroupInfo.lgrpi1_name = pszGroupName;
    GroupInfo.lgrpi1_comment = pszGroupDesc;

    netStatus = NetLocalGroupAdd(
                            NULL,
                            1,
                            (LPBYTE)&GroupInfo,
                            &dwParmErr
                        );

    if( NERR_Success == netStatus )
    {
        if(FALSE == IsLocalGroupExists(pszGroupName))
        {
            // We have big problem
            netStatus = GetLastError();
        }
    }

    if( NERR_Success == netStatus && TRUE == bAddEveryone )
    {
        LOCALGROUP_MEMBERS_INFO_0 gmember;
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        PSID pEveryoneSID = NULL;

        //
        // add everyone to the group
        //
        if(AllocateAndInitializeSid(  &SIDAuthWorld, 1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pEveryoneSID) )
        {
            gmember.lgrmi0_sid = pEveryoneSID;

            bAddEveryone = NetLocalGroupAddMembers(
                                    NULL,
                                    pszGroupName,
                                    0,
                                    (PBYTE)&gmember,
                                    1
                                );

            if( ERROR_MEMBER_IN_ALIAS == netStatus )
            {
                // ignore this error
                netStatus = NERR_Success;
            }

            FreeSid( pEveryoneSID );
        }
    }

    return netStatus;
}

//---------------------------------------------------------

DWORD
IsLocalAccountEnabled(
    IN LPWSTR pszUserName,
    IN BOOL* pEnabled
    )
/*++

Routine Description:

    Check if local account enabled    

Parameters:

    pszUserName : Name of user account.
    pEnabled : Return TRUE is account is enabled, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwResult;
    NET_API_STATUS err;
    LPBYTE pBuffer;
    USER_INFO_1 *pUserInfo;

    err = NetUserGetInfo(
                        NULL,
                        pszUserName,
                        1,
                        &pBuffer
                    );

    if( NERR_Success == err )
    {
        pUserInfo = (USER_INFO_1 *)pBuffer;

        if (pUserInfo != NULL)
        {
            if( pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
            {
                *pEnabled = FALSE;
            }
            else
            {
                *pEnabled = TRUE;
            }
        }

        NetApiBufferFree( pBuffer );
    }
    else if( NERR_UserNotFound == err )
    {
        *pEnabled = FALSE;
        //err = NERR_Success;
    }

    return err;
}

//---------------------------------------------------------

DWORD
EnableLocalAccount(
    IN LPWSTR pszUserName,
    IN BOOL bEnable
    )
/*++

Routine Description:

    Routine to enable/disable a local account.

Parameters:

    pszUserName : Name of user account.
    bEnable : TRUE if enabling account, FALSE if disabling account.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwResult;
    NET_API_STATUS err;
    LPBYTE pBuffer;
    USER_INFO_1 *pUserInfo;
    BOOL bChangeAccStatus = TRUE;

    err = NetUserGetInfo(
                        NULL,
                        pszUserName,
                        1,
                        &pBuffer
                    );

    if( NERR_Success == err )
    {
        pUserInfo = (USER_INFO_1 *)pBuffer;

        if(pUserInfo != NULL)
        {

            if( TRUE == bEnable && pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
            {
                pUserInfo->usri1_flags &= ~UF_ACCOUNTDISABLE;
            }
            else if( FALSE == bEnable && !(pUserInfo->usri1_flags & UF_ACCOUNTDISABLE) )
            {
                pUserInfo->usri1_flags |= UF_ACCOUNTDISABLE;
            }   
            else
            {
                bChangeAccStatus = FALSE;
            }

            if( TRUE == bChangeAccStatus )
            {
                err = NetUserSetInfo( 
                                NULL,
                                pszUserName,
                                1,
                                pBuffer,
                                &dwResult
                            );
            }
        }

        NetApiBufferFree( pBuffer );
    }

    return err;
}

//---------------------------------------------------------

BOOL
IsTermSrvInstalled()
/*++

Routine Description:

    Check if TS is installed on local box.

Parameters:

    None.

Return:

    TRUE/FALSE
--*/
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    BOOL bSuccess;

    ZeroMemory(
            &osVersionInfo, 
            sizeof(OSVERSIONINFOEX)
        );

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
    bSuccess= VerifyVersionInfo(
                            &osVersionInfo,
                            VER_SUITENAME,
                            dwlConditionMask
                        );

    return bSuccess;
}
    

DWORD
CreateLocalAccount(
    IN LPWSTR pszUserName,
    IN LPWSTR pszUserPwd,
    IN LPWSTR pszFullName,
    IN LPWSTR pszComment,
    IN LPWSTR pszGroup,
    IN LPWSTR pszScript,
    OUT BOOL* pbAccountExist
    )
/*++

Routine Description:

    Create an user account on local machine.

Parameters:

    pszUserName : Name of the user account.
    pszUserPwd : User account password.
    pszFullName : Account Full Name.
    pszComment : Account comment.
    pszGroup : Local group of the account.
    pbAccountExist ; Return TRUE if account already exists, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    LPBYTE pbServer = NULL;
    BYTE *pBuffer;
    NET_API_STATUS netErr = NERR_Success;
    DWORD parm_err;
    DWORD dwStatus;

    netErr = NetUserGetInfo( 
                        NULL, 
                        pszUserName, 
                        3, 
                        &pBuffer 
                    );

    if( NERR_Success == netErr )
    {
        //
        // User account exists, if account is disabled,
        // enable it and change password
        //
        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

        if( lpui3->usri3_flags & UF_ACCOUNTDISABLE ||
            lpui3->usri3_flags & UF_LOCKOUT )
        {
            // enable the account
            lpui3->usri3_flags &= ~ ~UF_LOCKOUT;;

            if( lpui3->usri3_flags & UF_ACCOUNTDISABLE )
            {
                // we only reset password if account is disabled.
                lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
            }

            //lpui3->usri3_password = pszUserPwd;

            // reset password if account is disabled.
            lpui3->usri3_name = pszUserName;
            lpui3->usri3_comment = pszComment;
            lpui3->usri3_full_name = pszFullName;
            //lpui3->usri3_primary_group_id = dwGroupId;

            netErr = NetUserSetInfo(
                                NULL,
                                pszUserName,
                                3,
                                (PBYTE)lpui3,
                                &parm_err
                            );
        }

        *pbAccountExist = TRUE;
        NetApiBufferFree(pBuffer);
    }
    else if( NERR_UserNotFound == netErr )
    {
        //
        // Account does not exist, create and set it to our group
        //
        USER_INFO_1 UserInfo;

        memset(&UserInfo, 0, sizeof(USER_INFO_1));

        UserInfo.usri1_name = pszUserName;
        UserInfo.usri1_password = pszUserPwd;
        UserInfo.usri1_priv = USER_PRIV_USER;   // see USER_INFO_1 for detail
        UserInfo.usri1_comment = pszComment;
        UserInfo.usri1_flags = UF_PASSWD_CANT_CHANGE | UF_DONT_EXPIRE_PASSWD;

        netErr = NetUserAdd(
                        NULL,
                        1,
                        (PBYTE)&UserInfo,
                        &parm_err
                    );

        *pbAccountExist = FALSE;
    }

    return netErr;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
ChangeLocalAccountPassword(
    IN LPWSTR pszAccName,
    IN LPWSTR pszOldPwd,
    IN LPWSTR pszNewPwd
    )
/*++

Routine Description:

    Change password of a local account.

Parameters:

    pszAccName : Name of user account.
    pszOldPwd : Old password.
    pszNewPwd : New password.

Returns:

    ERROR_SUCCESS or error code.

Notes:

    User NetUserChangePassword(), must have priviledge

--*/
{
    USER_INFO_1003  sUserInfo3;
    NET_API_STATUS  netErr;


    UNREFERENCED_PARAMETER( pszOldPwd );

    sUserInfo3.usri1003_password = pszNewPwd;
    netErr = NetUserSetInfo( 
                        NULL,
                        pszAccName,
                        1003,
                        (BYTE *) &sUserInfo3,
                        0 
                    );

    return netErr;
}
   
///////////////////////////////////////////////////////////////////////////////
DWORD
RetrieveKeyFromLSA(
    IN PWCHAR pwszKeyName,
    OUT PBYTE * ppbKey,
    OUT DWORD * pcbKey 
    )
/*++

Routine Description:

    Retrieve private data previously stored with StoreKeyWithLSA().

Parameters:

    pwszKeyName : Name of the key.
    ppbKey : Pointer to PBYTE to receive binary data.
    pcbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    ERROR_FILE_NOT_FOUND
    LSA return code

Note:

    Memory is allocated using LocalAlloc() 

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) || ( NULL == ppbKey ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_GET_PRIVATE_INFORMATION, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaRetrievePrivateData(
                            PolicyHandle,
                            &SecretKeyName,
                            &pSecretData
                        );

    LsaClose( PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    if (pSecretData == NULL)
    {
        return E_UNEXPECTED;
    }

    if(pSecretData->Length)
    {
        *ppbKey = ( LPBYTE )LocalAlloc( LPTR, pSecretData->Length );

        if( *ppbKey )
        {
            *pcbKey = pSecretData->Length;
            CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
            Status = ERROR_SUCCESS;
        } 
        else 
        {
            Status = GetLastError();
        }
    }
    else
    {
        Status = ERROR_FILE_NOT_FOUND;
        *pcbKey = 0;
        *ppbKey = NULL;
    }

    ZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
StoreKeyWithLSA(
    IN PWCHAR  pwszKeyName,
    IN BYTE *  pbKey,
    IN DWORD   cbKey 
    )
/*++

Routine Description:

    Save private data to LSA.

Parameters:

    pwszKeyName : Name of the key this data going to be stored under.
    pbKey : Binary data to be saved.
    cbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    LSA return code

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;
    
    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_CREATE_SECRET, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}


///////////////////////////////////////////////////////////////////////////////
DWORD
OpenPolicy(
    IN LPWSTR ServerName,
    IN DWORD  DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle 
    )
/*++

Routine Description:

    Create/return a LSA policy handle.

Parameters:
    
    ServerName : Name of server, refer to LsaOpenPolicy().
    DesiredAccess : Desired access level, refer to LsaOpenPolicy().
    PolicyHandle : Return PLSA_HANDLE.

Returns:

    ERROR_SUCCESS or  LSA error code

--*/
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaOpenPolicy(
                    Server,
                    &ObjectAttributes,
                    DesiredAccess,
                    PolicyHandle ) );
}


///////////////////////////////////////////////////////////////////////////////
void
InitLsaString(
    IN OUT PLSA_UNICODE_STRING LsaString,
    IN LPWSTR String 
    )
/*++

Routine Description:

    Initialize LSA unicode string.

Parameters:

    LsaString : Pointer to LSA_UNICODE_STRING to be initialized.
    String : String to initialize LsaString.

Returns:

    None.

Note:

    Refer to LSA_UNICODE_STRING

--*/
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}

//-----------------------------------------------------
BOOL 
ValidatePassword(
    IN LPWSTR pszUserName,
    IN LPWSTR pszDomain,
    IN LPWSTR pszPassword
    )
/*++

Routine Description:

    Validate user account password.

Parameters:

    pszUserName : Name of user account.
    pszDomain : Domain name.
    pszPassword : Password to be verified.

Returns:

    TRUE or FALSE.


Note:

    To debug this code, you will need to run process as service in order
    for it to verify password.  Refer to MSDN on LogonUser
    
--*/
{
    HANDLE hToken;
    BOOL bSuccess;


    //
    // To debug this code, you will need to run process as service in order
    // for it to verify password.  Refer to MSDN on LogonUser
    //

    bSuccess = LogonUser( 
                        pszUserName, 
                        pszDomain, //_TEXT("."), //pszDomain, 
                        pszPassword, 
                        LOGON32_LOGON_NETWORK_CLEARTEXT, 
                        LOGON32_PROVIDER_DEFAULT, 
                        &hToken
                    );

    if( TRUE == bSuccess )
    {
        CloseHandle( hToken );
    }
    else
    {
        DWORD dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("ValidatePassword() failed with %d\n"),
                dwStatus
            );

        SetLastError(dwStatus);
    }

    return bSuccess;
}

//---------------------------------------------------------------

BOOL 
GetTextualSid(
    IN PSID pSid,            // binary Sid
    IN OUT LPTSTR TextualSid,    // buffer for Textual representation of Sid
    IN OUT LPDWORD lpdwBufferLen // required/provided TextualSid buffersize
    )
/*++

Routine Description:

    Conver a SID to string representation, code from MSDN

Parameters:

    pSid : Pointer to SID to be converted to string.
    TextualSid : On input, pointer to buffer to received converted string, on output,
                 converted SID in string form.
    lpdwBufferLen : On input, size of the buffer, on output, length of converted string
                    or required buffer size in char.

Returns:

    TRUE/FALSE, use GetLastError() to retrieve detail error code.

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Validate the binary SID.

    if(!IsValidSid(pSid)) 
    {
        return FALSE;
    }

    // Get the identifier authority value from the SID.

    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.

    if (*lpdwBufferLen < dwSidSize)
    {
        *lpdwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Add 'S' prefix and revision number to the string.

    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // Add SID identifier authority to the string.

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    return TRUE;
}

#endif

long
GetUserTSLogonIdEx( 
    HANDLE hToken 
    )
/*++

--*/
{
    BOOL  Result;
    LONG SessionId = -1;
    ULONG ReturnLength;

#ifndef __WIN9XBUILD__
    //
    // Use the _HYDRA_ extension to GetTokenInformation to
    // return the SessionId from the token.
    //

    Result = GetTokenInformation(
                         hToken,
                         TokenSessionId,
                         &SessionId,
                         sizeof(SessionId),
                         &ReturnLength
                     );

    if( !Result ) {

        DWORD dwStatus = GetLastError();
        SessionId = -1; 

    }

#endif

    return SessionId;
}

   

long
GetUserTSLogonId()
/*++

Routine Description:

    Return client TS Session ID.

Parameters:

    None.

Returns:

    Client's TS session ID or 0 if not on TS.

Note:

    Must have impersonate user first.

--*/
{
    LONG lSessionId = -1;

#ifndef __WIN9XBUILD__
    HANDLE hToken;
    BOOL bSuccess;

    bSuccess = OpenThreadToken(
                        GetCurrentThread(),
                        TOKEN_QUERY, //TOKEN_ALL_ACCESS,
                        FALSE,
                        &hToken
                    );

    if( TRUE == bSuccess )
    {
        lSessionId = GetUserTSLogonIdEx(hToken);   
        CloseHandle(hToken);
    }

#else

    lSessionId = 0;

#endif

    return lSessionId;
}

//
//
////////////////////////////////////////////////////////////////
//
//

DWORD
RegEnumSubKeys(
    IN HKEY hKey,
    IN LPCTSTR pszSubKey,
    IN RegEnumKeyCallback pFunc,
    IN HANDLE userData
    )
/*++


--*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    LONG dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;

    if( NULL == hKey )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    dwStatus = RegOpenKeyEx(
                            hKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            (DWORD *)&dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)LocalAlloc(
                                    LPTR,
                                    dwMaxValueNameLen * sizeof(TCHAR)
                                );
    if(pszValueName == NULL)
    {
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.
        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)LocalAlloc(
                                            LPTR,
                                            dwMaxSubKeyLength * sizeof(TCHAR)
                                        );
        if(pszSubKeyName == NULL)
        {
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

        for(;dwStatus == ERROR_SUCCESS && dwNumSubKeys >= 0;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)--dwNumSubKeys,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = pFunc( 
                                hSubKey, 
                                pszSubKeyName, 
                                userData 
                            );
            }
        }

        if( ERROR_NO_MORE_ITEMS == dwStatus )
        {
            dwStatus = ERROR_SUCCESS;
        }
    }

cleanup:
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    if(pszValueName != NULL)
    {
        LocalFree(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        LocalFree(pszSubKeyName);
    }

    return dwStatus;   
}    


DWORD
RegDelKey(
    IN HKEY hRegKey,
    IN LPCTSTR pszSubKey
    )
/*++

Abstract:

    Recursively delete entire registry key.

Parameter:

    hKey : Handle to a curently open key.
    pszSubKey : Pointer to NULL terminated string containing the key to be deleted.

Returns:

    Error code from RegOpenKeyEx(), RegQueryInfoKey(), 
        RegEnumKeyEx().

++*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    DWORD dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;

    if( NULL == hRegKey )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    dwStatus = RegOpenKeyEx(
                            hRegKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)LocalAlloc(
                                    LPTR,
                                    dwMaxValueNameLen * sizeof(TCHAR)
                                );
    if(pszValueName == NULL)
    {
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.

        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)LocalAlloc(
                                            LPTR,
                                            dwMaxSubKeyLength * sizeof(TCHAR)
                                        );
        if(pszSubKeyName == NULL)
        {
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }


        //for(index = 0; index < dwNumSubKeys; index++)
        for(;dwStatus == ERROR_SUCCESS;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)0,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = RegDelKey( hSubKey, pszSubKeyName );
            }

            // ignore any error and continue on
        }
    }

cleanup:

    for(dwStatus = ERROR_SUCCESS; pszValueName != NULL && dwStatus == ERROR_SUCCESS;)
    {
        dwValueNameLength = dwMaxValueNameLen;
        memset(pszValueName, 0, dwMaxValueNameLen * sizeof(TCHAR));

        dwStatus = RegEnumValue(
                            hSubKey,
                            0,
                            pszValueName,
                            &dwValueNameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            RegDeleteValue(hSubKey, pszValueName);
        }
    }   
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    // try to delete this key, will fail if any of the subkey
    // failed to delete in loop
    dwStatus = RegDeleteKey(
                            hRegKey,
                            pszSubKey
                        );



    if(pszValueName != NULL)
    {
        LocalFree(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        LocalFree(pszSubKeyName);
    }

    return dwStatus;   
}    

//---------------------------------------------------------------
DWORD
GetUserSid(
    OUT PBYTE* ppbSid,
    OUT DWORD* pcbSid
    )
/*++

Routine Description:

    Retrieve user's SID , must impersonate client first.

Parameters:

    ppbSid : Pointer to PBYTE to receive user's SID.
    pcbSid : Pointer to DWORD to receive size of SID.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Must have call ImpersonateClient(), funtion is NT specific,
    Win9X will return internal error.

--*/
{
#ifndef __WIN9XBUILD__

    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    HANDLE hToken = NULL;
    DWORD dwSize = 0;
    TOKEN_USER* pToken = NULL;

    *ppbSid = NULL;
    *pcbSid = 0;

    //
    // Open current process token
    //
    bSuccess = OpenThreadToken(
                            GetCurrentThread(),
                            TOKEN_QUERY, 
                            FALSE,
                            &hToken
                        );

    if( TRUE == bSuccess )
    {
        //
        // get user's token.
        //
        GetTokenInformation(
                        hToken,
                        TokenUser,
                        NULL,
                        0,
                        &dwSize
                    );

        pToken = (TOKEN_USER *)LocalAlloc( LPTR, dwSize );
        if( NULL != pToken )
        {
            bSuccess = GetTokenInformation(
                                        hToken,
                                        TokenUser,
                                        (LPVOID) pToken,
                                        dwSize,
                                        &dwSize
                                    );

            if( TRUE == bSuccess )
            {
                //
                // GetLengthSid() return size of buffer require,
                // must call IsValidSid() first
                //
                bSuccess = IsValidSid( pToken->User.Sid );
                if( TRUE == bSuccess )
                {
                    *pcbSid = GetLengthSid( (PBYTE)pToken->User.Sid );
                    *ppbSid = (PBYTE)LocalAlloc(LPTR, *pcbSid);
                    if( NULL != *ppbSid )
                    {
                        bSuccess = CopySid(
                                            *pcbSid,
                                            *ppbSid,
                                            pToken->User.Sid
                                        );                  
                    }
                    else // fail in LocalAlloc()
                    {
                        bSuccess = FALSE;
                    }
                } // IsValidSid()
            } // GetTokenInformation()
        }
        else // LocalAlloc() fail
        {
            bSuccess = FALSE;
        }
    }

    if( TRUE != bSuccess )
    {
        dwStatus = GetLastError();

        if( NULL != *ppbSid )
        {
            LocalFree(*ppbSid);
            *ppbSid = NULL;
            *pcbSid = 0;
        }
    }

    //
    // Free resources...
    //
    if( NULL != pToken )
    {
        LocalFree(pToken);
    }

    if( NULL != hToken )
    {
        CloseHandle(hToken);
    }

    return dwStatus;

#else

    return E_UNEXPECTED;

#endif
}


//----------------------------------------------------------------
HRESULT
GetUserSidString(
    OUT CComBSTR& bstrSid
    )
/*++

Routine Description:

    Retrieve user's SID in textual form, must impersonate client first.

Parameters:

    bstrSID : Return users' SID in textual form.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Must have call ImpersonateClient().

--*/
{
#ifndef __WIN9XBUILD__

    DWORD dwStatus;
    PBYTE pbSid = NULL;
    DWORD cbSid = 0;
    BOOL bSuccess = TRUE;
    LPTSTR pszTextualSid = NULL;
    DWORD dwTextualSid = 0;

    dwStatus = GetUserSid( &pbSid, &cbSid );
    if( ERROR_SUCCESS == dwStatus )
    {
        bSuccess = GetTextualSid( 
                            pbSid, 
                            NULL, 
                            &dwTextualSid 
                        );

        if( FALSE == bSuccess && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            pszTextualSid = (LPTSTR)LocalAlloc(
                                            LPTR, 
                                            (dwTextualSid + 1) * sizeof(TCHAR)
                                        );

            if( NULL != pszTextualSid )
            {
                bSuccess = GetTextualSid( 
                                        pbSid, 
                                        pszTextualSid, 
                                        &dwTextualSid
                                    );

                if( TRUE == bSuccess )
                {
                    bstrSid = pszTextualSid;
                }
            }
        }

        if( FALSE == bSuccess )
        {
            dwStatus = GetLastError();
        }
    }

    if( NULL != pszTextualSid )
    {
        LocalFree(pszTextualSid);
    }

    if( NULL != pbSid )
    {
        LocalFree(pbSid);
    }

    return HRESULT_FROM_WIN32(dwStatus);

#else

    bstrSid = WIN9X_USER_SID;

    return S_OK;

#endif
}

BOOL
FileExists(
    IN  LPCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    DWORD Error;

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) 
    {
        Error = GetLastError();
    } 
    else 
    {
        FindClose(FindHandle);
        if(FindData) 
        {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

     SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
AdjustPrivilege(
    PWSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege, // (LPWSTR)SE_SECURITY_NAME,
                               &( LuidAndAttributes.Luid ) ) ) {
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        return( FALSE );
    }

    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\imsession.h ===
/*
   IMSession.h
*/

#ifndef __IMSESSION__
#define __IMSESSION__

#include "resource.h"
#include "sessions.h"
#include "mdispid.h"
#include "wincrypt.h"

EXTERN_C const IID DIID_DMsgrSessionEvents;
EXTERN_C const IID DIID_DMsgrSessionManagerEvents;
EXTERN_C const IID LIBID_MsgrSessionManager;

#define C_RA_APPID TEXT("{56b994a7-380f-410b-9985-c809d78c1bdc}")

#define RA_IM_COMPLETE 	        0x1
#define RA_IM_WAITFORCONNECT    0x2
#define RA_IM_CONNECTTOSERVER   0x3
#define RA_IM_APPSHUTDOWN       0x4
#define RA_IM_SENDINVITE        0x5
#define RA_IM_ACCEPTED          0x6
#define RA_IM_DECLINED          0x7
#define RA_IM_NOAPP             0x8
#define RA_IM_TERMINATED        0x9
#define RA_IM_CANCELLED         0xA
#define RA_IM_UNLOCK_WAIT       0xB
#define RA_IM_UNLOCK_FAILED     0xC
#define RA_IM_UNLOCK_SUCCEED    0xD
#define RA_IM_UNLOCK_TIMEOUT    0xE
#define RA_IM_CONNECTTOEXPERT   0xF
#define RA_IM_EXPERT_TICKET_OUT 0x10
#define RA_IM_FAILED            0x11
#define RA_IM_CLOSE_INVITE_UI   0x12

class CIMSession;

#include "sessevnt.h"
#include "sessmgrevnt.h"

#define IDC_IMSession 100

class ATL_NO_VTABLE CIMSession : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIMSession, &CLSID_IMSession>,
	public IDispatchImpl<IIMSession, &IID_IIMSession, &LIBID_RCBDYCTLLib>
{
public:
	CIMSession();

    ~CIMSession();

DECLARE_REGISTRY_RESOURCEID(IDR_IMSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIMSession)
	COM_INTERFACE_ENTRY(IIMSession)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(put_OnSessionStatus)(/*[in]*/ IDispatch * pfn);
    STDMETHOD(HSC_Invite)(IDispatch *pUser);
    STDMETHOD(get_ReceivedUserTicket)(/*[out,retval]*/ BSTR* pNewTicket);
    STDMETHOD(GetLaunchingSession)(LONG lID);
    STDMETHOD(SendOutExpertTicket)(BSTR pbstrData);
    STDMETHOD(ProcessContext)(BSTR pContext);
    STDMETHOD(CloseRA)();
    STDMETHOD(get_User)(IDispatch** ppVal);
    STDMETHOD(Hook)(IMsgrSession*, HWND);
    STDMETHOD(Notify)(int);
    STDMETHOD(ContextDataProperty)(BSTR pName, BSTR* ppValue);
    STDMETHOD(get_IsInviter)(BOOL* pVal);

public:
    IMsgrSessionManager* m_pSessMgr;
    IMsgrSession* m_pSessObj;
    IMsgrLock*    m_pMsgrLockKey;
    IDispatch*    m_pInvitee;
    CSessionMgrEvent* m_pSessionMgrEvent;
    BOOL m_bIsHSC;
    CComPtr<IDispatch> m_pfnSessionStatus;

private:
    CComObject<CSessionEvent>* m_pSessionEvent;
    CComBSTR m_bstrSalemTicket;
    CComBSTR m_bstrContextData;

    BOOL m_bIsInviter;
    HCRYPTPROV m_hCryptProv;
    HCRYPTKEY  m_hPublicKey;
    int m_iState;
    DWORD GetExchangeRegValue();
    BOOL m_bExchangeUser;

public:
    CComBSTR m_bstrExpertTicket;
    HWND m_hWnd;
    BOOL m_bLocked;

public:
    HRESULT InitCSP(BOOL bGenPublicKey=TRUE);
    HRESULT InitSessionEvent(IMsgrSession* pSessObj);
    HRESULT DoSessionStatus(int);
    HRESULT GetKeyExportString(HCRYPTKEY hKey, HCRYPTKEY hExKey, DWORD dwBlobType, BSTR* pBlob, DWORD *pdwCount);
    HRESULT ExtractSalemTicket(BSTR pContext);
    HRESULT BinaryToString(LPBYTE pBinBuf, DWORD dwLen, BSTR* pBlob, DWORD *pdwCount);
    HRESULT StringToBinary(BSTR pBlob, DWORD dwCount, LPBYTE *ppBuf, DWORD* pdwLen);
    HRESULT GenEncryptdNoviceBlob(BSTR pPublicKeyBlob, BSTR pSalemTicket, BSTR* pBlob);
    HRESULT InviterSendSalemTicket(BSTR pContext);
    HRESULT ProcessNotify(BSTR);
    HRESULT OnLockResult(BOOL, LONG);
    HRESULT OnLockChallenge(BSTR, LONG);
    HRESULT Invite(IDispatch*);

};

#endif // __IMSession__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\panic.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Panic.cpp

Abstract:
    Sets up a Key board hook on calling SetPanicHook and removes the KeyBoard hook on calling 
	ClearPanicHook. Calling SetPanicHook creates a new thread which waits for the setting of an
	named event. And on the setting of the named event it Invokes the script function pointer 
	passed to SetPanicHook.

Revision History:
    created     a-josem      1/3/01
	revised		a-josem		 1/4/01  Added comments and function headers.
    
*/

// Panic.cpp : Implementation of CPanic
#include "stdafx.h"
#include "Rcbdyctl.h"
#include "Panic.h"

/////////////////////////////////////////////////////////////////////////////
// CPanic
CHookHnd CPanic::m_Hook;
HANDLE CPanic::m_hPanicThread = NULL;
LPSTREAM g_spStream = NULL;
BOOL g_bHookActive = FALSE;
/*++
Routine Description:
	Destructor, In case the m_hEvent is not set it sets the event and exits. Setting of
	the event makes the Panic watch thread to come out of wait.	

Arguments:
	None

Return Value:
	None
--*/

CPanic::~CPanic()
{
	g_bHookActive = FALSE;
	if (m_hEvent)
	{
		SetEvent(m_hEvent);
	}
}

/*++
Routine Description:
	Called from script to setup a Panic Keyboard Hook. It also Marshalls the IDispatch ptr
	to LPSTREAM to be used by the Panic watch thread. If the Panic watch thread is not created
	this function creates the thread.

Arguments:
	iDisp - Function pointer to the JavaScript function passed from script

Return Value:
	S_OK on success.
--*/
STDMETHODIMP CPanic::SetPanicHook(IDispatch *iDisp)
{
	m_Hook.SetHook();
	if (iDisp)
	{
		if (m_ptrScriptFncPtr != iDisp)
		{
			m_ptrScriptFncPtr = iDisp;
			g_bHookActive = TRUE;
			CoMarshalInterThreadInterfaceInStream(IID_IDispatch,iDisp,&g_spStream);

			if (m_hPanicThread != NULL)
			{
				if (WAIT_TIMEOUT != WaitForSingleObject(m_hPanicThread,0) )
				{
					if (m_hPanicThread != NULL)
					{
						CloseHandle(m_hPanicThread);
						m_hPanicThread = NULL;
					}
					DWORD ThreadId; 
					m_hPanicThread = CreateThread(NULL,0,PanicThread,this,0,&ThreadId);
				}
			}
			else
			{
				DWORD ThreadId; 
				m_hPanicThread = CreateThread(NULL,0,PanicThread,this,0,&ThreadId);
			}
		}
	}
	return S_OK;
}

/*++
Routine Description:
	Clears the PanicHook. And Sets the Event so that the thread comes out of wait and exits 
	gracefully.

Arguments:
	None

Return Value:
	S_OK on success.
--*/
STDMETHODIMP CPanic::ClearPanicHook()
{
	m_Hook.UnHook();
	m_ptrScriptFncPtr = NULL;
	g_bHookActive = FALSE;
	if (m_hEvent)
	{
		SetEvent(m_hEvent);
	}
	return S_OK;
}

/*++
Routine Description:
	The thread function creates an Event and waits for the Event to be set. The event is set
	when the Panic key is pressed. It immediately comes out of the wait state and calls the 
	Javascript function.

Arguments:
	lpParameter - CPanic Object address

Return Value:
	S_OK on success.
--*/
DWORD WINAPI CPanic::PanicThread(LPVOID lpParameter)
{
	CoInitialize(NULL);
	CPanic *ptrThis = (CPanic *)lpParameter;

	if (g_spStream)
	{
		CComPtr<IDispatch> ptrIDisp;
		CoGetInterfaceAndReleaseStream(g_spStream,IID_IDispatch,(void**)&ptrIDisp);
		g_spStream = NULL;

		ptrThis->m_hEvent = CreateEvent(NULL,FALSE,FALSE,_T(EventName));
		HRESULT hr;

		while (g_bHookActive == TRUE)
		{
			DWORD dwWaitResult = WaitForMultipleObjects(1,&(ptrThis->m_hEvent),TRUE,INFINITE);

			switch (dwWaitResult) 
			{
				case WAIT_OBJECT_0: 
					{
						if ((ptrIDisp != NULL) && (g_bHookActive == TRUE))
						{
							DISPPARAMS disp = { NULL, NULL, 0, 0 };
							hr = ptrIDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
						}
						break; 
					}
			}
			ResetEvent(ptrThis->m_hEvent);
		}
		if (ptrThis->m_hEvent)
		{
			CloseHandle(ptrThis->m_hEvent);
			ptrThis->m_hEvent = NULL;
		}
	}

	CoUninitialize();
	return 0;
}

/*++
Routine Description:
	Called when ever a key board event occurs. It handles only WM_KEYUP of Esc Key.

Arguments:
	code 
	wParam
	lParam

Return Value:
	returns what ever CallNextHookEx returns.
--*/
LRESULT CALLBACK KeyboardProc(int code,WPARAM wParam,LPARAM lParam)
{
	if (code == HC_ACTION)
	{
		if ((wParam == 27) & (lParam >> 31))
		{
			HANDLE hEvent = CreateEvent(NULL,FALSE,FALSE,_T(EventName));
			if (hEvent)
			{
				SetEvent(hEvent);
				CloseHandle(hEvent);
			}
		}
	}
	return CallNextHookEx(CPanic::m_Hook.m_hHook,code,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\panic.h ===
// Panic.h : Declaration of the CPanic

#ifndef __PANIC_H_
#define __PANIC_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPanic
#define EventName "{26ED148B-1050-461d-9999-3A5002D0103D}"

LRESULT CALLBACK KeyboardProc(int code,WPARAM wParam,LPARAM lParam);

class CHookHnd
{
public:
	HHOOK m_hHook;

	CHookHnd()
	{
		m_hHook = NULL;
	}

	~CHookHnd()
	{
		if (m_hHook)
			UnhookWindowsHookEx(m_hHook);
	}

	HHOOK SetHook()
	{
		if (!m_hHook)
		{
			m_hHook = SetWindowsHookEx(WH_KEYBOARD,KeyboardProc,_Module.GetModuleInstance(),NULL);
		}
		return m_hHook;
	}

	BOOL UnHook()
	{
		BOOL bRetVal = TRUE;
		if (m_hHook)
		{
			bRetVal = UnhookWindowsHookEx(m_hHook);
			if (bRetVal == TRUE)
				m_hHook = NULL;
		}
		return bRetVal;
	}
};

class ATL_NO_VTABLE CPanic : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPanic, &CLSID_Panic>,
	public IDispatchImpl<IPanic, &IID_IPanic, &LIBID_RCBDYCTLLib>
{
public:
	CPanic()
	{
		m_hEvent = NULL;
	}

	~CPanic();

DECLARE_REGISTRY_RESOURCEID(IDR_PANIC)
DECLARE_NOT_AGGREGATABLE(CPanic)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPanic)
	COM_INTERFACE_ENTRY(IPanic)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	CComPtr<IDispatch> m_ptrScriptFncPtr;
	HANDLE m_hEvent;
	static CHookHnd m_Hook;
	static HANDLE m_hPanicThread;
	static DWORD WINAPI PanicThread(LPVOID lpParameter);

// IPanic
public:
	STDMETHOD(ClearPanicHook)();
	STDMETHOD(SetPanicHook)(/*[in]*/ IDispatch *iDisp);
};

#endif //__PANIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\helper.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    Helper.h

Abstract:

    Funtion prototype.

Author:

    HueiWang    2/17/2000

--*/

#ifndef __HELPER_H__
#define __HELPER_H__
#include <windows.h>

#define MAX_ACCDESCRIPTION_LENGTH       256

#define MAX_HELPACCOUNT_NAME		256

#ifndef __WIN9XBUILD__

#define MAX_HELPACCOUNT_PASSWORD	LM20_PWLEN		// from lmcons.h

#else

// keep same max. password length same as NT
#define MAX_HELPACCOUNT_PASSWORD	14

#endif




typedef HRESULT (WINAPI* RegEnumKeyCallback)(
                                    IN HKEY hKey,
                                    IN LPTSTR pszKeyName,
                                    IN HANDLE userData
                                );



#ifndef __WIN9XBUILD__
#include <ntsecapi.h>
#endif


#ifdef __cplusplus
extern "C"{
#endif

    DWORD
    GenerateRandomString(
        IN DWORD dwSizeRandomSeed,
        IN OUT LPTSTR* pszRandomString
    );

    DWORD
    GenerateRandomBytes(
        IN DWORD dwSize,
        IN OUT LPBYTE pbBuffer
    );

    void
    UnixTimeToFileTime(
        time_t t,
        LPFILETIME pft
    );


    long
    GetUserTSLogonId();

    //
    // create a random password, buffer must 
    // be at least MAX_HELPACCOUNT_PASSWORD+1
    VOID
    CreatePassword(
        TCHAR   *pszPassword
    );


    DWORD
    RegEnumSubKeys(
        IN HKEY hKey,
        IN LPCTSTR pszSubKey,
        IN RegEnumKeyCallback pFunc,
        IN HANDLE userData
    );

    DWORD
    RegDelKey(
        IN HKEY hRegKey,
        IN LPCTSTR pszSubKey
    );

    DWORD
    GetUserSid(
        PBYTE* ppbSid,
        DWORD* pcbSid
    );

    HRESULT
    GetUserSidString(
        OUT CComBSTR& bstrSid
    );


#ifndef __WIN9XBUILD__

    BOOL
    MyMkTime(
        IN SYSTEMTIME* pSysTime,
        OUT FILETIME* pft
    );
    

    // Detemine if TermSrv is enable on local box
    BOOL
    IsTermSrvInstalled();


    // 
    // Check if a user is in a local group
    //
    DWORD
    IsUserInLocalGroup(
        IN PBYTE pbUserSid,
        IN LPCTSTR pszLocalGroup,
        OUT BOOL* pbInGroup
    );

    //
    // Create a local account
    //
    DWORD
    CreateLocalAccount(
        IN LPWSTR pszUserName,
        IN LPWSTR pszUserPwd,
        IN LPWSTR pszUserFullName,
        IN LPWSTR pszUserDesc,
        IN LPWSTR pszGroupName,
        IN LPWSTR pszScript,
        OUT BOOL* pbAccountExists
    );

    //
    // Check if a user account is enabled.
    //
    DWORD
    IsLocalAccountEnabled(
        IN LPWSTR pszUserName,
        IN BOOL* pEnabled
    );

    //
    // Enable/disable a user account
    //
    DWORD
    EnableLocalAccount(
        IN LPWSTR pszUserName,
        IN BOOL bEnable
    );

    //
    // Change local account password
    //
    DWORD
    ChangeLocalAccountPassword(
        IN LPWSTR pszUserName,
        IN LPWSTR pszOldPwd,
        IN LPWSTR pszNewPwd
    );
    
    //
    // Check if a specific group exist
    // on local machine.
    //
    BOOL
    IsLocalGroupExists(
        IN LPWSTR pszGroupName
    );

    //
    // Create a local group
    //
    DWORD
    CreateLocalGroup(
        IN LPWSTR pszGroupName,
        IN LPWSTR pszGroupDesc,
        IN BOOL bAddEveryone
    );

    //
    // Validate a user password
    //
    BOOL 
    ValidatePassword(
        IN LPWSTR UserName,
        IN LPWSTR Domain,
        IN LPWSTR Password
    );

    //
    // Retrieve private data saved to LSA
    //
    DWORD
    RetrieveKeyFromLSA(
	    PWCHAR pwszKeyName,
	    PBYTE * ppbKey,
        DWORD * pcbKey 
    );

    //
    // Save private data to LSA
    //
    DWORD
    StoreKeyWithLSA(
	    PWCHAR  pwszKeyName,
        BYTE *  pbKey,
        DWORD   cbKey 
    );
    
    //
    // Open LSA policy
    //
    DWORD
    OpenPolicy( 
	    LPWSTR ServerName,
	    DWORD  DesiredAccess,
	    PLSA_HANDLE PolicyHandle 
    );

    //
    // Initialize LSA string
    //
    void
    InitLsaString(  
	    PLSA_UNICODE_STRING LsaString,
        LPWSTR String 
    );



#ifdef DBG

    void
    DebugPrintf(
        IN LPCTSTR format, ...
    );

#else

    #define DebugPrintf

#endif //PRIVATE_DEBUG  


    //
    // Convert a user SID to string form
    //
    BOOL 
    GetTextualSid(
        IN PSID pSid,
        IN OUT LPTSTR TextualSid,
        IN OUT LPDWORD lpdwBufferLen
    );

    DWORD 
    IsUserAdmin(
        BOOL* bMember
    );


    BOOL
    LookupAliasFromRid(
        LPWSTR pTargetComputer,
        DWORD Rid,
        LPWSTR pName,
        PDWORD cchName
    );

#else

    #define DebugPrintf

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\imsession.cpp ===
#include "stdafx.h"
#include "rcbdyctl.h"
#include "IMSession.h"
#include "wincrypt.h"
#include "auth.h"
#include "assert.h"
#include "wininet.h"
#include "msgrua.h"
#include "msgrua_i.c"

#include "utils.h"
#include "lock_i.c"
#include "sessions.h"
#include "sessions_i.c"
#include "helpservicetypelib.h"
#include "helpservicetypelib_i.c"
#include "safrcfiledlg.h"
#include "safrcfiledlg_i.c"

/////////////////////////////////////////////////////////////////////////
// CIMSession
// Global help functions declaration.
HWND InitInstance(HINSTANCE hInstance, int nCmdShow);
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
DWORD WINAPI HSCInviteThread(LPVOID lpParam);
HRESULT UnlockSession(CIMSession* pThis);
VOID CALLBACK ConnectToExpertCallback(HWND hwnd,UINT uMsg,UINT_PTR idEvent,DWORD dwTime);


UINT_PTR g_timerID;
CIMSession * g_pThis;


// Window class name
TCHAR szWindowClass[] = TEXT("Microsoft Remote Assistance Messenger UNLOCK window");

extern HINSTANCE g_hInstance;

#define VIESDESKTOP_PERMISSION_NOT_REQUIRE 0x4
#define SESSION_EXPIRY 305
#define RA_TIMER_UNLOCK_ID 0x1
#define RA_TIMEOUT_UNLOCK 180 * 1000 // 3 minutes.
#define RA_TIMEOUT_USER   1800 * 1000 // 30 minutes

HANDLE  g_hLockEvent = NULL;
BOOL    g_bActionCancel = FALSE;
HWND    g_hWnd = NULL;
LPSTREAM g_spInvitee = NULL;
LPSTREAM g_spStatus = NULL;
CIMSession::CIMSession()
{
    m_pSessObj = NULL;
    m_pSessMgr = NULL;
    m_pMsgrLockKey = NULL;
    m_bIsInviter = TRUE;
    m_hCryptProv = NULL;
    m_hPublicKey = NULL;
    m_pSessionEvent = NULL;
    m_iState = 0;
    m_pfnSessionStatus = NULL;
    m_pSessionMgrEvent = NULL;
    m_bIsHSC = FALSE;
    m_pInvitee = NULL;
    m_bLocked = TRUE;
    m_bExchangeUser = FALSE;
}

CIMSession::~CIMSession()
{
    if (m_pSessObj)
    {
        if (m_pSessionEvent)
            m_pSessionEvent->DispEventUnadvise(m_pSessObj);

        m_pSessObj->Release();
    }

    if (m_pSessionMgrEvent)
        m_pSessionMgrEvent->Release();

    if (m_pSessionEvent)
        m_pSessionEvent->Release();

    if (m_pMsgrLockKey)
        m_pMsgrLockKey->Release();

    if (m_pSessMgr)
        m_pSessMgr->Release();

    if (m_hPublicKey)
        CryptDestroyKey(m_hPublicKey);

    if (m_hCryptProv)
        CryptReleaseContext(m_hCryptProv, 0);

}

STDMETHODIMP CIMSession::put_OnSessionStatus(IDispatch* pfn)
{
    m_pfnSessionStatus = pfn;
    return S_OK;
}

STDMETHODIMP CIMSession::get_ReceivedUserTicket(BSTR* pSalemTicket)
{
    *pSalemTicket = m_bstrSalemTicket.Copy();
    return S_OK;
}

STDMETHODIMP CIMSession::Hook(IMsgrSession*, HWND hWnd)
{
    HRESULT hr = S_OK;

    m_hWnd = hWnd;

    return hr;
}

STDMETHODIMP CIMSession::ContextDataProperty(BSTR pName, BSTR* ppValue)
{
    HRESULT hr = S_OK;
    CComPtr<IRASetting> cpSetting;

    if (*ppValue != NULL)
    {
        SysFreeString(*ppValue);
        *ppValue = NULL;
    }

    if (m_bstrContextData.Length() == 0)
        goto done;

    if (pName == NULL || *pName == L'\0')
    {
        *ppValue = m_bstrContextData.Copy();
        goto done;
    }

    hr = cpSetting.CoCreateInstance( CLSID_RASetting, NULL, CLSCTX_INPROC_SERVER);
    if (FAILED_HR(_T("ISetting->CoCreateInstance failed: %s"), hr))
        goto done;
    
    cpSetting->get_GetPropertyInBlob(m_bstrContextData, pName, ppValue);

done:
    return hr;
}

STDMETHODIMP CIMSession::get_User(IDispatch** ppUser)
{
    HRESULT hr = S_OK;
    if (m_pSessObj)
    {
        hr = m_pSessObj->get_User(ppUser);
        if (FAILED_HR(_T("get_User failed %s"), hr))
            goto done;
    }
    else
    {
        DEBUG_MSG(_T("No Session found"));
        *ppUser = NULL;
    }

done:
    return S_OK;
}

STDMETHODIMP CIMSession::get_IsInviter(BOOL* pVal)
{
    *pVal = m_bIsInviter;
    return S_OK;
}

STDMETHODIMP CIMSession::CloseRA()
{
    HRESULT hr = S_OK;

    if(m_bIsInviter && m_hWnd) // for inviter, this is the last function to call.
        SendMessage(m_hWnd, WM_CLOSE, NULL, NULL);

    return hr;
}

HRESULT CIMSession::GenEncryptdNoviceBlob(BSTR pPublicKeyBlob, BSTR pSalemTicket, BSTR* pBlob)
{
    TraceSpew(_T("Funct: GenEncryptedNoviceBlob"));

    HRESULT hr;

    if (!pPublicKeyBlob)
        return FALSE;

    DWORD   	dwLen, dwBlobLen, dwSessionKeyCount, dwSalemCount;
    LPBYTE 	    pBuf            =NULL;
    HCRYPTKEY   hSessKey        =NULL;
    HCRYPTKEY   hPublicKey      =NULL;
    BSTR        pSessionKeyBlob =NULL;
    BSTR        pSalemBlob      =NULL;
    TCHAR       szHeader[20];
    CComBSTR    bstrBlob;

    if (FAILED(hr = InitCSP(FALSE)))
        goto done;
    
    // Import public key
    if (FAILED(hr = StringToBinary(pPublicKeyBlob, wcslen(pPublicKeyBlob), &pBuf, &dwLen)))
        goto done;

    if (!CryptImportKey(m_hCryptProv,
                        pBuf,      
                        (UINT)dwLen,
                        0, 
                        0,
                        &hPublicKey))   
    {
        DEBUG_MSG(_T("Can't import public key"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // Gen session key.
    if (!CryptGenKey(m_hCryptProv, CALG_RC2, CRYPT_EXPORTABLE, &hSessKey))
    {
        DEBUG_MSG(_T("Create Session key failed"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if (FAILED(hr=GetKeyExportString(hSessKey, hPublicKey, SIMPLEBLOB, &pSessionKeyBlob, &dwSessionKeyCount)))
        goto done;

    // Encrypt SalemTicket
    dwBlobLen = dwLen = wcslen(pSalemTicket) * sizeof(OLECHAR);
    if (!CryptEncrypt(hSessKey, NULL, TRUE, 0, NULL, &dwBlobLen, dwLen))
    {
        DEBUG_MSG(_T("Can't calculate salem ticket buffer length."));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if (pBuf)
        free(pBuf);

    if((pBuf = (LPBYTE)malloc(dwBlobLen)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
   
    ZeroMemory(pBuf, dwBlobLen);
    memcpy(pBuf, (LPBYTE)pSalemTicket, dwLen);
    if (!CryptEncrypt(hSessKey, NULL, TRUE, 0, pBuf, &dwLen, dwBlobLen))
    {
        DEBUG_MSG(_T("Can't calculate user ticket length"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // Need to generate salem ticket blob
    if (FAILED(hr=BinaryToString(pBuf, dwBlobLen, &pSalemBlob, &dwSalemCount)))
        goto done;

    // Generate final Blob
    wsprintf(szHeader, _T("%d;S="), dwSessionKeyCount + 2);
    bstrBlob = szHeader;
    bstrBlob.AppendBSTR(pSessionKeyBlob);
    wsprintf(szHeader, _T("%d;U="), dwSalemCount + 2);
    bstrBlob.Append(szHeader);
    bstrBlob.AppendBSTR(pSalemBlob);
    if (!InternetGetConnectedState(&dwLen, 0))
    {
        DEBUG_MSG(_T("No Internet connection"));
    }
    else
    {
        if (dwLen & INTERNET_CONNECTION_MODEM) // connected through Modem
        {
            bstrBlob.Append("3;L=1");
        }
    }
    *pBlob = bstrBlob.Detach();

done:
    if (pBuf)
        free(pBuf);

    if (pSessionKeyBlob)
        SysFreeString(pSessionKeyBlob);

    if (pSalemBlob)
        SysFreeString(pSalemBlob);

    if (hPublicKey)
        CryptDestroyKey(hPublicKey);

    if (hSessKey)
        CryptDestroyKey(hSessKey);

    return hr;
}

HRESULT CIMSession::InviterSendSalemTicket(BSTR pContext)
{
    TraceSpew(_T("Funct: InviterSendSalemTicket"));

    HRESULT hr;
    CComPtr<IRASetting> cpSetting;
    ISAFRemoteDesktopSession *pRCS = NULL;
    BSTR pPublicKeyBlob = NULL;
    CComBSTR bstrExpertTicket;
    CComBSTR bstrSalemTicket;
    CComBSTR bstrBlob, bstrExpertName, bstrUserBlob;
    CComPtr<IClassFactory> fact;
    CComQIPtr<IPCHUtility> disp;
    CComPtr<IDispatch> cpDisp;
    CComPtr<IMessengerContact> cpExpert;
    TCHAR szHeader[100];

    hr = cpSetting.CoCreateInstance( CLSID_RASetting, NULL, CLSCTX_INPROC_SERVER);
    if (FAILED_HR(_T("ISetting->CoCreateInstance failed: %s"), hr))
        goto done;
    
    // bstrExpertBlob has 2 part: Expert ticket and expert public key. Names: "ET" and "PK"
    cpSetting->get_GetPropertyInBlob(pContext, CComBSTR("ET"), &m_bstrExpertTicket);
    if (m_bstrExpertTicket.Length() == 0)
    {
        DEBUG_MSG(_T("No expert ticket"));
        goto done;
    }
    cpSetting->get_GetPropertyInBlob(pContext, CComBSTR("PK"), &pPublicKeyBlob);

    // Generate SALEM Ticket.
    hr =::CoGetClassObject(CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact );
    if (FAILED_HR(_T("CoGetClassObject failed: %s"), hr))
        goto done;
    
    // Get Expert name and put it into userblob
    hr = m_pSessObj->get_User(&cpDisp);
    if (FAILED_HR(_T("get_User failed %s"), hr))
        goto done;

    hr = cpDisp->QueryInterface(IID_IMessengerContact, (LPVOID*)&cpExpert);
    if (FAILED_HR(_T("QI IMsgrUser failed: %s"), hr))
        goto done;

    hr = cpExpert->get_FriendlyName(&bstrExpertName);
    if (FAILED_HR(_T("get_FriendlyName failed %s"), hr))
        goto done;

    wsprintf(szHeader, _T("%d;EXP_NAME="), bstrExpertName.Length() + 9);
    bstrUserBlob = szHeader;
    bstrUserBlob.AppendBSTR(bstrExpertName);
    bstrUserBlob.Append("4;IM=1");
    disp = fact; //... it would run QI automatically.
    hr = disp->CreateObject_RemoteDesktopSession(
                                     (REMOTE_DESKTOP_SHARING_CLASS)VIESDESKTOP_PERMISSION_NOT_REQUIRE, 
                                     SESSION_EXPIRY, // expired in 5 minutes. 
                                     CComBSTR(""),
                                     bstrUserBlob, 
                                     &pRCS );
    if (FAILED_HR(_T("CreateRemoteDesktopSession failed %s"), hr))
        goto done;

    hr = pRCS->get_ConnectParms(&bstrSalemTicket);
    if (FAILED_HR(_T("GetConnectParms failed: %s"), hr))
        goto done;

    // Encrypt ticket with the key and send it back.
    if (pPublicKeyBlob)
    {
        if (FAILED(hr = GenEncryptdNoviceBlob(pPublicKeyBlob, bstrSalemTicket, &bstrBlob)))
            goto done;
    }
    else
    {
        TCHAR sbuf[20];
        wsprintf(sbuf, _T("%d;U="), wcslen(bstrSalemTicket) + 2);
        bstrBlob = sbuf;
        bstrBlob += bstrSalemTicket;
    }
        
    hr = m_pSessObj->SendContextData((BSTR)bstrBlob);
    if (FAILED_HR(TEXT("Send Context data filed: %s"), hr))
        goto done;

done:
    if (pRCS)
        pRCS->Release();

    if (pPublicKeyBlob)
        SysFreeString(pPublicKeyBlob);

    return hr;
}

#define IM_STATE_GET_TICKET 1
#define IM_STATE_COMPLETE   2

STDMETHODIMP CIMSession::ProcessContext(BSTR pContext)
{
    TraceSpewW(L"Funct: ProcessContext %s", (pContext==NULL?L"NULL":pContext));

    HRESULT hr = S_OK;    

    hr = ProcessNotify(pContext); // Is it a notification?
    if (SUCCEEDED(hr))
    {
        goto done;
    }

    m_iState++;
    m_bstrContextData = pContext;
    if (m_bIsInviter)
    {
        switch(m_iState)
        {
        case IM_STATE_GET_TICKET: // Received Expert ticket
            if (!m_bIsHSC)
            {
                DWORD   dwValue = 0x0;
                BOOL    bEnableAsyncCall = FALSE;

                dwValue = GetExchangeRegValue();
                if (( 0x3 & dwValue ) == 0x3)
                {
                    bEnableAsyncCall = TRUE;
                }

                hr = InviterSendSalemTicket(pContext);
                if (FAILED(hr))
                {
                    // Need to notify expert side.
                    Notify(RA_IM_FAILED);
                    // Also let the local session know the status.
                    DoSessionStatus(RA_IM_FAILED);

                    CloseRA(); // close inviter side rcimlby.exe.

                }
                else
                { 
                    // It is impossible for bEnabledAsync == TRUE and m_bExchangeUser == FALSE
                    // This is taken care of when we read the reg key in GetExchangeRegValue().
                    if ((bEnableAsyncCall) && (m_bExchangeUser)) 
                    {
                        // Set a timer to callback and then we call ConnectToExpert.
                        g_pThis = this;
                        g_timerID = SetTimer (NULL, NULL, 1000, (TIMERPROC)ConnectToExpertCallback);

                        if (!g_timerID)
                        {
                            // SetTimer failed! This means that we have to bail out of the IM request
                            // since the call to ConnectToExpert will never happen.
                            // Need to notify expert side.
                            Notify(RA_IM_FAILED);
                            // Also let the local session know the status.
                            DoSessionStatus(RA_IM_FAILED);
                        
                            CloseRA(); // close inviter side rcimlby.exe.

                        }
                    }
                    else 
                    {
                        CComPtr<IClassFactory> fact;
                        CComQIPtr<IPCHUtility> disp;
                        LONG lError;
                        
                        TraceSpew(_T("Connect to Expert"));
                        hr =::CoGetClassObject(CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact );
                        if (!FAILED_HR(_T("CoGetClass CLSID_PCHService failed: %s"), hr))
                        {
                            disp = fact; //... it would run QI automatically.
                            hr = disp->ConnectToExpert(m_bstrExpertTicket, 10, &lError);
                            if (!FAILED_HR(_T("ConnectToExpert failed: %s"), hr))
                                DoSessionStatus(RA_IM_CONNECTTOEXPERT);
                        }

                        CloseRA(); // close inviter side rcimlby.exe
                    }
                }


            }
            else // Inviter HelpCtr status update.
            {
                DoSessionStatus(RA_IM_WAITFORCONNECT);
            }
            break;
#if 0 // Connection complete: currently not used.
        case IM_STATE_COMPLETE: 
            // If host is rcimlby.exe, close it.
            if (m_hWnd)
            {
                DestroyWindow(m_hWnd);
            }
            else
            {
                DoSessionStatus(RA_IM_COMPLETE);
            }
            break;
#endif 
        default:
            // Noise?
            break;
        }
    }
    else // Expert side.
    {
        switch(m_iState)
        {
        case IM_STATE_GET_TICKET: // Get Novice salem ticket
            // Extract this ticket to member variable and signal the call back to let host start to connect.
            hr = ExtractSalemTicket(pContext);
            if (FAILED(hr))
            {
                // need to notify Novice that connection failed.
                Notify(RA_IM_FAILED);
                DoSessionStatus(RA_IM_FAILED);
            }
            else
            {
                DoSessionStatus(RA_IM_CONNECTTOSERVER);
            }
            break;
        default:
            // Noise?
            break;
        }
    }

done:
    return hr;
}

VOID CALLBACK ConnectToExpertCallback(
  HWND hwnd,         
  UINT uMsg,         
  UINT_PTR idEvent,  
  DWORD dwTime       
)
{
    // Kill the Timer
    KillTimer(NULL, g_timerID);

    HRESULT hr = S_OK;
    CComPtr<IClassFactory> fact;
    CComQIPtr<IPCHUtility> disp;
    LONG lError;
    
    TraceSpew(_T("Connect to Expert"));
    hr =::CoGetClassObject(CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact );
    if (!FAILED_HR(_T("CoGetClass CLSID_PCHService failed: %s"), hr))
    {
        disp = fact; //... it would run QI automatically.
        hr = disp->ConnectToExpert(g_pThis->m_bstrExpertTicket, 10, &lError);
        if (!FAILED_HR(_T("ConnectToExpert failed: %s"), hr))
            g_pThis->DoSessionStatus(RA_IM_CONNECTTOEXPERT);
    }

    g_pThis->CloseRA(); // close inviter side rcimlby.exe.
}

///////////////////////////////////////////////////////////////////////////////////////////
// We can't notify the other party too much time. The context data can be set only 5 times.
HRESULT CIMSession::ProcessNotify(BSTR pContext)
{
    TraceSpewW(L"Funct: ProcessNotify %s", (pContext?pContext:L"NULL"));

    HRESULT hr = S_OK;
    CComPtr<IRASetting> cpSetting;
    CComBSTR bstrData;
    int lStatus;

    hr = cpSetting.CoCreateInstance( CLSID_RASetting, NULL, CLSCTX_INPROC_SERVER);
    if (FAILED_HR(_T("ISetting->CoCreateInstance failed: %s"), hr))
        goto done;
    
    cpSetting->get_GetPropertyInBlob(pContext, CComBSTR("NOTIFY"), &bstrData);
    if (bstrData.Length() == 0)
    {
        hr = E_FAIL; // Not a notification.
        goto done;
    }

    lStatus = _wtoi((BSTR)bstrData);
    switch (lStatus)
    {
    case RA_IM_COMPLETE:
        DoSessionStatus(RA_IM_COMPLETE);
        break;
    case RA_IM_TERMINATED:
        DoSessionStatus(RA_IM_TERMINATED);
        break;
    case RA_IM_FAILED:
        DoSessionStatus(RA_IM_FAILED);
        break;
    default: // ignore the others.
        break;
    }

done:
    return hr;
}

HRESULT CIMSession::DoSessionStatus(int iState)
{
    // Used for trace purpose.
    static TCHAR *szMsg[] = { _T("Unknown session status"),
                       _T("RA_IM_COMPLETE"),        //   0x1
                       _T("RA_IM_WAITFORCONNECT"),  //   0x2
                       _T("RA_IM_CONNECTTOSERVER"), //   0x3
                       _T("RA_IM_APPSHUTDOWN"),     //   0x4
                       _T("RA_IM_SENDINVITE"),      //   0x5
                       _T("RA_IM_ACCEPTED"),        //   0x6
                       _T("RA_IM_DECLINED"),        //   0x7
                       _T("RA_IM_NOAPP"),           //   0x8
                       _T("RA_IM_TERMINATED"),      //   0x9
                       _T("RA_IM_CANCELLED"),       //   0xA
                       _T("RA_IM_UNLOCK_WAIT"),     //   0xB
                       _T("RA_IM_UNLOCK_FAILED"),   //   0xC
                       _T("RA_IM_UNLOCK_SUCCEED"),  //   0xD
                       _T("RA_IM_UNLOCK_TIMEOUT"),  //   0xE
                       _T("RA_IM_CONNECTTOEXPERT"), //   0xF
                       _T("RA_IM_EXPERT_TICKET_OUT")//   0x10
    };

    TCHAR *pMsg = NULL;
    if (iState > 0 && iState <= (sizeof(szMsg) / sizeof(TCHAR*)))
        pMsg = szMsg[iState];
    else
        pMsg = szMsg[0];

    TraceSpew(_T("DoSessionStatus: %s"), pMsg);

    if (m_pfnSessionStatus)
    {
        DISPPARAMS disp;
        VARIANTARG varg[1];

        disp.rgvarg = varg;
        disp.rgdispidNamedArgs = NULL;
        disp.cArgs = 1;
        disp.cNamedArgs = 0;

        varg[0].vt = VT_I4;
        varg[0].lVal = iState;

        if (m_pfnSessionStatus)
            m_pfnSessionStatus->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
    }

    if ((iState == RA_IM_TERMINATED || iState == RA_IM_FAILED) && m_bIsInviter && !m_bIsHSC)
    {
        // need to close inviter RA lobby
        CloseRA();
    }

    return S_OK;
}

HRESULT CIMSession::InitSessionEvent(IMsgrSession* pSessObj)
{
    HRESULT hr = S_OK;

    if (!m_pSessionEvent)
    {
        hr = CComObject<CSessionEvent>::CreateInstance(&m_pSessionEvent);
        if (FAILED_HR(_T("CreateInstance SessionEvent failed: %s"), hr))
            goto done;
        m_pSessionEvent->AddRef();
    }

    m_pSessionEvent->Init(this, pSessObj);
done:
    return hr;
}

HRESULT CIMSession::InitCSP(BOOL bGenPublicKey /* = TRUE */)
{
    TraceSpew(_T("Funct: InitCSP"));

    HRESULT hr = S_OK;
    TCHAR szUser[] = _T("RemoteAssistanceIMIntegration");

    if (!m_hCryptProv)
    {
        // 1. If it doesn't exist then create a new one.
        if (!CryptAcquireContext(&m_hCryptProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            DEBUG_MSG(_T("Create CSP failed"));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }
    }

    // Get public key
    if(bGenPublicKey &&
       !m_hPublicKey && 
       !CryptGetUserKey(m_hCryptProv, AT_KEYEXCHANGE, &m_hPublicKey)) 
    {
        // Check to see if one needs to be created.
        if(GetLastError() == NTE_NO_KEY) 
        { 
            // Create an key exchange key pair.
            if(!CryptGenKey(m_hCryptProv,AT_KEYEXCHANGE,0,&m_hPublicKey)) 
            {
                DEBUG_MSG(_T("Error occurred attempting to create an exchange key."));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }
        }
        else
        {
            DEBUG_MSG(_T("Error occurred when access Public key"));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }
    }

done:
    return hr;
}

HRESULT CIMSession::ExtractSalemTicket(BSTR pContext)
{
    TraceSpewW(L"Funct: ExtraceSalemTicket %s", pContext?pContext:L"NULL");

    HRESULT hr = S_OK;

    // This ContextData could contains S (sessionkey) and U (user=ticket) name pairs.
    CComBSTR bstrU, bstrS;
    CComPtr<ISetting> cpSetting;
    DWORD dwLen;
    HCRYPTKEY hSessKey = NULL;
    LPBYTE pBuf = NULL;
    BSTR pBlob = NULL;

    hr = cpSetting.CoCreateInstance(CLSID_Setting, NULL, CLSCTX_INPROC_SERVER);
    if (FAILED_HR(_T("ISetting->CoCreateInstance failed: %s"), hr))
        goto done;

    cpSetting->get_GetPropertyInBlob(pContext, CComBSTR("U"), &bstrU);
    cpSetting->get_GetPropertyInBlob(pContext, CComBSTR("S"), &bstrS);
    dwLen = bstrS.Length();
    if (dwLen > 0)
    {
        // need to decrypt user ticket
        TraceSpewW(L"Decrypt user ticket using Expert's public key...");

        if (!m_hCryptProv || !m_hPublicKey)
        {
            DEBUG_MSG(_T("Can't find Cryptographic handler"));
            hr = FALSE;
            goto done;
        }

        if (FAILED(hr = StringToBinary((BSTR)bstrS, dwLen, &pBuf, &dwLen)))
            goto done;

        if (!CryptImportKey(m_hCryptProv, pBuf, dwLen, m_hPublicKey, 0, &hSessKey))
        {
            DEBUG_MSG(_T("Can't import Session Key"));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        free(pBuf); 
        pBuf=NULL;
        if (FAILED(hr = StringToBinary((BSTR)bstrU, bstrU.Length(), &pBuf, &dwLen)))
            goto done;
        
        if (!CryptDecrypt(hSessKey, 0, TRUE, 0, pBuf, &dwLen))
        {
            DEBUG_MSG(_T("Can't decrypt salem ticket"));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        pBlob = SysAllocStringByteLen((char*)pBuf, dwLen);
        m_bstrSalemTicket.Attach(pBlob);
    }
    else
    {
        TraceSpew(_T("No expert's public key, use plain text to send salem ticket."));
        m_bstrSalemTicket = bstrU;
    }

done:
    if (pBuf)
        free(pBuf);

    if (hSessKey)
        CryptDestroyKey(hSessKey);
        
    return hr;
}

DWORD CIMSession::GetExchangeRegValue()
{
    CRegKey     cKey;
    LONG        lRet = 0x0;
    DWORD       dwValue = 0x0;

    lRet = cKey.Open(HKEY_LOCAL_MACHINE, 
                     TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                     KEY_READ );
    if (lRet == ERROR_SUCCESS)
    {
        lRet = cKey.QueryValue(dwValue,TEXT("UseExchangeIM"));
        if (lRet == ERROR_SUCCESS)
        {
            // Success
        }
    }

    return dwValue;
}

////////////////////////////////////////////////////////////////////
// This is used for recipient to get his session object.

STDMETHODIMP CIMSession::GetLaunchingSession(LONG lID)
{
    HRESULT hr;
    IDispatch *pDisp = NULL;
    LONG lFlags;
    LONG lRet;
    CComPtr<IDispatch>          cpDispUser;
    CComPtr<IMessengerContact>  cpMessContact;
    CComBSTR                    bstrServiceId;       
    CComBSTR                    bstrNetGUID;
    CRegKey                     cKey;
    DWORD                       dwValue = 0x0;

    BOOL                        bEnableExchangeIM = FALSE;

    if (!m_pSessMgr)
    {
        hr = CoCreateInstance (CLSID_MsgrSessionManager,
                               NULL,
                               CLSCTX_LOCAL_SERVER,
                               IID_IMsgrSessionManager,
                               (LPVOID*)&m_pSessMgr);
        if (FAILED_HR(_T("CoCreate IMsgrSessionManager failed: %s"), hr))
            goto done;
    }

    hr = UnlockSession(this);
    if (FAILED(hr))
        goto done;

    hr = m_pSessMgr->GetLaunchingSession(lID, (IDispatch**)&pDisp);
    if (FAILED_HR(TEXT("GetLaunchingSession failed: %s"), hr))
        goto done;

    hr = pDisp->QueryInterface(IID_IMsgrSession, (LPVOID*)&m_pSessObj);
    if (FAILED_HR(_T("QI IID_IMsgrSession failed: %s"), hr))
        goto done;

/****************************************************************************
  This check should be done only if the RegKey 
        HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\UseExchangeIM 
  has the 0 bit set.
*****************************************************************************/
    
    dwValue = GetExchangeRegValue();
    if ( 1 & dwValue )
    {
        bEnableExchangeIM = TRUE;
    }
        
// **************************************************************************
    
    // Grab the user
    hr = m_pSessObj->get_User((IDispatch**)&cpDispUser);
    if (FAILED_HR(_T("get_User failed: %s"), hr))
        goto done;

    // QI for the IMessengerContact
    hr = cpDispUser->QueryInterface(IID_IMessengerContact, (void **)&cpMessContact);
    if (FAILED_HR(_T("QI failed getting IID_IMessengerContact hr=%s"),hr))
        goto done;

    // Grab the Service ID from the Messenger Contact
    hr = cpMessContact->get_ServiceId(&bstrServiceId);
    if (FAILED_HR(_T("get_ServiceId failed! hr=%s"),hr))
        goto done;
    
    // If the service ID is {9b017612-c9f1-11d2-8d9f-0000f875c541}, then set the 
    // flag to unlock the API.
    // bstrNetGUID = L"{9b017612-c9f1-11d2-8d9f-0000f875c541}"; // Messenger GUID
    bstrNetGUID = L"{83D4679E-B6D7-11D2-BF36-00C04FB90A03}";
    if (bstrNetGUID == bstrServiceId)
    {
        m_bExchangeUser = TRUE;

        // Exchange User - put up a dialog and fail if we need to!
        if (!bEnableExchangeIM)
        {
            // Load the strings into buffers 
            // from the resource (IDS_MAPI_E_NOT_SUPPORTED , IDS_APPNAME)
            CComBSTR buffString;
            CComBSTR buffAppName;

            buffString.LoadString(_Module.GetResourceInstance(),
                       IDS_NOEXCHANGE);

            buffAppName.LoadString(_Module.GetResourceInstance(),
                       IDS_APPNAME);

            ::MessageBox(NULL,
                         buffString,
                         buffAppName,
                         MB_OK | MB_ICONEXCLAMATION);

            // FAIL
            hr = E_FAIL;
            goto done;
        }
    } 
    // Else continue...

// ***************************************************************************

    // Hook up everything
    if (FAILED(hr = InitSessionEvent(m_pSessObj)))
        goto done;

    hr = m_pSessObj->get_Flags(&lFlags);
    if (FAILED_HR(TEXT("Session Get flags failed: %s"), hr))
        goto done;

    if (lFlags & SF_INVITEE) // Inviter. Only happened when Messenger UI sends this invitation.
    {
        m_bIsInviter = FALSE;
    }

done:
    if (pDisp)
        pDisp->Release();

    return hr;
}
HRESULT CIMSession::OnLockChallenge(BSTR pChallenge , LONG lCookie)
{
    // Send response.
    //
    // id =  assist@msnmsgr.com
    // key = L2P3B7C6V9J4T8D5
    //
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComBSTR bstrID = "assist@msnmsgr.com";
    CComBSTR bstrResponse;
    LPSTR pszKey = "L2P3B7C6V9J4T8D5";
    PSTR pszParam1 = NULL;
    LPSTR pszResponse = NULL;
    
    pszResponse = CAuthentication::GetAuthentication()->GetMD5Result(W2A(pChallenge), pszKey);
    bstrResponse = pszResponse;

    hr = m_pMsgrLockKey->SendResponse(bstrID, bstrResponse, lCookie);
    if (FAILED_HR(_T("SendResponse failed %s"), hr))
        goto done;
done:
    if (pszResponse)
        delete pszResponse;

    return hr;
}

#define WM_APP_LOCKNOTIFY WM_APP + 0x1
#define WM_APP_LOCKNOTIFY_OK WM_APP + 0x2
#define WM_APP_LOCKNOTIFY_FAIL WM_APP + 0x3
#define WM_APP_LOCKNOTIFY_INTHREAD WM_APP + 0x4

HRESULT CIMSession::OnLockResult(BOOL fSucceed, LONG lCookie)
{
    // Notify UnlockSession that we've get response..
    assert(g_hWnd);

    SendNotifyMessage(g_hWnd, WM_APP_LOCKNOTIFY, (WPARAM)fSucceed, NULL);

    DoSessionStatus(fSucceed ? RA_IM_UNLOCK_SUCCEED : RA_IM_UNLOCK_FAILED);
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// This method will be used only from inside HSC
STDMETHODIMP CIMSession::HSC_Invite(IDispatch* pUser)
{
    // Create a Invitation thread and return.
    // Need a lock for user to click cancel.
    HRESULT hr = S_OK;

    assert(g_hLockEvent == NULL); // If it's not NULL, there is a bug.
    g_hLockEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!g_hLockEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    CoMarshalInterThreadInterfaceInStream(IID_IDispatch,pUser,&g_spInvitee);
    if (this->m_pfnSessionStatus)
    {
        CoMarshalInterThreadInterfaceInStream(IID_IDispatch, this->m_pfnSessionStatus, &g_spStatus);
        this->m_pfnSessionStatus = NULL;
    }

    if (!CreateThread(NULL, 0, HSCInviteThread, this, 0, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

done:

    if (FAILED(hr) && g_hLockEvent != NULL)
    {
        CloseHandle(g_hLockEvent);
        g_hLockEvent = NULL;
    }
        
    return hr;
}

DWORD WINAPI HSCInviteThread(LPVOID lpParam)
{
    CComObject<CIMSession> *pThis = NULL;
    HRESULT hr;
    CComBSTR bstrAPPID(C_RA_APPID);
    CComPtr<IDispatch> cpDisp;
    LockStatus ls=LOCK_NOTINITIALIZED;

    hr = CComObject<CIMSession>::CreateInstance(&pThis);
    if (FAILED(hr))
    {
        goto done;
    }

    assert(!pThis->m_pSessObj);
    assert(!pThis->m_pSessionEvent);

    if (g_spStatus) // Rebuild StatusCallback
    {
        CoGetInterfaceAndReleaseStream(g_spStatus,IID_IDispatch,(void**)&pThis->m_pfnSessionStatus);
        g_spStatus = NULL;
    }   

    // 1. Create SessionManager
    if (!pThis->m_pSessMgr)
    {
        hr = UnlockSession(pThis);
        if (FAILED(hr))
            goto done;
    }

    // Check Lock status
    hr = pThis->m_pMsgrLockKey->get_Status(&ls);
    if (ls != LOCK_UNLOCKED)
        pThis->DoSessionStatus(RA_IM_UNLOCK_SUCCEED);
    else
        pThis->DoSessionStatus(RA_IM_UNLOCK_FAILED);

    if (ls != LOCK_UNLOCKED)
    {
        pThis->DoSessionStatus(RA_IM_UNLOCK_FAILED);
        goto done;
    }

    // 3. create session object
    hr = pThis->m_pSessMgr->CreateSession((IDispatch**)&cpDisp);
    if (FAILED(hr))
        goto done;

    hr = cpDisp->QueryInterface(IID_IMsgrSession, (void **)&pThis->m_pSessObj);
    if (FAILED(hr))
        goto done;

    // Hook up enent sink
    if (FAILED(hr = pThis->InitSessionEvent(pThis->m_pSessObj)))
        goto done;

    // 4. Set session option
    hr = pThis->m_pSessObj->put_Application((BSTR)bstrAPPID);
    if (FAILED_HR(_T("put_Application failed: %s"), hr))
        goto done;

    // OK. I'm from HelpCtr.
    pThis->m_bIsHSC = TRUE;

    // Invite 
    if (!cpDisp)
        cpDisp.Release();

    CoGetInterfaceAndReleaseStream(g_spInvitee,IID_IDispatch,(void**)&cpDisp);
    g_spInvitee = NULL;
    
    if (g_bActionCancel) // It's cancelled already.
        goto done;

    if(FAILED(hr = pThis->Invite(cpDisp)))
       goto done;

    // This loop is only used if user wants to cancel this invitation.
    while (1)
    {
        // User has 10 minutes to click cancel.
        // If regular connection doesn't happen in 10 minutes, it timeout too.
        DWORD dwWaitState = WaitForSingleObject(g_hLockEvent, RA_TIMEOUT_USER);
        if (dwWaitState == WAIT_OBJECT_0 && g_bActionCancel == TRUE) // at this moment, we don't have anyother action.
        {
            hr = pThis->m_pSessObj->Cancel(MSGR_E_CANCEL, NULL);
        }
        break; // For now, we always get out of the loop.
    }

done:
    if (g_hLockEvent)
    {
        CloseHandle(g_hLockEvent);
        g_hLockEvent = NULL;
    }
    
    if (pThis)
        pThis->Release();

    g_bActionCancel = FALSE; //reset this global variable.
    return hr;
}

////////////////////////////////////////////////////////////////
// This function only used from inside HSC
HRESULT CIMSession::Invite(IDispatch* pUser)
{
    HRESULT hr = S_OK;

    if (m_pSessObj == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    // Send invitation without ticket. Ticket will be sent from ContextData.
    hr = m_pSessObj->Invite(pUser, NULL);
    if (FAILED_HR(TEXT("Invite failed %s"), hr))
        goto done;

    DoSessionStatus(RA_IM_SENDINVITE);

done:
    return hr;
}

STDMETHODIMP CIMSession::Notify(int iIMStatus)
{
    HRESULT hr = S_OK;
    TCHAR szHeader[1024];
    CComBSTR bstrData;

    if (iIMStatus == RA_IM_CANCELLED || iIMStatus == RA_IM_CLOSE_INVITE_UI) // Doesn't need to use ContextData to notify this msg
    {
        assert(m_bIsHSC == TRUE); // Only helpctr scenario would do this.
        if (g_hLockEvent)         // if it's NULL, that means this thread has already terminated itself.
        {
            g_bActionCancel = (iIMStatus == RA_IM_CANCELLED); // It's possible that user just want to close the UI.
            SetEvent(g_hLockEvent);
        }
        goto done;
    }

    if (m_pSessObj)
    {
        wsprintf(szHeader, _T("%d;NOTIFY=%d"), GetDigit(iIMStatus) + 7, iIMStatus);
        bstrData = szHeader;

        if (bstrData.Length() > 0)
        {
            hr = m_pSessObj->SendContextData((BSTR)bstrData);
            if (FAILED_HR(_T("Notify: SendContextData failed %s"), hr))
                goto done;
        }
    }

done:
    return S_OK;
}

////////////////////////////////////////////////////////////////
// This function sends expert ticket to user through ContextData
STDMETHODIMP CIMSession::SendOutExpertTicket(BSTR bstrTicket)
{
    TraceSpewW(L"Funct: SendOutExpertTicket %s", bstrTicket?bstrTicket:L"NULL");

    HRESULT hr = S_OK;
    CComBSTR bstrPublicKeyBlob;
    CComBSTR bstrBlob;
    DWORD dwCount=0, dwLen;
    TCHAR szHeader[100];

    if (!m_pSessObj)
        return FALSE;

    // 1. Get public blob.
    if (FAILED(hr = InitCSP()))
        goto done;

    // 2. Create Blob with predefined format.
    if(FAILED(hr = GetKeyExportString(m_hPublicKey, 0, PUBLICKEYBLOB, &bstrPublicKeyBlob, &dwCount)))
        goto done;

    dwLen = wcslen(bstrTicket);
    wsprintf(szHeader, _T("%d;ET="), dwLen+3);
    bstrBlob = szHeader;
    bstrBlob.AppendBSTR(bstrTicket);
    if (dwCount)
    {
        wsprintf(szHeader, _T("%d;PK="), dwCount+3);
        bstrBlob.Append(szHeader);
        bstrBlob += bstrPublicKeyBlob;
    }

    // 3. Send it out.
    hr = m_pSessObj->SendContextData((BSTR)bstrBlob);
    if (FAILED(hr))
        goto done;

    DoSessionStatus(RA_IM_EXPERT_TICKET_OUT);
done:

    return hr;
}

HRESULT CIMSession::GetKeyExportString(HCRYPTKEY hKey, HCRYPTKEY hExKey, DWORD dwBlobType, BSTR* pBlob, DWORD *pdwCount)
{
    HRESULT hr = S_OK;
    DWORD dwKeyLen;
    LPBYTE pBinBuf = NULL;

    if (!pBlob)
        return FALSE;

    // Calculate how big the destination buffer size we need.
    if (!CryptExportKey(hKey, hExKey, dwBlobType, 0, NULL, &dwKeyLen))
    {
        DEBUG_MSG(_T("Can't calculate public key length"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    pBinBuf = (LPBYTE)malloc(dwKeyLen);
    if (!pBinBuf)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (!CryptExportKey(hKey, hExKey, dwBlobType, 0, pBinBuf, &dwKeyLen))
    {
        DEBUG_MSG(_T("Can't write public key to blob"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if (FAILED(hr=BinaryToString(pBinBuf, dwKeyLen, pBlob, pdwCount)))
        goto done;

done:
    if (pBinBuf) 
        free(pBinBuf);

    return hr;
}

HRESULT CIMSession::BinaryToString(LPBYTE pBinBuf, DWORD dwLen, BSTR* pBlob, DWORD *pdwCount)
{
    HRESULT hr = S_OK;
    TCHAR *pBuf = NULL;
    CComBSTR bstrBlob;

    if (!pBlob)
        return FALSE;

    if (!CryptBinaryToString(pBinBuf, dwLen, CRYPT_STRING_BASE64, NULL, pdwCount))
    {
        DEBUG_MSG(_T("Can't calculate string len for blob converstion"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if (NULL == (pBuf = (TCHAR*)malloc(*pdwCount * sizeof(TCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (!CryptBinaryToString(pBinBuf, dwLen, CRYPT_STRING_BASE64, pBuf, pdwCount))
    {
        DEBUG_MSG(_T("Can't convert key blob to string"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    bstrBlob.Append(pBuf);
    *pBlob = bstrBlob.Detach();
    
done:
    if (pBuf)
        free(pBuf);

    return hr;
}

HRESULT CIMSession::StringToBinary(BSTR pBlob, DWORD dwCount, LPBYTE *ppBuf, DWORD* pdwLen)
{
    HRESULT hr=S_OK;
    DWORD dwSkip, dwFlag;

    if (!CryptStringToBinary(pBlob, dwCount, CRYPT_STRING_BASE64, NULL, pdwLen, &dwSkip, &dwFlag))
    {
        DEBUG_MSG(_T("Can't calculate needed binary buffer length"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    *ppBuf = (LPBYTE)malloc(*pdwLen);
    if (!CryptStringToBinary(pBlob, dwCount, CRYPT_STRING_BASE64, 
                             *ppBuf, pdwLen, &dwSkip, &dwFlag))
    {
        DEBUG_MSG(_T("Can't convert to binary blob"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }
    
done:
    return hr;
}

HRESULT UnlockSession(CIMSession* pThis)
{
    TraceSpew(_T("Funct: UnlockSession"));

    HRESULT     hr = S_OK;
    MSG         msg;
    CComPtr<IConnectionPointContainer> cpCPC;
    CComPtr<IConnectionPoint> cpCP;
    LockStatus ls=LOCK_NOTINITIALIZED;
    BOOL bRet;

    assert(pThis->m_pSessMgr == NULL);
    hr = CoCreateInstance(  CLSID_MsgrSessionManager,
                            NULL,
                            CLSCTX_LOCAL_SERVER,
                            IID_IMsgrSessionManager,
                            (LPVOID*)&pThis->m_pSessMgr);
    if (FAILED_HR(_T("CoCreate CLSID_MsgrSessionManager failed: %s"), hr))
        goto done;

    // 2. Create Lock object
    hr = pThis->m_pSessMgr->QueryInterface(IID_IMsgrLock, (LPVOID*)&pThis->m_pMsgrLockKey);
    if (FAILED_HR(_T("Can't create MsgrLock object: %s"), hr))
        goto done;

    // 2. Hook SessionManager events
    pThis->m_pSessionMgrEvent = new CSessionMgrEvent(pThis);
    if (!pThis->m_pSessionMgrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    pThis->m_pSessionMgrEvent->AddRef();

    hr = pThis->m_pSessMgr->QueryInterface(IID_IConnectionPointContainer, (void**)&cpCPC);
    if (FAILED_HR(_T("QI: IConnectionPointContainer of SessionMgr failed %s"), hr))
        goto done;

    hr = cpCPC->FindConnectionPoint(DIID_DMsgrSessionManagerEvents, &cpCP);
    if (FAILED_HR(_T("FindConnectionPoint DMessengerEvents failed %s"), hr))
        goto done;

    hr = pThis->m_pSessionMgrEvent->Advise(cpCP);
    if (FAILED(hr))
        goto done;
    g_hWnd = InitInstance(g_hInstance, 0);

    // Set up credential with server.
    hr = pThis->m_pMsgrLockKey->get_Status(&ls);
    if (ls == LOCK_UNLOCKED)
    {
        hr = S_OK;
        goto done;
    }

    SetTimer(g_hWnd, RA_TIMER_UNLOCK_ID, RA_TIMEOUT_UNLOCK, NULL); // 3 minutes.
        
    // Send challenge
    pThis->DoSessionStatus(RA_IM_UNLOCK_WAIT);
    hr = pThis->m_pMsgrLockKey->RequestChallenge(70); // Random number: 70
    if (FAILED_HR(_T("RequestChallenge failed: %s"), hr))
        goto done;

    // Wait until permission get granted or timeout.
    while (bRet = GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.message == WM_APP_LOCKNOTIFY_INTHREAD)
        {
            hr = ((BOOL)msg.wParam)?S_OK:E_FAIL;
            break;
        }

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

done:
    if (g_hWnd)
    {
        // kill control window.
        DestroyWindow(g_hWnd);
        g_hWnd = NULL;
    }

    TraceSpew(_T("Leave UnlockSession hr=%s"),GetStringFromError(hr));
    return hr;
}

HWND InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    HWND hWnd;

	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= NULL; 
	wcex.hCursor		= NULL; 
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= NULL; 
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= NULL; 

	RegisterClassEx(&wcex);

    hWnd = CreateWindow(szWindowClass, TEXT("Remote Assistance"), WS_OVERLAPPEDWINDOW,
                        CW_USEDEFAULT, CW_USEDEFAULT, 500, 500, NULL, NULL, hInstance, NULL);

    return hWnd;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message) 
	{
    case WM_CREATE:
        TraceSpew(_T("WndProc: WM_CREATE called"));
        g_hWnd = hWnd;
        break;
        
    case WM_TIMER:
        {
            if (wParam == RA_TIMER_UNLOCK_ID)
            {
                TraceSpew(_T("WndProc: WM_TIMER RA_TIMER_UNLOCK_ID fired"));
                PostMessage(NULL, WM_APP_LOCKNOTIFY_INTHREAD, (WPARAM)FALSE, NULL);
            }
        }
        break;
    case WM_APP_LOCKNOTIFY:
        {
            //PostQuitMessage(0); // Used for single thread 
            TraceSpew(_T("WndProc: WM_APP_LOCKNOTIFY fired"));
            KillTimer(g_hWnd, RA_TIMER_UNLOCK_ID);
            PostMessage(NULL, WM_APP_LOCKNOTIFY_INTHREAD, wParam, lParam);
        }
        break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\rcbdyctl.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    rcbdyctl.cpp

Abstract:
    Implementation of DLL Exports and Registration

Revision History:
    created     steveshi      08/23/00
    
*/

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "rcbdyctl.h"

#include "rcbdyctl_i.c"
#include "smapi.h"
#include "Recipient.h"
#include "Recipients.h"
#include "EnumRecipient.h"
#include "setting.h"
#include "connection.h"
#include "imsession.h"
#include "display.h"

CComModule _Module;
HINSTANCE g_hInstance;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_smapi, Csmapi)
OBJECT_ENTRY(CLSID_Setting, CSetting)
OBJECT_ENTRY(CLSID_Connection, CConnection)
OBJECT_ENTRY(CLSID_Display, CDisplay)
OBJECT_ENTRY(CLSID_IMSession, CIMSession)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_RCBDYCTLLib);
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance; // used for Dialog.
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\recipient.h ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Recipient.h

Abstract:
    Definition of the Recipient class

Revision History:
    created     steveshi      08/23/00
    
*/
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RECIPIENT_H__6A30AB13_B7FA_48AB_964E_E99E11701097__INCLUDED_)
#define AFX_RECIPIENT_H__6A30AB13_B7FA_48AB_964E_E99E11701097__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
/////////////////////////////////////////////////////////////////////////////
// Recipient

class Recipient : 
	public IDispatchImpl<IRecipient, &IID_IRecipient, &LIBID_RCBDYCTLLib>, 
//	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<Recipient,&CLSID_Recipient>
{
	friend class Csmapi;
	friend class Recipients;

public:
	Recipient() { m_pNext = NULL; m_pRecip = NULL;}
	~Recipient();

BEGIN_COM_MAP(Recipient)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRecipient)
//	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(Recipient) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

//DECLARE_REGISTRY_RESOURCEID(IDR_Recipient)
// ISupportsErrorInfo
//	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IRecipient
public:
	STDMETHOD(get_Address)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Address)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);

protected:
	CComBSTR m_bstrName;
	CComBSTR m_bstrAddress;
	Recipient* m_pNext;
	MapiRecipDesc* m_pRecip;
};

#endif // !defined(AFX_RECIPIENT_H__6A30AB13_B7FA_48AB_964E_E99E11701097__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\recipient.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Recipient.cpp

Abstract:
    Recipient object. Used to save current Simple MAPI recipient information.

Revision History:
    created     steveshi      08/23/00
    
*/

#include "stdafx.h"
#include "rcbdyctl.h"
#include "Recipient.h"
#include "smapi.h"

/////////////////////////////////////////////////////////////////////////////
//

Recipient::~Recipient()
{
}
/*
STDMETHODIMP Recipient::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IRecipient,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
*/
STDMETHODIMP Recipient::get_Name(BSTR *pVal)
{
	// TODO: Add your implementation code here
	//GET_BSTR(pVal, m_bstrName);
	*pVal = m_bstrName.Copy();
	return S_OK;
}

STDMETHODIMP Recipient::put_Name(BSTR newVal)
{
	// TODO: Add your implementation code here
	m_bstrName = newVal;
	return S_OK;
}

STDMETHODIMP Recipient::get_Address(BSTR *pVal)
{
	// TODO: Add your implementation code here
	//GET_BSTR(pVal, m_bstrAddress);
	*pVal = m_bstrAddress.Copy();
	return S_OK;
}

STDMETHODIMP Recipient::put_Address(BSTR newVal)
{
	// TODO: Add your implementation code here
	m_bstrAddress = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rcbdyctl.rc
//
#define IDS_PROJNAME                    100
#define IDR_SMAPI                       101
#define IDS_RECIPIENT_DESC              102
#define IDR_Recipient                   103
#define IDS_RECIPIENTS_DESC             104
#define IDR_Recipients                  105
#define IDS_ENUMRECIPIENT_DESC          106
#define IDR_EnumRecipient               107
#define IDR_Setting                     108
#define IDC_IPLIST                      109
#define IDD_IPLISTDLG                   110
#define IDS_IPSELECTION                 111
#define IDR_CONNECTION                  112
#define IDR_DISPLAY                     113
#define IDR_PANIC                       114
#define IDR_IMSESSION                   115


#define IDS_MAPI_E_FAILURE              121
#define IDS_MAPI_E_INSUFFICIENT_MEMORY  122
#define IDS_MAPI_E_LOGIN_FAILURE        123
#define IDS_MAPI_E_TOO_MANY_SESSIONS    124
#define IDS_MAPI_E_USER_ABORT           125
#define IDS_MAPI_E_INVALID_SESSION      130
#define IDS_MAPI_E_INVALID_EDITFIELDS   135
#define IDS_MAPI_E_INVALID_RECIPS       136
#define IDS_MAPI_E_NOT_SUPPORTED        137
#define IDS_MAPI_E_AMBIGUOUS_RECIPIENT  141
#define IDS_MAPI_E_ATTACHMENT_NOT_FOUND 142
#define IDS_MAPI_E_ATTACHMENT_OPEN_FAILURE 143
#define IDS_MAPI_E_BAD_RECIPTYPE        144
#define IDS_MAPI_E_TEXT_TOO_LARGE       145
#define IDS_MAPI_E_TOO_MANY_FILES       146
#define IDS_MAPI_E_TOO_MANY_RECIPIENTS  147
#define IDS_MAPI_E_UNKNOWN_RECIPIENT    148
#define IDS_E_FUNC_NOTFOUND 149

#define IDS_FRIENDLYTYPENAME 150
#define IDS_RASYSMENUTIP	 151	
#define	IDS_APPNAME			 152
#define IDS_NOEXCHANGE                  153

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\sessevnt.cpp ===
#include "stdafx.h"
#include "rcbdyctl.h"
#include "IMSession.h"
#include "utils.h"
/////////////////////////////////////////////////////////////////////////
// CSessionEvent

void __stdcall CSessionEvent::OnContextData(BSTR pBlob)
{
    TraceSpewW(L"Funct OnContextData %s", pBlob?pBlob:L"NULL");
    m_pIMSession->ProcessContext(pBlob);

    return;
}

void __stdcall CSessionEvent::OnAccepted(BSTR bstrAppData)
{
    // OK Recipient accepts it. Wait for his public key.
    m_pIMSession->DoSessionStatus(RA_IM_ACCEPTED);
}

void __stdcall CSessionEvent::OnDeclined(BSTR bstrAppData)
{    
    // Hum, he declined. Do nothing.
    m_pIMSession->DoSessionStatus(RA_IM_DECLINED);
}

void __stdcall CSessionEvent::OnAppNotPresent(BSTR bstrAppName, BSTR bstrAppURL)
{
    // Do nothing.
    m_pIMSession->DoSessionStatus(RA_IM_NOAPP);
}

void __stdcall CSessionEvent::OnTermination(long hr, BSTR bstrAppData)
{
    // Do nothing
    m_pIMSession->DoSessionStatus(RA_IM_TERMINATED);
}

void __stdcall CSessionEvent::OnReadyToLaunch()
{
    // Do nothing
    DEBUG_MSG(TEXT("OnReadyToLaunch"));
}

void __stdcall CSessionEvent::OnCancelled(BSTR bstrAppData)
{
    m_pIMSession->DoSessionStatus(RA_IM_CANCELLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\recipients.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Recipients.cpp

Abstract:
    Recipients object. Used to save current Simple MAPI recipients list.

Revision History:
    created     steveshi      08/23/00
    
*/

#include "stdafx.h"
#include "rcbdyctl.h"
#include "Recipients.h"
#include "EnumRecipient.h"
#include "Recipient.h"

/////////////////////////////////////////////////////////////////////////////
//
/*
STDMETHODIMP Recipients::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IRecipients,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
*/
STDMETHODIMP Recipients::get__NewEnum(LPUNKNOWN *pVal)
{
    HRESULT hr = S_OK;
    
   	CComObject<EnumRecipient>*	pEnum = NULL;
	
	if (hr = CComObject<EnumRecipient>::CreateInstance(&pEnum))
		goto done;

    pEnum->AddRef();
	if (hr = pEnum->Init(this))
		goto done;

    hr = pEnum->QueryInterface(IID_IEnumVARIANT, (LPVOID*)pVal);
    
done:
    if (pEnum)
        pEnum->Release();

    return hr;
}

STDMETHODIMP Recipients::get_Item(LONG vIndex, IRecipient **pVal)
{
    HRESULT hr = S_OK;
    Recipient* pTmp = m_pHead;

	//  Get the Node whose index == lIndex.
	//  Traverse the linked list to hit the lIndexth Node.
	
	while (vIndex >= 1 && pTmp != NULL)
	{
		pTmp = pTmp->m_pNext;
		vIndex--;
	}

    if (pTmp == NULL)
    {
        hr = DISP_E_BADINDEX;
        goto done;
    }
    
    hr = pTmp->QueryInterface(IID_IRecipient, (LPVOID*)pVal);

done:
	return hr;
}

STDMETHODIMP Recipients::get_Count(long *pVal)
{
	int i=0;
	Recipient * pTmp = m_pHead;


    //Traverse the complete linked list till the last Node is encountered.
	while (pTmp != NULL)
	{
		pTmp = pTmp->m_pNext;
		i++;
	}

    *pVal = i;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\sessmgrevnt.cpp ===
/**********************************************************

  (C) 2001 Microsoft Corp.
  
***********************************************************/

#include "stdafx.h"
#include "mdisp.h"
#include "mdispid.h"
#include "rcbdyctl.h"
#include "IMSession.h"
#include "SessMgrEvnt.h"
#include "utils.h"

//****************************************************************************
//
// CSessionMgrEvent::CSessionMgrEvent()
// Constructor
//
//****************************************************************************
CSessionMgrEvent::CSessionMgrEvent(CIMSession *pIMSession)
: m_dwCookie(0), m_iid(/*DIID_DMsgrSessionManagerEvents*/)
{  
    m_pIMSession = pIMSession;

    m_dwRefCount = 0;
    m_pCP = NULL;
}

CSessionMgrEvent::~CSessionMgrEvent()
{
    if (m_pCP)
    {
        if (m_dwCookie)
            m_pCP->Unadvise(m_dwCookie);
        m_pCP->Release();
    }
}

//****************************************************************************
//
// STDMETHODIMP CSessionMgrEvent::QueryInterface( REFIID riid, void **ppv )
//
//
//****************************************************************************
STDMETHODIMP CSessionMgrEvent::QueryInterface( REFIID riid, void **ppv )
{
    // Alway initialize out components to NULL
    *ppv = NULL;
    
    if( (IID_IUnknown == riid) || (m_iid == riid) || (IID_IDispatch == riid) ) 
    {
        *ppv = this;
    }
    
    if( NULL == *ppv )
    {
        return( E_NOINTERFACE );
    }
    else 
    {
        ((IUnknown *)(*ppv))->AddRef();
        return( S_OK );
    }
}

//****************************************************************************
//
// STDMETHODIMP CSessionMgrEvent::GetTypeInfoCount(UINT* pcTypeInfo)
//
// should always return NOERROR
//
//****************************************************************************

STDMETHODIMP CSessionMgrEvent::GetTypeInfoCount(UINT* pcTypeInfo)
{
    *pcTypeInfo = 0 ;
    return NOERROR ;
}

//****************************************************************************
//
// STDMETHODIMP CSessionMgrEvent::GetTypeInfo(
//
// should always return E_NOTIMPL
//
//****************************************************************************

STDMETHODIMP CSessionMgrEvent::GetTypeInfo(UINT iTypeInfo,
                                           LCID,          // This object does not support localization.
                                           ITypeInfo** ppITypeInfo)
{    
    *ppITypeInfo = NULL ;
    
    if(iTypeInfo != 0)
    {       
        return DISP_E_BADINDEX ; 
    }
    else
    {
        return E_NOTIMPL;
    }
}

//****************************************************************************
//
// STDMETHODIMP CSessionMgrEvent::GetIDsOfNames(  
//                                                const IID& iid,
//                                                OLECHAR** arrayNames,
//                                                UINT countNames,
//                                                LCID,          // Localization is not supported.
//                                                DISPID* arrayDispIDs)
//
// should always return E_NOTIMPL
//
//****************************************************************************

STDMETHODIMP CSessionMgrEvent::GetIDsOfNames(const IID& iid,
                                             OLECHAR** arrayNames,
                                             UINT countNames,
                                             LCID,          // Localization is not supported.
                                             DISPID* arrayDispIDs)
{
    HRESULT hr;
    if (iid != IID_NULL)
    {       
        return DISP_E_UNKNOWNINTERFACE ;
    }
    
    hr = E_NOTIMPL;
    
    return hr ;
}

//****************************************************************************
//
// STDMETHODIMP CSessionMgrEvent::Invoke(
//
//
//****************************************************************************

STDMETHODIMP CSessionMgrEvent::Invoke(DISPID dispidMember,
                                      const IID& iid,
                                      LCID,          // Localization is not supported.
                                      WORD wFlags,
                                      DISPPARAMS* pDispParams,
                                      VARIANT* pvarResult,
                                      EXCEPINFO* pExcepInfo,
                                      UINT* pArgErr)
{
    HRESULT        hr=E_FAIL;
    HRESULT     hrRet=E_FAIL;

    _ASSERTE(iid == IID_NULL);
    switch (dispidMember) 
    {
        case DISPID_ONINVITATION:
        case DISPID_ONAPPREGISTERED:
        case DISPID_ONAPPUNREGISTERED:
        case DISPID_ONLOCKCHALLENGE:
            m_pIMSession->OnLockChallenge(V_BSTR(&pDispParams->rgvarg[0]), V_I4(&pDispParams->rgvarg[1]));
            break;
        case DISPID_ONLOCKRESULT:
            m_pIMSession->OnLockResult(V_BOOL(&pDispParams->rgvarg[0]), V_I4(&pDispParams->rgvarg[1]));
            break;
        case DISPID_ONLOCKENABLE:
            //OutMessageBox(_T("Lock is enabled"));
            break;
        case DISPID_ONAPPSHUTDOWN:
            m_pIMSession->DoSessionStatus(RA_IM_APPSHUTDOWN);
            break;

        default:
            OutMessageBox(_T("got unknown Event from COM object: %d\r\n"), dispidMember);
            break;        
    }
    
    return NOERROR;
}

HRESULT CSessionMgrEvent::Advise(IConnectionPoint* pCP)
{
    HRESULT hr = S_OK;

    if (!pCP)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_pCP && m_dwCookie)
    {
        m_pCP->Unadvise(m_dwCookie);
        m_dwCookie = 0;
        m_pCP->Release();
    }

    m_pCP = pCP;
    m_pCP->AddRef();

    hr = m_pCP->Advise((IUnknown*)this, &m_dwCookie);
    if (FAILED_HR(_T("CSessionMgrEvent:Advise failed %s"), hr))
        goto done;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\sessmgrevnt.h ===
//////////////////////////////////////////////////////////////////////
#ifndef __SESSMGREVNT_H__
#define __SESSMGREVNT_H__

//#include <atlbase.h>
//#include "IMSession.h"
class CIMSession;

class CSessionMgrEvent : public IDispatch  
{
public:
	CSessionMgrEvent(CIMSession*);
    ~CSessionMgrEvent();
    // IUnknown methods

public:                             
    STDMETHOD_(ULONG, AddRef) ()            
    {                                       
        InterlockedIncrement((long*)&m_dwRefCount);
        return m_dwRefCount;             
    }                                       
    STDMETHOD_(ULONG, Release) ()           
    {                                       
        if ( InterlockedDecrement((long*)&m_dwRefCount) == 0 )
        {                                   
            delete this;                    
            return 0;                       
        }                                   
        else                                
            return  m_dwRefCount;        
    }                                       ;

    STDMETHOD (QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
    
    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) ; 
    
    STDMETHOD(GetTypeInfo)(
							THIS_ 
							UINT itinfo,
							LCID lcid,
							ITypeInfo FAR* FAR* pptinfo) ;
    
    STDMETHOD(GetIDsOfNames)( 
							THIS_ 
							REFIID riid,
							OLECHAR FAR* FAR* rgszNames,
							UINT cNames,
							LCID lcid, 
							DISPID FAR* rgdispid) ;
    
    STDMETHOD(Invoke)(
						THIS_
						DISPID dispidMember,
						REFIID riid,
						LCID lcid,
						WORD wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						EXCEPINFO FAR* pexcepinfo,
						UINT FAR* puArgErr);

public:
    HRESULT Advise(IConnectionPoint*);
    void OnAppShutDown();

private:
    ULONG m_dwRefCount; 
    CIMSession *m_pIMSession;
    IConnectionPoint* m_pCP;
    DWORD                               m_dwCookie;
    IID                                 m_iid;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\recipients.h ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Recipients.h

Abstract:
    Definition of the Recipients class

Revision History:
    created     steveshi      08/23/00
    
*/
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RECIPIENTS_H__4FFDA87C_5402_4AAA_93B2_7582B352FDF1__INCLUDED_)
#define AFX_RECIPIENTS_H__4FFDA87C_5402_4AAA_93B2_7582B352FDF1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Recipients

class Recipients : 
	public IDispatchImpl<IRecipients, &IID_IRecipients, &LIBID_RCBDYCTLLib>, 
//	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<Recipients,&CLSID_Recipients>
{
public:
	Recipients() {}
BEGIN_COM_MAP(Recipients)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRecipients)
//	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(Recipients) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

//DECLARE_REGISTRY_RESOURCEID(IDR_Recipients)
// ISupportsErrorInfo
//	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IRecipients
public:
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_Item)(LONG vIndex, /*[out, retval]*/ IRecipient* *pVal);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);


protected:
	Recipient* m_pHead;
    Recipient* m_pCurrent;

public:
	HRESULT Init(Recipient* pHead) { m_pHead = pHead; return S_OK; }
};

#endif // !defined(AFX_RECIPIENTS_H__4FFDA87C_5402_4AAA_93B2_7582B352FDF1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\sessevnt.h ===
/*
   SessEvnt.h
*/

#ifndef __SESSEVNT__
#define __SESSEVNT__

#define IDC_SessionEvent 100

// Timer IDs
#define  TIMER_CONNECTTOEXPERT 0x01
#define  TIMER_TIMEOUT            0x02

class ATL_NO_VTABLE CSessionEvent :
    public CComObjectRootEx<CComSingleThreadModel>,
	public IDispEventImpl<IDC_SessionEvent, CSessionEvent, &DIID_DMsgrSessionEvents, &LIBID_MsgrSessionManager, 1, 0>
{
 public:
    CSessionEvent()
    {
        m_pSessObj = NULL; m_pIMSession = NULL;
    }
    ~CSessionEvent()
    {
        if (m_pSessObj) 
        {
            DispEventUnadvise(m_pSessObj);
            m_pSessObj->Release();
        }
    }

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSessionEvent)
END_COM_MAP()

BEGIN_SINK_MAP(CSessionEvent)
	SINK_ENTRY_EX(IDC_SessionEvent, DIID_DMsgrSessionEvents, DISPID_ONAPPNOTPRESENT, OnAppNotPresent)
	SINK_ENTRY_EX(IDC_SessionEvent, DIID_DMsgrSessionEvents, DISPID_ONACCEPTED, OnAccepted)
	SINK_ENTRY_EX(IDC_SessionEvent, DIID_DMsgrSessionEvents, DISPID_ONDECLINED, OnDeclined)
	SINK_ENTRY_EX(IDC_SessionEvent, DIID_DMsgrSessionEvents, DISPID_ONTERMINATION, OnTermination)
	SINK_ENTRY_EX(IDC_SessionEvent, DIID_DMsgrSessionEvents, DISPID_ONREADYTOLAUNCH, OnReadyToLaunch)
	SINK_ENTRY_EX(IDC_SessionEvent, DIID_DMsgrSessionEvents, DISPID_ONCONTEXTDATA, OnContextData)
	SINK_ENTRY_EX(IDC_SessionEvent, DIID_DMsgrSessionEvents, DISPID_ONCANCELLED, OnCancelled)
END_SINK_MAP()

public:
    void Init(CIMSession* pIM, IMsgrSession *pS) 
    {
        if (m_pSessObj)
        {
            DispEventUnadvise(m_pSessObj);
            m_pSessObj->Release();
        }
        m_pIMSession = pIM; 
        m_pSessObj = pS; 
        m_pSessObj->AddRef(); 
        DispEventAdvise(m_pSessObj); 
    };

private:
    IMsgrSession* m_pSessObj;
    CIMSession* m_pIMSession;

    void __stdcall OnAppNotPresent(BSTR bstrAppName, BSTR bstrAppURL);
    void __stdcall OnAccepted(BSTR bstrAppData);
    void __stdcall OnDeclined(BSTR bstrAppData);
    void __stdcall OnTermination(long hr, BSTR bstrAppData);
    void __stdcall OnReadyToLaunch();
    void __stdcall OnContextData(BSTR pBlob);
    void __stdcall OnCancelled(BSTR bstrAppData);
};

#endif // __SESSEVNT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\smapi.h ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    smapi.h

Abstract:
    Definition of the Csmapi class

Revision History:
    created     steveshi      08/23/00
    
*/

#ifndef __SMAPI_H_
#define __SMAPI_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Csmapi
class ATL_NO_VTABLE Csmapi : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<Csmapi, &CLSID_smapi>,
	public ISupportErrorInfo,
    public IDispatchImpl<Ismapi, &IID_Ismapi, &LIBID_RCBDYCTLLib>
{
public:
    Csmapi()
    {
        m_pRecipHead = NULL;
        m_bLogonOK = FALSE;
        m_lhSession = NULL;
        m_hLib = NULL;
        m_lpfnMapiFreeBuf = NULL;
        m_lpfnMapiAddress = NULL;
        m_lOEFlag = 0;
        m_szSmapiName[0] = _T('\0');
        m_szDllPath[0] = _T('\0');
    }

    ~Csmapi();

DECLARE_REGISTRY_RESOURCEID(IDR_SMAPI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(Csmapi)
    COM_INTERFACE_ENTRY(Ismapi)
    COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// Ismapi
public:
    STDMETHOD(get_AttachedXMLFile)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_AttachedXMLFile)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Body)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Body)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Subject)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Subject)(/*[in]*/ BSTR newVal);
    STDMETHOD(ClearRecipList)();
    STDMETHOD(SendMail)(/*[out, retval]*/ LONG* plStatus);
    STDMETHOD(get_Recipients)(/*[out, retval*/ IRecipients* *pVal);
    STDMETHOD(AddRecipient)(BSTR newRecip);
    STDMETHOD(OpenAddressBox)();
    STDMETHOD(Logoff)();
    STDMETHOD(Logon)(ULONG *plRet);
    STDMETHOD(get_SMAPIClientName)(BSTR *pVal);
    STDMETHOD(get_IsSMAPIClient_OE)(LONG *pVal);
    STDMETHOD(get_Reload)(LONG *pVal);

protected:
    ULONG GetRecipCount();
    ULONG BuildMapiRecipDesc(MapiRecipDesc* *ppMapiRecipDesc);
    HRESULT AddRecipientInternal(char*);
    HRESULT AddRecipientInternal(WCHAR*);
	void PopulateAndThrowErrorInfo(ULONG err);
    BOOL IsOEConfig();
    HMODULE LoadOE();

public:
    void MAPIFreeBuffer( MapiRecipDesc* p );

protected:
    BOOL     m_bLogonOK;
    CComBSTR m_bstrSubject;
    CComBSTR m_bstrBody;
    CComBSTR m_bstrXMLFile;
    Recipient* m_pRecipHead;

public:
    // MAPI variables
    HMODULE m_hLib;
    LHANDLE m_lhSession;
    
    // MAPI functions
    LPMAPIFREEBUFFER m_lpfnMapiFreeBuf;
    LPMAPIADDRESS    m_lpfnMapiAddress;

    TCHAR m_szSmapiName[MAX_PATH];
    TCHAR m_szDllPath[MAX_PATH];
    LONG m_lOEFlag;
};

#endif //__SMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\setting.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    setting.cpp

Abstract:
    CSetting object. Used to support Remote Assistance Channel settings.

Revision History:
    created     steveshi      08/23/00
    
*/

#include "stdafx.h"
#include "Rcbdyctl.h"
#include "setting.h"
#include "iphlpapi.h"
#include "userenv.h"
#include "shlobj.h"
#include "stdio.h"
#include "windowsx.h"

#include "helper.h"
#include "utils.h"

const TCHAR cstrRCBDYINI[] = _T("RcBuddy.ini");
const TCHAR cstrRCBDYAPP[] = _T("RcBuddyChannel");
void CreatePassword(TCHAR* pass);

extern HINSTANCE g_hInstance;
INT_PTR APIENTRY IPDlgProc( HWND, UINT, WPARAM, LPARAM);
PIP_ADAPTER_INFO g_pIp;
PIP_ADDR_STRING  g_pIpAddr;

//////////////////////////////////////////////////////////////////////////////
// GetIPAddress
// Return a list of current available IP address. 
// If multiple IP addresses are available, ";" will be used as delimiter.
//////////////////////////////////////////////////////////////////////////////
HRESULT CSetting::get_GetIPAddress(/*[out, retval]*/ BSTR *pVal)
{
	HRESULT hr = S_FALSE; // In case no adapter

	PMIB_IPADDRTABLE pmib=NULL;
	ULONG ulSize = 0;
	DWORD dw;
	PIP_ADAPTER_INFO pAdpInfo = NULL;

	if (!pVal)
	{
		hr = E_INVALIDARG;
		goto done;
	}

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );
	if (dw == ERROR_BUFFER_OVERFLOW)
	{
		pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);
		if (!pAdpInfo)
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}

		dw = GetAdaptersInfo(
			pAdpInfo,
			&ulSize);
		if (dw == ERROR_SUCCESS)
		{
            if (pAdpInfo->Next != NULL ||
                pAdpInfo->IpAddressList.Next != NULL) // We got more than 1 IP Address
            {
                int iCount = 0;
                PIP_ADAPTER_INFO p;
                PIP_ADDR_STRING ps, psMem = NULL;
                CComBSTR t;

                for(p=pAdpInfo; p!=NULL; p=p->Next)
                {
                    for(PIP_ADDR_STRING ps = &(p->IpAddressList); ps; ps=ps->Next)
                    {
                        if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0) // Filter out ZERO address as ipconfig does
                        {
                            if (t.Length() > 0)
                                t.Append(";");
                            t.Append(ps->IpAddress.String);
                        }
                    }
                }
                if (t.Length() > 0)
                    *pVal = t.Copy();
                else
                    goto done;
            }
            else 
            {
                // Only 1 IP address found.
                *pVal = CComBSTR(pAdpInfo->IpAddressList.IpAddress.String).Copy();
            }

            hr = S_OK;
		}

	}

done:
	if (pAdpInfo)
		free(pAdpInfo);

	return hr;
}

/*********************************************************
Func:
    get_GetUserTempFileName

Abstract:
    Return a temp file name under user's profile directory
 *********************************************************/

//HRESULT CSetting::get_GetUserTempFileName(/*[out, retval]*/ BSTR *pVal)
/*
{
	HRESULT hr = S_FALSE; 
    TCHAR sFile[MAX_PATH + 256];

    if(FAILED(InitProfile()))
        goto done;

    // Get Temp file name
    if (!GetTempFileName(m_pProfileDir, _T("RC"), 0, &sFile[0]))
        goto done;

    *pVal = CComBSTR(sFile).Copy();
    hr = S_OK;

done:
	return hr;
}
*/
/*********************************************************
Func:
    GetProfileString

Abstract:
    Get profile string inside the channel's setting file.

Params:
    bstrSec: Section key.
    pVal:    Output string (default is "0", if not found.)
 *********************************************************/
/*
HRESULT CSetting::GetProfileString(BSTR bstrSec, BSTR* pVal)
{
    HRESULT hr = S_FALSE;
    TCHAR sBuf[512];
    DWORD dwSize;
    USES_CONVERSION;

    if (FAILED(InitProfile()))
        goto done;

    dwSize = GetPrivateProfileString(cstrRCBDYAPP, 
                                     W2T(bstrSec), 
                                     TEXT("0"), &sBuf[0], 512, m_pIniFile);

    *pVal = CComBSTR(sBuf).Copy();
    hr = S_OK;

done:
    return hr;
}
*/

/*********************************************************
Func:
    SetProfileString

Abstract:
    Set profile string inside the channel's setting file.

Params:
    bstrSec: Section key.
    bstrVal: New value
 *********************************************************/
/*
HRESULT CSetting::SetProfileString(BSTR bstrSec, BSTR bstrVal)
{
    HRESULT hr = S_FALSE;
    USES_CONVERSION;

    if (FAILED(InitProfile()))
        goto done;

    if (!WritePrivateProfileString(cstrRCBDYAPP, W2T(bstrSec), W2T(bstrVal), m_pIniFile))
        goto done;

    hr = S_OK;

done:
    return hr;
}
*/
//////////////////////////////////////////////////////////////////////////////////////
// Helper functions used to support the above methods or properties
/////////////////////////////


/*********************************************************
Func:
    InitProfile

Abstract:
    Create the setting file.
    A RCIncidents subdir will be created under user's profile dir.
    A RcBuddy.ini file be created as the user's RA channel setting file.

 *********************************************************/
/*
HRESULT CSetting::InitProfile()
{
    HRESULT hr = E_FAIL;

    if (m_pProfileDir && m_pIniFile) // No need to process
        return S_OK;

    if (m_pProfileDir || m_pIniFile) // Only one has value: Error. No need to process either.
        return E_FAIL;

    // Get User profile directory
    HANDLE hProcess = GetCurrentProcess();
    TCHAR* pPath = NULL;
    const TCHAR sSubDir[] = _T("\\Local Settings\\Application Data\\RcIncidents");
    TCHAR sPath[MAX_PATH];
    ULONG ulSize = sizeof(sPath) - sizeof(sSubDir) -1; // preserve space for subdir.
    TCHAR sFile[MAX_PATH + 256];
    HANDLE hToken = NULL;
    int iRet = 0;
    BOOL bNeedFree = FALSE;

    if (!OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_WRITE, &hToken))
        goto done;

    if (!GetUserProfileDirectory(hToken, &sPath[0], &ulSize)) // Buffer not big enough
    {
        if (ulSize == sizeof(sPath)-1) // Not because of insufficent space.
            goto done;

        pPath = (TCHAR*)malloc((ulSize+1+sizeof(sSubDir))*sizeof(TCHAR));
        if (!pPath)
		{
			hr = E_OUTOFMEMORY;
            goto done;
		}

        bNeedFree = TRUE;

        if (!GetUserProfileDirectory(hToken, pPath, &ulSize))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
		}
    }

    if (!pPath)
        pPath = sPath;

    // Create RCIncidents sub dir
    _tcscat(pPath, sSubDir);
    iRet = SHCreateDirectoryEx(NULL, pPath, NULL);
    if (iRet != ERROR_SUCCESS && iRet != ERROR_ALREADY_EXISTS)
        goto done;

    // Set variables
    iRet = (_tcslen(pPath) + 1) * sizeof(TCHAR);
    m_pProfileDir = (TCHAR*)malloc(iRet);
    if (!m_pProfileDir)
	{
		hr = E_OUTOFMEMORY;
        goto done;
	}
    
    memcpy(m_pProfileDir, pPath, iRet);

    m_pIniFile = (TCHAR*)malloc(iRet + (1+sizeof(cstrRCBDYINI))*sizeof(TCHAR));
    if (!m_pIniFile)
	{
		hr = E_OUTOFMEMORY;
        goto done;
	}

    _stprintf(m_pIniFile, _T("%s\\%s"), m_pProfileDir, cstrRCBDYINI);
    
    hr = S_OK;

done:
    if (hToken)
        CloseHandle(hToken);

    if (bNeedFree)
        free(pPath);

    return hr;
}
*/
/*********************************************************
Func:
    get_CreatePassword

Abstract:
    Create a random string as password

Params:
 *********************************************************/
HRESULT CSetting::get_CreatePassword(/*[out, retval]*/ BSTR *pVal)
{
    WCHAR szPass[MAX_HELPACCOUNT_PASSWORD + 1];
    if (!pVal)
        return E_FAIL;

    szPass[0] = L'\0';
    CreatePassword(szPass);
    if (szPass[0] != L'\0')
        *pVal = SysAllocString(szPass);

    return S_OK;
}

/*********************************************************
Func:
    get_GetPropertyInBlob

Abstract:
    Get the specified property value in Blob

Params:
    bstrBlob: Blob for searching. (ex: 8;PASS=ABC )
    bstrName: property name. (ex: "PASS", without '=' char)
 *********************************************************/

HRESULT CSetting::get_GetPropertyInBlob(/*[in]*/ BSTR bstrBlob, /*[in]*/ BSTR bstrName, /*[out, retval]*/ BSTR *pVal)
{
    HRESULT hRet = S_FALSE;
    WCHAR *p1, *p2, *pEnd;
    LONG lTotal =0;
    size_t lProp = 0;
    size_t iNameLen;

    if (!bstrBlob || *bstrBlob==L'\0' || !bstrName || *bstrName ==L'\0'|| !pVal)
        return FALSE;

    iNameLen = wcslen(bstrName);

    pEnd = bstrBlob + wcslen(bstrBlob);
    p1 = p2 = bstrBlob;

    while (1)
    {
        // get porperty length
        while (*p2 != L';' && *p2 != L'\0' && iswdigit(*p2) ) p2++;
        if (*p2 != L';')
            goto done;

        *p2 = L'\0'; // set it to get length
        lProp = _wtol(p1);
        *p2 = L';'; // revert it back.
    
        // get property string
        p1 = ++p2;
    
        while (*p2 != L'=' && *p2 != L'\0' && p2 < p1+lProp) p2++;
        if (*p2 != L'=')
            goto done;

        if ((p2-p1==iNameLen) && (wcsncmp(p1, bstrName, iNameLen)==0) )
        {
            if (lProp == iNameLen+1) // A=B= case (no value)
                goto done;

            WCHAR C = *(p2 + lProp-iNameLen);
            *(p2 + lProp-iNameLen) = L'\0';
            *pVal = SysAllocString(p2+1);
            *(p2 + lProp-iNameLen) = C;
            hRet = S_OK;
            break;
        }

        // check next property
        p2 = p1 = p1 + lProp;
        if (p2 > pEnd)
            break;
    }

done:
    return hRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\setting.h ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    setting.h

Abstract:
    Definition of the CSetting class

Revision History:
    created     steveshi      08/23/00
    
*/

#ifndef __SETTING_H_
#define __SETTING_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSetting
class ATL_NO_VTABLE CSetting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSetting, &CLSID_Setting>,
	public IDispatchImpl<ISetting, &IID_ISetting, &LIBID_RCBDYCTLLib>
{
public:
	CSetting()
	{
        m_pIniFile = NULL;
        m_pProfileDir = NULL;
	}

    ~CSetting()
    {
        if (m_pIniFile) free(m_pIniFile);
        if (m_pProfileDir) free(m_pProfileDir);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_Setting)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetting)
	COM_INTERFACE_ENTRY(ISetting)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Ismapi
public:
	STDMETHOD(get_GetIPAddress)(/*[out, retval]*/ BSTR *pVal);
//	STDMETHOD(get_GetUserTempFileName)(/*[out, retval]*/ BSTR *pVal);
//	STDMETHOD(GetProfileString)(/*[in]*/ BSTR session, /*[out, retval]*/ BSTR *pVal);
//	STDMETHOD(SetProfileString)(/*[in]*/ BSTR session, /*[in]*/ BSTR newVal);
	STDMETHOD(get_CreatePassword)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetPropertyInBlob)(/*[in]*/ BSTR bstrBlob, /*[in]*/ BSTR bstrName, /*[out, retval]*/ BSTR *pVal);

public:

    TCHAR* m_pIniFile;
    TCHAR* m_pProfileDir;
/*
protected:
    HRESULT InitProfile();*/
};

#endif //__SETTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\smapi.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    smapi.cpp

Abstract:
    CSMapi object. Used to support our simple MAPI functions.

Revision History:
    created     steveshi      08/23/00
    
*/

#include "stdafx.h"
#include "Rcbdyctl.h"
#include "smapi.h"
#include "Recipient.h"
#include "Recipients.h"
#include "mapix.h"
#include "utils.h"

#define C_OEAPP    TEXT("Outlook Express")
#define F_ISOE     0x1
#define F_ISCONFIG 0x2

#define LEN_MSOE_DLL    9 // length of "\\msoe.dll"
#define LEN_HMMAPI_DLL 11 // length of "\\hmmapi.dll"

BOOL GetMAPIDefaultProfile(TCHAR*, DWORD*);


#define E_FUNC_NOTFOUND 1000 //Userdefined error no.

#define MACRO_AddRecipientInternal( pName ) \
{   \
    CComObject<Recipient>* pItem = NULL; \
    HRESULT hr = CComObject<Recipient>::CreateInstance(&pItem); \
    if (hr) \
        goto done; \
    pItem->AddRef(); \
    pItem->put_Name(CComBSTR(pName).Copy()); \
    ((Recipient*)pItem)->m_pNext = m_pRecipHead; \
    m_pRecipHead = (Recipient*)pItem; \
done: \
    return hr; \
}

// Csmapi
Csmapi::~Csmapi() 
{
    if (m_bLogonOK)
        Logoff();
    
    if (m_hLib)
        FreeLibrary(m_hLib);
}

STDMETHODIMP Csmapi::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_Ismapi
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

BOOL Csmapi::IsOEConfig()
{
    CRegKey cOE;
    LONG lRet;
    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_PATH];
    DWORD dwCount = MAX_PATH -1 ;

    lRet = cOE.Open(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Account Manager"), KEY_READ);
    if(lRet == ERROR_SUCCESS)
    {
        lRet = cOE.QueryValue(szBuf, TEXT("Default Mail Account"), &dwCount);
        if (lRet == ERROR_SUCCESS)
        {
            TCHAR szActs[MAX_PATH];
            CRegKey cOEAcct;

            wsprintf(szActs, TEXT("Accounts\\%s"), szBuf);
            lRet = cOEAcct.Open((HKEY)cOE, szActs, KEY_READ);
            if (lRet == ERROR_SUCCESS)
            {
                bRet = TRUE;
                cOEAcct.Close();
            }
        }
        cOE.Close();
    }
    return bRet;
}

STDMETHODIMP Csmapi::get_Reload(LONG* pVal)
{
    HRESULT hr = S_OK;
    CComBSTR bstrName, bstrOldName;
    *pVal = 0; // assume failed for some reason;
    
    if(m_bLogonOK)
    {
        Logoff();
    }
    
    if (m_hLib)
    {
        FreeLibrary(m_hLib);
        m_lpfnMapiFreeBuf = NULL;
        m_lpfnMapiAddress = NULL;
        m_hLib = NULL;        
    }

    if (m_szSmapiName[0] != _T('\0'))
        bstrOldName = m_szSmapiName;

    m_lOEFlag = 0;    
    hr = get_SMAPIClientName(&bstrName);
    if (FAILED(hr) || bstrName.Length() == 0)
    {
        *pVal = 0; // failed for some reason
        goto done;
    }

    if (bstrOldName.Length() > 0 && wcscmp(bstrOldName,bstrName) != 0)
    {
        *pVal = 1; // Email client get changed.
    }
    else
    {
        *pVal = -1; // succeed.
    }

done:
    return S_OK;
}

STDMETHODIMP Csmapi::get_SMAPIClientName(BSTR *pVal)
{
    HRESULT hr = S_OK;

    CRegKey cKey;
    LONG lRet;
    DWORD dwCount = sizeof(m_szSmapiName)/sizeof(m_szSmapiName[0]) -1;

    // Get default email client
    if (m_hLib) // Already initialized.
        goto done;

#ifndef _WIN64 // WIN32. We use only OE on Win64.

    lRet = cKey.Open(HKEY_LOCAL_MACHINE, TEXT("Software\\Clients\\Mail"), KEY_READ);
    if (lRet != ERROR_SUCCESS)
        goto done;

    lRet = cKey.QueryValue(m_szSmapiName, NULL, &dwCount); // get default value
    if (lRet == ERROR_SUCCESS)
    {
        // Is the email client Smapi compliant?
        // 1. get it's dllpath
        CRegKey cMail;
        lRet = cMail.Open((HKEY)cKey, m_szSmapiName, KEY_READ);
        if (lRet == ERROR_SUCCESS)
        {
            dwCount = sizeof(m_szDllPath)/sizeof(m_szDllPath[0]) - 1;
            lRet = cMail.QueryValue(m_szDllPath, TEXT("DLLPath"), &dwCount);
            if (lRet == ERROR_SUCCESS)
            {
                LONG len = lstrlen(m_szDllPath);
                if ( !(len > LEN_MSOE_DLL && // no need to check OE  
                      lstrcmpi(&m_szDllPath[len - LEN_MSOE_DLL], TEXT("\\msoe.dll")) == 0) && 
                     !(len > LEN_HMMAPI_DLL && // We don't want HMMAPI either
                        _tcsicmp(&m_szDllPath[len - LEN_HMMAPI_DLL], TEXT("\\hmmapi.dll")) == 0))
                {
                    HMODULE hLib = LoadLibrary(m_szDllPath);
                    if (hLib != NULL)
                    {
                        if (GetProcAddress(hLib, "MAPILogon"))
                        {
                            m_hLib = hLib; // OK, this is the email program that we want.
                        }
                    }
                }
                cMail.Close();
            }
        }
        cKey.Close();
    }
#endif

    if (m_hLib == NULL) // Need to use OE
    {
        m_szSmapiName[0] = TEXT('\0'); // in case OE is not available.
        m_hLib = LoadOE();
    }

done:
    *pVal = (BSTR)CComBSTR(m_szSmapiName).Copy();
    return hr;
}

HMODULE Csmapi::LoadOE()
{
    LONG lRet;
    HKEY hKey, hSubKey;
    DWORD dwIndex = 0;
    TCHAR szName[MAX_PATH];
    TCHAR szBuf[MAX_PATH];
    TCHAR szDll[MAX_PATH];
    DWORD dwName, dwBuf;
    FILETIME ft;
    HMODULE hLib = NULL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        TEXT("Software\\Clients\\Mail"),
                        0, 
                        KEY_ENUMERATE_SUB_KEYS,
                        &hKey);
    
    if (lRet == ERROR_SUCCESS)
    {
        dwName = sizeof(szName) / sizeof(szName[0]);
        while(ERROR_SUCCESS == RegEnumKeyEx(hKey,
                                            dwIndex++,              // subkey index
                                            &szName[0],              // subkey name
                                            &dwName,            // size of subkey buffer
                                            NULL, 
                                            NULL,
                                            NULL,
                                            &ft))
        {
            // get dll path.
            lRet = RegOpenKeyEx(hKey, szName, 0, KEY_QUERY_VALUE, &hSubKey);
            if (lRet == ERROR_SUCCESS)
            {
                dwBuf = sizeof(szBuf);
                lRet = RegQueryValueEx(hSubKey,            // handle to key
                                       TEXT("DllPath"),
                                       NULL, 
                                       NULL, 
                                       (BYTE*)&szBuf[0],     // data buffer
                                       &dwBuf);
                if (lRet == ERROR_SUCCESS)
                {
                    // is it msoe.dll?
                    lRet = lstrlen(szBuf);
                    if (lRet > LEN_MSOE_DLL && 
                        lstrcmpi(&szBuf[lRet - LEN_MSOE_DLL], TEXT("\\msoe.dll")) == 0)
                    { 
                        // Resolve environment variable.
                        lRet = sizeof(m_szDllPath) / sizeof(m_szDllPath[0]);
                        dwBuf = ExpandEnvironmentStrings(szBuf, m_szDllPath, lRet);
                        if (dwBuf > (DWORD)lRet)
                        {
                            // TODO: Need to handle this case
                        }
                        else if (dwBuf == 0)
                        {
                            // TODO: Failed.
                        }
                        else if ((hLib = LoadLibrary(m_szDllPath)))
                        {
                            lstrcpy(m_szSmapiName, szName);
                            m_lOEFlag = F_ISOE | (IsOEConfig() ? F_ISCONFIG : 0);
                        }
                        break;
                    }
                }
                RegCloseKey(hSubKey);
            }
            dwName = sizeof(szName) / sizeof(szName[0]);
        }
        RegCloseKey(hKey);
    }
                            
    return hLib;        
}

STDMETHODIMP Csmapi::get_IsSMAPIClient_OE(LONG *pVal)
{
    HRESULT hr = S_OK;
    CComBSTR bstrTest;
    get_SMAPIClientName(&bstrTest);
    *pVal = m_lOEFlag;
    return hr;
}

/******************************************
Func:
    Logon
Abstract:
    Simple MAPI logon wrapper
Params:
	None
*******************************************/
STDMETHODIMP Csmapi::Logon(ULONG *plReg)
{
    HRESULT hr = E_FAIL;
	*plReg = 0;
    USES_CONVERSION;
    
    ULONG err = 0;
    // Check Win.ini MAPI == 1 ?
    if (m_bLogonOK)
    {
        hr = S_OK;
		*plReg = 0;
        goto done;
    }
    
	// Load MAPI32.DLL
    if (!m_hLib)
    {
        LONG lError;
        get_Reload(&lError);
        if (lError == 0) // failed.
        {
            *plReg = 1;
            goto done;
        }
    }

    if (m_hLib != NULL)
    {
        LPMAPILOGON lpfnMapiLogon = (LPMAPILOGON)GetProcAddress(m_hLib, "MAPILogon");
        if (lpfnMapiLogon == NULL)
            goto done;

        // 1st, is there any existing session that I can use?
        err = lpfnMapiLogon(
                0L,
                NULL,   
                NULL,   
                0 ,         
                0,
                &m_lhSession);
 
        if (err != SUCCESS_SUCCESS)
        {
            // OK. I need a new session.
            // Get default profile from registry
            //
            TCHAR szProfile[256];
            DWORD dwCount = 255;
            szProfile[0]= TEXT('\0');
            ::GetMAPIDefaultProfile((TCHAR*)szProfile, &dwCount);

            err = lpfnMapiLogon(
                0L,
                T2A(szProfile),   
                NULL,   
                MAPI_LOGON_UI ,         
                0,
                &m_lhSession);

            if (err != SUCCESS_SUCCESS)
			{
				PopulateAndThrowErrorInfo(err);
				goto done;			
			}
        }
        
        // err == SUCCESS_SUCCESS
        m_bLogonOK = TRUE;
		*plReg = 1;
        hr = S_OK;
    }

done: 
    return hr;
}

/******************************************
Func:
    Logoff

Abstract:
    Simple MAPI logoff wrapper

Params:

*******************************************/
STDMETHODIMP Csmapi::Logoff()
{
    // Clean up Recipient list
    ClearRecipList();

    if (m_bLogonOK)
    {
        LPMAPILOGOFF lpfnMapiLogOff = (LPMAPILOGOFF)GetProcAddress(m_hLib, "MAPILogoff");
        if (lpfnMapiLogOff)
            lpfnMapiLogOff (m_lhSession, 0, 0, 0);

        m_bLogonOK = FALSE;
    }

    return S_OK;
}

/******************************************
Func:
    OpenAddressBox

Abstract:
    Simple MAPI MAPIAddress wrapper.
    If the internal recepient list is not empty, it needs to generate a MapiRecipDesc and 
    pre-filled the address box.

Params:

*******************************************/
STDMETHODIMP Csmapi::OpenAddressBox()
{
    HRESULT hr = E_FAIL;
	ULONG lRet = 0;
    if (!m_lpfnMapiAddress)
    {
        m_lpfnMapiAddress = (LPMAPIADDRESS)GetProcAddress(m_hLib, "MAPIAddress");
        if (!m_lpfnMapiAddress) // No MAPIAddress?
            return E_FAIL;
    }

    USES_CONVERSION;
    if (m_bLogonOK)
    {
        ULONG lNewRecips = 0;
        MapiRecipDesc *pOldMapiRecipDesc = NULL;
        MapiRecipDesc *pNewRecips = NULL;
        ULONG nRecips = 0;

        // Is the name string not empty?
        // If not, we need to generate a MapiRecipDesc for OpenAddress to display.
        nRecips = GetRecipCount();
        if (nRecips>0)
        {
            pOldMapiRecipDesc = new MapiRecipDesc[nRecips];
            if (pOldMapiRecipDesc == NULL)
                return E_OUTOFMEMORY;

            ZeroMemory(pOldMapiRecipDesc, sizeof(MapiRecipDesc) * nRecips);
            nRecips = 0;

            for (Recipient* p=m_pRecipHead; p; p=p->m_pNext)
            {
                (pOldMapiRecipDesc)[nRecips].lpszName = W2A(p->m_bstrName);
                (pOldMapiRecipDesc)[nRecips].ulRecipClass = MAPI_TO;
                nRecips++;
            }
        }

        lRet = m_lpfnMapiAddress(m_lhSession,                  
                    0,                    
                    NULL,                 
                    1,                  
                    NULL,                  
                    nRecips,                      
                    pOldMapiRecipDesc,           
                    0,
                    0,
                    &lNewRecips,               
                    &pNewRecips);

        if (lRet == SUCCESS_SUCCESS) 
        {
            // clean up old recipients for the new name list.
            ClearRecipList();

            for (int i=0; i< (int)lNewRecips; i++)
            {
                AddRecipientInternal(pNewRecips[i].lpszName);
            }

            // Free the returned buffer, since we don't need it.
            if (pNewRecips)
                MAPIFreeBuffer(pNewRecips);

            hr = S_OK;
        }
		else if (lRet == MAPI_E_USER_ABORT)
		{
			hr = S_FALSE;
		}
		else
		{
			PopulateAndThrowErrorInfo(lRet);
		}
        if (pOldMapiRecipDesc)
            delete pOldMapiRecipDesc;

    }

    return hr;
}

/******************************************
Func:
    AddRecipient

Abstract:
    Add new recipients to the recipient list.

Params:
    newRecip: new recipient names. Seperate by ";".
*******************************************/
STDMETHODIMP Csmapi::AddRecipient(BSTR newRecip)
{
    HRESULT hr = S_OK;
    ULONG iCount;
    WCHAR* pNew;

    // Need to parse strings if users use multi names here.
    if (!newRecip || (iCount = wcslen((WCHAR*)newRecip))==0)
        return S_FALSE;

    pNew = new WCHAR[iCount + 1];
    if (pNew == NULL)
        return E_OUTOFMEMORY;

    wcscpy(pNew, (WCHAR*)newRecip);
    WCHAR *p = pNew;
    WCHAR *p1;
    BOOL bEnd = FALSE;

    // Parse names
    while (1)
    {
        // Remove leading space
        while ((*p == L' ' || *p == L';') && *p != L'\0') 
            p++;
        if (*p == L'\0')
            break;
        p1=p++;

        // Find end point
        while (*p != L';' && *p != L'\0') 
            p++;

        if (*p == L'\0')
            bEnd = TRUE;
        else
            *p = L'\0'; // Create the end point of the current name string
        
        hr = AddRecipientInternal(p1);
        if (hr)
            goto done;

        if (bEnd)
            break;

        p++;
    }

done:
    if (pNew)
        delete pNew;

    return hr;
}

/******************************************
Func:
    ClearRecipList

Abstract:
    Remote the recipient list.

Params:
    
*******************************************/
STDMETHODIMP Csmapi::ClearRecipList()
{
    while (m_pRecipHead)
    {
        Recipient* p = m_pRecipHead->m_pNext;
        if (m_pRecipHead->m_pRecip)
            MAPIFreeBuffer(m_pRecipHead->m_pRecip);

        m_pRecipHead->Release();
        m_pRecipHead = p;
    }

    return S_OK;
}

/******************************************
Func:
    SendMail

Abstract:
    Simple MAPI MAPISendMail wrapper. It always take the attachment file from m_bstrXMLFile member variable.

Params:
    *plStatus: 1(Succeed)/others(Fail)
*******************************************/
STDMETHODIMP Csmapi::SendMail(LONG* plStatus)
{
	HRESULT hr = E_FAIL;
    ULONG err = 0;
    ULONG cRecip = 0;
    MapiRecipDesc *pMapiRecipDesc = NULL;

    USES_CONVERSION;

    *plStatus = 0;
    if (!m_bLogonOK) // Logon problem !
        return S_FALSE;

    LPMAPISENDMAIL lpfnMapiSendMail = (LPMAPISENDMAIL)GetProcAddress(m_hLib, "MAPISendMail");
    if (lpfnMapiSendMail == NULL)
        return E_FAIL;

    // Since we don't resolve name before, we need to resolve name here
    // Even if the name list comes form AddressBook, some name list was not resolved
    // in address book.
    cRecip = BuildMapiRecipDesc(&pMapiRecipDesc);

    if (cRecip <= 0 || pMapiRecipDesc == NULL)
    {
        if (cRecip == -1) // resolve name failed.
            *plStatus = 2;
        return E_FAIL;
    }

    MapiFileDesc attachment = {0,         // ulReserved, must be 0
                               0,         // no flags; this is a data file
                               (ULONG)-1, // position not specified
                               W2A(m_bstrXMLFile),  // pathname
                               NULL, //"RcBuddy.MsRcIncident",  // original filename
                               NULL};               // MapiFileTagExt unused
    // Create a blank message. Most members are set to NULL or 0 because
    // MAPISendMail will let the user set them.
    MapiMessage note = {0,            // reserved, must be 0
                        W2A(m_bstrSubject),
                        W2A(m_bstrBody),
                        NULL,         // NULL = interpersonal message
                        NULL,         // no date; MAPISendMail ignores it
                        NULL,         // no conversation ID
                        0,           // no flags, MAPISendMail ignores it
                        NULL,         // no originator, this is ignored too
                        cRecip,            // # of recipients
                        pMapiRecipDesc,         // recipient array
                        1,            // one attachment
                        &attachment}; // the attachment structure
 
    //Next, the client calls the MAPISendMail function and 
    //stores the return status so it can detect whether the call succeeded. 

    err = lpfnMapiSendMail (m_lhSession,          // use implicit session.
                            0L,          // ulUIParam; 0 is always valid
                            &note,       // the message being sent
                            0,            // Use MapiMessge recipients
                            0L);         // reserved; must be 0
    if (err == SUCCESS_SUCCESS )
    {
        *plStatus = 1;
        hr = S_OK;
    }
	else
	{
		PopulateAndThrowErrorInfo(err);
	}
    // remove array allocated inside BuildMapiRecipDesc with 'new' command
    if (pMapiRecipDesc)
        delete pMapiRecipDesc;

    return hr;
}

/******************************************
Func:
    get_Recipients

Abstract:
    Return the Recipients list object.

Params:
    *ppVal: Recipients object
*******************************************/
STDMETHODIMP Csmapi::get_Recipients(IRecipients **ppVal)
{
    HRESULT hr = S_FALSE;
    CComObject<Recipients> *pRet = NULL;
    if (hr = CComObject<Recipients>::CreateInstance(&pRet))
        goto done;

    pRet->AddRef();
    if (hr = pRet->Init(m_pRecipHead))
        goto done;

    hr = pRet->QueryInterface(IID_IRecipients, (LPVOID*)ppVal);
    
done:
    if (pRet)
        pRet->Release();

    return hr;
}

/******************************************
Func:
    get_Subject

Abstract:
    Return the Subject line information.

Params:
    *pVal: returned string
*******************************************/
STDMETHODIMP Csmapi::get_Subject(BSTR *pVal)
{
    //GET_BSTR(pVal, m_bstrSubject);
	*pVal = m_bstrSubject.Copy();
    return S_OK;
}

/******************************************
Func:
    put_Subject

Abstract:
    Set the Subject line information.

Params:
    newVal: new string
*******************************************/
STDMETHODIMP Csmapi::put_Subject(BSTR newVal)
{
    m_bstrSubject = newVal;
    return S_OK;
}

/******************************************
Func:
    get_Body

Abstract:
    Get the Body message

Params:
    *pVal: body message string
*******************************************/
STDMETHODIMP Csmapi::get_Body(BSTR *pVal)
{
    //GET_BSTR(pVal, m_bstrBody);
	*pVal = m_bstrBody.Copy();
    return S_OK;
}

/******************************************
Func:
    put_Body

Abstract:
    Set the Body message

Params:
    newVal: new body message string
*******************************************/
STDMETHODIMP Csmapi::put_Body(BSTR newVal)
{
    m_bstrBody = newVal;
    return S_OK;
}

/******************************************
Func:
    get_AttachedXMLFile

Abstract:
    get Attachment file info.

Params:
    *pVal: attachment file pathname.
*******************************************/
STDMETHODIMP Csmapi::get_AttachedXMLFile(BSTR *pVal)
{
    //GET_BSTR(pVal, m_bstrXMLFile);
	*pVal = m_bstrXMLFile.Copy();
    return S_OK;
}

/******************************************
Func:
    put_AttachedXMLFile

Abstract:
    set Attachment file info.

Params:
    newVal: attachment file pathname.
*******************************************/
STDMETHODIMP Csmapi::put_AttachedXMLFile(BSTR newVal)
{
    m_bstrXMLFile = newVal;
    return S_OK;
}

/* ----------------------------------------------------------- */
/* Internal Helper functions */
/* ----------------------------------------------------------- */

/******************************************
Func:
    GetRecipCount

Abstract:
    Return the number of recipients

Params:
    
*******************************************/
ULONG Csmapi::GetRecipCount()
{
    ULONG count = 0;
    Recipient* p = m_pRecipHead;
    while (p)
    {
        count ++;
        p = p->m_pNext;
    }
    return count;
}

/******************************************
Func:
    BuildMapiRecipDesc

Abstract:
    Used Simple MAPI MAPIResolveName to resolve the recipient's email alias.
    It would pop up an selection box when a conflict was found.

Params:
    **ppMapiRecipDesc: Return the resolved MAPI recipients array.
*******************************************/
ULONG Csmapi::BuildMapiRecipDesc(MapiRecipDesc** ppMapiRecipDesc)
{
    USES_CONVERSION;

    if (!m_bLogonOK)
        return 0;

    ULONG count = GetRecipCount();
    if (count <= 0)
	{
		PopulateAndThrowErrorInfo(MAPI_E_INVALID_RECIPS);
        return 0;
	}

    *ppMapiRecipDesc = new MapiRecipDesc[count];
    if (*ppMapiRecipDesc == NULL)
	{
		PopulateAndThrowErrorInfo(MAPI_E_INSUFFICIENT_MEMORY);
        return 0;
	}

    ZeroMemory(*ppMapiRecipDesc, sizeof(MapiRecipDesc) * count);

    ULONG err = MAPI_E_FAILURE;
    Recipient* p = m_pRecipHead;
    count = 0;
    LPMAPIRESOLVENAME lpfnResolveName = (LPMAPIRESOLVENAME)GetProcAddress(m_hLib, "MAPIResolveName");
    if (lpfnResolveName == NULL)
	{
		PopulateAndThrowErrorInfo(E_FUNC_NOTFOUND);
        return -1; // -1 means ResolveName failed.
	}

    while (p)
    {
        if (p->m_pRecip)
            MAPIFreeBuffer(p->m_pRecip);

        err = lpfnResolveName(
                        m_lhSession,
                        0,
                        W2A(p->m_bstrName),
                        MAPI_DIALOG,
                        0,
                        &p->m_pRecip);

        if (err != SUCCESS_SUCCESS )
        {
            count = -1;
            break;
        }
		
        p->m_pRecip->ulRecipClass = MAPI_TO;
        (*ppMapiRecipDesc)[count] = *(p->m_pRecip);
        count++;
        p = p->m_pNext;
    }

    // ResolveName failed.
    if (err != SUCCESS_SUCCESS)
    {
        delete *ppMapiRecipDesc;
        *ppMapiRecipDesc = NULL;
		PopulateAndThrowErrorInfo(err);
    }

    return count;
}

/******************************************
Func:
    MAPIFreeBuffer

Abstract:
    MAPIFreeBuffer wrapper.

Params:
    *p: buffer pointer will be deleted.
*******************************************/
void Csmapi::MAPIFreeBuffer( MapiRecipDesc* p )
{
    if (m_lpfnMapiFreeBuf == NULL && m_hLib)
    {
        m_lpfnMapiFreeBuf = (LPMAPIFREEBUFFER)GetProcAddress(m_hLib, "MAPIFreeBuffer");
    }

    if (!m_lpfnMapiFreeBuf)
        return;

    m_lpfnMapiFreeBuf(p);
}

/******************************************
Func:
    AddRecipientInternal

Abstract:
    Add one recipient to recipients list.

Params:
    *pName: new recipient name.
*******************************************/
HRESULT Csmapi::AddRecipientInternal(char* pName)
{
    MACRO_AddRecipientInternal(pName);
}

HRESULT Csmapi::AddRecipientInternal(WCHAR* pName)
{
    MACRO_AddRecipientInternal(pName);
}

/******************************************
Func:
    GetMAPIDefaultProfile

Abstract:
    get default profile string from Registry

Params:
    *pProfile: profile string buffer.
    *pdwCount: # of char of profile string 
*******************************************/

BOOL GetMAPIDefaultProfile(TCHAR* pProfile, DWORD* pdwCount)
{
    CRegKey cKey;
    LONG lRet;
    BOOL bRet = FALSE;
    lRet = cKey.Open(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles"), KEY_READ);
    if (lRet == ERROR_SUCCESS)
    {
        lRet = cKey.QueryValue(pProfile, TEXT("DefaultProfile"), pdwCount);
        if (lRet == ERROR_SUCCESS)
        {
            bRet = TRUE;
        }
        cKey.Close();
    }
    return bRet;
}


void Csmapi::PopulateAndThrowErrorInfo(ULONG err)
{
	UINT uID = 0;

	switch (err)
	{
	case E_FUNC_NOTFOUND:
		uID = IDS_E_FUNC_NOTFOUND;
		break;
	case MAPI_E_FAILURE :
		uID = IDS_MAPI_E_FAILURE;
		break;
	case MAPI_E_INSUFFICIENT_MEMORY :
		uID = IDS_MAPI_E_INSUFFICIENT_MEMORY;
		break;
	case MAPI_E_LOGIN_FAILURE :
		uID = IDS_MAPI_E_LOGIN_FAILURE;
		break;
	case MAPI_E_TOO_MANY_SESSIONS :
		uID = IDS_MAPI_E_TOO_MANY_SESSIONS;
		break;
	case MAPI_E_USER_ABORT :
		uID = IDS_MAPI_E_USER_ABORT;
		break;
	case MAPI_E_INVALID_SESSION :
		uID = IDS_MAPI_E_INVALID_SESSION;
		break;
	case MAPI_E_INVALID_EDITFIELDS :
		uID = IDS_MAPI_E_INVALID_EDITFIELDS;
		break;
	case MAPI_E_INVALID_RECIPS :
		uID = IDS_MAPI_E_INVALID_RECIPS;
		break;
	case MAPI_E_NOT_SUPPORTED :
		uID = IDS_MAPI_E_NOT_SUPPORTED;
		break;
	case MAPI_E_AMBIGUOUS_RECIPIENT :
		uID = IDS_MAPI_E_AMBIGUOUS_RECIPIENT;
		break;
	case MAPI_E_ATTACHMENT_NOT_FOUND :
		uID = IDS_MAPI_E_ATTACHMENT_NOT_FOUND;
		break;
	case MAPI_E_ATTACHMENT_OPEN_FAILURE :
		uID = IDS_MAPI_E_ATTACHMENT_OPEN_FAILURE;
		break;
	case MAPI_E_BAD_RECIPTYPE :
		uID = IDS_MAPI_E_BAD_RECIPTYPE;
		break;
	case MAPI_E_TEXT_TOO_LARGE :
		uID = IDS_MAPI_E_TEXT_TOO_LARGE;
		break;
	case MAPI_E_TOO_MANY_FILES :
		uID = IDS_MAPI_E_TOO_MANY_FILES;
		break;
	case MAPI_E_TOO_MANY_RECIPIENTS :
		uID = IDS_MAPI_E_TOO_MANY_RECIPIENTS;
		break;
	case MAPI_E_UNKNOWN_RECIPIENT :
		uID = IDS_MAPI_E_UNKNOWN_RECIPIENT;
		break;
	default:
		uID = IDS_MAPI_E_FAILURE;
	}
	//Currently the hresult in the Error info structure is set to E_FAIL
	Error(uID,IID_Ismapi,E_FAIL,_Module.GetResourceInstance());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\utils.h ===
/**********************************************************

  (C) 2001 Microsoft Corp.
  
    File    : utils.h
      
***********************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

#include "msgrua.h"

#ifdef DEBUG
#define FAILED_HR(msg, hr) (FAILED(hr)?OutMessageBox(_T("Line: %d\n") msg ,__LINE__,GetStringFromError(hr)):0)

#define DEBUG_MSG(msg) OutMessageBox(_T("Remote Assistance Error\nLine: %d\n") msg, __LINE__)
#else
#define FAILED_HR(msg,hr)  (FAILED(hr)?TraceSpew(msg,GetStringFromError(hr)):0)
#define DEBUG_MSG(msg)     TraceSpew(_T("%s"), msg)
#endif


#include "mdisp.h" 
#include "basicim.h"
#include "sessions.h"

#define MAXBUFSIZE 2000
void PrintDefaultVal(LPSTR szVal, int id, HWND hDlg);

LPCTSTR GetStringFromCOMError(HRESULT hr);
LPCTSTR GetStringFromError(HRESULT hr);
LPCTSTR GetStringFromBasicIMError(HRESULT hr);

LPCTSTR GetStringFromSessionState(SESSION_STATE ss);
LPCTSTR GetStringFromLockAndKeyStatus(long lK);
LPCTSTR GetStringFromContactStatus(MISTATUS bs);
LPCTSTR GetStringFromServiceStatus(MSVCSTATUS bs);
LPCTSTR GetStringFromUserProperty(MUSERPROPERTY ps);
LPCTSTR GetStringFromProfileField(MPFLFIELD fl);
LPCTSTR GetStringFromVoiceSessionState(VOICESESSIONSTATE vs);
LPCTSTR GetStringFromMURLType(MURLTYPE mt);

HRESULT HrEncode64 (LPSTR lpszTextIn, LPSTR lpszTextOut, DWORD dwOutLen);

LPCTSTR GetStringFromState(long lK);
LPCTSTR	GetStringFromBasicIMState(long lK);
LPCTSTR GetStringFromMessagePrivacy(long lK);
LPCTSTR GetStringFromPrompt(long lK);
LPCTSTR GetStringFromEventId(long dispid);
LPCTSTR GetStringFromSessionEventId(long dispid);
LPCTSTR GetStringFromLocalOption(long lK);
LPCTSTR	GetStringFromInboxFolder(long lK);
LPCTSTR GetStringFromProxyType(long lK);

HRESULT LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz);
HRESULT BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr);
BOOL _cdecl OutMessageBox(LPCTSTR sFormat, ...);

int GetDigit(int iLen);

#ifdef UNICODE
#define TraceSpew TraceSpewW
#else
#define TraceSpew TraceSpewA
#endif

BOOL TraceSpewA(LPCSTR sFormat, ...);
BOOL TraceSpewW(WCHAR* sFormat, ...);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F240A903_47FB_4756_8B20_D0870FE32059__INCLUDED_)
#define AFX_STDAFX_H__F240A903_47FB_4756_8B20_D0870FE32059__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <MAPI.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

// Put some generic macro here
#endif // !defined(AFX_STDAFX_H__F240A903_47FB_4756_8B20_D0870FE32059__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\activex\utils.cpp ===
/**********************************************************

  (C) 2001 Microsoft Corp.
  
    File    : utils.cpp
      
***********************************************************/

#include "stdafx.h"
#include "utils.h"
#include "mdispid.h"
#include <crtdbg.h>
#include <winreg.h>

#define STRING_CASE(val)            case val: pcsz = _T(#val); break

LPCTSTR GetStringFromCOMError(HRESULT hr)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (hr)
    {
		STRING_CASE(REGDB_E_CLASSNOTREG);
		STRING_CASE(CLASS_E_NOAGGREGATION);
		STRING_CASE(E_NOINTERFACE);
		        
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), hr);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromSessionState(SESSION_STATE ss)
{
    LPCTSTR pcsz=NULL;
    static TCHAR sz[MAX_PATH];
    
    switch (ss)
    {
		STRING_CASE(SS_UNKNOWN);
        STRING_CASE(SS_READY);
        STRING_CASE(SS_INVITATION);
        STRING_CASE(SS_CONNECTED);
        STRING_CASE(SS_CANCELLED);
        STRING_CASE(SS_DECLINED);
		STRING_CASE(SS_TERMINATED);
       
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), ss);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromServiceStatus(MSVCSTATUS bs)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (bs)
    {
        STRING_CASE(MSS_LOGGED_ON);
        STRING_CASE(MSS_NOT_LOGGED_ON);
        STRING_CASE(MSS_LOGGING_ON);
        STRING_CASE(MSS_LOGGING_OFF);
        
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), bs);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromUserProperty(MUSERPROPERTY ps)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (ps)
    {			
		STRING_CASE(MUSERPROP_INVALID_PROPERTY);
        STRING_CASE(MUSERPROP_HOME_PHONE_NUMBER);
        STRING_CASE(MUSERPROP_WORK_PHONE_NUMBER);
        STRING_CASE(MUSERPROP_MOBILE_PHONE_NUMBER);
		STRING_CASE(MUSERPROP_PAGES_ALLOWED);
//		STRING_CASE(MUSERPROP_NUMBER_OF_PUBLIC_PROPERTIES);
		STRING_CASE(MUSERPROP_PAGES_ENABLED);
        
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), ps);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromProfileField(MPFLFIELD fl)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (fl)
    {
		STRING_CASE(MPFLFIELD_COUNTRY);
		STRING_CASE(MPFLFIELD_POSTALCODE);
		STRING_CASE(MPFLFIELD_LANG_PREFERENCE);
		STRING_CASE(MPFLFIELD_GENDER);
		STRING_CASE(MPFLFIELD_PREFERRED_EMAIL);
		STRING_CASE(MPFLFIELD_NICKNAME);
		STRING_CASE(MPFLFIELD_ACCESSIBILITY);
		STRING_CASE(MPFLFIELD_WALLET);
		STRING_CASE(MPFLFIELD_DIRECTORY);
		STRING_CASE(MPFLFIELD_INETACCESS);    
        
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), fl);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromVoiceSessionState(VOICESESSIONSTATE vs)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (vs)
    {
		STRING_CASE(VOICESESSIONSTATE_DISABLED);
		STRING_CASE(VOICESESSIONSTATE_INACTIVE);
		STRING_CASE(VOICESESSIONSTATE_ACTIVE);
		        
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), vs);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromMURLType(MURLTYPE mt)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (mt)
    {
		STRING_CASE(MURLTYPE_CHANGE_PASSWORD);
		STRING_CASE(MURLTYPE_CHANGE_INFO);
		STRING_CASE(MURLTYPE_COMPOSE_EMAIL);
		STRING_CASE(MURLTYPE_GO_TO_EMAIL_INBOX);
		STRING_CASE(MURLTYPE_GO_TO_EMAIL_FOLDERS);
		STRING_CASE(MURLTYPE_CHANGE_MOBILE_INFO);
		STRING_CASE(MURLTYPE_MOBILE_SIGNUP);
		        
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), mt);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromEventId(long dispid)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (dispid)
    {

        STRING_CASE(DISPID_ONLOGONRESULT);
        STRING_CASE(DISPID_ONLOGOFF);

        STRING_CASE(DISPID_ONLISTADDRESULT);
        STRING_CASE(DISPID_ONLISTREMOVERESULT);

        STRING_CASE(DISPID_ONMESSAGEPRIVACYCHANGERESULT);
        STRING_CASE(DISPID_ONPROMPTCHANGERESULT);

        STRING_CASE(DISPID_ONUSERSTATECHANGED);
        STRING_CASE(DISPID_ONTEXTRECEIVED);
        STRING_CASE(DISPID_ONLOCALSTATECHANGERESULT);
        STRING_CASE(DISPID_ONAPPINVITERECEIVED);
        STRING_CASE(DISPID_ONAPPINVITEACCEPTED);
        STRING_CASE(DISPID_ONAPPINVITECANCELLED);
		STRING_CASE(DISPID_ONPRIMARYSERVICECHANGED);
		STRING_CASE(DISPID_ONSERVICELOGOFF);
		STRING_CASE(DISPID_ONFINDRESULT);
		STRING_CASE(DISPID_ONLOCALFRIENDLYNAMECHANGERESULT);

        STRING_CASE(DISPID_ONFILETRANSFERINVITERECEIVED);
        STRING_CASE(DISPID_ONFILETRANSFERINVITEACCEPTED);
        STRING_CASE(DISPID_ONFILETRANSFERINVITECANCELLED);
        STRING_CASE(DISPID_ONFILETRANSFERCANCELLED);
        STRING_CASE(DISPID_ONFILETRANSFERSTATUSCHANGE);

        STRING_CASE(DISPID_ONSENDRESULT);
		STRING_CASE(DISPID_ONUSERJOIN);
		STRING_CASE(DISPID_ONUNREADEMAILCHANGED);
		STRING_CASE(DISPID_ONUSERDROPPED);
		STRING_CASE(DISPID_ONREQUESTURLPOSTRESULT);
        
       
        STRING_CASE(DISPID_ONUSERFRIENDLYNAMECHANGERESULT);
        STRING_CASE(DISPID_ONNEWERCLIENTAVAILABLE);	
        STRING_CASE(DISPID_ONINVITEMAILRESULT);		
        STRING_CASE(DISPID_ONREQUESTURLRESULT);	
	    STRING_CASE(DISPID_ONSESSIONSTATECHANGE);	
	    STRING_CASE(DISPID_ONUSERLEAVE);	
	    STRING_CASE(DISPID_ONNEWSESSIONREQUEST);	
		STRING_CASE(DISPID_ONINVITEUSER);
		STRING_CASE(DISPID_ONAPPSHUTDOWN);

//	Commented out since Voice API has been removed
/*		STRING_CASE(DISPID_ONVOICEIMINVITERECEIVED);
		STRING_CASE(DISPID_ONVOICEIMINVITEACCEPTED);
		STRING_CASE(DISPID_ONVOICEIMINVITECANCELLED);*/

		STRING_CASE(DISPID_ONSPMESSAGERECEIVED);
		STRING_CASE(DISPID_ONNEWERSITESAVAILABLE);

		STRING_CASE(DISPID_ONLOCALPROPERTYCHANGERESULT);
		STRING_CASE(DISPID_ONBUDDYPROPERTYCHANGERESULT);

		STRING_CASE(DISPID_ONBEFORELAUNCHIMUI);

		STRING_CASE(DISPID_ONSHOWIMUI);
		STRING_CASE(DISPID_ONDESTROYIMUI);
		STRING_CASE(DISPID_ONINDICATEMESSAGERECEIVED);
		STRING_CASE(DISPID_ONSTATUSTEXT);
		STRING_CASE(DISPID_ONTITLEBARTEXT);
		STRING_CASE(DISPID_ONINFOBARTEXT);
		STRING_CASE(DISPID_ONSENDENABLED);

		STRING_CASE(DISPID_ONTRANSLATEACCELERATOR);
		STRING_CASE(DISPID_ONFILETRANSFER);
		STRING_CASE(DISPID_ONVOICESESSIONSTATE);
		STRING_CASE(DISPID_ONVOICEVOLUMECHANGED);
		STRING_CASE(DISPID_ONMICROPHONEMUTE);

    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), dispid);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromSessionEventId(long dispid)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (dispid)
    {
		STRING_CASE(DISPID_ONINVITATION);
		STRING_CASE(DISPID_ONAPPREGISTERED);
		STRING_CASE(DISPID_ONAPPUNREGISTERED);
		STRING_CASE(DISPID_ONLOCKCHALLENGE);
		STRING_CASE(DISPID_ONLOCKRESULT);
		STRING_CASE(DISPID_ONLOCKENABLE);
		STRING_CASE(DISPID_ONAPPSHUTDOWN);

    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), dispid);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}


LPCTSTR GetStringFromError(HRESULT hr)
{
    LPCTSTR pcsz = NULL;
    static TCHAR sz[MAX_PATH];
    
    switch (hr)
    {      
        // non-Error codes
        STRING_CASE(S_OK);
        STRING_CASE(S_FALSE);
//		STRING_CASE(E_FILE_NOT_FOUND);
		STRING_CASE(HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
		STRING_CASE(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));
       
        // Registration database stuff
        STRING_CASE(REGDB_E_CLASSNOTREG);
        STRING_CASE(REGDB_E_READREGDB);
        STRING_CASE(REGDB_E_WRITEREGDB);
        STRING_CASE(REGDB_E_KEYMISSING);
        STRING_CASE(REGDB_E_INVALIDVALUE);
        STRING_CASE(REGDB_E_IIDNOTREG);
        
        // COM error codes
        STRING_CASE(E_UNEXPECTED);
        STRING_CASE(E_NOTIMPL);
        STRING_CASE(E_OUTOFMEMORY);
        STRING_CASE(E_INVALIDARG);
        STRING_CASE(E_NOINTERFACE);
        STRING_CASE(E_POINTER);
        STRING_CASE(E_HANDLE);
        STRING_CASE(E_ABORT);
        STRING_CASE(E_FAIL);
        STRING_CASE(E_ACCESSDENIED);
        
        // MSGR Error codes
		STRING_CASE(MSGR_E_CONNECT);
		STRING_CASE(MSGR_E_INVALID_SERVER_NAME);
		STRING_CASE(MSGR_E_INVALID_PASSWORD);
		STRING_CASE(MSGR_E_ALREADY_LOGGED_ON);
		STRING_CASE(MSGR_E_SERVER_VERSION);
		STRING_CASE(MSGR_E_LOGON_TIMEOUT);
		STRING_CASE(MSGR_E_LIST_FULL);
		STRING_CASE(MSGR_E_AI_REJECT);
		STRING_CASE(MSGR_E_AI_REJECT_NOT_INST);
		STRING_CASE(MSGR_E_USER_NOT_FOUND);
		STRING_CASE(MSGR_E_ALREADY_IN_LIST);
		STRING_CASE(MSGR_E_DISCONNECTED);
		STRING_CASE(MSGR_E_UNEXPECTED);
		STRING_CASE(MSGR_E_SERVER_TOO_BUSY);
		STRING_CASE(MSGR_E_INVALID_AUTH_PACKAGES);
		STRING_CASE(MSGR_E_NEWER_CLIENT_AVAILABLE);
		STRING_CASE(MSGR_E_AI_TIMEOUT);
		STRING_CASE(MSGR_E_CANCEL);
		STRING_CASE(MSGR_E_TOO_MANY_MATCHES);
		STRING_CASE(MSGR_E_SERVER_UNAVAILABLE);
		STRING_CASE(MSGR_E_LOGON_UI_ACTIVE);
		STRING_CASE(MSGR_E_OPTION_UI_ACTIVE);
		STRING_CASE(MSGR_E_CONTACT_UI_ACTIVE);
		STRING_CASE(MSGR_E_PRIMARY_SERVICE_NOT_LOGGED_ON);
		STRING_CASE(MSGR_E_LOGGED_ON);
		STRING_CASE(MSGR_E_CONNECT_PROXY);
		STRING_CASE(MSGR_E_PROXY_AUTH);
		STRING_CASE(MSGR_E_PROXY_AUTH_TYPE);
		STRING_CASE(MSGR_E_INVALID_PROXY_NAME);
		STRING_CASE(MSGR_E_NOT_PRIMARY_SERVICE);
		STRING_CASE(MSGR_E_TOO_MANY_SESSIONS);
		STRING_CASE(MSGR_E_TOO_MANY_MESSAGES);
		STRING_CASE(MSGR_E_REMOTE_LOGIN);
		STRING_CASE(MSGR_E_INVALID_FRIENDLY_NAME);
		STRING_CASE(MSGR_E_SESSION_FULL);
		STRING_CASE(MSGR_E_NOT_ALLOWING_NEW_USERS);
		STRING_CASE(MSGR_E_INVALID_DOMAIN);
		STRING_CASE(MSGR_E_TCP_ERROR);
		STRING_CASE(MSGR_E_SESSION_TIMEOUT);
		STRING_CASE(MSGR_E_MULTIPOINT_SESSION_BEGIN_TIMEOUT);
		STRING_CASE(MSGR_E_MULTIPOINT_SESSION_END_TIMEOUT);
		STRING_CASE(MSGR_E_REVERSE_LIST_FULL);
		STRING_CASE(MSGR_E_SERVER_ERROR);
		STRING_CASE(MSGR_E_SYSTEM_CONFIG);
		STRING_CASE(MSGR_E_NO_DIRECTORY);
		STRING_CASE(MSGR_E_RETRY_SET);
		STRING_CASE(MSGR_E_CHILD_WITHOUT_CONSENT);
		STRING_CASE(MSGR_E_USER_CANCELLED);
		STRING_CASE(MSGR_E_CANCEL_BEFORE_CONNECT);
		STRING_CASE(MSGR_E_VOICE_IM_TIMEOUT);
		STRING_CASE(MSGR_E_NOT_ACCEPTING_PAGES);
		STRING_CASE(MSGR_E_EMAIL_PASSPORT_NOT_VALIDATED);

		STRING_CASE(MSGR_S_ALREADY_IN_THE_MODE);
		STRING_CASE(MSGR_S_TRANSFER_SEND_BEGUN);
		STRING_CASE(MSGR_S_TRANSFER_SEND_FINISHED);
		STRING_CASE(MSGR_S_TRANSFER_RECEIVE_BEGUN);
		STRING_CASE(MSGR_S_TRANSFER_RECEIVE_FINISHED);

		STRING_CASE(MSGR_E_MESSAGE_TOO_LONG);
		//STRING_CASE(CONNECT_E_NOCONNECTION);

		STRING_CASE(SR_APPLICATION_LAUNCH_FAILED);
		STRING_CASE(SR_INVITATION_DECLINED);
		STRING_CASE(SR_CONNECTION_FAILURE);
		STRING_CASE(SR_AUTHENTICATION_FAILED);
		STRING_CASE(SR_SESSION_NOT_READY);
		STRING_CASE(SR_SESSION_CANCELLED_LOCAL);
		STRING_CASE(SR_SESSION_CANCELLED_REMOTE);
		STRING_CASE(SR_SESSION_PROTOCOL_ERROR);
		STRING_CASE(SR_SESSION_TIMEOUT);
		STRING_CASE(SR_CANCEL_BEFORE_CONNECT);
		STRING_CASE(SR_NOT_INVITEE);
		STRING_CASE(SR_NOT_INVITER);
		STRING_CASE(SR_APP_ALREADY_REGISTERED);
		STRING_CASE(SR_APP_NOT_REGISTERED);
		STRING_CASE(SR_NOT_VALID_FOR_APP_INVITE);

		STRING_CASE(MSGR_E_API_NOTINITIALIZED);
		STRING_CASE(MSGR_E_API_LOCKED);
		STRING_CASE(MSGR_E_API_UNLOCK_FAILED);
		STRING_CASE(MSGR_E_API_ALREADY_UNLOCKED);
		STRING_CASE(MSGR_E_API_PENDING_UNLOCK);

		default:
			if( HRESULT_FACILITY(hr) == FACILITY_WIN32 )
			{
				switch( HRESULT_CODE(hr) )
				{
					STRING_CASE(RPC_X_NULL_REF_POINTER);
					STRING_CASE(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
					STRING_CASE(RPC_S_SERVER_UNAVAILABLE);
					STRING_CASE(RPC_E_SERVERFAULT);
				}
			}
               
            if( !pcsz )
            {
                wsprintf(sz, _T("(unknown) [0x%08X]"), hr);
                pcsz = sz;
            }
    }

    return pcsz;
}

LPCTSTR GetStringFromBasicIMError(HRESULT hr)
{
    LPCTSTR pcsz = NULL;
    static TCHAR sz[MAX_PATH];
    
    switch (hr)
    {
        // non-Error codes
        STRING_CASE(S_OK);
        STRING_CASE(S_FALSE);
//		STRING_CASE(E_FILE_NOT_FOUND);
       
        // Registration database stuff
        STRING_CASE(REGDB_E_CLASSNOTREG);
        STRING_CASE(REGDB_E_READREGDB);
        STRING_CASE(REGDB_E_WRITEREGDB);
        STRING_CASE(REGDB_E_KEYMISSING);
        STRING_CASE(REGDB_E_INVALIDVALUE);
        STRING_CASE(REGDB_E_IIDNOTREG);
        
        // COM error codes
        STRING_CASE(E_UNEXPECTED);
        STRING_CASE(E_NOTIMPL);
        STRING_CASE(E_OUTOFMEMORY);
        STRING_CASE(E_INVALIDARG);
        STRING_CASE(E_NOINTERFACE);
        STRING_CASE(E_POINTER);
        STRING_CASE(E_HANDLE);
        STRING_CASE(E_ABORT);
        STRING_CASE(E_FAIL);
        STRING_CASE(E_ACCESSDENIED);

		// Basic IM error codes
		STRING_CASE(BASICIM_E_CONNECT);
		STRING_CASE(BASICIM_E_INVALID_SERVER_NAME);
		STRING_CASE(BASICIM_E_INVALID_PASSWORD);
		STRING_CASE(BASICIM_E_ALREADY_LOGGED_ON);
		STRING_CASE(BASICIM_E_SERVER_VERSION);
		STRING_CASE(BASICIM_E_LOGON_TIMEOUT);
		STRING_CASE(BASICIM_E_LIST_FULL);
		STRING_CASE(BASICIM_E_AI_REJECT);
		STRING_CASE(BASICIM_E_AI_REJECT_NOT_INST);
		STRING_CASE(BASICIM_E_USER_NOT_FOUND);
		STRING_CASE(BASICIM_E_ALREADY_IN_LIST);
		STRING_CASE(BASICIM_E_DISCONNECTED);
		STRING_CASE(BASICIM_E_UNEXPECTED);
		STRING_CASE(BASICIM_E_SERVER_TOO_BUSY);
		STRING_CASE(BASICIM_E_INVALID_AUTH_PACKAGES);
		STRING_CASE(BASICIM_E_NEWER_CLIENT_AVAILABLE);
		STRING_CASE(BASICIM_E_AI_TIMEOUT);
		STRING_CASE(BASICIM_E_CANCEL);
		STRING_CASE(BASICIM_E_TOO_MANY_MATCHES);
		STRING_CASE(BASICIM_E_SERVER_UNAVAILABLE);
		STRING_CASE(BASICIM_E_LOGON_UI_ACTIVE);
		STRING_CASE(BASICIM_E_OPTION_UI_ACTIVE);
		STRING_CASE(BASICIM_E_CONTACT_UI_ACTIVE);
		STRING_CASE(BASICIM_E_PRIMARY_SERVICE_NOT_LOGGED_ON);

		STRING_CASE(BASICIM_S_ASYNCRESULT);
		//STRING_CASE(CONNECT_E_NOCONNECTION);

        default:
			if( HRESULT_FACILITY(hr) == FACILITY_WIN32 )
			{
				switch( HRESULT_CODE(hr) )
				{
					STRING_CASE(RPC_X_NULL_REF_POINTER);
					STRING_CASE(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
					STRING_CASE(RPC_S_SERVER_UNAVAILABLE);
					STRING_CASE(RPC_E_SERVERFAULT);
				}
			}
               
            if( !pcsz )
            {
                wsprintf(sz, _T("(unknown) [0x%08X]"), hr);
                pcsz = sz;
            }
    }

    return pcsz;
}

LPCTSTR GetStringFromContactStatus(MISTATUS ms)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (ms)
    {
        // MISTATUS
        STRING_CASE(MISTATUS_UNKNOWN);

        STRING_CASE(MISTATUS_OFFLINE);
        STRING_CASE(MISTATUS_ONLINE);
        STRING_CASE(MISTATUS_INVISIBLE);
        STRING_CASE(MISTATUS_BUSY);
        STRING_CASE(MISTATUS_IDLE);

        STRING_CASE(MISTATUS_BE_RIGHT_BACK);
        STRING_CASE(MISTATUS_AWAY);
        STRING_CASE(MISTATUS_ON_THE_PHONE);
        STRING_CASE(MISTATUS_OUT_TO_LUNCH);

        STRING_CASE(MISTATUS_LOCAL_FINDING_SERVER);
        STRING_CASE(MISTATUS_LOCAL_CONNECTING_TO_SERVER);
        STRING_CASE(MISTATUS_LOCAL_SYNCHRONIZING_WITH_SERVER);
        STRING_CASE(MISTATUS_LOCAL_DISCONNECTING_FROM_SERVER);

    default:
        wsprintf(sz, _T("(unknown) %i"), ms);
        pcsz = sz;
        break;
    }
    return pcsz;
}

LPCTSTR GetStringFromBasicIMState(long lK)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (lK)
    {
        STRING_CASE(BIMSTATE_ONLINE);
        STRING_CASE(BIMSTATE_OFFLINE);
        STRING_CASE(BIMSTATE_INVISIBLE);
        STRING_CASE(BIMSTATE_BUSY);
        STRING_CASE(BIMSTATE_UNKNOWN);

        STRING_CASE(BIMSTATE_BE_RIGHT_BACK);
        STRING_CASE(BIMSTATE_IDLE);
        STRING_CASE(BIMSTATE_AWAY);
        STRING_CASE(BIMSTATE_ON_THE_PHONE);
        STRING_CASE(BIMSTATE_OUT_TO_LUNCH);

        STRING_CASE(BIMSTATE_LOCAL_FINDING_SERVER);
        STRING_CASE(BIMSTATE_LOCAL_CONNECTING_TO_SERVER);
        STRING_CASE(BIMSTATE_LOCAL_SYNCHRONIZING_WITH_SERVER);
        STRING_CASE(BIMSTATE_LOCAL_DISCONNECTING_FROM_SERVER);
        
    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), lK);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromLockAndKeyStatus(long lK)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (lK)
    {
        STRING_CASE(LOCK_NOTINITIALIZED);
        STRING_CASE(LOCK_INITIALIZED);
        STRING_CASE(LOCK_PENDINGRESULT);
        STRING_CASE(LOCK_UNLOCKED);
        STRING_CASE(LOCK_UNLOCKFAILED);

    default:
        wsprintf(sz, _T("(unknown) [0x%08X]"), lK);
        pcsz = sz;
        break;
    }
    
    return pcsz;
}

LPCTSTR GetStringFromMessagePrivacy(long lK)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (lK)
    {
        STRING_CASE(MMSGPRIVACY_BLOCK_LIST_EXCLUDED);
        STRING_CASE(MMSGPRIVACY_ALLOW_LIST_ONLY);

    default:
        wsprintf(sz, _T("(unknown) %i"), lK);
        pcsz = sz;
        break;
    }
    return pcsz;
}


LPCTSTR GetStringFromPrompt(long lK)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (lK)
    {
        STRING_CASE(MPROMPT_YES_IF_NOT_ALLOWED_OR_BLOCKED);
        STRING_CASE(MPROMPT_NO_ADD_TO_ALLOW);

    default:
        wsprintf(sz, _T("(unknown) %i"), lK);
        pcsz = sz;
        break;
    }
    return pcsz;
}


LPCTSTR GetStringFromLocalOption(long lK)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (lK)
    {
		STRING_CASE(MLOPT_PROXY_STATE);
		STRING_CASE(MLOPT_PROXY_TYPE);
		STRING_CASE(MLOPT_SOCKS4_SERVER);
		STRING_CASE(MLOPT_SOCKS5_SERVER);
		STRING_CASE(MLOPT_HTTPS_SERVER);
		STRING_CASE(MLOPT_SOCKS4_PORT);
		STRING_CASE(MLOPT_SOCKS5_PORT);
		STRING_CASE(MLOPT_HTTPS_PORT);
		STRING_CASE(MLOPT_SOCKS5_USERNAME);
		STRING_CASE(MLOPT_SOCKS5_PASSWORD);
		STRING_CASE(MLOPT_SERVER_NAME);
		STRING_CASE(MLOPT_ENABLE_IDLE_DETECT);
		STRING_CASE(MLOPT_IDLE_THRESHOLD);
		STRING_CASE(MLOPT_IDLE_DETECTABLE);
		STRING_CASE(MLOPT_SS_DETECTABLE);

    default:
        wsprintf(sz, _T("(unknown) %i"), lK);
        pcsz = sz;
        break;
    }
    return pcsz;
}

LPCTSTR GetStringFromInboxFolder(long lK)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (lK)
    {
		STRING_CASE(MFOLDER_INBOX);
		STRING_CASE(MFOLDER_ALL_OTHER_FOLDERS);

    default:
        wsprintf(sz, _T("(unknown) %i"), lK);
        pcsz = sz;
        break;
    }
    return pcsz;
}

LPCTSTR GetStringFromProxyType(long lK)
{
    LPCTSTR pcsz;
    static TCHAR sz[MAX_PATH];
    
    switch (lK)
    {
        STRING_CASE(MPROXYTYPE_NO_PROXY);
        STRING_CASE(MPROXYTYPE_SOCKS4);
        STRING_CASE(MPROXYTYPE_SOCKS5);
        STRING_CASE(MPROXYTYPE_HTTPS);

    default:
        wsprintf(sz, _T("(unknown) %i"), lK);
        pcsz = sz;
        break;
    }
    return pcsz;
}

// =====================================================================================
// HrEncode64
// =====================================================================================
static char Ebase_64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ ";
HRESULT HrEncode64 (LPSTR lpszTextIn, LPSTR lpszTextOut, DWORD dwOutLen)
{
	//DebugEntry (CSignOnDlg::HrEncode64);
	_ASSERTE(lpszTextIn && lpszTextOut);

	HRESULT hr = S_OK;

	ULONG cbTextIn, i, cbTextOut = 0;

	cbTextIn = lstrlenA(lpszTextIn);

	if (dwOutLen < (cbTextIn * 4/3 + 5)) // 5 for 3 extra chars max + \0 + 1 for round down on 4/3
	{
		//ALMLogPrint (LOGERROR,_T("CSignOnDlg::HrEncode64--lpszTextOut not long enough"));
		hr = E_FAIL;
	}

	if (SUCCEEDED(hr))
	{
		// Encodes 3 characters at a time
		for (i=0; i<cbTextIn; i+=3)
		{
			UCHAR           ch[3];   

			ch[0] = lpszTextIn[i];
			ch[1] = (i+1 < cbTextIn) ? lpszTextIn[i+1] : '\0';
			ch[2] = (i+2 < cbTextIn) ? lpszTextIn[i+2] : '\0';

			lpszTextOut[cbTextOut++] = Ebase_64[ ( ch[0] >> 2 ) & 0x3F ];
			lpszTextOut[cbTextOut++] = Ebase_64[ ( ch[0] << 4 | ch[1] >> 4 ) & 0x3F ];

			if (i+1 < cbTextIn)
				lpszTextOut[cbTextOut++] = Ebase_64[ ( ch[1] << 2 | ch[2] >> 6 ) & 0x3F ];
			else
				lpszTextOut[cbTextOut++] = '=';

			if (i+2 < cbTextIn)
				lpszTextOut[cbTextOut++] = Ebase_64[ ( ch[2] ) & 0x3F ];
			else
				lpszTextOut[cbTextOut++] = '=';
		}
		// Null terminate so we know when to stop.
		lpszTextOut[cbTextOut++] = '\0';
	}

	//DebugExitHRESULT (CSignOnDlg::HrEncode64, hr);
    return hr;
}

//****************************************************************************
// LPTSTR AllocLPTSTR (ULONG cb)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

LPTSTR AllocLPTSTR (ULONG cb)
{
	LPTSTR psz = NULL;

	psz = (LPTSTR)LocalAlloc(LMEM_FIXED, cb*sizeof(TCHAR));
	return psz;
}

//////////////////////////////////////////////////////////////////////
// History:  Stolen from...
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//////////////////////////////////////////////////////////////////////
HRESULT LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz)
{
#ifndef UNICODE

	BSTR bstr = NULL;
	int i = 0;
	HRESULT hr;

	// compute the length of the required BSTR
	//
	i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
	if (i <= 0)
	{
		return E_UNEXPECTED;
	};

	// allocate the widestr, +1 for terminating null
	//
	bstr = SysAllocStringLen(NULL, i-1); // SysAllocStringLen adds 1

	if (bstr != NULL)
	{
		MultiByteToWideChar(CP_ACP, 0, psz, -1, (LPWSTR)bstr, i);
		((LPWSTR)bstr)[i - 1] = 0;
		*pbstr = bstr;
		hr = S_OK;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	};

	return hr;

#else

	BSTR bstr = NULL;

	bstr = SysAllocString(psz);

	if (bstr != NULL)
	{
		*pbstr = bstr;

		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	};

#endif // UNICODE
}

//
//   FUNCTION: OutMessageBox(LPCTSTR sFormat, ...)
//
//   PURPOSE: Pop up a message box with the error message.
//
BOOL _cdecl OutMessageBox(LPCTSTR sFormat, ...)
{					
	va_list			VarArg;
	TCHAR			sText[MAXBUFSIZE];
	DWORD			nBytesToWrite;

	va_start(VarArg,sFormat);
	nBytesToWrite = wvsprintf(sText, sFormat, VarArg);

	MessageBox(NULL, sText, TEXT("RA Debug"), MB_OK);
    return TRUE;
}

BOOL TraceInit()
{
    static BOOL bInit = FALSE;
    static BOOL bTrace = FALSE;

    if (!bInit)
    {
        DWORD dwValue = 0, dwSize=sizeof(DWORD);
        HKEY hKey = NULL;

        bInit = TRUE;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                        _T("SOFTWARE\\Microsoft\\PCHealth\\HelpCtr\\SAFSessionResolver"), 
                                        0,
                                        KEY_READ,
                                        &hKey))
		{
            if (ERROR_SUCCESS == RegQueryValueEx(hKey, _T("DebugSpew"), NULL, NULL, (BYTE*)&dwValue, &dwSize))
                bTrace = !!dwValue;
            RegCloseKey(hKey);
        }
    }

    return bTrace;
}

BOOL TraceSpewA(LPCSTR sFormat, ...)
{
    OutputDebugStringW(L"TraceSpewA: Not implemented yet");
    return TRUE;
}

BOOL TraceSpewW(WCHAR* sFormat, ...)
{
	va_list			VarArg;
	WCHAR			sText[MAXBUFSIZE];
	DWORD			nBytesToWrite;

    if (TraceInit())
    {
        va_start(VarArg,sFormat);
        swprintf(sText, L"\nRA:\r");
        nBytesToWrite = vswprintf(&sText[5], sFormat, VarArg);

        OutputDebugStringW(sText);
    }
    return TRUE;
}


int GetDigit(int iLen)
{
    int iRet = 0;
    while (iLen >= 1)
    {
        iRet ++;
        iLen /= 10;
    }
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\dplay_im\directplayconnection.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DirectPlayConnection

Abstract:

    DirectPlayConnection is a wrapper around the direct play interfaces
    to just do what is needed for this application.  It takes care of 
    connecting to the remote machine and sending/recieving the connction
    paramters.

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __DIRECTPLAYCONNECTION_H__
#define __DIRECTPLAYCONNECTION_H__

#include "dplobby.h"
#define USE_IM_OBJECT 0

#if USE_IM_OBJECT // Don't use IM objects
#include "msmsgs_i.c"
#endif

//  We want to wait 60 seconds for the remote instance to start
#define GETREMOTEPLAYERTIMEOUT (60*1000)

//  We want to wait 60 seconds for the message to show up
#define GETPARMSTIMEOUT (60*1000)

////////////////////////////////////////////////
//
//    CDirectPlayConnection
//
//    Class for dealing with all the direct play APIs.
//

class CDirectPlayConnection  
{
private:
    
    DPID m_PlayerID;
    DPID m_idOtherPlayer;
    BOOL m_bConnected;
    LPDIRECTPLAY2 m_rDirectPlay;
    LPDPLCONNECTION m_rSettings;
    LPDIRECTPLAYLOBBY m_rLobby;
    HANDLE m_hEventHandle;
    BSTR m_bstrLocalName;

    HRESULT GetOtherPlayerID(DPID*);
    LPDPMSG_GENERIC ReceiveMessage(DPID from, DPID to, DWORD dwFlags);
    HRESULT GetLocalPlayerName();

public:

    //  Constructor/Destructor
    CDirectPlayConnection();
    ~CDirectPlayConnection();
    
    //  This returns whether or not this is the server session.
    BOOL IsServer();

    //  This fetches the connection parms from the server session.
    HRESULT ReceiveConnectionParameters(BSTR *pData);

    //  This sends the connection parms to the client session,
    HRESULT SendConnectionParameters(BSTR parms);
    
    //  This connections you to the remote session.
    HRESULT ConnectToRemoteApplication();

    // This disconnects you from the remote session
    HRESULT DisconnectRemoteApplication();

    HRESULT GetOtherPlayerName(TCHAR* pName, DWORD* pdwSize);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\dplay_im\directplayconnection.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DirectPlayConnection.cpp

Abstract:

    DirectPlayConnection is a wrapper around the direct play interfaces
    to just do what is needed for this application.  It takes care of 
    connecting to the remote machine and sending/recieving the connction
    paramters.

Author:

    Marc Reyhner 7/5/2000
    SteveShi (updated) 8/23/2000

--*/

#include "stdafx.h"

#include "DirectPlayConnection.h"
#include "resource.h"
#include "msmsgs.h"

#define DP_ERR( hr ) if(SUCCEEDED(hr)) hr = E_FAIL; // Weird DP error.

#define DP_MY_DATATYPE          0x0111

typedef struct _DP_MY_DATA
{
    DWORD       dwType;         // My message type
    DWORD       dwDataSize;
    BYTE        pData[1];
} DP_MY_DATA, *LPDP_MY_DATA;

/***********************************************
Func:
    EnumPlayersCallback
Abstract:
    Callback function for enumerating the player list.
    For our scenario, we've only one remote player.
************************************************/
static BOOL FAR PASCAL
EnumPlayersCallback(DPID dpId, DWORD dwPlayerType, LPCDPNAME lpName, DWORD dwFlags, LPVOID lpContext)
{
    *(DPID*)lpContext = dpId;
    return FALSE;
}

/*************************************************
Func:
    EnumAddressCallback
Abstract:
    Return remote player's IP address.
**************************************************/
BOOL FAR PASCAL
EnumAddressCallback(REFGUID guidDataType,
                                          DWORD dwDataSize,
                                          LPCVOID lpData,
                                          LPVOID lpContext)
{
    if (guidDataType == DPAID_INet)
    {
        strcpy((char*)lpContext, (char*)lpData);
        return FALSE;
    }
    return TRUE;
}

/**********************************************
Func:
    Constructor
Abstract:
    Initialize member variables
***********************************************/
CDirectPlayConnection::CDirectPlayConnection()
{
    m_rLobby = NULL;
    m_rSettings = NULL;
    m_rDirectPlay = NULL;
    m_bConnected = FALSE;
    m_PlayerID = 0;
    m_hEventHandle = NULL;
    m_bstrLocalName = NULL;
    m_idOtherPlayer = 0;
}

/**********************************************
Func:
    Destructor
Abstract:
    Clean up left memory
***********************************************/
CDirectPlayConnection::~CDirectPlayConnection()
{
    DisconnectRemoteApplication();

    if (m_bstrLocalName)
        SysFreeString(m_bstrLocalName);
}

/*********************************************************
Func:
    ConnectToRemoteApplication
Abstract:
    Start DP connection
**********************************************************/
HRESULT CDirectPlayConnection::ConnectToRemoteApplication()
{
	DWORD dwSize = 0;
	HRESULT hr;

    if (!m_rLobby)
    {
        hr = CoCreateInstance(CLSID_DirectPlayLobby,NULL,CLSCTX_ALL,
            IID_IDirectPlayLobby,(LPVOID*)&m_rLobby);

	    if (hr != S_OK) 
		    goto done;
    }

    if (!m_hEventHandle)
    {
        m_hEventHandle = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (!m_hEventHandle) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }
    }
    
    hr = m_rLobby->GetConnectionSettings(0,NULL,&dwSize);
	if (hr != DPERR_BUFFERTOOSMALL) // Unknown error.
    {
        DP_ERR(hr);
        goto done;
    }

    m_rSettings = (DPLCONNECTION *)new BYTE [dwSize];
	if (!m_rSettings) 
    {
        hr = E_OUTOFMEMORY;        
		goto done;
    }
	    
    hr = m_rLobby->GetConnectionSettings(0,m_rSettings,&dwSize);
    if (hr != DP_OK) 
    {
        DP_ERR(hr);
        goto done;
    }

    hr = m_rLobby->Connect(0,&m_rDirectPlay,NULL);
    if (hr != DP_OK) 
    {
        DP_ERR(hr);
        goto done;
    }

    if (SUCCEEDED(GetLocalPlayerName()))
    {
        DPNAME DPName;
        DPName.dwSize=sizeof(DPNAME);
        DPName.dwFlags = 0;
        DPName.lpszShortName = m_bstrLocalName;
	    hr = m_rDirectPlay->CreatePlayer(&m_PlayerID,&DPName,m_hEventHandle,NULL,0,0);
    }
    else
	    hr = m_rDirectPlay->CreatePlayer(&m_PlayerID,NULL,m_hEventHandle,NULL,0,0);

    if (hr != DP_OK) 
		goto done;

    m_bConnected = TRUE;
    
done:
    return hr;
}

/**********************************************************
Func:
    DisconnectRemoteApplication
Abstract:
    Disconnect DP and clean up
***********************************************************/
HRESULT CDirectPlayConnection::DisconnectRemoteApplication()
{
    HRESULT hr = S_OK;

    if (m_rDirectPlay)
    {
        m_rDirectPlay->Close();
        m_rDirectPlay->Release();
        m_rDirectPlay = NULL;
    }
    
    if (m_rLobby) 
    {
        m_rLobby->Release();
        m_rLobby = NULL;
    }

    if (m_hEventHandle) 
    {
        CloseHandle(m_hEventHandle);
        m_hEventHandle = NULL;
    }

	if (m_rSettings) 
    {
		delete m_rSettings;
        m_rSettings = NULL;
	}

    m_idOtherPlayer = 0;

    m_bConnected = FALSE;
    return hr;
}

/*********************************************
Func:
    SendConnectionParameters
Abstract:
    Send data to remote player
Params:
    parms: A BSTR data string to send
**********************************************/
HRESULT CDirectPlayConnection::SendConnectionParameters(BSTR parms)
{
	HRESULT hr;

    DWORD dwCount;

    if (!m_bConnected) 
    {
        hr = S_FALSE;
        goto done;
	}

    if (m_idOtherPlayer == 0 && (FAILED(GetOtherPlayerID(&m_idOtherPlayer))))
    {
        hr = S_FALSE; // no other player
        goto done;
    }

    // We don't support Secured session now, leave the code here for future usage.
    /************************
    if (m_rSettings->lpSessionDesc->dwFlags & DPSESSION_SECURESERVER) 
    {
	    hr = m_rDirectPlay->Send(m_PlayerID,
                                 m_idOtherPlayer,
		                         DPSEND_ENCRYPTED|DPSEND_GUARANTEED|DPSEND_SIGNED,
                                 parms,
		                         dwCount);
        if (hr != DP_OK) 
		    goto done;
    } 
    else 
    *************************/
    {
        dwCount = (wcslen(parms)+1) * sizeof(OLECHAR);
        LPDP_MY_DATA pConnectParms = (LPDP_MY_DATA)new BYTE[sizeof(DP_MY_DATA) + dwCount];
        if (!pConnectParms) 
        {
            hr = E_OUTOFMEMORY;
		    goto done;
        }
        pConnectParms->dwType = DP_MY_DATATYPE;
        pConnectParms->dwDataSize = dwCount;
        CopyMemory(pConnectParms->pData, (LPVOID)parms, dwCount);
        hr = m_rDirectPlay->Send(m_PlayerID,
                                 m_idOtherPlayer,
                                 DPSEND_GUARANTEED,
                                 pConnectParms,
                                 sizeof(DP_MY_DATA) + dwCount);

        delete pConnectParms;
    }

done:
    return hr;
}

/************************************************
Func:
    ReceiveConnectionParameters
Abstract:
    Receive data from remote player
Return:
    BSTR data string from remote player
**************************************************/
HRESULT CDirectPlayConnection::ReceiveConnectionParameters( BSTR* pBstr)
{
	DWORD dwSize = 0;
	DWORD endWaitTime;
    DWORD dwResult;
    HRESULT hr = S_OK;
    LPDP_MY_DATA pData = NULL;
    
    if (!m_bConnected) 
        return S_FALSE; // not connected

    if (m_idOtherPlayer == 0 && FAILED(GetOtherPlayerID(&m_idOtherPlayer)))
    {
        hr = S_FALSE; // No other player
        goto done;
    }
           	
	endWaitTime = GetTickCount() + GETPARMSTIMEOUT; // 1 minute
	
    while (1) 
    {
        hr = m_rDirectPlay->Receive(&m_idOtherPlayer, 
                                    &m_PlayerID, 
                                    DPRECEIVE_FROMPLAYER | DPRECEIVE_TOPLAYER,
                                    NULL,
                                    &dwSize);

        if (hr == DPERR_BUFFERTOOSMALL && dwSize >= sizeof(DP_MY_DATA))
        {
            // Have received some meaningful message...
            pData = (LPDP_MY_DATA) new BYTE[dwSize];
            if (!pData)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            hr = m_rDirectPlay->Receive(&m_idOtherPlayer, 
                                        &m_PlayerID, 
                                        DPRECEIVE_FROMPLAYER | DPRECEIVE_TOPLAYER,
                                        (LPVOID)pData,
                                        &dwSize);
            if (hr != DP_OK)
                goto done;

            if (pData->dwType == DP_MY_DATATYPE)
            {           
                *pBstr = SysAllocString((WCHAR*)pData->pData);
                break;
            }
        }

        // If we can't get the message in pre-defined duration, then we failed.
        if (endWaitTime < GetTickCount())
        {
            hr = E_FAIL;
            goto done;
        }

        // Wait for another message to come.
        dwResult = WaitForSingleObject(m_hEventHandle, GETPARMSTIMEOUT); // Wait 60 seconds.
        if (dwResult != WAIT_OBJECT_0) 
        {
            hr = E_FAIL; // Timed out.
		    goto done;
        }
    }
	
done:
    if (pData)
        delete pData;

    return hr;
}

BOOL CDirectPlayConnection::IsServer()
{
    if (!m_bConnected) 
    {
        return FALSE;
	}

	return (m_rSettings->dwFlags & DPLCONNECTION_CREATESESSION);
}

/***************************************
Func:
    GetOtherPlayerID
Abstract:
    Find the other player's ID
Params:
    *pID: the return ID.
****************************************/
HRESULT CDirectPlayConnection::GetOtherPlayerID(DPID* pID)
{    
    HRESULT hr = S_OK;
    DPID ID = 0;

    hr = m_rDirectPlay->EnumPlayers(NULL, EnumPlayersCallback, &ID, /*&playerData,*/ DPENUMPLAYERS_REMOTE);
    if (hr == DP_OK && ID)
    {
        *pID = ID;
        return hr;
    }

    // OK. The other player is not in yet. Waiting for the System msg that tells when he's ready.
    LPDPMSG_GENERIC lpMsg = NULL;
    LPDPMSG_CREATEPLAYERORGROUP lpCreateMsg; 
    DWORD dwResult;
    DWORD timeOutTime;
    timeOutTime = GetTickCount() + GETREMOTEPLAYERTIMEOUT; // Wait 60 seconds.

    hr = E_FAIL;

	while (1) 
    {
        // Listen to all system messages to catch the Create Player msg.
        while (lpMsg = ReceiveMessage(DPID_SYSMSG,m_PlayerID,
                                      DPRECEIVE_TOPLAYER|DPRECEIVE_FROMPLAYER)) 
        {
            if (lpMsg->dwType == DPSYS_CREATEPLAYERORGROUP) 
            {
                lpCreateMsg = (LPDPMSG_CREATEPLAYERORGROUP)lpMsg;
                if (lpCreateMsg->dwPlayerType == DPPLAYERTYPE_PLAYER &&
                    lpCreateMsg->dpId != m_PlayerID) 
                {
                    *pID = lpCreateMsg->dpId;
                    delete lpMsg;
                    hr = S_OK;

                    goto done;
                }
            }
            delete lpMsg;
        }

        if (timeOutTime < GetTickCount()) // Timeout.
            break;

        // Wait for next message.
        dwResult = WaitForSingleObject(m_hEventHandle,GETREMOTEPLAYERTIMEOUT);
        if (dwResult != WAIT_OBJECT_0) // Timeout.
	        goto done;
    }

done:
    return hr;
}

/***************************************************
Func:
    GetLocalPlayerName
Abstract:
    Return the user name of local machine.
****************************************************/
HRESULT CDirectPlayConnection::GetLocalPlayerName()
{
    HRESULT hr = S_OK;

    // Clean up local name buffer.
    if (m_bstrLocalName)
    {
        SysFreeString(m_bstrLocalName);
        m_bstrLocalName = NULL;
    }

#if USE_IM_OBJECT // Don't use the IM objects.
    IMsgrObject *pObj;

    hr = CoCreateInstance(CLSID_MsgrObject,     //Class identifier (CLSID) of the object
                          NULL, //Pointer to controlling IUnknown
                          CLSCTX_INPROC_SERVER,  //Context for running executable code
                          IID_IMsgrObject,         //Reference to the identifier of the interface
                          (LPVOID*)&pObj);         //Address of output variable that receives 
    if (SUCCEEDED(hr))
    {
        pObj->get_LocalFriendlyName(&m_bstrLocalName);
        pObj->Release();
        goto done;
    }
#else // Use the local username variable
    WCHAR szName[256];
    DWORD dw = GetEnvironmentVariable(L"USERNAME", szName, 255);
    if (dw == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    if (dw > 255)
    {
        WCHAR *p = new WCHAR[dw+1];
        if (!p)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        GetEnvironmentVariable(L"USERNAME", p, dw);
        m_bstrLocalName = SysAllocString(p);
        delete p;
    }
    else
        m_bstrLocalName = SysAllocString(szName);

#endif
done:
    return hr;                       
}

/*****************************************
Func:
    GetOtherPlayerName
Abstract:
    Return the name on the other side of connection
Params:
    pName: buffer. If other player doesn't have a name, a null string will be returned.
    pdwCount: buffer size in char.
******************************************/
HRESULT CDirectPlayConnection::GetOtherPlayerName(TCHAR* pName, DWORD* pdwCount)
{
    DPID ID;
    HRESULT hr = E_FAIL;
    LPBYTE pBuffer = NULL;
    DWORD dwOriSize = *pdwCount;

    *pdwCount = 0;

    if (m_idOtherPlayer == 0)
        hr = GetOtherPlayerID(&m_idOtherPlayer);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = 0;
        hr = m_rDirectPlay->GetPlayerName(m_idOtherPlayer, (LPVOID)pBuffer, &dwSize);
        if (hr == DPERR_BUFFERTOOSMALL)
        {
            pBuffer = new BYTE[dwSize];
            if (!pBuffer)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            hr = m_rDirectPlay->GetPlayerName(m_idOtherPlayer, (LPVOID)pBuffer, &dwSize);
            if (hr == DP_OK)
            {
                LPTSTR p = ((DPNAME*)pBuffer)->lpszShortName;                
                if (p && *p != _T('\0'))
                {
                    dwSize = _tcslen(p);
                    if (dwSize > dwOriSize)
                    {
                        hr = DPERR_BUFFERTOOSMALL;
                        goto done;
                    }

                    _stprintf(pName, p); 
                    *pdwCount = dwSize;
                    goto done;
                }
            }
        }
    }

done:
    if (pBuffer)
        delete pBuffer;

    return hr;
}



/*++

Routine Description:

    This reads the next message for the given from and to addresses.
*/
LPDPMSG_GENERIC CDirectPlayConnection::ReceiveMessage(DPID from,DPID to,DWORD dwFlags)
{
    HRESULT hr;
    LPVOID lpMsg = 0x0;
    DWORD dwSize = 0;

    hr = m_rDirectPlay->Receive(&from,&to,dwFlags,NULL,&dwSize);
    if (hr != DPERR_BUFFERTOOSMALL) 
        goto done; //Either no message or failed

    lpMsg = (LPVOID)new BYTE [dwSize];
    if (!lpMsg)         //"Out of memory.
        goto done;
    
    hr = m_rDirectPlay->Receive(&from,&to,dwFlags,lpMsg,&dwSize);
    if (hr != DP_OK) 
    {
        //"Error receiving message.";
        goto done;
    }

    return (LPDPMSG_GENERIC)lpMsg;

done:

    if (lpMsg) {
        delete lpMsg;
    }
    return NULL;
}

/* Do we need this function ???*/
static BOOL
SendLaunchSuccessful(
    IN OUT LPDIRECTPLAYLOBBY2 pLobby
    )
{
	HRESULT hr;
	DPLMSG_GENERIC msg;
	
	msg.dwType = DPLSYS_DPLAYCONNECTSUCCEEDED;
	hr = pLobby->SendLobbyMessage( DPLMSG_STANDARD, 0, &msg, sizeof(msg) );
	if ( FAILED(hr) )
	{
		MessageBox( NULL, TEXT("Send system message failed."), TEXT("Error"), MB_OK |
               	MB_APPLMODAL );
		return false;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\dplay_im\stdafx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Precompiled Headers

Abstract:

    Just the precompiled headers.

Author:

    Marc Reyhner 7/5/2000

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\dplay_im\rcontrol.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Rcontrol.h

Author:

    Steve Shih 7/5/2000

--*/

#ifndef __RCONTROL_H__
#define __RCONTROL_H__

EXTERN_C const IID DIID_DMsgrSessionEvents;
EXTERN_C const IID DIID_DMsgrSessionManagerEvents;
EXTERN_C const IID LIBID_MsgrSessionManager;

// Window name for inviter side
TCHAR szWindowClass[] = TEXT("Microsoft Remote Assistance Messenger window");

// My startup page.
#ifdef _PERF_OPTIMIZATIONS
#define CHANNEL_PATH TEXT("\\PCHEALTH\\HelpCtr\\Binaries\\HelpCtr.exe -Mode \"hcp://system/Remote Assistance/RAIMLayout.xml\" -Url \"hcp://system/Remote%20Assistance")
#else
#define CHANNEL_PATH TEXT("\\PCHEALTH\\HelpCtr\\Binaries\\HelpCtr.exe -Mode \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/RAIMLayout.xml\" -Url \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance")
#endif


// Help functions
void RegisterEXE(BOOL);
void InviterStart(HINSTANCE, IMsgrSession*);
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow);
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\dplay_im\rcontrol.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    Rcontrol.cpp

Abstract:
    This is the entry of our Remote Assistance DirectPlay application.

Author:
    steveshi 10/1/2000

--*/

#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#include "stdafx.h"
#include "resource.h"
#include "sessions.h"
#include "utils.h"
#include "rcontrol.h"
#include "rcbdyctl.h"
#include "rcbdyctl_i.c"
#include "imsession.h"
#include "sessions_i.c"

//#include "sessions_i.c"

TCHAR c_szHttpPath[] = _T("http://www.microsoft.com");

CComModule _Module;
HWND g_hWnd = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

INT WINAPI
WinMain(HINSTANCE hInstance, 
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        INT nShowCmd)
{
    HRESULT hr;
    DWORD dwID;
    BOOL bIsInviter = FALSE;
    IIMSession* pIMSession = NULL;

    CoInitialize(NULL);
    _Module.Init(NULL, hInstance);

    for (LPSTR lpszToken=lpCmdLine; lpszToken && *lpszToken !='\0' && *lpszToken != '-'; lpszToken++) ;
    if (*lpszToken == '-')
    {
        if (_stricmp(++lpszToken, "UnregServer")==0)
        {
            RegisterEXE(FALSE);
        }
        else if (_stricmp(lpszToken, "RegServer")==0)
        {
            RegisterEXE(TRUE);
        }
        else if (_stricmp(lpszToken, "LaunchRA")==0)
		{
			TCHAR szCommandLine[2000];
			PROCESS_INFORMATION ProcessInfo;
			STARTUPINFO StartUpInfo;

			TCHAR szWinDir[2048];
			GetWindowsDirectory(szWinDir, 2048);

			ZeroMemory((LPVOID)&StartUpInfo, sizeof(STARTUPINFO));
			StartUpInfo.cb = sizeof(STARTUPINFO);    

			wsprintf(szCommandLine, _T("%s\\pchealth\\helpctr\\binaries\\helpctr.exe -url \"hcp://services/centers/support?topic=hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/Escalation/Common/rcscreen1.htm\""), szWinDir);
			CreateProcess(NULL, szCommandLine,NULL,NULL,TRUE,CREATE_NEW_PROCESS_GROUP,NULL,&szWinDir[0],&StartUpInfo,&ProcessInfo);

		}
		else
        {
            // Wrong parameter. Do nothing.
        }

        goto done;
    }

    // OK, it's not Reg/UnRegserver. Lets run it.
    hr = ::CoCreateInstance(CLSID_IMSession, NULL, CLSCTX_INPROC_SERVER,
                            IID_IIMSession, (LPVOID*)&pIMSession);
    if (FAILED_HR(TEXT("CoCreate IMSession failed %s"), hr))
        goto done;

    dwID = GetCurrentProcessId();
    hr = pIMSession->GetLaunchingSession(dwID);
    if (FAILED_HR(TEXT("GetLaunchingSession failed: %s"), hr))
        goto done;

    hr = pIMSession->get_IsInviter(&bIsInviter);
    if (FAILED_HR(TEXT("Session Get flags failed: %s"), hr))
        goto done;
    
    if (bIsInviter) // Inviter. Only happened when Messenger UI sends this invitation.
    {
        MSG msg;

        InitInstance(hInstance, 0);

        if (FAILED(hr = pIMSession->Hook(NULL, g_hWnd)))
            goto done;

#define RA_TIMEOUT 300*1000 // 5 minutes
        SetTimer(g_hWnd, TIMER_TIMEOUT, RA_TIMEOUT, NULL);

        // Goto msg pump 
        while (GetMessage(&msg, NULL, 0, 0)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    else // Invitee: should be handled inside HelpCtr.
    {
        pIMSession->Release(); // since I don't need it.
        pIMSession = NULL;

        // 1. Create HelpCtr and pass it my process ID.
        TCHAR szCommandLine[2000];
        PROCESS_INFORMATION ProcessInfo;
        STARTUPINFO StartUpInfo;

        TCHAR szWinDir[2048];
        GetWindowsDirectory(szWinDir, 2048);

        ZeroMemory((LPVOID)&StartUpInfo, sizeof(STARTUPINFO));
        StartUpInfo.cb = sizeof(STARTUPINFO);    

        wsprintf(szCommandLine, _T("%s%s/Interaction/Client/rctoolScreen1.htm\" -ExtraArgument \"IM=%d\""), szWinDir,CHANNEL_PATH, dwID);
        CreateProcess(NULL, szCommandLine,NULL,NULL,TRUE,CREATE_NEW_PROCESS_GROUP,NULL,&szWinDir[0],&StartUpInfo,&ProcessInfo);

//#define SLEEP_TIME 60 * 1000 // 60 seconds
//        Sleep(SLEEP_TIME);
    }

done:
    if (pIMSession)
        pIMSession->Release();

    _Module.Term();
    CoUninitialize();    

    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// The Inviter World: Only get called when Messenger UI starts this invitation.
/////////////////////////////////////////////////////////////////////////////////////////////

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    HWND hWnd;

	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= NULL; //LoadIcon(hInstance, (LPCTSTR)IDI_MARBLE);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= NULL; //(LPCSTR)IDC_MARBLE;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= NULL; //LoadIcon(wcex.hInstance, (LPCTSTR)IDI_MARBLE);

	RegisterClassEx(&wcex);

    hWnd = CreateWindow(szWindowClass, TEXT("Remote Assistance"), WS_OVERLAPPEDWINDOW,
                        CW_USEDEFAULT, CW_USEDEFAULT, 500, 500, NULL, NULL, hInstance, NULL);

    if (!hWnd)
    {
        return FALSE;
    }

    g_hWnd = hWnd;	// Save the window handle

#ifdef DEBUG // Maybe it's useful for debug build.
    //ShowWindow(hWnd, nCmdShow);
    //UpdateWindow(hWnd);
#endif
   return TRUE;
}

void RegisterEXE(BOOL bRegister)
{
    CComBSTR bstrRAName;
    HKEY hKey = NULL;

    TCHAR szPath[MAX_PATH];

#define REG_KEY_SESSMGR_RA _T("SOFTWARE\\Microsoft\\MessengerService\\SessionManager\\Apps\\") C_RA_APPID
//{56b994a7-380f-410b-9985-c809d78c1bdc}]

    bstrRAName.LoadString(IDS_RA_NAME);

    if (bRegister)
    {
        GetModuleFileName(NULL, szPath, MAX_PATH);
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_SESSMGR_RA, 0, NULL, 
                                            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL))
        {
            RegSetValueExW(hKey, L"Name", 0, REG_SZ, (LPBYTE)((BSTR)bstrRAName), bstrRAName.Length()*sizeof(WCHAR));
            RegSetValueEx(hKey, _T("URL"),  0, REG_SZ, (LPBYTE)c_szHttpPath, _tcslen(c_szHttpPath)*sizeof(TCHAR));
            RegSetValueEx(hKey, _T("Path"), 0, REG_SZ, (LPBYTE)szPath, _tcslen(szPath)*sizeof(TCHAR));
        }
        RegCloseKey(hKey);
        // Need to clean up some leftover from Beta2, if it's still there.
        SHDeleteKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\MicroSoft\\DirectPlay\\Applications\\Remote Assistance"));
    }
    else
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_SESSMGR_RA);
    }
    
    return;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	
	switch (message) 
	{
	case WM_CREATE:
		{
		}
		break;
	case WM_DESTROY:
		{
			PostQuitMessage(0);
		}
		break;
    case WM_TIMER:
        {
            if (wParam == TIMER_TIMEOUT)
            {
                DestroyWindow(g_hWnd);
                PostQuitMessage(0);
            }
        }
        break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\dplay_im\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rcontrol.rc
//
#define IDS_FOO                         1
#define IDS_ADVISEERROR                 1
#define IDS_ERRORDDLGTITLE              2
#define IDS_TRAYTOOLTIPDISCONNECTED     3
#define IDS_TRAYEXITDLGTEXT             4
#define IDS_TRAYEXITDLGTITLE            5
#define IDS_STRINGMISSING               6
#define IDS_DPERRORCREATE               7
#define IDS_DPNOTLOBBIED                8
#define IDS_DPERRORCONNECT              9
#define IDS_DPNOTCONNECTED              10
#define IDS_DPERRORSEND                 11
#define IDS_DPERRORRECEIVE              12
#define IDS_DPERRORTIMEOUT              13
#define IDS_CLIENTWNDTITLE              14
#define IDS_CLIENTERRORCREATE           15
#define IDS_SERVERRRORCREATE            16
#define IDS_SERVERERRORLISTEN           17
#define IDS_TRAYTOOLTIPCONNECTED        18
#define IDS_TRAYINFOTEXT                19
#define IDS_TRAYINFOTITLE               20
#define IDS_INITERRORMUTEX              21
#define IDS_INITALREADYEXISTS           22
#define IDS_DPERRORMSGRECIEVE           23
#define IDS_CLIENTREMOTEFAIL            24
#define IDS_CLIENTREMOTEDISCONNECT      25
#define IDS_RDSERRORSTOPLISTENING       26
#define IDS_HELPCTR_CLOSED              27
#define IDS_RA_NAME                     28
#define IDS_INVITATION_TERMINATED       29
#define IDS_PROJNAME                    100
#define IDR_Rcontrol                    100
#define IDR_ONCONNECTED                 101
#define IDI_TRAYICON                    201
#define IDR_TRAYMENU                    204
#define IDR_CLIENTMENU                  206
#define IDI_CLIENTICON                  207
#define IDD_ABOUT                       208
#define IDD_APPROVALWAIT                209
#define ID_QUIT                         32773
#define ID_EXIT                         32774
#define ID_ABOUT                        32775

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        211
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\dplay_im\stdafx.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Precompiled Headers

Abstract:

    Just the precompiled headers.

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <atlbase.h>

//
//  This makes ATL happy.  We don't actually instantiate this anywhere
//  but ATL gets unhappy if _Module isn't even defined
//
extern CComModule _Module;

#include <atlcom.h>
#include <atlwin.h>



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\im_inc\mdisp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Mar 02 11:18:03 2001
 */
/* Compiler settings for ..\..\msgsm7\bl\msbl\mdisp.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mdisp_h__
#define __mdisp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMsgrObject_FWD_DEFINED__
#define __IMsgrObject_FWD_DEFINED__
typedef interface IMsgrObject IMsgrObject;
#endif 	/* __IMsgrObject_FWD_DEFINED__ */


#ifndef __IMsgrUser_FWD_DEFINED__
#define __IMsgrUser_FWD_DEFINED__
typedef interface IMsgrUser IMsgrUser;
#endif 	/* __IMsgrUser_FWD_DEFINED__ */


#ifndef __IMsgrUsers_FWD_DEFINED__
#define __IMsgrUsers_FWD_DEFINED__
typedef interface IMsgrUsers IMsgrUsers;
#endif 	/* __IMsgrUsers_FWD_DEFINED__ */


#ifndef __IMsgrIMSession_FWD_DEFINED__
#define __IMsgrIMSession_FWD_DEFINED__
typedef interface IMsgrIMSession IMsgrIMSession;
#endif 	/* __IMsgrIMSession_FWD_DEFINED__ */


#ifndef __IMsgrIMSessions_FWD_DEFINED__
#define __IMsgrIMSessions_FWD_DEFINED__
typedef interface IMsgrIMSessions IMsgrIMSessions;
#endif 	/* __IMsgrIMSessions_FWD_DEFINED__ */


#ifndef __IMessengerApp_FWD_DEFINED__
#define __IMessengerApp_FWD_DEFINED__
typedef interface IMessengerApp IMessengerApp;
#endif 	/* __IMessengerApp_FWD_DEFINED__ */


#ifndef __IMessengerApp2_FWD_DEFINED__
#define __IMessengerApp2_FWD_DEFINED__
typedef interface IMessengerApp2 IMessengerApp2;
#endif 	/* __IMessengerApp2_FWD_DEFINED__ */


#ifndef __IMessengerApp3_FWD_DEFINED__
#define __IMessengerApp3_FWD_DEFINED__
typedef interface IMessengerApp3 IMessengerApp3;
#endif 	/* __IMessengerApp3_FWD_DEFINED__ */


#ifndef __IMessengerIMWindow_FWD_DEFINED__
#define __IMessengerIMWindow_FWD_DEFINED__
typedef interface IMessengerIMWindow IMessengerIMWindow;
#endif 	/* __IMessengerIMWindow_FWD_DEFINED__ */


#ifndef __IMessengerIMWindows_FWD_DEFINED__
#define __IMessengerIMWindows_FWD_DEFINED__
typedef interface IMessengerIMWindows IMessengerIMWindows;
#endif 	/* __IMessengerIMWindows_FWD_DEFINED__ */


#ifndef __IMsgrServices_FWD_DEFINED__
#define __IMsgrServices_FWD_DEFINED__
typedef interface IMsgrServices IMsgrServices;
#endif 	/* __IMsgrServices_FWD_DEFINED__ */


#ifndef __IMsgrService_FWD_DEFINED__
#define __IMsgrService_FWD_DEFINED__
typedef interface IMsgrService IMsgrService;
#endif 	/* __IMsgrService_FWD_DEFINED__ */


#ifndef __IMsgrObject2_FWD_DEFINED__
#define __IMsgrObject2_FWD_DEFINED__
typedef interface IMsgrObject2 IMsgrObject2;
#endif 	/* __IMsgrObject2_FWD_DEFINED__ */


#ifndef __DMsgrObjectEvents_FWD_DEFINED__
#define __DMsgrObjectEvents_FWD_DEFINED__
typedef interface DMsgrObjectEvents DMsgrObjectEvents;
#endif 	/* __DMsgrObjectEvents_FWD_DEFINED__ */


#ifndef __DMsgrSPEvents_FWD_DEFINED__
#define __DMsgrSPEvents_FWD_DEFINED__
typedef interface DMsgrSPEvents DMsgrSPEvents;
#endif 	/* __DMsgrSPEvents_FWD_DEFINED__ */


#ifndef __IMsgrUser2_FWD_DEFINED__
#define __IMsgrUser2_FWD_DEFINED__
typedef interface IMsgrUser2 IMsgrUser2;
#endif 	/* __IMsgrUser2_FWD_DEFINED__ */


#ifndef __IMsgrSP_FWD_DEFINED__
#define __IMsgrSP_FWD_DEFINED__
typedef interface IMsgrSP IMsgrSP;
#endif 	/* __IMsgrSP_FWD_DEFINED__ */


#ifndef __IMsgrSP2_FWD_DEFINED__
#define __IMsgrSP2_FWD_DEFINED__
typedef interface IMsgrSP2 IMsgrSP2;
#endif 	/* __IMsgrSP2_FWD_DEFINED__ */


#ifndef __MsgrObject_FWD_DEFINED__
#define __MsgrObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsgrObject MsgrObject;
#else
typedef struct MsgrObject MsgrObject;
#endif /* __cplusplus */

#endif 	/* __MsgrObject_FWD_DEFINED__ */


#ifndef __MessengerApp_FWD_DEFINED__
#define __MessengerApp_FWD_DEFINED__

#ifdef __cplusplus
typedef class MessengerApp MessengerApp;
#else
typedef struct MessengerApp MessengerApp;
#endif /* __cplusplus */

#endif 	/* __MessengerApp_FWD_DEFINED__ */


#ifndef __DMessengerAppEvents_FWD_DEFINED__
#define __DMessengerAppEvents_FWD_DEFINED__
typedef interface DMessengerAppEvents DMessengerAppEvents;
#endif 	/* __DMessengerAppEvents_FWD_DEFINED__ */


#ifndef __IMsnMessengerIMWindow_FWD_DEFINED__
#define __IMsnMessengerIMWindow_FWD_DEFINED__
typedef interface IMsnMessengerIMWindow IMsnMessengerIMWindow;
#endif 	/* __IMsnMessengerIMWindow_FWD_DEFINED__ */


#ifndef __IMsnMessengerIMWindow2_FWD_DEFINED__
#define __IMsnMessengerIMWindow2_FWD_DEFINED__
typedef interface IMsnMessengerIMWindow2 IMsnMessengerIMWindow2;
#endif 	/* __IMsnMessengerIMWindow2_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "lock.h"
#include "sessions.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_mdisp_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1997 Microsoft Corporation. All Rights Reserved.
//
//  File: mdisp.h
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_mdisp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mdisp_0000_v0_0_s_ifspec;


#ifndef __Messenger_LIBRARY_DEFINED__
#define __Messenger_LIBRARY_DEFINED__

/* library Messenger */
/* [helpstring][version][uuid] */ 













typedef /* [public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0001
    {	MSTATE_UNKNOWN	= 0,
	MSTATE_OFFLINE	= 0x1,
	MSTATE_ONLINE	= 0x2,
	MSTATE_INVISIBLE	= 0x6,
	MSTATE_BUSY	= 0xa,
	MSTATE_BE_RIGHT_BACK	= 0xe,
	MSTATE_IDLE	= 0x12,
	MSTATE_AWAY	= 0x22,
	MSTATE_ON_THE_PHONE	= 0x32,
	MSTATE_OUT_TO_LUNCH	= 0x42,
	MSTATE_LOCAL_FINDING_SERVER	= 0x100,
	MSTATE_LOCAL_CONNECTING_TO_SERVER	= 0x200,
	MSTATE_LOCAL_SYNCHRONIZING_WITH_SERVER	= 0x300,
	MSTATE_LOCAL_DISCONNECTING_FROM_SERVER	= 0x400
    }	MSTATE;

typedef /* [public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0002
    {	MPROMPT_YES_IF_NOT_ALLOWED_OR_BLOCKED	= 0,
	MPROMPT_NO_ADD_TO_ALLOW	= 1
    }	MPROMPT;

typedef /* [public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0003
    {	MMSGPRIVACY_BLOCK_LIST_EXCLUDED	= 0,
	MMSGPRIVACY_ALLOW_LIST_ONLY	= 1
    }	MMSGPRIVACY;

typedef /* [public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0004
    {	MURLTYPE_CHANGE_PASSWORD	= 0,
	MURLTYPE_CHANGE_INFO	= 1,
	MURLTYPE_COMPOSE_EMAIL	= 2,
	MURLTYPE_GO_TO_EMAIL_INBOX	= 3,
	MURLTYPE_GO_TO_EMAIL_FOLDERS	= 4,
	MURLTYPE_MOBILE_SIGNUP	= 5,
	MURLTYPE_CHANGE_MOBILE_INFO	= 6,
	MURLTYPE_CHANGE_PROFILE	= 7,
	MURLTYPE_N2P_ACCOUNT	= 8,
	MURLTYPE_N2P_ADD_FUND	= 9
    }	MURLTYPE;

typedef /* [public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0005
    {	MLIST_CONTACT	= 0,
	MLIST_ALLOW	= 1,
	MLIST_BLOCK	= 2,
	MLIST_REVERSE	= 3
    }	MLIST;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0006
    {	MMSGTYPE_NO_RESULT	= 0,
	MMSGTYPE_ERRORS_ONLY	= 1,
	MMSGTYPE_ALL_RESULTS	= 2
    }	MMSGTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0007
    {	MUPDATE_OPTIONAL	= 0x1,
	MUPDATE_MANDATORY	= 0x2,
	MUPDATE_BRANDED	= 0x4
    }	MUPDATE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0008
    {	MIF_NONE	= 0,
	MIF_REQUEST_LAUNCH	= 0x1,
	MIF_REQUEST_IP	= 0x4,
	MIF_PROVIDE_IP	= 0x8
    }	MINVITE_FLAGS;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0009
    {	MPFLFIELD_COUNTRY	= 0,
	MPFLFIELD_POSTALCODE	= 1,
	MPFLFIELD_LANG_PREFERENCE	= 2,
	MPFLFIELD_GENDER	= 3,
	MPFLFIELD_PREFERRED_EMAIL	= 4,
	MPFLFIELD_NICKNAME	= 5,
	MPFLFIELD_ACCESSIBILITY	= 6,
	MPFLFIELD_WALLET	= 7,
	MPFLFIELD_DIRECTORY	= 8,
	MPFLFIELD_INETACCESS	= 9
    }	MPFLFIELD;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0010
    {	MSGR_E_CONNECT	= 0x81000300 + 0x1,
	MSGR_E_INVALID_SERVER_NAME	= 0x81000300 + 0x2,
	MSGR_E_INVALID_PASSWORD	= 0x81000300 + 0x3,
	MSGR_E_ALREADY_LOGGED_ON	= 0x81000300 + 0x4,
	MSGR_E_SERVER_VERSION	= 0x81000300 + 0x5,
	MSGR_E_LOGON_TIMEOUT	= 0x81000300 + 0x6,
	MSGR_E_LIST_FULL	= 0x81000300 + 0x7,
	MSGR_E_AI_REJECT	= 0x81000300 + 0x8,
	MSGR_E_AI_REJECT_NOT_INST	= 0x81000300 + 0x9,
	MSGR_E_USER_NOT_FOUND	= 0x81000300 + 0xa,
	MSGR_E_ALREADY_IN_LIST	= 0x81000300 + 0xb,
	MSGR_E_DISCONNECTED	= 0x81000300 + 0xc,
	MSGR_E_UNEXPECTED	= 0x81000300 + 0xd,
	MSGR_E_SERVER_TOO_BUSY	= 0x81000300 + 0xe,
	MSGR_E_INVALID_AUTH_PACKAGES	= 0x81000300 + 0xf,
	MSGR_E_NEWER_CLIENT_AVAILABLE	= 0x81000300 + 0x10,
	MSGR_E_AI_TIMEOUT	= 0x81000300 + 0x11,
	MSGR_E_CANCEL	= 0x81000300 + 0x12,
	MSGR_E_TOO_MANY_MATCHES	= 0x81000300 + 0x13,
	MSGR_E_SERVER_UNAVAILABLE	= 0x81000300 + 0x14,
	MSGR_E_LOGON_UI_ACTIVE	= 0x81000300 + 0x15,
	MSGR_E_OPTION_UI_ACTIVE	= 0x81000300 + 0x16,
	MSGR_E_CONTACT_UI_ACTIVE	= 0x81000300 + 0x17,
	MSGR_E_PRIMARY_SERVICE_NOT_LOGGED_ON	= 0x81000300 + 0x18,
	MSGR_E_LOGGED_ON	= 0x81000300 + 0x19,
	MSGR_E_CONNECT_PROXY	= 0x81000300 + 0x1a,
	MSGR_E_PROXY_AUTH	= 0x81000300 + 0x1b,
	MSGR_E_PROXY_AUTH_TYPE	= 0x81000300 + 0x1c,
	MSGR_E_INVALID_PROXY_NAME	= 0x81000300 + 0x1d,
	MSGR_E_NOT_LOGGED_ON	= 0x81000300 + 0x1e,
	MSGR_E_NOT_PRIMARY_SERVICE	= 0x81000300 + 0x20,
	MSGR_E_TOO_MANY_SESSIONS	= 0x81000300 + 0x21,
	MSGR_E_TOO_MANY_MESSAGES	= 0x81000300 + 0x22,
	MSGR_E_REMOTE_LOGIN	= 0x81000300 + 0x23,
	MSGR_E_INVALID_FRIENDLY_NAME	= 0x81000300 + 0x24,
	MSGR_E_SESSION_FULL	= 0x81000300 + 0x25,
	MSGR_E_NOT_ALLOWING_NEW_USERS	= 0x81000300 + 0x26,
	MSGR_E_INVALID_DOMAIN	= 0x81000300 + 0x27,
	MSGR_E_TCP_ERROR	= 0x81000300 + 0x28,
	MSGR_E_SESSION_TIMEOUT	= 0x81000300 + 0x29,
	MSGR_E_MULTIPOINT_SESSION_BEGIN_TIMEOUT	= 0x81000300 + 0x2a,
	MSGR_E_MULTIPOINT_SESSION_END_TIMEOUT	= 0x81000300 + 0x2b,
	MSGR_E_REVERSE_LIST_FULL	= 0x81000300 + 0x2c,
	MSGR_E_SERVER_ERROR	= 0x81000300 + 0x2d,
	MSGR_E_SYSTEM_CONFIG	= 0x81000300 + 0x2e,
	MSGR_E_NO_DIRECTORY	= 0x81000300 + 0x2f,
	MSGR_E_RETRY_SET	= 0x81000300 + 0x30,
	MSGR_E_CHILD_WITHOUT_CONSENT	= 0x81000300 + 0x31,
	MSGR_E_USER_CANCELLED	= 0x81000300 + 0x32,
	MSGR_E_CANCEL_BEFORE_CONNECT	= 0x81000300 + 0x33,
	MSGR_E_VOICE_IM_TIMEOUT	= 0x81000300 + 0x34,
	MSGR_E_NOT_ACCEPTING_PAGES	= 0x81000300 + 0x35,
	MSGR_E_EMAIL_PASSPORT_NOT_VALIDATED	= 0x81000300 + 0x36,
	MSGR_E_AUDIO_UI_ACTIVE	= 0x81000300 + 0x37,
	MSGR_E_NO_HARDWARE	= 0x81000300 + 0x38,
	MSGR_E_PAGING_UNAVAILABLE	= 0x81000300 + 0x39,
	MSGR_E_PHONE_INVALID_NUMBER	= 0x81000300 + 0x3a,
	MSGR_E_PHONE_NO_FUNDS	= 0x81000300 + 0x3b,
	MSGR_E_VOICE_NO_ANSWER	= 0x81000300 + 0x3c,
	MSGR_E_VOICE_WAVEIN_DEVICE	= 0x81000300 + 0x3d,
	MSGR_E_FT_TIMEOUT	= 0x81000300 + 0x3e,
	MSGR_E_MESSAGE_TOO_LONG	= 0x81000300 + 0x3f,
	MSGR_E_VOICE_FIREWALL	= 0x81000300 + 0x40,
	MSGR_E_VOICE_NETCONN	= 0x81000300 + 0x41,
	MSGR_E_PHONE_CIRCUITS_BUSY	= 0x81000300 + 0x42,
	MSGR_E_SERVER_PROTOCOL	= 0x81000300 + 0x43,
	MSGR_E_UNAVAILABLE_VIA_HTTP	= 0x81000300 + 0x44,
	MSGR_E_PHONE_INVALID_PIN	= 0x81000300 + 0x45,
	MSGR_E_PHONE_PINPROCEED_TIMEOUT	= 0x81000300 + 0x46,
	MSGR_E_SERVER_SHUTDOWN	= 0x81000300 + 0x47,
	MSGR_E_CLIENT_DISALLOWED	= 0x81000300 + 0x48,
	MSGR_E_PHONE_CALL_NOT_COMPLETE	= 0x81000300 + 0x49,
	MSGR_S_ALREADY_IN_THE_MODE	= 0x1000300 + 0x1,
	MSGR_S_TRANSFER_SEND_BEGUN	= 0x1000300 + 0x2,
	MSGR_S_TRANSFER_SEND_FINISHED	= 0x1000300 + 0x3,
	MSGR_S_TRANSFER_RECEIVE_BEGUN	= 0x1000300 + 0x4,
	MSGR_S_TRANSFER_RECEIVE_FINISHED	= 0x1000300 + 0x5,
	MSGR_E_FAIL	= 0x80004005,
	MSGR_S_OK	= 0
    }	MSGRConstants;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0011
    {	SSTATE_DISCONNECTED	= 0,
	SSTATE_CONNECTING	= 1,
	SSTATE_CONNECTED	= 2,
	SSTATE_DISCONNECTING	= 3,
	SSTATE_ERROR	= 4
    }	SSTATE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0012
    {	MFOLDER_INBOX	= 0,
	MFOLDER_ALL_OTHER_FOLDERS	= 1
    }	MFOLDER;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0013
    {	MLOPT_PROXY_STATE	= 0,
	MLOPT_PROXY_TYPE	= 1,
	MLOPT_SOCKS4_SERVER	= 2,
	MLOPT_SOCKS5_SERVER	= 3,
	MLOPT_HTTPS_SERVER	= 4,
	MLOPT_SOCKS4_PORT	= 5,
	MLOPT_SOCKS5_PORT	= 6,
	MLOPT_HTTPS_PORT	= 7,
	MLOPT_SOCKS5_USERNAME	= 8,
	MLOPT_SOCKS5_PASSWORD	= 9,
	MLOPT_SERVER_NAME	= 10,
	MLOPT_ENABLE_IDLE_DETECT	= 11,
	MLOPT_IDLE_THRESHOLD	= 12,
	MLOPT_IDLE_DETECTABLE	= 13,
	MLOPT_SS_DETECTABLE	= 14,
	MLOPT_HTTP_SERVER	= 15,
	MLOPT_HTTP_PORT	= 16
    }	MLOCALOPTION;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0014
    {	MUSERPROP_INVALID_PROPERTY	= -1,
	MUSERPROP_HOME_PHONE_NUMBER	= 0,
	MUSERPROP_WORK_PHONE_NUMBER	= 1,
	MUSERPROP_MOBILE_PHONE_NUMBER	= 2,
	MUSERPROP_PAGES_ALLOWED	= 3,
	MUSERPROP_NUMBER_OF_PUBLIC_PROPERTIES	= 4,
	MUSERPROP_PAGES_ENABLED	= 4,
	MUSERPROP_NUMBER_OF_PROPERTIES	= MUSERPROP_PAGES_ENABLED + 1
    }	MUSERPROPERTY;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0015
    {	MLOPT_MAX_SERVICE_STRING	= 255,
	MLOPT_MAX_PROXY_STRING	= 255,
	MLOPT_MAX_PORT_NUMBER	= 65535,
	MLOPT_MAX_IDLE_THRESHOLD	= 999
    }	MLOCALOPTION_LIMITS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0016
    {	MPROXYTYPE_NO_PROXY	= 0,
	MPROXYTYPE_SOCKS4	= 1,
	MPROXYTYPE_SOCKS5	= 2,
	MPROXYTYPE_HTTPS	= 3,
	MPROXYTYPE_HTTP	= 4
    }	MPROXYTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0017
    {	MCONNECTIONTYPE_DISCONNECTED	= 0,
	MCONNECTIONTYPE_DIRECT	= 1,
	MCONNECTIONTYPE_BROWSER_PROXY	= 2,
	MCONNECTIONTYPE_HTTP_PROXY	= 3,
	MCONNECTIONTYPE_SOCKS_PROXY	= 4
    }	MCONNECTIONTYPE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0018
    {	MOPTDLG_GENERAL_PAGE	= 0,
	MOPTDLG_PRIVACY_PAGE	= 1,
	MOPTDLG_EXCHANGE_PAGE	= 2,
	MOPTDLG_ACCOUNTS_PAGE	= 3,
	MOPTDLG_CONNECTION_PAGE	= 4,
	MOPTDLG_PREFERENCES_PAGE	= 5,
	MOPTDLG_SERVICES_PAGE	= 6,
	MOPTDLG_PHONE_PAGE	= 7
    }	MOPTDLGPAGE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0019
    {	MSF_PRIMARY	= 0x1,
	MSF_APP_INVITE	= 0x2,
	MSF_MULTI_IM	= 0x4,
	MSF_BLOCKING	= 0x8,
	MSF_UNAME_IN_EMAIL_FMT	= 0x10,
	MSF_LOCAL_LISTS	= 0x20,
	MSF_FIND_USER	= 0x40,
	MSF_INVITE_MAIL	= 0x80,
	MSF_INTERNET	= 0x100,
	MSF_NO_ALLOW_LIST	= 0x200
    }	MSERVICE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0020
    {	MFT_SAVE_PASSWORD	= 0,
	MFT_DONT_SAVE_PASSWORD	= 0x1,
	MFT_OVERWRITE_EXISTING	= 0x2
    }	MFIRSTTIME_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0021
    {	MSS_LOGGED_ON	= 0,
	MSS_NOT_LOGGED_ON	= 1,
	MSS_LOGGING_ON	= 2,
	MSS_LOGGING_OFF	= 3
    }	MSVCSTATUS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0000_0022
    {	MFTF_SENDING	= 0x4,
	MFTF_RECEIVING	= 0x8,
	MFTF_CONNECTING	= 0x10,
	MFTF_CONNECTED	= 0x20,
	MFTF_DISCONNECTED	= 0x40
    }	MFILETRANSFER_FLAGS;


EXTERN_C const IID LIBID_Messenger;

#ifndef __IMsgrObject_INTERFACE_DEFINED__
#define __IMsgrObject_INTERFACE_DEFINED__

/* interface IMsgrObject */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("218CB451-20B6-11d2-8E17-0000F803A446")
    IMsgrObject : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUser( 
            /* [in] */ BSTR bstrLogonName,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Logon( 
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Logoff( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_List( 
            /* [in] */ MLIST mList,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalLogonName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalFriendlyName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocalState( 
            /* [in] */ MSTATE mState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LocalState( 
            /* [retval][out] */ MSTATE __RPC_FAR *pmState) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MessagePrivacy( 
            /* [in] */ MMSGPRIVACY mmpSetting) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MessagePrivacy( 
            /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Prompt( 
            /* [in] */ MPROMPT mpSetting) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Prompt( 
            /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendAppInvite( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ BSTR bstrAppGUID,
            /* [in] */ BSTR bstrAppName,
            /* [in] */ BSTR bstrAppURL,
            /* [in] */ LONG lInviteType,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendAppInviteAccept( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG lInviteType,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendAppInviteCancel( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG hrReason,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocalOption( 
            /* [in] */ MLOCALOPTION option,
            /* [in] */ VARIANT vSetting) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LocalOption( 
            /* [in] */ MLOCALOPTION option,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSetting) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE FindUser( 
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [in] */ BSTR bstrCity,
            /* [in] */ BSTR bstrState,
            /* [in] */ BSTR bstrCountry,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendInviteMail( 
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestURLPost( 
            /* [in] */ MURLTYPE muType,
            /* [in] */ BSTR bstrAdditionalInfo,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IMSessions( 
            /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateIMSession( 
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SessionRequestAccept( 
            /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
            /* [in] */ long hrReason) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SessionRequestCancel( 
            /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
            /* [in] */ long hrReason) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Services( 
            /* [retval][out] */ IMsgrServices __RPC_FAR *__RPC_FAR *ppServices) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UnreadEmail( 
            /* [in] */ MFOLDER mFolder,
            /* [retval][out] */ long __RPC_FAR *pcUnreadEmail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateUser )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ BSTR bstrLogonName,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logon )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logoff )( 
            IMsgrObject __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_List )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MLIST mList,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalLogonName )( 
            IMsgrObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalFriendlyName )( 
            IMsgrObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalState )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MSTATE mState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalState )( 
            IMsgrObject __RPC_FAR * This,
            /* [retval][out] */ MSTATE __RPC_FAR *pmState);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessagePrivacy )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MMSGPRIVACY mmpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessagePrivacy )( 
            IMsgrObject __RPC_FAR * This,
            /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Prompt )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MPROMPT mpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Prompt )( 
            IMsgrObject __RPC_FAR * This,
            /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendAppInvite )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ BSTR bstrAppGUID,
            /* [in] */ BSTR bstrAppName,
            /* [in] */ BSTR bstrAppURL,
            /* [in] */ LONG lInviteType,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendAppInviteAccept )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG lInviteType,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendAppInviteCancel )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG hrReason,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalOption )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MLOCALOPTION option,
            /* [in] */ VARIANT vSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalOption )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MLOCALOPTION option,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSetting);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindUser )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [in] */ BSTR bstrCity,
            /* [in] */ BSTR bstrState,
            /* [in] */ BSTR bstrCountry,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendInviteMail )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [in] */ BSTR bstrAdditionalInfo,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMSessions )( 
            IMsgrObject __RPC_FAR * This,
            /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIMSession )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SessionRequestAccept )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
            /* [in] */ long hrReason);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SessionRequestCancel )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
            /* [in] */ long hrReason);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Services )( 
            IMsgrObject __RPC_FAR * This,
            /* [retval][out] */ IMsgrServices __RPC_FAR *__RPC_FAR *ppServices);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UnreadEmail )( 
            IMsgrObject __RPC_FAR * This,
            /* [in] */ MFOLDER mFolder,
            /* [retval][out] */ long __RPC_FAR *pcUnreadEmail);
        
        END_INTERFACE
    } IMsgrObjectVtbl;

    interface IMsgrObject
    {
        CONST_VTBL struct IMsgrObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrObject_CreateUser(This,bstrLogonName,pService,ppUser)	\
    (This)->lpVtbl -> CreateUser(This,bstrLogonName,pService,ppUser)

#define IMsgrObject_Logon(This,bstrUser,bstrPassword,pService)	\
    (This)->lpVtbl -> Logon(This,bstrUser,bstrPassword,pService)

#define IMsgrObject_Logoff(This)	\
    (This)->lpVtbl -> Logoff(This)

#define IMsgrObject_get_List(This,mList,ppUsers)	\
    (This)->lpVtbl -> get_List(This,mList,ppUsers)

#define IMsgrObject_get_LocalLogonName(This,pbstrName)	\
    (This)->lpVtbl -> get_LocalLogonName(This,pbstrName)

#define IMsgrObject_get_LocalFriendlyName(This,pbstrName)	\
    (This)->lpVtbl -> get_LocalFriendlyName(This,pbstrName)

#define IMsgrObject_put_LocalState(This,mState)	\
    (This)->lpVtbl -> put_LocalState(This,mState)

#define IMsgrObject_get_LocalState(This,pmState)	\
    (This)->lpVtbl -> get_LocalState(This,pmState)

#define IMsgrObject_put_MessagePrivacy(This,mmpSetting)	\
    (This)->lpVtbl -> put_MessagePrivacy(This,mmpSetting)

#define IMsgrObject_get_MessagePrivacy(This,pmmpSetting)	\
    (This)->lpVtbl -> get_MessagePrivacy(This,pmmpSetting)

#define IMsgrObject_put_Prompt(This,mpSetting)	\
    (This)->lpVtbl -> put_Prompt(This,mpSetting)

#define IMsgrObject_get_Prompt(This,pmpSetting)	\
    (This)->lpVtbl -> get_Prompt(This,pmpSetting)

#define IMsgrObject_SendAppInvite(This,pUser,lCookie,bstrAppGUID,bstrAppName,bstrAppURL,lInviteType,mmtType,plCookie)	\
    (This)->lpVtbl -> SendAppInvite(This,pUser,lCookie,bstrAppGUID,bstrAppName,bstrAppURL,lInviteType,mmtType,plCookie)

#define IMsgrObject_SendAppInviteAccept(This,pUser,lCookie,lInviteType,mmtType,plCookie)	\
    (This)->lpVtbl -> SendAppInviteAccept(This,pUser,lCookie,lInviteType,mmtType,plCookie)

#define IMsgrObject_SendAppInviteCancel(This,pUser,lCookie,hrReason,mmtType,plCookie)	\
    (This)->lpVtbl -> SendAppInviteCancel(This,pUser,lCookie,hrReason,mmtType,plCookie)

#define IMsgrObject_put_LocalOption(This,option,vSetting)	\
    (This)->lpVtbl -> put_LocalOption(This,option,vSetting)

#define IMsgrObject_get_LocalOption(This,option,pvSetting)	\
    (This)->lpVtbl -> get_LocalOption(This,option,pvSetting)

#define IMsgrObject_FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)	\
    (This)->lpVtbl -> FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)

#define IMsgrObject_SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)	\
    (This)->lpVtbl -> SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)

#define IMsgrObject_RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)

#define IMsgrObject_get_IMSessions(This,ppIMSessions)	\
    (This)->lpVtbl -> get_IMSessions(This,ppIMSessions)

#define IMsgrObject_CreateIMSession(This,vUser,ppIMSession)	\
    (This)->lpVtbl -> CreateIMSession(This,vUser,ppIMSession)

#define IMsgrObject_SessionRequestAccept(This,pIMsgrIMSession,hrReason)	\
    (This)->lpVtbl -> SessionRequestAccept(This,pIMsgrIMSession,hrReason)

#define IMsgrObject_SessionRequestCancel(This,pIMsgrIMSession,hrReason)	\
    (This)->lpVtbl -> SessionRequestCancel(This,pIMsgrIMSession,hrReason)

#define IMsgrObject_get_Services(This,ppServices)	\
    (This)->lpVtbl -> get_Services(This,ppServices)

#define IMsgrObject_get_UnreadEmail(This,mFolder,pcUnreadEmail)	\
    (This)->lpVtbl -> get_UnreadEmail(This,mFolder,pcUnreadEmail)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_CreateUser_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ BSTR bstrLogonName,
    /* [in] */ IMsgrService __RPC_FAR *pService,
    /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);


void __RPC_STUB IMsgrObject_CreateUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_Logon_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ BSTR bstrUser,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ IMsgrService __RPC_FAR *pService);


void __RPC_STUB IMsgrObject_Logon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_Logoff_Proxy( 
    IMsgrObject __RPC_FAR * This);


void __RPC_STUB IMsgrObject_Logoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_List_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MLIST mList,
    /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);


void __RPC_STUB IMsgrObject_get_List_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_LocalLogonName_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IMsgrObject_get_LocalLogonName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_LocalFriendlyName_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IMsgrObject_get_LocalFriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrObject_put_LocalState_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MSTATE mState);


void __RPC_STUB IMsgrObject_put_LocalState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_LocalState_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [retval][out] */ MSTATE __RPC_FAR *pmState);


void __RPC_STUB IMsgrObject_get_LocalState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrObject_put_MessagePrivacy_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MMSGPRIVACY mmpSetting);


void __RPC_STUB IMsgrObject_put_MessagePrivacy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_MessagePrivacy_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting);


void __RPC_STUB IMsgrObject_get_MessagePrivacy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrObject_put_Prompt_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MPROMPT mpSetting);


void __RPC_STUB IMsgrObject_put_Prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_Prompt_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting);


void __RPC_STUB IMsgrObject_get_Prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_SendAppInvite_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ LONG lCookie,
    /* [in] */ BSTR bstrAppGUID,
    /* [in] */ BSTR bstrAppName,
    /* [in] */ BSTR bstrAppURL,
    /* [in] */ LONG lInviteType,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject_SendAppInvite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_SendAppInviteAccept_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ LONG lCookie,
    /* [in] */ LONG lInviteType,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject_SendAppInviteAccept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_SendAppInviteCancel_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ LONG lCookie,
    /* [in] */ LONG hrReason,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject_SendAppInviteCancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrObject_put_LocalOption_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MLOCALOPTION option,
    /* [in] */ VARIANT vSetting);


void __RPC_STUB IMsgrObject_put_LocalOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_LocalOption_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MLOCALOPTION option,
    /* [retval][out] */ VARIANT __RPC_FAR *pvSetting);


void __RPC_STUB IMsgrObject_get_LocalOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_FindUser_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ BSTR bstrFirstName,
    /* [in] */ BSTR bstrLastName,
    /* [in] */ BSTR bstrCity,
    /* [in] */ BSTR bstrState,
    /* [in] */ BSTR bstrCountry,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject_FindUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_SendInviteMail_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress,
    /* [in] */ LONG lFindCookie,
    /* [in] */ LONG lFindIndex,
    /* [in] */ LONG lLCID,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject_SendInviteMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_RequestURLPost_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MURLTYPE muType,
    /* [in] */ BSTR bstrAdditionalInfo,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject_RequestURLPost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_IMSessions_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions);


void __RPC_STUB IMsgrObject_get_IMSessions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_CreateIMSession_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ VARIANT vUser,
    /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);


void __RPC_STUB IMsgrObject_CreateIMSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_SessionRequestAccept_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
    /* [in] */ long hrReason);


void __RPC_STUB IMsgrObject_SessionRequestAccept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject_SessionRequestCancel_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
    /* [in] */ long hrReason);


void __RPC_STUB IMsgrObject_SessionRequestCancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_Services_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [retval][out] */ IMsgrServices __RPC_FAR *__RPC_FAR *ppServices);


void __RPC_STUB IMsgrObject_get_Services_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject_get_UnreadEmail_Proxy( 
    IMsgrObject __RPC_FAR * This,
    /* [in] */ MFOLDER mFolder,
    /* [retval][out] */ long __RPC_FAR *pcUnreadEmail);


void __RPC_STUB IMsgrObject_get_UnreadEmail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrObject_INTERFACE_DEFINED__ */


#ifndef __IMsgrUser_INTERFACE_DEFINED__
#define __IMsgrUser_INTERFACE_DEFINED__

/* interface IMsgrUser */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("218CB453-20B6-11d2-8E17-0000F803A446")
    IMsgrUser : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FriendlyName( 
            /* [in] */ BSTR bstrFriendlyName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFriendlyName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEmailAddress) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ MSTATE __RPC_FAR *pmState) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LogonName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogonName) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendText( 
            /* [in] */ BSTR bstrMsgHeader,
            /* [in] */ BSTR bstrMsgText,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Service( 
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrUser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrUser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrUser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrUser __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrUser __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrUser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrUser __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FriendlyName )( 
            IMsgrUser __RPC_FAR * This,
            /* [in] */ BSTR bstrFriendlyName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FriendlyName )( 
            IMsgrUser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFriendlyName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddress )( 
            IMsgrUser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEmailAddress);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            IMsgrUser __RPC_FAR * This,
            /* [retval][out] */ MSTATE __RPC_FAR *pmState);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogonName )( 
            IMsgrUser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogonName);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendText )( 
            IMsgrUser __RPC_FAR * This,
            /* [in] */ BSTR bstrMsgHeader,
            /* [in] */ BSTR bstrMsgText,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Service )( 
            IMsgrUser __RPC_FAR * This,
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);
        
        END_INTERFACE
    } IMsgrUserVtbl;

    interface IMsgrUser
    {
        CONST_VTBL struct IMsgrUserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrUser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrUser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrUser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrUser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrUser_put_FriendlyName(This,bstrFriendlyName)	\
    (This)->lpVtbl -> put_FriendlyName(This,bstrFriendlyName)

#define IMsgrUser_get_FriendlyName(This,pbstrFriendlyName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrFriendlyName)

#define IMsgrUser_get_EmailAddress(This,pbstrEmailAddress)	\
    (This)->lpVtbl -> get_EmailAddress(This,pbstrEmailAddress)

#define IMsgrUser_get_State(This,pmState)	\
    (This)->lpVtbl -> get_State(This,pmState)

#define IMsgrUser_get_LogonName(This,pbstrLogonName)	\
    (This)->lpVtbl -> get_LogonName(This,pbstrLogonName)

#define IMsgrUser_SendText(This,bstrMsgHeader,bstrMsgText,mmtType,plCookie)	\
    (This)->lpVtbl -> SendText(This,bstrMsgHeader,bstrMsgText,mmtType,plCookie)

#define IMsgrUser_get_Service(This,ppService)	\
    (This)->lpVtbl -> get_Service(This,ppService)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrUser_put_FriendlyName_Proxy( 
    IMsgrUser __RPC_FAR * This,
    /* [in] */ BSTR bstrFriendlyName);


void __RPC_STUB IMsgrUser_put_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrUser_get_FriendlyName_Proxy( 
    IMsgrUser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFriendlyName);


void __RPC_STUB IMsgrUser_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrUser_get_EmailAddress_Proxy( 
    IMsgrUser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEmailAddress);


void __RPC_STUB IMsgrUser_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrUser_get_State_Proxy( 
    IMsgrUser __RPC_FAR * This,
    /* [retval][out] */ MSTATE __RPC_FAR *pmState);


void __RPC_STUB IMsgrUser_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrUser_get_LogonName_Proxy( 
    IMsgrUser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrLogonName);


void __RPC_STUB IMsgrUser_get_LogonName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrUser_SendText_Proxy( 
    IMsgrUser __RPC_FAR * This,
    /* [in] */ BSTR bstrMsgHeader,
    /* [in] */ BSTR bstrMsgText,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrUser_SendText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrUser_get_Service_Proxy( 
    IMsgrUser __RPC_FAR * This,
    /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);


void __RPC_STUB IMsgrUser_get_Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrUser_INTERFACE_DEFINED__ */


#ifndef __IMsgrUsers_INTERFACE_DEFINED__
#define __IMsgrUsers_INTERFACE_DEFINED__

/* interface IMsgrUsers */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrUsers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("218CB454-20B6-11d2-8E17-0000F803A446")
    IMsgrUsers : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pcUsers) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long Index,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser) = 0;
        
        virtual /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrUsersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrUsers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrUsers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrUsers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrUsers __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrUsers __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrUsers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrUsers __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsgrUsers __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcUsers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IMsgrUsers __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IMsgrUsers __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IMsgrUsers __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser);
        
        /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsgrUsers __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IMsgrUsersVtbl;

    interface IMsgrUsers
    {
        CONST_VTBL struct IMsgrUsersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrUsers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrUsers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrUsers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrUsers_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrUsers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrUsers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrUsers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrUsers_get_Count(This,pcUsers)	\
    (This)->lpVtbl -> get_Count(This,pcUsers)

#define IMsgrUsers_Item(This,Index,ppUser)	\
    (This)->lpVtbl -> Item(This,Index,ppUser)

#define IMsgrUsers_Add(This,pUser)	\
    (This)->lpVtbl -> Add(This,pUser)

#define IMsgrUsers_Remove(This,pUser)	\
    (This)->lpVtbl -> Remove(This,pUser)

#define IMsgrUsers_get__NewEnum(This,ppUnknown)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrUsers_get_Count_Proxy( 
    IMsgrUsers __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcUsers);


void __RPC_STUB IMsgrUsers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrUsers_Item_Proxy( 
    IMsgrUsers __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);


void __RPC_STUB IMsgrUsers_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrUsers_Add_Proxy( 
    IMsgrUsers __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser);


void __RPC_STUB IMsgrUsers_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrUsers_Remove_Proxy( 
    IMsgrUsers __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser);


void __RPC_STUB IMsgrUsers_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IMsgrUsers_get__NewEnum_Proxy( 
    IMsgrUsers __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IMsgrUsers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrUsers_INTERFACE_DEFINED__ */


#ifndef __IMsgrIMSession_INTERFACE_DEFINED__
#define __IMsgrIMSession_INTERFACE_DEFINED__

/* interface IMsgrIMSession */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrIMSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82e11592-20f5-11d2-91ad-0000f81fefc9")
    IMsgrIMSession : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Members( 
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ SSTATE __RPC_FAR *psState) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Service( 
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Invitees( 
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LeaveSession( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InviteUser( 
            /* [in] */ VARIANT vUser) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendText( 
            /* [in] */ BSTR bstrMsgHeader,
            /* [in] */ BSTR bstrMsgText,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrIMSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrIMSession __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrIMSession __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Members )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [retval][out] */ SSTATE __RPC_FAR *psState);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Service )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Invitees )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LeaveSession )( 
            IMsgrIMSession __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InviteUser )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [in] */ VARIANT vUser);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendText )( 
            IMsgrIMSession __RPC_FAR * This,
            /* [in] */ BSTR bstrMsgHeader,
            /* [in] */ BSTR bstrMsgText,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        END_INTERFACE
    } IMsgrIMSessionVtbl;

    interface IMsgrIMSession
    {
        CONST_VTBL struct IMsgrIMSessionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrIMSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrIMSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrIMSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrIMSession_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrIMSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrIMSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrIMSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrIMSession_get_Members(This,ppUsers)	\
    (This)->lpVtbl -> get_Members(This,ppUsers)

#define IMsgrIMSession_get_State(This,psState)	\
    (This)->lpVtbl -> get_State(This,psState)

#define IMsgrIMSession_get_Service(This,ppService)	\
    (This)->lpVtbl -> get_Service(This,ppService)

#define IMsgrIMSession_get_Invitees(This,ppUsers)	\
    (This)->lpVtbl -> get_Invitees(This,ppUsers)

#define IMsgrIMSession_LeaveSession(This)	\
    (This)->lpVtbl -> LeaveSession(This)

#define IMsgrIMSession_InviteUser(This,vUser)	\
    (This)->lpVtbl -> InviteUser(This,vUser)

#define IMsgrIMSession_SendText(This,bstrMsgHeader,bstrMsgText,mmtType,plCookie)	\
    (This)->lpVtbl -> SendText(This,bstrMsgHeader,bstrMsgText,mmtType,plCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrIMSession_get_Members_Proxy( 
    IMsgrIMSession __RPC_FAR * This,
    /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);


void __RPC_STUB IMsgrIMSession_get_Members_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrIMSession_get_State_Proxy( 
    IMsgrIMSession __RPC_FAR * This,
    /* [retval][out] */ SSTATE __RPC_FAR *psState);


void __RPC_STUB IMsgrIMSession_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrIMSession_get_Service_Proxy( 
    IMsgrIMSession __RPC_FAR * This,
    /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);


void __RPC_STUB IMsgrIMSession_get_Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrIMSession_get_Invitees_Proxy( 
    IMsgrIMSession __RPC_FAR * This,
    /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);


void __RPC_STUB IMsgrIMSession_get_Invitees_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrIMSession_LeaveSession_Proxy( 
    IMsgrIMSession __RPC_FAR * This);


void __RPC_STUB IMsgrIMSession_LeaveSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrIMSession_InviteUser_Proxy( 
    IMsgrIMSession __RPC_FAR * This,
    /* [in] */ VARIANT vUser);


void __RPC_STUB IMsgrIMSession_InviteUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrIMSession_SendText_Proxy( 
    IMsgrIMSession __RPC_FAR * This,
    /* [in] */ BSTR bstrMsgHeader,
    /* [in] */ BSTR bstrMsgText,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrIMSession_SendText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrIMSession_INTERFACE_DEFINED__ */


#ifndef __IMsgrIMSessions_INTERFACE_DEFINED__
#define __IMsgrIMSessions_INTERFACE_DEFINED__

/* interface IMsgrIMSessions */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrIMSessions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6fd143e6-20a5-11d2-91ad-0000f81fefc9")
    IMsgrIMSessions : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pcSessions) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long Index,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession) = 0;
        
        virtual /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrIMSessionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrIMSessions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrIMSessions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcSessions);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);
        
        /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsgrIMSessions __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IMsgrIMSessionsVtbl;

    interface IMsgrIMSessions
    {
        CONST_VTBL struct IMsgrIMSessionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrIMSessions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrIMSessions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrIMSessions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrIMSessions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrIMSessions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrIMSessions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrIMSessions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrIMSessions_get_Count(This,pcSessions)	\
    (This)->lpVtbl -> get_Count(This,pcSessions)

#define IMsgrIMSessions_Item(This,Index,ppIMSession)	\
    (This)->lpVtbl -> Item(This,Index,ppIMSession)

#define IMsgrIMSessions_get__NewEnum(This,ppUnknown)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrIMSessions_get_Count_Proxy( 
    IMsgrIMSessions __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcSessions);


void __RPC_STUB IMsgrIMSessions_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrIMSessions_Item_Proxy( 
    IMsgrIMSessions __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);


void __RPC_STUB IMsgrIMSessions_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IMsgrIMSessions_get__NewEnum_Proxy( 
    IMsgrIMSessions __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IMsgrIMSessions_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrIMSessions_INTERFACE_DEFINED__ */


#ifndef __IMessengerApp_INTERFACE_DEFINED__
#define __IMessengerApp_INTERFACE_DEFINED__

/* interface IMessengerApp */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMessengerApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3A614DD-ABE0-11d2-A441-00C04F795683")
    IMessengerApp : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Quit( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFullName) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchLogonUI( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchOptionsUI( 
            /* [in] */ MOPTDLGPAGE mOptDlgPage) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchAddContactUI( 
            /* [in] */ BSTR bstrEMail) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchFindContactUI( 
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [optional][in] */ VARIANT vbstrCity,
            /* [optional][in] */ VARIANT vbstrState,
            /* [optional][in] */ VARIANT vbstrCountry) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchIMUI( 
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IMWindows( 
            /* [retval][out] */ IMessengerIMWindows __RPC_FAR *__RPC_FAR *ppIMWindows) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ToolBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ToolBar( 
            /* [in] */ VARIANT_BOOL BoolToolBar) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StatusBar( 
            /* [in] */ VARIANT_BOOL BoolStatusBar) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StatusText( 
            /* [in] */ BSTR bstrStatusText) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HWND( 
            /* [retval][out] */ long __RPC_FAR *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *plLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long lLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *plTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long lTop) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *plWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long lWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *plHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long lHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL BoolVisible) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE AutoLogon( void) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FirstTimeCredentials( 
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_CachedPassword( 
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ VARIANT_BOOL BoolSavePassword) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestURLPost( 
            /* [in] */ MURLTYPE muType,
            /* [optional][in] */ VARIANT vbstrAdditionalInfo) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TaskbarIcon( 
            /* [in] */ VARIANT_BOOL BoolVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TaskbarIcon( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessengerAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessengerApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessengerApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMessengerApp __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IMessengerApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFullName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPath);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchLogonUI )( 
            IMessengerApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchOptionsUI )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ MOPTDLGPAGE mOptDlgPage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchAddContactUI )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ BSTR bstrEMail);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchFindContactUI )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [optional][in] */ VARIANT vbstrCity,
            /* [optional][in] */ VARIANT vbstrState,
            /* [optional][in] */ VARIANT vbstrCountry);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchIMUI )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMWindows )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ IMessengerIMWindows __RPC_FAR *__RPC_FAR *ppIMWindows);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolToolBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolStatusBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ BSTR bstrStatusText);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ long lLeft);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ long lTop);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ long lWidth);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ long lHeight);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolVisible);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoLogon )( 
            IMessengerApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FirstTimeCredentials )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ long lFlags);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CachedPassword )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ VARIANT_BOOL BoolSavePassword);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [optional][in] */ VARIANT vbstrAdditionalInfo);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TaskbarIcon )( 
            IMessengerApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolVisible);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TaskbarIcon )( 
            IMessengerApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);
        
        END_INTERFACE
    } IMessengerAppVtbl;

    interface IMessengerApp
    {
        CONST_VTBL struct IMessengerAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessengerApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessengerApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessengerApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessengerApp_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMessengerApp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMessengerApp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMessengerApp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMessengerApp_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IMessengerApp_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IMessengerApp_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define IMessengerApp_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IMessengerApp_get_FullName(This,pbstrFullName)	\
    (This)->lpVtbl -> get_FullName(This,pbstrFullName)

#define IMessengerApp_get_Path(This,pbstrPath)	\
    (This)->lpVtbl -> get_Path(This,pbstrPath)

#define IMessengerApp_LaunchLogonUI(This)	\
    (This)->lpVtbl -> LaunchLogonUI(This)

#define IMessengerApp_LaunchOptionsUI(This,mOptDlgPage)	\
    (This)->lpVtbl -> LaunchOptionsUI(This,mOptDlgPage)

#define IMessengerApp_LaunchAddContactUI(This,bstrEMail)	\
    (This)->lpVtbl -> LaunchAddContactUI(This,bstrEMail)

#define IMessengerApp_LaunchFindContactUI(This,bstrFirstName,bstrLastName,vbstrCity,vbstrState,vbstrCountry)	\
    (This)->lpVtbl -> LaunchFindContactUI(This,bstrFirstName,bstrLastName,vbstrCity,vbstrState,vbstrCountry)

#define IMessengerApp_LaunchIMUI(This,vUser,ppIMWindow)	\
    (This)->lpVtbl -> LaunchIMUI(This,vUser,ppIMWindow)

#define IMessengerApp_get_IMWindows(This,ppIMWindows)	\
    (This)->lpVtbl -> get_IMWindows(This,ppIMWindows)

#define IMessengerApp_get_ToolBar(This,pBoolToolBar)	\
    (This)->lpVtbl -> get_ToolBar(This,pBoolToolBar)

#define IMessengerApp_put_ToolBar(This,BoolToolBar)	\
    (This)->lpVtbl -> put_ToolBar(This,BoolToolBar)

#define IMessengerApp_get_StatusBar(This,pBoolStatusBar)	\
    (This)->lpVtbl -> get_StatusBar(This,pBoolStatusBar)

#define IMessengerApp_put_StatusBar(This,BoolStatusBar)	\
    (This)->lpVtbl -> put_StatusBar(This,BoolStatusBar)

#define IMessengerApp_get_StatusText(This,pbstrStatusText)	\
    (This)->lpVtbl -> get_StatusText(This,pbstrStatusText)

#define IMessengerApp_put_StatusText(This,bstrStatusText)	\
    (This)->lpVtbl -> put_StatusText(This,bstrStatusText)

#define IMessengerApp_get_HWND(This,phWnd)	\
    (This)->lpVtbl -> get_HWND(This,phWnd)

#define IMessengerApp_get_Left(This,plLeft)	\
    (This)->lpVtbl -> get_Left(This,plLeft)

#define IMessengerApp_put_Left(This,lLeft)	\
    (This)->lpVtbl -> put_Left(This,lLeft)

#define IMessengerApp_get_Top(This,plTop)	\
    (This)->lpVtbl -> get_Top(This,plTop)

#define IMessengerApp_put_Top(This,lTop)	\
    (This)->lpVtbl -> put_Top(This,lTop)

#define IMessengerApp_get_Width(This,plWidth)	\
    (This)->lpVtbl -> get_Width(This,plWidth)

#define IMessengerApp_put_Width(This,lWidth)	\
    (This)->lpVtbl -> put_Width(This,lWidth)

#define IMessengerApp_get_Height(This,plHeight)	\
    (This)->lpVtbl -> get_Height(This,plHeight)

#define IMessengerApp_put_Height(This,lHeight)	\
    (This)->lpVtbl -> put_Height(This,lHeight)

#define IMessengerApp_get_Visible(This,pBoolVisible)	\
    (This)->lpVtbl -> get_Visible(This,pBoolVisible)

#define IMessengerApp_put_Visible(This,BoolVisible)	\
    (This)->lpVtbl -> put_Visible(This,BoolVisible)

#define IMessengerApp_AutoLogon(This)	\
    (This)->lpVtbl -> AutoLogon(This)

#define IMessengerApp_put_FirstTimeCredentials(This,bstrUser,bstrPassword,pService,lFlags)	\
    (This)->lpVtbl -> put_FirstTimeCredentials(This,bstrUser,bstrPassword,pService,lFlags)

#define IMessengerApp_put_CachedPassword(This,bstrUser,bstrPassword,pService,BoolSavePassword)	\
    (This)->lpVtbl -> put_CachedPassword(This,bstrUser,bstrPassword,pService,BoolSavePassword)

#define IMessengerApp_RequestURLPost(This,muType,vbstrAdditionalInfo)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,vbstrAdditionalInfo)

#define IMessengerApp_put_TaskbarIcon(This,BoolVisible)	\
    (This)->lpVtbl -> put_TaskbarIcon(This,BoolVisible)

#define IMessengerApp_get_TaskbarIcon(This,pBoolVisible)	\
    (This)->lpVtbl -> get_TaskbarIcon(This,pBoolVisible)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Application_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IMessengerApp_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Parent_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IMessengerApp_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_Quit_Proxy( 
    IMessengerApp __RPC_FAR * This);


void __RPC_STUB IMessengerApp_Quit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Name_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IMessengerApp_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_FullName_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFullName);


void __RPC_STUB IMessengerApp_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Path_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IMessengerApp_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_LaunchLogonUI_Proxy( 
    IMessengerApp __RPC_FAR * This);


void __RPC_STUB IMessengerApp_LaunchLogonUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_LaunchOptionsUI_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ MOPTDLGPAGE mOptDlgPage);


void __RPC_STUB IMessengerApp_LaunchOptionsUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_LaunchAddContactUI_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ BSTR bstrEMail);


void __RPC_STUB IMessengerApp_LaunchAddContactUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_LaunchFindContactUI_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ BSTR bstrFirstName,
    /* [in] */ BSTR bstrLastName,
    /* [optional][in] */ VARIANT vbstrCity,
    /* [optional][in] */ VARIANT vbstrState,
    /* [optional][in] */ VARIANT vbstrCountry);


void __RPC_STUB IMessengerApp_LaunchFindContactUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_LaunchIMUI_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ VARIANT vUser,
    /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);


void __RPC_STUB IMessengerApp_LaunchIMUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_IMWindows_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ IMessengerIMWindows __RPC_FAR *__RPC_FAR *ppIMWindows);


void __RPC_STUB IMessengerApp_get_IMWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_ToolBar_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar);


void __RPC_STUB IMessengerApp_get_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_ToolBar_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolToolBar);


void __RPC_STUB IMessengerApp_put_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_StatusBar_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar);


void __RPC_STUB IMessengerApp_get_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_StatusBar_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolStatusBar);


void __RPC_STUB IMessengerApp_put_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_StatusText_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText);


void __RPC_STUB IMessengerApp_get_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_StatusText_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ BSTR bstrStatusText);


void __RPC_STUB IMessengerApp_put_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_HWND_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *phWnd);


void __RPC_STUB IMessengerApp_get_HWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Left_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plLeft);


void __RPC_STUB IMessengerApp_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_Left_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ long lLeft);


void __RPC_STUB IMessengerApp_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Top_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTop);


void __RPC_STUB IMessengerApp_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_Top_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ long lTop);


void __RPC_STUB IMessengerApp_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Width_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWidth);


void __RPC_STUB IMessengerApp_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_Width_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ long lWidth);


void __RPC_STUB IMessengerApp_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Height_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plHeight);


void __RPC_STUB IMessengerApp_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_Height_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ long lHeight);


void __RPC_STUB IMessengerApp_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_Visible_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);


void __RPC_STUB IMessengerApp_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_Visible_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolVisible);


void __RPC_STUB IMessengerApp_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_AutoLogon_Proxy( 
    IMessengerApp __RPC_FAR * This);


void __RPC_STUB IMessengerApp_AutoLogon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_FirstTimeCredentials_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ BSTR bstrUser,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ IMsgrService __RPC_FAR *pService,
    /* [in] */ long lFlags);


void __RPC_STUB IMessengerApp_put_FirstTimeCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_CachedPassword_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ BSTR bstrUser,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ IMsgrService __RPC_FAR *pService,
    /* [in] */ VARIANT_BOOL BoolSavePassword);


void __RPC_STUB IMessengerApp_put_CachedPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_RequestURLPost_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ MURLTYPE muType,
    /* [optional][in] */ VARIANT vbstrAdditionalInfo);


void __RPC_STUB IMessengerApp_RequestURLPost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_put_TaskbarIcon_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolVisible);


void __RPC_STUB IMessengerApp_put_TaskbarIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp_get_TaskbarIcon_Proxy( 
    IMessengerApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);


void __RPC_STUB IMessengerApp_get_TaskbarIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessengerApp_INTERFACE_DEFINED__ */


#ifndef __IMessengerApp2_INTERFACE_DEFINED__
#define __IMessengerApp2_INTERFACE_DEFINED__

/* interface IMessengerApp2 */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMessengerApp2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FF55D627-CF5B-40de-850F-62D20BC241C8")
    IMessengerApp2 : public IMessengerApp
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchPhoneUI( 
            /* [in] */ VARIANT vUser,
            /* [in] */ MUSERPROPERTY ePhoneNumber) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchAudioTuningWizard( 
            /* [in] */ long hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessengerApp2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessengerApp2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessengerApp2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IMessengerApp2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFullName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPath);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchLogonUI )( 
            IMessengerApp2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchOptionsUI )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ MOPTDLGPAGE mOptDlgPage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchAddContactUI )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ BSTR bstrEMail);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchFindContactUI )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [optional][in] */ VARIANT vbstrCity,
            /* [optional][in] */ VARIANT vbstrState,
            /* [optional][in] */ VARIANT vbstrCountry);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchIMUI )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMWindows )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ IMessengerIMWindows __RPC_FAR *__RPC_FAR *ppIMWindows);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolToolBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolStatusBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ BSTR bstrStatusText);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ long lLeft);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ long lTop);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ long lWidth);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ long lHeight);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolVisible);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoLogon )( 
            IMessengerApp2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FirstTimeCredentials )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ long lFlags);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CachedPassword )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ VARIANT_BOOL BoolSavePassword);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [optional][in] */ VARIANT vbstrAdditionalInfo);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TaskbarIcon )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolVisible);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TaskbarIcon )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchPhoneUI )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [in] */ MUSERPROPERTY ePhoneNumber);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchAudioTuningWizard )( 
            IMessengerApp2 __RPC_FAR * This,
            /* [in] */ long hwndParent);
        
        END_INTERFACE
    } IMessengerApp2Vtbl;

    interface IMessengerApp2
    {
        CONST_VTBL struct IMessengerApp2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessengerApp2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessengerApp2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessengerApp2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessengerApp2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMessengerApp2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMessengerApp2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMessengerApp2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMessengerApp2_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IMessengerApp2_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IMessengerApp2_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define IMessengerApp2_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IMessengerApp2_get_FullName(This,pbstrFullName)	\
    (This)->lpVtbl -> get_FullName(This,pbstrFullName)

#define IMessengerApp2_get_Path(This,pbstrPath)	\
    (This)->lpVtbl -> get_Path(This,pbstrPath)

#define IMessengerApp2_LaunchLogonUI(This)	\
    (This)->lpVtbl -> LaunchLogonUI(This)

#define IMessengerApp2_LaunchOptionsUI(This,mOptDlgPage)	\
    (This)->lpVtbl -> LaunchOptionsUI(This,mOptDlgPage)

#define IMessengerApp2_LaunchAddContactUI(This,bstrEMail)	\
    (This)->lpVtbl -> LaunchAddContactUI(This,bstrEMail)

#define IMessengerApp2_LaunchFindContactUI(This,bstrFirstName,bstrLastName,vbstrCity,vbstrState,vbstrCountry)	\
    (This)->lpVtbl -> LaunchFindContactUI(This,bstrFirstName,bstrLastName,vbstrCity,vbstrState,vbstrCountry)

#define IMessengerApp2_LaunchIMUI(This,vUser,ppIMWindow)	\
    (This)->lpVtbl -> LaunchIMUI(This,vUser,ppIMWindow)

#define IMessengerApp2_get_IMWindows(This,ppIMWindows)	\
    (This)->lpVtbl -> get_IMWindows(This,ppIMWindows)

#define IMessengerApp2_get_ToolBar(This,pBoolToolBar)	\
    (This)->lpVtbl -> get_ToolBar(This,pBoolToolBar)

#define IMessengerApp2_put_ToolBar(This,BoolToolBar)	\
    (This)->lpVtbl -> put_ToolBar(This,BoolToolBar)

#define IMessengerApp2_get_StatusBar(This,pBoolStatusBar)	\
    (This)->lpVtbl -> get_StatusBar(This,pBoolStatusBar)

#define IMessengerApp2_put_StatusBar(This,BoolStatusBar)	\
    (This)->lpVtbl -> put_StatusBar(This,BoolStatusBar)

#define IMessengerApp2_get_StatusText(This,pbstrStatusText)	\
    (This)->lpVtbl -> get_StatusText(This,pbstrStatusText)

#define IMessengerApp2_put_StatusText(This,bstrStatusText)	\
    (This)->lpVtbl -> put_StatusText(This,bstrStatusText)

#define IMessengerApp2_get_HWND(This,phWnd)	\
    (This)->lpVtbl -> get_HWND(This,phWnd)

#define IMessengerApp2_get_Left(This,plLeft)	\
    (This)->lpVtbl -> get_Left(This,plLeft)

#define IMessengerApp2_put_Left(This,lLeft)	\
    (This)->lpVtbl -> put_Left(This,lLeft)

#define IMessengerApp2_get_Top(This,plTop)	\
    (This)->lpVtbl -> get_Top(This,plTop)

#define IMessengerApp2_put_Top(This,lTop)	\
    (This)->lpVtbl -> put_Top(This,lTop)

#define IMessengerApp2_get_Width(This,plWidth)	\
    (This)->lpVtbl -> get_Width(This,plWidth)

#define IMessengerApp2_put_Width(This,lWidth)	\
    (This)->lpVtbl -> put_Width(This,lWidth)

#define IMessengerApp2_get_Height(This,plHeight)	\
    (This)->lpVtbl -> get_Height(This,plHeight)

#define IMessengerApp2_put_Height(This,lHeight)	\
    (This)->lpVtbl -> put_Height(This,lHeight)

#define IMessengerApp2_get_Visible(This,pBoolVisible)	\
    (This)->lpVtbl -> get_Visible(This,pBoolVisible)

#define IMessengerApp2_put_Visible(This,BoolVisible)	\
    (This)->lpVtbl -> put_Visible(This,BoolVisible)

#define IMessengerApp2_AutoLogon(This)	\
    (This)->lpVtbl -> AutoLogon(This)

#define IMessengerApp2_put_FirstTimeCredentials(This,bstrUser,bstrPassword,pService,lFlags)	\
    (This)->lpVtbl -> put_FirstTimeCredentials(This,bstrUser,bstrPassword,pService,lFlags)

#define IMessengerApp2_put_CachedPassword(This,bstrUser,bstrPassword,pService,BoolSavePassword)	\
    (This)->lpVtbl -> put_CachedPassword(This,bstrUser,bstrPassword,pService,BoolSavePassword)

#define IMessengerApp2_RequestURLPost(This,muType,vbstrAdditionalInfo)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,vbstrAdditionalInfo)

#define IMessengerApp2_put_TaskbarIcon(This,BoolVisible)	\
    (This)->lpVtbl -> put_TaskbarIcon(This,BoolVisible)

#define IMessengerApp2_get_TaskbarIcon(This,pBoolVisible)	\
    (This)->lpVtbl -> get_TaskbarIcon(This,pBoolVisible)


#define IMessengerApp2_LaunchPhoneUI(This,vUser,ePhoneNumber)	\
    (This)->lpVtbl -> LaunchPhoneUI(This,vUser,ePhoneNumber)

#define IMessengerApp2_LaunchAudioTuningWizard(This,hwndParent)	\
    (This)->lpVtbl -> LaunchAudioTuningWizard(This,hwndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp2_LaunchPhoneUI_Proxy( 
    IMessengerApp2 __RPC_FAR * This,
    /* [in] */ VARIANT vUser,
    /* [in] */ MUSERPROPERTY ePhoneNumber);


void __RPC_STUB IMessengerApp2_LaunchPhoneUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp2_LaunchAudioTuningWizard_Proxy( 
    IMessengerApp2 __RPC_FAR * This,
    /* [in] */ long hwndParent);


void __RPC_STUB IMessengerApp2_LaunchAudioTuningWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessengerApp2_INTERFACE_DEFINED__ */


#ifndef __IMessengerApp3_INTERFACE_DEFINED__
#define __IMessengerApp3_INTERFACE_DEFINED__

/* interface IMessengerApp3 */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMessengerApp3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28E28123-7DC5-45d3-860E-8EE1C3681BD5")
    IMessengerApp3 : public IMessengerApp2
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchPagerUI( 
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessengerApp3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessengerApp3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessengerApp3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IMessengerApp3 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFullName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPath);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchLogonUI )( 
            IMessengerApp3 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchOptionsUI )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ MOPTDLGPAGE mOptDlgPage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchAddContactUI )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ BSTR bstrEMail);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchFindContactUI )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [optional][in] */ VARIANT vbstrCity,
            /* [optional][in] */ VARIANT vbstrState,
            /* [optional][in] */ VARIANT vbstrCountry);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchIMUI )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMWindows )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ IMessengerIMWindows __RPC_FAR *__RPC_FAR *ppIMWindows);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolToolBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolStatusBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ BSTR bstrStatusText);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ long lLeft);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ long lTop);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ long lWidth);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ long lHeight);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolVisible);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoLogon )( 
            IMessengerApp3 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FirstTimeCredentials )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ long lFlags);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CachedPassword )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [in] */ VARIANT_BOOL BoolSavePassword);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [optional][in] */ VARIANT vbstrAdditionalInfo);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TaskbarIcon )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolVisible);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TaskbarIcon )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchPhoneUI )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [in] */ MUSERPROPERTY ePhoneNumber);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchAudioTuningWizard )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ long hwndParent);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchPagerUI )( 
            IMessengerApp3 __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);
        
        END_INTERFACE
    } IMessengerApp3Vtbl;

    interface IMessengerApp3
    {
        CONST_VTBL struct IMessengerApp3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessengerApp3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessengerApp3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessengerApp3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessengerApp3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMessengerApp3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMessengerApp3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMessengerApp3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMessengerApp3_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IMessengerApp3_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IMessengerApp3_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define IMessengerApp3_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IMessengerApp3_get_FullName(This,pbstrFullName)	\
    (This)->lpVtbl -> get_FullName(This,pbstrFullName)

#define IMessengerApp3_get_Path(This,pbstrPath)	\
    (This)->lpVtbl -> get_Path(This,pbstrPath)

#define IMessengerApp3_LaunchLogonUI(This)	\
    (This)->lpVtbl -> LaunchLogonUI(This)

#define IMessengerApp3_LaunchOptionsUI(This,mOptDlgPage)	\
    (This)->lpVtbl -> LaunchOptionsUI(This,mOptDlgPage)

#define IMessengerApp3_LaunchAddContactUI(This,bstrEMail)	\
    (This)->lpVtbl -> LaunchAddContactUI(This,bstrEMail)

#define IMessengerApp3_LaunchFindContactUI(This,bstrFirstName,bstrLastName,vbstrCity,vbstrState,vbstrCountry)	\
    (This)->lpVtbl -> LaunchFindContactUI(This,bstrFirstName,bstrLastName,vbstrCity,vbstrState,vbstrCountry)

#define IMessengerApp3_LaunchIMUI(This,vUser,ppIMWindow)	\
    (This)->lpVtbl -> LaunchIMUI(This,vUser,ppIMWindow)

#define IMessengerApp3_get_IMWindows(This,ppIMWindows)	\
    (This)->lpVtbl -> get_IMWindows(This,ppIMWindows)

#define IMessengerApp3_get_ToolBar(This,pBoolToolBar)	\
    (This)->lpVtbl -> get_ToolBar(This,pBoolToolBar)

#define IMessengerApp3_put_ToolBar(This,BoolToolBar)	\
    (This)->lpVtbl -> put_ToolBar(This,BoolToolBar)

#define IMessengerApp3_get_StatusBar(This,pBoolStatusBar)	\
    (This)->lpVtbl -> get_StatusBar(This,pBoolStatusBar)

#define IMessengerApp3_put_StatusBar(This,BoolStatusBar)	\
    (This)->lpVtbl -> put_StatusBar(This,BoolStatusBar)

#define IMessengerApp3_get_StatusText(This,pbstrStatusText)	\
    (This)->lpVtbl -> get_StatusText(This,pbstrStatusText)

#define IMessengerApp3_put_StatusText(This,bstrStatusText)	\
    (This)->lpVtbl -> put_StatusText(This,bstrStatusText)

#define IMessengerApp3_get_HWND(This,phWnd)	\
    (This)->lpVtbl -> get_HWND(This,phWnd)

#define IMessengerApp3_get_Left(This,plLeft)	\
    (This)->lpVtbl -> get_Left(This,plLeft)

#define IMessengerApp3_put_Left(This,lLeft)	\
    (This)->lpVtbl -> put_Left(This,lLeft)

#define IMessengerApp3_get_Top(This,plTop)	\
    (This)->lpVtbl -> get_Top(This,plTop)

#define IMessengerApp3_put_Top(This,lTop)	\
    (This)->lpVtbl -> put_Top(This,lTop)

#define IMessengerApp3_get_Width(This,plWidth)	\
    (This)->lpVtbl -> get_Width(This,plWidth)

#define IMessengerApp3_put_Width(This,lWidth)	\
    (This)->lpVtbl -> put_Width(This,lWidth)

#define IMessengerApp3_get_Height(This,plHeight)	\
    (This)->lpVtbl -> get_Height(This,plHeight)

#define IMessengerApp3_put_Height(This,lHeight)	\
    (This)->lpVtbl -> put_Height(This,lHeight)

#define IMessengerApp3_get_Visible(This,pBoolVisible)	\
    (This)->lpVtbl -> get_Visible(This,pBoolVisible)

#define IMessengerApp3_put_Visible(This,BoolVisible)	\
    (This)->lpVtbl -> put_Visible(This,BoolVisible)

#define IMessengerApp3_AutoLogon(This)	\
    (This)->lpVtbl -> AutoLogon(This)

#define IMessengerApp3_put_FirstTimeCredentials(This,bstrUser,bstrPassword,pService,lFlags)	\
    (This)->lpVtbl -> put_FirstTimeCredentials(This,bstrUser,bstrPassword,pService,lFlags)

#define IMessengerApp3_put_CachedPassword(This,bstrUser,bstrPassword,pService,BoolSavePassword)	\
    (This)->lpVtbl -> put_CachedPassword(This,bstrUser,bstrPassword,pService,BoolSavePassword)

#define IMessengerApp3_RequestURLPost(This,muType,vbstrAdditionalInfo)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,vbstrAdditionalInfo)

#define IMessengerApp3_put_TaskbarIcon(This,BoolVisible)	\
    (This)->lpVtbl -> put_TaskbarIcon(This,BoolVisible)

#define IMessengerApp3_get_TaskbarIcon(This,pBoolVisible)	\
    (This)->lpVtbl -> get_TaskbarIcon(This,pBoolVisible)


#define IMessengerApp3_LaunchPhoneUI(This,vUser,ePhoneNumber)	\
    (This)->lpVtbl -> LaunchPhoneUI(This,vUser,ePhoneNumber)

#define IMessengerApp3_LaunchAudioTuningWizard(This,hwndParent)	\
    (This)->lpVtbl -> LaunchAudioTuningWizard(This,hwndParent)


#define IMessengerApp3_LaunchPagerUI(This,vUser,ppIMWindow)	\
    (This)->lpVtbl -> LaunchPagerUI(This,vUser,ppIMWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerApp3_LaunchPagerUI_Proxy( 
    IMessengerApp3 __RPC_FAR * This,
    /* [in] */ VARIANT vUser,
    /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);


void __RPC_STUB IMessengerApp3_LaunchPagerUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessengerApp3_INTERFACE_DEFINED__ */


#ifndef __IMessengerIMWindow_INTERFACE_DEFINED__
#define __IMessengerIMWindow_INTERFACE_DEFINED__

/* interface IMessengerIMWindow */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMessengerIMWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35EDD1CD-1A8C-11d2-B49D-00C04FB90376")
    IMessengerIMWindow : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IMSession( 
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_History( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrHistory) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendText( 
            /* [in] */ BSTR bstrSendText) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ToolBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ToolBar( 
            /* [in] */ VARIANT_BOOL BoolToolBar) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StatusBar( 
            /* [in] */ VARIANT_BOOL BoolStatusBar) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StatusText( 
            /* [in] */ BSTR bstrStatusText) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HWND( 
            /* [retval][out] */ long __RPC_FAR *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *plLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long lLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *plTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long lTop) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *plWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long lWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *plHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long lHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL BoolVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Members( 
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessengerIMWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessengerIMWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessengerIMWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMSession )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_History )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrHistory);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendText )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ BSTR bstrSendText);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IMessengerIMWindow __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolToolBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolStatusBar);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ BSTR bstrStatusText);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ long lLeft);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ long lTop);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ long lWidth);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ long lHeight);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolVisible);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Members )( 
            IMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);
        
        END_INTERFACE
    } IMessengerIMWindowVtbl;

    interface IMessengerIMWindow
    {
        CONST_VTBL struct IMessengerIMWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessengerIMWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessengerIMWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessengerIMWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessengerIMWindow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMessengerIMWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMessengerIMWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMessengerIMWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMessengerIMWindow_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IMessengerIMWindow_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IMessengerIMWindow_get_IMSession(This,ppIMSession)	\
    (This)->lpVtbl -> get_IMSession(This,ppIMSession)

#define IMessengerIMWindow_get_History(This,pbstrHistory)	\
    (This)->lpVtbl -> get_History(This,pbstrHistory)

#define IMessengerIMWindow_SendText(This,bstrSendText)	\
    (This)->lpVtbl -> SendText(This,bstrSendText)

#define IMessengerIMWindow_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IMessengerIMWindow_get_ToolBar(This,pBoolToolBar)	\
    (This)->lpVtbl -> get_ToolBar(This,pBoolToolBar)

#define IMessengerIMWindow_put_ToolBar(This,BoolToolBar)	\
    (This)->lpVtbl -> put_ToolBar(This,BoolToolBar)

#define IMessengerIMWindow_get_StatusBar(This,pBoolStatusBar)	\
    (This)->lpVtbl -> get_StatusBar(This,pBoolStatusBar)

#define IMessengerIMWindow_put_StatusBar(This,BoolStatusBar)	\
    (This)->lpVtbl -> put_StatusBar(This,BoolStatusBar)

#define IMessengerIMWindow_get_StatusText(This,pbstrStatusText)	\
    (This)->lpVtbl -> get_StatusText(This,pbstrStatusText)

#define IMessengerIMWindow_put_StatusText(This,bstrStatusText)	\
    (This)->lpVtbl -> put_StatusText(This,bstrStatusText)

#define IMessengerIMWindow_get_HWND(This,phWnd)	\
    (This)->lpVtbl -> get_HWND(This,phWnd)

#define IMessengerIMWindow_get_Left(This,plLeft)	\
    (This)->lpVtbl -> get_Left(This,plLeft)

#define IMessengerIMWindow_put_Left(This,lLeft)	\
    (This)->lpVtbl -> put_Left(This,lLeft)

#define IMessengerIMWindow_get_Top(This,plTop)	\
    (This)->lpVtbl -> get_Top(This,plTop)

#define IMessengerIMWindow_put_Top(This,lTop)	\
    (This)->lpVtbl -> put_Top(This,lTop)

#define IMessengerIMWindow_get_Width(This,plWidth)	\
    (This)->lpVtbl -> get_Width(This,plWidth)

#define IMessengerIMWindow_put_Width(This,lWidth)	\
    (This)->lpVtbl -> put_Width(This,lWidth)

#define IMessengerIMWindow_get_Height(This,plHeight)	\
    (This)->lpVtbl -> get_Height(This,plHeight)

#define IMessengerIMWindow_put_Height(This,lHeight)	\
    (This)->lpVtbl -> put_Height(This,lHeight)

#define IMessengerIMWindow_get_Visible(This,pBoolVisible)	\
    (This)->lpVtbl -> get_Visible(This,pBoolVisible)

#define IMessengerIMWindow_put_Visible(This,BoolVisible)	\
    (This)->lpVtbl -> put_Visible(This,BoolVisible)

#define IMessengerIMWindow_get_Members(This,ppUsers)	\
    (This)->lpVtbl -> get_Members(This,ppUsers)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Application_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IMessengerIMWindow_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Parent_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IMessengerIMWindow_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_IMSession_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);


void __RPC_STUB IMessengerIMWindow_get_IMSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_History_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrHistory);


void __RPC_STUB IMessengerIMWindow_get_History_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_SendText_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ BSTR bstrSendText);


void __RPC_STUB IMessengerIMWindow_SendText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_Close_Proxy( 
    IMessengerIMWindow __RPC_FAR * This);


void __RPC_STUB IMessengerIMWindow_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_ToolBar_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolToolBar);


void __RPC_STUB IMessengerIMWindow_get_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_ToolBar_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolToolBar);


void __RPC_STUB IMessengerIMWindow_put_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_StatusBar_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolStatusBar);


void __RPC_STUB IMessengerIMWindow_get_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_StatusBar_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolStatusBar);


void __RPC_STUB IMessengerIMWindow_put_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_StatusText_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusText);


void __RPC_STUB IMessengerIMWindow_get_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_StatusText_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ BSTR bstrStatusText);


void __RPC_STUB IMessengerIMWindow_put_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_HWND_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *phWnd);


void __RPC_STUB IMessengerIMWindow_get_HWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Left_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plLeft);


void __RPC_STUB IMessengerIMWindow_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_Left_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ long lLeft);


void __RPC_STUB IMessengerIMWindow_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Top_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTop);


void __RPC_STUB IMessengerIMWindow_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_Top_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ long lTop);


void __RPC_STUB IMessengerIMWindow_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Width_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWidth);


void __RPC_STUB IMessengerIMWindow_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_Width_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ long lWidth);


void __RPC_STUB IMessengerIMWindow_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Height_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plHeight);


void __RPC_STUB IMessengerIMWindow_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_Height_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ long lHeight);


void __RPC_STUB IMessengerIMWindow_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Visible_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolVisible);


void __RPC_STUB IMessengerIMWindow_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_put_Visible_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolVisible);


void __RPC_STUB IMessengerIMWindow_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindow_get_Members_Proxy( 
    IMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);


void __RPC_STUB IMessengerIMWindow_get_Members_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessengerIMWindow_INTERFACE_DEFINED__ */


#ifndef __IMessengerIMWindows_INTERFACE_DEFINED__
#define __IMessengerIMWindows_INTERFACE_DEFINED__

/* interface IMessengerIMWindows */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMessengerIMWindows;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35EDD1CC-1A8C-11d2-B49D-00C04FB90376")
    IMessengerIMWindows : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pcWindows) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long Index,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow) = 0;
        
        virtual /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessengerIMWindowsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessengerIMWindows __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessengerIMWindows __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcWindows);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);
        
        /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMessengerIMWindows __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IMessengerIMWindowsVtbl;

    interface IMessengerIMWindows
    {
        CONST_VTBL struct IMessengerIMWindowsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessengerIMWindows_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessengerIMWindows_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessengerIMWindows_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessengerIMWindows_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMessengerIMWindows_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMessengerIMWindows_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMessengerIMWindows_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMessengerIMWindows_get_Count(This,pcWindows)	\
    (This)->lpVtbl -> get_Count(This,pcWindows)

#define IMessengerIMWindows_Item(This,Index,ppIMWindow)	\
    (This)->lpVtbl -> Item(This,Index,ppIMWindow)

#define IMessengerIMWindows_get__NewEnum(This,ppUnknown)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindows_get_Count_Proxy( 
    IMessengerIMWindows __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcWindows);


void __RPC_STUB IMessengerIMWindows_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindows_Item_Proxy( 
    IMessengerIMWindows __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ IMessengerIMWindow __RPC_FAR *__RPC_FAR *ppIMWindow);


void __RPC_STUB IMessengerIMWindows_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IMessengerIMWindows_get__NewEnum_Proxy( 
    IMessengerIMWindows __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IMessengerIMWindows_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessengerIMWindows_INTERFACE_DEFINED__ */


#ifndef __IMsgrServices_INTERFACE_DEFINED__
#define __IMsgrServices_INTERFACE_DEFINED__

/* interface IMsgrServices */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("659ECAD8-A5C0-11d2-A440-00C04F795683")
    IMsgrServices : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PrimaryService( 
            /* [in] */ IMsgrService __RPC_FAR *pService) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrimaryService( 
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pcServices) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long Index,
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService) = 0;
        
        virtual /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrServices __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrServices __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrServices __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrServices __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrServices __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PrimaryService )( 
            IMsgrServices __RPC_FAR * This,
            /* [in] */ IMsgrService __RPC_FAR *pService);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrimaryService )( 
            IMsgrServices __RPC_FAR * This,
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsgrServices __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcServices);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IMsgrServices __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);
        
        /* [helpcontext][helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsgrServices __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IMsgrServicesVtbl;

    interface IMsgrServices
    {
        CONST_VTBL struct IMsgrServicesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrServices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrServices_put_PrimaryService(This,pService)	\
    (This)->lpVtbl -> put_PrimaryService(This,pService)

#define IMsgrServices_get_PrimaryService(This,ppService)	\
    (This)->lpVtbl -> get_PrimaryService(This,ppService)

#define IMsgrServices_get_Count(This,pcServices)	\
    (This)->lpVtbl -> get_Count(This,pcServices)

#define IMsgrServices_Item(This,Index,ppService)	\
    (This)->lpVtbl -> Item(This,Index,ppService)

#define IMsgrServices_get__NewEnum(This,ppUnknown)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrServices_put_PrimaryService_Proxy( 
    IMsgrServices __RPC_FAR * This,
    /* [in] */ IMsgrService __RPC_FAR *pService);


void __RPC_STUB IMsgrServices_put_PrimaryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrServices_get_PrimaryService_Proxy( 
    IMsgrServices __RPC_FAR * This,
    /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);


void __RPC_STUB IMsgrServices_get_PrimaryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrServices_get_Count_Proxy( 
    IMsgrServices __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcServices);


void __RPC_STUB IMsgrServices_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrServices_Item_Proxy( 
    IMsgrServices __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);


void __RPC_STUB IMsgrServices_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IMsgrServices_get__NewEnum_Proxy( 
    IMsgrServices __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IMsgrServices_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrServices_INTERFACE_DEFINED__ */


#ifndef __IMsgrService_INTERFACE_DEFINED__
#define __IMsgrService_INTERFACE_DEFINED__

/* interface IMsgrService */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("659ECAD9-A5C0-11d2-A440-00C04F795683")
    IMsgrService : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrServiceName) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LogonName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FriendlyName( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Capabilities( 
            /* [retval][out] */ LONG __RPC_FAR *plCapabilities) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ MSVCSTATUS __RPC_FAR *pmStatus) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Logoff( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindUser( 
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [in] */ BSTR bstrCity,
            /* [in] */ BSTR bstrState,
            /* [in] */ BSTR bstrCountry,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SendInviteMail( 
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RequestURLPost( 
            /* [in] */ MURLTYPE muType,
            /* [in] */ BSTR bstrAdditionalInfo,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ProfileField( 
            /* [in] */ MPFLFIELD mpflField,
            /* [in] */ VARIANT vFieldValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProfileField( 
            /* [in] */ MPFLFIELD mpflField,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFieldValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrService __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServiceName )( 
            IMsgrService __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrServiceName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogonName )( 
            IMsgrService __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FriendlyName )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FriendlyName )( 
            IMsgrService __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IMsgrService __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plCapabilities);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IMsgrService __RPC_FAR * This,
            /* [retval][out] */ MSVCSTATUS __RPC_FAR *pmStatus);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logoff )( 
            IMsgrService __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindUser )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [in] */ BSTR bstrCity,
            /* [in] */ BSTR bstrState,
            /* [in] */ BSTR bstrCountry,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendInviteMail )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [in] */ BSTR bstrAdditionalInfo,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProfileField )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ MPFLFIELD mpflField,
            /* [in] */ VARIANT vFieldValue);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProfileField )( 
            IMsgrService __RPC_FAR * This,
            /* [in] */ MPFLFIELD mpflField,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFieldValue);
        
        END_INTERFACE
    } IMsgrServiceVtbl;

    interface IMsgrService
    {
        CONST_VTBL struct IMsgrServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrService_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrService_get_ServiceName(This,pbstrServiceName)	\
    (This)->lpVtbl -> get_ServiceName(This,pbstrServiceName)

#define IMsgrService_get_LogonName(This,pbstrName)	\
    (This)->lpVtbl -> get_LogonName(This,pbstrName)

#define IMsgrService_put_FriendlyName(This,bstrName)	\
    (This)->lpVtbl -> put_FriendlyName(This,bstrName)

#define IMsgrService_get_FriendlyName(This,pbstrName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrName)

#define IMsgrService_get_Capabilities(This,plCapabilities)	\
    (This)->lpVtbl -> get_Capabilities(This,plCapabilities)

#define IMsgrService_get_Status(This,pmStatus)	\
    (This)->lpVtbl -> get_Status(This,pmStatus)

#define IMsgrService_Logoff(This)	\
    (This)->lpVtbl -> Logoff(This)

#define IMsgrService_FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)	\
    (This)->lpVtbl -> FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)

#define IMsgrService_SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)	\
    (This)->lpVtbl -> SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)

#define IMsgrService_RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)

#define IMsgrService_put_ProfileField(This,mpflField,vFieldValue)	\
    (This)->lpVtbl -> put_ProfileField(This,mpflField,vFieldValue)

#define IMsgrService_get_ProfileField(This,mpflField,pvFieldValue)	\
    (This)->lpVtbl -> get_ProfileField(This,mpflField,pvFieldValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrService_get_ServiceName_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrServiceName);


void __RPC_STUB IMsgrService_get_ServiceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrService_get_LogonName_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IMsgrService_get_LogonName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrService_put_FriendlyName_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IMsgrService_put_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrService_get_FriendlyName_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IMsgrService_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrService_get_Capabilities_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plCapabilities);


void __RPC_STUB IMsgrService_get_Capabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrService_get_Status_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [retval][out] */ MSVCSTATUS __RPC_FAR *pmStatus);


void __RPC_STUB IMsgrService_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrService_Logoff_Proxy( 
    IMsgrService __RPC_FAR * This);


void __RPC_STUB IMsgrService_Logoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrService_FindUser_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [in] */ BSTR bstrFirstName,
    /* [in] */ BSTR bstrLastName,
    /* [in] */ BSTR bstrCity,
    /* [in] */ BSTR bstrState,
    /* [in] */ BSTR bstrCountry,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrService_FindUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrService_SendInviteMail_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress,
    /* [in] */ LONG lFindCookie,
    /* [in] */ LONG lFindIndex,
    /* [in] */ LONG lLCID,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrService_SendInviteMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrService_RequestURLPost_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [in] */ MURLTYPE muType,
    /* [in] */ BSTR bstrAdditionalInfo,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrService_RequestURLPost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrService_put_ProfileField_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [in] */ MPFLFIELD mpflField,
    /* [in] */ VARIANT vFieldValue);


void __RPC_STUB IMsgrService_put_ProfileField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrService_get_ProfileField_Proxy( 
    IMsgrService __RPC_FAR * This,
    /* [in] */ MPFLFIELD mpflField,
    /* [retval][out] */ VARIANT __RPC_FAR *pvFieldValue);


void __RPC_STUB IMsgrService_get_ProfileField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrService_INTERFACE_DEFINED__ */


#ifndef __IMsgrObject2_INTERFACE_DEFINED__
#define __IMsgrObject2_INTERFACE_DEFINED__

/* interface IMsgrObject2 */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("218CB455-20B6-11d2-8E17-0000F803A446")
    IMsgrObject2 : public IMsgrObject
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendFileTransferInvite( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ BSTR bstrFilePath,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendFileTransferInviteAccept( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ BSTR bstrFilePath,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendFileTransferInviteCancel( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG hrReason,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelFileTransfer( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG hrReason,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE FileTransferStatus( 
            /* [in] */ LONG lCookie,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [out] */ long __RPC_FAR *plStatus,
            /* [out] */ BSTR __RPC_FAR *pbstrFilePath,
            /* [out] */ long __RPC_FAR *plTotalBytes,
            /* [out] */ long __RPC_FAR *plBytesTransferred) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocalProperty( 
            /* [in] */ MUSERPROPERTY ePropType,
            /* [in] */ VARIANT vPropVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LocalProperty( 
            /* [in] */ MUSERPROPERTY ePropType,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendPage( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ MUSERPROPERTY ePhoneType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendCustomInviteMail( 
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [in] */ BSTR bstrCustomText,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrObject2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrObject2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrObject2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateUser )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ BSTR bstrLogonName,
            /* [in] */ IMsgrService __RPC_FAR *pService,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logon )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ IMsgrService __RPC_FAR *pService);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logoff )( 
            IMsgrObject2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_List )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MLIST mList,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalLogonName )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalFriendlyName )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalState )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MSTATE mState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalState )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [retval][out] */ MSTATE __RPC_FAR *pmState);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessagePrivacy )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MMSGPRIVACY mmpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessagePrivacy )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Prompt )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MPROMPT mpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Prompt )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendAppInvite )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ BSTR bstrAppGUID,
            /* [in] */ BSTR bstrAppName,
            /* [in] */ BSTR bstrAppURL,
            /* [in] */ LONG lInviteType,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendAppInviteAccept )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG lInviteType,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendAppInviteCancel )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG hrReason,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalOption )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MLOCALOPTION option,
            /* [in] */ VARIANT vSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalOption )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MLOCALOPTION option,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSetting);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindUser )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [in] */ BSTR bstrCity,
            /* [in] */ BSTR bstrState,
            /* [in] */ BSTR bstrCountry,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendInviteMail )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [in] */ BSTR bstrAdditionalInfo,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMSessions )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIMSession )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ VARIANT vUser,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SessionRequestAccept )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
            /* [in] */ long hrReason);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SessionRequestCancel )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrIMSession __RPC_FAR *pIMsgrIMSession,
            /* [in] */ long hrReason);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Services )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [retval][out] */ IMsgrServices __RPC_FAR *__RPC_FAR *ppServices);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UnreadEmail )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MFOLDER mFolder,
            /* [retval][out] */ long __RPC_FAR *pcUnreadEmail);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFileTransferInvite )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ BSTR bstrFilePath,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFileTransferInviteAccept )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ BSTR bstrFilePath,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFileTransferInviteCancel )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG hrReason,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelFileTransfer )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ LONG lCookie,
            /* [in] */ LONG hrReason,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileTransferStatus )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ LONG lCookie,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [out] */ long __RPC_FAR *plStatus,
            /* [out] */ BSTR __RPC_FAR *pbstrFilePath,
            /* [out] */ long __RPC_FAR *plTotalBytes,
            /* [out] */ long __RPC_FAR *plBytesTransferred);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalProperty )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY ePropType,
            /* [in] */ VARIANT vPropVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalProperty )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY ePropType,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendPage )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ MUSERPROPERTY ePhoneType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendCustomInviteMail )( 
            IMsgrObject2 __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [in] */ BSTR bstrCustomText,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        END_INTERFACE
    } IMsgrObject2Vtbl;

    interface IMsgrObject2
    {
        CONST_VTBL struct IMsgrObject2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrObject2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrObject2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrObject2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrObject2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrObject2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrObject2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrObject2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrObject2_CreateUser(This,bstrLogonName,pService,ppUser)	\
    (This)->lpVtbl -> CreateUser(This,bstrLogonName,pService,ppUser)

#define IMsgrObject2_Logon(This,bstrUser,bstrPassword,pService)	\
    (This)->lpVtbl -> Logon(This,bstrUser,bstrPassword,pService)

#define IMsgrObject2_Logoff(This)	\
    (This)->lpVtbl -> Logoff(This)

#define IMsgrObject2_get_List(This,mList,ppUsers)	\
    (This)->lpVtbl -> get_List(This,mList,ppUsers)

#define IMsgrObject2_get_LocalLogonName(This,pbstrName)	\
    (This)->lpVtbl -> get_LocalLogonName(This,pbstrName)

#define IMsgrObject2_get_LocalFriendlyName(This,pbstrName)	\
    (This)->lpVtbl -> get_LocalFriendlyName(This,pbstrName)

#define IMsgrObject2_put_LocalState(This,mState)	\
    (This)->lpVtbl -> put_LocalState(This,mState)

#define IMsgrObject2_get_LocalState(This,pmState)	\
    (This)->lpVtbl -> get_LocalState(This,pmState)

#define IMsgrObject2_put_MessagePrivacy(This,mmpSetting)	\
    (This)->lpVtbl -> put_MessagePrivacy(This,mmpSetting)

#define IMsgrObject2_get_MessagePrivacy(This,pmmpSetting)	\
    (This)->lpVtbl -> get_MessagePrivacy(This,pmmpSetting)

#define IMsgrObject2_put_Prompt(This,mpSetting)	\
    (This)->lpVtbl -> put_Prompt(This,mpSetting)

#define IMsgrObject2_get_Prompt(This,pmpSetting)	\
    (This)->lpVtbl -> get_Prompt(This,pmpSetting)

#define IMsgrObject2_SendAppInvite(This,pUser,lCookie,bstrAppGUID,bstrAppName,bstrAppURL,lInviteType,mmtType,plCookie)	\
    (This)->lpVtbl -> SendAppInvite(This,pUser,lCookie,bstrAppGUID,bstrAppName,bstrAppURL,lInviteType,mmtType,plCookie)

#define IMsgrObject2_SendAppInviteAccept(This,pUser,lCookie,lInviteType,mmtType,plCookie)	\
    (This)->lpVtbl -> SendAppInviteAccept(This,pUser,lCookie,lInviteType,mmtType,plCookie)

#define IMsgrObject2_SendAppInviteCancel(This,pUser,lCookie,hrReason,mmtType,plCookie)	\
    (This)->lpVtbl -> SendAppInviteCancel(This,pUser,lCookie,hrReason,mmtType,plCookie)

#define IMsgrObject2_put_LocalOption(This,option,vSetting)	\
    (This)->lpVtbl -> put_LocalOption(This,option,vSetting)

#define IMsgrObject2_get_LocalOption(This,option,pvSetting)	\
    (This)->lpVtbl -> get_LocalOption(This,option,pvSetting)

#define IMsgrObject2_FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)	\
    (This)->lpVtbl -> FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)

#define IMsgrObject2_SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)	\
    (This)->lpVtbl -> SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)

#define IMsgrObject2_RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)

#define IMsgrObject2_get_IMSessions(This,ppIMSessions)	\
    (This)->lpVtbl -> get_IMSessions(This,ppIMSessions)

#define IMsgrObject2_CreateIMSession(This,vUser,ppIMSession)	\
    (This)->lpVtbl -> CreateIMSession(This,vUser,ppIMSession)

#define IMsgrObject2_SessionRequestAccept(This,pIMsgrIMSession,hrReason)	\
    (This)->lpVtbl -> SessionRequestAccept(This,pIMsgrIMSession,hrReason)

#define IMsgrObject2_SessionRequestCancel(This,pIMsgrIMSession,hrReason)	\
    (This)->lpVtbl -> SessionRequestCancel(This,pIMsgrIMSession,hrReason)

#define IMsgrObject2_get_Services(This,ppServices)	\
    (This)->lpVtbl -> get_Services(This,ppServices)

#define IMsgrObject2_get_UnreadEmail(This,mFolder,pcUnreadEmail)	\
    (This)->lpVtbl -> get_UnreadEmail(This,mFolder,pcUnreadEmail)


#define IMsgrObject2_SendFileTransferInvite(This,pUser,lCookie,bstrFilePath,mmtType,plCookie)	\
    (This)->lpVtbl -> SendFileTransferInvite(This,pUser,lCookie,bstrFilePath,mmtType,plCookie)

#define IMsgrObject2_SendFileTransferInviteAccept(This,pUser,lCookie,bstrFilePath,mmtType,plCookie)	\
    (This)->lpVtbl -> SendFileTransferInviteAccept(This,pUser,lCookie,bstrFilePath,mmtType,plCookie)

#define IMsgrObject2_SendFileTransferInviteCancel(This,pUser,lCookie,hrReason,mmtType,plCookie)	\
    (This)->lpVtbl -> SendFileTransferInviteCancel(This,pUser,lCookie,hrReason,mmtType,plCookie)

#define IMsgrObject2_CancelFileTransfer(This,pUser,lCookie,hrReason,mmtType,plCookie)	\
    (This)->lpVtbl -> CancelFileTransfer(This,pUser,lCookie,hrReason,mmtType,plCookie)

#define IMsgrObject2_FileTransferStatus(This,lCookie,pUser,plStatus,pbstrFilePath,plTotalBytes,plBytesTransferred)	\
    (This)->lpVtbl -> FileTransferStatus(This,lCookie,pUser,plStatus,pbstrFilePath,plTotalBytes,plBytesTransferred)

#define IMsgrObject2_put_LocalProperty(This,ePropType,vPropVal)	\
    (This)->lpVtbl -> put_LocalProperty(This,ePropType,vPropVal)

#define IMsgrObject2_get_LocalProperty(This,ePropType,pvPropVal)	\
    (This)->lpVtbl -> get_LocalProperty(This,ePropType,pvPropVal)

#define IMsgrObject2_SendPage(This,pUser,bstrMessage,ePhoneType,plCookie)	\
    (This)->lpVtbl -> SendPage(This,pUser,bstrMessage,ePhoneType,plCookie)

#define IMsgrObject2_SendCustomInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,bstrCustomText,plCookie)	\
    (This)->lpVtbl -> SendCustomInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,bstrCustomText,plCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_SendFileTransferInvite_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ LONG lCookie,
    /* [in] */ BSTR bstrFilePath,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject2_SendFileTransferInvite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_SendFileTransferInviteAccept_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ LONG lCookie,
    /* [in] */ BSTR bstrFilePath,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject2_SendFileTransferInviteAccept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_SendFileTransferInviteCancel_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ LONG lCookie,
    /* [in] */ LONG hrReason,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject2_SendFileTransferInviteCancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_CancelFileTransfer_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ LONG lCookie,
    /* [in] */ LONG hrReason,
    /* [in] */ MMSGTYPE mmtType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject2_CancelFileTransfer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_FileTransferStatus_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ LONG lCookie,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [out] */ long __RPC_FAR *plStatus,
    /* [out] */ BSTR __RPC_FAR *pbstrFilePath,
    /* [out] */ long __RPC_FAR *plTotalBytes,
    /* [out] */ long __RPC_FAR *plBytesTransferred);


void __RPC_STUB IMsgrObject2_FileTransferStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_put_LocalProperty_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ MUSERPROPERTY ePropType,
    /* [in] */ VARIANT vPropVal);


void __RPC_STUB IMsgrObject2_put_LocalProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_get_LocalProperty_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ MUSERPROPERTY ePropType,
    /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal);


void __RPC_STUB IMsgrObject2_get_LocalProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_SendPage_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ BSTR bstrMessage,
    /* [in] */ MUSERPROPERTY ePhoneType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject2_SendPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrObject2_SendCustomInviteMail_Proxy( 
    IMsgrObject2 __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress,
    /* [in] */ LONG lFindCookie,
    /* [in] */ LONG lFindIndex,
    /* [in] */ LONG lLCID,
    /* [in] */ BSTR bstrCustomText,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrObject2_SendCustomInviteMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrObject2_INTERFACE_DEFINED__ */


#ifndef __DMsgrObjectEvents_DISPINTERFACE_DEFINED__
#define __DMsgrObjectEvents_DISPINTERFACE_DEFINED__

/* dispinterface DMsgrObjectEvents */
/* [hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_DMsgrObjectEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("218CB452-20B6-11d2-8E17-0000F803A446")
    DMsgrObjectEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DMsgrObjectEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DMsgrObjectEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DMsgrObjectEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DMsgrObjectEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DMsgrObjectEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DMsgrObjectEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DMsgrObjectEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DMsgrObjectEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DMsgrObjectEventsVtbl;

    interface DMsgrObjectEvents
    {
        CONST_VTBL struct DMsgrObjectEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DMsgrObjectEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DMsgrObjectEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DMsgrObjectEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DMsgrObjectEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DMsgrObjectEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DMsgrObjectEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DMsgrObjectEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DMsgrObjectEvents_DISPINTERFACE_DEFINED__ */


#ifndef __DMsgrSPEvents_DISPINTERFACE_DEFINED__
#define __DMsgrSPEvents_DISPINTERFACE_DEFINED__

/* dispinterface DMsgrSPEvents */
/* [hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_DMsgrSPEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("2B2F1E9E-B01D-47e9-BD6A-EF6D63DE7170")
    DMsgrSPEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DMsgrSPEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DMsgrSPEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DMsgrSPEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DMsgrSPEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DMsgrSPEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DMsgrSPEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DMsgrSPEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DMsgrSPEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DMsgrSPEventsVtbl;

    interface DMsgrSPEvents
    {
        CONST_VTBL struct DMsgrSPEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DMsgrSPEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DMsgrSPEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DMsgrSPEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DMsgrSPEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DMsgrSPEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DMsgrSPEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DMsgrSPEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DMsgrSPEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IMsgrUser2_INTERFACE_DEFINED__
#define __IMsgrUser2_INTERFACE_DEFINED__

/* interface IMsgrUser2 */
/* [object][oleautomation][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrUser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("218CB456-20B6-11d2-8E17-0000F803A446")
    IMsgrUser2 : public IMsgrUser
    {
    public:
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Property( 
            /* [in] */ MUSERPROPERTY ePropType,
            /* [in] */ VARIANT vPropVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Property( 
            /* [in] */ MUSERPROPERTY ePropType,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrUser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrUser2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrUser2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FriendlyName )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ BSTR bstrFriendlyName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FriendlyName )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFriendlyName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddress )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEmailAddress);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [retval][out] */ MSTATE __RPC_FAR *pmState);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogonName )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLogonName);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendText )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ BSTR bstrMsgHeader,
            /* [in] */ BSTR bstrMsgText,
            /* [in] */ MMSGTYPE mmtType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Service )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [retval][out] */ IMsgrService __RPC_FAR *__RPC_FAR *ppService);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Property )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY ePropType,
            /* [in] */ VARIANT vPropVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Property )( 
            IMsgrUser2 __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY ePropType,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal);
        
        END_INTERFACE
    } IMsgrUser2Vtbl;

    interface IMsgrUser2
    {
        CONST_VTBL struct IMsgrUser2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrUser2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrUser2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrUser2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrUser2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrUser2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrUser2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrUser2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrUser2_put_FriendlyName(This,bstrFriendlyName)	\
    (This)->lpVtbl -> put_FriendlyName(This,bstrFriendlyName)

#define IMsgrUser2_get_FriendlyName(This,pbstrFriendlyName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrFriendlyName)

#define IMsgrUser2_get_EmailAddress(This,pbstrEmailAddress)	\
    (This)->lpVtbl -> get_EmailAddress(This,pbstrEmailAddress)

#define IMsgrUser2_get_State(This,pmState)	\
    (This)->lpVtbl -> get_State(This,pmState)

#define IMsgrUser2_get_LogonName(This,pbstrLogonName)	\
    (This)->lpVtbl -> get_LogonName(This,pbstrLogonName)

#define IMsgrUser2_SendText(This,bstrMsgHeader,bstrMsgText,mmtType,plCookie)	\
    (This)->lpVtbl -> SendText(This,bstrMsgHeader,bstrMsgText,mmtType,plCookie)

#define IMsgrUser2_get_Service(This,ppService)	\
    (This)->lpVtbl -> get_Service(This,ppService)


#define IMsgrUser2_put_Property(This,ePropType,vPropVal)	\
    (This)->lpVtbl -> put_Property(This,ePropType,vPropVal)

#define IMsgrUser2_get_Property(This,ePropType,pvPropVal)	\
    (This)->lpVtbl -> get_Property(This,ePropType,pvPropVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrUser2_put_Property_Proxy( 
    IMsgrUser2 __RPC_FAR * This,
    /* [in] */ MUSERPROPERTY ePropType,
    /* [in] */ VARIANT vPropVal);


void __RPC_STUB IMsgrUser2_put_Property_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrUser2_get_Property_Proxy( 
    IMsgrUser2 __RPC_FAR * This,
    /* [in] */ MUSERPROPERTY ePropType,
    /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal);


void __RPC_STUB IMsgrUser2_get_Property_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrUser2_INTERFACE_DEFINED__ */


#ifndef __IMsgrSP_INTERFACE_DEFINED__
#define __IMsgrSP_INTERFACE_DEFINED__

/* interface IMsgrSP */
/* [object][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrSP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E5B42158-AF2C-11d2-8D9D-0000F875C541")
    IMsgrSP : public IMsgrService
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Logon( 
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateUser( 
            /* [in] */ BSTR bstrLogonName,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_List( 
            /* [in] */ MLIST mList,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MessagePrivacy( 
            /* [in] */ MMSGPRIVACY mmpSetting) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MessagePrivacy( 
            /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Prompt( 
            /* [in] */ MPROMPT mpSetting) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Prompt( 
            /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocalState( 
            /* [in] */ MSTATE mState) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalState( 
            /* [retval][out] */ MSTATE __RPC_FAR *pmState) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddBuddy( 
            /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
            /* [in] */ MLIST mList) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RemoveBuddy( 
            /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
            /* [in] */ MLIST mList) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateIMSession( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IMSessions( 
            /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrSPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrSP __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrSP __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrSP __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServiceName )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrServiceName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogonName )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FriendlyName )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FriendlyName )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plCapabilities);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ MSVCSTATUS __RPC_FAR *pmStatus);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logoff )( 
            IMsgrSP __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindUser )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [in] */ BSTR bstrCity,
            /* [in] */ BSTR bstrState,
            /* [in] */ BSTR bstrCountry,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendInviteMail )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [in] */ BSTR bstrAdditionalInfo,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProfileField )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ MPFLFIELD mpflField,
            /* [in] */ VARIANT vFieldValue);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProfileField )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ MPFLFIELD mpflField,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFieldValue);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logon )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateUser )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ BSTR bstrLogonName,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_List )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ MLIST mList,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessagePrivacy )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ MMSGPRIVACY mmpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessagePrivacy )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Prompt )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ MPROMPT mpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Prompt )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalState )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ MSTATE mState);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalState )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ MSTATE __RPC_FAR *pmState);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBuddy )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
            /* [in] */ MLIST mList);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveBuddy )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
            /* [in] */ MLIST mList);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIMSession )( 
            IMsgrSP __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMSessions )( 
            IMsgrSP __RPC_FAR * This,
            /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions);
        
        END_INTERFACE
    } IMsgrSPVtbl;

    interface IMsgrSP
    {
        CONST_VTBL struct IMsgrSPVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrSP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrSP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrSP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrSP_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrSP_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrSP_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrSP_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrSP_get_ServiceName(This,pbstrServiceName)	\
    (This)->lpVtbl -> get_ServiceName(This,pbstrServiceName)

#define IMsgrSP_get_LogonName(This,pbstrName)	\
    (This)->lpVtbl -> get_LogonName(This,pbstrName)

#define IMsgrSP_put_FriendlyName(This,bstrName)	\
    (This)->lpVtbl -> put_FriendlyName(This,bstrName)

#define IMsgrSP_get_FriendlyName(This,pbstrName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrName)

#define IMsgrSP_get_Capabilities(This,plCapabilities)	\
    (This)->lpVtbl -> get_Capabilities(This,plCapabilities)

#define IMsgrSP_get_Status(This,pmStatus)	\
    (This)->lpVtbl -> get_Status(This,pmStatus)

#define IMsgrSP_Logoff(This)	\
    (This)->lpVtbl -> Logoff(This)

#define IMsgrSP_FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)	\
    (This)->lpVtbl -> FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)

#define IMsgrSP_SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)	\
    (This)->lpVtbl -> SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)

#define IMsgrSP_RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)

#define IMsgrSP_put_ProfileField(This,mpflField,vFieldValue)	\
    (This)->lpVtbl -> put_ProfileField(This,mpflField,vFieldValue)

#define IMsgrSP_get_ProfileField(This,mpflField,pvFieldValue)	\
    (This)->lpVtbl -> get_ProfileField(This,mpflField,pvFieldValue)


#define IMsgrSP_Logon(This,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> Logon(This,bstrUser,bstrPassword)

#define IMsgrSP_CreateUser(This,bstrLogonName,ppUser)	\
    (This)->lpVtbl -> CreateUser(This,bstrLogonName,ppUser)

#define IMsgrSP_get_List(This,mList,ppUsers)	\
    (This)->lpVtbl -> get_List(This,mList,ppUsers)

#define IMsgrSP_put_MessagePrivacy(This,mmpSetting)	\
    (This)->lpVtbl -> put_MessagePrivacy(This,mmpSetting)

#define IMsgrSP_get_MessagePrivacy(This,pmmpSetting)	\
    (This)->lpVtbl -> get_MessagePrivacy(This,pmmpSetting)

#define IMsgrSP_put_Prompt(This,mpSetting)	\
    (This)->lpVtbl -> put_Prompt(This,mpSetting)

#define IMsgrSP_get_Prompt(This,pmpSetting)	\
    (This)->lpVtbl -> get_Prompt(This,pmpSetting)

#define IMsgrSP_put_LocalState(This,mState)	\
    (This)->lpVtbl -> put_LocalState(This,mState)

#define IMsgrSP_get_LocalState(This,pmState)	\
    (This)->lpVtbl -> get_LocalState(This,pmState)

#define IMsgrSP_AddBuddy(This,pBuddy,mList)	\
    (This)->lpVtbl -> AddBuddy(This,pBuddy,mList)

#define IMsgrSP_RemoveBuddy(This,pBuddy,mList)	\
    (This)->lpVtbl -> RemoveBuddy(This,pBuddy,mList)

#define IMsgrSP_CreateIMSession(This,pUser,ppIMSession)	\
    (This)->lpVtbl -> CreateIMSession(This,pUser,ppIMSession)

#define IMsgrSP_get_IMSessions(This,ppIMSessions)	\
    (This)->lpVtbl -> get_IMSessions(This,ppIMSessions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrSP_Logon_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ BSTR bstrUser,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB IMsgrSP_Logon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrSP_CreateUser_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ BSTR bstrLogonName,
    /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);


void __RPC_STUB IMsgrSP_CreateUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrSP_get_List_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ MLIST mList,
    /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);


void __RPC_STUB IMsgrSP_get_List_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrSP_put_MessagePrivacy_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ MMSGPRIVACY mmpSetting);


void __RPC_STUB IMsgrSP_put_MessagePrivacy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrSP_get_MessagePrivacy_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting);


void __RPC_STUB IMsgrSP_get_MessagePrivacy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrSP_put_Prompt_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ MPROMPT mpSetting);


void __RPC_STUB IMsgrSP_put_Prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrSP_get_Prompt_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting);


void __RPC_STUB IMsgrSP_get_Prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrSP_put_LocalState_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ MSTATE mState);


void __RPC_STUB IMsgrSP_put_LocalState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrSP_get_LocalState_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [retval][out] */ MSTATE __RPC_FAR *pmState);


void __RPC_STUB IMsgrSP_get_LocalState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrSP_AddBuddy_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
    /* [in] */ MLIST mList);


void __RPC_STUB IMsgrSP_AddBuddy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrSP_RemoveBuddy_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
    /* [in] */ MLIST mList);


void __RPC_STUB IMsgrSP_RemoveBuddy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMsgrSP_CreateIMSession_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);


void __RPC_STUB IMsgrSP_CreateIMSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrSP_get_IMSessions_Proxy( 
    IMsgrSP __RPC_FAR * This,
    /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions);


void __RPC_STUB IMsgrSP_get_IMSessions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrSP_INTERFACE_DEFINED__ */


#ifndef __IMsgrSP2_INTERFACE_DEFINED__
#define __IMsgrSP2_INTERFACE_DEFINED__

/* interface IMsgrSP2 */
/* [object][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsgrSP2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E5B42159-AF2C-11d2-8D9D-0000F875C541")
    IMsgrSP2 : public IMsgrSP
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalIPAddress( 
            /* [retval][out] */ long __RPC_FAR *plAddr) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocalProperty( 
            /* [in] */ MUSERPROPERTY ePropType,
            /* [in] */ VARIANT vPropVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LocalProperty( 
            /* [in] */ MUSERPROPERTY ePropType,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendPage( 
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ MUSERPROPERTY ePhoneType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendCustomInviteMail( 
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [in] */ BSTR bstrCustomText,
            /* [retval][out] */ LONG __RPC_FAR *plCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsgrSP2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsgrSP2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsgrSP2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServiceName )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrServiceName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogonName )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FriendlyName )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FriendlyName )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plCapabilities);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ MSVCSTATUS __RPC_FAR *pmStatus);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logoff )( 
            IMsgrSP2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindUser )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ BSTR bstrFirstName,
            /* [in] */ BSTR bstrLastName,
            /* [in] */ BSTR bstrCity,
            /* [in] */ BSTR bstrState,
            /* [in] */ BSTR bstrCountry,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendInviteMail )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestURLPost )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MURLTYPE muType,
            /* [in] */ BSTR bstrAdditionalInfo,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProfileField )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MPFLFIELD mpflField,
            /* [in] */ VARIANT vFieldValue);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProfileField )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MPFLFIELD mpflField,
            /* [retval][out] */ VARIANT __RPC_FAR *pvFieldValue);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Logon )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrPassword);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateUser )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ BSTR bstrLogonName,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_List )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MLIST mList,
            /* [retval][out] */ IMsgrUsers __RPC_FAR *__RPC_FAR *ppUsers);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessagePrivacy )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MMSGPRIVACY mmpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessagePrivacy )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ MMSGPRIVACY __RPC_FAR *pmmpSetting);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Prompt )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MPROMPT mpSetting);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Prompt )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ MPROMPT __RPC_FAR *pmpSetting);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalState )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MSTATE mState);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalState )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ MSTATE __RPC_FAR *pmState);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBuddy )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
            /* [in] */ MLIST mList);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveBuddy )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pBuddy,
            /* [in] */ MLIST mList);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIMSession )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [retval][out] */ IMsgrIMSession __RPC_FAR *__RPC_FAR *ppIMSession);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IMSessions )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ IMsgrIMSessions __RPC_FAR *__RPC_FAR *ppIMSessions);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalIPAddress )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAddr);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocalProperty )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY ePropType,
            /* [in] */ VARIANT vPropVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalProperty )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY ePropType,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendPage )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ IMsgrUser __RPC_FAR *pUser,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ MUSERPROPERTY ePhoneType,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendCustomInviteMail )( 
            IMsgrSP2 __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ LONG lFindCookie,
            /* [in] */ LONG lFindIndex,
            /* [in] */ LONG lLCID,
            /* [in] */ BSTR bstrCustomText,
            /* [retval][out] */ LONG __RPC_FAR *plCookie);
        
        END_INTERFACE
    } IMsgrSP2Vtbl;

    interface IMsgrSP2
    {
        CONST_VTBL struct IMsgrSP2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsgrSP2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsgrSP2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsgrSP2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsgrSP2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsgrSP2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsgrSP2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsgrSP2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsgrSP2_get_ServiceName(This,pbstrServiceName)	\
    (This)->lpVtbl -> get_ServiceName(This,pbstrServiceName)

#define IMsgrSP2_get_LogonName(This,pbstrName)	\
    (This)->lpVtbl -> get_LogonName(This,pbstrName)

#define IMsgrSP2_put_FriendlyName(This,bstrName)	\
    (This)->lpVtbl -> put_FriendlyName(This,bstrName)

#define IMsgrSP2_get_FriendlyName(This,pbstrName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrName)

#define IMsgrSP2_get_Capabilities(This,plCapabilities)	\
    (This)->lpVtbl -> get_Capabilities(This,plCapabilities)

#define IMsgrSP2_get_Status(This,pmStatus)	\
    (This)->lpVtbl -> get_Status(This,pmStatus)

#define IMsgrSP2_Logoff(This)	\
    (This)->lpVtbl -> Logoff(This)

#define IMsgrSP2_FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)	\
    (This)->lpVtbl -> FindUser(This,bstrFirstName,bstrLastName,bstrCity,bstrState,bstrCountry,plCookie)

#define IMsgrSP2_SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)	\
    (This)->lpVtbl -> SendInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,plCookie)

#define IMsgrSP2_RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)	\
    (This)->lpVtbl -> RequestURLPost(This,muType,bstrAdditionalInfo,plCookie)

#define IMsgrSP2_put_ProfileField(This,mpflField,vFieldValue)	\
    (This)->lpVtbl -> put_ProfileField(This,mpflField,vFieldValue)

#define IMsgrSP2_get_ProfileField(This,mpflField,pvFieldValue)	\
    (This)->lpVtbl -> get_ProfileField(This,mpflField,pvFieldValue)


#define IMsgrSP2_Logon(This,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> Logon(This,bstrUser,bstrPassword)

#define IMsgrSP2_CreateUser(This,bstrLogonName,ppUser)	\
    (This)->lpVtbl -> CreateUser(This,bstrLogonName,ppUser)

#define IMsgrSP2_get_List(This,mList,ppUsers)	\
    (This)->lpVtbl -> get_List(This,mList,ppUsers)

#define IMsgrSP2_put_MessagePrivacy(This,mmpSetting)	\
    (This)->lpVtbl -> put_MessagePrivacy(This,mmpSetting)

#define IMsgrSP2_get_MessagePrivacy(This,pmmpSetting)	\
    (This)->lpVtbl -> get_MessagePrivacy(This,pmmpSetting)

#define IMsgrSP2_put_Prompt(This,mpSetting)	\
    (This)->lpVtbl -> put_Prompt(This,mpSetting)

#define IMsgrSP2_get_Prompt(This,pmpSetting)	\
    (This)->lpVtbl -> get_Prompt(This,pmpSetting)

#define IMsgrSP2_put_LocalState(This,mState)	\
    (This)->lpVtbl -> put_LocalState(This,mState)

#define IMsgrSP2_get_LocalState(This,pmState)	\
    (This)->lpVtbl -> get_LocalState(This,pmState)

#define IMsgrSP2_AddBuddy(This,pBuddy,mList)	\
    (This)->lpVtbl -> AddBuddy(This,pBuddy,mList)

#define IMsgrSP2_RemoveBuddy(This,pBuddy,mList)	\
    (This)->lpVtbl -> RemoveBuddy(This,pBuddy,mList)

#define IMsgrSP2_CreateIMSession(This,pUser,ppIMSession)	\
    (This)->lpVtbl -> CreateIMSession(This,pUser,ppIMSession)

#define IMsgrSP2_get_IMSessions(This,ppIMSessions)	\
    (This)->lpVtbl -> get_IMSessions(This,ppIMSessions)


#define IMsgrSP2_get_LocalIPAddress(This,plAddr)	\
    (This)->lpVtbl -> get_LocalIPAddress(This,plAddr)

#define IMsgrSP2_put_LocalProperty(This,ePropType,vPropVal)	\
    (This)->lpVtbl -> put_LocalProperty(This,ePropType,vPropVal)

#define IMsgrSP2_get_LocalProperty(This,ePropType,pvPropVal)	\
    (This)->lpVtbl -> get_LocalProperty(This,ePropType,pvPropVal)

#define IMsgrSP2_SendPage(This,pUser,bstrMessage,ePhoneType,plCookie)	\
    (This)->lpVtbl -> SendPage(This,pUser,bstrMessage,ePhoneType,plCookie)

#define IMsgrSP2_SendCustomInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,bstrCustomText,plCookie)	\
    (This)->lpVtbl -> SendCustomInviteMail(This,bstrEmailAddress,lFindCookie,lFindIndex,lLCID,bstrCustomText,plCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsgrSP2_get_LocalIPAddress_Proxy( 
    IMsgrSP2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAddr);


void __RPC_STUB IMsgrSP2_get_LocalIPAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsgrSP2_put_LocalProperty_Proxy( 
    IMsgrSP2 __RPC_FAR * This,
    /* [in] */ MUSERPROPERTY ePropType,
    /* [in] */ VARIANT vPropVal);


void __RPC_STUB IMsgrSP2_put_LocalProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMsgrSP2_get_LocalProperty_Proxy( 
    IMsgrSP2 __RPC_FAR * This,
    /* [in] */ MUSERPROPERTY ePropType,
    /* [retval][out] */ VARIANT __RPC_FAR *pvPropVal);


void __RPC_STUB IMsgrSP2_get_LocalProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrSP2_SendPage_Proxy( 
    IMsgrSP2 __RPC_FAR * This,
    /* [in] */ IMsgrUser __RPC_FAR *pUser,
    /* [in] */ BSTR bstrMessage,
    /* [in] */ MUSERPROPERTY ePhoneType,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrSP2_SendPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsgrSP2_SendCustomInviteMail_Proxy( 
    IMsgrSP2 __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress,
    /* [in] */ LONG lFindCookie,
    /* [in] */ LONG lFindIndex,
    /* [in] */ LONG lLCID,
    /* [in] */ BSTR bstrCustomText,
    /* [retval][out] */ LONG __RPC_FAR *plCookie);


void __RPC_STUB IMsgrSP2_SendCustomInviteMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsgrSP2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MsgrObject;

#ifdef __cplusplus

class DECLSPEC_UUID("F3A614DC-ABE0-11d2-A441-00C04F795683")
MsgrObject;
#endif

EXTERN_C const CLSID CLSID_MessengerApp;

#ifdef __cplusplus

class DECLSPEC_UUID("FB7199AB-79BF-11d2-8D94-0000F875C541")
MessengerApp;
#endif
#endif /* __Messenger_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_mdisp_0154 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0154_0001
    {	INFOBAR_DEFAULT	= 0,
	INFOBAR_INFORMATION	= 1,
	INFOBAR_EXCLAMATION	= 2
    }	INFOBAR;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0154_0002
    {	FONTSIZE_SMALLEST	= 0,
	FONTSIZE_SMALLER	= 1,
	FONTSIZE_MEDIUM	= 2,
	FONTSIZE_LARGER	= 3,
	FONTSIZE_LARGEST	= 4
    }	FONTSIZE;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_mdisp_0154_0003
    {	VOICESESSIONSTATE_DISABLED	= 0,
	VOICESESSIONSTATE_INACTIVE	= 1,
	VOICESESSIONSTATE_ACTIVE	= 2
    }	VOICESESSIONSTATE;

typedef struct  tagLOGFONT_DATA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    LONG lfItalic;
    LONG lfUnderline;
    LONG lfStrikeOut;
    LONG lfCharSet;
    LONG lfOutPrecision;
    LONG lfClipPrecision;
    LONG lfQuality;
    LONG lfPitchAndFamily;
    BSTR bstrFaceName;
    }	LOGFONT_DATA;



extern RPC_IF_HANDLE __MIDL_itf_mdisp_0154_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mdisp_0154_v0_0_s_ifspec;

#ifndef __IMsnMessengerIMWindow_INTERFACE_DEFINED__
#define __IMsnMessengerIMWindow_INTERFACE_DEFINED__

/* interface IMsnMessengerIMWindow */
/* [object][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsnMessengerIMWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B7E6AA9-C4FA-4951-815B-4AFE39D81453")
    IMsnMessengerIMWindow : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HistoryHWND( 
            /* [retval][out] */ long __RPC_FAR *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_InputHWND( 
            /* [retval][out] */ long __RPC_FAR *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SetWindowStyle( 
            /* [in] */ long hWnd,
            /* [in] */ long lStyle,
            /* [in] */ long lExStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TextSize( 
            /* [retval][out] */ FONTSIZE __RPC_FAR *plSize) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_TextSize( 
            /* [in] */ FONTSIZE lSize) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessageFont( 
            /* [out] */ LOGFONT_DATA __RPC_FAR *plfMessage,
            /* [out] */ COLORREF __RPC_FAR *pcrMessage,
            /* [out] */ long __RPC_FAR *plMinPointSize,
            /* [out] */ long __RPC_FAR *plMaxPointSize) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMessageFont( 
            /* [in] */ LOGFONT_DATA __RPC_FAR *plfMessage,
            /* [in] */ COLORREF crMessage) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SendFile( 
            /* [in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelFileTransfer( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VoiceSessionState( 
            /* [retval][out] */ VOICESESSIONSTATE __RPC_FAR *plState) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_VoiceSessionState( 
            /* [in] */ VOICESESSIONSTATE lState) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VoiceVolume( 
            /* [retval][out] */ long __RPC_FAR *plVolume) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_VoiceVolume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MicrophoneMute( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolMute) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MicrophoneMute( 
            /* [in] */ VARIANT_BOOL BoolMute) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MicrophoneAmplitude( 
            /* [retval][out] */ long __RPC_FAR *plAmplitude) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsPageMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolPager) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneNumber( 
            /* [retval][out] */ MUSERPROPERTY __RPC_FAR *plProp) = 0;
        
        virtual /* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PhoneNumber( 
            /* [in] */ MUSERPROPERTY lProp) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultUser( 
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsnMessengerIMWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsnMessengerIMWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsnMessengerIMWindow __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HistoryHWND )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InputHWND )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWindowStyle )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ long hWnd,
            /* [in] */ long lStyle,
            /* [in] */ long lExStyle);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextSize )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ FONTSIZE __RPC_FAR *plSize);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TextSize )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ FONTSIZE lSize);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageFont )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [out] */ LOGFONT_DATA __RPC_FAR *plfMessage,
            /* [out] */ COLORREF __RPC_FAR *pcrMessage,
            /* [out] */ long __RPC_FAR *plMinPointSize,
            /* [out] */ long __RPC_FAR *plMaxPointSize);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMessageFont )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ LOGFONT_DATA __RPC_FAR *plfMessage,
            /* [in] */ COLORREF crMessage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFile )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ BSTR bstrFilePath);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelFileTransfer )( 
            IMsnMessengerIMWindow __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VoiceSessionState )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ VOICESESSIONSTATE __RPC_FAR *plState);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VoiceSessionState )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ VOICESESSIONSTATE lState);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VoiceVolume )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVolume);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VoiceVolume )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ long lVolume);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MicrophoneMute )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolMute);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MicrophoneMute )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolMute);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MicrophoneAmplitude )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAmplitude);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsPageMode )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolPager);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PhoneNumber )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ MUSERPROPERTY __RPC_FAR *plProp);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PhoneNumber )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY lProp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultUser )( 
            IMsnMessengerIMWindow __RPC_FAR * This,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);
        
        END_INTERFACE
    } IMsnMessengerIMWindowVtbl;

    interface IMsnMessengerIMWindow
    {
        CONST_VTBL struct IMsnMessengerIMWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsnMessengerIMWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsnMessengerIMWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsnMessengerIMWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsnMessengerIMWindow_get_HistoryHWND(This,phWnd)	\
    (This)->lpVtbl -> get_HistoryHWND(This,phWnd)

#define IMsnMessengerIMWindow_get_InputHWND(This,phWnd)	\
    (This)->lpVtbl -> get_InputHWND(This,phWnd)

#define IMsnMessengerIMWindow_SetWindowStyle(This,hWnd,lStyle,lExStyle)	\
    (This)->lpVtbl -> SetWindowStyle(This,hWnd,lStyle,lExStyle)

#define IMsnMessengerIMWindow_get_TextSize(This,plSize)	\
    (This)->lpVtbl -> get_TextSize(This,plSize)

#define IMsnMessengerIMWindow_put_TextSize(This,lSize)	\
    (This)->lpVtbl -> put_TextSize(This,lSize)

#define IMsnMessengerIMWindow_GetMessageFont(This,plfMessage,pcrMessage,plMinPointSize,plMaxPointSize)	\
    (This)->lpVtbl -> GetMessageFont(This,plfMessage,pcrMessage,plMinPointSize,plMaxPointSize)

#define IMsnMessengerIMWindow_SetMessageFont(This,plfMessage,crMessage)	\
    (This)->lpVtbl -> SetMessageFont(This,plfMessage,crMessage)

#define IMsnMessengerIMWindow_SendFile(This,bstrFilePath)	\
    (This)->lpVtbl -> SendFile(This,bstrFilePath)

#define IMsnMessengerIMWindow_CancelFileTransfer(This)	\
    (This)->lpVtbl -> CancelFileTransfer(This)

#define IMsnMessengerIMWindow_get_VoiceSessionState(This,plState)	\
    (This)->lpVtbl -> get_VoiceSessionState(This,plState)

#define IMsnMessengerIMWindow_put_VoiceSessionState(This,lState)	\
    (This)->lpVtbl -> put_VoiceSessionState(This,lState)

#define IMsnMessengerIMWindow_get_VoiceVolume(This,plVolume)	\
    (This)->lpVtbl -> get_VoiceVolume(This,plVolume)

#define IMsnMessengerIMWindow_put_VoiceVolume(This,lVolume)	\
    (This)->lpVtbl -> put_VoiceVolume(This,lVolume)

#define IMsnMessengerIMWindow_get_MicrophoneMute(This,pBoolMute)	\
    (This)->lpVtbl -> get_MicrophoneMute(This,pBoolMute)

#define IMsnMessengerIMWindow_put_MicrophoneMute(This,BoolMute)	\
    (This)->lpVtbl -> put_MicrophoneMute(This,BoolMute)

#define IMsnMessengerIMWindow_get_MicrophoneAmplitude(This,plAmplitude)	\
    (This)->lpVtbl -> get_MicrophoneAmplitude(This,plAmplitude)

#define IMsnMessengerIMWindow_get_IsPageMode(This,pBoolPager)	\
    (This)->lpVtbl -> get_IsPageMode(This,pBoolPager)

#define IMsnMessengerIMWindow_get_PhoneNumber(This,plProp)	\
    (This)->lpVtbl -> get_PhoneNumber(This,plProp)

#define IMsnMessengerIMWindow_put_PhoneNumber(This,lProp)	\
    (This)->lpVtbl -> put_PhoneNumber(This,lProp)

#define IMsnMessengerIMWindow_get_DefaultUser(This,ppUser)	\
    (This)->lpVtbl -> get_DefaultUser(This,ppUser)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_HistoryHWND_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *phWnd);


void __RPC_STUB IMsnMessengerIMWindow_get_HistoryHWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_InputHWND_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *phWnd);


void __RPC_STUB IMsnMessengerIMWindow_get_InputHWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_SetWindowStyle_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ long hWnd,
    /* [in] */ long lStyle,
    /* [in] */ long lExStyle);


void __RPC_STUB IMsnMessengerIMWindow_SetWindowStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_TextSize_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ FONTSIZE __RPC_FAR *plSize);


void __RPC_STUB IMsnMessengerIMWindow_get_TextSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_put_TextSize_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ FONTSIZE lSize);


void __RPC_STUB IMsnMessengerIMWindow_put_TextSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_GetMessageFont_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [out] */ LOGFONT_DATA __RPC_FAR *plfMessage,
    /* [out] */ COLORREF __RPC_FAR *pcrMessage,
    /* [out] */ long __RPC_FAR *plMinPointSize,
    /* [out] */ long __RPC_FAR *plMaxPointSize);


void __RPC_STUB IMsnMessengerIMWindow_GetMessageFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_SetMessageFont_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ LOGFONT_DATA __RPC_FAR *plfMessage,
    /* [in] */ COLORREF crMessage);


void __RPC_STUB IMsnMessengerIMWindow_SetMessageFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_SendFile_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ BSTR bstrFilePath);


void __RPC_STUB IMsnMessengerIMWindow_SendFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_CancelFileTransfer_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This);


void __RPC_STUB IMsnMessengerIMWindow_CancelFileTransfer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_VoiceSessionState_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ VOICESESSIONSTATE __RPC_FAR *plState);


void __RPC_STUB IMsnMessengerIMWindow_get_VoiceSessionState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_put_VoiceSessionState_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ VOICESESSIONSTATE lState);


void __RPC_STUB IMsnMessengerIMWindow_put_VoiceSessionState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_VoiceVolume_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVolume);


void __RPC_STUB IMsnMessengerIMWindow_get_VoiceVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_put_VoiceVolume_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ long lVolume);


void __RPC_STUB IMsnMessengerIMWindow_put_VoiceVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_MicrophoneMute_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolMute);


void __RPC_STUB IMsnMessengerIMWindow_get_MicrophoneMute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_put_MicrophoneMute_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL BoolMute);


void __RPC_STUB IMsnMessengerIMWindow_put_MicrophoneMute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_MicrophoneAmplitude_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAmplitude);


void __RPC_STUB IMsnMessengerIMWindow_get_MicrophoneAmplitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_IsPageMode_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolPager);


void __RPC_STUB IMsnMessengerIMWindow_get_IsPageMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_PhoneNumber_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ MUSERPROPERTY __RPC_FAR *plProp);


void __RPC_STUB IMsnMessengerIMWindow_get_PhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_put_PhoneNumber_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [in] */ MUSERPROPERTY lProp);


void __RPC_STUB IMsnMessengerIMWindow_put_PhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow_get_DefaultUser_Proxy( 
    IMsnMessengerIMWindow __RPC_FAR * This,
    /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);


void __RPC_STUB IMsnMessengerIMWindow_get_DefaultUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsnMessengerIMWindow_INTERFACE_DEFINED__ */


#ifndef __IMsnMessengerIMWindow2_INTERFACE_DEFINED__
#define __IMsnMessengerIMWindow2_INTERFACE_DEFINED__

/* interface IMsnMessengerIMWindow2 */
/* [object][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IMsnMessengerIMWindow2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70BF15A8-58CD-4687-A8B3-D14E2F760371")
    IMsnMessengerIMWindow2 : public IMsnMessengerIMWindow
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ProcessSysChar( 
            long lChar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsnMessengerIMWindow2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HistoryHWND )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InputHWND )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phWnd);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWindowStyle )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ long hWnd,
            /* [in] */ long lStyle,
            /* [in] */ long lExStyle);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextSize )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ FONTSIZE __RPC_FAR *plSize);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TextSize )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ FONTSIZE lSize);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageFont )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [out] */ LOGFONT_DATA __RPC_FAR *plfMessage,
            /* [out] */ COLORREF __RPC_FAR *pcrMessage,
            /* [out] */ long __RPC_FAR *plMinPointSize,
            /* [out] */ long __RPC_FAR *plMaxPointSize);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMessageFont )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ LOGFONT_DATA __RPC_FAR *plfMessage,
            /* [in] */ COLORREF crMessage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFile )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ BSTR bstrFilePath);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelFileTransfer )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VoiceSessionState )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ VOICESESSIONSTATE __RPC_FAR *plState);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VoiceSessionState )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ VOICESESSIONSTATE lState);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VoiceVolume )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVolume);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VoiceVolume )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ long lVolume);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MicrophoneMute )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolMute);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MicrophoneMute )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL BoolMute);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MicrophoneAmplitude )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAmplitude);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsPageMode )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBoolPager);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PhoneNumber )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ MUSERPROPERTY __RPC_FAR *plProp);
        
        /* [helpcontext][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PhoneNumber )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [in] */ MUSERPROPERTY lProp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultUser )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            /* [retval][out] */ IMsgrUser __RPC_FAR *__RPC_FAR *ppUser);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessSysChar )( 
            IMsnMessengerIMWindow2 __RPC_FAR * This,
            long lChar);
        
        END_INTERFACE
    } IMsnMessengerIMWindow2Vtbl;

    interface IMsnMessengerIMWindow2
    {
        CONST_VTBL struct IMsnMessengerIMWindow2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsnMessengerIMWindow2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsnMessengerIMWindow2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsnMessengerIMWindow2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsnMessengerIMWindow2_get_HistoryHWND(This,phWnd)	\
    (This)->lpVtbl -> get_HistoryHWND(This,phWnd)

#define IMsnMessengerIMWindow2_get_InputHWND(This,phWnd)	\
    (This)->lpVtbl -> get_InputHWND(This,phWnd)

#define IMsnMessengerIMWindow2_SetWindowStyle(This,hWnd,lStyle,lExStyle)	\
    (This)->lpVtbl -> SetWindowStyle(This,hWnd,lStyle,lExStyle)

#define IMsnMessengerIMWindow2_get_TextSize(This,plSize)	\
    (This)->lpVtbl -> get_TextSize(This,plSize)

#define IMsnMessengerIMWindow2_put_TextSize(This,lSize)	\
    (This)->lpVtbl -> put_TextSize(This,lSize)

#define IMsnMessengerIMWindow2_GetMessageFont(This,plfMessage,pcrMessage,plMinPointSize,plMaxPointSize)	\
    (This)->lpVtbl -> GetMessageFont(This,plfMessage,pcrMessage,plMinPointSize,plMaxPointSize)

#define IMsnMessengerIMWindow2_SetMessageFont(This,plfMessage,crMessage)	\
    (This)->lpVtbl -> SetMessageFont(This,plfMessage,crMessage)

#define IMsnMessengerIMWindow2_SendFile(This,bstrFilePath)	\
    (This)->lpVtbl -> SendFile(This,bstrFilePath)

#define IMsnMessengerIMWindow2_CancelFileTransfer(This)	\
    (This)->lpVtbl -> CancelFileTransfer(This)

#define IMsnMessengerIMWindow2_get_VoiceSessionState(This,plState)	\
    (This)->lpVtbl -> get_VoiceSessionState(This,plState)

#define IMsnMessengerIMWindow2_put_VoiceSessionState(This,lState)	\
    (This)->lpVtbl -> put_VoiceSessionState(This,lState)

#define IMsnMessengerIMWindow2_get_VoiceVolume(This,plVolume)	\
    (This)->lpVtbl -> get_VoiceVolume(This,plVolume)

#define IMsnMessengerIMWindow2_put_VoiceVolume(This,lVolume)	\
    (This)->lpVtbl -> put_VoiceVolume(This,lVolume)

#define IMsnMessengerIMWindow2_get_MicrophoneMute(This,pBoolMute)	\
    (This)->lpVtbl -> get_MicrophoneMute(This,pBoolMute)

#define IMsnMessengerIMWindow2_put_MicrophoneMute(This,BoolMute)	\
    (This)->lpVtbl -> put_MicrophoneMute(This,BoolMute)

#define IMsnMessengerIMWindow2_get_MicrophoneAmplitude(This,plAmplitude)	\
    (This)->lpVtbl -> get_MicrophoneAmplitude(This,plAmplitude)

#define IMsnMessengerIMWindow2_get_IsPageMode(This,pBoolPager)	\
    (This)->lpVtbl -> get_IsPageMode(This,pBoolPager)

#define IMsnMessengerIMWindow2_get_PhoneNumber(This,plProp)	\
    (This)->lpVtbl -> get_PhoneNumber(This,plProp)

#define IMsnMessengerIMWindow2_put_PhoneNumber(This,lProp)	\
    (This)->lpVtbl -> put_PhoneNumber(This,lProp)

#define IMsnMessengerIMWindow2_get_DefaultUser(This,ppUser)	\
    (This)->lpVtbl -> get_DefaultUser(This,ppUser)


#define IMsnMessengerIMWindow2_ProcessSysChar(This,lChar)	\
    (This)->lpVtbl -> ProcessSysChar(This,lChar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsnMessengerIMWindow2_ProcessSysChar_Proxy( 
    IMsnMessengerIMWindow2 __RPC_FAR * This,
    long lChar);


void __RPC_STUB IMsnMessengerIMWindow2_ProcessSysChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsnMessengerIMWindow2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\im_inc\msgruaid.h ===
#ifndef __MSGRUAID__H__
#define __MSGRUAID__H__

//
// Dispatch IDs for DMessengerEvents
// 
#define DISPID_MUAE_ONSIGNIN				  0x400
#define DISPID_MUAE_ONSIGNOUT				  0x401
#define DISPID_MUAE_ONLISTADD				  0x402
#define DISPID_MUAE_ONLISTREMOVE			  0x403
#define DISPID_MUAE_ONUSERFRIENDLYNAMECHANGE  0x404
#define DISPID_MUAE_ONMYFRIENDLYNAMECHANGE	  0x405
#define DISPID_MUAE_ONUSERSTATECHANGE		  0x406
#define DISPID_MUAE_ONMYSTATECHANGE 		  0x407
#define DISPID_MUAE_ONAPPSHUTDOWN			  0x408
#define DISPID_MUAE_ONMYPROPERTYCHANGE		  0x409
#define DISPID_MUAE_ONUSERPROPERTYCHANGE	  0x40a
#define DISPID_MUAE_ONUSERBLOCKCHANGE		  0x40b
#define DISPID_MUAE_ONUSERPAGERCHANGE		  0x40c
#define DISPID_MUAE_ONUSERPHONECHANGE		  0x40d
#define DISPID_MUAE_ONMYPHONECHANGE 		  0x40e
#define DISPID_MUAE_ONUNREADEMAILCHANGE 	  0x40f

//
// Dispatch IDs for IMessenger
//
#define DISPID_MUAM_RECEIVEDIR				 0x500
#define DISPID_MUAM_STARTVOICE				 0x501
#define DISPID_MUAM_FRIENDLYNAME			 0x502
#define DISPID_MUAM_WINDOW					 0x503
#define DISPID_MUAM_UNREADEMAILCOUNT		 0x504
#define DISPID_MUAM_VIEWPROFILE 			 0x505
#define DISPID_MUAM_GETCONTACT	 			 0x506
#define DISPID_MUAM_OPTIONUI				 0x507
#define DISPID_MUAM_ADDUI					 0x508
#define DISPID_MUAM_FINDUI					 0x509
#define DISPID_MUAM_INSTANTMESSAGE			 0x50a
#define DISPID_MUAM_SIGNOUT 				 0x50b
#define DISPID_MUAM_SENDFILE				 0x50c
#define DISPID_MUAM_OPENINBOX				 0x50d
#define DISPID_MUAM_MYSERVICENAME			 0x50e
#define DISPID_MUAM_INVITEAPP				 0x50f
#define DISPID_MUAM_MYPHONENUMBER			 0x510
#define DISPID_MUAM_SIGNIN					 0x511
#define DISPID_MUAM_SENDMAIL				 0x512
#define DISPID_MUAM_AUTOSIGNIN				 0x513
#define DISPID_MUAM_PHONEUI 				 0x514
#define DISPID_MUAM_AUDIOUI 				 0x515
#define DISPID_MUAM_PAGERUI 				 0x516
#define DISPID_MUAM_CONTACTS				 0x517
#define DISPID_MUAM_SIGNINNAME				 0x518
#define DISPID_MUAM_STATUS					 0x519
#define DISPID_MUAM_MYPROPERTY				 0x51a
#define DISPID_MUAM_SERVICEID				 0x51b
#define DISPID_MUAM_SERVICES	 			 0x51c


//
// Dispatch IDs for IMessengerContact
//

#define DISPID_MUAC_FRIENDLYNAME			 0x600
#define DISPID_MUAC_STATUS					 0x601
#define DISPID_MUAC_SIGNINNAME				 0x602
#define DISPID_MUAC_SERVICENAME 			 0x603
#define DISPID_MUAC_BLOCK					 0x604
#define DISPID_MUAC_ISSELF					 0x605
#define DISPID_MUAC_PROPERTY				 0x606
#define DISPID_MUAC_CANPAGE 				 0x607
#define DISPID_MUAC_PHONENUMBER 			 0x608
#define DISPID_MUAC_SERVICEID				 0x609


//
// Dispatch IDs for IMessengerContacts
//

#define DISPID_MUAC_COUNT					 0x700
#define DISPID_MUAC_REMOVE					 0x701


//
// Dispatch IDs for IMessengerWindow
//

#define DISPID_MUAW_HWND					0x800
#define DISPID_MUAW_LEFT					0x801
#define DISPID_MUAW_TOP 					0x802
#define DISPID_MUAW_WIDTH					0x803
#define DISPID_MUAW_HEIGHT					0x804
#define DISPID_MUAW_CLOSE					0x805
#define DISPID_MUAW_SHOW					0x806
#define DISPID_MUAW_ISCLOSED				0x807
#define DISPID_MUAW_PROPERTY				0x808

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\setup\makefile.inc ===
gocab:
	del rcBuddy.cab
	cabarc -s 6144 n rcBuddy.cab ..\UI_B2\*.htm ..\UI_B2\*.gif ..\UI_B2\*.png ..\UI_B2\*.css *.xml ..\..\rctool\UI_B2\*.htm ..\..\rctool\UI_B2\*.gif ..\..\rctool\UI_B2\*.js ..\..\rctool\UI_B2\*.css ..\..\rctool\UI_B2\*.xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\bdychannel\im_inc\mdispid.h ===
#ifndef _MDISPID_H_
#define _MDISPID_H_

//
// Dispatch IDs for DMsgrObjectEvents Dispatch Events.
//
#define DISPID_ONLOGONRESULT				  100
#define DISPID_ONLOGOFF 					  101
#define DISPID_ONLISTADDRESULT				  102
#define DISPID_ONLISTREMOVERESULT			  103
#define DISPID_ONMESSAGEPRIVACYCHANGERESULT   104
#define DISPID_ONPROMPTCHANGERESULT 		  105
#define DISPID_ONUSERFRIENDLYNAMECHANGERESULT 106
#define DISPID_ONUSERSTATECHANGED			  107
#define DISPID_ONTEXTRECEIVED				  108
#define DISPID_ONLOCALFRIENDLYNAMECHANGERESULT 109
#define DISPID_ONLOCALSTATECHANGERESULT 	  110
#define DISPID_ONAPPINVITERECEIVED			  111
#define DISPID_ONAPPINVITEACCEPTED			  112
#define DISPID_ONAPPINVITECANCELLED 		  113
#define DISPID_ONSENDRESULT 				  114
#define DISPID_ONNEWERCLIENTAVAILABLE		  115
#define DISPID_ONFINDRESULT 				  116
#define DISPID_ONINVITEMAILRESULT			  117
#define DISPID_ONREQUESTURLRESULT			  118
#define DISPID_ONSESSIONSTATECHANGE 		  119
#define DISPID_ONUSERJOIN					  120
#define DISPID_ONUSERLEAVE					  121
#define DISPID_ONNEWSESSIONREQUEST			  122
#define DISPID_ONINVITEUSER 				  123
#define DISPID_ONSERVICELOGOFF				  124
#define DISPID_ONPRIMARYSERVICECHANGED		  125
#define DISPID_ONAPPSHUTDOWN				  126
#define DISPID_ONUNREADEMAILCHANGED 		  127
#define DISPID_ONUSERDROPPED				  128
#define DISPID_ONREQUESTURLPOSTRESULT		  129
#define DISPID_ONNEWERSITESAVAILABLE		  130
#define DISPID_ONTRUSTCHANGED				  131
#define DISPID_ONFILETRANSFERINVITERECEIVED   132
#define DISPID_ONFILETRANSFERINVITEACCEPTED   133
#define DISPID_ONFILETRANSFERINVITECANCELLED  134
#define DISPID_ONFILETRANSFERCANCELLED		  135
#define DISPID_ONFILETRANSFERSTATUSCHANGE	  136
#define DISPID_ONSPMESSAGERECEIVED			  137
#define DISPID_ONLOCALPROPERTYCHANGERESULT	  141
#define DISPID_ONBUDDYPROPERTYCHANGERESULT	  142
#define DISPID_ONNOTIFICATIONRECEIVED		  143
#define DISPID_ONPAGERECEIVED				  144
#define DISPID_ONLOCKCHALLENGE			145
#define DISPID_ONLOCKRESULT 			146
#define DISPID_ONLOCKENABLE 			147


//
// Dispatch IDs for DMessengerAppEvents Dispatch Events.
// (don't overlap DMsgrObjectEvents ids)
//
#define DISPID_ONBEFORELAUNCHIMUI			20000
#define DISPID_ONSHOWIMUI					20001
#define DISPID_ONDESTROYIMUI				20002
#define DISPID_ONINDICATEMESSAGERECEIVED	20003
#define DISPID_ONSTATUSTEXT 				20004
#define DISPID_ONTITLEBARTEXT				20005
#define DISPID_ONINFOBARTEXT				20006
#define DISPID_ONSENDENABLED				20007
#define DISPID_ONTRANSLATEACCELERATOR		20008
#define DISPID_ONFILETRANSFER				20009
#define DISPID_ONVOICESESSIONSTATE			20010
#define DISPID_ONVOICEVOLUMECHANGED 		20011
#define DISPID_ONMICROPHONEMUTE 			20012

//
// Dispatch IDs for IMsgrObject.
//
#define DISPID_CREATEUSER					  100
#define DISPID_LOGON						  104
#define DISPID_LOGOFF						  105
#define DISPID_GETLIST						  0x60020003
#define DISPID_LOCALLOGONNAME				  0x60020004
#define DISPID_LOCALFRIENDLYNAME			  0x60020005
#define DISPID_LOCALSTATE					  0x60020006
#define DISPID_MESSAGEPRIVACY				  0x60020008
#define DISPID_PROMPT						  0x6002000a
#define DISPID_SENDAPPINVITE				  108
#define DISPID_SENDAPPINVITEACCEPT			  109
#define DISPID_SENDAPPINVITECANCEL			  110
#define DISPID_LOCALOPTION					  0x6002000f
#define DISPID_FINDUSER 					  111
#define DISPID_SENDINVITEMAIL				  112
#define DISPID_REQUESTURL					  113
#define DISPID_IMSESSIONS					  0x60020014
#define DISPID_CREATEIMSESSIONS 			  114
#define DISPID_SESSIONREQUESTACCEPT 		  115
#define DISPID_SESSIONREQUESTCANCEL 		  116
#define DISPID_SERVICES 					  0x60020018
#define DISPID_UNREADEMAIL					  0x60020019
#define DISPID_SENDFILETRANSFERINVITE		  117
#define DISPID_SENDFILETRANSFERINVITEACCEPT   118
#define DISPID_SENDFILETRANSFERINVITECANCEL   119
#define DISPID_CANCELFILETRANSFER			  120
#define DISPID_FILETRANSFERSTATUS			  121


//
// Dispatch IDs for IMessengerApp.
//
#define DISPID_APPLICATION					  0x60020000
#define DISPID_PARENT						  0x60020001
#define DISPID_QUIT 						  100
#define DISPID_NAME 						  0x60020003
#define DISPID_FULLNAME 					  0x60020004
#define DISPID_PATH 						  0x60020005
#define DISPID_LAUNCHLOGONUI				  200
#define DISPID_LAUNCHOPTIONSUI				  201
#define DISPID_LAUNCHADDCONTACTUI			  202
#define DISPID_LAUNCHFINDCONTACTUI			  203
#define DISPID_LAUNCHIMUI					  210
#define DISPID_IMWINDOWS					  0x6002000b
#define DISPID_TOOLBAR						  0x6002000c
#define DISPID_STATUSBAR					  0x6002000e
#define DISPID_STATUSTEXT					  0x60020010
#define DISPID_GETHWND						  0x60020012
#define DISPID_LEFT 						  0x60020013
#define DISPID_TOP							  0x60020015
#define DISPID_WIDTH						  0x60020017
#define DISPID_HEIGHT						  0x60020019
#define DISPID_MSGS_VISIBLE 				  0x6002001b
#define DISPID_AUTOLOGON					  222
#define DISPID_FIRSTTIMECREDENTIONS 		  0x6002001e
#define DISPID_CACHEDPASSWORD				  0x6002001f
#define DISPID_REQUESTURLPOST				  223
#define DISPID_MSGS_TASKBARICON 			  224

//
// Dispatch IDs for IMessengerApp2.
//
#define DISPID_LAUNCHPHONEUI				  225
#define DISPID_LAUNCHAUDIOWIZARD			  226

//
// Dispatch IDs for IMessengerApp3
//
#define DISPID_LAUNCHPAGERUI				  227


//
// Dispatch IDs for IMsgrUser.
//
#define DISPID_USERFRIENDLYNAME 			  0x60020000
#define DISPID_USEREMAILADDRESS 			  0x60020002
#define DISPID_USERSTATE					  0x60020003
#define DISPID_USERLOGONNAME				  0x60020004
#define DISPID_USERSENDTEXT 				  101
#define DISPID_USERSERVICE					  0x60020006

//
// Dispatch IDs for IMsgrUsers.
//
#define DISPID_USERSCOUNT					  0x60020000
#define DISPID_USERSADD 					  100
#define DISPID_USERSREMOVE					  101

//
// Dispatch IDs for IMsgrService.
//
#define DISPID_SERVICESERVICENAME			  0x60020000
#define DISPID_SERVICELOGONNAME 			  0x60020001
#define DISPID_SERVICEFRIENDLYNAME			  0x60020002
#define DISPID_SERVICECAPABILITIES			  0x60020004
#define DISPID_SERVICESTATUS				  0x60020005
#define DISPID_SERVICELOGOFF				  0x60020006
#define DISPID_SERVICEFINDUSER				  0x60020007
#define DISPID_SERVICESENDINVITEMAIL		  0x60020008
#define DISPID_SERVICEREQUESTURL			  0x60020009
#define DISPID_SERVICEPROFILEFIELD			  0x6002000a

//
// Dispatch IDs for IMsgrServices.
//
#define DISPID_SERVICESPRIMARYSERVICE		  0x60020000
#define DISPID_SERVICESCOUNT				  0x60020002

//
// Dispatch IDs for DMsgrSessionManagerEvents and DMsgrSessionEvents
//
#define DISPID_ONINVITATION 			100
#define DISPID_ONAPPREGISTERED			101
#define DISPID_ONAPPUNREGISTERED		102
#define DISPID_ONSTATECHANGED			103
#define DISPID_ONAPPNOTPRESENT			104
#define DISPID_ONACCEPTED				105
#define DISPID_ONDECLINED				106
#define DISPID_ONCANCELLED				107
#define DISPID_ONTERMINATION			108
#define DISPID_ONREADYTOLAUNCH			109
#define DISPID_ONCONTEXTDATA			110
#define DISPID_ONSENDERROR				111

#endif // ! _MDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\include\common.inc ===
#define MAC_IF_DIRECTLAUNCH_CLIENT if(null==parent.idFrameSet1)
#define MAC_IF_DIRECTLAUNCH_SERVER if(null==parent.OnLoad1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\escalation\makefile.inc ===
!INCLUDE ..\include\makefile.pl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\include\debug_decl.inc ===
#ifndef DEBUG
#define EndTrace()
#define DebugTrace( szMsg )
#define TraceFunctEnter( szFuncName )
#define TraceFunctLeave()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\interaction\makefile.inc ===
!INCLUDE ..\include\makefile.pl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\include\constants.inc ===
#if DEBUG
#define REMOTE_ASSISTANCE Remote Assistance Debug
#else
#define REMOTE_ASSISTANCE Remote Assistance
#endif

#define REMOTE_ASSISTANCE_MAIN		Remote Assistance - Options
#define REMOTE_ASSISTANCE_INVITE	Remote Assistance - Invite a helper
#define REMOTE_ASSISTANCE_STATUS	Remote Assistance - Invitation Status

//
// Version Information
//
#define c_szSchema					 "SCHEMAVERSION"
#define c_szControlChannel			 "CONTROLCHANNELVERSION"
#define c_szHelperVersion			 "HELPERVERSION"
#define c_szSchemaVersion			 "5.1"
#define c_szControlChannelVersion	 "5.1"
#define g_bVersionCheckEnforced		 false

//
// Constants
//
#define c_szChatChannelID			 "70"
#define	c_szControlChannelID		 "71"
#define c_szHomePage				 "hcp://system/HomePage.htm"
#define c_szRCCommand				 "RCCOMMAND"
#define c_szRCCommandName			 "NAME"
#define c_szScreenInfo				 "SCREENINFO"
#define c_szDisconnect				 "DISCONNECT"
#define c_szWidth					 "WIDTH"
#define c_szHeight					 "HEIGHT"
#define c_szColorDepth				 "COLORDEPTH"
#define c_szwinName					 "Windows Remote Assistance Tool"
#define c_szDisconnectRC			 "DISCONNECTRC"
#define c_szRejectRC				 "REJECTRC"
#define c_szAcceptRC				 "ACCEPTRC"
#define c_szDeniedRC				 "DENIEDRC"
#define c_szErrorRC                  "ERRORRC"
#define c_szEscRC                    "ESCRC"
#define c_szAbortRC	 			"ABORTRC"
#define c_szTakeControl				 "TAKECONTROL"
#define c_szFileXfer				 "FILEXFER"
#define c_szFileName				 "FILENAME"
#define c_szFileSize				 "FILESIZE"
#define c_szChannelId				 "CHANNELID"
#define c_szRemoteCtrlStart			 "REMOTECTRLSTART"
#define c_szRemoteCtrlEnd			 "REMOTECTRLEND"
#define c_szRCMODE					 "Connected in REMOTE ASSISTANCE Mode"
#define c_szCHATMODE				 "Connected in CHAT Mode"
#define c_szFileXferACK				 "FILEXFERACK"
#define c_szFileXferREJECT			 "FILEXFERREJECT"
#define c_szFileXferEND				 "FILEXFEREND"
#define c_MAXFILEXFERSIZE			 102400
#define c_FILEXFERPKTGAP             1
#define c_szURC						 "URC"
#define c_szSHOWCHAT				 "SHOWCHAT"
#define c_szHIDECHAT				 "HIDECHAT"
#define c_FileXferWidth				 "405"
#define c_FileXferHeight			 "179"
#define c_RCChatWidth				 "384"
#define c_RCChatHeight				 "528"
#define c_RCControlWidth			 (2*(window.screen.availWidth/3))
#define c_RCControlHeight			 "100"

#define c_RCControlHiddenWidth		 "100"
#define c_RCControlHiddenHeight		 "325"

#define c_szVoipPreStart			 "PRESTART"
#define c_szVoipPreStartYes			 "PRESTARTYES"
#define c_szVoipPreStartNo			 "PRESTARTNO"
#define c_szVoipDisable				 "DISABLEVOICE"
#define c_szVoipGo					 "VOIPGO"
#define c_szVoipGoKey                "VOIPGOKEY"
#define c_szVoipIPList               "VOIPIPLIST"
#define c_szVoipVer					 "VOIPVER"
#define c_szVoipPreGo				 "VOIPPREGO"
#define c_szVoipPreGo2				 "VOIPPREGO2"
#define c_szVoipQNo					 "VOIPQNO"
#define c_szVoipGoNo				 "VOIPGONO"
#define c_szVoipGoFail				 "VOIPGOFAIL"
#define c_szVoipWizardGood           "WIZARDGOOD"
#define c_szVoipWizardBad			 "WIZARDBAD"
#define c_szVoipBandwidthToHigh		 "BANDWTOHIGH"
#define c_szVoipBandwidthToLow		 "BANDWTOLOW"
#define c_szVoipVersion2			 "VOIPVER2"

#define c_szTYPINGSTART              "TYPINGSTART"

#ifdef _PERF_OPTIMIZATIONS
#define c_szFileXferURL			 "hcp://system/Remote Assistance/Interaction/Common/RCFileXfer.htm"
#define c_szMsgURL				 "hcp://system/Remote Assistance/Interaction/Common/ErrorMsgs.htm"
#define c_szVOIPMsgURL			 "hcp://system/Remote Assistance/Interaction/Common/VOIPMsgs.htm"
#else
#define c_szFileXferURL			 "hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/Interaction/Common/RCFileXfer.htm"
#define c_szMsgURL				 "hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/Interaction/Common/ErrorMsgs.htm"
#define c_szVOIPMsgURL			 "hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/Interaction/Common/VOIPMsgs.htm"
#endif
#define c_szMsgSpecs             "dialogwidth:405px;dialogHeight:165px;status:no;resizable:no;help:no"
#define c_szTCMsgSpecs           "dialogwidth:470px;dialogHeight:188px;status:no;resizable:no;help:no"
#define c_szTakeControlSpecs     "dialogwidth:405px;dialogHeight:270px;status:no;resizeable:no;help:no" 

#define c_szNOIncidentFile		 "NOFILE"

#define c_szLISTEN               "LISTEN"

#define c_iCONNECTION_TIMEOUT	 20000

//
// Object ProgIDs
//
#define szProgIDPanic               "SAFRCFileDlg.Panic"
#define szProgIDSetting             "SAFRCFileDlg.RASetting"
#define szProgIDEscalationSetting   "rcbdyctl.Setting"

#define c_szREGDebugSpew            "HKLM\\SOFTWARE\\Microsoft\\PCHealth\\HelpCtr\\SAFSessionResolver\\DebugSpew"

#ifdef _BVT
#define c_szChatBVT                 "!!!!!!!!!!!@@@@@@@@@@ CHAT BVT @@@@@@@@@@!!!!!!!!!!!"
#define c_szTakeControlBVT          "!!!!!!!!!!!@@@@@@@@@@ TAKE CONTROL BVT @@@@@@@@@@!!!!!!!!!!!"
#define c_szReleaseControlBVT       "!!!!!!!!!!!@@@@@@@@@@ RELEASE CONTROL BVT @@@@@@@@@@!!!!!!!!!!!"
#define c_szDisconnectBVT           "!!!!!!!!!!!@@@@@@@@@@ DISCONNECT BVT @@@@@@@@@@!!!!!!!!!!!"
#define c_szBVTPASS                 "!!!!!!!!!!!@@@@@@@@@@ PASS @@@@@@@@@@!!!!!!!!!!!"
#define c_szBVTFAIL                 "!!!!!!!!!!!@@@@@@@@@@ FAIL @@@@@@@@@@!!!!!!!!!!!"
#define c_szPASS                    " PASS "
#define c_szFAIL                    " FAIL "
#define c_szBVTTESTER               "{683EA56F-546F-44e0-81D4-AC683E50757B}"
#define c_szBVTUSER                 " BVT "
#endif

//error messages

#define c_szError1					"A program has stopped responding.Please try again."
#define c_szError2					"A program could not start.Please try again."
#define c_szError3					"A program has stopped responding.Please restart the program and try again."
#define c_szVoiceError				"The necessary hardware and/or configuration to use a voice connection is not available;'Start Talking' will be disabled for the remainder of this Remote Assistance session."
#define c_szVoiceConnError			"A voice connection could not be established. Please try again later.";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\redist\makefile.inc ===
!INCLUDE ..\include\makefile.pl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\include\header.inc ===
// This file contain the header disclaimer for all RA htm files

<!--
Copyright (c) 2000 Microsoft Corporation
-->
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\cpl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__FEE2BF2D_1AE5_4E56_BE33_028D54A4A72F__INCLUDED_)
#define AFX_STDAFX_H__FEE2BF2D_1AE5_4E56_BE33_028D54A4A72F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <afx.h>
#include <assert.h>
#include <atlbase.h>
 

#endif // !defined(AFX_STDAFX_H__FEE2BF2D_1AE5_4E56_BE33_028D54A4A72F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\cpl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	RCOptions.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\cpl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RCOptions.rc
//
#define IDS_INFO                        1
#define IDS_NAME                        2
#define IDACCEPT                        3
#define IDD_SETOPTIONS                  203
#define ID_ICON                         204
#define IDC_DATA_COLLECTION             209
#define IDC_UNATTENDED                  210
#define IDC_ENABLE_RC                   211
#define IDC_DISABLE_RC                  212
#define IDC_SHADOW_ONLY                 213
#define IDC_SPIN1                       214
#define IDC_PASSWD_ENCRYPT_REQD         214
#define IDC_EDIT1                       215
#define IDC_MAXIMUM_TICKET_TIMEOUT      215

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         220
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\cpl\rcoptions.cpp ===
// RCOptions.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include <afx.h>
#include <CPL.H>
#include <windows.h>
#include "resource.h"
#include <stdio.h>
#include <RACPLSettings.h>

CRegKey g_cRegKey;

static HINSTANCE g_hInstance;
 
HMODULE g_hRASettings = NULL;
pfnOpenRACPLSettings    g_pfnOpen   = NULL;
pfnCloseRACPLSettings   g_pfnClose  = NULL;
pfnGetRACPLSettings     g_pfnGet    = NULL;
pfnSetRACPLSettings     g_pfnSet    = NULL;

RACPLSETTINGS           g_RACPLSettings;

#define	REG_VALUE_DATA_COLLECTION	_T("RDC")
#define REG_VALUE_PWD_ENCRYPT		_T("PasswdEncryt")
#define	REG_BINARY_VALUE_NOTSET_RC		0



//
// Globals
//
TCHAR   szMaxTimeOut[MAX_PATH];

DWORD   dwDataCollection	= 0;
DWORD   dwEnableRC			= REG_DWORD_RA_DISABLED;
DWORD   dwUnSolicited		= 0;
DWORD   dwMaxTicket         = 0;
DWORD   dwTrue			    = 1;
DWORD   dwFalse			    = 0;
DWORD   dwPasswdEncrypt		= 0;


DWORD  InitDialog( HWND hwndDlg )
{
    DWORD   dwRetVal = S_OK;
    TCHAR   szError[128];

    g_hRASettings = LoadLibrary( _T("RACPLSettings.dll") );
    if(NULL == g_hRASettings)
    {
        //
        // Error
        //
        _stprintf(szError, L"Error: %ld", GetLastError());
        MessageBox( GetFocus(), szError, _T("LoadLibrary failed"), 0);
        ExitThread(0);
    }

    g_pfnOpen = (pfnOpenRACPLSettings)GetProcAddress( g_hRASettings,  "OpenRACPLSettings"  );
    if(NULL == g_pfnOpen)
    {
        //
        // Error
        //
        _stprintf(szError, L"Error: %ld", GetLastError());
        MessageBox( GetFocus(), szError, _T("Failed to GetProcAddress of OpenRACPLSettings") , 0);
        ExitThread(0);
    }

    g_pfnClose = (pfnCloseRACPLSettings)GetProcAddress( g_hRASettings,  "CloseRACPLSettings"  );
    if(NULL == g_pfnClose)
    {
        //
        // Error
        //
        _stprintf(szError, L"Error: %ld", GetLastError());
        MessageBox( GetFocus(), szError, _T("Failed to GetProcAddress of CloseRACPLSettings") , 0);
        ExitThread(0);
    }

    g_pfnGet = (pfnGetRACPLSettings)GetProcAddress( g_hRASettings,  "GetRACPLSettings"  );
    if(NULL == g_pfnGet)
    {
        //
        // Error
        //
        _stprintf(szError, L"Error: %ld", GetLastError());
        MessageBox( GetFocus(), szError, _T("Failed to GetProcAddress of GetRACPLSettings"),   0);
        ExitThread(0);
    }


    g_pfnSet = (pfnSetRACPLSettings)GetProcAddress( g_hRASettings,  "SetRACPLSettings"  );
    if(NULL == g_pfnSet )
    {
        //
        // Error
        //
        _stprintf(szError, L"Error: %ld", GetLastError());
        MessageBox( GetFocus(),szError, _T("Failed to GetProcAddress of SetRACPLSettings"),  0);
        ExitThread(0);
    }


    //
    // Open the RACPLSettings
    //
    g_pfnOpen();

    //
    // Load the settings
    //
    dwRetVal = g_pfnGet(&g_RACPLSettings);
    if(S_OK != dwRetVal)
    {
        //
        // Error
        //
        _stprintf(szError, L"Error: %ld", GetLastError());
        MessageBox( GetFocus(), szError, _T("GetRACPLSettings failed"),  0);
        ExitThread(0);
    }

    //
    // Remote Assistance Mode
    //
    switch(g_RACPLSettings.dwMode)
	{
		case REG_DWORD_RA_DISABLED:
			CheckDlgButton(hwndDlg ,IDC_DISABLE_RC,BST_CHECKED);
			break;
		case REG_DWORD_RA_ENABLED:
			CheckDlgButton(hwndDlg ,IDC_ENABLE_RC,BST_CHECKED);
			break;
		case REG_DWORD_RA_SHADOWONLY:
			CheckDlgButton(hwndDlg ,IDC_SHADOW_ONLY,BST_CHECKED);
			break;
		default:
            _stprintf(szError, L"Unknown Remote Assitance Mode in registry", GetLastError());
            MessageBox( GetFocus(), szError, _T("Remote Assistance Mode"),  0);
			break;
    }

    //
    // Allow Unsolicited Remote Assistance
    //
    if (g_RACPLSettings.dwUnsolicited == REG_DWORD_RA_ALLOW)
    {
		CheckDlgButton(hwndDlg ,IDC_UNATTENDED,BST_CHECKED);
    }
	else if (g_RACPLSettings.dwUnsolicited == REG_DWORD_RA_DISALLOW)
    {
		CheckDlgButton(hwndDlg ,IDC_UNATTENDED,BST_UNCHECKED);
    }
    else
    {
        _stprintf(szError, L"Unknown Allow unsolicited RA value in registry", GetLastError());
        MessageBox( GetFocus(), szError, _T("Remote Assistance Mode"),  0);
    }


    //
    // Maximum Ticket Timeout
    //
    _stprintf(szMaxTimeOut, L"%d", g_RACPLSettings.dwMaxTimeout);
    SetWindowText(GetDlgItem(hwndDlg ,IDC_MAXIMUM_TICKET_TIMEOUT),  szMaxTimeOut);

    return dwRetVal;
}


DWORD  CommitChanges( HWND hwndDlg )
{
    DWORD   dwRetVal = S_OK;
    DWORD   dwTimeout = 0;

    //
    // Remote Assistance Mode
    //
    if (IsDlgButtonChecked(hwndDlg, IDC_ENABLE_RC) == BST_CHECKED)
    {
        g_RACPLSettings.dwMode = REG_DWORD_RA_ENABLED;
    }
    else if (IsDlgButtonChecked(hwndDlg, IDC_DISABLE_RC) == BST_CHECKED)
    {
        g_RACPLSettings.dwMode = REG_DWORD_RA_DISABLED;
    }
    else 
    {
        g_RACPLSettings.dwMode = REG_DWORD_RA_SHADOWONLY;
    }

    //
    // Allow Unsolicited Remote Assistance
    //
    if (IsDlgButtonChecked(hwndDlg, IDC_UNATTENDED) == BST_CHECKED)
    {
		g_RACPLSettings.dwUnsolicited = REG_DWORD_RA_ALLOW;
    }
	else
    {
		g_RACPLSettings.dwUnsolicited = REG_DWORD_RA_DISALLOW;
    }

    //
    // Ticket Timeout
    //
    GetWindowText(GetDlgItem(hwndDlg ,IDC_MAXIMUM_TICKET_TIMEOUT),  szMaxTimeOut, MAX_PATH);
    _stscanf( szMaxTimeOut, _T("%d"), &dwTimeout );
    g_RACPLSettings.dwMaxTimeout = dwTimeout;

    
    //
    // Write the settings to registry
    //
    if( S_OK != g_pfnSet( &g_RACPLSettings ))
    {
        //
        // Error
        //
        MessageBox( GetFocus(), _T("SetRACPLSettings failed"), _T("Error"), 0);
    }

    return dwRetVal;
}

// **************************************************************************
INT_PTR CALLBACK DialogBoxCallBack(HWND hwndDlg, UINT uMsg, WPARAM wParam, 
                             LPARAM lParam)
{
    WORD    wRes = 0;
	DWORD   dwRetVal = S_OK;
    TCHAR szError[128];

    switch(uMsg)
    {
        case WM_COMMAND:
		 
            wRes = LOWORD(wParam);
            switch(LOWORD(wParam))
            {
				case IDACCEPT:
					CommitChanges( hwndDlg );

					EnableWindow(GetDlgItem(hwndDlg ,IDACCEPT),false);
					break;

				case IDOK:
					 
					CommitChanges( hwndDlg );

                    //
                    // Close down RACPLSettings API
                    //
                    g_pfnClose();
					EndDialog(hwndDlg, wRes);

                    break;

				case IDC_UNATTENDED:
 
					EnableWindow(GetDlgItem(hwndDlg ,IDACCEPT),true);
					break;

                case IDCANCEL:
					 
					EndDialog(hwndDlg, wRes);
                    break;


				case IDC_ENABLE_RC:
					 
					dwEnableRC = REG_DWORD_RA_ENABLED;
					EnableWindow(GetDlgItem(hwndDlg ,IDACCEPT),true);
					break;

				case IDC_DISABLE_RC:
 
					dwEnableRC = REG_DWORD_RA_DISABLED;
					EnableWindow(GetDlgItem(hwndDlg ,IDACCEPT),true);
					break;
 
				case IDC_SHADOW_ONLY:
 
					dwEnableRC = REG_DWORD_RA_SHADOWONLY;
					EnableWindow(GetDlgItem(hwndDlg ,IDACCEPT),true);
					break;
				
				case IDC_MAXIMUM_TICKET_TIMEOUT:
 
					GetWindowText(GetDlgItem(hwndDlg ,IDC_MAXIMUM_TICKET_TIMEOUT),  szMaxTimeOut,MAX_PATH);
					EnableWindow(GetDlgItem(hwndDlg ,IDACCEPT),true);
					break;
				
				default:
					break;
                    
            }

            break;  

        case WM_INITDIALOG:
             
            InitDialog( hwndDlg );

			 
            break;
    }
    
    return FALSE;
}

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    g_hInstance = hInstance;
	return TRUE;
}

 
LONG  CPlApplet(
    HWND hwndCPl,
    UINT uMsg,
    LONG lParam1,
    LONG lParam2
)
{
    INT_PTR	nResDlg = NULL;
    LPCPLINFO lpCPlInfo;

	
	switch (uMsg)
    {
        case ( CPL_INIT ) :
        {
          return true;
        }
        case ( CPL_EXIT ) :
        {
            break;
        }
        case ( CPL_STOP ) :
        {
            break;
        }
        case ( CPL_GETCOUNT ) :
        {
           return 1;
        }
        case ( CPL_INQUIRE ) :
        {
            lpCPlInfo = (LPCPLINFO)lParam2;

            lpCPlInfo->idIcon = ID_ICON;
            lpCPlInfo->idName = IDS_NAME;
            lpCPlInfo->idInfo = IDS_INFO;


          return true;
        }
        case ( CPL_NEWINQUIRE ) :
        {
           return true;
        }
        case ( CPL_DBLCLK ) :
        case ( CPL_STARTWPARMS ) :

        {
 			nResDlg = DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_SETOPTIONS), NULL,
                                      (int (__stdcall *)(struct HWND__ *,unsigned int,unsigned int,long))DialogBoxCallBack);
			return true;
        }
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\rchandler\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\rchandler\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rcHandler.rc
//
#define IDS_PROJNAME                    100
#define IDR_RCULPROVIDER                101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\rchandler\dll\rculprovider.h ===
// RcULProvider.h : Declaration of the CRcULProvider

#ifndef __RCULPROVIDER_H_
#define __RCULPROVIDER_H_

#include "resource.h"       // main symbols


#include <msxml.h>
#include <comdef.h>


/////////////////////////////////////////////////////////////////////////////
// CRcULProvider
class ATL_NO_VTABLE CRcULProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRcULProvider, &CLSID_RcULProvider>,
	public IULProvider 
{
public:
	CRcULProvider()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_RCULPROVIDER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRcULProvider)
	COM_INTERFACE_ENTRY(IULProvider)
END_COM_MAP()

// IULProvider
public:
    STDMETHOD(TransferComplete)(IULServer *pSrv, IULSession *pJob);
    STDMETHOD(DataAvailable)(IULServer *pSrv, IULSession *pJob);
    STDMETHOD(ValidateClient)(IULServer *pSrv, IULSession *pJob);
};

#endif //__RCULPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\rchandler\dll\rculprovider.cpp ===
// RcULProvider.cpp : Implementation of CRcULProvider

#include "stdafx.h"

//#import "c:\program files\common files\system\ado\msado15.dll" no_namespace rename("EOF", "adoEOF") implementation_only
#include "RcHandler.h"
#include "RcULProvider.h"
//#include <adoid.h>
//#include <adoint.h>



/*static _variant_t GetXmlValues (IXMLDOMDocument *pxdDoc,
								_bstr_t sElement, 
								_bstr_t sAttr, 
								HRESULT *hr);
static HRESULT UploadRCData (_variant_t vtType,
								_variant_t vtName,
								_variant_t vtDesc,
								_variant_t vtShareLoc);

#define __UNICODE_MARKER_ 0xfeff


struct InitOle {
InitOle()  { ::CoInitialize(NULL); }
~InitOle() { ::CoUninitialize();   }
} _init_InitOle_; 

*/
/////////////////////////////////////////////////////////////////////////////
// CRcULProvider

HRESULT CRcULProvider::ValidateClient(IULServer* pServer, IULSession* pJob)
{
    // This is not used for this provider
    return NOERROR;
}

HRESULT CRcULProvider::DataAvailable(IULServer* pServer, IULSession* pJob)
{
    // This is not used for this provider
    return NOERROR;
}

HRESULT CRcULProvider::TransferComplete(IULServer* pSrv, IULSession* pJob)
{
    HRESULT         hr = NOERROR;
    IStream         *pStm = NULL;
    DWORD           dwPassHigh, dwPassLow, cbAvail;
	
	
/*	LARGE_INTEGER	liSeekPos = {0, 0};
	ULARGE_INTEGER	luNewPos;
	WCHAR			*xmlString = NULL;
	STATSTG			statIStream;
	ULONG			iStmSize, cbRead;
	VARIANT_BOOL	vtbRes;

	CComPtr<IXMLDOMDocument>		pxdDoc;
	_variant_t vtTypeVal, vtNameVal, vtDescVal, vtShareLocation;
	

    if (pSrv == NULL || pJob == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = pJob->get_SizeAvailable(&cbAvail);
    if (FAILED(hr) || cbAvail <=0 )
    {
        hr = E_FAIL;
        goto done;
    }

    hr = pJob->get_Data(&pStm);
    if (FAILED(hr))
    {
        // No data available
        hr = E_FAIL;
        goto done;
    }

	
	// Get the size of the stream
	hr = pStm->Seek (liSeekPos, STREAM_SEEK_END, &luNewPos);
	if (hr != S_OK)
		goto done;

	hr = pStm->Stat (&statIStream, STATFLAG_NONAME);
	if (hr != S_OK)
		goto done;
		
	iStmSize = (int) statIStream.cbSize.QuadPart;
	xmlString = (WCHAR *) malloc (iStmSize);
	if (xmlString == (WCHAR *) NULL)
		goto done;

	//Rewind and read from the stream
	hr = pStm->Seek (liSeekPos, STREAM_SEEK_SET, &luNewPos);
	if (hr != S_OK)
		goto done;
	_ASSERT (liSeekPos.QuadPart == luNewPos.QuadPart);

	hr = pStm->Read (xmlString, iStmSize, &cbRead);
	if (hr != S_OK)
		goto done;
	_ASSERT (stmSize == cbRead);

	hr = CoCreateInstance(CLSID_DOMDocument, NULL, 
							CLSCTX_INPROC_SERVER,
							IID_IXMLDOMDocument, 
							(void**)&pxdDoc);
	if (hr != S_OK)
		goto done;

	// Read the xml string into the xml document
	if (*(xmlString+0) == __UNICODE_MARKER_)
		hr = pxdDoc->loadXML ((xmlString+1), &vtbRes);
	else
		hr = pxdDoc->loadXML (xmlString, &vtbRes);

	if (hr != S_OK || vtbRes != VARIANT_TRUE)
		goto done;
	// Don't know if we need the Type value at all.
	// There's only one type that we handle now
	vtTypeVal = GetXmlValues (pxdDoc, L"UPLOADINFO", L"TYPE", &hr);
	if (hr != S_OK)
		goto done;
		
	vtNameVal = GetXmlValues (pxdDoc, L"UPLOADDATA", L"USERNAME", &hr);
	if (hr != S_OK)
		goto done;

	vtDescVal = GetXmlValues (pxdDoc, L"UPLOADDATA", L"PROBLEMDESCRIPTION", &hr);
	if (hr != S_OK)
		goto done;

	//Fill in these values in the database
	vtShareLocation.SetString ("\\\\prav02\\shared\\XML\\");
	hr = UploadRCData (vtTypeVal, vtNameVal, vtDescVal, 
											vtShareLocation);
	if (hr != S_OK)
		goto done;
  */ 
done:
    return hr; 
}

// Utility functions internal to this file
/*
static _variant_t GetXmlValues (IXMLDOMDocument *pxdDoc, 
								_bstr_t sElement, 
								_bstr_t sAttr, 
								HRESULT *hr)
{
	_variant_t vtAttrVal;
	
	CComPtr<IXMLDOMNodeList>		pxnlElement;
	CComPtr<IXMLDOMNode>			pxnElement, pxnAttr;
	CComPtr<IXMLDOMNamedNodeMap>	pxnmAttr;

	*hr = E_FAIL;
	vtAttrVal.SetString ("");

	*hr = pxdDoc->getElementsByTagName (sElement, &pxnlElement);
	if (*hr != S_OK)
		return vtAttrVal;

	*hr = pxnlElement->get_item (0L, &pxnElement);
	if (*hr != S_OK)
		return vtAttrVal;
	
	*hr = pxnElement->get_attributes(&pxnmAttr);
	if (*hr != S_OK)
		return vtAttrVal;

	*hr = pxnmAttr->getNamedItem (sAttr, &pxnAttr);
	if (*hr != S_OK)
		return vtAttrVal;

	*hr = pxnAttr->get_nodeValue (&vtAttrVal);
	if (*hr != S_OK)
		return vtAttrVal;

	*hr = S_OK;
	return vtAttrVal;
}


static HRESULT UploadRCData (_variant_t vtType, 
								_variant_t vtName,
								_variant_t vtDesc, 
								_variant_t vtShareLoc)
{
	_ConnectionPtr	pConn;
	_CommandPtr		pCmd;
	_ParameterPtr	pParam;
	HRESULT			hr;
	_variant_t		vtParam;

	// Open the connection
	hr = pConn.CreateInstance (__uuidof(Connection));
	if (hr != S_OK)
		return hr;
	
	// hard coded connection string for now
	pConn->ConnectionString = L"driver={sql server};server=prav02;Database=test;UID=sa;PWD=;";
	pConn->Open ("", "", "", -1);

	hr = pCmd.CreateInstance(__uuidof(Command));
	if (hr != S_OK)
		return hr;

	pCmd->PutActiveConnection(_variant_t((IDispatch*)pConn));
	
	pCmd->CommandText = L"sp_AddRCIncident";
	pCmd->CommandType = adCmdStoredProc;

	hr = pCmd->Parameters->Append 
					(pCmd->CreateParameter (L"sDescription",
											adVarWChar,
											adParamInput, 
											1000, 
											vtDesc));
	if (hr != S_OK)
		return hr;

	hr = pCmd->Parameters->Append 
					(pCmd->CreateParameter (L"sUserName",
											adVarWChar,
											adParamInput, 
											200,
											vtName));
	if (hr != S_OK)
		return hr;

		hr = pCmd->Parameters->Append 
					(pCmd->CreateParameter (L"sShare",
											adVarWChar,
											adParamInput, 
											1000,
											vtShareLoc));
	if (hr != S_OK)
		return hr;

	hr = pCmd->Parameters->Append 
					(pCmd->CreateParameter (L"iError",
											adInteger,
											adParamOutput, 
											0));
	if (hr != S_OK)
		return hr;

	pCmd->Execute (NULL, NULL, adExecuteNoRecords);

	// check the return value for errors
	pParam = pCmd->Parameters->GetItem (_variant_t (L"iError"));
	vtParam = pParam->GetAttributes();

	if ((vtParam.vt != VT_I4) || (vtParam.intVal != 0))
		hr = E_FAIL;

	return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\files\header.inc ===
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link REL="STYLESHEET" HREF="style.css" TYPE="text/css">
<Script Language=Javascript Src=comf.js></Script>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\rchandler\dll\rchandler.cpp ===
// rcHandler.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f rcHandlerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "rcHandler.h"

#include "rcHandler_i.c"
#include "RcULProvider.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RcULProvider, CRcULProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_RCHANDLERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\rchandler\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__73CED374_F865_47B3_A127_6587998D9F22__INCLUDED_)
#define AFX_STDAFX_H__73CED374_F865_47B3_A127_6587998D9F22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//#include "ado15tli.h"
//#include "ado15tlh.h"
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//#include <comdef.h>
//#import <msado15.dll> no_namespace rename("EOF", "adoEOF") no_implementation

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__73CED374_F865_47B3_A127_6587998D9F22__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\raregsetting.cpp ===
// RARegSetting.cpp : Implementation of CRARegSetting
#include "stdafx.h"
#include "RAssistance.h"
#include "common.h"
#include "RARegSetting.h"
#include "assert.h"

/////////////////////////////////////////////////////////////////////////////
// CRARegSetting

STDMETHODIMP CRARegSetting::get_AllowGetHelpCPL(BOOL *pVal)
{
    // Set default value;
    DWORD dwValue;
    *pVal = RA_CTL_RA_ENABLE_DEF_VALUE;
    HRESULT hr = RegGetDwValueCPL(RA_CTL_RA_ENABLE, &dwValue);
    if (hr == S_OK)
    {
        *pVal = !!dwValue;
    }

	return hr;
}

STDMETHODIMP CRARegSetting::get_AllowGetHelp(BOOL *pVal)
{
    // Set default value;
    DWORD dwValue;
    *pVal = RA_CTL_RA_ENABLE_DEF_VALUE;
    HRESULT hr = RegGetDwValue(RA_CTL_RA_ENABLE, &dwValue);
    if (hr == S_OK)
    {
        *pVal = !!dwValue;
    }

	return hr;
}

STDMETHODIMP CRARegSetting::put_AllowGetHelp(BOOL newVal)
{
    DWORD dwValue = newVal;
    HRESULT hr = RegSetDwValue(RA_CTL_RA_ENABLE, dwValue);
	return hr;
}

STDMETHODIMP CRARegSetting::get_AllowBuddyHelp(BOOL *pVal)
{
    // Set default value;
    DWORD dwValue;
    *pVal = RA_CTL_ALLOW_BUDDYHELP_DEF_VALUE;
    HRESULT hr = RegGetDwValue(RA_CTL_ALLOW_BUDDYHELP, &dwValue);
    if (hr == S_OK)
    {
        *pVal = !!dwValue;
    }

	return hr;
}

STDMETHODIMP CRARegSetting::get_AllowUnSolicitedFullControl(BOOL *pVal)
{
    // Set default value;
    DWORD dwValue;
    *pVal = RA_CTL_ALLOW_UNSOLICITEDFULLCONTROL_DEF_VALUE;
    HRESULT hr = RegGetDwValue(RA_CTL_ALLOW_UNSOLICITEDFULLCONTROL, &dwValue);
    if (hr == S_OK)
    {
        *pVal = !!dwValue;
    }

	return hr;
}

STDMETHODIMP CRARegSetting::get_AllowUnSolicited(BOOL *pVal)
{
    // Set default value;
    DWORD dwValue;
    *pVal = RA_CTL_ALLOW_UNSOLICITED_DEF_VALUE;
    HRESULT hr = RegGetDwValue(RA_CTL_ALLOW_UNSOLICITED, &dwValue);
    if (hr == S_OK)
    {
        *pVal = !!dwValue;
    }

	return hr;
}

STDMETHODIMP CRARegSetting::put_AllowUnSolicited(BOOL newVal)
{
    DWORD dwValue = newVal;
    HRESULT hr = RegSetDwValue(RA_CTL_ALLOW_UNSOLICITED, dwValue);
	return hr;
}

STDMETHODIMP CRARegSetting::get_AllowFullControl(BOOL *pVal)
{
    // Set default value;
    DWORD dwValue;
    *pVal = RA_CTL_ALLOW_FULLCONTROL_DEF_VALUE;
    HRESULT hr = RegGetDwValue(RA_CTL_ALLOW_FULLCONTROL, &dwValue);
    if (hr == S_OK)
    {
        *pVal = !!dwValue;
    }

	return hr;
}

STDMETHODIMP CRARegSetting::put_AllowFullControl(BOOL newVal)
{
    DWORD dwValue = newVal;
    HRESULT hr = RegSetDwValue(RA_CTL_ALLOW_FULLCONTROL, dwValue);
	return hr;
}

STDMETHODIMP CRARegSetting::get_MaxTicketExpiry(LONG *pVal)
{
    // Set default value;
    DWORD dwUnit, dwValue;
    HRESULT hr = FALSE;
    DWORD	dwSize = sizeof(DWORD), dwSize1 = sizeof(DWORD);
    HKEY	hKey=NULL, hPolKey=NULL, hCtlKey=NULL;

    *pVal = RA_CTL_TICKET_EXPIRY_DEF_VALUE;
	//
	// Look up Group Policy settings first
	//
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE_GP, 0, KEY_READ, &hPolKey);
	//
	// look up Control Panel settings
	//
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE, 0, KEY_READ, &hCtlKey);

	//
	// Read the reg value if we could open the key
	//
    if (hPolKey)
        hKey = hPolKey;
    else if (hCtlKey)
        hKey = hCtlKey;

    while (hKey)
	{
        // Get value
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, RA_CTL_TICKET_EXPIRY, 0, NULL, (LPBYTE)&dwValue, &dwSize) &&
            ERROR_SUCCESS == RegQueryValueEx(hKey, RA_CTL_TICKET_EXPIRY_UNIT, 0, NULL, (LPBYTE)&dwUnit, &dwSize1))
        {
            *pVal = dwValue * ((dwUnit==RA_IDX_MIN)?60:((dwUnit==RA_IDX_HOUR)?3600:86400)); // 0: minute 1: hour 2: day
            break;
        }
        else if (hPolKey == hKey)
        {
            //
            // Group Policy gets rid of the value if you disable the policy
            // Need to read the value from Control Panel settings.
            // 
            assert(hCtlKey != hPolKey);

            hKey = hCtlKey;
            continue;
        }

        break;
    }


    if (hPolKey)
        RegCloseKey(hPolKey);

    if (hCtlKey)
        RegCloseKey(hCtlKey);

	return S_OK;
}

STDMETHODIMP CRARegSetting::put_MaxTicketExpiry(LONG newVal)
{
    DWORD dwValue = newVal;
    DWORD dwUnit = -1, dwBase=0;
    RegGetDwValue(RA_CTL_TICKET_EXPIRY_UNIT, &dwUnit);
    if (dwUnit != -1)
    {
        dwBase = (dwUnit==0)?60:((dwUnit==1)?3600:86400);
        if (dwValue % dwBase == 0) // no need to change Unit
        {
            dwValue = dwValue/dwBase;
            goto set_value;
        }
    }
    
    if (dwValue % 86400 == 0)
    {
        dwValue /= 86400;
        dwUnit = RA_IDX_DAY;
    }
    else if (dwValue % 3600 == 0)
    {
        dwValue /=  3600;
        dwUnit = RA_IDX_HOUR;
    }

    dwValue = dwValue / 60 + ((dwValue % 60) > 0); // round to the next minutes
    dwUnit = RA_IDX_MIN;

set_value:
    RegSetDwValue(RA_CTL_TICKET_EXPIRY, dwValue);
    RegSetDwValue(RA_CTL_TICKET_EXPIRY_UNIT, dwUnit);

    return S_OK;
}


STDMETHODIMP CRARegSetting::get_AllowRemoteAssistance(BOOL *pVal)
{
    // Set default value;
    DWORD dwValue;
    *pVal = RA_CTL_RA_ENABLE_DEF_VALUE;
    HRESULT hr = RegGetDwValue(RA_CTL_RA_MODE, &dwValue);
    if (hr == S_OK)
    {
        *pVal = !!dwValue;
    }

	return hr;
}

STDMETHODIMP CRARegSetting::put_AllowRemoteAssistance(BOOL newVal)
{
    DWORD dwValue = newVal;
    HRESULT hr = RegSetDwValue(RA_CTL_RA_MODE, dwValue);
	return hr;
}

/*****************************************************************
Func:
    RegGetDwValueCPL()
Abstract:
    Internal Helper function to retrieve RA setting values for Control Panel settings
Return:
    DWORD value
******************************************************************/
HRESULT CRARegSetting::RegGetDwValueCPL(LPCTSTR valueName, DWORD* pdword)
{
    HRESULT hr = S_FALSE;
    DWORD	dwSize = sizeof(DWORD);
    HKEY	hKey=NULL;

	//
	// look up Control Panel settings
	//
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE, 0, KEY_READ, &hKey))
    {
        //
        // Read the reg value if we could open the key
        //
        // Get value
        LONG lRetVal = RegQueryValueEx(hKey, valueName, 0, NULL, (LPBYTE)pdword, &dwSize );
        hr = (lRetVal == ERROR_SUCCESS) ? S_OK : S_FALSE;
    }

    if (hKey)
        RegCloseKey(hKey);

    return hr;
}

/*****************************************************************
Func:
    RegGetDwValue()
Abstract:
    Internal Helper function to retrieve RA setting values
Return:
    DWORD value
******************************************************************/
HRESULT CRARegSetting::RegGetDwValue(LPCTSTR valueName, DWORD* pdword)
{
    HRESULT hr = S_FALSE;
    DWORD	dwSize = sizeof(DWORD);
    HKEY	hKey=NULL, hPolKey=NULL, hCtlKey=NULL;

	//
	// Look up Group Policy settings first
	//
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE_GP, 0, KEY_READ, &hPolKey);
	//
	// look up Control Panel settings
	//
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE, 0, KEY_READ, &hCtlKey);

    *pdword = 0;

	//
	// Read the reg value if we could open the key
	//
    if (hPolKey)
        hKey = hPolKey;
    else if (hCtlKey)
        hKey = hCtlKey;

    while (hKey)
	{
        // Get value
        LONG lRetVal = RegQueryValueEx(hKey, valueName, 0, NULL, (LPBYTE)pdword, &dwSize );
        
        hr = (lRetVal == ERROR_SUCCESS) ? S_OK : S_FALSE;

        if (hr == S_FALSE && hPolKey == hKey)
        {
            //
            // Value not found in Group Policy
            // Need to read the value from Control Panel settings.
            // 
            assert(hCtlKey != hPolKey);

            hKey = hCtlKey;
            continue;
        }

        break;
    }


    if (hPolKey)
        RegCloseKey(hPolKey);

    if (hCtlKey)
        RegCloseKey(hCtlKey);

    return hr;
}

/*****************************************************************
Func:
    RegSetDwValue()
Abstract:
    Internal Helper function to set RA setting values
Return:
    DWORD value
******************************************************************/
HRESULT CRARegSetting::RegSetDwValue(LPCTSTR valueName, DWORD dwValue)
{
    HRESULT hr = S_FALSE;
    DWORD dwSize = sizeof(DWORD);
    HKEY hKey = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE, 0, KEY_WRITE, &hKey))
    {
        // Set Value
        if (ERROR_SUCCESS == 
                RegSetValueEx(hKey,valueName,0,REG_DWORD,(LPBYTE)&dwValue,sizeof(DWORD)))
        {
            hr = S_OK;
        }
        RegCloseKey(hKey);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\common.h ===
#include "regapi.h"

//
// Registry locations where the remote assistance control panel settings go
//
#define	REG_KEY_REMOTEASSISTANCE		    REG_CONTROL_GETHELP 

//
// Registry locations where the remote assistance group policy settings go
//
#define	REG_KEY_REMOTEASSISTANCE_GP			TS_POLICY_SUB_TREE
	

//
// Remote Assistance Mode
//
#define	REG_VALUE_MODE			            POLICY_TS_REMDSK_ALLOWTOGETHELP  
#define	REG_DWORD_RA_DISABLED		        0       // No Help
#define REG_DWORD_RA_NORC                   1       // No Remote Control
#define	REG_DWORD_RA_SHADOWONLY	            2       // View only
#define	REG_DWORD_RA_ENABLED		        3       // Full control


#define REG_DWORD_RA_DEFAULTMODE            REG_DWORD_RA_ENABLED

//
// Maximum Ticket Timeout
//
#define	REG_VALUE_MAX_TICKET		        _T("TicketTimeout")
#define REG_DWORD_RA_TIMEOUT_MIN            1
#define REG_DWORD_RA_TIMEOUT_MAX            (30 * 24 * REG_DWORD_RA_TIMEOUT_MIN)
#define REG_DWORD_RA_DEFAULT_TIMEOUT        REG_DWORD_RA_TIMEOUT_MIN

INT_PTR RemoteAssistanceProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//
// Value Names
//
#define RA_CTL_RA_ENABLE                       TEXT("fAllowToGetHelp")
#define RA_CTL_ALLOW_UNSOLICITED               TEXT("fAllowUnsolicited")
#define RA_CTL_ALLOW_UNSOLICITEDFULLCONTROL    TEXT("fAllowUnsolicitedFullControl")
#define RA_CTL_ALLOW_FULLCONTROL               TEXT("fAllowFullControl")
#define RA_CTL_ALLOW_BUDDYHELP                 TEXT("fAllowBuddyHelp")
#define RA_CTL_TICKET_EXPIRY                   TEXT("MaxTicketExpiry") // in seconds
#define RA_CTL_TICKET_EXPIRY_UNIT              TEXT("MaxTicketExpiryUnits")
#define RA_CTL_COMBO_NUMBER                    RA_CTL_TICKET_EXPIRY
#define RA_CTL_COMBO_UNIT                      RA_CTL_TICKET_EXPIRY_UNIT
#define RA_CTL_RA_MODE				           TEXT("fAllowRemoteAssistance")


// Default value
#define RA_CTL_RA_ENABLE_DEF_VALUE            0 // If it's missing, it's OFF.
#define RA_CTL_ALLOW_UNSOLICITED_DEF_VALUE    0
#define RA_CTL_ALLOW_UNSOLICITEDFULLCONTROL_DEF_VALUE    0
#define RA_CTL_ALLOW_BUDDYHELP_DEF_VALUE      1
#define RA_CTL_ALLOW_FULLCONTROL_DEF_VALUE    1
#define RA_CTL_COMBO_NUMBER_DEF_VALUE         30 // 30
#define RA_CTL_COMBO_UNIT_DEF_VALUE           2  // day
#define RA_CTL_TICKET_EXPIRY_DEF_VALUE        30 * 24 *60 * 60 // seconds of 30 days


// Default combo control index.
#define RA_IDX_DAY  2
#define RA_IDX_HOUR 1
#define RA_IDX_MIN  0

#define RA_MAX_DAYS 30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\raregsetting.h ===
// RARegSetting.h : Declaration of the CRARegSetting

#ifndef __RAREGSETTING_H_
#define __RAREGSETTING_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CRARegSetting
class ATL_NO_VTABLE CRARegSetting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRARegSetting, &CLSID_RARegSetting>,
	public IDispatchImpl<IRARegSetting, &IID_IRARegSetting, &LIBID_RASSISTANCELib>
{
public:
	CRARegSetting()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_RAREGSETTING)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRARegSetting)
	COM_INTERFACE_ENTRY(IRARegSetting)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRARegSetting
public:
	STDMETHOD(get_MaxTicketExpiry)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_MaxTicketExpiry)(/*[in]*/ LONG newVal);
	STDMETHOD(get_AllowFullControl)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowFullControl)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_AllowUnSolicited)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowUnSolicited)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_AllowGetHelp)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowGetHelp)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_AllowRemoteAssistance)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowRemoteAssistance)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_AllowUnSolicitedFullControl)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_AllowBuddyHelp)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_AllowGetHelpCPL)(/*[out, retval]*/ BOOL *pVal);
private:
	HRESULT RegSetDwValue(LPCTSTR valueName, DWORD dwValue);
	HRESULT RegGetDwValue(LPCTSTR valueName, DWORD* pdword);
	HRESULT RegGetDwValueCPL(LPCTSTR valueName, DWORD* pdword);
};

#endif //__RAREGSETTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\rasettingproperty.cpp ===
// RASettingProperty.cpp : Implementation of CRASettingProperty
#include "stdafx.h"
#include "windowsx.h"
#include "RAssistance.h"
#include "RASettingProperty.h"
#include "stdio.h"

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control.
#define HELP_FILE TEXT("SYSDM.HLP")

DWORD aRAHelpIds[] = {
    //IDC_ENABLERA,            HIDC_RA_ENABLE,
    IDC_ALLOWRC,             HIDC_RA_ALLOWRC,
    IDC_GROUP1,              HIDC_RA_ALLOWRC,
    IDC_ALLOWUNSOLICIT,      HIDC_RA_ALLOWUNSOLICIT,
    IDC_NUMBERCOMBO,         HIDC_RA_EXPIRY,
    IDC_UNITCOMBO,           HIDC_RA_EXPIRY,
    IDC_TIMEOUTTXT,          HIDC_RA_EXPIRY,
    IDC_GROUP2,              HIDC_RA_EXPIRY,
    IDC_STATIC_TEXT,         NO_HELP,
    0, 0
};

extern HINSTANCE g_hInst;

/************************************************
 RemoteAssistanceProc: DlgProc of Remote Assistance setup
 ************************************************/
INT_PTR 
RemoteAssistanceProc( HWND hDlg,
                      UINT uMsg,
                      WPARAM wParam,
                      LPARAM lParam   )
{
    static CRASettingProperty* pRaSetting = NULL;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR sTmp[32];
            int i;
            HWND hList;
            RA_SETTING *p;
            int iFocus = IDC_ALLOWRC;

            pRaSetting = (CRASettingProperty*)lParam;

            if (pRaSetting->m_bUseNewSetting)
                p = &pRaSetting->newSetting;
            else
                p = &pRaSetting->oldSetting;
/*
            if (p->m_bEnableRA)
                CheckDlgButton(hDlg,IDC_ENABLERA, BST_CHECKED);

            if (p->m_bAllowUnsolicited)
                CheckDlgButton(hDlg,IDC_ALLOWUNSOLICIT, BST_CHECKED);
*/

            CheckDlgButton(hDlg, IDC_ALLOWRC, p->m_bAllowFullControl?BST_CHECKED:BST_UNCHECKED);
            iFocus = IDC_ALLOWRC;

            // Add Numbers
            hList = GetDlgItem(hDlg, IDC_NUMBERCOMBO);
            for (i=1; i<100; i++)
            {
                wsprintf(sTmp, TEXT("%d"), i);
                ComboBox_AddString(hList, sTmp);
            }
            //ComboBox_SetCurSel(hList, p->m_iNumber);
            wsprintf(sTmp, TEXT("%d"), p->m_iNumber);
            ComboBox_SetText(hList, sTmp);


            // Add Units
            hList = GetDlgItem(hDlg, IDC_UNITCOMBO);
            i=0;
            if (LoadString(g_hInst, IDS_UNIT_MINUTE, sTmp, 32))
                ComboBox_AddString(hList, sTmp);
            if (LoadString(g_hInst, IDS_UNIT_HOUR, sTmp, 32))
                ComboBox_AddString(hList, sTmp);
            if (LoadString(g_hInst, IDS_UNIT_DAY, sTmp, 32))
                ComboBox_AddString(hList, sTmp);

            ComboBox_SetCurSel(hList, p->m_iUnit);
            SetFocus(GetDlgItem(hDlg, iFocus));
            return FALSE;
        }
                 
        break;
    case WM_HELP: // F1
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                HELP_FILE, 
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR)aRAHelpIds);
        break;
    case WM_CONTEXTMENU: // right-click help
        WinHelp((HWND)wParam,
                HELP_FILE, 
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPSTR)aRAHelpIds);
        break;
    
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
            case IDC_NUMBERCOMBO:
            {
                if (HIWORD(wParam) == CBN_EDITUPDATE)
                {
                    BOOL bOK;
                    DWORD nVal;

					TCHAR sTmp[MAX_PATH];
                    if (GetDlgItemText(hDlg,IDC_NUMBERCOMBO,&sTmp[0],MAX_PATH-1))
                    {
                        nVal = (DWORD)GetDlgItemInt(hDlg, IDC_NUMBERCOMBO, &bOK, FALSE);
                        if (!bOK || nVal > 99)
                        {
							CComBSTR bstrErrMsg;
							CComBSTR bstrTitle;
							
                            if (bstrErrMsg.LoadString(IDS_VALID_NUMBER) && bstrTitle.LoadString(IDS_PROJNAME))
                            {
                                MessageBox(hDlg, bstrErrMsg, bstrTitle, MB_OK | MB_ICONERROR);
                            }

                            // Set it back to default.
							wsprintf(sTmp, TEXT("%d"), pRaSetting->oldSetting.m_iNumber);
                            ComboBox_SetText(GetDlgItem(hDlg, IDC_NUMBERCOMBO), sTmp);
                            return TRUE;
                        }
                    }

                }
                break;
            }

            case IDCANCEL:
                pRaSetting->put_IsCancelled(TRUE);
                EndDialog(hDlg, 0);
                break;

            case IDOK:
                {
                    TCHAR sTmp[11];
                    wsprintf(sTmp, TEXT("0"));

                    // Map control value to local variables.
                    // pRaSetting->newSetting.m_bEnableRA = (IsDlgButtonChecked(hDlg,IDC_ENABLERA) == BST_CHECKED);
                    // pRaSetting->newSetting.m_bAllowUnsolicited = (IsDlgButtonChecked(hDlg,IDC_ALLOWUNSOLICIT)==BST_CHECKED);
                    pRaSetting->newSetting.m_bAllowFullControl = (IsDlgButtonChecked(hDlg,IDC_ALLOWRC)==BST_CHECKED);
                    ComboBox_GetText(GetDlgItem(hDlg, IDC_NUMBERCOMBO), sTmp, 10);
					DWORD iUnit = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_UNITCOMBO));
					
					//The max allowed value for number of days is 30 if the value selected is above 30 then 
					//show and error message and break without closing the dialog and set focus to number dropdown.
					if ( (iUnit == RA_IDX_DAY) && (_ttoi(sTmp) > RA_MAX_DAYS) )
					{
						CComBSTR bstrTitle;
						CComBSTR bstrErrMsg;
						bstrTitle.LoadString(IDS_PROJNAME);
						bstrErrMsg.LoadString(IDS_VALID_DAYS);
						if (bstrTitle.LoadString(IDS_PROJNAME) && bstrErrMsg.LoadString(IDS_VALID_DAYS))
							MessageBoxW(NULL,bstrErrMsg,bstrTitle,MB_OK | MB_ICONERROR);
						SetFocus(GetDlgItem(hDlg, IDC_NUMBERCOMBO));
						wsprintf(sTmp, TEXT("30")); //RA_MAX_DAYS VALUE
						SetDlgItemText(hDlg,IDC_NUMBERCOMBO,sTmp);
						break;
					}

                    pRaSetting->newSetting.m_iNumber = _ttoi(sTmp);
                    pRaSetting->newSetting.m_iUnit = iUnit;

                    // In case users open the dialog again before APPLY the changes.
                    pRaSetting->m_bUseNewSetting = TRUE;

                    EndDialog(hDlg, 0);
                }
                break;
            
            default: {
                // indicat not handled
                return FALSE;
            }
        }
        break; // WM_COMMAND

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRASettingProperty

/******************************
Func:
    get_IsCancelled
Abstract:
    Is the action get cancelled
*******************************/
STDMETHODIMP CRASettingProperty::get_IsCancelled(BOOL *pVal)
{
	*pVal = m_bCancelled;
	return S_OK;
}

STDMETHODIMP CRASettingProperty::put_IsCancelled(BOOL newVal)
{
	m_bCancelled = newVal;
	return S_OK;
}

/*************************************
Func:
    IsChanged
Abstract:
    Check if the RA setting values have been changed.
Return:
    TRUE (changed) else FALSE
**************************************/
STDMETHODIMP CRASettingProperty::get_IsChanged(BOOL *pVal)
{
    *pVal = FALSE;

    if (!m_bCancelled && !(oldSetting == newSetting))
        *pVal = TRUE;

	return S_OK;
}

/********************************************
Func:
    Init
Abstract:
    Initialize this object. Get setting values from Registry.
*********************************************/
STDMETHODIMP CRASettingProperty::Init()
{
    HRESULT hr = GetRegSetting();
    if (SUCCEEDED(hr))
    {
        newSetting = oldSetting;
    }

    return hr;
}


/**************************************************************
Func:
    GetRegSetting
Abstract:
    Get RA Settnig dialog's Registry values to oldSetting member.
***************************************************************/
HRESULT CRASettingProperty::GetRegSetting()
{
    // If any value is not found, use the default value.
    DWORD dwValue;
    DWORD dwSize;
    HKEY hKey = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE, 0, KEY_READ, &hKey))
    {
        // Get value
		/*
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, RA_CTL_RA_MODE, 0, NULL, (LPBYTE)&dwValue, &dwSize ))
        {
            oldSetting.m_bEnableRA = !!dwValue;
        }
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, RA_CTL_ALLOW_UNSOLICITED, 0, NULL, (LPBYTE)&dwValue, &dwSize))
        {
            oldSetting.m_bAllowUnsolicited = !!dwValue;
        }
		*/

        dwValue=0; 
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, RA_CTL_ALLOW_FULLCONTROL, 0, NULL, (LPBYTE)&dwValue, &dwSize ))
        {
            oldSetting.m_bAllowFullControl = !!dwValue;;
        }

        dwValue=0; 
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, RA_CTL_COMBO_NUMBER, 0, NULL, (LPBYTE)&dwValue, &dwSize ))
        {
            oldSetting.m_iNumber = dwValue;
        }

        dwValue=0; 
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, RA_CTL_COMBO_UNIT, 0, NULL, (LPBYTE)&dwValue, &dwSize ))
        {
            oldSetting.m_iUnit = dwValue;
        }

        RegCloseKey(hKey);
    }

    return S_OK;
}

/**************************************************************
Func:
    SetRegSetting
Abstract:
    Set RA setting dialog values to registry.
***************************************************************/
STDMETHODIMP CRASettingProperty::SetRegSetting()
{
    HRESULT hr = E_FAIL;
    HKEY hKey;
    DWORD dwAwFullControl /*,dwAwUnsolicited */;

    //dwAwUnsolicited = newSetting.m_bAllowUnsolicited;
    dwAwFullControl = newSetting.m_bAllowFullControl;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE, 0, KEY_WRITE, &hKey))
    {
        if (//ERROR_SUCCESS==RegSetValueEx(hKey,RA_CTL_ALLOW_UNSOLICITED,0,REG_DWORD,(LPBYTE)&dwAwUnsolicited,sizeof(DWORD)) &&
            ERROR_SUCCESS==RegSetValueEx(hKey,RA_CTL_ALLOW_FULLCONTROL,0,REG_DWORD,(LPBYTE)&dwAwFullControl,sizeof(DWORD)) &&
            ERROR_SUCCESS==RegSetValueEx(hKey,RA_CTL_COMBO_NUMBER,0,REG_DWORD,(LPBYTE)&newSetting.m_iNumber,sizeof(DWORD)) &&
            ERROR_SUCCESS==RegSetValueEx(hKey,RA_CTL_COMBO_UNIT,0,REG_DWORD,(LPBYTE)&newSetting.m_iUnit,sizeof(DWORD)))
        {
            hr = S_OK;

            // Sync old and new settings
            oldSetting = newSetting;
        }

        RegCloseKey(hKey);
    }

    return hr;
}

/**************************************************************
Func:
    ShowDialogBox
Abstract:
    Display the RA setting dialog
***************************************************************/
STDMETHODIMP CRASettingProperty::ShowDialogBox(HWND hWndParent)
{
    HRESULT hr = S_OK;
    m_bCancelled = FALSE;
    HMODULE hModule = GetModuleHandle(TEXT("RACPLDlg.dll"));
    INT_PTR i;

    if (!hModule)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    i = DialogBoxParam(hModule,
                    (LPTSTR) MAKEINTRESOURCE(IDD_RASETTINGS_DIALOG), 
                    hWndParent, 
                    RemoteAssistanceProc,
                    (LPARAM)this);
    if (i == -1)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\psschannel\server\files\asp.inc ===
<%
	' const part
	Const adOpenForwardOnly = 0
	Const adOpenKeyset = 1
	Const adOpenDynamic = 2
	Const adOpenStatic = 3

	Const adUseServer = 2
	Const adUseClient = 3

	Const adCmdStoredProc = &H0004
	Const adParamInput = &H0001
	Const adParamOutput = &H0002
	Const adParamInputOutput = &H0003
	Const adParamReturnValue = &H0004
	Const adWChar = 130
	Const adVarWChar = 202
	Const adTinyInt = 16
	Const adSmallInt = 2
	Const adInteger = 3
	Const adDate = 7
	Const adBoolean = 11
	Const adChar = 129
	Const adVarChar = 200
	Const adDBDate = 133
	Const adDBTime = 134
	Const adDBTimeStamp = 135

	Const adStateClosed = &H00000000
	
	Session.CodePage = 65001 
	Server.Execute ("db.ini")
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\rasettingproperty.h ===
// RASettingProperty.h : Declaration of the CRASettingProperty

#ifndef __RASETTINGPROPERTY_H_
#define __RASETTINGPROPERTY_H_

#include "resource.h"       // main symbols

/* Internal class */
class RA_SETTING
{
public:
    //BOOL m_bAllowUnsolicited;
    BOOL m_bAllowFullControl;
    DWORD  m_iNumber;
    DWORD  m_iUnit;

public:
    RA_SETTING() 
    {
        //m_bAllowUnsolicited =   RA_CTL_ALLOW_UNSOLICITED_DEF_VALUE;
        m_bAllowFullControl =   RA_CTL_ALLOW_FULLCONTROL_DEF_VALUE;
        m_iNumber =             RA_CTL_COMBO_NUMBER_DEF_VALUE;
        m_iUnit =               RA_CTL_COMBO_UNIT_DEF_VALUE;
    }

    BOOL operator== (RA_SETTING& ra)
    {
        if ( //m_bAllowUnsolicited == ra.m_bAllowUnsolicited &&
            m_bAllowFullControl == ra.m_bAllowFullControl &&
            m_iNumber == ra.m_iNumber &&
            m_iUnit == ra.m_iUnit)
            return TRUE;
        return FALSE;
    }

    RA_SETTING& operator= (RA_SETTING& ra)
    {
        //m_bAllowUnsolicited = ra.m_bAllowUnsolicited;
        m_bAllowFullControl = ra.m_bAllowFullControl;
        m_iNumber = ra.m_iNumber;
        m_iUnit = ra.m_iUnit;
        return *this;
    }
};

/////////////////////////////////////////////////////////////////////////////
// CRASettingProperty
class ATL_NO_VTABLE CRASettingProperty : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRASettingProperty, &CLSID_RASettingProperty>,
	public IDispatchImpl<IRASettingProperty, &IID_IRASettingProperty, &LIBID_RASSISTANCELib>
{
public:
	CRASettingProperty()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_RASETTINGPROPERTY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRASettingProperty)
	COM_INTERFACE_ENTRY(IRASettingProperty)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRASettingProperty
public:
	STDMETHOD(ShowDialogBox)(HWND hWndParent);
	STDMETHOD(SetRegSetting)();
	HRESULT GetRegSetting();
	STDMETHOD(Init)();
	STDMETHOD(get_IsChanged)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_IsCancelled)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_IsCancelled)(BOOL pVal);
	BOOL m_bUseNewSetting;
	BOOL m_bCancelled;
	RA_SETTING newSetting;
	RA_SETTING oldSetting;
};

#endif //__RASETTINGPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RAssistance.rc
//
#define IDS_PROJNAME                    100
#define IDR_RASETTINGPROPERTY           101
#define IDR_RAREGSETTING                102
#define IDS_UNIT_DAY                    103
#define IDS_UNIT_HOUR                   104
#define IDS_UNIT_MINUTE                 105
#define IDS_VALID_NUMBER                106
#define IDS_VALID_DAYS					107

#define IDD_RASETTINGS_DIALOG           503
#define IDC_ENABLERA                    504
#define IDC_STATIC_TEXT                 505
#define IDC_ALLOWUNSOLICIT              506
#define IDC_DISABLERA                   507
#define IDC_TIMEOUTSPIN                 508
#define IDC_RATIMEOUTVAL                509
#define IDC_NUMBERCOMBO                 510
#define IDC_UNITCOMBO                   511
#define IDC_GROUP1                      512
#define IDC_ALLOWRC                     513
#define IDC_RCVIEWONLY                  514
#define IDC_GROUP2                      515
#define IDC_TIMEOUTTXT                  -1

//Help message IDs for Remote Assistance setup
#define HIDC_RA_ADVANCED                15005
#define HIDC_RA_ENABLE                  15006
#define HIDC_RA_ALLOWUNSOLICIT          15007
#define HIDC_RA_ALLOWRC                 15008
#define HIDC_RA_EXPIRY                  15009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        516
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           113
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\rassistance.cpp ===
// RAssistance.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f RAssistanceps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "RAssistance.h"

#include "RAssistance_i.c"
#include "RASettingProperty.h"
#include "RARegSetting.h"


CComModule _Module;
HINSTANCE g_hInst = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RASettingProperty, CRASettingProperty)
OBJECT_ENTRY(CLSID_RARegSetting, CRARegSetting)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hInstance;
        _Module.Init(ObjectMap, hInstance, &LIBID_RASSISTANCELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racpldlg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F0090FB0_76BE_411A_B5FD_CF9FD0E58107__INCLUDED_)
#define AFX_STDAFX_H__F0090FB0_76BE_411A_B5FD_CF9FD0E58107__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "common.h"
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F0090FB0_76BE_411A_B5FD_CF9FD0E58107__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\content\include\debug_js.inc ===
//
// Error Handling & Tracing
//
#ifndef DEBUG
#define DEBUG_ALERT(x)
#define ALERT(x) alert(x)
#else
#define DEBUG_ALERT(x) alert("File: " + __FILE__ + "\nLine: " + __LINE__ + "\n" + x)
#define ALERT(x) DEBUG_ALERT(x)
#endif

#ifdef DEBUG
#define InitTrace()     InitTraceEx( __FILE__ )
#else
#define InitTrace()
#endif

#ifndef DEBUG
#include "debug_decl.inc"
#else
#include "constants.inc"
<Script id="idScriptdebug" name="idScriptdebug" Language="JavaScript">
var g_szFuncName        = null;
var TraceFso            = null;
var TraceFileHandle     = null;
var TraceFile           = null;
var TracetFileName      = null;
var g_oShell            = null;
var g_bDebugSpew        = 0;


function InitTraceEx( szFileName )
{
        try{
            if( null == g_oShell )
            {
                g_oShell = new ActiveXObject("WScript.Shell");
            }

            g_bDebugSpew = g_oShell.RegRead( c_szREGDebugSpew );
            //alert("g_bDebugSpew: " + g_bDebugSpew);

            if( g_bDebugSpew )
            {
                TraceFso = new ActiveXObject("Scripting.FileSystemObject");
                var tFolder = TraceFso.GetSpecialFolder(2); // Get Path to temp directory 
                TracetFileName = tFolder + "\\" + szFileName + "_RA.log";
                        
                TraceFileHandle = TraceFso.OpenTextFile( TracetFileName, 8, -2 );
        
                DebugTrace( "Start of new helpsession:::" );
            }
        }
        catch(x)
        {
            //alert("Error: " + x.description );
        }
}

function EndTrace()
{
        DebugTrace( "End of new helpsession:::" );
        try
        {
            if( g_bDebugSpew )
            {
                TraceFileHandle.Close(); 
            }
        }
        catch(e)
        {
        }
}

function DebugTrace( szMsg )
{
        if( g_bDebugSpew )
        {
            if( null == TraceFileHandle )
            {
                InitTrace();
            }
        
            var d = new Date();     
            try
            {
                TraceFileHandle.WriteLine( d.toLocaleString() + "::" + szMsg );
            }
            catch(e)
            {
                // Dont do any thing. 
            }
        }
}

function TraceFunctEnter( szFuncName )
{
    if( g_bDebugSpew )
    {
        g_szFuncName = szFuncName;
        DebugTrace("Entering " + g_szFuncName);
    }
}

function TraceFunctLeave()
{
    if( g_bDebugSpew )
    {
        DebugTrace("Leaving " + g_szFuncName);
    }
}
</Script>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racplsettings\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RACPLSettings.rc
//
#define IDAPPLY                         3
#define IDD_RASETTINGS_DIALOG           101
#define IDC_ENABLERA                    1001
#define IDC_ALLOWRC                     1002
#define IDC_ALLOWUNSOLICIT              1003
#define IDC_DISABLERA                   1004
#define IDC_TIMEOUTSPIN                 1010
#define IDC_RATIMEOUTVAL                1011
#define IDC_NUMBERCOMBO                 1015
#define IDC_UNITCOMBO                   1016
#define IDC_GROUP1                      1017
#define IDC_TIMEOUTTXT                  -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racplsettings\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__FEE2BF2D_1AE5_4E56_BE33_028D54A4A72F__INCLUDED_)
#define AFX_STDAFX_H__FEE2BF2D_1AE5_4E56_BE33_028D54A4A72F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <afx.h>
#include <assert.h>
#include <atlbase.h>
#include <afxwin.h>
#include <afxcmn.h> // for spin control

#endif // !defined(AFX_STDAFX_H__FEE2BF2D_1AE5_4E56_BE33_028D54A4A72F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racplsettings\racplsettings.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RACPLSettings.cpp

Abstract:


Author:

    Rajesh Soy 10/00

Revision History:
    
    Rajesh Soy - created 10/26/2000

--*/

#include "stdafx.h"
#include "RACPLSettings.h"

CRACPLSettings *g_pcRASettings = NULL;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


/*++
Function Name:
	
	CRACPLSettings::OnInitDialog

Routine Description:

	Invoked on WM_INITDIALOG

Arguments:
	
	none

Return Value:

    always returns TRUE

--*/
BOOL CRACPLSettingsDialog::OnInitDialog()
{
    //
    // Call CDialog::OnInitDialog();
    //
    CDialog::OnInitDialog();
   
    //
    // Open the RA Settings
    //
    if(S_OK != OpenRACPLSettings())
    {
        //
        // Error condition
        //
        goto ExitOnInitDialog;
    }


    //
    // Get the settings 
    //
    if( S_OK != GetRACPLSettings( &m_RACPLSettings ) )
    {
        //
        // Error condition
        //
        goto ExitOnInitDialog;
    }

    //
    // TODO: Set current values in UI
    //


ExitOnInitDialog:
    return TRUE;
}


/*++
Function Name:
	
	CRACPLSettings::CRACPLSettings

Routine Description:

	Constructor for the CRACPLSettings class

Arguments:
	
	none

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
CRACPLSettings::CRACPLSettings()
{ 
    //
    // Initialize member variables
    //
    m_RACPLSettings.dwMode        = REG_DWORD_RA_DEFAULTMODE;         // Remote Assistance Mode
    m_RACPLSettings.dwUnsolicited = REG_DWORD_RA_UNSOLICITED_DEFAULT; // Allow Unsolicited Remote Assistance
    m_RACPLSettings.dwMaxTimeout  = REG_DWORD_RA_DEFAULT_TIMEOUT;     // Maximum Ticket Timeout

    m_pcRegKey      = NULL;

	return; 
}


/*++
Function Name:
	
	CRACPLSettings::OpenRACPLSettings

Routine Description:

	Member function of the CRACPLSettings class that initializes the RACPLSettings API

Arguments:
	
	none

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
DWORD CRACPLSettings::OpenRACPLSettings()
{
    DWORD   dwRetVal = S_OK;

    //
    // Instantiate the registry access class
    //
    if( NULL == m_pcRegKey )
    {
        m_pcRegKey = new CRegKey;
        if( NULL == m_pcRegKey )
        {
            //
            // Error
            //
            dwRetVal = GetLastError();
            goto ExitOpenRACPLSettings;
        }
    }
    else
    {
        m_pcRegKey->Close();
    }

    //
    // Create the Remote Assistance Settings registry key. Open it if existing
    //
    if(ERROR_SUCCESS != m_pcRegKey->Create(HKEY_LOCAL_MACHINE, REG_KEY_REMOTEASSISTANCE))
    {
        //
        // Error condition, exit
        //
        dwRetVal = GetLastError();
        goto ExitOpenRACPLSettings;
    }

    //
    // Initialize member variables
    //

    dwRetVal = GetRACPLSettings( NULL );

ExitOpenRACPLSettings:
    return dwRetVal;
}


/*++
Function Name:
	
	CRACPLSettings::CloseRACPLSettings

Routine Description:

	Member function of the CRACPLSettings class that closes the RACPLSettings API

Arguments:
	
	none

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
DWORD CRACPLSettings::CloseRACPLSettings()
{
    DWORD   dwRetVal = S_OK;

    if( NULL != m_pcRegKey )
    {
        m_pcRegKey->Close();
        m_pcRegKey = NULL;
    }

    return dwRetVal;
}


/*++
Function Name:
	
	CRACPLSettings::GetRACPLSettings

Routine Description:

	Member function of the CRACPLSettings class that reads the Remote Assistance
    settings from registry and returns it in the buffer passed

Arguments:
	
	pRACPLSettings  - pointer to RACPLSETTINGS structure

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
DWORD CRACPLSettings::GetRACPLSettings(
    PRACPLSETTINGS  pRACPLSettings
)
{
    DWORD   dwRetVal = S_OK;

    if(NULL != m_pcRegKey)
    {
        //
        // Remote Assistance Mode
        //
        if(ERROR_SUCCESS != m_pcRegKey->QueryValue(  m_RACPLSettings.dwMode, REG_VALUE_MODE ))
        {
            m_RACPLSettings.dwMode        = REG_DWORD_RA_DEFAULTMODE; 
        }

        //
        // Allow Unsolicited Remote Assistance
        //
        if(ERROR_SUCCESS != m_pcRegKey->QueryValue(  m_RACPLSettings.dwUnsolicited, REG_VALUE_UNSOLICITED ))
        {
            m_RACPLSettings.dwUnsolicited = REG_DWORD_RA_UNSOLICITED_DEFAULT; 
        }

        //
        // Maximum Ticket Timeout
        //
        if(ERROR_SUCCESS != m_pcRegKey->QueryValue( m_RACPLSettings.dwMaxTimeout, REG_VALUE_MAX_TICKET ))
        {
            m_RACPLSettings.dwMaxTimeout  = REG_DWORD_RA_DEFAULT_TIMEOUT;
        }

        //
        // Copy the settings to the buffer passed if necessary
        //
        if(NULL != pRACPLSettings)
        {
            memcpy((void *)pRACPLSettings, (void *)&m_RACPLSettings, sizeof(RACPLSETTINGS));
        }

    }
    else
    {
        //
        // RACPLSettings API has not been initialized
        //
        dwRetVal = ERROR_BADKEY;
        goto ExitGetRACPLSettings;
    }

ExitGetRACPLSettings:
    return dwRetVal;
}


/*++
Function Name:
	
	CRACPLSettings::SetRACPLSettings

Routine Description:

	Member function of the CRACPLSettings class that sets the Remote Assistance
    settings in registry from the values passed in the input buffer

Arguments:
	
	pRACPLSettings  - pointer to RACPLSETTINGS structure containing the values
                      to be set

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
DWORD CRACPLSettings::SetRACPLSettings(PRACPLSETTINGS pRACPLSettings)
{
    DWORD   dwRetVal = S_OK;

    //
    // Sanity Check
    //
    if(NULL == pRACPLSettings)
    {
        dwRetVal = ERROR_INVALID_BLOCK;
        goto ExitSetRACPLSettings;
    }

    if(NULL != m_pcRegKey)
    {
        //
        // Remote Assistance Mode
        //
        switch( pRACPLSettings->dwMode ) {
        case REG_DWORD_RA_ENABLED:
        case REG_DWORD_RA_DISABLED:
        case REG_DWORD_RA_SHADOWONLY:
            //
            // These are the only valid values
            //

            if(ERROR_SUCCESS != m_pcRegKey->SetValue( pRACPLSettings->dwMode, REG_VALUE_MODE ))
            {
                dwRetVal = GetLastError();
                goto ExitSetRACPLSettings;
            }

            m_RACPLSettings.dwMode = pRACPLSettings->dwMode;
            break;
        
        default:
            //
            // Invalid value. Ignore
            //
            break;
        }

        //
        // Allow Unsolicited Remote Assistance
        //
        switch( pRACPLSettings->dwUnsolicited ) {
        case REG_DWORD_RA_ALLOW:
        case REG_DWORD_RA_DISALLOW:
            //
            // These are the only valid values
            //

            if(ERROR_SUCCESS != m_pcRegKey->SetValue( pRACPLSettings->dwUnsolicited, REG_VALUE_UNSOLICITED ))
            {
                dwRetVal = GetLastError();
                goto ExitSetRACPLSettings;
            }

            m_RACPLSettings.dwUnsolicited = pRACPLSettings->dwUnsolicited;
            break;
        
        default:
            //
            // Invalid value. Ignore
            //
            break;
        }


        //
        // Maximum Ticket Timeout
        //
        if( (REG_DWORD_RA_TIMEOUT_MIN <= pRACPLSettings->dwMaxTimeout) &&
            (REG_DWORD_RA_TIMEOUT_MAX >= pRACPLSettings->dwMaxTimeout))
        {
            if(ERROR_SUCCESS != m_pcRegKey->SetValue( pRACPLSettings->dwMaxTimeout, REG_VALUE_MAX_TICKET ))
            {
                dwRetVal = GetLastError();
                goto ExitSetRACPLSettings;
            }

            m_RACPLSettings.dwMaxTimeout = pRACPLSettings->dwMaxTimeout;
        }
    }
    else
    {
        //
        // RACPLSettings API has not been initialized
        //
        dwRetVal = ERROR_BADKEY;
        goto ExitSetRACPLSettings;
    }

ExitSetRACPLSettings:
    return dwRetVal;
}


/*++
    *********************** RACPLSettings API ***************************
--*/

/*++
Function Name:
	
	OpenRACPLSettings

Routine Description:

	Initializes the RACPLSettings API

Arguments:
	
	none

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
RACPLSETTINGS_API DWORD OpenRACPLSettings(void)
{
    DWORD   dwRetVal = S_OK;

    //
    // Allocate the global variable
    //
    if(NULL == g_pcRASettings)
    {
        g_pcRASettings = new CRACPLSettings;
    
        if(NULL == g_pcRASettings)
        {
            //
            // Fatal Error
            //
            dwRetVal = GetLastError();
            goto ExitOpenRACPLSettings;
        }
    }

    //
    // Call the initialization routine
    //
    dwRetVal = g_pcRASettings->OpenRACPLSettings();

ExitOpenRACPLSettings:
	return dwRetVal;
}


/*++
Function Name:
	
	CloseRACPLSettings

Routine Description:

	Closes the RACPLSettings API

Arguments:
	
	none

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
RACPLSETTINGS_API DWORD CloseRACPLSettings(void)
{
    DWORD   dwRetVal = S_OK;

    if(NULL != g_pcRASettings)
    {
        dwRetVal = g_pcRASettings->CloseRACPLSettings();
    }
    else
    {
        //
        // The registry key for RACPLSettings is not open
        //
        dwRetVal = ERROR_BADKEY;
    }

    return dwRetVal;
}



/*++
Function Name:
	
	GetRACPLSettings

Routine Description:

	Function that reads the Remote Assistance Settings
    from the system registry and returns it in the buffer passed

Arguments:
	
	pRACPLSettings  - void pointer that gets the RACPLSETTINGS structure

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
RACPLSETTINGS_API DWORD GetRACPLSettings(
    PRACPLSETTINGS  pRACPLSettings
)
{
    DWORD   dwRetVal = S_OK;

    //
    // Sanity check
    //
    if(NULL == pRACPLSettings)
    {
        dwRetVal = ERROR_INVALID_BLOCK;
        goto ExitGetRACPLSettings;
    }

    if(NULL != g_pcRASettings)
    {
        dwRetVal = g_pcRASettings->GetRACPLSettings( pRACPLSettings );
    }
    else
    {
        //
        // The registry key for RACPLSettings is not open
        //
        dwRetVal = ERROR_BADKEY;
    }

ExitGetRACPLSettings:
    return dwRetVal;
}


/*++
Function Name:
	
	SetRACPLSettings

Routine Description:

	Function that reads the Remote Assistance Settings
    from the buffer passed and writes them to the system registry 

Arguments:
	
	pRACPLSettings  - pointer to RACPLSETTINGS structure containing the values
                      to be set

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
RACPLSETTINGS_API DWORD SetRACPLSettings(
    PRACPLSETTINGS  pRACPLSettings
)
{
    DWORD   dwRetVal = S_OK;

    //
    // Sanity check
    //
    if(NULL == pRACPLSettings)
    {
        dwRetVal = ERROR_INVALID_BLOCK;
        goto ExitSetRACPLSettings;
    }
    
    if(NULL != g_pcRASettings)
    {
        dwRetVal = g_pcRASettings->SetRACPLSettings( pRACPLSettings );
    }
    else
    {
        //
        // The registry key for RACPLSettings is not open
        //
        dwRetVal = ERROR_BADKEY;
    }

ExitSetRACPLSettings:
    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\dlgwindow.h ===
/*************************************************************************
	FileName : DlgWindow.h

	Purpose  : This file is used for listing the prototypes of the functions
			   used by savedlg,opendlg ActiveX controls to accomodate the
			   functions called for display of dialogs for the user to 
			   choose the name of the file which is to be saved to or to 
			   choose a file for filexfer by RA.

  	Author   : Sudha Srinivasan (a-sudsi)
*************************************************************************/

DWORD SaveTheFile();
DWORD OpenTheFile(TCHAR *pszInitialDir);
HRESULT ResolveIt(TCHAR *pszShortcutFile);
void InitializeOpenFileName();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\dlgwindow.cpp ===
/*************************************************************************
	FileName : DlgWindow.cpp

	Purpose  : To accomodate the functions called for display of dialogs
	           for the user to choose the name of the file which is to be
			   saved to or to choose a file for filexfer by RA.

    Functions 
	defined  : InitializeOpenFileName,
			   SaveTheFile,
			   OpenTheFile,			   
			   ResolveIt

  	Author   : Sudha Srinivasan (a-sudsi)
*************************************************************************/
#include "stdafx.h"
#include "DlgWindow.h"
#include "Resource.h"

extern "C" {
#include <shlobj.h>
#include <objbase.h>
}

HINSTANCE g_hInst = NULL;
extern CComBSTR g_bstrFileName;
extern BOOL g_bFileNameSet;  
extern CComBSTR g_bstrFileType;

extern CComBSTR g_bstrOpenFileName;
extern BOOL g_bOpenFileNameSet;

OPENFILENAME g_OpenFileName;

//
//   FUNCTION: InitializeOpenFileName()
//
//   PURPOSE: Invokes common dialog function to save a file.
//
//   COMMENTS:
//
//	This function initializes the OPENFILENAME structure and calls
//            the GetSaveFileName() common dialog function.  
//	
//    RETURN VALUES:
//        TRUE - The file name is chosen successfully and read into the buffer.
//        FALSE - No filename is chosen.
//
//
void InitializeOpenFileName()
{
	g_OpenFileName.lStructSize       = sizeof(OPENFILENAME);
    g_OpenFileName.hwndOwner         = GetFocus(); 
    g_OpenFileName.hInstance         = g_hInst;
    g_OpenFileName.lpstrCustomFilter = NULL;
    g_OpenFileName.nMaxCustFilter    = 0;
    g_OpenFileName.nFilterIndex      = 0;
    g_OpenFileName.lpstrFileTitle    = NULL;
    g_OpenFileName.nMaxFileTitle     = 0;
    g_OpenFileName.lpstrInitialDir   = NULL;
    g_OpenFileName.nFileOffset       = 0;
    g_OpenFileName.nFileExtension    = 0;
    g_OpenFileName.lpstrDefExt       = NULL;
    g_OpenFileName.lCustData         = NULL; 
	g_OpenFileName.lpfnHook 		 = NULL; 
	g_OpenFileName.lpTemplateName    = NULL;

	return;
}


//
//   FUNCTION: SaveTheFile()
//
//   PURPOSE: Invokes common dialog function to save a file.
//
//   COMMENTS:
//
//	This function initializes the OPENFILENAME structure and calls
//            the GetSaveFileName() common dialog function.  
//	
//    RETURN VALUES:
//        TRUE - The file name is chosen successfully and read into the buffer.
//        FALSE - No filename is chosen.
//
//
DWORD SaveTheFile()
{
	USES_CONVERSION;
	TCHAR         szFile[MAX_PATH]      = "\0";
	TCHAR         szFilter[MAX_PATH]    = "\0";
	TCHAR         *tszFile =NULL;
    DWORD         dwSuc = TRUE;

	//Incase the user has given a filename to be displayed in the dialog.
    if (g_bFileNameSet)
	{
		tszFile = OLE2T(g_bstrFileName);
        if(NULL != tszFile)
        {
		    strcpy( szFile, tszFile);
        }
        else
        {
            //
            // Error condition
            //
            dwSuc = FALSE;
            g_bstrFileName = "";
            goto DoneSaveTheFile;
        }
	}
	else
	{
		strcpy( szFile, "");
	}

	//To display file types.
	if (g_bstrFileType.Length() > 0)
	{
		strcpy (szFilter, OLE2T(g_bstrFileType));
		lstrcat(szFilter, "\0\0");
	}
	else
	{
		TCHAR szAllFilesFilter[MAX_PATH+1];
		LoadString(g_hInst, IDS_ALLFILESFILTER, szAllFilesFilter,MAX_PATH);
		strcpy( szFilter, szAllFilesFilter);
	}

	// Fill in the OPENFILENAME structure to support a template and hook.
	InitializeOpenFileName();
    g_OpenFileName.lpstrFilter       = szFilter;
	g_OpenFileName.lpstrFile         = szFile;
    g_OpenFileName.nMaxFile          = sizeof(szFile);

	TCHAR szSaveFile[MAX_PATH+1];
	LoadString(g_hInst, IDS_SAVEFILE, szSaveFile,MAX_PATH);
    g_OpenFileName.lpstrTitle        = szSaveFile;

	g_OpenFileName.nFilterIndex      = 1;
    g_OpenFileName.Flags             = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

	// Call the common dialog function.
	dwSuc = GetSaveFileName(&g_OpenFileName);
    if (dwSuc)
    {
		g_bstrFileName = g_OpenFileName.lpstrFile;
	}
    else
   	{
		g_bstrFileName = "";
    }

DoneSaveTheFile:
	return dwSuc;
}

//
//   FUNCTION: OpenTheFile()
//
//   PURPOSE: Invokes common dialog function to open a file.
//
//   COMMENTS:
//
//	 This function initializes the OPENFILENAME structure and calls
//            the GetOpenFileName() common dialog function.  
//	
//   INPUTS:
//   The initial folder which has to be displayed in the open file dialog.
//   If this is NULL, it means that the default initial folder is to be 
//   displayed. Hence this value is not checked explicitly when the 
//   control enters the function.
//
//   RETURN VALUES:
//        TRUE - The file name is chosen successfully and read into the buffer.
//        FALSE - No filename is chosen.
//
//
DWORD OpenTheFile(TCHAR *pszInitialDir)
{
	USES_CONVERSION;
	TCHAR         szFile[MAX_PATH]      = "\0";
	TCHAR         szFilter[MAX_PATH]    = "\0";
	ZeroMemory(szFilter, sizeof(TCHAR));

	DWORD		  dwSuc = 0;

	strcpy( szFile, "");

	TCHAR szAllFilesFilter[MAX_PATH+1];
	LoadString(g_hInst, IDS_ALLFILESFILTER, szAllFilesFilter,MAX_PATH);
	strcpy( szFilter, szAllFilesFilter);

	// Fill in the OPENFILENAME structure.
	InitializeOpenFileName();
    g_OpenFileName.lpstrFilter       = szFilter; 
    g_OpenFileName.lpstrFile         = szFile;
    g_OpenFileName.nMaxFile          = sizeof(szFile);
    g_OpenFileName.lpstrInitialDir   = pszInitialDir;

	TCHAR szChooseFile[MAX_PATH+1];
	LoadString(g_hInst, IDS_CHOOSEFILE, szChooseFile,MAX_PATH);
	
    g_OpenFileName.lpstrTitle        = szChooseFile;
    g_OpenFileName.Flags             = OFN_PATHMUSTEXIST | OFN_EXPLORER ; 

	// Call the common dialog function.
	dwSuc = GetOpenFileName(&g_OpenFileName);
    if (dwSuc)
    {
		g_bstrOpenFileName = g_OpenFileName.lpstrFile;
		TCHAR *pstrTemp = NULL;
		pstrTemp = g_OpenFileName.lpstrFile;
		if (NULL == pstrTemp)
		{
			g_bstrOpenFileName = "";
		} 
		// Find out whether it is a LNK file.
		else if (_tcsstr(pstrTemp, ".lnk") != NULL)	
		{
			// Make the call to ResolveIt here.
			dwSuc = (DWORD)ResolveIt(pstrTemp);
			g_bstrOpenFileName = pstrTemp;
		}
	}
    else
   	{
		g_bstrOpenFileName = "";
    }

	return dwSuc;
}


//
//   FUNCTION: ResolveIt
//
//   PURPOSE: Find the destination of a shortcut.
//
//   COMMENTS:
//
//	 This function resolves the short-cut and populates the global variables
//   and calls back the OpenTheFile to display the appropriate folder.
//	
//   RETURN VALUES:
//   standard hres codes
//
//
HRESULT ResolveIt(TCHAR *pszShortcutFile)
{
	HRESULT hres = S_OK;
    IShellLink *psl;

	USES_CONVERSION;
	TCHAR szGotPath[MAX_PATH];
	TCHAR szDescription[MAX_PATH];
	WIN32_FIND_DATA wfd;

	if ( NULL == pszShortcutFile )
	{
		return hres;
	}

    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (void **)&psl);

    if (SUCCEEDED(hres))
    {
		// If hres is success, it means that psl is not NULL. Hence no explicit
		// check is done for NULL values.
        IPersistFile *ppf;

        // Get a pointer to the IPersistFile interface.
        hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
        if (SUCCEEDED(hres))
        {
			// If hres is success, it means that ppf is not NULL. Hence no explicit
			// check is done for NULL values.
             WORD wsz[MAX_PATH];   // buffer for Unicode string

             // Ensure that the string consists of Unicode characters.
             MultiByteToWideChar(CP_ACP, 0, pszShortcutFile, -1, wsz,
                                 MAX_PATH);
			 
			 // Load the shortcut.
             hres = ppf->Load(wsz, STGM_READ);
             if (SUCCEEDED(hres))
             {
                // Resolve the shortcut.
                hres = psl->Resolve(GetFocus(), SLR_ANY_MATCH);

                if (SUCCEEDED(hres))
				{
					_tcscpy(szGotPath, pszShortcutFile);
                   	
					// Get the parth to the shortcut target.
                   	hres = psl->GetPath(szGotPath, MAX_PATH,
                   	   (WIN32_FIND_DATA *)&wfd, SLGP_SHORTPATH );
				   	if (!SUCCEEDED(hres))
					{
						TCHAR szErrMsg[MAX_PATH+1];
						LoadString(g_hInst, IDS_URECLNKFILE, szErrMsg,MAX_PATH);

						TCHAR szErrCaption[MAX_PATH+1];
						LoadString(g_hInst, IDS_GETPATHFAILED, szErrCaption,MAX_PATH);
				
						MessageBox(GetFocus(), szErrMsg, szErrCaption, MB_OK);						
					}

					// Get the description of the target.
	               	hres = psl->GetDescription(szDescription, MAX_PATH);
					if (!SUCCEEDED(hres))
					{
						TCHAR szErrMsg[MAX_PATH+1];
						LoadString(g_hInst, IDS_URECLNKFILE, szErrMsg,MAX_PATH);

						TCHAR szErrCaption[MAX_PATH+1];
						LoadString(g_hInst, IDS_GETDESCFAILED, szErrCaption,MAX_PATH);
						
						MessageBox(GetFocus(), szErrMsg, szErrCaption, MB_OK);
					}
					//hres = OpenTheFile(szGotPath);
					lstrcpy(pszShortcutFile,szGotPath);
					hres = 1;
				}
             }
         
			 // Release the pointer to IPersistFile.
			 // ppf is not checked for NULL value because the control wouldn't come here 
			 // otherwise (in the case where QueryInterface would have failed).
			ppf->Release();
		 }

		// Release the pointer to IShellLink.
		// psl is not checked for NULL value because the control comes here only if it is 
		// not NULL when the CoCreateInstance succeeds.
		psl->Release();
	 }
   return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\racplsettings\racplsettings.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RACPLSettings.h

Abstract:


Author:

    Rajesh Soy 10/00

Revision History:
    
    Rajesh Soy - created 10/26/2000

--*/

#include <regapi.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Registry locations where the remote assistance control panel settings go
//
#define	REG_KEY_REMOTEASSISTANCE		    REG_CONTROL_GETHELP 

//
// Remote Assistance Mode
//
#define	REG_VALUE_MODE			            POLICY_TS_REMDSK_ALLOWTOGETHELP  
#define	REG_DWORD_RA_DISABLED		        0       // No Help
#define REG_DWORD_RA_NORC                   1       // No Remote Control
#define	REG_DWORD_RA_SHADOWONLY	            2       // View only
#define	REG_DWORD_RA_ENABLED		        3       // Full control


#define REG_DWORD_RA_DEFAULTMODE            REG_DWORD_RA_ENABLED

//
// Allow Unsolicited Remote Assistance
//
#define	REG_VALUE_UNSOLICITED		        _T("UnSolicited")
#define REG_DWORD_RA_ALLOW                  1
#define REG_DWORD_RA_DISALLOW               0
#define REG_DWORD_RA_UNSOLICITED_DEFAULT    REG_DWORD_RA_DISALLOW

//
// Maximum Ticket Timeout
//
#define	REG_VALUE_MAX_TICKET		        _T("TicketTimeout")
#define REG_DWORD_RA_TIMEOUT_MIN            1
#define REG_DWORD_RA_TIMEOUT_MAX            (30 * 24 * REG_DWORD_RA_TIMEOUT_MIN)
#define REG_DWORD_RA_DEFAULT_TIMEOUT        REG_DWORD_RA_TIMEOUT_MIN


#ifdef RACPLSETTINGS_EXPORTS
#define RACPLSETTINGS_API __declspec(dllexport)
#else
#define RACPLSETTINGS_API __declspec(dllimport)
#endif


//
// RACPLSettings: Current Remote Assistance Settings
//
typedef struct {
    //
    // Remote Assistance Mode
    //
    DWORD   dwMode;

    //
    // Allow Unsolicited Remote Assistance
    //
    DWORD   dwUnsolicited;

    //
    // Maximum Ticket Timeout
    //
    DWORD   dwMaxTimeout;
} RACPLSETTINGS, *PRACPLSETTINGS;


//
// CRACPLSettingsDialog: UI for changing the remote assistance settings
//
class CRACPLSettingsDialog: public CDialog
{
private:
    RACPLSETTINGS  m_RACPLSettings;   // The RA Settings

public:
    //
    // Constructor
    //
    CRACPLSettingsDialog()
    {
        //
        // Nothing special
        //
    }

    //
    // Overrides
    //
    BOOL    OnInitDialog();


};


//
// CRACPLSettings: This class implements the registry access routines that
// provide the functionality for setting and querying the Remote Access Settings
//
class CRACPLSettings
{
private:
    
    //
    // Registy Access Class
    //
    CRegKey *m_pcRegKey;
    
    //
    // Remote Assistance Control Panel Settings
    //
    RACPLSETTINGS   m_RACPLSettings;
    
public:


    //
    // Constructor
    //
    CRACPLSettings(void);
    
    //
    // Destructor
    //
    ~CRACPLSettings()
    {
        if( NULL != m_pcRegKey )
        {
            m_pcRegKey->Close();
            m_pcRegKey = NULL;
        }
    }

    //
    // Initializes the RACPLSettings API
    //
	DWORD OpenRACPLSettings();

    //
    // Closes the RACPLSettings
    //
    DWORD CloseRACPLSettings();

    //
    // Get the Remote Assistance Settings
    //
    DWORD GetRACPLSettings(
        PRACPLSETTINGS  pRACPLSettings  // pointer to RACPLSETTINGS
        );

    //
    // Set the Remote Assistance Settings
    //
    DWORD SetRACPLSettings( 
        PRACPLSETTINGS pRACPLSettings   // pointer to RACPLSETTINGS
        );
};



//
// Functions exposed by the RACPLSettings API
//
RACPLSETTINGS_API DWORD OpenRACPLSettings(void);
RACPLSETTINGS_API DWORD CloseRACPLSettings(void);
RACPLSETTINGS_API DWORD GetRACPLSettings(PRACPLSETTINGS pRACPLSettings);
RACPLSETTINGS_API DWORD SetRACPLSettings(PRACPLSETTINGS pRACPLSettings);


//
// Function pointers for RACPLSettings API
//
typedef DWORD (*pfnOpenRACPLSettings)(void);
typedef DWORD (*pfnCloseRACPLSettings)(void);
typedef DWORD (*pfnGetRACPLSettings)(PRACPLSETTINGS pRACPLSettings);
typedef DWORD (*pfnSetRACPLSettings)(PRACPLSETTINGS pRACPLSettings);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\fileopen.cpp ===
/*************************************************************************
	FileName : FileOpen.cpp 

	Purpose  : Implementation of CFileOpen

    Methods 
	defined  : OpenFileOpenDlg

    Properties
	defined  :
			   FileName

    Helper 
	functions: GET_BSTR 

  	Author   : Sudha Srinivasan (a-sudsi)
*************************************************************************/

#include "stdafx.h"
#include "SAFRCFileDlg.h"
#include "FileOpen.h"
#include "DlgWindow.h"

CComBSTR g_bstrOpenFileName;
BOOL   g_bOpenFileNameSet = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CFileOpen


STDMETHODIMP CFileOpen::OpenFileOpenDlg(DWORD *pdwRetVal)
{
	// TODO: Add your implementation code here
	HRESULT hr = S_OK;
	if (NULL == pdwRetVal)
	{
		hr = S_FALSE;
		goto done;
	}
	*pdwRetVal = OpenTheFile(NULL);
done:
	return hr ;
}

void CFileOpen::GET_BSTR (BSTR*& x, CComBSTR& y)
{
//    if (y.Length() > 0)
        *x = y.Copy();
}

STDMETHODIMP CFileOpen::get_FileName(BSTR *pVal)
{
	// TODO: Add your implementation code here
	GET_BSTR(pVal, g_bstrOpenFileName);
	return S_OK;
}

STDMETHODIMP CFileOpen::put_FileName(BSTR newVal)
{
	// TODO: Add your implementation code here
	g_bstrOpenFileName = newVal;
	g_bOpenFileNameSet = TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\filesave.h ===
/*************************************************************************
	FileName : FileSave.h 

	Purpose  : Declaration of CFileSave

    Methods 
	defined  : OpenFileSaveDlg

    Properties
	defined  :
			   FileName

    Helper 
	functions: GET_BSTR 

  	Author   : Sudha Srinivasan (a-sudsi)
*************************************************************************/

#ifndef __FILESAVE_H_
#define __FILESAVE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFileSave
class ATL_NO_VTABLE CFileSave : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFileSave, &CLSID_FileSave>,
	public IDispatchImpl<IFileSave, &IID_IFileSave, &LIBID_SAFRCFILEDLGLib>
{
public:
	CFileSave()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FILESAVE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFileSave)
	COM_INTERFACE_ENTRY(IFileSave)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFileSave
public:
	STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FileType)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FileType)(/*[in]*/ BSTR newVal);
	STDMETHOD(OpenFileSaveDlg)(/*[out, retval]*/ DWORD *pdwRetVal);
private:
	void GET_BSTR (BSTR*& x, CComBSTR& y);
};

#endif //__FILESAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\filesave.cpp ===
/*************************************************************************
	FileName : FileSave.cpp 

	Purpose  : Implementation of CFileSave

    Methods 
	defined  : OpenFileSaveDlg

    Properties
	defined  :
			   FileName

    Helper 
	functions: GET_BSTR 

  	Author   : Sudha Srinivasan (a-sudsi)
*************************************************************************/
#include "stdafx.h"
#include "SAFRCFileDlg.h"
#include "FileSave.h"
#include "DlgWindow.h"

CComBSTR g_bstrFileName;
CComBSTR g_bstrFileType;
BOOL   g_bFileNameSet = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CFileSave


STDMETHODIMP CFileSave::OpenFileSaveDlg(DWORD *pdwRetVal)
{
	HRESULT hr = S_OK;
	if (NULL == pdwRetVal)
	{
		hr = S_FALSE;
		goto done;
	}
		
	*pdwRetVal = SaveTheFile();
done:
	return hr;
}

STDMETHODIMP CFileSave::get_FileName(BSTR *pVal)
{
	GET_BSTR(pVal, g_bstrFileName);
	return S_OK;
}

STDMETHODIMP CFileSave::put_FileName(BSTR newVal)
{
	g_bstrFileName = newVal;
	g_bFileNameSet = TRUE;
	return S_OK;
}

STDMETHODIMP CFileSave::get_FileType(BSTR *pVal)
{
	GET_BSTR(pVal, g_bstrFileType);
	return S_OK;
}

STDMETHODIMP CFileSave::put_FileType(BSTR newVal)
{
  	g_bstrFileType = newVal;
	return S_OK;
}

void CFileSave::GET_BSTR(BSTR *&x, CComBSTR &y)
{
    //if (y.Length() > 0)
        *x = y.Copy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\panic.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    Panic.cpp

Abstract:
    Sets up a Key board hook on calling SetPanicHook and removes the KeyBoard hook on calling 
	ClearPanicHook. Calling SetPanicHook creates a new thread which waits for the setting of an
	named event. And on the setting of the named event it Invokes the script function pointer 
	passed to SetPanicHook.

Revision History:
    created     a-josem      1/3/01
	revised		a-josem		 1/4/01  Added comments and function headers.
    
*/

// Panic.cpp : Implementation of CPanic
#include "stdafx.h"
#include "SAFRCFileDlg.h"
#include "Panic.h"

/////////////////////////////////////////////////////////////////////////////
// CPanic
CHookHnd CPanic::m_Hook;
HANDLE CPanic::m_hPanicThread = NULL;
LPSTREAM g_spStream = NULL;
BOOL g_bHookActive = FALSE;
/*++
Routine Description:
	Destructor, In case the m_hEvent is not set it sets the event and exits. Setting of
	the event makes the Panic watch thread to come out of wait.	

Arguments:
	None

Return Value:
	None
--*/

CPanic::~CPanic()
{
	g_bHookActive = FALSE;
	if (m_hEvent)
	{
		SetEvent(m_hEvent);
	}
}

/*++
Routine Description:
	Called from script to setup a Panic Keyboard Hook. It also Marshalls the IDispatch ptr
	to LPSTREAM to be used by the Panic watch thread. If the Panic watch thread is not created
	this function creates the thread.

Arguments:
	iDisp - Function pointer to the JavaScript function passed from script

Return Value:
	S_OK on success.
--*/
STDMETHODIMP CPanic::SetPanicHook(IDispatch *iDisp)
{
	m_Hook.SetHook();
	if (iDisp)
	{
		if (m_ptrScriptFncPtr != iDisp)
		{
			m_ptrScriptFncPtr = iDisp;
			g_bHookActive = TRUE;
			CoMarshalInterThreadInterfaceInStream(IID_IDispatch,iDisp,&g_spStream);
			if (m_hPanicThread != NULL)
			{
				if (WAIT_TIMEOUT != WaitForSingleObject(m_hPanicThread,0) )
				{
					if (m_hPanicThread != NULL)
					{
						CloseHandle(m_hPanicThread);
						m_hPanicThread = NULL;
					}
					DWORD ThreadId; 
					m_hPanicThread = CreateThread(NULL,0,PanicThread,this,0,&ThreadId);
				}
			}
			else
			{
				DWORD ThreadId; 
				m_hPanicThread = CreateThread(NULL,0,PanicThread,this,0,&ThreadId);
			}
		}
	}
	return S_OK;
}

/*++
Routine Description:
	Clears the PanicHook. And Sets the Event so that the thread comes out of wait and exits 
	gracefully.

Arguments:
	None

Return Value:
	S_OK on success.
--*/
STDMETHODIMP CPanic::ClearPanicHook()
{
	m_Hook.UnHook();
	m_ptrScriptFncPtr = NULL;
	g_bHookActive = FALSE;
	if (m_hEvent)
	{
		SetEvent(m_hEvent);
	}
	return S_OK;
}

/*++
Routine Description:
	The thread function creates an Event and waits for the Event to be set. The event is set
	when the Panic key is pressed. It immediately comes out of the wait state and calls the 
	Javascript function.

Arguments:
	lpParameter - CPanic Object address

Return Value:
	S_OK on success.
--*/
DWORD WINAPI CPanic::PanicThread(LPVOID lpParameter)
{
	CoInitialize(NULL);
	CPanic *ptrThis = (CPanic *)lpParameter;

	if (g_spStream)
	{
		CComPtr<IDispatch> ptrIDisp;
		CoGetInterfaceAndReleaseStream(g_spStream,IID_IDispatch,(void**)&ptrIDisp);
		g_spStream = NULL;

		ptrThis->m_hEvent = CreateEvent(NULL,FALSE,FALSE,_T(EventName));
		HRESULT hr;

		while (g_bHookActive == TRUE)
		{
			DWORD dwWaitResult = WaitForMultipleObjects(1,&(ptrThis->m_hEvent),TRUE,INFINITE);

			switch (dwWaitResult) 
			{
				case WAIT_OBJECT_0: 
					{
						if ((ptrIDisp != NULL) && (g_bHookActive == TRUE))
						{
							DISPPARAMS disp = { NULL, NULL, 0, 0 };
							hr = ptrIDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
						}
						break; 
					}
			}
			ResetEvent(ptrThis->m_hEvent);
		}
		if (ptrThis->m_hEvent)
		{
			CloseHandle(ptrThis->m_hEvent);
			ptrThis->m_hEvent = NULL;
		}
	}

	CoUninitialize();
	return 0;
}

/*++
Routine Description:
	Called when ever a key board event occurs. It handles only WM_KEYUP of Esc Key.

Arguments:
	code 
	wParam
	lParam

Return Value:
	returns what ever CallNextHookEx returns.
--*/
LRESULT CALLBACK KeyboardProc(int code,WPARAM wParam,LPARAM lParam)
{
	if (code == HC_ACTION)
	{
		if ((wParam == 27) & (lParam >> 31))
		{
			HANDLE hEvent = CreateEvent(NULL,FALSE,FALSE,_T(EventName));
			if (hEvent)
			{
				SetEvent(hEvent);
				CloseHandle(hEvent);
			}
		}
	}
	return CallNextHookEx(CPanic::m_Hook.m_hHook,code,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\fileopen.h ===
/*************************************************************************
	FileName : FileOpen.h 

	Purpose  : Declaration of CFileOpen

    Methods 
	defined  : OpenFileOpenDlg

    Properties
	defined  :
			   FileName

    Helper 
	functions: GET_BSTR 

  	Author   : Sudha Srinivasan (a-sudsi)
*************************************************************************/

#ifndef __FILEOPEN_H_
#define __FILEOPEN_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFileOpen
class ATL_NO_VTABLE CFileOpen : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFileOpen, &CLSID_FileOpen>,
	public IDispatchImpl<IFileOpen, &IID_IFileOpen, &LIBID_SAFRCFILEDLGLib>
{
public:
	CFileOpen()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FILEOPEN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFileOpen)
	COM_INTERFACE_ENTRY(IFileOpen)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
	void GET_BSTR (BSTR*& x, CComBSTR& y);

// IFileOpen
public:
	STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);
	STDMETHOD(OpenFileOpenDlg)(/*[out, retval]*/ DWORD *pdwRetVal);
};

#endif //__FILEOPEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\panic.h ===
// Panic.h : Declaration of the CPanic

#ifndef __PANIC_H_
#define __PANIC_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPanic
#define EventName "{26ED148B-1050-461d-9999-3A5002D0103D}"

LRESULT CALLBACK KeyboardProc(int code,WPARAM wParam,LPARAM lParam);

class CHookHnd
{
public:
	HHOOK m_hHook;

	CHookHnd()
	{
		m_hHook = NULL;
	}

	~CHookHnd()
	{
		if (m_hHook)
			UnhookWindowsHookEx(m_hHook);
	}

	HHOOK SetHook()
	{
		if (!m_hHook)
		{
			m_hHook = SetWindowsHookEx(WH_KEYBOARD,KeyboardProc,_Module.GetModuleInstance(),NULL);
		}
		return m_hHook;
	}

	BOOL UnHook()
	{
		BOOL bRetVal = TRUE;
		if (m_hHook)
		{
			bRetVal = UnhookWindowsHookEx(m_hHook);
			if (bRetVal == TRUE)
				m_hHook = NULL;
		}
		return bRetVal;
	}
};

class ATL_NO_VTABLE CPanic : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPanic, &CLSID_Panic>,
	public IDispatchImpl<IPanic, &IID_IPanic, &LIBID_SAFRCFILEDLGLib>
{
public:
	CPanic()
	{
		m_hEvent = NULL;
	}

	~CPanic();

DECLARE_REGISTRY_RESOURCEID(IDR_PANIC)
DECLARE_NOT_AGGREGATABLE(CPanic)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPanic)
	COM_INTERFACE_ENTRY(IPanic)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	CComPtr<IDispatch> m_ptrScriptFncPtr;
	HANDLE m_hEvent;
	static CHookHnd m_Hook;
	static HANDLE m_hPanicThread;
	static DWORD WINAPI PanicThread(LPVOID lpParameter);

// IPanic
public:
	STDMETHOD(ClearPanicHook)();
	STDMETHOD(SetPanicHook)(/*[in]*/ IDispatch *iDisp);
};

#endif //__PANIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\safrcfiledlg.cpp ===
// SAFRCFileDlg.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SAFRCFileDlgps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SAFRCFileDlg.h"

#include "SAFRCFileDlg_i.c"
#include "FileSave.h"
#include "FileOpen.h"
#include "Panic.h"
#include "Setting.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_FileSave, CFileSave)
OBJECT_ENTRY(CLSID_FileOpen, CFileOpen)
OBJECT_ENTRY(CLSID_Panic, CPanic)
OBJECT_ENTRY(CLSID_RASetting, CSetting)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SAFRCFILEDLGLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SAFRCFileDlg.rc
//
#define IDS_PROJNAME                    100
#define IDR_FILESAVE                    101
#define IDR_FILEOPEN                    102
#define IDR_PANIC						103
#define IDR_SETTING						104



#define	IDS_ALLFILESFILTER				150
#define	IDS_SAVEFILE					151
#define	IDS_CHOOSEFILE					152
#define	IDS_URECLNKFILE					153
#define IDS_GETPATHFAILED				154
#define IDS_GETDESCFAILED				155

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__068A3AD9_81C0_4C70_95E4_66CC5D86769D__INCLUDED_)
#define AFX_STDAFX_H__068A3AD9_81C0_4C70_95E4_66CC5D86769D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <Commdlg.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__068A3AD9_81C0_4C70_95E4_66CC5D86769D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\setting.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    setting.cpp

Abstract:
    CSetting object. Used to support Remote Assistance Channel settings.

Revision History:
    created     steveshi      08/23/00
    
*/

#include "stdafx.h"
#include "SAFRCFileDlg.h"
#include "setting.h"
#include "userenv.h"
#include "stdio.h"

const TCHAR cstrRCBDYINI[] = _T("RcBuddy.ini");
const TCHAR cstrRCBDYAPP[] = _T("RcBuddyChannel");
const TCHAR cstrSubDir[] = _T("\\Local Settings\\Application Data\\RcIncidents");
extern HINSTANCE g_hInstance;

BOOL CreateRAIncidentDirectory(LPTSTR path, LPCTSTR subPath);
/*********************************************************
Func:
    GetProfileString

Abstract:
    Get profile string inside the channel's setting file.

Params:
    bstrSec: Section key.
    pVal:    Output string (default is "0", if not found.)
 *********************************************************/
HRESULT CSetting::GetProfileString(BSTR bstrSec, BSTR* pVal)
{
    HRESULT hr = S_FALSE;
    TCHAR sBuf[512];
    DWORD dwSize;
    USES_CONVERSION;

    if (FAILED(InitProfile()))
        goto done;

    dwSize = GetPrivateProfileString(cstrRCBDYAPP, 
                                     W2T(bstrSec), 
                                     TEXT("0"), &sBuf[0], 512, m_pIniFile);

    *pVal = CComBSTR(sBuf).Copy();
    hr = S_OK;

done:
    return hr;
}

/*********************************************************
Func:
    SetProfileString

Abstract:
    Set profile string inside the channel's setting file.

Params:
    bstrSec: Section key.
    bstrVal: New value
 *********************************************************/
HRESULT CSetting::SetProfileString(BSTR bstrSec, BSTR bstrVal)
{
    HRESULT hr = S_FALSE;
    USES_CONVERSION;

    if (FAILED(InitProfile()))
        goto done;

	//MessageBox(NULL,m_pIniFile,OLE2T(bstrSec),MB_OK);
    if (!WritePrivateProfileString(cstrRCBDYAPP, W2T(bstrSec), W2T(bstrVal), m_pIniFile))
        goto done;

    hr = S_OK;

done:
    return hr;
}

/*********************************************************
Func:
    get_GetUserProfileDirectory

Abstract:
    Return user's profile directory
 *********************************************************/

HRESULT CSetting::get_GetUserProfileDirectory(/*[out, retval]*/ BSTR *pVal)
{
    HRESULT hr = S_FALSE;
    if (FAILED(hr = InitProfile()))
        goto done;

    *pVal = CComBSTR(m_pProfileDir).Detach();

done:
    return hr;
}

/*********************************************************
Func:
    get_GetUserTempFileName

Abstract:
    Return a temp file name under user's profile directory
 *********************************************************/

HRESULT CSetting::get_GetUserTempFileName(/*[out, retval]*/ BSTR *pVal)
{
	HRESULT hr = S_FALSE; 
    TCHAR sFile[MAX_PATH + 256];

    if(FAILED(InitProfile()))
        goto done;

    // Get Temp file name
    if (!GetTempFileName(m_pProfileDir, _T("RC"), 0, &sFile[0]))
        goto done;

    *pVal = CComBSTR(sFile).Copy();
    hr = S_OK;

done:
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////
// Helper functions used to support the above methods or properties
/////////////////////////////

/*********************************************************
Func:
    InitProfile

Abstract:
    Create the setting file.
    A RCIncidents subdir will be created under user's profile dir.
    A RcBuddy.ini file be created as the user's RA channel setting file.

 *********************************************************/
HRESULT CSetting::InitProfile()
{
    HRESULT hr = E_FAIL;

    if (m_pProfileDir && m_pIniFile) // No need to process
        return S_OK;

    if (m_pProfileDir || m_pIniFile) // Only one has value: Error. No need to process either.
        return E_FAIL;

    // Get User profile directory
    HANDLE hProcess = GetCurrentProcess();
    TCHAR* pPath = NULL;

    TCHAR sPath[MAX_PATH];
    ULONG ulSize = sizeof(sPath) - sizeof(cstrSubDir) -1; // preserve space for subdir.
    TCHAR sFile[MAX_PATH + 256];
    HANDLE hToken = NULL;
    int iRet = 0;
    BOOL bNeedFree = FALSE;

    if (!OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_WRITE, &hToken))
        goto done;

    if (!GetUserProfileDirectory(hToken, &sPath[0], &ulSize)) // Buffer not big enough
    {
        if (ulSize == sizeof(sPath)-1) // Not because of insufficent space.
            goto done;

        pPath = (TCHAR*)malloc((ulSize+1+sizeof(cstrSubDir))*sizeof(TCHAR));
        if (!pPath)
		{
			hr = E_OUTOFMEMORY;
            goto done;
		}

        bNeedFree = TRUE;

        if (!GetUserProfileDirectory(hToken, pPath, &ulSize))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
		}
    }

    if (!pPath)
        pPath = sPath;

// Create RCIncidents sub dir
//  _tcscat(pPath, sSubDir);
//  iRet = SHCreateDirectoryEx(NULL, pPath, NULL);
	BOOL retVal = CreateRAIncidentDirectory(pPath, cstrSubDir);

	if (retVal == FALSE)
		goto done;
	_tcscat(pPath, cstrSubDir);
//  if (iRet != ERROR_SUCCESS && iRet != ERROR_ALREADY_EXISTS)
//        goto done;

    // Set variables
    iRet = (_tcslen(pPath) + 1) * sizeof(TCHAR);
    m_pProfileDir = (TCHAR*)malloc(iRet);
    if (!m_pProfileDir)
	{
		hr = E_OUTOFMEMORY;
        goto done;
	}
    
    memcpy(m_pProfileDir, pPath, iRet);
	
    m_pIniFile = (TCHAR*)malloc(iRet + (1+sizeof(cstrRCBDYINI))*sizeof(TCHAR));
    if (!m_pIniFile)
	{
		hr = E_OUTOFMEMORY;
        goto done;
	}

    _stprintf(m_pIniFile, _T("%s\\%s"), m_pProfileDir, cstrRCBDYINI);
    hr = S_OK;

done:
    if (hToken)
        CloseHandle(hToken);

    if (bNeedFree)
        free(pPath);

    return hr;
}

/*********************************************************
Func:
    get_GetPropertyInBlob

Abstract:
    Get the specified property value in Blob

Params:
    bstrBlob: Blob for searching. (ex: 8;PASS=ABC )
    bstrName: property name. (ex: "PASS", without '=' char)
 *********************************************************/
HRESULT CSetting::get_GetPropertyInBlob(/*[in]*/ BSTR bstrBlob, /*[in]*/ BSTR bstrName, /*[out, retval]*/ BSTR *pVal)
{
    HRESULT hRet = S_FALSE;
    WCHAR *p1, *p2, *pEnd;
    LONG lTotal =0;
    size_t lProp = 0;
    size_t iNameLen;

    if (!bstrBlob || *bstrBlob==L'\0' || !bstrName || *bstrName ==L'\0'|| !pVal)
        return FALSE;

    iNameLen = wcslen(bstrName);

    pEnd = bstrBlob + wcslen(bstrBlob);
    p1 = p2 = bstrBlob;

    while (1)
    {
        // get porperty length
        while (*p2 != L';' && *p2 != L'\0' && iswdigit(*p2) ) p2++;
        if (*p2 != L';')
            goto done;

        *p2 = L'\0'; // set it to get length
        lProp = _wtol(p1);
        *p2 = L';'; // revert it back.
    
        // get property string
        p1 = ++p2;
    
        while (*p2 != L'=' && *p2 != L'\0' && p2 < p1+lProp) p2++;
        if (*p2 != L'=')
            goto done;

        if ((p2-p1==iNameLen) && (wcsncmp(p1, bstrName, iNameLen)==0) )
        {
            if (lProp == iNameLen+1) // A=B= case (no value)
                goto done;

            WCHAR C = *(p2 + lProp-iNameLen);
            *(p2 + lProp-iNameLen) = L'\0';
            *pVal = SysAllocString(p2+1);
            *(p2 + lProp-iNameLen) = C;
            hRet = S_OK;
            break;
        }

        // check next property
        p2 = p1 = p1 + lProp;
        if (p2 > pEnd)
            break;
    }

done:
    return hRet;

}

STDMETHODIMP CSetting::AddPropertyToBlob(BSTR pName, BSTR pValue, BSTR poldBlob, BSTR *pnewBlob)
{
    WCHAR *pszBuf = NULL;
    LONG len, lOldBlob = 0;
    BOOL bHasValue = FALSE;

    if(!pName || *pName==L'\0' || !pnewBlob)
    {
        goto done;
    }

    if(poldBlob && *poldBlob != L'\0')
        lOldBlob = wcslen(poldBlob);

    len = wcslen(pName) + 1; // ;pName=pValue  1 is for the '='
    if (pValue && *pValue != L'\0')
    {
        len += wcslen(pValue);
        bHasValue = TRUE;
    }

    pszBuf = new WCHAR[len + lOldBlob + 1];
    if (lOldBlob > 0)
    {
        if (bHasValue)
        {
            swprintf(pszBuf, L"%s%d;%s=%s", poldBlob, len, pName, pValue);
        }
        else
        {
            swprintf(pszBuf, L"%s%d;%s=", poldBlob, len, pName);
        }
    }
    else
    {
        if (bHasValue)
            swprintf(pszBuf, L"%d;%s=%s", len, pName, pValue);
        else
            swprintf(pszBuf, L"%d;%s=", len, pName);
    }

 done:
    *pnewBlob = ::SysAllocString(pszBuf);
    if (pszBuf) delete pszBuf;

    return S_OK;
}

BOOL CreateRAIncidentDirectory(LPTSTR path, LPCTSTR subPath)
{
	BOOL bRetVal = FALSE;
	TCHAR seps[] = _T("\\");
	LPTSTR ptrDirPath = NULL;
	LPTSTR ptrSubDirPath = NULL;

	ptrDirPath = new TCHAR[strlen(path) + strlen(subPath) + 1];
	if (ptrDirPath == NULL)
	{
		bRetVal = FALSE;
		goto done;
	}

	lstrcpy(ptrDirPath,path);
	ptrSubDirPath = new TCHAR[strlen(subPath) + 1];
	if (ptrSubDirPath == NULL)
	{
		bRetVal = FALSE;
		goto done;
	}
	lstrcpy(ptrSubDirPath,subPath);
	LPTSTR token = _tcstok(ptrSubDirPath, seps);

	while( token != NULL )
	{
		lstrcat(ptrDirPath,_T("\\"));
		lstrcat(ptrDirPath,token);
		//MessageBox(NULL,ptrDirPath,token,MB_OK);
		if (CreateDirectory(ptrDirPath,NULL) == 0)
		{
			DWORD err = GetLastError();
			if ((err != ERROR_ALREADY_EXISTS) && (err != ERROR_SUCCESS))
			{
				bRetVal = FALSE;
				goto done;
			}
		}
		/* Get next token: */
		token = _tcstok(NULL, seps);
	}
	bRetVal = TRUE;

done:
	if (ptrDirPath) 
		delete ptrDirPath;
	if (ptrSubDirPath)
		delete ptrSubDirPath;
	return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\rctool\safrcfiledlg\setting.h ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    setting.h

Abstract:
    Definition of the CSetting class

Revision History:
    created     steveshi      08/23/00
    
*/

#ifndef __SETTING_H_
#define __SETTING_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSetting
class ATL_NO_VTABLE CSetting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSetting, &CLSID_RASetting>,
	public IDispatchImpl<IRASetting, &IID_IRASetting, &LIBID_SAFRCFILEDLGLib>
{
public:
	CSetting()
	{
        m_pIniFile = NULL;
        m_pProfileDir = NULL;
	}

    ~CSetting()
    {
        if (m_pIniFile) free(m_pIniFile);
        if (m_pProfileDir) free(m_pProfileDir);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SETTING)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetting)
	COM_INTERFACE_ENTRY(IRASetting)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Ismapi
public:
	STDMETHOD(GetProfileString)(/*[in]*/ BSTR session, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(SetProfileString)(/*[in]*/ BSTR session, /*[in]*/ BSTR newVal);
	STDMETHOD(get_GetUserTempFileName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetPropertyInBlob)(/*[in]*/ BSTR bstrBlob, /*[in]*/ BSTR bstrName, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(AddPropertyToBlob)(BSTR Name, BSTR Value, BSTR oldBlob, BSTR *pnewBlob);
	STDMETHOD(get_GetUserProfileDirectory)(/*[out, retval]*/ BSTR *pVal);
    
public:

    TCHAR* m_pIniFile;
    TCHAR* m_pProfileDir;

protected:
    HRESULT InitProfile();
};

#endif //__SETTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SAFInciTrac.rc
//
#define IDS_PROJNAME                    100
#define IDR_SAFCHANNELNOTIFYINCIDENT    101
#define IDI_NORMALINCIDENT              107
#define IDI_ALERTINCIDENT               201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\safchannelnotifyincident.cpp ===
// SAFChannelNotifyIncident.cpp : Implementation of CSAFChannelNotifyIncident
#include "stdafx.h"
#include "obj\i386\SAFInciTrac.h"
#include "SAFChannelNotifyIncident.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFChannelNotifyIncident
UINT CSAFChannelNotifyIncident::m_nRefCount = 0;
CSAFInciTrayIcon CSAFChannelNotifyIncident::m_TrayIcon(CSAFChannelNotifyIncident::m_nRefCount);

STDMETHODIMP CSAFChannelNotifyIncident::onIncidentAdded(ISAFChannel *ch, ISAFIncidentItem *inc, long n)
{
	::MessageBox(NULL,L"In Added",NULL,MB_OK);
	m_nRefCount++;
	if (CSAFInciTrayIcon::dwThreadId == 0)
	{
		HANDLE hnd = CreateThread(NULL,0,CSAFInciTrayIcon::SAFInciTrayIconThreadFn,&m_TrayIcon,0,&CSAFInciTrayIcon::dwThreadId);
		if (hnd)
			CloseHandle(hnd);
	}
	else
	{
		m_TrayIcon.ChangeToolTip();	
	}

	return S_OK;
}

STDMETHODIMP CSAFChannelNotifyIncident::onIncidentRemoved(ISAFChannel *ch, ISAFIncidentItem *inc, long n)
{
	::MessageBox(NULL,L"In Remove",NULL,MB_OK);
	if (m_nRefCount)
	{
		m_nRefCount--;
		m_TrayIcon.ChangeToolTip();	

		if (m_nRefCount == 0)
		{
			m_TrayIcon.RemoveTrayIcon();
			if (!PostThreadMessage(CSAFInciTrayIcon::dwThreadId,WM_QUIT,0,0))
			{
				DWORD dwError = GetLastError();
				TCHAR strBuf[100];
				wsprintf(strBuf,_T("The error is %d"),dwError);
				::MessageBox(NULL,strBuf,NULL,MB_OK);
			}
			CSAFInciTrayIcon::dwThreadId = 0;
		}
	}
	return S_OK;
}

STDMETHODIMP CSAFChannelNotifyIncident::onIncidentUpdated(ISAFChannel *ch, ISAFIncidentItem *inc, long n)
{
	m_TrayIcon.m_wIconId = IDI_ALERTINCIDENT;
	m_TrayIcon.ModifyIcon();
	return S_OK;
}

STDMETHODIMP CSAFChannelNotifyIncident::onChannelUpdated(ISAFChannel *ch, long dwCode, long n)
{
//	m_TrayIcon.ChangeIcon(IDI_NORMALINCIDENT);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\safchannelnotifyincident.h ===
// SAFChannelNotifyIncident.h : Declaration of the CSAFChannelNotifyIncident

#ifndef __SAFCHANNELNOTIFYINCIDENT_H_
#define __SAFCHANNELNOTIFYINCIDENT_H_

#include "resource.h"       // main symbols
#include "SAFInciTrayIcon.h"
/////////////////////////////////////////////////////////////////////////////
// CSAFChannelNotifyIncident
class ATL_NO_VTABLE CSAFChannelNotifyIncident : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSAFChannelNotifyIncident, &CLSID_SAFChannelNotifyIncident>,
	public IDispatchImpl<ISAFChannelNotifyIncident, &IID_ISAFChannelNotifyIncident, &LIBID_SAFINCITRACLib>
{
public:
	static UINT m_nRefCount;
	CSAFChannelNotifyIncident()
	{
	}

DECLARE_CLASSFACTORY_SINGLETON(CSAFChannelNotifyIncident)
DECLARE_REGISTRY_RESOURCEID(IDR_SAFCHANNELNOTIFYINCIDENT)
DECLARE_NOT_AGGREGATABLE(CSAFChannelNotifyIncident)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSAFChannelNotifyIncident)
	COM_INTERFACE_ENTRY(ISAFChannelNotifyIncident)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

private:
	static CSAFInciTrayIcon m_TrayIcon;

// ISAFChannelNotifyIncident
public:
	STDMETHOD(onChannelUpdated)(ISAFChannel * ch, long dwCode, long n);
	STDMETHOD(onIncidentUpdated)(ISAFChannel * ch, ISAFIncidentItem * inc, long n);
	STDMETHOD(onIncidentRemoved)(ISAFChannel * ch, ISAFIncidentItem * inc, long n);
	STDMETHOD(onIncidentAdded)(ISAFChannel * ch, ISAFIncidentItem * inc, long n);
};

#endif //__SAFCHANNELNOTIFYINCIDENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( ISAFrdm )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( ISAFrdm ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\safincitrac.cpp ===
// SAFInciTrac.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SAFInciTracps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "obj\i386\SAFInciTrac.h"

#include "obj\SAFInciTrac_i.c"
#include "SAFChannelNotifyIncident.h"

const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0 && CSAFChannelNotifyIncident::m_nRefCount == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFChannelNotifyIncident, CSAFChannelNotifyIncident)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_SAFINCITRACLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_SAFCHANNELNOTIFYINCIDENT, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_SAFCHANNELNOTIFYINCIDENT, TRUE);
            nRet = _Module.RegisterServer(TRUE);

			bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
		CSAFInciTrayIcon::RemoveTrayIcon();
        Sleep(dwPause); //wait for any threads to finish
    }

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\safincitrayicon.cpp ===
// SAFInciTrayIcon.cpp: implementation of the CSAFInciTrayIcon class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SAFInciTrayIcon.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
const UINT CSAFInciTrayIcon::WM_TASKBARCREATED = ::RegisterWindowMessage(_T("TaskbarCreated"));
DWORD CSAFInciTrayIcon::dwThreadId = 0;
BOOL CSAFInciTrayIcon::m_bVisible = FALSE;
NOTIFYICONDATA  CSAFInciTrayIcon::m_tnd;

#define CHANNEL_PATH TEXT("\\PCHEALTH\\HelpCtr\\Binaries\\HelpCtr.exe -FromStartHelp -Url \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance")
#define ID_SAFINCIDENT_ICON  1
const TCHAR cstrToolTip[] = _T("Remote Assistance - %d tickets");

CSAFInciTrayIcon::CSAFInciTrayIcon(UINT &nRefCount):m_nRefCount(nRefCount)
{
	m_wIconId = IDI_NORMALINCIDENT;
}

BOOL CSAFInciTrayIcon::RemoveTrayIcon()
{
    m_tnd.uFlags = 0;
	if (m_bVisible == TRUE)
	{
		if (Shell_NotifyIcon(NIM_DELETE, &m_tnd))
			m_bVisible = FALSE;
	}
	return m_bVisible;
}

BOOL CSAFInciTrayIcon::AddTrayIcon()
{
	ZeroMemory(&m_tnd, sizeof(m_tnd));

    m_tnd.cbSize = sizeof(NOTIFYICONDATA);
    m_tnd.hWnd = m_hWnd;
    m_tnd.uID = ID_SAFINCIDENT_ICON;
	m_tnd.hIcon = ::LoadIcon(_Module.m_hInst, (LPCWSTR)m_wIconId);
	m_tnd.uCallbackMessage = WM_ICON_NOTIFY;
    m_tnd.uFlags = NIF_MESSAGE | NIF_ICON ;

    if (m_nRefCount)
	{
		m_tnd.uFlags |= NIF_TIP;
		TCHAR strbuf[64] = _T("");
		wsprintf(strbuf,cstrToolTip,m_nRefCount);
        _tcsncpy(m_tnd.szTip, strbuf, 64);
	}
    m_bVisible = Shell_NotifyIcon(NIM_ADD, &m_tnd);

	m_tnd.uFlags = 0;
	m_tnd.uVersion = NOTIFYICON_VERSION;

	if (m_bVisible == TRUE)
	{
		Shell_NotifyIcon(NIM_SETVERSION, &m_tnd);
	}
	return m_bVisible;
}

BOOL CSAFInciTrayIcon::ChangeToolTip()
{
	NOTIFYICONDATA IconData = {0};

    IconData.cbSize = sizeof(NOTIFYICONDATA);
    IconData.hWnd = m_hWnd;
    IconData.uID = ID_SAFINCIDENT_ICON;
	if (m_nRefCount)
	{
		IconData.uFlags = NIF_TIP;
		TCHAR strbuf[64] = _T("");
		wsprintf(strbuf,cstrToolTip,m_nRefCount);
        _tcsncpy(IconData.szTip, strbuf, 64);
		Shell_NotifyIcon(NIM_MODIFY, &IconData);
	}
	return TRUE;
}

BOOL CSAFInciTrayIcon::ModifyIcon()
{
	NOTIFYICONDATA IconData = {0};

    IconData.cbSize = sizeof(NOTIFYICONDATA);
    IconData.hWnd = m_hWnd;
	IconData.uID = ID_SAFINCIDENT_ICON;
    IconData.hIcon = ::LoadIcon(_Module.m_hInst, (LPCWSTR)m_wIconId);
	IconData.uFlags = NIF_ICON;
	Shell_NotifyIcon(NIM_MODIFY, &IconData);

	return TRUE;
}

BOOL CSAFInciTrayIcon::ShowBalloon(LPCTSTR szText,
                            LPCTSTR szTitle  /*=NULL*/,
                            DWORD   dwIcon   /*=NIIF_NONE*/,
                            UINT    uTimeout /*=10*/ )
{
    m_tnd.uFlags = NIF_INFO;
    _tcsncpy(m_tnd.szInfo, szText, 256);
    if (szTitle)
        _tcsncpy(m_tnd.szInfoTitle, szTitle, 64);
    else
        m_tnd.szInfoTitle[0] = _T('\0');
    m_tnd.dwInfoFlags = dwIcon;
    m_tnd.uTimeout = uTimeout * 1000;   // convert time to ms

    BOOL bSuccess = Shell_NotifyIcon (NIM_MODIFY, &m_tnd);

    // Zero out the balloon text string so that later operations won't redisplay
    // the balloon.
    m_tnd.szInfo[0] = _T('\0');

    return bSuccess;
}

DWORD WINAPI CSAFInciTrayIcon::SAFInciTrayIconThreadFn(LPVOID lpParameter)
{
	CSAFInciTrayIcon *pThis = (CSAFInciTrayIcon*)lpParameter;

	HWND hWnd = pThis->Create(NULL,CWindow::rcDefault); 

	if (::IsWindow(hWnd) == FALSE)
		return FALSE;

	MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);

	pThis->RemoveTrayIcon();
	return TRUE;
}

LRESULT CSAFInciTrayIcon::OnTrayNotification(UINT wParam, LONG lParam) 
{
	if (LOWORD(lParam) == WM_LBUTTONDBLCLK)
	{
		TCHAR szCommandLine[2048];
		STARTUPINFO StartupInfo;
		PROCESS_INFORMATION ProcInfo;

		ZeroMemory(&StartupInfo,sizeof(StartupInfo));
		StartupInfo.cb = sizeof(StartupInfo);

        TCHAR szWinDir[2048];
        GetWindowsDirectory(szWinDir, 2048);
        _stprintf(szCommandLine, _T("%s%s/rcBuddy.htm?CheckStatus=1"), szWinDir,CHANNEL_PATH);
														
		BOOL bRetVal = CreateProcess(NULL,szCommandLine,NULL,NULL,TRUE,CREATE_NEW_PROCESS_GROUP,NULL,NULL,&StartupInfo,&ProcInfo);

		if (!bRetVal)
		{
			TCHAR buff[50];
			DWORD dwLastError = GetLastError();
			wsprintf(buff,_T("%d"),dwLastError);
			MessageBox(buff);
		}
		CloseHandle(ProcInfo.hThread);
		CloseHandle(ProcInfo.hProcess);
	}
    return 1;
}

LRESULT CSAFInciTrayIcon::OnIconNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	OnTrayNotification(wParam,lParam); 
	return 0;
}

LRESULT CSAFInciTrayIcon::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	AddTrayIcon();
	return 0;
}

LRESULT CSAFInciTrayIcon::OnTaskBarCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	AddTrayIcon();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\safrdm.cpp ===
// ISAFrdm.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ISAFrdmps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SAFrdm.h"

#include "SAFrdm_i.c"
#include "SAFRemoteDesktopManager.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopManager, CSAFRemoteDesktopManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ISAFRDMLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\safincitrayicon.h ===
// SAFInciTrayIcon.h: interface for the CSAFInciTrayIcon class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SAFINCITRAYICON_H__28C12A78_DAB2_47EB_9F1C_50EFCA619B05__INCLUDED_)
#define AFX_SAFINCITRAYICON_H__28C12A78_DAB2_47EB_9F1C_50EFCA619B05__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "Resource.h"

class CSAFInciTrayIcon : public CWindowImpl<CSAFInciTrayIcon, CWindow, 
	CWinTraits<WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN, WS_EX_APPWINDOW|WS_EX_WINDOWEDGE> >  
{
public:
	CSAFInciTrayIcon(UINT &nRefCount);
	static BOOL RemoveTrayIcon();
	WORD m_wIconId;

	BOOL AddTrayIcon();
	BOOL ModifyIcon();
	BOOL ChangeToolTip();

	static DWORD WINAPI SAFInciTrayIconThreadFn(LPVOID lpParameter);


    BOOL ShowBalloon(LPCTSTR szText, LPCTSTR szTitle = NULL,
                     DWORD dwIcon = NIIF_NONE, UINT uTimeout = 10);

BEGIN_MSG_MAP(CSAFInciTrayIcon)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_TASKBARCREATED, OnTaskBarCreate)
	MESSAGE_HANDLER(WM_ICON_NOTIFY, OnIconNotify)
END_MSG_MAP()

LRESULT OnIconNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
LRESULT OnTaskBarCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

LRESULT OnTrayNotification(UINT wParam, LONG lParam); 

static DWORD dwThreadId;

private:
static BOOL m_bVisible;
static NOTIFYICONDATA  m_tnd;
static const UINT WM_TASKBARCREATED;
UINT &m_nRefCount;
};

#endif // !defined(AFX_SAFINCITRAYICON_H__28C12A78_DAB2_47EB_9F1C_50EFCA619B05__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ISAFrdm.rc
//
#define IDS_PROJNAME                    100
#define IDR_SAFREMOTEDESKTOPMANAGER     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safincitrac\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D45EBB3E_C81F_4539_B92A_F25336C78835__INCLUDED_)
#define AFX_STDAFX_H__D45EBB3E_C81F_4539_B92A_F25336C78835__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400

#define _WIN32_IE 0x0501

#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <shellapi.h>

#define	WM_ICON_NOTIFY WM_APP+10
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D45EBB3E_C81F_4539_B92A_F25336C78835__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__06D175BE_6169_4143_AC02_5B284EA0BC8A__INCLUDED_)
#define AFX_STDAFX_H__06D175BE_6169_4143_AC02_5B284EA0BC8A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "SAFrdmMsgs.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__06D175BE_6169_4143_AC02_5B284EA0BC8A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\safremotedesktopmanager.cpp ===
// SAFRemoteDesktopManager.cpp : Implementation of CSAFRemoteDesktopManager
#include "stdafx.h"
#include "SAFrdm.h"
#include "SAFRemoteDesktopManager.h"

#define MODULE_NAME	L"SAFrdm"

/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteDesktopManager


STDMETHODIMP CSAFRemoteDesktopManager::Accepted()
{
	HRESULT	hr=E_FAIL;

	if (m_boolConnectionValid)
	{
		/*
		 * Place our WTS Session ID in the registry
		 */
		m_hkSession.SetValue(m_bstrSessionEnum, L"RCSession");

		/*
		 *  Then we signal the session resolver
		 */
		SignalResolver();
		hr = S_OK;
	}

	return hr;
}

STDMETHODIMP CSAFRemoteDesktopManager::Rejected()
{
	HRESULT	hr=E_FAIL;

	if (m_boolConnectionValid)
	{
		/*
		 * Mark our response in the registry
		 */
		m_hkSession.SetValue(L"NO", L"RCSession");

		/*
		 *  Then we signal the session resolver
		 */
		SignalResolver();
		hr = S_OK;
	}

	return hr;
}

STDMETHODIMP CSAFRemoteDesktopManager::Aborted(BSTR reason)
{
	HRESULT	hr=E_FAIL;

	if (m_boolConnectionValid)
	{
		/*
		 * Mark our response in the registry
		 */
		m_hkSession.SetValue(L"NO", L"RCSession");

		/*
		 *  Write out an NT Event with the "reason" in it.
		 */
		HANDLE	hEvent = RegisterEventSource(NULL, MODULE_NAME);
		LPCWSTR	ArgsArray[1]={reason};

		if (hEvent)
		{
			ReportEvent(hEvent, EVENTLOG_INFORMATION_TYPE, 
				0,
				SAFRDM_I_ABORT,
				NULL,
				1,
				0,
				ArgsArray,
				NULL);

			DeregisterEventSource(hEvent);
		}

		/*
		 *  Then we signal the session resolver
		 */
		SignalResolver();
		hr = S_OK;
	}

	return hr;
}

STDMETHODIMP CSAFRemoteDesktopManager::get_RCTicket(BSTR *pVal)
{
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_bstrRCTicket.Copy();

	return S_OK;
}

STDMETHODIMP CSAFRemoteDesktopManager::get_DesktopUnknown(BOOL *pVal)
{
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_boolDesktopUnknown;

	return S_OK;
}

STDMETHODIMP CSAFRemoteDesktopManager::get_SupportEngineer(BSTR *pVal)
{
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_bstrSupportEngineer.Copy();

	return S_OK;
}



void CSAFRemoteDesktopManager::SignalResolver()
{
	HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_bstrEventName);

	if (hEvent)
	{
		SetEvent(hEvent);
		CloseHandle(hEvent);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__73A37E09_99F2_4F8E_BE86_E3093AA6214E__INCLUDED_)
#define AFX_DLLDATAX_H__73A37E09_99F2_4F8E_BE86_E3093AA6214E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__73A37E09_99F2_4F8E_BE86_E3093AA6214E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( SAFSessionResolver )
EXTERN_PROXY_FILE( rdshost )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( SAFSessionResolver ),
  REFERENCE_PROXY_FILE( rdshost ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\safremotedesktopmanager.h ===
// SAFRemoteDesktopManager.h : Declaration of the CSAFRemoteDesktopManager

#ifndef __SAFREMOTEDESKTOPMANAGER_H_
#define __SAFREMOTEDESKTOPMANAGER_H_

#include "resource.h"       // main symbols

#define BUF_SZ 256

/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteDesktopManager
class ATL_NO_VTABLE CSAFRemoteDesktopManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSAFRemoteDesktopManager, &CLSID_SAFRemoteDesktopManager>,
	public IDispatchImpl<ISAFRemoteDesktopManager, &IID_ISAFRemoteDesktopManager, &LIBID_ISAFRDMLib>
{
public:
	CSAFRemoteDesktopManager()
	{

		WCHAR	buf1[BUF_SZ];

		m_bstrSupportEngineer = ((GetEnvironmentVariable(L"PCHSE", 
				buf1, BUF_SZ) > 0) ? buf1 : L"Support Engineer Unknown"); 

		m_bstrRCTicket = ((GetEnvironmentVariable(L"PCHCONNECTPARMS", 
				buf1, BUF_SZ) > 0) ? buf1 : L"none provided"); 

		m_bstrSessionEnum = ((GetEnvironmentVariable(L"PCHSESSIONENUM", 
				buf1, BUF_SZ) > 0) ? buf1 : NULL); 

		m_bstrEventName = ((GetEnvironmentVariable(L"PCHEVENTNAME", 
				buf1, BUF_SZ) > 0) ? buf1 : NULL); 

		m_boolDesktopUnknown = FALSE;
		m_boolConnectionValid = FALSE;

		if (m_bstrEventName && m_bstrSessionEnum)
		{
			if (StrCmp(buf1, L"singleConnect"))
				m_boolDesktopUnknown = TRUE;

			if (ERROR_SUCCESS == m_hkSession.Open(HKEY_CURRENT_USER, L"Software/Microsoft/PCHealth", KEY_ALL_ACCESS))
				m_boolConnectionValid = TRUE;
		}
	}

	~CSAFRemoteDesktopManager()
	{
		m_bstrRCTicket.Empty();
		m_bstrSupportEngineer.Empty();
		m_bstrSessionEnum.Empty();
		m_hkSession.Close();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SAFREMOTEDESKTOPMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSAFRemoteDesktopManager)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISAFRemoteDesktopManager
public:
	STDMETHOD(get_SupportEngineer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_DesktopUnknown)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_RCTicket)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Aborted)(/*[in]*/ BSTR Val);
	STDMETHOD(Rejected)();
	STDMETHOD(Accepted)();
private:
	CComBSTR m_bstrEventName;
	void SignalResolver(void);
	CComBSTR m_bstrSessionEnum;
	CRegKey m_hkSession;
	BOOL m_boolConnectionValid;
	CComBSTR m_bstrSupportEngineer;
	CComBSTR m_bstrRCTicket;
	BOOL m_boolDesktopUnknown;
};

#endif //__SAFREMOTEDESKTOPMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "SAFSessionResolver_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\safrdm\safrdm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Jul 27 11:50:24 2000
 */
/* Compiler settings for c:\nt\pchealth\helpctr\rc\foo\ISAFrdm\ISAFrdm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ISAFrdm_h__
#define __ISAFrdm_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISAFRemoteDesktopManager_FWD_DEFINED__
#define __ISAFRemoteDesktopManager_FWD_DEFINED__
typedef interface ISAFRemoteDesktopManager ISAFRemoteDesktopManager;
#endif 	/* __ISAFRemoteDesktopManager_FWD_DEFINED__ */


#ifndef __SAFRemoteDesktopManager_FWD_DEFINED__
#define __SAFRemoteDesktopManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAFRemoteDesktopManager SAFRemoteDesktopManager;
#else
typedef struct SAFRemoteDesktopManager SAFRemoteDesktopManager;
#endif /* __cplusplus */

#endif 	/* __SAFRemoteDesktopManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISAFRemoteDesktopManager_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopManager_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopManager */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("26934FF8-F0B6-4E10-8661-23D47F4C69C5")
    ISAFRemoteDesktopManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Accepted( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Rejected( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Aborted( 
            /* [in] */ BSTR Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RCTicket( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DesktopUnknown( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportEngineer( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAFRemoteDesktopManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAFRemoteDesktopManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Accepted )( 
            ISAFRemoteDesktopManager __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rejected )( 
            ISAFRemoteDesktopManager __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Aborted )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [in] */ BSTR Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RCTicket )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DesktopUnknown )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SupportEngineer )( 
            ISAFRemoteDesktopManager __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } ISAFRemoteDesktopManagerVtbl;

    interface ISAFRemoteDesktopManager
    {
        CONST_VTBL struct ISAFRemoteDesktopManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopManager_Accepted(This)	\
    (This)->lpVtbl -> Accepted(This)

#define ISAFRemoteDesktopManager_Rejected(This)	\
    (This)->lpVtbl -> Rejected(This)

#define ISAFRemoteDesktopManager_Aborted(This,Val)	\
    (This)->lpVtbl -> Aborted(This,Val)

#define ISAFRemoteDesktopManager_get_RCTicket(This,pVal)	\
    (This)->lpVtbl -> get_RCTicket(This,pVal)

#define ISAFRemoteDesktopManager_get_DesktopUnknown(This,pVal)	\
    (This)->lpVtbl -> get_DesktopUnknown(This,pVal)

#define ISAFRemoteDesktopManager_get_SupportEngineer(This,pVal)	\
    (This)->lpVtbl -> get_SupportEngineer(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopManager_Accepted_Proxy( 
    ISAFRemoteDesktopManager __RPC_FAR * This);


void __RPC_STUB ISAFRemoteDesktopManager_Accepted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopManager_Rejected_Proxy( 
    ISAFRemoteDesktopManager __RPC_FAR * This);


void __RPC_STUB ISAFRemoteDesktopManager_Rejected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopManager_Aborted_Proxy( 
    ISAFRemoteDesktopManager __RPC_FAR * This,
    /* [in] */ BSTR Val);


void __RPC_STUB ISAFRemoteDesktopManager_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopManager_get_RCTicket_Proxy( 
    ISAFRemoteDesktopManager __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISAFRemoteDesktopManager_get_RCTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopManager_get_DesktopUnknown_Proxy( 
    ISAFRemoteDesktopManager __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB ISAFRemoteDesktopManager_get_DesktopUnknown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopManager_get_SupportEngineer_Proxy( 
    ISAFRemoteDesktopManager __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISAFRemoteDesktopManager_get_SupportEngineer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopManager_INTERFACE_DEFINED__ */



#ifndef __ISAFRDMLib_LIBRARY_DEFINED__
#define __ISAFRDMLib_LIBRARY_DEFINED__

/* library ISAFRDMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ISAFRDMLib;

EXTERN_C const CLSID CLSID_SAFRemoteDesktopManager;

#ifdef __cplusplus

class DECLSPEC_UUID("04F34B7F-0241-455A-9DCD-25471E111409")
SAFRemoteDesktopManager;
#endif
#endif /* __ISAFRDMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SAFSessionResolver.rc
//
#define IDS_PROJNAME                    100
#define IDR_SESSIONRESOLVER             101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\sessionresolver.h ===
// SessionResolver.h : Declaration of the CSessionResolver

#ifndef __SESSIONRESOLVER_H_
#define __SESSIONRESOLVER_H_

#include "resource.h"       // main symbols
#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

#define DBG_MSG_DEST_FILE		0x020

extern int gDbgFlag, iDbgFileHandle;

typedef struct  _SPLASHLIST
{
	void	*next;	
	int		refcount;
    SID		Sid;
} SPLASHLIST, *PSPLASHLIST;


/////////////////////////////////////////////////////////////////////////////
// CSessionResolver
class ATL_NO_VTABLE CSessionResolver : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSessionResolver, &CLSID_SessionResolver>,
	public IDispatchImpl<ISAFRemoteDesktopCallback, &IID_ISAFRemoteDesktopCallback, &LIBID_SAFSESSIONRESOLVERLib>
{
public:
	CSessionResolver()
	{
		CRegKey hkSpew;

		// initialize our defaults
		m_iWaitDuration = 300 * 1000;  // 5 minute timeout

#ifdef _PERF_OPTIMIZATIONS
		m_bstrResolveURL = OLESTR("hcp://system/Remote%20Assistance/RAStartPage.htm");
		m_bstrConnectURL = OLESTR("hcp://system/Remote%20Assistance/RAStartPage.htm");
		m_bstrRemoteURL = OLESTR("hcp://system/Remote%20Assistance/RAStartPage.htm");
#else
		m_bstrResolveURL = OLESTR("hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/RAStartPage.htm");
		m_bstrConnectURL = OLESTR("hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/RAStartPage.htm");
		m_bstrRemoteURL = OLESTR("hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/RAStartPage.htm");
#endif

		m_lSessionTag = 0;

		gDbgFlag = 3;
		iDbgFileHandle = 0;

		if (ERROR_SUCCESS == hkSpew.Open(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\PCHealth\\HelpCtr\\SAFSessionResolver", KEY_READ))
		{

		DWORD dwLen = sizeof(gDbgFlag);

		hkSpew.QueryValue((LPTSTR)&gDbgFlag, L"DebugSpew", &dwLen);
		}

		if (gDbgFlag & DBG_MSG_DEST_FILE)
		{
			WCHAR szLogfileName[MAX_PATH];

			GetSystemDirectory(szLogfileName, sizeof(szLogfileName)/sizeof(szLogfileName[0]));
			wcscat(szLogfileName, L"\\safrslv.log");

			iDbgFileHandle = _wopen(szLogfileName, _O_APPEND | _O_BINARY | _O_RDWR, 0);
			if (-1 != iDbgFileHandle)
			{
				OutputDebugStringA("opened debug log file\n");
			}
			else
			{
				unsigned char UniCode[2] = {0xff, 0xfe};

				// we must create the file
				OutputDebugStringA("must create debug log file");
				iDbgFileHandle = _wopen(szLogfileName, _O_BINARY | _O_CREAT | _O_RDWR, _S_IREAD | _S_IWRITE);
				if (-1 != iDbgFileHandle)
					_write(iDbgFileHandle, &UniCode, sizeof(UniCode));
				else
				{
					OutputDebugStringA("ERROR: failed to create debug log file");
					iDbgFileHandle = 0;
				}
			}
		}

		InitializeCriticalSection(&m_CritSec);
		m_pSplash = (SPLASHLIST *)LocalAlloc(LMEM_FIXED, sizeof(SPLASHLIST));
		if (m_pSplash)
		{
			// make certain that we start the splash list with an empty
			// SID.
			ZeroMemory(m_pSplash, sizeof(SPLASHLIST));
		}
	}

	~CSessionResolver()
	{
		m_bstrResolveURL.Empty();
		m_bstrConnectURL.Empty();
		m_bstrRemoteURL.Empty();
		DeleteCriticalSection(&m_CritSec);
		PSPLASHLIST	lpWalker, lpNext;

		lpWalker = m_pSplash;

		while (lpWalker)
		{
			lpNext = (SPLASHLIST *)lpWalker->next;
			LocalFree(lpWalker);
			lpWalker = lpNext;
		}
		if (iDbgFileHandle)
			_close(iDbgFileHandle);
		iDbgFileHandle = 0;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SESSIONRESOLVER)
DECLARE_NOT_AGGREGATABLE(CSessionResolver)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSessionResolver)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopCallback)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:

	//
	//  ISAFRemoteDesktopCallback Methods
	//
	STDMETHOD(OnDisconnect)(
						/*[in]*/BSTR connectParms, 
						/*[in]*/BSTR userSID, 
						/*[in]*/long sessionID
						);
	STDMETHOD(ResolveUserSessionID)(
						/*[in]*/BSTR connectParms, 
						/*[in]*/BSTR userSID, 
						/*[in]*/ BSTR expertHelpBlob,
						/*[in]*/ BSTR userHelpBlob,
						/*[in, out, retval]*/long *sessionID,
						/*[in]*/DWORD dwPID
						,/*[out]*/ULONG_PTR* hHelpCtr
						,/*[out, retval]*/int *result
						);

private:
	int		m_iWaitDuration;
	int		m_iDbgFlag;
	long	m_lSessionTag;

	CRITICAL_SECTION	m_CritSec;
	PSPLASHLIST	m_pSplash;

	CComBSTR	m_bstrResolveURL;
	CComBSTR	m_bstrConnectURL;
	CComBSTR	m_bstrRemoteURL;
};

#endif //__SESSIONRESOLVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\sessionresolver.cpp ===
// SessionResolver.cpp : Implementation of CSessionResolver
#include "stdafx.h"
#include "SAFSessionResolver.h"
#include "SessionResolver.h"
#include <sddl.h>
#include <userenv.h>
#include <winerror.h>
#include <wtsapi32.h>
#include <winsta.h>
#include <wchar.h>
#include <stdarg.h>
#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#define ANSI
#include <stdarg.h>
#include <psapi.h>

//
// HCAPI stuff
//
#include <ProjectConstants.h>
#include <MPC_utils.h>
#include <rderror.h>

#define BUF_SZ	200

typedef struct _WTS_USER_SESSION_INFO {
	DWORD	dwIndex;		// Index into full table of these
	DWORD	dwSessionId;	// WTS Session ID
	HANDLE	hUserToken;		// Access token for user
	HANDLE	hEvent;			// filled in by launchex, yank on this to say "yes"
	HANDLE	hProcess;		// filled in by CreateProcessAsUser
	HANDLE	hThread;		//  so's this
	DWORD	dwProcessId;	//  and this
	DWORD	dwThreadId;		//  and this
} WTS_USER_SESSION_INFO, *PWTS_USER_SESSION_INFO;

// stolen from internal/ds/inc

#define RtlGenRandom                    SystemFunction036

extern "C" {
BOOL WINAPI
RtlGenRandom(
    OUT PVOID RandomBuffer,
    IN  ULONG RandomBufferLength
    );
}

/*
 *  Forward declarations
 */
void SetEventLog(bool yes, WCHAR *pUser, WCHAR *pDomain);
HANDLE	OurCreateEvent(WCHAR *lpNameBfr, int iBufCnt, PSECURITY_DESCRIPTOR pSD);
PSID	GetRealSID( BSTR pTextSID);
DWORD	getUserName(PSID pUserSID, WCHAR **lpName, WCHAR **lpDomain);
HANDLE  launchEx(PSID pUserSID, WTS_USER_SESSION_INFO *UserInfo, WCHAR *ConnectParms, WCHAR *HelpUrl, WCHAR *lpName, WCHAR *lpDomain, WCHAR *expertHelpBlob, WCHAR *userHelpBlob, SECURITY_ATTRIBUTES *sa);
DWORD	GetUserSessions(PSID pUserSID, PWTS_USER_SESSION_INFO *pUserTbl, DWORD *pEntryCnt, WCHAR *lpName, WCHAR *lpDomain);
PSECURITY_DESCRIPTOR CreateSd(PSID pUserSID);
BOOL	SecurityCheck(PSID pUserSID);
DWORD	localKill(WTS_USER_SESSION_INFO *SessInfo, LPTHREAD_START_ROUTINE killThrd, LPSECURITY_ATTRIBUTES lpSA);
LPTHREAD_START_ROUTINE getKillProc(void);
BOOL	ListFind(PSPLASHLIST pSplash, PSID user);
BOOL	ListInsert(PSPLASHLIST pSplash, PSID user);
BOOL	ListDelete(PSPLASHLIST pSplash, PSID user);
BOOL GetPropertyValueFromBlob(BSTR bstrHelpBlob, WCHAR * pName, WCHAR** ppValue);

/************  things that should remain as defines ****************/
// Some environment variables used to communicate with scripts
#define ENV_USER			L"USERNAME"
#define ENV_DOMAIN			L"USERDOMAIN"
#define ENV_EVENT			L"PCHEVENTNAME"
#define ENV_INDEX			L"PCHSESSIONENUM"
#define ENV_PARMS			L"PCHCONNECTPARMS"
#define	EVENT_PREFIX		L"Alex:PCH"

#define MODULE_NAME			L"safrslv"

// I can't imagine a user having more logins than this on one server, but...
#define MAX_SESSIONS	30 // used to be 256  

/************ our debug spew stuff ******************/
void DbgSpew(int DbgClass, BSTR lpFormat, va_list ap);
void TrivialSpew(BSTR lpFormat, ...);
void InterestingSpew(BSTR lpFormat, ...);
void ImportantSpew(BSTR lpFormat, ...);
void HeinousESpew(BSTR lpFormat, ...);
void HeinousISpew(BSTR lpFormat, ...);

#define DBG_MSG_TRIVIAL			0x001
#define DBG_MSG_INTERESTING		0x002
#define DBG_MSG_IMPORTANT		0x003
#define DBG_MSG_HEINOUS			0x004
#define DBG_MSG_DEST_DBG		0x010
#define DBG_MSG_DEST_FILE		0x020
#define DBG_MSG_DEST_EVENT		0x040
#define DBG_MSG_CLASS_ERROR		0x100
#define DBG_MSG_CLASS_SECURE	0x200

#define TRIVIAL_MSG(msg)		TrivialSpew msg 
#define INTERESTING_MSG(msg)	InterestingSpew msg
#define IMPORTANT_MSG(msg)		ImportantSpew msg
#define HEINOUS_E_MSG(msg)		HeinousESpew msg
#define HEINOUS_I_MSG(msg)		HeinousISpew msg

/* Strings for some error spewage. I waste the space since these friendly strings 
 * do make it into the Event Logs...
 */
WCHAR *lpszConnectState[] = {
	L"State_Active",
	L"State_Connected",
	L"State_ConnectQuery",
	L"State_Shadow",
	L"State_Disconnected",
	L"State_Idle",
	L"State_Listen",
	L"State_Reset",
	L"State_Down",
	L"State_Init"
};

/*
 *	This global flag controls the amount of spew that we 
 *	produce. Legit values are as follows:
 *		1 = Trivial msgs displayed
 *		2 = Interesting msgs displayed
 *		3 = Important msgs displayed
 *		4 = only the most Heinous msgs displayed
 *	The ctor actually sets this to 3 by default, but it can
 *	be overridden by setting:
 *	HKLM, Software/Microsoft/SAFSessionResolver, DebugSpew, DWORD 
 */
int gDbgFlag = 0x1;
int iDbgFileHandle = 0;
long lSessionTag;

/////////////////////////////////////////////////////////////////////////////
// CSessionResolver Methods
/*************************************************************
*
*   NewResolveTSRDPSessionID(ConnectParms, userSID, *sessionID)
*	Returns the WTS SessionID for the one enabled and 
*	ready to accept Remote Control.
*
*   RETURN CODES:
*	WTS_Session_ID		Connection accepted by user
*	RC_REFUSED		Connection refused by user
*	RC_TIMEOUT		User never responded
*	NONE_ACTIVE		Found no active WTS sessions
*	API_FAILURE		Something bad happened
*
*************************************************************/
STDMETHODIMP 
CSessionResolver::ResolveUserSessionID(
	/*[in]*/BSTR connectParms, 
	/*[in]*/BSTR userSID, 
	/*[in]*/ BSTR expertHelpBlob,
	/*[in]*/ BSTR userHelpBlob,
	/*[out, retval]*/long *sessionID,
	/*[in*/ DWORD dwPID, 
	/*[out]*/ULONG_PTR *hHelpCtr
	,/*[out, retval]*/int *userResponse
	)
{
	INTERESTING_MSG((L"CSessionResolver::ResolveUserSessionID"));

	DWORD	result;
	HANDLE	hRdsAddin = NULL;
	PSID 	pRealSID = NULL;
	WCHAR	*pUsername=NULL, *pDomainname=NULL;
	PWTS_USER_SESSION_INFO pUserSessionInfo=NULL;
	PSECURITY_DESCRIPTOR	pSD=NULL;
	HRESULT	ret_code;
	int		i;
	int	TsIndex=-1;
	DWORD	dwUserSessionCnt, dwSessionCnt;
	HANDLE	pHandles[(MAX_SESSIONS*2)+1];
	DWORD	dwhIndex = 0;
	SECURITY_ATTRIBUTES	sa;
	BOOL bAlreadyHelped, bRemoval=FALSE;
    WCHAR *pExpertId=NULL, *pUserId=NULL;

	/* param validation */
	if (!connectParms || !userSID || !sessionID || !hHelpCtr
		|| !userResponse
		)
	{
		IMPORTANT_MSG((L"Invalid params ConnectParms=0x%x, UserSID=0x%x, SessionID=0x%x", connectParms, userSID, sessionID));
		ret_code = E_INVALIDARG;
		goto done;
	}

	// set a default ret code
	*userResponse = SAFERROR_INTERNALERROR;

	if (dwPID)
		hRdsAddin = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);

	if (hRdsAddin)
	{
		DWORD	dwRes;
		WCHAR	*szAddin = L"rdsaddin.exe";
		WCHAR	szTmp[32];

		dwRes = GetModuleBaseNameW(hRdsAddin, NULL, szTmp, ARRAYSIZE(szTmp));
		if (!dwRes || StrCmpI(szAddin, szTmp))
		{
			IMPORTANT_MSG((L"ERROR: the process handle for rdsaddin.exe has been recycled"));
			CloseHandle(hRdsAddin);
			hRdsAddin = 0;
		}
	}

	if (!hRdsAddin)
	{
		// If we don't have a process handle, it is because 
		// the expert has already cancelled
		ret_code = E_ACCESSDENIED;
		*userResponse = SAFERROR_CANTFORMLINKTOUSERSESSION;
		goto done;
	}

	pRealSID = GetRealSID(userSID);
	if (!pRealSID)
	{
		IMPORTANT_MSG((L"GetRealSID failed"));

		ret_code = E_ACCESSDENIED;
		*userResponse = SAFERROR_INVALIDPARAMETERSTRING;
		goto done;
	}

	EnterCriticalSection(&m_CritSec);
	bAlreadyHelped = ListFind(m_pSplash, pRealSID);
	ListInsert(m_pSplash, pRealSID);
	// mark the SID for removal
	bRemoval=TRUE;
	LeaveCriticalSection(&m_CritSec);

	if (bAlreadyHelped)
	{
		INTERESTING_MSG((L"Helpee already has a ticket on the screen"));
		*sessionID = 0;
		*userResponse = SAFERROR_HELPEECONSIDERINGHELP;
		ret_code = E_ACCESSDENIED;
		goto done;
	}

    /* check password: skip is UNSOLICITED=1 */
    if (!GetPropertyValueFromBlob(userHelpBlob, L"UNSOLICITED", &pUserId) ||
        !pUserId || *pUserId != L'1')
    {
        // Need to check password.
        if (pUserId)
        {
            LocalFree(pUserId);
            pUserId = NULL;
        }
        if (GetPropertyValueFromBlob(userHelpBlob, L"PASS", &pUserId))
        {   
            if (!GetPropertyValueFromBlob(expertHelpBlob, L"PASS", &pExpertId) || wcscmp(pExpertId, pUserId) != 0)
            {
                IMPORTANT_MSG((L"Passwords don't match"));

                ret_code = E_ACCESSDENIED;
		        *userResponse = SAFERROR_INVALIDPASSWORD;
		        goto done;
            }
        }
    }

	/* get the user's account strings */
	if (!getUserName(pRealSID, &pUsername, &pDomainname))
	{
		DWORD error = GetLastError();
		HEINOUS_E_MSG((L"getUserName() failed, err=0x%x", error));
		ret_code = E_ACCESSDENIED;
		*userResponse = SAFERROR_INVALIDPARAMETERSTRING;
		goto done;
	}

	/* 
	 * Get a list of all the active sessions on this WTS Server
	 * For a specific user
	 */
	// keeps the compiler happy
	dwSessionCnt = 0;
	result = GetUserSessions(pRealSID, 
		&pUserSessionInfo,
		&dwUserSessionCnt,
		pUsername, pDomainname);

	if (!result )
	{
		IMPORTANT_MSG((L"GetUserSessions failed %08x", GetLastError()));
		ret_code = E_FAIL;
		goto done;
	}

	/* If no sessions are found, then exit! */
	if (dwUserSessionCnt == 0) 
	{
		INTERESTING_MSG((L"no sessions found"));
		*sessionID = 0;
		*userResponse = SAFERROR_HELPEENOTFOUND;
		ret_code = E_ACCESSDENIED;
		goto done;
	}
	/* make certain we don't overflow our handle buffers */
	else if (dwUserSessionCnt > MAX_SESSIONS)
	{
		HEINOUS_I_MSG((L"Found %d active sessions for %ws/%ws, limitting to %d", dwUserSessionCnt, pDomainname, pUsername, MAX_SESSIONS));

		int i = MAX_SESSIONS;

		// free the extra WTS tokens
		while (i < dwSessionCnt)
		{
			if (pUserSessionInfo[i].hUserToken)
				CloseHandle(pUserSessionInfo[i].hUserToken);
			i++;
		}
		dwUserSessionCnt = MAX_SESSIONS;
	}

	pSD = CreateSd(pRealSID);
	if (!pSD)
	{
		IMPORTANT_MSG((L"CreateSd failed err=%08x", GetLastError()));
		ret_code = E_ACCESSDENIED;
		goto done;
	}

	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = pSD;
	sa.bInheritHandle = FALSE;

	memset(&pHandles[0], 0, sizeof(pHandles));
	pHandles[0] = hRdsAddin;

	lSessionTag = InterlockedIncrement(&m_lSessionTag);
	/*
	 *  Start up the HelpCtr in all the various TS sessions
	 */
	for(i=0; i<(int)dwUserSessionCnt; i++)
	{
		TRIVIAL_MSG((L"calling launchEx[%d] for session %d", i, pUserSessionInfo[i].dwSessionId));

		pUserSessionInfo[i].hProcess = launchEx(pRealSID,
				&pUserSessionInfo[i],
				connectParms, m_bstrResolveURL,
				pUsername, pDomainname
				,expertHelpBlob,userHelpBlob, &sa);
		pHandles[i+1] = pUserSessionInfo[i].hProcess;
		pHandles[i+1+dwUserSessionCnt] = pUserSessionInfo[i].hEvent;
	}

	/*
	 * Then wait for somebody to click on a "Yes", or a "No"
	 */
	
	// We use CoWaitForMultipleHandles otherwise, rdsaddin and sessmg
	// deadlock since sessmgr is apartment threaded
	TRIVIAL_MSG((L"Waiting. m_iWaitDuration: %ld seconds", m_iWaitDuration/1000));

	ret_code = CoWaitForMultipleHandles (
		COWAIT_ALERTABLE,
		m_iWaitDuration,
		(dwUserSessionCnt*2)+1,
		pHandles,
		&dwhIndex
		);
	if (S_OK == ret_code)
	{
		if (dwhIndex > dwUserSessionCnt)
		{
			/* somebody said "yes" */

			TsIndex = dwhIndex-dwUserSessionCnt-1;
			TRIVIAL_MSG((L"User responded YES for session 0x%x", TsIndex));

			ret_code = S_OK;
			*userResponse = SAFERROR_NOERROR;
			// mark the SID for non-removal
			bRemoval=FALSE;

			//
			// This code must not return a failure from here onwards. If it does, we must 
			// remove the SID from the list
			//
			if (hRdsAddin)
			{
				*hHelpCtr = NULL;	// start with NULL

				DuplicateHandle(GetCurrentProcess(), pUserSessionInfo[TsIndex].hProcess,
							hRdsAddin, (HANDLE *)hHelpCtr, SYNCHRONIZE, FALSE, 0);
			}
			SetEventLog(TRUE, pUsername, pDomainname);
		}
		else if (dwhIndex == 0)
		{
			// we got here because the expert bailed out, or we lost the connection
			INTERESTING_MSG((L"Expert killed RdsAddin"));
			TsIndex = -1;
			ret_code = E_ACCESSDENIED;
			*userResponse = SAFERROR_CANTFORMLINKTOUSERSESSION;
		}
		else
		{
			/* 
			 * We get here because the novice "killed" a HelpCtr session 
			 * or else the novice just said "NO"
			 */
			INTERESTING_MSG((L"User killed session or clicked NO for session 0x%x", dwhIndex-1));
			/* this keeps us from trying to kill something the user has already closed */
			TsIndex = dwhIndex-1;
			ret_code = E_ACCESSDENIED;
			*userResponse = SAFERROR_HELPEESAIDNO;
			SetEventLog(FALSE, pUsername, pDomainname);
		}
	}
	else if (RPC_S_CALLPENDING == ret_code)
	{
		TRIVIAL_MSG((L"User response timed out after %d seconds", m_iWaitDuration/1000));

		TsIndex = -1;
		ret_code = E_PENDING;
		*userResponse = SAFERROR_HELPEENEVERRESPONDED;
	}
	else
	{
		IMPORTANT_MSG((L"WaitForObject failed %08x err=%08x", result, GetLastError()));
		TsIndex = -1;
		ret_code = E_FAIL;
	}

	/*
	 * Then close all the windows (except the one in TsIndex)
	 */
	for(i=0; i<(int)dwUserSessionCnt; i++)
		{
		LPTHREAD_START_ROUTINE lpKill = getKillProc();

			if (pUserSessionInfo[i].dwIndex != TsIndex &&
				pUserSessionInfo[i].hProcess)
			{
				/* This has to be done for each instance, since we call into the process
				 * to kill itself. If we did not get "lpKill" for each seperate occurance
				 * of HelpCtr, then Very Bad Things could happen...
				 */
				TRIVIAL_MSG((L"Killing HelpCtr in process %d", pUserSessionInfo[i].hProcess));
				localKill(&pUserSessionInfo[i], lpKill, &sa);
			}
		}

	if (ret_code == S_OK)
		*sessionID = (long) pUserSessionInfo[TsIndex].dwSessionId;
done:
	if (bRemoval)
	{
		// remove the SID from the list
		EnterCriticalSection(&m_CritSec);
		ListDelete(m_pSplash, pRealSID);
		LeaveCriticalSection(&m_CritSec);
	}

	if (hRdsAddin)
		CloseHandle(hRdsAddin);

	if (pRealSID)
		LocalFree(pRealSID);

	if (pUserSessionInfo)
	{

		/* close all the handles */
		for(i=0; i<(int)dwUserSessionCnt; i++)
			{
				if (pUserSessionInfo[i].hProcess)
					CloseHandle(pUserSessionInfo[i].hProcess);

				if (pUserSessionInfo[i].hUserToken)
					CloseHandle(pUserSessionInfo[i].hUserToken);

				if (pUserSessionInfo[i].hEvent)
					CloseHandle(pUserSessionInfo[i].hEvent);
			}
		
		LocalFree(pUserSessionInfo);
	}

	if (pUsername)
		LocalFree(pUsername);

	if (pDomainname)
		LocalFree(pDomainname);

	if (pSD)
		LocalFree(pSD);

    if (pUserId) LocalFree(pUserId);
    if (pExpertId) LocalFree(pExpertId);

	INTERESTING_MSG((L"CSessionResolver::ResolveUserSessionID returns %x\n", ret_code ));
	return ret_code;
}

/*************************************************************
*
*   OnDisconnect([in] BSTR connectParms, [in] BSTR userSID, [in] long sessionID)
*	Notifies us when an RA session ends
*
*   NOTES:
*	This is called so we can maintain the state of our user prompts
*
*	WARNING: ACHTUNG: ATTENZIONE:
*	 This method must do a minimal amount of work before returning
*	 and must NEVER do anything that would cause COM to pump
*	 messages. To do so would screw Salem immensely.a
*
*   RETURN CODES:
*	NONE_ACTIVE		Found no active WTS sessions
*	API_FAILURE		Something bad happened
*
*************************************************************/

STDMETHODIMP 
CSessionResolver::OnDisconnect(
	/*[in]*/BSTR connectParms, 
	/*[in]*/BSTR userSID, 
	/*[in]*/long sessionID
	)
{
	PSID pRealSID;
	WCHAR	*pUsername=NULL, *pDomainname=NULL;
	
	if (!connectParms || !userSID)
	{
		HEINOUS_I_MSG((L"Invalid params in OnDisconnect- ConnectParms=0x%x, UserSID=0x%x", connectParms, userSID));
		return E_INVALIDARG;
	}


	INTERESTING_MSG((L"CSessionResolver::OnDisconnect-(%ws)", userSID));

	pRealSID = GetRealSID(userSID);
	if (pRealSID)
	{
		EnterCriticalSection(&m_CritSec);
		ListDelete(m_pSplash, pRealSID);
		LeaveCriticalSection(&m_CritSec);

		/* get the user's account strings */
		if (!getUserName(pRealSID, &pUsername, &pDomainname))
		{
			pUsername = L"unknown user";
			pDomainname = L"unknown domain";
		}


		/* write out an NT Event */
		HANDLE	hEvent = RegisterEventSource(NULL, MODULE_NAME);
		LPCWSTR	ArgsArray[2]={pUsername, pDomainname};

		if (hEvent)
		{
			ReportEvent(hEvent, EVENTLOG_AUDIT_SUCCESS, 
				0,
				SESSRSLR_ONDISCON,
				NULL,
				2,
				0,
				ArgsArray,
				NULL);

			DeregisterEventSource(hEvent);
		}
	}

	if (pUsername)
		LocalFree(pUsername);
	if (pDomainname)
		LocalFree(pDomainname);


	INTERESTING_MSG((L"CSessionResolver::OnDisconnect; leaving"));
	return S_OK;
}

/*************************************************************
*
*   SetEventLog(bool yes, WCHAR *pUser, WCHAR *pDomain)
*
*************************************************************/

void SetEventLog(bool yes, WCHAR *pUser, WCHAR *pDomain)
{
	/* write out an NT Event */
	HANDLE	hEvent = RegisterEventSource(NULL, MODULE_NAME);
	LPCWSTR	ArgsArray[2]={pUser, pDomain};

	if (hEvent)
	{
		ReportEvent(hEvent, yes ? EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE, 
			0,
			yes ? SESSRSLR_RESOLVEYES : SESSRSLR_RESOLVENO,
			NULL,
			2,
			0,
			ArgsArray,
			NULL);

		DeregisterEventSource(hEvent);
	}
}

/*************************************************************
*
*   GetRealSID([in] BSTR pTextSID)
*	Converts a string-based SID into a REAL usable SID
*
*   NOTES:
*	This is a stub into "ConvertStringSidToSid".
*
*   RETURN CODES:
*	NULL			Failed for some reason
*	PSID			Pointer to a real SID. Must be 
*				freed with "LocalFree"
*
*************************************************************/
PSID GetRealSID( BSTR pTextSID)
{
	PSID pRetSID = NULL;

	if (!ConvertStringSidToSidW(pTextSID, &pRetSID))
		IMPORTANT_MSG((L"ConvertStringSidToSidW(%ws) failed %08x\n", pTextSID, GetLastError()));

	return pRetSID;
}

/*************************************************************
*
*   launchEx(PSID, WTS_USER_SESSION_INFO, char * ConnectParms, char * EventName)
*
*
*   RETURN CODES:
*	0	Failed to start process
*	<>	HANDLE to started process
*
*************************************************************/

HANDLE launchEx(PSID pUserSID, WTS_USER_SESSION_INFO *UserInfo, 
				WCHAR *ConnectParms, WCHAR *HelpPageURL,
				WCHAR *pUsername, WCHAR *pDomainname,
				WCHAR *expertHelpBlob, WCHAR *userHelpBlob,
				SECURITY_ATTRIBUTES *sa
			   )
{
	BOOL 			result = FALSE;
	HANDLE			retval = 0;
	STARTUPINFOW    StartUp;
	PROCESS_INFORMATION	p_i;
	WCHAR			buf1[BUF_SZ], buf2[BUF_SZ], *lpUtf8ConnectParms=NULL;
	static WCHAR	*szEnvUser =   ENV_USER;
	static WCHAR	*szEnvDomain = ENV_DOMAIN;
	static WCHAR	*szEnvEvent =  ENV_EVENT;
	static WCHAR	*szEnvIndex =  ENV_INDEX;
	static WCHAR	*szEnvParms =  ENV_PARMS;
	static WCHAR	*szEnvExpertBlob =  L"PCHEXPERTBLOB";
	static WCHAR	*szEnvUserBlob =    L"PCHUSERBLOB";
#ifndef _PERF_OPTIMIZATIONS
	WCHAR			*pCmdLine = NULL;
	WCHAR			*pFormatString = L"\"%ws?%ws\"";
#endif
	VOID			*pEnvBlock = NULL;
	DWORD			dwUsername=0, dwDomainname=0, dwStrSz;
    MPC::wstring    strExe( HC_ROOT_HELPSVC_BINARIES L"\\HelpCtr.exe" ); 
    MPC::SubstituteEnvVariables( strExe );

#ifndef _PERF_OPTIMIZATIONS
	dwStrSz = wcslen(HelpPageURL) + wcslen(ConnectParms) + wcslen(pFormatString) + 3;
	pCmdLine = (WCHAR *)LocalAlloc(LMEM_FIXED, dwStrSz * sizeof(WCHAR));

	if (!pCmdLine)
	{
		IMPORTANT_MSG((L"LocalAlloc failed in resolver:launchex, err=0x%x", GetLastError()));
		goto done;
	}

	wsprintf(pCmdLine, pFormatString, HelpPageURL, ConnectParms);

	strExe += L" -Mode \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/RAHelpeeAcceptLayout.xml\" -url ";
	strExe += pCmdLine;
#else
	strExe += L" -Mode \"hcp://system/Remote Assistance/RAHelpeeAcceptLayout.xml\" -url ";
	strExe += HelpPageURL;
#endif

	/*
	 *  Here, we must start up a Help Center script in a WTS Session
	 *  It gets a bit sticky, though as we do not have access to the 
	 *  user's desktop (any desktop), and this must appear on only
	 *  one particular desktop. I am relying on the WTS-User-Token
	 *  to get the desktop for me.
	 *
	 *  The main component is our call to CreateProcessAsUser.
	 *  Before we call that we must:
	 *	Set up Environment as follows:
	 *	  PATH=%SystemPath%
	 *	  WINDIR=SystemRoot%
	 *	  USERNAME=(from WTS)
	 *	  USERDOMAIN=
	 *	  PCHEVENTNAME=EventName
	 *	  PCHSESSIONENUM=UserInfo->dwIndex
	 *	  PCHCONNECTPARMS=ConnectParms
	 */
	TRIVIAL_MSG((L"Launch %ws", (LPWSTR)strExe.c_str()));

	/* Step on the ENVIRONMENT */
	WCHAR	lpNameBfr[256];

	wnsprintfW(lpNameBfr, ARRAYSIZE(lpNameBfr), L"Global\\%ws%lx_%02d", EVENT_PREFIX, lSessionTag, UserInfo->dwIndex);

	UserInfo->hEvent = CreateEvent(sa, TRUE, FALSE, lpNameBfr);
	if (!UserInfo->hEvent || ERROR_ALREADY_EXISTS == GetLastError())
	{
		/*
		 * If we failed to create this event, it is most likely because one is already
		 * in name-space, perhaps an event, or else a mutex... In any case, we will
		 * try again, with a more random name. If that fails, then we must bail out.
		 */
		long lRand;

		if (UserInfo->hEvent)
			CloseHandle(UserInfo->hEvent);

		RtlGenRandom(&lRand, sizeof(lRand));
		wnsprintfW(lpNameBfr, ARRAYSIZE(lpNameBfr), L"Global\\%lx%lx%lx_%02d", 
			lRand, lSessionTag, UserInfo->dwIndex);
		UserInfo->hEvent = CreateEvent(sa, TRUE, FALSE, lpNameBfr);

		if (!UserInfo->hEvent || ERROR_ALREADY_EXISTS == GetLastError())
		{
			if (UserInfo->hEvent)
				CloseHandle(UserInfo->hEvent);
			UserInfo->hEvent = 0;
			HEINOUS_E_MSG((L"The named event \"%s\" was in use- potential security issue, so Remote Assistance will be denied.", lpNameBfr));
			goto done;
		}
	}

	SetEnvironmentVariable(szEnvEvent, lpNameBfr);

	wsprintf(buf1, L"%d", UserInfo->dwIndex);
	SetEnvironmentVariable(szEnvIndex, buf1);
	SetEnvironmentVariable(szEnvParms, ConnectParms);
	SetEnvironmentVariable(szEnvUser, pUsername );	 
	SetEnvironmentVariable(szEnvDomain, pDomainname );
	SetEnvironmentVariable(szEnvExpertBlob, expertHelpBlob);
	SetEnvironmentVariable(szEnvUserBlob, userHelpBlob);

	if (!CreateEnvironmentBlock(&pEnvBlock, UserInfo->hUserToken, TRUE))
	{
		IMPORTANT_MSG((L"CreateEnvironmentBlock failed in resolver:launchex, err=0x%x", GetLastError()));
		goto done;
	}

	// initialize our structs
	ZeroMemory(&p_i, sizeof(p_i));
	ZeroMemory(&StartUp, sizeof(StartUp));
	StartUp.cb = sizeof(StartUp);
	StartUp.dwFlags = STARTF_USESHOWWINDOW;
	StartUp.wShowWindow = SW_SHOWNORMAL;

	result = CreateProcessAsUserW(UserInfo->hUserToken, 
			NULL, (LPWSTR)strExe.c_str(),
			NULL, NULL, FALSE, 
			NORMAL_PRIORITY_CLASS + CREATE_UNICODE_ENVIRONMENT ,
			pEnvBlock,				// Environment block  (must use the CREATE_UNICODE_ENVIRONMENT flag)
			NULL, &StartUp, &p_i);

	if (result)
	{
		// keep a leak from happening, as we never need the hThread...
		CloseHandle(p_i.hThread);
		UserInfo->hProcess = p_i.hProcess;
		UserInfo->hThread = 0;
		UserInfo->dwProcessId = p_i.dwProcessId;
		UserInfo->dwThreadId = p_i.dwThreadId;

		retval = p_i.hProcess;

		TRIVIAL_MSG((L"CreateProcessAsUserW started up [%ws]", (LPWSTR)strExe.c_str()));
	}
	else
	{
		IMPORTANT_MSG((L"CreateProcessAsUserW failed, err=0x%x command line=[%ws]", GetLastError(), (LPWSTR)strExe.c_str()));
		result=0;
	}
done:
	if (!result)
	{
		UserInfo->hProcess = 0;
		UserInfo->hThread = 0;
		UserInfo->dwProcessId = 0;
		UserInfo->dwThreadId = 0;
	}

	// restore any memory we borrowed
#ifndef _PERF_OPTIMIZATIONS
	if (pCmdLine) LocalFree(pCmdLine);
#endif

	if (pEnvBlock) DestroyEnvironmentBlock(pEnvBlock);

	return retval;
}

/*************************************************************
*
*   CreateSids([in] BSTR pTextSID)
*	Create 3 Security IDs
*
*   NOTES:
*	Caller must free memory allocated to SIDs on success.
*
*   RETURN CODES: TRUE if successfull, FALSE if not.
*
*************************************************************/

BOOL
CreateSids(
    PSID                    *BuiltInAdministrators,
    PSID                    *PowerUsers,
    PSID                    *AuthenticatedUsers
)
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  BuiltInAdministrators)) 
	{
        // error
		HEINOUS_E_MSG((L"Could not allocate security credentials for admins."));
    } 
	else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 2 sub-authorities
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         PowerUsers)) 
	{
        // error

		HEINOUS_E_MSG((L"Could not allocate security credentials for power users."));
        FreeSid(BuiltInAdministrators);
        BuiltInAdministrators = NULL;

    } 
	else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         AuthenticatedUsers)) 
	{
        // error
		HEINOUS_E_MSG((L"Could not allocate security credentials for users."));

        FreeSid(BuiltInAdministrators);
        BuiltInAdministrators = NULL;

        FreeSid(PowerUsers);
        PowerUsers = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


/*************************************************************
*
*   CreateSd(void)
*	Creates a SECURITY_DESCRIPTOR with specific DACLs.
*
*   NOTES:
*	Caller must free the returned buffer if not NULL.
*
*   RETURN CODES:
*	NULL			Failed for some reason
*	PSECURITY_DESCRIPTOR	Pointer to a SECURITY_DESCRIPTOR. 
*				Must be freed with "LocalFree"
*
*************************************************************/
PSECURITY_DESCRIPTOR CreateSd(PSID pUserSID)
{
	PSID                    AuthenticatedUsers;
	PSID                    BuiltInAdministrators;
	PSID                    PowerUsers;
	PSECURITY_DESCRIPTOR    Sd = NULL;
	ULONG                   AclSize;
	ACL                     *Acl;


	if (!CreateSids(&BuiltInAdministrators,
                    &PowerUsers,
                    &AuthenticatedUsers)) 
	{
		// error
		IMPORTANT_MSG((L"CreateSids failed"));

		return NULL;
	} 

	// 
	// Calculate the size of and allocate a buffer for the DACL, we need
	// this value independently of the total alloc size for ACL init.
	//

	//
	// "- sizeof (ULONG)" represents the SidStart field of the
	// ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
	// SID, this field is counted twice.
	//

	AclSize = sizeof (ACL) +
		(4 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
		GetLengthSid(AuthenticatedUsers) +
		GetLengthSid(BuiltInAdministrators) +
		GetLengthSid(PowerUsers) +
		GetLengthSid(pUserSID);

	Sd = LocalAlloc(LMEM_FIXED + LMEM_ZEROINIT, 
		SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

	if (!Sd) 
	{
		IMPORTANT_MSG((L"Cound not allocate 0x%x bytes for Security Descriptor", SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize));
		goto error;
	} 

	Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

	if (!InitializeAcl(Acl,
			AclSize,
			ACL_REVISION)) 
	{
		// error
		IMPORTANT_MSG((L"Cound not initialize ACL err=0x%x", GetLastError()));
		goto error;
	}
	TRIVIAL_MSG((L"initialized Successfully"));
	

	if (!AddAccessAllowedAce(Acl,
				ACL_REVISION,
				STANDARD_RIGHTS_ALL | GENERIC_WRITE,
				pUserSID)) 
	{
		// Failed to build the ACE granted to OWNER
		// (STANDARD_RIGHTS_ALL) access.
		IMPORTANT_MSG((L"Cound not add owner rights to ACL err=0x%x", GetLastError()));
		goto error;
	} 


	if (!AddAccessAllowedAce(Acl,
				ACL_REVISION,
				GENERIC_READ,
				AuthenticatedUsers)) 
	{
		// Failed to build the ACE granting "Authenticated users"
		// (SYNCHRONIZE | GENERIC_READ) access.
		IMPORTANT_MSG((L"Cound not add user rights to ACL err=0x%x", GetLastError()));
		goto error;
	} 

	if (!AddAccessAllowedAce(Acl,
				ACL_REVISION,
				GENERIC_READ | GENERIC_WRITE,
				PowerUsers)) 
	{
		// Failed to build the ACE granting "Power users"
		// (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE) access.
		IMPORTANT_MSG((L"Cound not add power user rights to ACL err=0x%x", GetLastError()));
		goto error;
	}

	if (!AddAccessAllowedAce(Acl,
				ACL_REVISION,
				STANDARD_RIGHTS_ALL,
				BuiltInAdministrators)) 
	{
		// Failed to build the ACE granting "Built-in Administrators"
		// STANDARD_RIGHTS_ALL access.
		IMPORTANT_MSG((L"Cound not add admin rights to ACL err=0x%x", GetLastError()));
		goto error;
	}

	
	if (!InitializeSecurityDescriptor(Sd,SECURITY_DESCRIPTOR_REVISION)) 
	{
		// error
		IMPORTANT_MSG((L"Cound not initialize SD err=0x%x", GetLastError()));
		goto error;
	}

	if (!SetSecurityDescriptorDacl(Sd,
					TRUE,
					Acl,
					FALSE)) 
	{
		// error
		IMPORTANT_MSG((L"SetSecurityDescriptorDacl failed err=0x%x", GetLastError()));
		goto error;
	} 

	FreeSid(AuthenticatedUsers);
	FreeSid(BuiltInAdministrators);
	FreeSid(PowerUsers);

//	TRIVIAL_MSG((L"CreateSd succeeded."));

	return Sd;

error:
	/* A jump of last resort */
	if (Sd)
		LocalFree(Sd);

		// error
	if (AuthenticatedUsers)
                FreeSid(AuthenticatedUsers);
	if (BuiltInAdministrators)
                FreeSid(BuiltInAdministrators);
	if (PowerUsers)
                FreeSid(PowerUsers);
	return NULL;
}

/*************************************************************
*
*   GetUserSessions(PSID, PWTS_USER_SESSION_INFOW , *DWORD)
*	Returns a table of all the active WTS Sessions for this
*	user, on this server.
*
*   RETURN CODES:
*
*   NOTES:
*	Should log NT Events for failures
*
*************************************************************/
DWORD GetUserSessions(PSID pUserSID, PWTS_USER_SESSION_INFO *pUserTbl, DWORD *pEntryCnt, WCHAR *pUsername, WCHAR *pDomainname)
{
	int			i,ii=0;
	DWORD 		retval=0,
				dwSessions=0,
				dwValidSessions,
				dwOwnedSessions;
	PWTS_SESSION_INFO	pSessionInfo=NULL;
	DWORD			dwRetSize = 0;
	WINSTATIONINFORMATION WSInfo;

	/* param validation */
	if (!pUserSID || !pUserTbl || !pEntryCnt)
	{
		IMPORTANT_MSG((L"GetUserSessions parameter violation"));

		return 0; 
	}

	/* Start with WTSEnumerateSessions,
	 * narrow it down to only active sessions, 
	 * then filter further against the logonID
	 * then use WinStationQueryInformation to get the logged on users token
	 */
	if (!WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwSessions) ||
		!pSessionInfo || !dwSessions)
	{
		/* if we can't do this, then we must give up */
		IMPORTANT_MSG((L"GetUserSessions parameter violation"));
		return 0;
	}

	/* 
	 *   Narrow down to only active sessions -
	 *	a quick test
	 */
	for (i=0,dwValidSessions=0;i<(int)dwSessions;i++)
	{
		if (pSessionInfo[i].State == WTSActive)
			dwValidSessions++;
	}

	/* bail out early if none found */
	if (dwValidSessions == 0)
	{
		/* free the memory we asked for */
		WTSFreeMemory(pSessionInfo);

		INTERESTING_MSG((L"No active sessions found"));
		return 0;
	}

	INTERESTING_MSG((L"%d sessions found", dwValidSessions));

	/*
	 *  Now see who owns each session. Only one problem- session details kept
	 *  by WTS have no concept of SIDs- just a user name & domain. Oh well,
	 *  it is a safe assumption that the two are just as reliable forms of
	 *  identification. One little caveat- the names can be stored using
	 *	different case variants. Example: "TomFr" and "tomfr" are equivalent,
	 *	according to NT domain rules, so I have to use a case-insensitive
	 *	check here.
	 *
	 *  So, now that I know there is at least one possible WTS Session here,
	 *  I will compare these IDs to determine if we want to notify this particular
	 *  session.
	 */

	/* now look at all the active sessions and compare domain & user names */
	for (i=0,dwOwnedSessions=0;i<(int)dwSessions;i++)
	{
		if (pSessionInfo[i].State == WTSActive)
		{
			DWORD 			CurSessionId = pSessionInfo[i].SessionId;
		 
			memset( &WSInfo, 0, sizeof(WSInfo) );

			if (!WinStationQueryInformationW(
                 SERVERNAME_CURRENT,
                 CurSessionId,
                 WinStationInformation,
                 &WSInfo,
                 sizeof(WSInfo),
                 &dwRetSize
                 ))
			{
				IMPORTANT_MSG((L"WinStationQueryInformation failed err=0x%x", GetLastError()));

				break;
			}

			if (StrCmpI(WSInfo.Domain, pDomainname))
				continue;

			if (StrCmpI(WSInfo.UserName, pUsername))
				continue;

			/*
			 * If we got this far, then we know we want this session 
			 */
			dwOwnedSessions++;

			// mark this as a "session of interest"
			pSessionInfo[i].State = (WTS_CONNECTSTATE_CLASS)0x45;
		}
	}

	/* did we find any sessions? */
	if (dwOwnedSessions == 0)
	{
		TRIVIAL_MSG((L"No matching sessions found"));
		goto none_found;
	}

	/* Get some memory for our session tables */
	*pUserTbl = (PWTS_USER_SESSION_INFO)LocalAlloc(LMEM_FIXED, dwOwnedSessions * sizeof(WTS_USER_SESSION_INFO));

	if (!*pUserTbl)
	{
		HEINOUS_E_MSG((L"Could not allocate memory for %d sessions, err=0x%x", dwOwnedSessions, GetLastError()));
		goto none_found;
	}

	*pEntryCnt = dwOwnedSessions;

	for (i=0,ii=0;i<(int)dwSessions; i++)
	{
		/* 
		 *  If this is one of our "sessions of interest", get the session ID 
		 *  and User Token.
		 */
		if (pSessionInfo[i].State == (WTS_CONNECTSTATE_CLASS)0x45)
		{
			WINSTATIONUSERTOKEN	WsUserToken;
			ULONG			ulRet;
			PWTS_USER_SESSION_INFO	lpi = &((*pUserTbl)[ii]);

			WsUserToken.ProcessId = LongToHandle(GetCurrentProcessId());
			WsUserToken.ThreadId = LongToHandle(GetCurrentThreadId());

			lpi->dwIndex = (DWORD)ii;
			lpi->dwSessionId = pSessionInfo[i].SessionId;

			if (!WinStationQueryInformationW(WTS_CURRENT_SERVER_HANDLE, pSessionInfo[i].SessionId, 
				WinStationUserToken, &WsUserToken, sizeof(WsUserToken), &ulRet))
			{
				goto none_found;
			}

			lpi->hUserToken = WsUserToken.UserToken;
			ii++;
		}
	}

	/* Yahoo! we finally built our table. Now we can leave after cleaning up */
	WTSFreeMemory(pSessionInfo);

	IMPORTANT_MSG((L"GetUserSessions exiting: %d sessions found", *pEntryCnt));

	return 1;

none_found:
	/* free the memory we asked for */
	if (pSessionInfo) WTSFreeMemory(pSessionInfo);

	// we found no entries
	*pEntryCnt =0;
	*pUserTbl = NULL;
	IMPORTANT_MSG((L"GetUserSessions exiting: no sessions found"));
	return 1;
}

LPTHREAD_START_ROUTINE getKillProc(void)
{
	LPTHREAD_START_ROUTINE lpKill = NULL;

	HMODULE hKernel = LoadLibrary(L"kernel32");
	if (hKernel)
	{
		lpKill = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel, "ExitProcess");
		FreeLibrary(hKernel);
	}

	return lpKill;
}

/*************************************************************
*
*   localKill(WTS_USER_SESSION_INFO *SessInfo, LPTHREAD_START_ROUTINE lpKill)
*		kills the process for us.
*
*************************************************************/
DWORD localKill(WTS_USER_SESSION_INFO *SessInfo, LPTHREAD_START_ROUTINE lpKill, LPSECURITY_ATTRIBUTES lpSA)
{
	TRIVIAL_MSG((L"Entered localKill(0x%x, 0x%x)", SessInfo, lpKill));

	if (lpKill)
	{
		HANDLE	hKillThrd= CreateRemoteThread(
			SessInfo->hProcess, 
			lpSA, 
			NULL,
			lpKill, 
			0, 
			0, 
			NULL);
		if (hKillThrd)
		{
			CloseHandle(hKillThrd);
			return 1;
		}
		IMPORTANT_MSG((L"CreateRemoteThread failed. Err: %08x", GetLastError()));
		// the fall-through is by design...
	}

	if(!TerminateProcess( SessInfo->hProcess, 0 ))
	{
		IMPORTANT_MSG((L"TerminateProcess failed. Err: %08x", GetLastError()));
	}

	return 0;
}

/*************************************************************
*
*   getUserName()
*		get the user's name & domain.
*
*************************************************************/
DWORD	getUserName(PSID pUserSID, WCHAR **pUsername, WCHAR **pDomainname)
{
	if (!pUsername || !pDomainname || !pUserSID)
		return 0;

	DWORD		dwUsername=0, dwDomainname=0;
	SID_NAME_USE 	eUse;

	TRIVIAL_MSG((L"Entered getUserName"));

	*pUsername=NULL, *pDomainname=NULL;

	/* get the size of the buffers we will need */
	if (!LookupAccountSid(NULL, pUserSID, NULL, &dwUsername, NULL, &dwDomainname, &eUse) &&
		(!dwUsername || !dwDomainname))
	{
		IMPORTANT_MSG((L"LookupAccountSid(nulls) failed err=0x%x", GetLastError()));
		return 0;
	}

	/* now get enough memory for our name & domain strings */
	*pUsername = (WCHAR *)LocalAlloc(LMEM_FIXED, (dwUsername+16) * sizeof(WCHAR));			
	*pDomainname = (WCHAR *)LocalAlloc(LMEM_FIXED, (dwDomainname+16) * sizeof(WCHAR));

	if (!*pUsername || !*pDomainname ||
		!LookupAccountSid(NULL, pUserSID, *pUsername, &dwUsername, *pDomainname, &dwDomainname, &eUse))
	{
		/* if we get here, it is very bad!! */
		DWORD error = GetLastError();
		if (!*pUsername || !*pDomainname)
			IMPORTANT_MSG((L"LocalAlloc failed err=0x%x", error));
		else
			IMPORTANT_MSG((L"LookupAccountSid(ptrs) failed err=0x%x", error));

		return 0;
	}

	TRIVIAL_MSG((L"Requested user=[%ws] dom=[%ws]", *pUsername, *pDomainname));
	return 1;
}

/*************************************************************
*
*	ListFind(PSPLASHLIST pSplash, PSID user)
*		returns TRUE if SID is found in our "splash table"
*
*************************************************************/
BOOL	ListFind(PSPLASHLIST pSplash, PSID user)
{
	PSPLASHLIST	lpSplash;

	if (!pSplash)
	{
		IMPORTANT_MSG((L"ListFind: no splash table memory"));
		return FALSE;
	}

	if (!user)
	{
		IMPORTANT_MSG((L"Fatal error: no SID pointer"));
		return FALSE;
	}

	lpSplash = pSplash;

	while (lpSplash)
	{
		if (lpSplash->refcount &&
			EqualSid(user, &lpSplash->Sid))
		{
			return TRUE;
		}
		lpSplash = (PSPLASHLIST) lpSplash->next;
	}

	return FALSE;
}

/*************************************************************
*
*	ListInsert(PSPLASHLIST pSplash, int iSplashCnt, PSID user)
*		inserts SID in our "splash table"
*
*	NOTES:
*		if already there, we increment the refcount for SID
*
*************************************************************/
BOOL	ListInsert(PSPLASHLIST pSplash, PSID user)
{
	PSPLASHLIST	lpSplash;

	if (!pSplash)
	{
		IMPORTANT_MSG((L"Fatal error: no splash table memory"));
		return FALSE;
	}

	if (!user)
	{
		IMPORTANT_MSG((L"Fatal error: no SID pointer"));
		return FALSE;
	}

	if (!IsValidSid(user))
	{
		IMPORTANT_MSG((L"Fatal error: bad SID"));
		return FALSE;
	}

	// first, look for one already in the list
	lpSplash = pSplash;

	while (lpSplash)
	{
		if (lpSplash->refcount && EqualSid(user, &lpSplash->Sid))
		{
			TRIVIAL_MSG((L"Recycling SID in ListInsert"));
			lpSplash->refcount++;
			return TRUE;
		}
		lpSplash = (PSPLASHLIST) lpSplash->next;
	}


	// since we did not find one, let's add a new one
	lpSplash = pSplash;

	while (lpSplash->next)
		lpSplash = (PSPLASHLIST) lpSplash->next;

	int iSidSz = GetLengthSid(user);

	lpSplash->next = LocalAlloc(LMEM_FIXED, sizeof(SPLASHLIST) + iSidSz - sizeof(SID));

	if (lpSplash->next)
	{
		lpSplash = (PSPLASHLIST) lpSplash->next;

		CopySid(iSidSz, &lpSplash->Sid, user);
		lpSplash->refcount=1;
		lpSplash->next = NULL;
		return TRUE;
	}
	else
	{
		IMPORTANT_MSG((L"Fatal error: no memory available to extend splash tables"));
	}


	return FALSE;
}

/*************************************************************
*
*	ListDelete(PSPLASHLIST pSplash, PSID user)
*		deletes SID from our "splash table"
*
*	NOTES:
*		if there, we decrement the refcount for SID
*		when refcount hits zero, SID is removed
*
*************************************************************/
BOOL	ListDelete(PSPLASHLIST pSplash, PSID user)
{
	PSPLASHLIST	lpSplash, lpLast;

	if (!pSplash)
	{
		IMPORTANT_MSG((L"Fatal error: no splash table memory"));
		return FALSE;
	}

	if (!user)
	{
		IMPORTANT_MSG((L"Fatal error: no SID pointer"));
		return FALSE;
	}

	lpSplash = lpLast = pSplash;

	while (lpSplash)
	{
		if (lpSplash->refcount &&
			EqualSid(user, &lpSplash->Sid))
		{
			lpSplash->refcount--;
			TRIVIAL_MSG((L"found SID in ListDelete"));

			if (!lpSplash->refcount)
			{
				// blow away the SID data
				TRIVIAL_MSG((L"deleting SID entry"));
				lpLast->next = lpSplash->next;
				LocalFree(lpSplash);
			}
			return TRUE;
		}
		lpLast = lpSplash;
		lpSplash = (PSPLASHLIST) lpSplash->next;
	}

	IMPORTANT_MSG((L"Fatal error: attempted to delete non-existant SID from splash table memory"));
	return FALSE;
}


/*************************************************************
*
*   DbgSpew(DbgClass, char *, ...)
*		Sends debug information.
*
*************************************************************/
void DbgSpew(int DbgClass, BSTR lpFormat, va_list ap)
{
	WCHAR		szMessage[2400];


	vswprintf(szMessage, lpFormat, ap);
	wcscat(szMessage, L"\r\n");

	if ((DbgClass & 0x0F) >= (gDbgFlag & 0x0F))
	{
		// should this be sent to the debugger?
		if (DbgClass & DBG_MSG_DEST_DBG)
			OutputDebugStringW(szMessage);

		// should this go to our log file?
		if (iDbgFileHandle)
			_write(iDbgFileHandle, szMessage, (2*lstrlen(szMessage)));
	}

	// should this msg go to the Event Logs?
	if (DbgClass & DBG_MSG_DEST_EVENT)
	{
		WORD	wType;
		DWORD	dwEvent;

		if (DbgClass & DBG_MSG_CLASS_SECURE)
		{
			if (DbgClass & DBG_MSG_CLASS_ERROR)
			{
				wType = EVENTLOG_AUDIT_FAILURE;
				dwEvent = SESSRSLR_E_SECURE;
			}
			else
			{
				wType = EVENTLOG_AUDIT_SUCCESS;
				dwEvent = SESSRSLR_I_SECURE;
			}
		}
		else
		{
			if (DbgClass & DBG_MSG_CLASS_ERROR)
			{
				wType = EVENTLOG_ERROR_TYPE;
				dwEvent = SESSRSLR_E_GENERAL;
			}
			else
			{
				wType = EVENTLOG_INFORMATION_TYPE;
				dwEvent = SESSRSLR_I_GENERAL;
			}
		}

		/* write out an NT Event */
		HANDLE	hEvent = RegisterEventSource(NULL, MODULE_NAME);
		LPCWSTR	ArgsArray[1]={szMessage};

		if (hEvent)
		{
			ReportEvent(hEvent, wType, 
				0,
				dwEvent,
				NULL,
				1,
				0,
				ArgsArray,
				NULL);

			DeregisterEventSource(hEvent);
		}
	}
}

void TrivialSpew(BSTR lpFormat, ...)
{
	va_list	vd;
	va_start(vd, lpFormat);
	DbgSpew(DBG_MSG_TRIVIAL+DBG_MSG_DEST_DBG, lpFormat, vd);
	va_end(vd);
}

void InterestingSpew(BSTR lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_INTERESTING+DBG_MSG_DEST_DBG, lpFormat, ap);
	va_end(ap);
}

void ImportantSpew(BSTR lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_IMPORTANT+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE, lpFormat, ap);
	va_end(ap);
}

void HeinousESpew(BSTR lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_HEINOUS+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE+DBG_MSG_DEST_EVENT+DBG_MSG_CLASS_ERROR, lpFormat, ap);
	va_end(ap);
}

void HeinousISpew(BSTR lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_HEINOUS+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE+DBG_MSG_DEST_EVENT, lpFormat, ap);
	va_end(ap);
}

// Blob format: propertylength;propertyName=value.
BOOL GetPropertyValueFromBlob(BSTR bstrHelpBlob, WCHAR * pName, WCHAR** ppValue)
{
    WCHAR *p1, *p2, *pEnd;
    BOOL bRet = FALSE;
    LONG lTotal =0;
    size_t lProp = 0;
    size_t iNameLen;

    if (!bstrHelpBlob || *bstrHelpBlob==L'\0' || !pName || *pName ==L'\0'|| !ppValue)
        return FALSE;

    iNameLen = wcslen(pName);

    pEnd = bstrHelpBlob + wcslen(bstrHelpBlob);
    p1 = p2 = bstrHelpBlob;

    while (1)
    {
        // get property length
        while (*p2 != L';' && *p2 != L'\0' && iswdigit(*p2) ) p2++;
        if (*p2 != L';')
            goto done;

        *p2 = L'\0'; // set it to get length
        lProp = _wtol(p1);
        *p2 = L';'; // revert it back.
    
        // get property string
        p1 = ++p2;
    
        while (*p2 != L'=' && *p2 != L'\0' && p2 < p1+lProp) p2++;
        if (*p2 != L'=')
            goto done;

        if (wcsncmp(p1, pName, iNameLen) == 0)
        {
            if (lProp == iNameLen+1) // A=B= case (no value)
                goto done;

            *ppValue = (WCHAR*)LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * (lProp-iNameLen));
            if (*ppValue == NULL)
                goto done;

            wcsncpy(*ppValue, p2+1, lProp-iNameLen-1);
            (*ppValue)[lProp-iNameLen-1]=L'\0';
            bRet = TRUE;
            break;
        }

        // check next property
        p2 = p1 = p1 + lProp;
        if (p2 > pEnd)
            break;
    }

done:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\unattend\unittest\pchunattendtst.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <stdio.h>

#include "..\Unattend.h"
#define ArrayCount 17

BOOL WritePCHealthIni()
{
	struct IniEntries
	{
	TCHAR strKey[MAX_PATH]; //Name of the key in the inifile and registry
	DWORD dwType;			//Type of the key to be used when writing into the registry
	BOOL bIterate;			//Only one key exists or iterate for more keys with the same name
	};

	IniEntries ArrIniEntries[ArrayCount] =
	{
		{_T("ER_Display_UI"),REG_DWORD,FALSE},
		{_T("ER_Enable_Applications"),REG_SZ,FALSE},
		{_T("ER_Enable_Kernel_Errors"),REG_DWORD,FALSE},
		{_T("ER_Enable_Reporting"),REG_DWORD,FALSE},
		{_T("ER_Enable_Windows_Components"),REG_DWORD,FALSE},
		{_T("ER_Include_MSApps"),REG_DWORD,FALSE},
		{_T("ER_Exclude_EXE"),REG_SZ,TRUE},
		{_T("ER_Include_EXE"),REG_SZ,TRUE},
		{_T("ER_Report_Path"),REG_SZ,FALSE},
		{_T("ER_No_External_URLs"),REG_DWORD,FALSE},
		{_T("ER_No_File_Collection"),REG_DWORD,FALSE},
		{_T("ER_No_Data_Collection"),REG_DWORD,FALSE},
		{_T("RA_AllowToGetHelp"),REG_DWORD,FALSE},
		{_T("RA_AllowUnSolicited"),REG_DWORD,FALSE},
		{_T("RA_AllowFullControl"),REG_DWORD,FALSE},
		{_T("RA_AllowRemoteAssistance"),REG_DWORD,FALSE},
		{_T("RA_MaxTicketExpiry"),REG_DWORD,FALSE},
	};

	//Section name in the registry.
	TCHAR strSection[] = _T("PCHealth");
	//Ini File Path
	TCHAR strFilePath[MAX_PATH] = _T("C:\\PCHealth.ini");

	int num = 0;
	TCHAR strNum[MAX_PATH];
	BOOL retval = TRUE;

	for (int nIndex = 0; nIndex < ArrayCount; nIndex++)
	{
		if (ArrIniEntries[nIndex].bIterate == FALSE)
		{
			if (ArrIniEntries[nIndex].dwType == REG_DWORD)
			{
				_tprintf(_T("Enter value for %s :-"),ArrIniEntries[nIndex].strKey);
				_tscanf(_T("%d"),&num);
				wsprintf(strNum,L"%d",num);
				retval = WritePrivateProfileString(strSection,ArrIniEntries[nIndex].strKey,strNum,strFilePath);
			}
			else if (ArrIniEntries[nIndex].dwType == REG_SZ)
			{
				_tprintf(_T("Enter value for %s :- "),ArrIniEntries[nIndex].strKey);
				_tscanf(_T("%s"),strNum);
				retval = WritePrivateProfileString(strSection,ArrIniEntries[nIndex].strKey,strNum,strFilePath);
			}
		}
		else
		{
			if(ArrIniEntries[nIndex].dwType == REG_SZ)
			{
				char input;
				int nCount = 0;
				int nFileIndex = 0;
				do
				{
					nCount++;
					TCHAR strFileTagName[MAX_PATH];
					TCHAR strI[10];
					lstrcpy(strFileTagName,ArrIniEntries[nIndex].strKey);
					//itoa(nCount,strI,10);
					wsprintf(strI,_T("%d"),nCount);
					lstrcat(strFileTagName,strI);

					_tprintf(_T("Enter File path for %s :-"),strFileTagName);
					_tscanf(_T("%s"),strNum);
					fflush(stdin);
					retval = WritePrivateProfileString(strSection,strFileTagName,strNum,strFilePath);
		
					_tprintf(_T("Do you want to continue? y/n"));
					_tscanf(_T("%c"),&input);
				}while (input != 'n');
			}
		}

	}
	return TRUE;
}

int __cdecl wmain()
{
	WritePCHealthIni();
	PCHealthUnAttendedSetup();
	//UnAttendedPCHealthSetup(PCHealthRegEntries,NO_REGENTRIES);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\unattend\unattend.h ===
#ifndef UNATTEND_H

#define UNATTEND_H

#include <windows.h>
#include <wchar.h>
#include <setupbat.h>

BOOL PCHealthUnAttendedSetup();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\safsessionresolver.cpp ===
// SAFSessionResolver.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for SAFSessionResolver.idl by adding the following 
//      files to the Outputs.
//          SAFSessionResolver_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f SAFSessionResolverps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SAFSessionResolver.h"
#include "dlldatax.h"

#include "SAFSessionResolver_i.c"
#include "SessionResolver.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SessionResolver, CSessionResolver)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SAFSESSIONRESOLVERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\sessres\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E22C3F28_C05C_46E9_8421_D48A199B04AF__INCLUDED_)
#define AFX_STDAFX_H__E22C3F28_C05C_46E9_8421_D48A199B04AF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define ATL_TRACE_LEVEL 4

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "SessionResolverMsgs.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E22C3F28_C05C_46E9_8421_D48A199B04AF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\rc\unattend\unattend.cpp ===
/* 
Copyright (c) 2000 Microsoft Corporation

Module Name:
    UnAttend.cpp

Abstract:
    Reads entries from the ini file and adds them to the registry.We assume that the 
	ini file key name and registry key name are the same. 

Revision History:
    created     a-josem      12/11/00
	revised		a-josem		 12/12/00  Changed 	TCHAR to WCHAR, moved the global variables to 
									   local scope.	
    
*/
#include "UnAttend.h"

/*
 This generic structure has the Key Name, datatype of the key and iterate says if 
 the Key Name is to be appended with 1,2,3.. or used directly.
 */
struct RegEntries
{
WCHAR strIniKey[MAX_PATH];//Name of the key in the Ini file	
WCHAR strKey[MAX_PATH]; //Name of the key in the registry
DWORD dwType;			//Type of the key to be used when writing into the registry
BOOL bIterate;			//TRUE or FALSE for iterating 1,2,3,....
};

#define ARRAYSIZE(a) (sizeof(a)/sizeof(*a))

//Section name in the registry.
static const WCHAR strSection[] = L"PCHealth";

static const WCHAR strErrorReportingSubKey[] = L"SOFTWARE\\Microsoft\\PCHealth\\ErrorReporting\\";
static const RegEntries ErrorReportingRegEntries[] = 
{
	{L"ER_Display_UI",L"ShowUI",REG_DWORD,FALSE},
	{L"ER_Enable_Kernel_Errors",L"IncludeKernelFaults",REG_DWORD,FALSE},
	{L"ER_Enable_Reporting",L"DoReport",REG_DWORD,FALSE},
	{L"ER_Enable_Windows_Components",L"IncludeWindowsApps",REG_DWORD,FALSE},
	{L"ER_Include_MSApps",L"IncludeMicrosoftApps",REG_DWORD,FALSE},
	{L"ER_ Force_Queue_Mode",L"ForceQueueMode",REG_DWORD,FALSE},
	{L"ER_ Include_Shutdowns_Errs",L"IncludeShutdownsErrs",REG_DWORD,FALSE},
};	

static const WCHAR strExclusionSubKey[] = L"SOFTWARE\\Microsoft\\PCHealth\\ErrorReporting\\ExclusionList\\";
static const RegEntries ExclusionRegEntries[] = 
{
	{L"ER_Exclude_EXE",L"",REG_DWORD,TRUE}
};

static const WCHAR strInclusionSubKey[] = L"SOFTWARE\\Microsoft\\PCHealth\\ErrorReporting\\InclusionList\\";
static const RegEntries InclusionRegEntries[] = 
{
	{L"ER_Include_EXE",L"",REG_DWORD,TRUE}
};

static const WCHAR strDWSubKey[] = L"SOFTWARE\\Microsoft\\PCHealth\\ErrorReporting\\DW\\";
static const RegEntries DWRegEntries[] = 
{
	{L"ER_Report_Path",L"DWFileTreeRoot",REG_SZ,FALSE},
	{L"ER_No_External_URLs",L"DWNoExternalURL",REG_DWORD,FALSE},
	{L"ER_No_File_Collection",L"DWNoFileCollection",REG_DWORD,FALSE},
	{L"ER_No_Data_Collection",L"DWNoSecondLevelCollection",REG_DWORD,FALSE},
};

static const WCHAR strTerminalServerSubKey[] = L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\";
static const RegEntries TerminalServerRegEntries[] = 
{
	{L"RA_AllowToGetHelp",L"fAllowToGetHelp",REG_DWORD,FALSE},
	{L"RA_AllowUnSolicited",L"fAllowUnsolicited",REG_DWORD,FALSE},
	{L"RA_AllowFullControl",L"fAllowFullControl",REG_DWORD,FALSE},
	{L"RA_AllowRemoteAssistance",L"fAllowRemoteAssistance",REG_DWORD,FALSE},
	{L"RA_MaxTicketExpiry",L"MaxTicketExpiry",REG_DWORD,FALSE},
};

/*++
Routine Description:
	Reads ini file and adds those values in the registry

Arguments:
	lpstrSubKey    - SubKey under which the entries are to be made.
	arrRegEntries  - Array of RegEntries structure 
	nCount		   - Count of elements in the array.

Return Value:
	TRUE or FALSE depending on the Registry key opening.
 --*/
static BOOL UnAttendedSetup(LPCWSTR lpstrSubKey,const RegEntries *arrRegEntries,int nCount)
{
	//Ini File Path Temprorary path will be overwritten.
	WCHAR strFilePath[MAX_PATH];// = L"C:\\PCHealth.ini"; 

	BOOL fRetVal = TRUE;

	HKEY hKey = NULL;

	//The Key already exists just open the key.
	// BUGBUG: Change this to Create
	// Did the changes
	DWORD dwDisposition = 0;
	if (ERROR_SUCCESS != ::RegCreateKeyEx(HKEY_LOCAL_MACHINE,lpstrSubKey,0,NULL, 
		REG_OPTION_VOLATILE,KEY_WRITE,NULL,&hKey,&dwDisposition))
	{
		fRetVal = FALSE;
		goto doneUnAttend;
	}

	//Comment out the following three lines for testing purposes.
	GetSystemDirectory(strFilePath,MAX_PATH);
	lstrcat(strFilePath,TEXT("\\"));
	lstrcat(strFilePath,WINNT_GUI_FILE);
	///////

	WCHAR strRetVal[MAX_PATH];

	for (int nIndex = 0; nIndex < nCount; nIndex++)
	{
		if (arrRegEntries[nIndex].bIterate == FALSE)
		{
			if (GetPrivateProfileString(strSection,arrRegEntries[nIndex].strIniKey, 
				NULL,strRetVal,MAX_PATH,strFilePath) != 0)
			{
				if (arrRegEntries[nIndex].dwType == REG_DWORD)
				{
					DWORD nVal = 0;
					nVal = _wtoi(strRetVal);
					RegSetValueEx(hKey,arrRegEntries[nIndex].strKey,0,REG_DWORD, 
						(unsigned char *)&nVal,sizeof(DWORD));
				}
				else if (arrRegEntries[nIndex].dwType == REG_SZ)
				{
					RegSetValueEx(hKey,arrRegEntries[nIndex].strKey,0,REG_SZ, 
						(LPBYTE)strRetVal, (lstrlen(strRetVal) + 1) * sizeof(WCHAR) ); 
				}
			}
		}
		else
		{
			if(arrRegEntries[nIndex].dwType == REG_DWORD)
			{
				int nCount = 0;
				int nFileIndex = 0;
				do
				{
					WCHAR strFileTagName[MAX_PATH];
					WCHAR strI[10];
					lstrcpy(strFileTagName,arrRegEntries[nIndex].strIniKey);
					_itow(++nFileIndex,strI,10);
					lstrcat(strFileTagName,strI);

					nCount = GetPrivateProfileString(strSection,strFileTagName,0, 
						strRetVal,MAX_PATH,strFilePath);
					if (nCount)
					{
						DWORD dwVal = 1;
						RegSetValueEx(hKey,strRetVal,0,REG_DWORD, 
							(unsigned char*)&dwVal,sizeof(DWORD));
					}
				}while(nCount);
			}
		}
	}

doneUnAttend:
	if (hKey)
		RegCloseKey(hKey);
	return fRetVal;
}


/*++
Routine Description:
	Handles the special case of ER_Enable_Application 
Arguments:
	lpstrSubKey    - SubKey under which the entries are to be made.

Return Value:
	TRUE or FALSE depending on the Registry key opening.
 --*/
static BOOL SpecialCases(LPCWSTR lpstrSubKey)
{
	//Ini File Path temprorary path will be overwritten.
	WCHAR strFilePath[MAX_PATH];// = L"C:\\PCHealth.ini"; 

	BOOL fRetVal = TRUE;
	//Handling special cases 
	WCHAR strRetVal[MAX_PATH];
	HKEY hKey = NULL;

	DWORD dwDisposition = 0;
	if (ERROR_SUCCESS != ::RegCreateKeyEx(HKEY_LOCAL_MACHINE,lpstrSubKey,0,NULL, 
		REG_OPTION_VOLATILE,KEY_WRITE,NULL,&hKey,&dwDisposition))
	{
		fRetVal = FALSE;
		goto done;
	}

//Comment out the following three lines for testing purposes.
	GetSystemDirectory(strFilePath,MAX_PATH);
	lstrcat(strFilePath,TEXT("\\"));
	lstrcat(strFilePath,WINNT_GUI_FILE);
///////

	if (GetPrivateProfileString(strSection,TEXT("ER_Enable_Applications"),NULL, 
		strRetVal,MAX_PATH,strFilePath) != 0)
	{
		DWORD nVal = 0;
		if (!lstrcmpi(L"all",strRetVal))
		{
			nVal = 1;
			RegSetValueEx(hKey,L"AllOrNone",0,REG_DWORD, 
				(unsigned char *)&nVal,sizeof(DWORD));
		}
		else if (!lstrcmpi(L"Listed",strRetVal))
		{
			nVal = 0; 
			RegSetValueEx(hKey,L"AllOrNone",0,REG_DWORD, 
				(unsigned char *)&nVal,sizeof(DWORD));
		}
		else if (!lstrcmpi(L"None",strRetVal))
		{
			nVal = 2;
			RegSetValueEx(hKey,L"AllOrNone",0,REG_DWORD, 
				(unsigned char *)&nVal,sizeof(DWORD));
		}
	}

done:
	if (hKey)
		RegCloseKey(hKey);
	return fRetVal;
}

/*++
Routine Description:
	To be called from Register Server.

Arguments:
	None
Return Value:
	TRUE or FALSE depending on the Registry key opening.
--*/

BOOL PCHealthUnAttendedSetup()
{
	BOOL bRetVal1,bRetVal2,bRetVal3,bRetVal4,bRetVal5;

	SpecialCases(strErrorReportingSubKey);

	bRetVal1 = UnAttendedSetup(strErrorReportingSubKey, 
		ErrorReportingRegEntries,ARRAYSIZE(ErrorReportingRegEntries));
	bRetVal2 = UnAttendedSetup(strExclusionSubKey,ExclusionRegEntries, 
		ARRAYSIZE(ExclusionRegEntries));
	bRetVal3 = UnAttendedSetup(strInclusionSubKey,InclusionRegEntries, 
		ARRAYSIZE(InclusionRegEntries));
	bRetVal4 = UnAttendedSetup(strDWSubKey,DWRegEntries,ARRAYSIZE(DWRegEntries));
	bRetVal5 = UnAttendedSetup(strTerminalServerSubKey,TerminalServerRegEntries, 
		ARRAYSIZE(TerminalServerRegEntries));

	if ((bRetVal1== TRUE) && (bRetVal2 == TRUE) && (bRetVal3 == TRUE) && 
		(bRetVal4 == TRUE) && (bRetVal5 == TRUE))
		return TRUE;
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\accounts\unittest\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the unit test for the Security objects.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#include "StdAfx.h"

#include <initguid.h>

#include "HelpServiceTypeLib.h"
#include "HelpServiceTypeLib_i.c"

////////////////////////////////////////////////////////////////////////////////

static HRESULT CreateGroup()
{
    __HCP_FUNC_ENTRY( "CreateGroup" );

    HRESULT      hr;
	CPCHAccounts acc;

    __MPC_EXIT_IF_METHOD_FAILS(hr, acc.CreateGroup( L"TEST_GROUP1", L"This is a test group." ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

static HRESULT CreateUser()
{
    __HCP_FUNC_ENTRY( "CreateUser" );

    HRESULT      hr;
	CPCHAccounts acc;

    __MPC_EXIT_IF_METHOD_FAILS(hr, acc.CreateUser( L"TEST_USER1", L"This is a long password;;;;", L"Test User", L"This is a test user." ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

static HRESULT DestroyUser()
{
    __HCP_FUNC_ENTRY( "DestroyUser" );

    HRESULT      hr;
	CPCHAccounts acc;

    __MPC_EXIT_IF_METHOD_FAILS(hr, acc.DeleteUser( L"TEST_USER1" ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

static HRESULT DestroyGroup()
{
    __HCP_FUNC_ENTRY( "DestroyGroup" );

    HRESULT      hr;
	CPCHAccounts acc;

    __MPC_EXIT_IF_METHOD_FAILS(hr, acc.DeleteGroup( L"TEST_GROUP1" ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT RunTests( int argc, WCHAR **argv )
{
	__HCP_FUNC_ENTRY( "RunTests" );

	HRESULT hr;

	__MPC_EXIT_IF_METHOD_FAILS(hr, CreateGroup());
	__MPC_EXIT_IF_METHOD_FAILS(hr, CreateUser ());

	__MPC_EXIT_IF_METHOD_FAILS(hr, DestroyUser ());
	__MPC_EXIT_IF_METHOD_FAILS(hr, DestroyGroup());

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

int __cdecl wmain( int argc, WCHAR **argv, WCHAR **envp)
{
    HRESULT  hr;

    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
		hr = RunTests( argc, argv );

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\accounts\unittest\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <Debug.h>

//////

#include <ProjectConstants.h>

//////

#include <SecurityLib.h>

//////

#include <AccountsLib.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\accounts\secretsstore.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    SecretsStore.cpp

Abstract:
    File for Implementation of CPCHSecretsStore class, used to store secrets.

Revision History:
    Davide Massarenti created  03/27/2000

********************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

static const WCHAR c_SecretsStore[] = HC_HELPSVC_STORE_USERS;
static const WCHAR c_SecretsKey  [] = L"HelpService_PrivateData";

/////////////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CPCHSecretsStore::Inner_Pair)
    CFG_ATTRIBUTE( L"Key", wstring, m_strKey  ),
	CFG_VALUE    (         wstring, m_strValue),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CPCHSecretsStore::Inner_Pair)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CPCHSecretsStore::Inner_Pair,L"Pair")


DEFINE_CONFIG_METHODS__NOCHILD(CPCHSecretsStore::Inner_Pair)


bool CPCHSecretsStore::Inner_Pair::operator==( /*[in]*/ const MPC::wstring& strKey ) const
{
    MPC::NocaseCompare cmp;

    return cmp( m_strKey, strKey );
}

////////////////////

CFG_BEGIN_FIELDS_MAP(CPCHSecretsStore)
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CPCHSecretsStore)
    CFG_CHILD(CPCHSecretsStore::Inner_Pair)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CPCHSecretsStore,L"SecretsStore")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CPCHSecretsStore,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lst.insert( m_lst.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CPCHSecretsStore,xdn)
    hr = MPC::Config::SaveList( m_lst, xdn );
DEFINE_CONFIG_METHODS_END(CPCHSecretsStore)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CPCHSecretsStore::CPCHSecretsStore()
{
    m_fLoaded  = false;                                                     // bool         m_fLoaded;
    m_fDirty   = false;                                                     // bool         m_fDirty;
    m_strStore = c_SecretsStore; MPC::SubstituteEnvVariables( m_strStore ); // MPC::wstring m_strStore;
                                                                            // List         m_lst;
                                                                            // CComBSTR     m_bstrSecret;
}

////////////////////

CPCHSecretsStore* CPCHSecretsStore::s_GLOBAL( NULL );

HRESULT CPCHSecretsStore::InitializeSystem()
{
	if(s_GLOBAL == NULL)
	{
		s_GLOBAL = new CPCHSecretsStore;
	}

	return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void CPCHSecretsStore::FinalizeSystem()
{
	if(s_GLOBAL)
	{
		delete s_GLOBAL; s_GLOBAL = NULL;
	}
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecretsStore::GetSecret()
{
    __HCP_FUNC_ENTRY( "CPCHSecretsStore::GetSecret" );

    HRESULT               hr;
    NTSTATUS              ntRes;
    LSA_OBJECT_ATTRIBUTES objectAttributes; ::ZeroMemory( &objectAttributes, sizeof(objectAttributes) );
    LSA_UNICODE_STRING    lsaKeyString;
    LSA_UNICODE_STRING    lsaPrivateDataWrite;
    PLSA_UNICODE_STRING   lsaPrivateDataRead = NULL;
    HANDLE                policyHandle       = NULL;


    if(m_bstrSecret.Length() == 0)
    {
        GUID guidNEW;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateGuid( &guidNEW )); // Initialized to a new, random value.

        ntRes = ::LsaOpenPolicy( NULL, &objectAttributes, POLICY_CREATE_SECRET | POLICY_GET_PRIVATE_INFORMATION, &policyHandle );
        if(ntRes != STATUS_SUCCESS)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::LsaNtStatusToWinError( ntRes ));
        }

        CPCHSecurityDescriptorDirect::InitLsaString( lsaKeyString, c_SecretsKey );

        ntRes = ::LsaRetrievePrivateData( policyHandle, &lsaKeyString, &lsaPrivateDataRead );
        if(ntRes == STATUS_SUCCESS && lsaPrivateDataRead)
        {
            m_bstrSecret.Attach( ::SysAllocStringLen( lsaPrivateDataRead->Buffer, lsaPrivateDataRead->Length / sizeof(WCHAR) ) );
        }
        else if(ntRes == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            CComBSTR bstrSecret( guidNEW );

            CPCHSecurityDescriptorDirect::InitLsaString( lsaPrivateDataWrite, bstrSecret );

            ntRes = ::LsaStorePrivateData( policyHandle, &lsaKeyString, &lsaPrivateDataWrite );
            if(ntRes != STATUS_SUCCESS)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::LsaNtStatusToWinError( ntRes ));
            }

            m_bstrSecret = bstrSecret;
        }
        else
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::LsaNtStatusToWinError( ntRes ));
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(lsaPrivateDataRead) ::LsaFreeMemory( lsaPrivateDataRead );
    if(policyHandle      ) ::LsaClose     ( policyHandle       );

    __MPC_FUNC_EXIT(hr);
}

HRESULT CPCHSecretsStore::SyncFile()
{
    __HCP_FUNC_ENTRY( "CPCHSecretsStore::SyncFile" );

    HRESULT                       hr;
    CComPtr<MPC::EncryptedStream> streamEncrypted;
    CComPtr<MPC::FileStream>      streamPlain;


    if(m_fLoaded == false)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, GetSecret());

        //
        // Load the file, decrypting using the GUID stored in the secret data.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamEncrypted ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamPlain     ));

        if(SUCCEEDED(hr = streamPlain->InitForRead( m_strStore.c_str() )))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamEncrypted->Init( streamPlain, m_bstrSecret ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream( this, streamEncrypted ));

        }

        streamEncrypted.Release();
        streamPlain    .Release();

        m_fLoaded = true;
        m_fDirty  = false;
    }

    if(m_fDirty == true)
    {
        MPC::wstring     strStoreNew( m_strStore ); strStoreNew  += L".new";
        CComPtr<IStream> stream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, GetSecret());


        //
        // Save to a temp file, encrypting using the GUID stored in the secret data.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamEncrypted ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamPlain     ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamPlain->InitForWrite( strStoreNew.c_str() ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamEncrypted->Init( streamPlain, m_bstrSecret ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveStream( this, &stream ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( stream, streamEncrypted ));

        streamEncrypted.Release();
        streamPlain    .Release();

        //
        // Move the temp file to the real one.
        //
        ::SetFileAttributesW( m_strStore.c_str(), FILE_ATTRIBUTE_NORMAL );
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::MoveFileExW( strStoreNew.c_str(), m_strStore.c_str(), MOVEFILE_REPLACE_EXISTING ));

        m_fDirty = false;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecretsStore::Write( /*[in]*/ const MPC::wstring& strKey   ,
                                 /*[in]*/ const MPC::wstring& strValue )
{
    __HCP_FUNC_ENTRY( "CPCHSecretsStore::Write" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    Iter                         it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncFile());

    it = std::find( m_lst.begin(), m_lst.end(), strKey );
    if(it == m_lst.end())
    {
        it = m_lst.insert( m_lst.end() );

        it->m_strKey = strKey;
    }

    it->m_strValue = strValue; m_fDirty = true;

    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncFile());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSecretsStore::Read( /*[in ]*/ const MPC::wstring& strKey   ,
                                /*[out]*/       MPC::wstring& strValue )
{
    __HCP_FUNC_ENTRY( "CPCHSecretsStore::Read" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    IterConst                    it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncFile());

    it = std::find( m_lst.begin(), m_lst.end(), strKey );
    if(it == m_lst.end())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    strValue = it->m_strValue;
    hr      = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSecretsStore::Remove( /*[in]*/ const MPC::wstring& strKey )
{
    __HCP_FUNC_ENTRY( "CPCHSecretsStore::Remove" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    Iter                         it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncFile());

    it = std::find( m_lst.begin(), m_lst.end(), strKey );
    if(it != m_lst.end())
    {
        m_lst.erase( it ); m_fDirty = true;

        __MPC_EXIT_IF_METHOD_FAILS(hr, SyncFile());
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\accounts\accounts.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Accounts.cpp

Abstract:
    This file contains the implementation of the CPCHAccounts class,
    which is used to represent and manage user/group accounts.

Revision History:
    Davide Massarenti   (Dmassare)  03/26/2000
        created

******************************************************************************/

#include "StdAfx.h"

#include <Lmapibuf.h>
#include <Lmaccess.h>
#include <Lmerr.h>

////////////////////////////////////////////////////////////////////////////////

CPCHAccounts::CPCHAccounts()
{
}

CPCHAccounts::~CPCHAccounts()
{
    CleanUp();
}

void CPCHAccounts::CleanUp()
{
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHAccounts::CreateGroup( /*[in]*/ LPCWSTR szGroup   ,
                                   /*[in]*/ LPCWSTR szComment )
{
    __HCP_FUNC_ENTRY( "CPCHAccounts::CreateGroup" );

    HRESULT           hr;
    NET_API_STATUS    dwRes;
    LOCALGROUP_INFO_1 group; ::ZeroMemory( &group, sizeof(group) );

    group.lgrpi1_name    = (LPWSTR)szGroup;
    group.lgrpi1_comment = (LPWSTR)szComment;

    dwRes = ::NetLocalGroupAdd( NULL, 1, (LPBYTE)&group, NULL );
    if(dwRes != NERR_Success       &&
       dwRes != NERR_GroupExists   &&
       dwRes != ERROR_ALIAS_EXISTS  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHAccounts::CreateUser( /*[in]*/ LPCWSTR szUser     ,
                                  /*[in]*/ LPCWSTR szPassword ,
                                  /*[in]*/ LPCWSTR szFullName ,
                                  /*[in]*/ LPCWSTR szComment  )
{
    __HCP_FUNC_ENTRY( "CPCHAccounts::CreateUser" );

    HRESULT                   hr;
    NET_API_STATUS            dwRes;
	MPC::wstring              strGroupName;
    LOCALGROUP_MEMBERS_INFO_3 group; ::ZeroMemory( &group, sizeof(group) );
    USER_INFO_2               user;  ::ZeroMemory( &user , sizeof(user ) );
    LPUSER_INFO_10            userExisting = NULL;


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_GROUPNAME, strGroupName ));


    user.usri2_name            = (LPWSTR)szUser;
    user.usri2_password        = (LPWSTR)szPassword;
//  user.usri2_password_age
    user.usri2_priv            =         USER_PRIV_USER;
//  user.usri2_home_dir
    user.usri2_comment         = (LPWSTR)szComment;
    user.usri2_flags           =         UF_SCRIPT | UF_PASSWD_CANT_CHANGE | UF_DONT_EXPIRE_PASSWD;
//  user.usri2_script_path
//  user.usri2_auth_flags
    user.usri2_full_name       = (LPWSTR)szFullName;
//  user.usri2_usr_comment
//  user.usri2_parms
//  user.usri2_workstations
//  user.usri2_last_logon
//  user.usri2_last_logoff
    user.usri2_acct_expires    =         TIMEQ_FOREVER;
    user.usri2_max_storage     =         USER_MAXSTORAGE_UNLIMITED;
//  user.usri2_units_per_week
//  user.usri2_logon_hours
//  user.usri2_bad_pw_count
//  user.usri2_num_logons
//  user.usri2_logon_server
//  user.usri2_country_code
//  user.usri2_code_page

    dwRes = ::NetUserAdd( NULL, 2, (LPBYTE)&user, NULL );

    //
    // If the user already exists but its "FullName" field matches the requested one, it's the same user, so simply set the password.
    //
    if(dwRes == NERR_UserExists)
    {
        if(::NetUserGetInfo( NULL, szUser, 10, (LPBYTE*)&userExisting ) == NERR_Success)
        {
            if(!MPC::StrICmp( userExisting->usri10_full_name, szFullName ))
            {
                USER_INFO_1003 userChgPwd; ::ZeroMemory( &userChgPwd, sizeof(userChgPwd) );


                userChgPwd.usri1003_password = (LPWSTR)szPassword;


                dwRes = ::NetUserSetInfo( NULL, szUser, 1003, (LPBYTE)&userChgPwd, NULL );
            }
        }
    }

    if(dwRes != NERR_Success)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    ////////////////////////////////////////

    group.lgrmi3_domainandname = (LPWSTR)szUser;

    dwRes = ::NetLocalGroupAddMembers( NULL, strGroupName.c_str(), 3, (LPBYTE)&group, 1 );
    if(dwRes != NERR_Success          &&
       dwRes != ERROR_MEMBER_IN_ALIAS  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::AddPrivilege( szUser, SE_BATCH_LOGON_NAME            ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::AddPrivilege( szUser, SE_DENY_NETWORK_LOGON_NAME     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::AddPrivilege( szUser, SE_DENY_INTERACTIVE_LOGON_NAME ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(userExisting) ::NetApiBufferFree( userExisting );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHAccounts::DeleteGroup( /*[in]*/ LPCWSTR szGroup )
{
    __HCP_FUNC_ENTRY( "CPCHAccounts::DeleteGroup" );

    HRESULT        hr;
    NET_API_STATUS dwRes;


    dwRes = ::NetLocalGroupDel( NULL, szGroup );
    if(dwRes != NERR_Success )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHAccounts::DeleteUser( /*[in]*/ LPCWSTR szUser )
{
    __HCP_FUNC_ENTRY( "CPCHAccounts::DeleteUser" );

    HRESULT        hr;
    NET_API_STATUS dwRes;


    dwRes = ::NetUserDel( NULL, szUser );
    if(dwRes != NERR_Success )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHAccounts::ChangeUserStatus( /*[in]*/ LPCWSTR szUser  ,
										/*[in]*/ bool    fEnable )
{
    __HCP_FUNC_ENTRY( "CPCHAccounts::ChangeUserStatus" );

    HRESULT        	 hr;
    NET_API_STATUS 	 dwRes;
	LPUSER_INFO_2    pinfo2 = NULL;
	USER_INFO_1008   info1008;


    dwRes = ::NetUserGetInfo( NULL, szUser, 2, (LPBYTE*)&pinfo2 );
    if(dwRes != NERR_Success)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

	if(pinfo2)
	{
		info1008.usri1008_flags = pinfo2->usri2_flags;

		if(fEnable) info1008.usri1008_flags &= ~UF_ACCOUNTDISABLE;
		else        info1008.usri1008_flags |=  UF_ACCOUNTDISABLE;

		dwRes = ::NetUserSetInfo( NULL, szUser, 1008, (LPBYTE)&info1008, NULL );
		if(dwRes != NERR_Success)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(pinfo2) ::NetApiBufferFree( pinfo2 );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHAccounts::LogonUser( /*[in ]*/ LPCWSTR szUser     ,
                                 /*[in ]*/ LPCWSTR szPassword ,
                                 /*[out]*/ HANDLE& hToken     )
{
    __HCP_FUNC_ENTRY( "CPCHAccounts::LogonUser" );

    HRESULT  hr;
	GUID     guidPassword;
	WCHAR    rgPassword[128];
	LPOLESTR szGuid = NULL;


    //
    // If no password is supplied, generate a new password on the fly and change the old one with it.
    //
    if(szPassword == NULL)
    {
		USER_INFO_1003 userChgPwd; ::ZeroMemory( &userChgPwd, sizeof(userChgPwd) );
		DWORD          dwRes;


		//
		// This generates a random password.
		//
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateGuid( &guidPassword ));
		(void)::StringFromGUID2( guidPassword, rgPassword, MAXSTRLEN(rgPassword) );

		userChgPwd.usri1003_password = rgPassword;

		dwRes = ::NetUserSetInfo( NULL, szUser, 1003, (LPBYTE)&userChgPwd, NULL );
		if(dwRes != NERR_Success)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
		}

		
		szPassword = rgPassword;
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::LogonUserW( (LPWSTR)szUser, L".", (LPWSTR)szPassword, LOGON32_LOGON_BATCH, LOGON32_PROVIDER_DEFAULT, &hToken ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\accounts\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>

#include <Debug.h>

//////

#include <ProjectConstants.h>

//////

#include <SecurityLib.h>

//////

#include <AccountsLib.h>


#include <TrustedScripts.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\accounts\slave.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Slave.cpp

Abstract:
    File for Implementation of CPCHMasterSlave and CPCHUserProcess classes,
    used to establish a connection between the service and a slave process.

Revision History:
    Davide Massarenti created  03/28/2000

********************************************************************/

#include "stdafx.h"

#include <UserEnv.h>

/////////////////////////////////////////////////////////////////////////////

static const WCHAR c_HelpHost[] = HC_ROOT_HELPSVC_BINARIES L"\\HelpHost.exe";
static const DWORD c_Timeout = 100 * 1000;

/////////////////////////////////////////////////////////////////////////////

CPCHUserProcess::UserEntry::UserEntry()
{
                           // CComBSTR                  m_bstrUser
    m_dwSessionID = 0;     // DWORD                     m_dwSessionID;
                           //
                           // CComBSTR                  m_bstrVendorID;
                           // CComBSTR                  m_bstrPublicKey;
                           //
                           // GUID                      m_guid;
                           // CComPtr<IPCHSlaveProcess> m_spConnection;
    m_hToken      = NULL;  // HANDLE                    m_hToken;
    m_hProcess    = NULL;  // HANDLE                    m_hProcess;
    m_phEvent     = NULL;  // HANDLE*                   m_phEvent;

    ::ZeroMemory( &m_guid, sizeof(m_guid) );
}

CPCHUserProcess::UserEntry::~UserEntry()
{
    Cleanup();
}

void CPCHUserProcess::UserEntry::Cleanup()
{
    m_bstrUser     .Empty  ();
    m_dwSessionID = 0;

    m_bstrVendorID .Empty  ();
    m_bstrPublicKey.Empty  ();

    m_spConnection .Release();

    if(m_hProcess)
    {
        ::CloseHandle( m_hProcess ); m_hProcess = NULL;
    }

    if(m_hToken)
    {
        ::CloseHandle( m_hToken ); m_hToken = NULL;
    }
}

////////////////////

bool CPCHUserProcess::UserEntry::operator==( /*[in]*/ const UserEntry& ue ) const
{
    if(ue.m_bstrUser)
    {
        if(m_bstrUser == ue.m_bstrUser && m_dwSessionID == ue.m_dwSessionID) return true;
    }

    if(ue.m_bstrVendorID)
    {
        if(MPC::StrICmp( m_bstrVendorID, ue.m_bstrVendorID ) == 0) return true;
    }

    return false;
}

bool CPCHUserProcess::UserEntry::operator==( /*[in]*/ const GUID& guid ) const
{
    return ::IsEqualGUID( m_guid, guid ) ? true : false;
}

////////////////////

HRESULT CPCHUserProcess::UserEntry::Clone( /*[in]*/ const UserEntry& ue )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::UserEntry::Clone" );

    HRESULT hr;

    Cleanup();

    m_bstrUser      = ue.m_bstrUser;      // CComBSTR                  m_bstrUser;
    m_dwSessionID   = ue.m_dwSessionID;   // DWORD                     m_dwSessionID;
                                          //
    m_bstrVendorID  = ue.m_bstrVendorID;  // CComBSTR                  m_bstrVendorID;
    m_bstrPublicKey = ue.m_bstrPublicKey; // CComBSTR                  m_bstrPublicKey;
                                          //
                                          // GUID                      m_guid;          // Used for establishing the connection.
                                          // CComPtr<IPCHSlaveProcess> m_spConnection;  // Live object.
                                          // HANDLE                    m_hToken;        // User token.
                                          // HANDLE                    m_hProcess;      // Process handle.
                                          // HANDLE*                   m_phEvent;       // To notify activator.

    if(ue.m_hToken)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::DuplicateTokenEx( ue.m_hToken, 0, NULL, SecurityImpersonation, TokenPrimary, &m_hToken ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHUserProcess::UserEntry::Connect( /*[out]*/ HANDLE& hEvent )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::UserEntry::Connect" );

    HRESULT hr;


    //
    // Logon the user, if not already done.
    //
    if(m_hToken == NULL)
    {
        CPCHAccounts acc;
		LPCWSTR      szUser = SAFEBSTR( m_bstrUser );

////    // DEBUG
////    // DEBUG
////    // DEBUG
////    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::OpenProcessToken( ::GetCurrentProcess(), TOKEN_ALL_ACCESS, &m_hToken ));

		//
		// Only keep the account enabled for the time it takes to create its token.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, acc.ChangeUserStatus( szUser, /*fEnable*/true  ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, acc.LogonUser       ( szUser, NULL, m_hToken   ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, acc.ChangeUserStatus( szUser, /*fEnable*/false ));
    }

    if(m_hProcess     == NULL ||
       m_spConnection == NULL  )
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, SendActivation( hEvent ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHUserProcess::UserEntry::SendActivation( /*[out]*/ HANDLE& hEvent )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::UserEntry::SendActivation" );

    HRESULT             hr;
    DWORD               dwRes;
    PROCESS_INFORMATION piProcessInformation;
    STARTUPINFOW        siStartupInfo;
    VOID*               pEnvBlock = NULL;
    MPC::wstring        strExe( c_HelpHost ); MPC::SubstituteEnvVariables( strExe );
    WCHAR               rgCommandLine[1024];

    ::ZeroMemory( (PVOID)&piProcessInformation, sizeof( piProcessInformation ) );
    ::ZeroMemory( (PVOID)&siStartupInfo       , sizeof( siStartupInfo        ) ); siStartupInfo.cb = sizeof( siStartupInfo );


    //
    // Generate random ID.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateGuid( &m_guid ));


    //
    // Create event.
    //
    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL )));

    //
    // Create process as user.
    //
    {
        CComBSTR bstrGUID( m_guid );

        swprintf( rgCommandLine, L"\"%s\" -guid %s", strExe.c_str(), (BSTR)bstrGUID );
    }

	__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateEnvironmentBlock( &pEnvBlock, m_hToken, TRUE ));

////    // DEBUG
////    // DEBUG
////    // DEBUG
////    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateProcessW( NULL,
////                                                           rgCommandLine,
////                                                           NULL,
////                                                           NULL,
////                                                           FALSE,
////                                                           NORMAL_PRIORITY_CLASS,
////                                                           NULL,
////                                                           NULL,
////                                                           &siStartupInfo,
////                                                           &piProcessInformation ));

    // REAL
    // REAL
    // REAL
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateProcessAsUserW( m_hToken                                           ,
                                                                 NULL                                               ,
                                                                 rgCommandLine                                      ,
                                                                 NULL                                               ,
                                                                 NULL                                               ,
                                                                 FALSE                                              ,
                                                                 NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT ,
                                                                 pEnvBlock                                          ,
                                                                 NULL                                               ,
                                                                 &siStartupInfo                                     ,
                                                                 &piProcessInformation                              ));

    m_hProcess = piProcessInformation.hProcess; piProcessInformation.hProcess = NULL;
    hr         = S_OK;


    __HCP_FUNC_CLEANUP;

	if(pEnvBlock) ::DestroyEnvironmentBlock( pEnvBlock );

    if(piProcessInformation.hProcess) ::CloseHandle( piProcessInformation.hProcess );
    if(piProcessInformation.hThread ) ::CloseHandle( piProcessInformation.hThread  );

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHUserProcess::UserEntry::InitializeForVendorAccount( /*[in]*/ BSTR bstrUser      ,
                                                                /*[in]*/ BSTR bstrVendorID  ,
                                                                /*[in]*/ BSTR bstrPublicKey )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::UserEntry::InitializeForVendorAccount" );

    HRESULT hr;

    Cleanup();

    m_bstrUser      = bstrUser;

    m_bstrVendorID  = bstrVendorID;
    m_bstrPublicKey = bstrPublicKey;

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHUserProcess::UserEntry::InitializeForImpersonation( /*[in]*/ HANDLE hToken )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::UserEntry::InitializeForImpersonation" );

    HRESULT            hr;
    MPC::Impersonation imp;
    MPC::wstring       strUser;
    DWORD              dwSize;
    PSID               pUserSid = NULL;


    if(hToken == NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize( MAXIMUM_ALLOWED ));

        hToken = imp;
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::DuplicateTokenEx( hToken, 0, NULL, SecurityImpersonation, TokenPrimary, &m_hToken ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetTokenInformation( m_hToken, TokenSessionId, &m_dwSessionID, sizeof(m_dwSessionID), &dwSize ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::GetTokenSids         ( m_hToken, &pUserSid, NULL    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::ConvertSIDToPrincipal(            pUserSid, strUser )); m_bstrUser = strUser.c_str();


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::SecurityDescriptor::ReleaseMemory( pUserSid );

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CPCHUserProcess::CPCHUserProcess()
{
    // List m_lst;

    (void)MPC::_MPC_Module.RegisterCallback( this, (void (CPCHUserProcess::*)())Shutdown );
}

CPCHUserProcess::~CPCHUserProcess()
{
    MPC::CallDestructorForAll( m_lst );

    MPC::_MPC_Module.UnregisterCallback( this );
}

////////////////////

CPCHUserProcess* CPCHUserProcess::s_GLOBAL( NULL );

HRESULT CPCHUserProcess::InitializeSystem()
{
    if(s_GLOBAL == NULL)
    {
        s_GLOBAL = new CPCHUserProcess;
    }

    return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void CPCHUserProcess::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////

void CPCHUserProcess::Shutdown()
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::Shutdown" );

    MPC::SmartLock<_ThreadModel> lock( this );


    m_lst.clear();
}


CPCHUserProcess::UserEntry* CPCHUserProcess::Lookup( /*[in]*/ const UserEntry& ue, /*[in]*/ bool fRelease )
{
    UserEntry* ueReal;

    //
    // Locate vendor and connect to it.
    //
    for(Iter it = m_lst.begin(); it != m_lst.end(); )
    {
        ueReal = *it;
        if(ueReal && *ueReal == ue)
        {
            if(fRelease)
            {
                delete ueReal;

                m_lst.erase( it++ ); continue;
            }
            else
            {
                return ueReal;
            }
        }

        it++;
    }

    return NULL;
}

HRESULT CPCHUserProcess::Remove( /*[in]*/ const UserEntry& ue )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::Remove" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    (void)Lookup( ue, /*fRelease*/true );


    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHUserProcess::Connect( /*[in ]*/ const UserEntry&   ue           ,
                                  /*[out]*/ IPCHSlaveProcess* *spConnection )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::Connect" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    HANDLE                       hEvent = NULL;
    UserEntry*                   ueReal = NULL;

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHUserProcess::Connect" );

    //
    // Locate vendor and connect to it.
    //
    ueReal = Lookup( ue, /*fRelease*/false );
    if(ueReal == NULL)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, ueReal, new UserEntry);
        m_lst.push_back( ueReal );

        __MPC_EXIT_IF_METHOD_FAILS(hr, ueReal->Clone( ue ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, ueReal->Connect( hEvent ));


    //
    // If "Connect" returns an event handle, wait on it.
    //
    if(hEvent)
    {
        ueReal->m_phEvent = &hEvent; // For waiting response...

        lock = NULL;

        if(::WaitForSingleObject( hEvent, c_Timeout ) != WAIT_OBJECT_0)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        lock = this;

        //
        // Relocate vendor (we release the lock on the object, so "ueReal" is not valid anymore.
        //
        ueReal = Lookup( ue, /*fRelease*/false );
        if(ueReal == NULL)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, ueReal->m_spConnection.QueryInterface( spConnection ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hEvent) ::CloseHandle( hEvent );

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHUserProcess::Connect - done" );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHUserProcess::RegisterHost( /*[in]*/ BSTR              bstrID ,
                                       /*[in]*/ IPCHSlaveProcess* pObj   )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::RegisterHost" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    UserEntry*                   ueReal = NULL;
    GUID                         guid;


    //
    // Validate input.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CLSIDFromString( bstrID, &guid ));


    //
    // Locate vendor and connect to it.
    //
    for(Iter it = m_lst.begin(); it != m_lst.end(); it++)
    {
        ueReal = *it;
        if(ueReal && *ueReal == guid)
        {
            break;
        }
    }
    if(ueReal == NULL)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->Initialize( ueReal->m_bstrVendorID, ueReal->m_bstrPublicKey ));

    ueReal->m_spConnection = pObj;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(ueReal)
    {
        if(ueReal->m_phEvent)
        {
            //
            // Signal the event handle, to awake the activator.
            //
            ::SetEvent( *(ueReal->m_phEvent) );

            ueReal->m_phEvent = NULL;
        }
    }

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHUserProcess::SendResponse( /*[in]*/ DWORD    dwArgc   ,
                                       /*[in]*/ LPCWSTR* lpszArgv )
{
    __HCP_FUNC_ENTRY( "CPCHUserProcess::SendResponse" );

    HRESULT                   hr;
    int                       i;
    CComBSTR                  bstrGUID;
    CComPtr<IPCHService>      srv;
    CComPtr<CPCHSlaveProcess> obj;
#ifdef DEBUG
    bool                      fDebug = false;
#endif


    //
    // Parse the arguments.
    //
    for(i=1; i<dwArgc; i++)
    {
        LPCWSTR szArg = lpszArgv[i];

        if(szArg[0] == '-' ||
           szArg[0] == '/'  )
        {
            szArg++;

            if(_wcsicmp( szArg, L"guid" ) == 0 && (i<dwArgc-1))
            {
                bstrGUID = lpszArgv[++i];
                continue;
            }

#ifdef DEBUG
            if(_wcsicmp( szArg, L"debug" ) == 0)
            {
                fDebug = true;
                continue;
            }
#endif
        }

        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

#ifdef DEBUG
    if(fDebug) DebugBreak();
#endif

    //
    // Create the COM object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    //
    // Register it with the service.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_PCHService, NULL, CLSCTX_ALL, IID_IPCHService, (void**)&srv ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, srv->RegisterHost( bstrGUID, obj ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CPCHSlaveProcess::CPCHSlaveProcess()
{
    						 // CComBSTR                    m_bstrVendorID;
    						 // CComBSTR                    m_bstrPublicKey;
	m_ScriptLauncher = NULL; // CPCHScriptWrapper_Launcher* m_ScriptLauncher;
}

CPCHSlaveProcess::~CPCHSlaveProcess()
{
	delete m_ScriptLauncher;
}

HRESULT CPCHSlaveProcess::Initialize( /*[in]*/ BSTR bstrVendorID, /*[in]*/ BSTR bstrPublicKey )
{
    m_bstrVendorID  = bstrVendorID;
    m_bstrPublicKey = bstrPublicKey;

    return S_OK;
}

HRESULT CPCHSlaveProcess::CreateInstance( /*[in ]*/ REFCLSID   rclsid    ,
                                          /*[in ]*/ IUnknown*  pUnkOuter ,
                                          /*[out]*/ IUnknown* *ppvObject )
{
	HRESULT hr;

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::CreateInstance" );

    hr = ::CoCreateInstance( rclsid, pUnkOuter, CLSCTX_ALL, IID_IUnknown, (void**)ppvObject );

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::CreateInstance - done" );

	return hr;
}

HRESULT CPCHSlaveProcess::CreateScriptWrapper( /*[in ]*/ REFCLSID   rclsid   ,
                                               /*[in ]*/ BSTR       bstrCode ,
                                               /*[in ]*/ BSTR       bstrURL  ,
                                               /*[out]*/ IUnknown* *ppObj    )
{
    __HCP_FUNC_ENTRY( "CPCHSlaveProcess::CreateScriptWrapper" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	if(!m_ScriptLauncher)
	{
		__MPC_EXIT_IF_ALLOC_FAILS(hr, m_ScriptLauncher, new CPCHScriptWrapper_Launcher);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_ScriptLauncher->CreateScriptWrapper( rclsid, bstrCode, bstrURL, ppObj ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSlaveProcess::OpenBlockingStream( /*[in ]*/ BSTR       bstrURL   ,
                                              /*[out]*/ IUnknown* *ppvObject )
{
    __HCP_FUNC_ENTRY( "CPCHSlaveProcess::OpenBlockingStream" );

    HRESULT          hr;
    CComPtr<IStream> stream;


	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::OpenBlockingStream" );

    __MPC_EXIT_IF_METHOD_FAILS(hr, URLOpenBlockingStreamW( NULL, bstrURL, &stream, 0, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream.QueryInterface( ppvObject ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::OpenBlockingStream - done" );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSlaveProcess::IsNetworkAlive( /*[out]*/ VARIANT_BOOL* pfRetVal )
{
    __HCP_FUNC_ENTRY( "CPCHSlaveProcess::IsNetworkAlive" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pfRetVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::IsNetworkAlive" );

    if(SUCCEEDED(MPC::Connectivity::NetworkAlive( HC_TIMEOUT_CONNECTIONCHECK )))
    {
        *pfRetVal = VARIANT_TRUE;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::IsNetworkAlive - done" );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSlaveProcess::IsDestinationReachable( /*[in ]*/ BSTR bstrDestination, /*[out]*/ VARIANT_BOOL *pfRetVal )
{
    __HCP_FUNC_ENTRY( "CPCHSlaveProcess::IsDestinationReachable" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrDestination);
        __MPC_PARAMCHECK_POINTER_AND_SET(pfRetVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::IsDestinationReachable" );

    if(SUCCEEDED(MPC::Connectivity::DestinationReachable( bstrDestination, HC_TIMEOUT_CONNECTIONCHECK )))
    {
        *pfRetVal = VARIANT_TRUE;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	DEBUG_AppendPerf( DEBUG_PERF_HELPHOST, "CPCHSlaveProcess::IsDestinationReachable - done" );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\core\dload.c ===
#include <windows.h>
#include <delayimp.h>

#include <esent.h>

////////////////////////////////////////////////////////////////////////////////

static JET_ERR WINAPI hook_ESENT()
{
	return JET_wrnNyi;
}

static HRESULT WINAPI hook_HRESULT()
{
	return HRESULT_FROM_WIN32( ERROR_PROC_NOT_FOUND );
}

static VOID* WINAPI hook_NULL()
{
	SetLastError( ERROR_PROC_NOT_FOUND );

	return NULL;
}

static DWORD WINAPI hook_ACCESSDENIED()
{
	return ERROR_ACCESS_DENIED;
}

////////////////////////////////////////////////////////////////////////////////

FARPROC WINAPI HELPSVC_DelayLoadFailureHook( UINT unReason, PDelayLoadInfo pDelayInfo )
{
	if(!lstrcmpiA( pDelayInfo->szDll, "esent.dll" ))
	{
		// ESENT.DLL :: JetAttachDatabase
		// ESENT.DLL :: JetBeginSession
		// ESENT.DLL :: JetBeginTransaction
		// ESENT.DLL :: JetCloseDatabase
		// ESENT.DLL :: JetCloseTable
		// ESENT.DLL :: JetCommitTransaction
		// ESENT.DLL :: JetCreateDatabase
		// ESENT.DLL :: JetCreateTable
		// ESENT.DLL :: JetCreateTableColumnIndex
		// ESENT.DLL :: JetDBUtilities
		// ESENT.DLL :: JetDelete
		// ESENT.DLL :: JetDetachDatabase
		// ESENT.DLL :: JetDupCursor
		// ESENT.DLL :: JetEndSession
		// ESENT.DLL :: JetGetObjectInfo
		// ESENT.DLL :: JetGetTableColumnInfo
		// ESENT.DLL :: JetGetTableIndexInfo
		// ESENT.DLL :: JetGotoBookmark
		// ESENT.DLL :: JetInit
		// ESENT.DLL :: JetMakeKey
		// ESENT.DLL :: JetMove
		// ESENT.DLL :: JetOpenDatabase
		// ESENT.DLL :: JetOpenTable
		// ESENT.DLL :: JetPrepareUpdate
		// ESENT.DLL :: JetResetSessionContext
		// ESENT.DLL :: JetRetrieveColumn
		// ESENT.DLL :: JetRetrieveColumns
		// ESENT.DLL :: JetRollback
		// ESENT.DLL :: JetSeek
		// ESENT.DLL :: JetSetColumn
		// ESENT.DLL :: JetSetCurrentIndex2
		// ESENT.DLL :: JetSetIndexRange
		// ESENT.DLL :: JetSetSessionContext
		// ESENT.DLL :: JetSetSystemParameter
		// ESENT.DLL :: JetTerm2
		// ESENT.DLL :: JetUpdate
		return (FARPROC)hook_ESENT;
	}
	else if(!lstrcmpiA( pDelayInfo->szDll, "wintrust.dll" ))
	{
		// WINTRUST.DLL :: WinVerifyTrust
		return (FARPROC)hook_HRESULT;
	}
	else if(!lstrcmpiA( pDelayInfo->szDll, "NETAPI32.dll" ))
	{
		// NETAPI32.DLL :: NetApiBufferFree
		// NETAPI32.DLL :: NetLocalGroupAdd
		// NETAPI32.DLL :: NetLocalGroupAddMembers
		// NETAPI32.DLL :: NetLocalGroupDel
		// NETAPI32.DLL :: NetUserAdd
		// NETAPI32.DLL :: NetUserDel
		// NETAPI32.DLL :: NetUserGetInfo
		// NETAPI32.DLL :: NetUserSetInfo
		return (FARPROC)hook_ACCESSDENIED;
	}

	// CABINET.DLL 	:: *
	// CRYPT32.DLL 	:: CertCloseStore
	// CRYPT32.DLL 	:: CertEnumCertificatesInStore
	// CRYPT32.DLL 	:: CertFreeCertificateContext
	// CRYPT32.DLL 	:: CertGetNameStringW
	// CRYPT32.DLL 	:: CryptQueryObject
	// SECUR32.dll 	:: TranslateNameW
	// SHLWAPI.DLL 	:: StrChrA
	// SHLWAPI.DLL 	:: StrStrIW
	// USERENV.DLL 	:: CreateEnvironmentBlock
	// USERENV.DLL 	:: DestroyEnvironmentBlock
	// WININET.DLL 	:: InternetCanonicalizeUrlW
	// WINSTA.DLL   :: WinStationIsHelpAssistantSession
	// WINSTA.DLL   :: WinStationQueryInformationW
	// WTSAPI32.DLL :: WTSEnumerateSessionsW
	// WTSAPI32.DLL :: WTSFreeMemory

	return (FARPROC)hook_NULL; // Also covers hook_ZERO and hook_FALSE.
}

// we assume DELAYLOAD_VERSION >= 0x0200
PfnDliHook __pfnDliFailureHook2 = HELPSVC_DelayLoadFailureHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\common\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_


#include <module.h>


#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>
#include <MPC_logging.h>
#include <MPC_security.h>

#include <SvcResource.h>

#include <SvcUtils.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <Service.h>
#include <Utility.h>

#include <AccountsLib.h>

#include <TrustedScripts.h>

extern MPC::NTEvent g_NTEvents;

#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\core\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the implementation of the WinMain function for HelpSvc.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <SvcResource.h>

#include <initguid.h>

#include "msscript.h"

#include "HelpServiceTypeLib.h"
#include "HelpServiceTypeLib_i.c"

#include "HelpCenterTypeLib.h"
#include "HelpCenterTypeLib_i.c"


BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PCHServiceReal, CPCHService        )
    OBJECT_ENTRY(CLSID_PCHUpdateReal , HCUpdate::Engine   )
#ifndef NOJETBLUECOM
    OBJECT_ENTRY(CLSID_PCHDBSession  , JetBlueCOM::Session)
#endif
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////////////

bool local_IsSameSKUInstalled()
{
    MPC::wstring strCabinet;
    bool         fSameSKU = false;

	//
	// Find the best fit.
	//
	do
	{
		OSVERSIONINFOEXW ver;
		MPC::WStringList lst;
		MPC::WStringIter it;

		::ZeroMemory( &ver, sizeof(ver) ); ver.dwOSVersionInfoSize = sizeof(ver);

		::GetVersionExW( (LPOSVERSIONINFOW)&ver );

		if(FAILED(SVC::LocateDataArchive( HC_ROOT_HELPSVC_BINARIES, lst ))) break;
		if(lst.size() == 0) break;

		for(it = lst.begin(); it != lst.end(); it++)
		{
			Installer::Package pkg;

			if(SUCCEEDED(pkg.Init( it->c_str() )) &&
			   SUCCEEDED(pkg.Load(             ))  )
			{
				LPCWSTR szSKU = pkg.GetData().m_ths.GetSKU();

				if(ver.wProductType == VER_NT_WORKSTATION)
				{
					if(ver.wSuiteMask & VER_SUITE_PERSONAL)
					{
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_PERSONAL )) break;
					}
					else
					{
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_PROFESSIONAL )) break;
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_64_PROFESSIONAL )) break;
					}
				}
				else
				{
					if(ver.wSuiteMask & VER_SUITE_DATACENTER)
					{
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_DATACENTER )) break;
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_64_DATACENTER )) break;
					}
					else if(ver.wSuiteMask & VER_SUITE_ENTERPRISE)
					{
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_ADVANCED_SERVER )) break;
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_64_ADVANCED_SERVER )) break;
					}
					else
					{
						if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_SERVER )) break;
					}
				}
			}
		}

		strCabinet = *(it == lst.end() ? lst.begin() : it);
	}
	while(0);

	if(strCabinet.size())
	{
		Installer::Package              pkg;
        Taxonomy::Instance              instCab;
        Taxonomy::LockingHandle         handle;
        Taxonomy::InstanceIterConst     itBegin;
        Taxonomy::InstanceIterConst     itEnd;

		
		if(SUCCEEDED(pkg.Init( strCabinet.c_str() )) &&
		   SUCCEEDED(pkg.Load(                    )) &&
		   SUCCEEDED(instCab.InitializeFromBase( pkg.GetData(), /*fSystem*/true, /*fMUI*/false )) &&
           SUCCEEDED(Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle )) &&
           SUCCEEDED(Taxonomy::InstalledInstanceStore::s_GLOBAL->Instance_GetList( itBegin, itEnd )) )
		{

            for(;itBegin != itEnd; itBegin++)
            {
                const Taxonomy::Instance& inst = *itBegin;

                if( inst.m_ths == instCab.m_ths && inst.m_fSystem )  // Same system SKU
                {
                    fSameSKU = true;
                    break;
                }
            }
		}
	}

	return fSameSKU;
}


static HRESULT PurgeTempFiles()
{
    __HCP_FUNC_ENTRY( "PurgeTempFiles" );

    HRESULT                          hr;
    MPC::wstring                     szTempPath( HC_ROOT_HELPSVC_TEMP ); MPC::SubstituteEnvVariables( szTempPath );
    MPC::FileSystemObject            fso( szTempPath.c_str() );
    MPC::FileSystemObject::List      fso_lst;
    MPC::FileSystemObject::IterConst fso_it;


    //
    // Inspect the temp directory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.CreateDir( true ));


    //
    // Delete any subdirectory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFolders( fso_lst ));
    for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->Delete( true, false ));
    }
    fso_lst.clear();

    //
    // For each file, if it's not in the database, delete it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFiles( fso_lst ));
    for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->Delete( false, false ));
    }
    fso_lst.clear();


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT InitAll()
{
    __HCP_FUNC_ENTRY( "InitAll" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeInit());

    __MPC_EXIT_IF_METHOD_FAILS(hr, JetBlue::SessionPool            ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::Cache                 ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OfflineCache::Root              ::InitializeSystem( /*fMaster*/true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHContentStore                ::InitializeSystem( /*fMaster*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess                 ::InitializeSystem(                 ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurity                    ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSystemMonitor               ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg                         ::InitializeSystem(                 ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static void CleanAll()
{
	//
	// Make sure everything is stopped before releasing any object.
	//
	if(Taxonomy::InstalledInstanceStore::s_GLOBAL)
	{
		Taxonomy::InstalledInstanceStore::s_GLOBAL->Shutdown();
	}


    CSAFReg                         ::FinalizeSystem();
    CPCHSystemMonitor               ::FinalizeSystem();
    CPCHSecurity                    ::FinalizeSystem();

    CPCHUserProcess                 ::FinalizeSystem();
    CPCHContentStore                ::FinalizeSystem();

    OfflineCache::Root              ::FinalizeSystem();
    Taxonomy::Cache                 ::FinalizeSystem();
    Taxonomy::InstalledInstanceStore::FinalizeSystem();
    JetBlue::SessionPool            ::FinalizeSystem();
}

static HRESULT ProcessArguments( int      argc ,
                                 LPCWSTR* argv )
{
    __HCP_FUNC_ENTRY( "ProcessArguments" );

    HRESULT  hr;
    int      i;
    LPCWSTR  szSvcHostGroup = NULL;
    bool     fCOM_reg       = false;
    bool     fCOM_unreg     = false;
    bool     fInstall       = false;
    bool     fUninstall     = false;
    bool     fCollect       = false;
    bool     fRunAsService  = true;
    bool     fRun           = true;
    bool     fMUI_install   = false;
    bool     fMUI_uninstall = false;
	LPCWSTR  MUI_language   = NULL;
	CComBSTR MUI_cabinet;

	__MPC_EXIT_IF_METHOD_FAILS(hr, InitAll());


    for(i=1; i<argc; i++)
    {
        LPCWSTR szArg = argv[i];

        if(szArg[0] == '-' ||
           szArg[0] == '/'  )
        {
            szArg++;

            if(_wcsicmp( szArg, L"SvcHost" ) == 0 && i < argc-1)
            {
                szSvcHostGroup = argv[++i];
                continue;
            }

            if(_wcsicmp( szArg, L"UnregServer" ) == 0)
            {
                fCOM_unreg = true;
                fRun       = false;
                continue;
            }

            if(_wcsicmp( szArg, L"RegServer" ) == 0)
            {
                fCOM_unreg = true; // Unregister before registering. Useful in upgrade scenario.
                fCOM_reg   = true;
                fRun       = false;
                continue;
            }

            if(_wcsicmp( szArg, L"Embedding" ) == 0)
            {
                fRunAsService = false;
                continue;
            }

            if(_wcsicmp( szArg, L"Install" ) == 0)
            {
                fInstall = true;
                fRun     = false;
                continue;
            }

            if(_wcsicmp( szArg, L"Install2" ) == 0)
            {
                // Install only when the same SKU is not already installed
                if ( !local_IsSameSKUInstalled() )
                {
                    fInstall = true;
                }

                fRun = false;
                continue;
            }

            if(_wcsicmp( szArg, L"Uninstall" ) == 0)
            {
                fUninstall = true;
                fRun       = false;
                continue;
            }

            if(_wcsicmp( szArg, L"MUI_Install" ) == 0 && i < argc-2)
            {
				MUI_language = argv[++i];
				MUI_cabinet  = argv[++i];

				fMUI_install = true;
                fRun         = false;
                continue;
            }

            if(_wcsicmp( szArg, L"MUI_Uninstall" ) == 0 && i < argc-1)
            {
				MUI_language = argv[++i];

				fMUI_uninstall = true;
                fRun           = false;
                continue;
            }

            if(_wcsicmp( szArg, L"Collect" ) == 0)
            {
                fCollect = true;
                fRun     = false;
                continue;
            }
        }

        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    //////////////////////////////////////////////////////////////////////

    if(fCollect       ||
	   fMUI_install   ||
	   fMUI_uninstall  )
    {
		try
		{
			CComPtr<IPCHService> svc;
			long                 lLCID = 0;

			if(MUI_language)
			{
				swscanf( MUI_language, L"%lx", &lLCID );
			}

			if(FAILED(hr = ::CoCreateInstance( CLSID_PCHService, NULL, CLSCTX_ALL, IID_IPCHService, (void**)&svc )))
			{
                static WCHAR s_szRunOnceKey[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce";

                MPC::RegKey  rk;
				MPC::wstring szName = L"DelayedHelpSvc_";
				WCHAR        rgBuf[8];

				if(fCollect)
				{
					szName += L"Collect";
				}

				if(fMUI_install)
				{
					swprintf( rgBuf, L"%04x", (int)lLCID );
					
					szName += L"MUI_Install_";
					szName += rgBuf;
				}

				if(fMUI_uninstall)
				{
					swprintf( rgBuf, L"%04x", (int)lLCID );
					
					szName += L"MUI_Uninstall_";
					szName += rgBuf;
				}

                if(SUCCEEDED(rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS )) &&
                   SUCCEEDED(rk.Attach ( s_szRunOnceKey                     )) &&
                   SUCCEEDED(rk.Create (                                    ))  )
                {
					MPC::wstring szCmd = ::GetCommandLineW();

					rk.Write( szCmd, szName.c_str() );
				}

				__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
			}

			if(fCollect)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, svc->TriggerScheduledDataCollection( VARIANT_TRUE ));
			}

			if(fMUI_install)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, svc->MUI_Install( lLCID, MUI_cabinet ));
			}

			if(fMUI_uninstall)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, svc->MUI_Uninstall( lLCID ));
			}
		}
		catch(...)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, EXCEPTION_NONCONTINUABLE_EXCEPTION);
		}

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //////////////////////////////////////////////////////////////////////

	if(fCOM_unreg)
	{
		_Module.UnregisterServer( szSvcHostGroup );
	}

    if(fCOM_reg)
	{
		_Module.RegisterServer( TRUE, (szSvcHostGroup != NULL), szSvcHostGroup );
	}


    if(fInstall)
    {
		try
		{
			(void)Local_Install();
		}
		catch(...)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, EXCEPTION_NONCONTINUABLE_EXCEPTION);
		}
    }

    if(fUninstall)
    {
		try
		{
			(void)Local_Uninstall();
		}
		catch(...)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, EXCEPTION_NONCONTINUABLE_EXCEPTION);
		}
    }

    //////////////////////////////////////////////////////////////////////

    if(fRun)
    {
#ifdef DEBUG
        _Module.ReadDebugSettings();
#endif

		DEBUG_AppendPerf( DEBUG_PERF_HELPSVC, "Start" );

		try
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, PurgeTempFiles());

			//
			// To run properly, we need this privilege.
			//
			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::SetPrivilege( L"SeSecurityPrivilege" ));
		
			__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSystemMonitor::s_GLOBAL->Startup());

			DEBUG_AppendPerf( DEBUG_PERF_HELPSVC, "Started" );

			_Module.Start( fRunAsService ? TRUE : FALSE );
		}
		catch(...)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, EXCEPTION_NONCONTINUABLE_EXCEPTION);
		}

		DEBUG_AppendPerf( DEBUG_PERF_HELPSVC, "Shutdown"               );
		DEBUG_DumpPerf  ( L"%WINDIR%\\TEMP\\HELPSVC_perf_counters.txt" );
    }

    //////////////////////////////////////////////////////////////////////

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

	CleanAll();

    __HCP_FUNC_EXIT(hr);
}


extern "C" int WINAPI wWinMain( HINSTANCE   hInstance    ,
                                HINSTANCE   hPrevInstance,
                                LPWSTR      lpCmdLine    ,
                                int         nShowCmd     )
{
    HRESULT  hr;
    int      argc;
    LPCWSTR* argv;

    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED ))) // We need to be a multi-threaded application.
    {
        if(SUCCEEDED(hr = ::CoInitializeSecurity( NULL                      ,
                                                  -1                        , // We don't care which authentication service we use.
                                                  NULL                      ,
                                                  NULL                      ,
                                                  RPC_C_AUTHN_LEVEL_CONNECT , // We want to identify the callers.
                                                  RPC_C_IMP_LEVEL_IDENTIFY  ,
                                                  NULL                      ,
                                                  EOAC_DYNAMIC_CLOAKING     , // Let's use the thread token for outbound calls.
                                                  NULL                      )))
        {
#ifdef PCH_DEBUG_SETUP
            {
                static WCHAR s_szDebugAsyncTrace[] = L"SOFTWARE\\Microsoft\\MosTrace\\CurrentVersion\\DebugAsyncTrace";

                MPC::RegKey rkTrace;

                if(SUCCEEDED(rkTrace.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS )) &&
                   SUCCEEDED(rkTrace.Attach ( s_szDebugAsyncTrace                )) &&
                   SUCCEEDED(rkTrace.Create (                                    ))  )
                {
                    CComVariant vValue;

                    vValue = (long)0x00000000   ; (void)rkTrace.put_Value( vValue, L"AsyncThreadPriority" );
                    vValue = (long)0x00000001   ; (void)rkTrace.put_Value( vValue, L"OutputTraceType"     );
                    vValue = (long)500*1024*1024; (void)rkTrace.put_Value( vValue, L"MaxTraceFileSize"    );
                    vValue = L"c:\\trace.atf"   ; (void)rkTrace.put_Value( vValue, L"TraceFile"           );
                    vValue = (long)0x00000001   ; (void)rkTrace.put_Value( vValue, L"AsyncTraceFlag"      );
                    vValue = (long)0x0000003F   ; (void)rkTrace.put_Value( vValue, L"EnabledTraces"       );
                }
            }
#endif

            __MPC_TRACE_INIT();

            g_NTEvents.Init( L"HELPSVC" );

			//
			// Parse the command line.
			//
			if(SUCCEEDED(hr = MPC::CommandLine_Parse( argc, argv )))
			{
				//
				// Initialize ATL modules.
				//
				_Module.Init( ObjectMap, hInstance, HC_HELPSVC_NAME, IDS_HELPSVC_DISPLAYNAME, IDS_HELPSVC_DESCRIPTION );

				//
				// Initialize MPC module.
				//
				if(SUCCEEDED(hr = MPC::_MPC_Module.Init()))
				{
					//
					// Process arguments.
					//
					hr = ProcessArguments( argc, argv );

					MPC::_MPC_Module.Term();
				}

				_Module.Term();

				MPC::CommandLine_Free( argc, argv );
			}


            __MPC_TRACE_TERM();
        }

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\common\module.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    module.cpp

Abstract:
    This file contains the implementation of the CServiceModule class, which is
    used to handling service-related routines.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

      DWORD dwTimeOut  = 16*1000; // time for EXE to be idle before shutting down
const DWORD dwPause    =    1000;  // time to wait for threads to finish up

CServiceModule _Module;
MPC::NTEvent   g_NTEvents;
MPC::FileLog   g_ApplicationLog( /*fCacheHandle*/false, /*fUseUnicode*/false );

/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
#define DEBUG_REGKEY       HC_REGISTRY_HELPSVC L"\\Debug"
#define DEBUG_BREAKONSTART L"BREAKONSTART"
#define DEBUG_TIMEOUT      L"TIMEOUT"

void CServiceModule::ReadDebugSettings()
{
    __HCP_FUNC_ENTRY( "CServiceModule::ReadDebugSettings" );

    HRESULT     hr;
    MPC::RegKey rkBase;
    bool        fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SetRoot( HKEY_LOCAL_MACHINE ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Attach ( DEBUG_REGKEY       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Exists ( fFound             ));

    if(fFound)
    {
        CComVariant vValue;

        __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_BREAKONSTART ));
        if(fFound && vValue.vt == VT_I4)
        {
            if(vValue.lVal == 1) DebugBreak();
            if(vValue.lVal == 2) while(vValue.lVal) ::Sleep( 100 );
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_TIMEOUT ));
        if(fFound && vValue.vt == VT_I4)
        {
            dwTimeOut = 1000 * vValue.lVal;
        }
    }

    __HCP_FUNC_CLEANUP;
}
#endif

/////////////////////////////////////////////////////////////////////////////

static const WCHAR s_SvcHost[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost";

static const WCHAR s_Key  [] = L"System\\CurrentControlSet\\Services\\%s";
static const WCHAR s_Key2 [] = L"\\Parameters";
static const WCHAR s_Name [] = L"ServiceDll";
static const WCHAR s_Value[] = L"%WINDIR%\\PCHealth\\HelpCtr\\Binaries\\pchsvc.dll";

static HRESULT ServiceHost_Install( LPCWSTR szName, LPCWSTR szGroup )
{
	__HCP_FUNC_ENTRY( "ServiceHost_Install" );

	HRESULT hr;

	{
		WCHAR rgRegPath[_MAX_PATH]; swprintf( rgRegPath, s_Key, szName ); wcscat( rgRegPath, s_Key2 );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey_Value_Write( s_Value, rgRegPath, s_Name, HKEY_LOCAL_MACHINE, true ));
	}

	{
		MPC::RegKey		 rk;
		MPC::WStringList lstValue;
		bool             fFound;
		bool             fGot = false;

		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach (                     s_SvcHost      ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Create (                                    ));


		if(SUCCEEDED(rk.Read( lstValue, fFound, szGroup )))
		{
			for(MPC::WStringIterConst it = lstValue.begin(); it != lstValue.end(); it++)
			{
				if(!MPC::StrICmp( *it, szName ))
				{
					fGot = true;
					break;
				}
			}
		}

		if(fGot == false)
		{
			lstValue.push_back( szName );
			__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Write( lstValue, szGroup ));
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

static HRESULT ServiceHost_Uninstall( LPCWSTR szName, LPCWSTR szGroup )
{
	__HCP_FUNC_ENTRY( "ServiceHost_Uninstall" );

	HRESULT hr;

	{
		WCHAR	    rgRegPath[_MAX_PATH]; swprintf( rgRegPath, s_Key, szName );
		MPC::RegKey rk;

		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach (                     rgRegPath      ));
		(void)rk.Delete( /*fDeep*/true );
	}

	{
		MPC::RegKey      rk;
		MPC::WStringList lstValue;
		bool             fFound;


		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach (                     s_SvcHost      ));

		if(SUCCEEDED(rk.Read( lstValue, fFound, szGroup )))
		{
			MPC::WStringIterConst it   = lstValue.begin();
			bool                  fGot = false;

			while(it != lstValue.end())
			{
				MPC::WStringIterConst it2 = it++;

				if(!MPC::StrICmp( *it2, szName ))
				{
					lstValue.erase( it2 );
					fGot = true;
				}
			}

			if(fGot)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Write( lstValue, szGroup ));
			}
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

CServiceModule::CServiceModule()
{
    m_hEventShutdown = NULL;  //  HANDLE                m_hEventShutdown;
    m_dwThreadID     = 0;     //  DWORD                 m_dwThreadID;
    m_hMonitor       = NULL;  //  HANDLE                m_hMonitor;
    m_bActivity      = FALSE; //  BOOL                  m_bActivity;
                              //
    m_szServiceName  = NULL;  //  LPCWSTR               m_szServiceName;
    m_iDisplayName   = 0;     //  UINT                  m_iDisplayName;
    m_iDescription   = 0;     //  UINT                  m_iDescription;
    m_hServiceStatus = NULL;  //  SERVICE_STATUS_HANDLE m_hServiceStatus;
                              //  SERVICE_STATUS        m_status;
    m_bService       = FALSE; //  BOOL                  m_bService;

    ::ZeroMemory( &m_status, sizeof( m_status ) );
}

CServiceModule::~CServiceModule()
{
    if(m_hEventShutdown) ::CloseHandle( m_hEventShutdown );
    if(m_hMonitor      ) ::CloseHandle( m_hMonitor       );
}

/////////////////////////////////////////////////////////////////////////////

LONG CServiceModule::Lock()
{
    LONG lCount = CComModule::Lock();

    return lCount;
}

LONG CServiceModule::Unlock()
{
    LONG lCount = CComModule::Unlock();

    if(lCount == 0)
    {
        m_bActivity = TRUE;

        if(m_hEventShutdown) ::SetEvent( m_hEventShutdown ); // tell monitor that we transitioned to zero
    }

    return lCount;
}

void CServiceModule::MonitorShutdown()
{
    while(1)
    {
        DWORD dwWait;

        m_bActivity = FALSE;
        dwWait      = ::WaitForSingleObject( m_hEventShutdown, dwTimeOut );

        if(dwWait == WAIT_OBJECT_0) continue; // We are alive...

        //
        // If no activity let's really bail.
        //
        if(m_bActivity == FALSE && m_nLockCnt <= 0)
        {
            ::CoSuspendClassObjects();

            if(m_bActivity == FALSE && m_nLockCnt <= 0) break;
        }
    }

    ForceShutdown();
}

void CServiceModule::ForceShutdown()
{

    //
    // Tell process to exit.
    //
    ::PostThreadMessage( m_dwThreadID, WM_QUIT, 0, 0 );
}

BOOL CServiceModule::StartMonitor()
{
    DWORD dwThreadID;


    m_hMonitor = ::CreateThread( NULL, 0, _Monitor, this, 0, &dwThreadID );
    if(m_hMonitor == NULL) return FALSE;


    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CServiceModule::RegisterServer( BOOL bRegTypeLib, BOOL bService, LPCWSTR szSvcHostGroup )
{
    HRESULT hr;

    // Remove any previous service since it may point to the incorrect file
    Uninstall( szSvcHostGroup );

    if(bService)
    {
        // Create service
        Install( szSvcHostGroup );
    }

    // Add object entries
    if(FAILED(hr = CComModule::RegisterServer( TRUE ))) return hr;

    if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_HELPSVC , TRUE ))) return hr;
    if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_HCUPDATE, TRUE ))) return hr;

#ifndef NOJETBLUECOM
    if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_PCHDBSESSION, TRUE ))) return hr;
#endif

    return S_OK;
}

HRESULT CServiceModule::UnregisterServer( LPCWSTR szSvcHostGroup )
{
    HRESULT hr;

    // Remove service
    Uninstall( szSvcHostGroup );

    // Remove object entries
    if(FAILED(hr = CComModule::UnregisterServer( TRUE ))) return hr;

    if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_HELPSVC , FALSE ))) return hr;
    if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_HCUPDATE, FALSE ))) return hr;

#ifndef NOJETBLUECOM
    if(FAILED(hr = _Module.UpdateRegistryFromResource( IDR_PCHDBSESSION, FALSE ))) return hr;
#endif

    return S_OK;
}

void CServiceModule::Init( _ATL_OBJMAP_ENTRY* p, HINSTANCE h, LPCWSTR szServiceName, UINT iDisplayName, UINT iDescription, const GUID* plibid )
{
    CComModule::Init( p, h, plibid );

	{
		MPC::wstring strLogFile( HC_ROOT_HELPSVC_LOGS L"\\" ); MPC::SubstituteEnvVariables( strLogFile );

		strLogFile += szServiceName;
		strLogFile += L".log";

		g_ApplicationLog.SetLocation( strLogFile.c_str() );
	}

    m_szServiceName = szServiceName;
    m_iDisplayName  = iDisplayName;
    m_iDescription  = iDescription;

    // set up the initial service status
    m_hServiceStatus = NULL;

    m_status.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState            = SERVICE_STOPPED;
    m_status.dwControlsAccepted        = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode           = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint              = 0;
    m_status.dwWaitHint                = 0;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL      bResult = FALSE;
    SC_HANDLE hSCM    = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );


    if((hSCM = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS )))
    {
        SC_HANDLE hService;

        if((hService = ::OpenServiceW( hSCM, m_szServiceName, SERVICE_QUERY_CONFIG )))
        {
            bResult = TRUE;

            ::CloseServiceHandle( hService );
        }

        ::CloseServiceHandle( hSCM );
    }

    return bResult;
}

BOOL CServiceModule::Install( LPCWSTR szSvcHostGroup )
{
    BOOL      bResult = FALSE;
    SC_HANDLE hSCM;


    if((hSCM = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS )))
    {
        MPC::wstring strDisplayName;
        MPC::wstring strDescription;
        WCHAR        szFilePath[_MAX_PATH];
        SC_HANDLE    hService;
        DWORD        dwStartType;


        if(szSvcHostGroup)
        {
            dwStartType = SERVICE_WIN32_SHARE_PROCESS;

			swprintf( szFilePath, L"%%SystemRoot%%\\System32\\svchost.exe -k %s", szSvcHostGroup );
        }
        else
        {
            dwStartType = SERVICE_WIN32_OWN_PROCESS;

            ::GetModuleFileNameW( NULL, szFilePath, _MAX_PATH );
        }

        if(FAILED( MPC::LocalizeString( m_iDisplayName, strDisplayName )))
        {
            strDisplayName = m_szServiceName;
        }
        (void)MPC::LocalizeString( m_iDescription, strDescription );


        hService = ::OpenServiceW( hSCM, m_szServiceName, SERVICE_QUERY_CONFIG );
        if(hService == NULL)
        {
			hService = ::CreateServiceW( hSCM                  ,
                                      	 m_szServiceName       ,
                                      	 strDisplayName.c_str(),
                                      	 SERVICE_ALL_ACCESS    ,
                                      	 dwStartType           ,
                                      	 SERVICE_AUTO_START    ,
                                      	 SERVICE_ERROR_NORMAL  ,
                                      	 szFilePath            ,
                                      	 NULL                  ,
                                      	 NULL                  ,
                                      	 L"RPCSS\0"            ,
                                      	 NULL                  ,
                                      	 NULL                  );
		}

        if(hService)
		{
            if(strDescription.size())
            {
                SERVICE_DESCRIPTIONW     desc;     ::ZeroMemory( &desc    , sizeof(desc    ) );
				SERVICE_FAILURE_ACTIONSW recovery; ::ZeroMemory( &recovery, sizeof(recovery) ); 
				SC_ACTION                actions[] =
				{
					{ SC_ACTION_RESTART, 100 },
					{ SC_ACTION_RESTART, 100 },
					{ SC_ACTION_NONE   , 100 },
				};

				desc.lpDescription = (LPWSTR)strDescription.c_str();

				recovery.dwResetPeriod = 24 * 60 * 60; // 1 day
				recovery.cActions      = ARRAYSIZE(actions);
				recovery.lpsaActions   =           actions;

                ::ChangeServiceConfig2W( hService, SERVICE_CONFIG_DESCRIPTION    , &desc     );
                ::ChangeServiceConfig2W( hService, SERVICE_CONFIG_FAILURE_ACTIONS, &recovery );
            }

            if(szSvcHostGroup)
            {
				if(SUCCEEDED(ServiceHost_Install( m_szServiceName, szSvcHostGroup )))
				{
                    bResult = TRUE;
                }
            }
            else
            {
                bResult = TRUE;
            }

            ::CloseServiceHandle( hService );
        }

        if(bResult == FALSE)
        {
            (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, HELPSVC_ERR_CANNOTCREATESERVICE, NULL );
        }

        ::CloseServiceHandle( hSCM );
    }
    else
    {
        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, HELPSVC_ERR_CANNOTOPENSCM, NULL );
    }

    return bResult;
}

BOOL CServiceModule::Uninstall( LPCWSTR szSvcHostGroup )
{
    BOOL      bResult = FALSE;
    SC_HANDLE hSCM;


    if((hSCM = ::OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS )))
    {
        SC_HANDLE hService;

        if((hService = ::OpenServiceW( hSCM, m_szServiceName, SERVICE_STOP | DELETE )))
        {
            SERVICE_STATUS status;

            ::ControlService( hService, SERVICE_CONTROL_STOP, &status );

            bResult = ::DeleteService( hService );
			if(bResult)
			{
				::Sleep( 2000 ); // Let the service stop down...

				if(szSvcHostGroup)
				{
					if(FAILED(ServiceHost_Uninstall( m_szServiceName, szSvcHostGroup )))
					{
						bResult = FALSE;
					}
				}
			}

            if(bResult == FALSE)
            {
                (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, HELPSVC_ERR_CANNOTDELETESERVICE, NULL );
            }

            ::CloseServiceHandle( hService );
        }

        ::CloseServiceHandle( hSCM );
    }
    else
    {
        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, HELPSVC_ERR_CANNOTOPENSCM, NULL );
    }


    return bResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
BOOL CServiceModule::Start( BOOL bService )
{
    SERVICE_TABLE_ENTRYW st[] =
    {
        { (LPWSTR)m_szServiceName, _ServiceMain },
        { NULL                   , NULL         }
    };

    m_hEventShutdown = ::CreateEvent( NULL, FALSE, FALSE, NULL );
    if(m_hEventShutdown == NULL) return FALSE;

    if((m_bService = bService) && !::StartServiceCtrlDispatcherW( st ))
    {
        DWORD dwRes = ::GetLastError();

        m_bService = FALSE;
    }

    if(m_bService == FALSE)
    {
        if(StartMonitor() == FALSE) return FALSE;

        if(FAILED(Run())) return FALSE;
    }

    return TRUE;
}

void CServiceModule::ServiceMain( DWORD dwArgc, LPWSTR lpszArgv[] )
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;

    if((m_hServiceStatus = ::RegisterServiceCtrlHandlerW( m_szServiceName, _Handler )))
    {
        SetServiceStatus( SERVICE_START_PENDING );

        m_status.dwWin32ExitCode = S_OK;
        m_status.dwCheckPoint    = 0;
        m_status.dwWaitHint      = 0;

        // When the Run function returns, the service has stopped.
        Run();

        SetServiceStatus( SERVICE_STOPPED );
    }
    else
    {
        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, HELPSVC_ERR_REGISTERHANDLER, NULL );
    }

}

void CServiceModule::Handler( DWORD dwOpcode )
{
    switch(dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus( SERVICE_STOP_PENDING );
        ForceShutdown();
        break;

    case SERVICE_CONTROL_PAUSE:
        break;

    case SERVICE_CONTROL_CONTINUE:
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        break;

    default:
        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, HELPSVC_ERR_BADSVCREQUEST, NULL );
    }
}

HRESULT CServiceModule::Run()
{
    __HCP_FUNC_ENTRY( "CServiceModule::Run" );

    HRESULT hr;
    MSG     msg;


    m_dwThreadID = ::GetCurrentThreadId();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoInitializeEx( NULL, COINIT_MULTITHREADED )); // We need to be a multi-threaded application.


    __MPC_EXIT_IF_METHOD_FAILS(hr, RegisterClassObjects( CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE ));

    if(m_bService)
    {
        SetServiceStatus( SERVICE_RUNNING );
    }


    while(::GetMessage( &msg, 0, 0, 0 ))
    {
        ::DispatchMessage( &msg );
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    _Module.RevokeClassObjects();
    ::Sleep( dwPause ); //wait for any threads to finish

    __HCP_FUNC_EXIT(hr);
}

void CServiceModule::SetServiceStatus( DWORD dwState )
{
    m_status.dwCurrentState = dwState;

    ::SetServiceStatus( m_hServiceStatus, &m_status );
}

////////////////////////////////////////////////////////////////////////////////

void WINAPI CServiceModule::_ServiceMain( DWORD dwArgc, LPWSTR* lpszArgv )
{
    _Module.ServiceMain( dwArgc, lpszArgv );
}

void WINAPI CServiceModule::_Handler( DWORD dwOpcode )
{
    _Module.Handler( dwOpcode );
}

DWORD WINAPI CServiceModule::_Monitor( void* pv )
{
    ((CServiceModule*)pv)->MonitorShutdown();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\common\utils.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    utils.cpp

Abstract:
    This file contains the implementation of various utility functions.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_szDataFiles_Pattern[] = L"pchdt_*.ca?";

////////////////////////////////////////////////////////////////////////////////

HRESULT SVC::OpenStreamForRead( /*[in]*/  LPCWSTR   szFile           ,
                                /*[out]*/ IStream* *pVal             ,
                                /*[in]*/  bool      fDeleteOnRelease )
{
    __HCP_FUNC_ENTRY( "SVC::OpenStreamForRead" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;
    MPC::wstring             strFileFull;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFile);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    MPC::SubstituteEnvVariables( strFileFull = szFile );


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead    ( strFileFull.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->DeleteOnRelease( fDeleteOnRelease    ));


    //
    // Return the stream to the caller.
    //
    *pVal = stream.Detach();
    hr    = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT SVC::OpenStreamForWrite( /*[in]*/  LPCWSTR   szFile           ,
                                 /*[out]*/ IStream* *pVal             ,
                                 /*[in]*/  bool      fDeleteOnRelease )
{
    __HCP_FUNC_ENTRY( "SVC::OpenStreamForWrite" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;
    MPC::wstring             strFileFull;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFile);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    MPC::SubstituteEnvVariables( strFileFull = szFile );


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForWrite   ( strFileFull.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->DeleteOnRelease( fDeleteOnRelease    ));


    //
    // Return the stream to the caller.
    //
    *pVal = stream.Detach();
    hr    = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SVC::CopyFileWhileImpersonating( /*[in]*/ LPCWSTR             szSrc                 ,
                                         /*[in]*/ LPCWSTR             szDst                 ,
                                         /*[in]*/ MPC::Impersonation& imp                   ,
                                         /*[in]*/ bool                fImpersonateForSource )
{
    __HCP_FUNC_ENTRY( "SVC::CopyFileWhileImpersonating" );

    HRESULT          hr;
    CComPtr<IStream> streamSrc;
    CComPtr<IStream> streamDst;


	if(fImpersonateForSource == true) __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForRead( szSrc, &streamSrc ));

	if(fImpersonateForSource == true) __MPC_EXIT_IF_METHOD_FAILS(hr, imp.RevertToSelf());

	////////////////////

	if(fImpersonateForSource == false) __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( szDst, &streamDst ));

	if(fImpersonateForSource == false) __MPC_EXIT_IF_METHOD_FAILS(hr, imp.RevertToSelf());

	////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamSrc, streamDst ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)imp.RevertToSelf();

    __HCP_FUNC_EXIT(hr);
}

HRESULT SVC::CopyOrExtractFileWhileImpersonating( /*[in]*/ LPCWSTR             szSrc ,
												  /*[in]*/ LPCWSTR             szDst ,
												  /*[in]*/ MPC::Impersonation& imp   )
{
    __HCP_FUNC_ENTRY( "SVC::CopyOrExtractFileWhileImpersonating" );

    HRESULT      hr;
    MPC::wstring strTempFile;


    //
    // First of all, try to simply copy the file.
    //
    if(FAILED(hr = CopyFileWhileImpersonating( szSrc, szDst, imp )))
    {
        int iLen = wcslen( szSrc );

        if(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) || iLen < 1)
        {
            __MPC_FUNC_LEAVE;
        }
        else
        {
            MPC::wstring strSrc2( szSrc ); strSrc2[iLen-1] = '_';
			LPCWSTR      szSrc3;

            //
            // Simple copy failed, let's try to copy the same file, with the last character changed to an underscore.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( strTempFile ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, CopyFileWhileImpersonating( strSrc2.c_str(), strTempFile.c_str(), imp ));

            //
            // Success, so it should be a cabinet, extract the real file.
            //
			szSrc3 = wcsrchr( szSrc, '\\' );
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DecompressFromCabinet( strTempFile.c_str(), szDst, szSrc3 ? szSrc3+1 : szSrc ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)MPC::RemoveTemporaryFile( strTempFile );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SVC::LocateDataArchive( /*[in ]*/ LPCWSTR           szDir ,
								/*[out]*/ MPC::WStringList& lst   )
{
    __HCP_FUNC_ENTRY( "SVC::LocateDataArchive" );

    HRESULT                          hr;
    MPC::wstring                     strName;
    MPC::wstring                     strInput( szDir           ); MPC::SubstituteEnvVariables( strInput );
    MPC::FileSystemObject            fso     ( strInput.c_str() );
    MPC::FileSystemObject::List      fso_lst;
    MPC::FileSystemObject::IterConst fso_it;


    //
    // Locate the "pchdt_<XX>.ca?" file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.Scan( false, true, c_szDataFiles_Pattern ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFiles( fso_lst ));
    for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
    {
		MPC::wstring& strDataArchive = *(lst.insert( lst.end() ));
		int           iLen;

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->get_Path( strDataArchive ));

		//
		// If it's a compressed file from the CD, return the real name.
		//
		iLen = strDataArchive.size();
		if(iLen && strDataArchive[iLen-1] == '_')
		{
			strDataArchive[iLen-1] = 'b';
		}
	}

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SVC::RemoveAndRecreateDirectory( /*[in]*/ const MPC::wstring& strDir, /*[in]*/ LPCWSTR szExtra, /*[in]*/ bool fRemove, /*[in]*/ bool fRecreate )
{
	return RemoveAndRecreateDirectory( strDir.c_str(), szExtra, fRemove, fRecreate );
}

HRESULT SVC::RemoveAndRecreateDirectory( /*[in]*/ LPCWSTR szDir, /*[in]*/ LPCWSTR szExtra, /*[in]*/ bool fRemove, /*[in]*/ bool fRecreate )
{
	HRESULT      hr;
    MPC::wstring strPath( szDir ); if(szExtra) strPath.append( szExtra );

	if(SUCCEEDED(hr = MPC::SubstituteEnvVariables( strPath )))
	{
		MPC::FileSystemObject fso( strPath.c_str() );

		if(fRemove)
		{
			hr = fso.Delete( true, false );
		}

		if(SUCCEEDED(hr))
		{
			if(fRecreate)
			{
				hr = fso.CreateDir( /*fForce*/true );
			}
		}
	}

	return hr;
}

HRESULT SVC::ChangeSD( /*[in]*/ MPC::SecurityDescriptor& sdd     ,
					   /*[in]*/ MPC::wstring             strPath ,
					   /*[in]*/ LPCWSTR                  szExtra )
{
    __HCP_FUNC_ENTRY( "SVC::ChangeSD" );

    HRESULT hr;

    if(szExtra) strPath.append( szExtra );

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strPath ));

    {
        MPC::FileSystemObject fso( strPath.c_str() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, fso.CreateDir( true ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetFileSecurityW( strPath.c_str()                     ,
                                                                 GROUP_SECURITY_INFORMATION          |
                                                                 DACL_SECURITY_INFORMATION           |
                                                                 PROTECTED_DACL_SECURITY_INFORMATION ,
                                                                 sdd.GetSD()                         ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


////////////////////////////////////////////////////////////////////////////////

static HRESULT local_ReadWithRetry( /*[in]*/ const MPC::wstring& strFile   ,
									/*[in]*/ MPC::FileStream*    stream    ,
									/*[in]*/ DWORD               dwTimeout ,
									/*[in]*/ DWORD               dwRetries )
{
	HRESULT hr;

	while(1)
	{
		if(SUCCEEDED(hr = stream->InitForRead( strFile.c_str() ))) return S_OK;

		if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED    ) ||
		   hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) ||
		   hr == HRESULT_FROM_WIN32(ERROR_LOCK_VIOLATION   )  )
		{
			(void)stream->Close();

			if(dwRetries)
			{
				::Sleep( dwTimeout );

				dwRetries--;
				continue;
			}
		}

		break;
	}

	return hr;
}

static HRESULT local_WriteWithRetry( /*[in]*/ const MPC::wstring& strFile   ,
									 /*[in]*/ MPC::FileStream*    stream    ,
									 /*[in]*/ DWORD               dwTimeout ,
									 /*[in]*/ DWORD               dwRetries )
{
	HRESULT hr;

	while(1)
	{
		if(SUCCEEDED(hr = stream->InitForWrite( strFile.c_str() ))) return S_OK;

		if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED    ) ||
		   hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) ||
		   hr == HRESULT_FROM_WIN32(ERROR_LOCK_VIOLATION   )  )
		{
			(void)stream->Close();

			if(dwRetries)
			{
				::Sleep( dwTimeout );

				dwRetries--;
				continue;
			}
		}

		break;
	}

	return hr;
}

HRESULT SVC::SafeLoad( /*[in]*/ const MPC::wstring& 	  strFile   ,
					   /*[in]*/ CComPtr<MPC::FileStream>& stream    ,
					   /*[in]*/ DWORD                     dwTimeout ,
					   /*[in]*/ DWORD                     dwRetries )
{
	__HCP_FUNC_ENTRY( "SVC::SafeLoad" );

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

	//
	// If fails, try to load "<file>.orig"
	//
	if(FAILED(hr = local_ReadWithRetry( strFile, stream, dwTimeout, dwRetries )))
	{
		MPC::wstring strFileOrig( strFile ); strFileOrig += L".orig";

		__MPC_EXIT_IF_METHOD_FAILS(hr, local_ReadWithRetry( strFileOrig, stream, dwTimeout, dwRetries ));
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT SVC::SafeSave_Init( /*[in]*/ const MPC::wstring& 	   strFile   ,
							/*[in]*/ CComPtr<MPC::FileStream>& stream    ,
							/*[in]*/ DWORD                     dwTimeout ,
							/*[in]*/ DWORD                     dwRetries )
{
	__HCP_FUNC_ENTRY( "SVC::SafeSave_Init" );

	HRESULT      hr;
	MPC::wstring strFileNew( strFile ); strFileNew += L".new";

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir        (  strFileNew ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance ( &stream     ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, local_WriteWithRetry( strFileNew, stream, dwTimeout, dwRetries ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT SVC::SafeSave_Finalize( /*[in]*/ const MPC::wstring&  	   strFile   ,
								/*[in]*/ CComPtr<MPC::FileStream>& stream    ,
								/*[in]*/ DWORD                     dwTimeout ,
								/*[in]*/ DWORD                     dwRetries )
{
	__HCP_FUNC_ENTRY( "SVC::SafeSave_Finalize" );

	HRESULT      hr;
	MPC::wstring strFileNew ( strFile ); strFileNew  += L".new";
	MPC::wstring strFileOrig( strFile ); strFileOrig += L".orig";


	stream.Release();

    //
    // Then move "<file>" to "<file>.orig"
    //
	(void)MPC::DeleteFile(          strFileOrig );
	(void)MPC::MoveFile  ( strFile, strFileOrig );

	while(1)
	{
		//
		// Then rename "<file>.new" to "<file>"
		//
		if(SUCCEEDED(hr = MPC::MoveFile( strFileNew, strFile ))) break;

		if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED    ) ||
		   hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) ||
		   hr == HRESULT_FROM_WIN32(ERROR_LOCK_VIOLATION   )  )
		{
			if(dwRetries)
			{
				::Sleep( dwTimeout );

				dwRetries--;
				continue;
			}
		}

		__MPC_FUNC_LEAVE;
	}

    //
    // Finally delete "<file>.orig"
    //
	(void)MPC::DeleteFile( strFileOrig );

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\common\service.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Service.cpp

Abstract:
    This file contains the implementation of IPCHService interface.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created
    Kalyani Narlanka    (Kalyanin)  10/20/2000
        Added functionality for Unsolicited Remote Control

******************************************************************************/

#include "stdafx.h"

#include <KeysLib.h>
#include <wtsapi32.h>
#include <winsta.h>
#include <unsolicitedRC.h>

#include "sessmgr_i.c"
#include <sessmgr.h>

#include "rassistance.h"
#include "rassistance_i.c"

/////////////////////////////////////////////////////////////////////////////

static const WCHAR s_location_HELPCTR [] = HC_ROOT_HELPSVC_BINARIES L"\\HelpCtr.exe";
static const WCHAR s_location_HELPSVC [] = HC_ROOT_HELPSVC_BINARIES L"\\HelpSvc.exe";
static const WCHAR s_location_HELPHOST[] = HC_ROOT_HELPSVC_BINARIES L"\\HelpHost.exe";

static const LPCWSTR s_include_Generic[] =
{
    s_location_HELPCTR ,
    s_location_HELPSVC ,
    s_location_HELPHOST,
    NULL
};

static const LPCWSTR s_include_RegisterHost[] =
{
    s_location_HELPHOST,
    NULL
};

static const WCHAR c_szUnsolicitedRA   [] = L"Software\\Policies\\Microsoft\\Windows NT\\Terminal Services";
static const WCHAR c_szUnsolicitedRA_SD[] = L"UnsolicitedAccessDACL";
static const WCHAR c_szUnsolicitedListKey[]= L"RAUnsolicit";
static const WCHAR c_szUnsolicitedNew_SD [] = L"UnsolicitedAccessNewDACL";

static HRESULT local_MakeDACL( MPC::WStringList& sColl, LPWSTR& pwszSD );
static HRESULT local_GetDACLValue( MPC::wstring& pSD, bool& fFound);

/////////////////////////////////////////////////////////////////////////////

CPCHService::CPCHService()
{
    __HCP_FUNC_ENTRY( "CPCHService::CPCHService" );

    m_fVerified = false; // bool m_fVerified;
}

CPCHService::~CPCHService()
{
    __HCP_FUNC_ENTRY( "CPCHService::~CPCHService" );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHService::get_RemoteSKUs( /*[out, retval]*/ IPCHCollection* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHService::get_RemoteSKUs" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Return a list with only the exported SKUs.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHTaxonomyDatabase::SelectInstalledSKUs( true, pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHService::IsTrusted( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ VARIANT_BOOL *pfTrusted )
{
    __HCP_FUNC_ENTRY( "CPCHService::IsTrusted" );

    HRESULT hr;
    bool    fTrusted;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
        __MPC_PARAMCHECK_POINTER_AND_SET(pfTrusted,VARIANT_FALSE);
        __MPC_PARAMCHECK_NOTNULL(CPCHContentStore::s_GLOBAL);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHContentStore::s_GLOBAL->IsTrusted( bstrURL, fTrusted ));

    if(fTrusted) *pfTrusted = VARIANT_TRUE;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHService::Utility( /*[in ]*/ BSTR          bstrSKU ,
                                   /*[in ]*/ long          lLCID   ,
                                   /*[out]*/ IPCHUtility* *pVal    )
{
    __HCP_FUNC_ENTRY( "CPCHService::Utility" );

    HRESULT              hr;
    CComPtr<CPCHUtility> svc;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Verify the caller is a trusted one.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::VerifyCallerIsTrusted( s_include_Generic ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &svc ));

    if(bstrSKU || lLCID)
    {
        CComPtr<IPCHUserSettings> pchus;

        __MPC_EXIT_IF_METHOD_FAILS(hr, svc->get_UserSettings( &pchus ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pchus->Select( bstrSKU, lLCID ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, svc.QueryInterface( pVal ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHService::RemoteHelpContents( /*[in ]*/ BSTR                     bstrSKU ,
                                              /*[in ]*/ long                     lLCID   ,
                                              /*[out]*/ IPCHRemoteHelpContents* *pVal    )
{
    __HCP_FUNC_ENTRY( "CPCHService::RemoteHelpContents" );

    HRESULT                         hr;
    CComPtr<CPCHRemoteHelpContents> rhc;
    Taxonomy::HelpSet               ths;
    Taxonomy::LockingHandle         handle;
    Taxonomy::InstalledInstanceIter it;
    bool                            fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
        __MPC_PARAMCHECK_NOTNULL(Taxonomy::InstalledInstanceStore::s_GLOBAL);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, ths.Initialize( bstrSKU, lLCID ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle          ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( ths, fFound, it ));
    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &rhc ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, rhc->Init( it->m_inst ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, rhc.QueryInterface( pVal ));
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHService::RegisterHost( /*[in]*/ BSTR bstrID, /*[in]*/ IUnknown* pUnk )
{
    __HCP_FUNC_ENTRY( "CPCHService::RegisterHost" );

    HRESULT                     hr;
    CComQIPtr<IPCHSlaveProcess> pObj = pUnk;


    if(pObj == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);


    //
    // Verify the caller is really HelpHost.exe.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::VerifyCallerIsTrusted( s_include_RegisterHost ));


    hr = CPCHUserProcess::s_GLOBAL ? CPCHUserProcess::s_GLOBAL->RegisterHost( bstrID, pObj ) : E_FAIL;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHService::CreateScriptWrapper( /*[in ]*/ REFCLSID   rclsid   ,
                                               /*[in ]*/ BSTR       bstrCode ,
                                               /*[in ]*/ BSTR       bstrURL  ,
                                               /*[out]*/ IUnknown* *ppObj    )
{
    __HCP_FUNC_ENTRY( "CPCHService::CreateScriptWrapper" );

    HRESULT                                  hr;
    CComBSTR                                 bstrRealCode;
    CPCHScriptWrapper_ServerSide::HeaderList lst;
    CPCHScriptWrapper_ServerSide::HeaderIter it;
    CPCHUserProcess::UserEntry               ue;
    CComPtr<IPCHSlaveProcess>                sp;
    MPC::wstring                             strVendorID;
    MPC::wstring                             strSignature;


    if(bstrURL                    == NULL ||
	   CPCHContentStore::s_GLOBAL == NULL ||
	   CSAFReg         ::s_GLOBAL == NULL ||
	   CPCHUserProcess ::s_GLOBAL == NULL  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHScriptWrapper_ServerSide::ProcessBody( bstrCode, bstrRealCode, lst ));

    //
    // Look for the vendor ID.
    //
    it = std::find( lst.begin(), lst.end(), L"VENDORID" );
    if(it == lst.end())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
    }
    strVendorID = it->m_strValue;

    //
    // Make sure the VendorID declared in the script matches the one which has registered the URL as trusted.
    //
    {
        bool         fTrusted;
        MPC::wstring strVendorURL;

        __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHContentStore::s_GLOBAL->IsTrusted( bstrURL, fTrusted, &strVendorURL ));

        if(MPC::StrICmp( strVendorID, strVendorURL ))
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }
    }


    //
    // Look for the script signature.
    //
    it = std::find( lst.begin(), lst.end(), L"SIGNATURE" );
    if(it == lst.end())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
    }
    strSignature = it->m_strValue;

    //
    // Lookup the vendor in the SAF store (this also prepares the creation of the user process).
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg::s_GLOBAL->LookupAccountData( CComBSTR( strVendorID.c_str() ), ue ));

    //
    // Verify signature.
    //
    {
        CPCHCryptKeys key;

        __MPC_EXIT_IF_METHOD_FAILS(hr, key.ImportPublic( ue.GetPublicKey() ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, key.VerifyData( strSignature.c_str(), (BYTE*)(BSTR)bstrRealCode, ::SysStringLen( bstrRealCode ) * sizeof(WCHAR) ));
    }

    //
    // Create the vendor's process.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp ));

    //
    // Forward request.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, sp->CreateScriptWrapper( rclsid, bstrCode, bstrURL, ppObj ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHService::TriggerScheduledDataCollection( /*[in]*/ VARIANT_BOOL fStart )
{
    return CPCHSystemMonitor::s_GLOBAL ? CPCHSystemMonitor::s_GLOBAL->TriggerDataCollection( fStart == VARIANT_TRUE ) : E_FAIL;
}

STDMETHODIMP CPCHService::PrepareForShutdown()
{
    __HCP_FUNC_ENTRY( "CPCHService::PrepareForShutdown" );

    _Module.ForceShutdown();

    __HCP_FUNC_EXIT(S_OK);
}

////////////////////

STDMETHODIMP CPCHService::ForceSystemRestore()
{
    __HCP_FUNC_ENTRY( "CPCHService::ForceSystemRestore" );

	HRESULT                       hr;
    CComObject<HCUpdate::Engine>* hc = NULL;
	

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::VerifyCallerIsTrusted( s_include_Generic ));



    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, hc->ForceSystemRestore());

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

    if(hc) hc->Release();

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHService::UpgradeDetected()
{
    __HCP_FUNC_ENTRY( "CPCHService::UpgradeDetected" );

	HRESULT hr;
	
	//
	// Allow only ADMINS.
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL, MPC::IDENTITY_ADMINS ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHService::MUI_Install( /*[in]*/ long LCID, /*[in]*/ BSTR bstrFile )
{
    __HCP_FUNC_ENTRY( "CPCHService::MUI_Install" );

	HRESULT hr;
	
	//
	// Allow only ADMINS.
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL, MPC::IDENTITY_ADMINS ));

	////////////////////////////////////////

    {
		Installer::Package 	         pkg;
		CComPtr<CPCHSetOfHelpTopics> sht;
		MPC::wstring                 strFile;

		//
		// Because of a possible problem with the INF, it could be that the filename has an extra "%LCID%" in it, instead of the straight %LCID%.
		//
		{
			WCHAR  					rgBufBad[64]; swprintf( rgBufBad, L"\"%04x\"", LCID );
			WCHAR  					rgBufOk [64]; swprintf( rgBufOk , L"%04x"    , LCID );
			MPC::wstring::size_type pos;
			MPC::wstring::size_type len = wcslen( rgBufBad );

			strFile = SAFEBSTR(bstrFile);

			while((pos = strFile.find( rgBufBad )) != strFile.npos)
			{
				strFile.replace( pos, len, rgBufOk );
			}
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &sht ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( strFile.c_str() ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Load(                 ));

		{
			Taxonomy::InstanceBase& base = pkg.GetData();

			if(_wcsicmp( base.m_ths.GetSKU()      ,  Taxonomy::HelpSet::GetMachineSKU() )    ||
			             base.m_ths.GetLanguage() !=                    LCID                 ||
			             LCID                     == Taxonomy::HelpSet::GetMachineLanguage()  ) // Don't overwrite system SKU!!
			{
				__MPC_SET_ERROR_AND_EXIT(hr, S_FALSE); // Mismatch in parameter, ignore it.
			}
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, sht->DirectInstall( pkg, /*fSetup*/false, /*fSystem*/false, /*fMUI*/true ));
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHService::MUI_Uninstall( /*[in]*/ long LCID )
{
    __HCP_FUNC_ENTRY( "CPCHService::MUI_Uninstall" );

	HRESULT hr;

	//
	// Allow only ADMINS.
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL, MPC::IDENTITY_ADMINS ));

	////////////////////////////////////////


    {
		Installer::Package 	         pkg;
		CComPtr<CPCHSetOfHelpTopics> sht;
		Taxonomy::HelpSet            ths;

		__MPC_EXIT_IF_METHOD_FAILS(hr, ths.Initialize( Taxonomy::HelpSet::GetMachineSKU(), LCID ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &sht ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, sht->DirectUninstall( &ths ));
    }


	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////

static void local_PackString( /*[in/out]*/ CComBSTR& bstr     ,
							  /*[in    ]*/ LPCWSTR   szAppend )
{
    WCHAR rgLen[64];

	SANITIZEWSTR( szAppend );

	swprintf( rgLen, L"%d;", wcslen( szAppend ) );
	
	bstr.Append( rgLen    );
	bstr.Append( szAppend );
}

static HRESULT local_MakeDACL( MPC::WStringList& sColl, LPWSTR& pwszSD )
{
    __HCP_FUNC_ENTRY( "local_MakeDACL" );

    SID_IDENTIFIER_AUTHORITY    siaNT = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR         sd;
    SID_NAME_USE                snu;
    WCHAR                       *pwszDomain = NULL, *pwszUser = NULL;
    WCHAR                       wszDom[1024];
    DWORD                       cbNeedACL, cbNeed, cchDom, dwCount;
    DWORD                       cchSD;
    PACL                        pacl = NULL;
    PSID                        *rgsid = NULL, psidAdm = NULL;
    BOOL                        fRet = FALSE;
    int                         i, cSIDs = 0;
    long                        lCount;
    HRESULT                     hr;
    MPC::WStringIter            it;

    lCount = sColl.size();

    if (lCount == 0)
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);

    rgsid = (PSID *) malloc (lCount * sizeof(PSID));
    if (rgsid == NULL)
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);

    if (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, 
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 
                                  0, &psidAdm))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }

    cbNeedACL = sizeof(ACL);
    for(it = sColl.begin(); it != sColl.end(); it++)
    {
        LPCWSTR bstrVal = it->c_str();
        cchDom = sizeof(wszDom)/sizeof(WCHAR);
        cbNeed = 0;
        fRet = LookupAccountNameW(NULL, bstrVal, NULL, &cbNeed, wszDom, &cchDom, 
                                  &snu);

        rgsid[cSIDs] = (PSID) malloc (cbNeed);
        if (rgsid[cSIDs] == NULL)
            __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);

        cchDom = sizeof(wszDom)/sizeof(WCHAR);
        fRet = LookupAccountNameW(NULL, bstrVal, rgsid[cSIDs], &cbNeed, 
                                  wszDom, &cchDom, &snu);
        if (fRet == FALSE)
        {
            // invalid user name;
            free (rgsid[cSIDs]);
            rgsid[cSIDs] = NULL;
            continue;
        }

        cbNeedACL += GetLengthSid(rgsid[cSIDs]);
        cbNeedACL += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));
        cSIDs++;
    }

    if (cbNeedACL == sizeof(ACL)) // No valid entry
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    pacl = (PACL) malloc (cbNeedACL);
    if (pacl == NULL)
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);

    fRet = InitializeAcl(pacl, cbNeedACL, ACL_REVISION);
    if (fRet == FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }

    for(i = 0; i < cSIDs; i++)
    {
        fRet = AddAccessAllowedAce(pacl, ACL_REVISION, 
                                   GENERIC_ALL | 
                                   STANDARD_RIGHTS_ALL |
                                   SPECIFIC_RIGHTS_ALL, rgsid[i]);
        if (fRet == FALSE)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    if (InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) == FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }
    
    // set the SD dacl
    if (SetSecurityDescriptorDacl(&sd, TRUE, pacl, FALSE) == FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }

    // set the SD owner
    if (SetSecurityDescriptorOwner(&sd, psidAdm, FALSE) == FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }

    // set the SD group
    if (SetSecurityDescriptorGroup(&sd, psidAdm, FALSE) == FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }
    
	// Verify if the SD is valid
    if (IsValidSecurityDescriptor(&sd) == FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }

    if (FALSE == ConvertSecurityDescriptorToStringSecurityDescriptorW(&sd, SDDL_REVISION_1, 
                                                                      GROUP_SECURITY_INFORMATION | 
                                                                      OWNER_SECURITY_INFORMATION |
                                                                      DACL_SECURITY_INFORMATION, 
                                                                      &pwszSD, &cchSD))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(GetLastError()));
    }

    __MPC_FUNC_CLEANUP;

    if (rgsid != NULL)
    {
        for(i = 0; i < cSIDs; i++)
        {
            if (rgsid[i] != NULL)
                free(rgsid[i]);
        }

        free(rgsid);
    }

    if (pacl != NULL)
        free(pacl);
    if (psidAdm != NULL)
        FreeSid(psidAdm);

    __MPC_FUNC_EXIT(hr);
}

static HRESULT local_GetDACLValue(MPC::wstring& pSD, bool& fFound)
{
    __HCP_FUNC_ENTRY( "local_GetDACLValue" );
    
    HRESULT hr;
    CRegKey cKey, cKeyDACL;
    LONG lRet;
    DWORD dwCount;
    LPWSTR pwBuf = NULL;

    if (ERROR_SUCCESS != cKey.Open(HKEY_LOCAL_MACHINE, c_szUnsolicitedRA))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    // Check to see if new DACL value exist
    dwCount = 0;
    if (ERROR_SUCCESS == cKey.QueryValue(NULL, c_szUnsolicitedNew_SD, &dwCount))
    {
        if (NULL == (pwBuf = (LPWSTR)malloc(dwCount)))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
        }

        if (ERROR_SUCCESS != (lRet = cKey.QueryValue(pwBuf, c_szUnsolicitedNew_SD, &dwCount)))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(lRet));
        }

        pSD = pwBuf;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    // If we don't have DACL value, then we need to check DACL regkey list.
    if ( ERROR_SUCCESS != cKeyDACL.Open((HKEY)cKey, c_szUnsolicitedListKey))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    // 1. Do we have default value
    dwCount = 0;
    if ( ERROR_SUCCESS == cKeyDACL.QueryValue(NULL, NULL, &dwCount) && dwCount > sizeof(WCHAR)) // It's possible it contains '\0' 
    {
        if (pwBuf) free(pwBuf);
        if (NULL == (pwBuf = (LPWSTR)malloc(dwCount)))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
        }

        if ( ERROR_SUCCESS != (lRet = cKeyDACL.QueryValue(pwBuf, NULL, &dwCount)))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(lRet));
        }
            
        pSD = pwBuf;
    }
    else // Need to calculate DACL
    {
        DWORD dwIndex = 0;
        DWORD dwType;
        WCHAR szName[257];
        dwCount = 256;
        MPC::WStringList sColl;
        long lCount;

        while (ERROR_SUCCESS == RegEnumValueW((HKEY)cKeyDACL,
                                              dwIndex,
                                              &szName[0],
                                              &dwCount,
                                              NULL,
                                              &dwType,
                                              NULL, // no need to get it's data
                                              NULL))
        {
            if ((dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ) && szName[0] != L'\0')
            {
                sColl.push_back( MPC::wstring(szName) );
            }
            
            szName [0] = L'\0';
            dwIndex ++;
            dwCount = 256;
        }
        
        if (sColl.size() > 0)
        {
            LPWSTR pwDACL = NULL;
            __MPC_EXIT_IF_METHOD_FAILS(hr, local_MakeDACL( sColl, pwDACL ));
            
            // Update default value
            if (pwDACL)
            {
                pSD = pwDACL;
                cKeyDACL.SetValue(pwDACL);
                LocalFree(pwDACL);
            }
        }
        else
            __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if (pwBuf)
    {
        free(pwBuf);
    }

    fFound = (hr == S_OK);

    __MPC_FUNC_EXIT(hr);
}

static HRESULT local_CheckAccessRights()
{
	__HCP_FUNC_ENTRY( "local_CheckAccessRights" );

	HRESULT                 hr;
	bool                    fPermit = false;
    CComPtr<IRARegSetting>  pRARegSetting;
    BOOL                    fAllowUnsolicited;

	//
    // Check the policy settings to see whether Unsolicited RA is allowed, if not give an Access Denied error.
    // Create an instance of IRARegSetting.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pRARegSetting.CoCreateInstance( CLSID_RARegSetting, NULL, CLSCTX_INPROC_SERVER ));

    // Call get_AllowUnSolicited() Method of IRARegSetting.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pRARegSetting->get_AllowUnSolicited( &fAllowUnsolicited ));
    if(!fAllowUnsolicited)
	{
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DISABLED_BY_POLICY);
	}

    // Allow someone from ADMINS to query for this data.
    if(SUCCEEDED(MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL,  MPC::IDENTITY_ADMINS )))
    {
        fPermit = true;
    }
    else // If not from ADMINS, check the caller against the SD stored in the Registry in the String Format.
    {
		MPC::AccessCheck ac;
        MPC::wstring     strSD;
        bool         	 fFound;
        BOOL         	 fGranted  = FALSE;
        DWORD        	 dwGranted = 0;

        __MPC_EXIT_IF_METHOD_FAILS(hr, local_GetDACLValue( strSD, fFound));
        if(!fFound) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);


        // Use the SD to check against the Caller.
        __MPC_EXIT_IF_METHOD_FAILS(hr, ac.GetTokenFromImpersonation());
        if(SUCCEEDED(ac.Verify( ACCESS_READ, fGranted, dwGranted, strSD.c_str() )) && fGranted)
        {
            fPermit = true;
        }
    }

    if(!fPermit)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHService::RemoteConnectionParms( /*[in ]*/ BSTR  bstrUserName          ,
                                                 /*[in ]*/ BSTR  bstrDomainName        ,
                                                 /*[in ]*/ long  lSessionID            ,
                                                 /*[in ]*/ BSTR  bstrUserHelpBlob      ,
                                                 /*[out]*/ BSTR *pbstrConnectionString )
{
    __HCP_FUNC_ENTRY( "CPCHService::RemoteConnectionParms" );

    HRESULT                               hr;
    CComPtr<IRemoteDesktopHelpSessionMgr> pRDHelpSessionMgr;
    MPC::wstring                          strSID;
    CComBSTR                              bstrString1;
    CComBSTR                              bstrString2;
    CComBSTR                              bstrExpert;
    PSID                                  pExpertSid         = NULL;
    LPCWSTR                               szExpertUserName   = NULL;
    LPCWSTR                               szExpertDomainName = NULL;
	BOOL                                  fRevertSucceeded;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pbstrConnectionString,NULL);
    __MPC_PARAMCHECK_END();

	// Fix for bug 367683
	// If Unsolicited RA is done from one session to another on the same machine,
	// we need to RevertToSelf() before we do anything, this is because on the Expert end we do
	// an impersonation before calling this method.  While this is correct when the expert 
	// and novice are on two different machines, in case of a single machine, by the time the 
	// novice side code is called there is an extra impersonation, which should not be there
	// we need to undo this by doing RevertToSelf()

	fRevertSucceeded = RevertToSelf();

	__MPC_EXIT_IF_METHOD_FAILS(hr, local_CheckAccessRights());


    // Create an instance of IRemoteDesktopHelpSessionMgr in order to call its method RemoteCreateHelpSession.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pRDHelpSessionMgr.CoCreateInstance( CLSID_RemoteDesktopHelpSessionMgr, NULL, CLSCTX_LOCAL_SERVER ));
	
	
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoSetProxyBlanket( pRDHelpSessionMgr           ,
                                                        RPC_C_AUTHN_DEFAULT         ,
                                                        RPC_C_AUTHZ_DEFAULT         ,
                                                        NULL                        ,
                                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY/*RPC_C_AUTHN_LEVEL_DEFAULT */,
                                                        RPC_C_IMP_LEVEL_IMPERSONATE ,
                                                        NULL                        ,
                                                        EOAC_NONE                   ));

	//
    // Get the SID corresponding to the UserName and DomainName
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::NormalizePrincipalToStringSID( bstrUserName, bstrDomainName, strSID ));
	
	//
    // Get the Expert SID and then get the username and domain name corresponding to the SID.
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetCallerPrincipal                       ( /*fImpersonate*/true, bstrExpert                                                     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::ConvertPrincipalToSID( 						 bstrExpert, pExpertSid                                         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::ConvertSIDToPrincipal( 									 pExpertSid, &szExpertUserName, &szExpertDomainName ));

    // Update the user Help Blob before invoking the RemoteCreateHelpSession()
    // The UserHelpBlob should have the following format.
    // Updated UserHelpBlob = string1 + string2 + original UserHelpBlob.
    // string1 = "13;UNSOLICITED=1"
    // string2 = #ofchars in expert identity;ID=expertDomainName\expertName
	
	local_PackString( bstrString1, L"UNSOLICITED=1" );

    bstrString2 =       L"ID=";
    bstrString2.Append( szExpertDomainName );
    bstrString2.Append( L"\\"              );
    bstrString2.Append( szExpertUserName   );
	local_PackString( bstrString1, bstrString2 );

    bstrString1.Append( bstrUserHelpBlob );
	
	
    //Use Salem API to get the Connection Parameters.
    {
        // Fix for Bug 252092.
        static const REMOTE_DESKTOP_SHARING_CLASS c_sharingClass = VIEWDESKTOP_PERMISSION_NOT_REQUIRE;
        static const LONG                         c_lTimeOut     = 301; // 5 mins. Timeout after which resolver kills helpctr if 
		                                                                // no response from user (300 seconds)

	
        CComBSTR bstrSID( strSID.c_str() );
	
        __MPC_EXIT_IF_METHOD_FAILS(hr, pRDHelpSessionMgr->RemoteCreateHelpSession( c_sharingClass, c_lTimeOut, lSessionID, bstrSID, bstrString1, pbstrConnectionString ));
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    MPC::SecurityDescriptor::ReleaseMemory( (void*&)pExpertSid         );
    MPC::SecurityDescriptor::ReleaseMemory( (void*&)szExpertUserName   );
    MPC::SecurityDescriptor::ReleaseMemory( (void*&)szExpertDomainName );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHService::RemoteUserSessionInfo( /*[out]*/ IPCHCollection* *ppSessions )
{
    __HCP_FUNC_ENTRY( "CPCHService::RemoteUserSessionInfo" );

    HRESULT                 hr;
    CComPtr<CPCHCollection> pColl;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppSessions,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, local_CheckAccessRights());

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

	// Transfer the SessionInfoTable to the IPCHCollection.
	__MPC_EXIT_IF_METHOD_FAILS(hr, CSAFRemoteConnectionData::Populate( pColl ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppSessions ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CPCHRemoteHelpContents::CPCHRemoteHelpContents()
{
                 // Taxonomy::Instance     m_data;
                 // Taxonomy::Settings     m_ts;
                 // MPC::wstring           m_strDir;
                 //						   
                 // Taxonomy::Updater      m_updater;
                 // JetBlue::SessionHandle m_handle;
    m_db = NULL; // JetBlue::Database*     m_db;
}

CPCHRemoteHelpContents::~CPCHRemoteHelpContents()
{
    DetachFromDatabase();
}

HRESULT CPCHRemoteHelpContents::AttachToDatabase()
{
    __HCP_FUNC_ENTRY( "CPCHRemoteHelpContents::AttachToDatabase" );

    HRESULT hr;


    if(m_db == NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.GetDatabase( m_handle, m_db, /*fReadOnly*/true ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.Init( m_ts, m_db ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHRemoteHelpContents::DetachFromDatabase()
{
    (void)m_updater.Close();

    m_handle.Release();
    m_db = NULL;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHRemoteHelpContents::Init( /*[in]*/ const Taxonomy::Instance& data )
{
    __HCP_FUNC_ENTRY( "CPCHRemoteHelpContents::Init" );

    HRESULT hr;


    m_data = data;
    m_ts   = data.m_ths;

    m_strDir = m_data.m_strHelpFiles; m_strDir += L"\\";
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( m_strDir ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHRemoteHelpContents::get_SKU( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHRemoteHelpContents::get_SKU",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_data.m_ths.GetSKU(), pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHRemoteHelpContents::get_Language( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHRemoteHelpContents::get_Language",hr,pVal,m_data.m_ths.GetLanguage());

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHRemoteHelpContents::get_ListOfFiles( /*[out, retval]*/ VARIANT *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHRemoteHelpContents::get_ListOfFiles" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    MPC::WStringList             lstFiles;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pVal);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, AttachToDatabase());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ListAllTheHelpFiles( lstFiles ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertListToSafeArray( lstFiles, *pVal, VT_BSTR ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    DetachFromDatabase();

    __HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHRemoteHelpContents::GetDatabase( /*[out, retval]*/ IUnknown* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHRemoteHelpContents::GetDatabase" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComPtr<IStream>             stream;
	MPC::wstring                 strDataArchive;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	{
		Taxonomy::LockingHandle         handle;
		Taxonomy::InstalledInstanceIter it;
		bool                   			fFound;

		__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle           ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_ts, fFound, it ));
		if(!fFound)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
		}
		
		__MPC_EXIT_IF_METHOD_FAILS(hr, it->m_inst.GetFileName( strDataArchive ));
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForRead( strDataArchive.c_str(), &stream ));

    *pVal = stream.Detach();
    hr    = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHRemoteHelpContents::GetFile( /*[in]*/ BSTR bstrFileName, /*[out, retval]*/ IUnknown* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHRemoteHelpContents::GetFile" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    MPC::wstring                 strHelpFile;
    CComPtr<IStream>             stream;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFileName);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    //
    // .. not allowed, for security reasons.
    //
    if(wcsstr( bstrFileName, L".." ))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }


    strHelpFile  = m_strDir;
    strHelpFile += bstrFileName;

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForRead( strHelpFile.c_str(), &stream ));

    *pVal = stream.Detach();
    hr    = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\core\setup.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    setup.cpp

Abstract:
    This file contains the code responsible for the install/uninstall of the
    Help system.

Revision History:
    Davide Massarenti   (Dmassare)  04/19/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <unattend.h>

#include <aclapi.h>

#include <initguid.h>
#include <mstask.h> // for task scheduler apis
#include <msterr.h>

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_szMessageFile      [] = HC_ROOT_HELPSVC_BINARIES L"\\HCAppRes.dll";

static const WCHAR c_szRegistryLog      [] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\HelpSvc";
static const WCHAR c_szRegistryLog_File [] = L"EventMessageFile";
static const WCHAR c_szRegistryLog_Flags[] = L"TypesSupported";

static const DWORD SETUP_LOCALIZATION_STRINGS = 0x00000001;
static const DWORD SETUP_MESSAGE_FILE         = 0x00000002;
static const DWORD SETUP_CREATE_GROUP         = 0x00000004;
static const DWORD SETUP_OEMINFO              = 0x00000008;
static const DWORD SETUP_SKU_INSTALL          = 0x00000010;

static const MPC::StringToBitField c_Setup[] =
{
    { L"LOCALIZATION_STRINGS", SETUP_LOCALIZATION_STRINGS, SETUP_LOCALIZATION_STRINGS, -1 },
    { L"MESSAGE_FILE"        , SETUP_MESSAGE_FILE        , SETUP_MESSAGE_FILE        , -1 },
    { L"CREATE_GROUP"        , SETUP_CREATE_GROUP        , SETUP_CREATE_GROUP        , -1 },
    { L"OEMINFO"             , SETUP_OEMINFO             , SETUP_OEMINFO             , -1 },
    { L"SKU_INSTALL"         , SETUP_SKU_INSTALL         , SETUP_SKU_INSTALL         , -1 },

    { NULL                                                                                }
};

////////////////////////////////////////////////////////////////////////////////

static HRESULT DumpSD( /*[in]*/ LPCWSTR                       szFile ,
                       /*[in]*/ CPCHSecurityDescriptorDirect& sdd    )
{
    __MPC_FUNC_ENTRY( COMMONID, "DumpSD" );

    HRESULT                         hr;
    CComPtr<CPCHSecurityDescriptor> pNew;
    CComPtr<IStream>                pStreamIn;
    CComPtr<IStream>                pStreamOut;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDToCOM( pNew ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pNew->SaveXMLAsStream  (         (IUnknown**)&pStreamIn  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( szFile,             &pStreamOut ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( pStreamIn, pStreamOut ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static void local_RemoveRegistryBackup()
{
	MPC::RegKey rkBase;

	if(SUCCEEDED(rkBase.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS )) &&
	   SUCCEEDED(rkBase.Attach ( HC_REGISTRY_HELPSVC L"\\Backup"    ))  )
	{
		(void)rkBase.Delete( /*fDeep*/true );
	}
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Local_Install()
{
    __HCP_FUNC_ENTRY( "Local_Install" );

    HRESULT      hr;
	MPC::wstring strGroupName;
	MPC::wstring strGroupComment;
	DWORD        dwStatus = SETUP_LOCALIZATION_STRINGS |
		                    SETUP_MESSAGE_FILE         |
		                    SETUP_CREATE_GROUP         |
		                    SETUP_OEMINFO              |
		                    SETUP_SKU_INSTALL;


	if(SUCCEEDED(MPC::LocalizeString( IDS_HELPSVC_GROUPNAME   , strGroupName    )) &&
	   SUCCEEDED(MPC::LocalizeString( IDS_HELPSVC_GROUPCOMMENT, strGroupComment ))  )
	{
		dwStatus &= ~SETUP_LOCALIZATION_STRINGS;
	}

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Register the message file into the registry.
    //
    {
        MPC::wstring strPath ( c_szMessageFile ); MPC::SubstituteEnvVariables( strPath );
        MPC::RegKey  rkEventLog;
        CComVariant  vValue;


		if(SUCCEEDED(rkEventLog.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS )) &&
		   SUCCEEDED(rkEventLog.Attach ( c_szRegistryLog                    )) &&
		   SUCCEEDED(rkEventLog.Create (                                    ))  )
		{
			if(SUCCEEDED(rkEventLog.put_Value( (vValue = strPath.c_str()), c_szRegistryLog_File  )) &&
			   SUCCEEDED(rkEventLog.put_Value( (vValue = (long)0x1F     ), c_szRegistryLog_Flags ))  )
			{
				dwStatus &= ~SETUP_MESSAGE_FILE;
			}
		}
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Remove old WinME directory and registry keys.
    //
    {
        MPC::RegKey rkRun;

        (void)SVC::RemoveAndRecreateDirectory( HC_ROOT L"\\Support", NULL, /*fRemove*/true, /*fRecreate*/false );

        if(SUCCEEDED(rkRun.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS                             )) &&
           SUCCEEDED(rkRun.Attach ( L"Software\\Microsoft\\Windows\\CurrentVersion\\Run\\PCHealth" ))  )
        {
            (void)rkRun.Delete( true );
        }
    }

	//
	// Remove old task scheduler entry.
	//
	{
		CComBSTR bstrTaskName;
	
		if(SUCCEEDED(MPC::LocalizeString( IDS_HELPSVC_TASKNAME, bstrTaskName )))
		{
			CComPtr<ITaskScheduler> pTaskScheduler;
		
			if(SUCCEEDED(::CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskScheduler, (void**)&pTaskScheduler )))
			{
				(void)pTaskScheduler->Delete( bstrTaskName );
			}
		}
	}

    ////////////////////////////////////////////////////////////////////////////////

	try
	{
		::PCHealthUnAttendedSetup();
	}
	catch(...)
	{
	}

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Create our group: "HelpServicesGroup".
    //
    {
        CPCHAccounts acc;

		if(SUCCEEDED(acc.CreateGroup( strGroupName.c_str(), strGroupComment.c_str() )))
		{
			dwStatus &= ~SETUP_CREATE_GROUP;
		}
    }

    ////////////////////////////////////////////////////////////////////////////////

	//
	// Extract OEM info from oeminfo.ini
	//
	{
        MPC::RegKey rk;

		if(SUCCEEDED(rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS )) &&
		   SUCCEEDED(rk.Attach ( HC_REGISTRY_HELPSVC L"\\OEMInfo"   )) &&
		   SUCCEEDED(rk.Delete ( /*fDeep*/true                      )) &&
		   SUCCEEDED(rk.Create (                                    ))  )
		{
			WCHAR        rgLine[512];
			MPC::wstring strOEMInfo( L"%WINDIR%\\system32\\oeminfo.ini" ); MPC::SubstituteEnvVariables( strOEMInfo );
			MPC::wstring strOEMText;
			CComVariant  vValue;
			int          i;

			if(::GetPrivateProfileStringW( L"General", L"Manufacturer", L"", rgLine, MAXSTRLEN(rgLine), strOEMInfo.c_str() ) > 0)
			{
				vValue = rgLine; rk.put_Value( vValue, L"Manufacturer" );
			}

			if(::GetPrivateProfileStringW( L"General", L"Model", L"", rgLine, MAXSTRLEN(rgLine), strOEMInfo.c_str() ) > 0)
			{
				vValue = rgLine; rk.put_Value( vValue, L"Model" );
			}

			for(i=1;;i++)
			{
				WCHAR rgKey[64]; swprintf( rgKey, L"Line%d", i );

				::GetPrivateProfileStringW( L"Support Information", rgKey, L"<eof>", rgLine, MAXSTRLEN(rgLine), strOEMInfo.c_str() );
				if(!wcscmp( rgLine, L"<eof>" )) break;

				if(strOEMText.size()) strOEMText += L"#BR#";

				strOEMText += rgLine;
			}

			if(strOEMText.size())
			{
				vValue = strOEMText.c_str(); rk.put_Value( vValue, L"Text" );
			}

			dwStatus &= ~SETUP_OEMINFO;
		}
	}

    ////////////////////////////////////////////////////////////////////////////////

	local_RemoveRegistryBackup();

    //
    // Extract all the data files.
    //
    {
        MPC::wstring strCabinet;

		//
		// Find the best fit.
		//
		do
		{
			OSVERSIONINFOEXW ver;
			MPC::WStringList lst;
			MPC::WStringIter it;

			::ZeroMemory( &ver, sizeof(ver) ); ver.dwOSVersionInfoSize = sizeof(ver);

			::GetVersionExW( (LPOSVERSIONINFOW)&ver );

			if(FAILED(SVC::LocateDataArchive( HC_ROOT_HELPSVC_BINARIES, lst ))) break;
			if(lst.size() == 0) break;

			for(it = lst.begin(); it != lst.end(); it++)
			{
				Installer::Package pkg;

				if(SUCCEEDED(pkg.Init( it->c_str() )) &&
				   SUCCEEDED(pkg.Load(             ))  )
				{
					LPCWSTR szSKU = pkg.GetData().m_ths.GetSKU();

					if(ver.wProductType == VER_NT_WORKSTATION)
					{
						if(ver.wSuiteMask & VER_SUITE_PERSONAL)
						{
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_PERSONAL )) break;
						}
						else
						{
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_PROFESSIONAL )) break;
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_64_PROFESSIONAL )) break;
						}
					}
					else
					{
						if(ver.wSuiteMask & VER_SUITE_DATACENTER)
						{
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_DATACENTER )) break;
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_64_DATACENTER )) break;
						}
						else if(ver.wSuiteMask & VER_SUITE_ENTERPRISE)
						{
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_ADVANCED_SERVER )) break;
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_64_ADVANCED_SERVER )) break;
						}
						else
						{
							if(!MPC::StrICmp( szSKU, Taxonomy::s_szSKU_32_SERVER )) break;
						}
					}
				}
			}

			strCabinet = *(it == lst.end() ? lst.begin() : it);
		}
		while(0);

		if(strCabinet.size())
		{
			Installer::Package pkg;
			
			if(SUCCEEDED(pkg.Init( strCabinet.c_str() )) &&
			   SUCCEEDED(pkg.Load(                    ))  )
			{
				CComPtr<CPCHSetOfHelpTopics> sht;

				if(SUCCEEDED(MPC::CreateInstance( &sht )))
				{
					if(SUCCEEDED(sht->DirectInstall( pkg, /*fSetup*/true, /*fSystem*/true, /*fMUI*/false )))
					{
						dwStatus &= ~SETUP_SKU_INSTALL;
					}
				}
			}
		}
    }


    ////////////////////////////////////////////////////////////////////////////////

	{
		MPC::wstring strText;
		CComVariant  v;

		if(dwStatus)
		{
			if(SUCCEEDED(MPC::ConvertBitFieldToString( dwStatus, strText, c_Setup )))
			{
				v = strText.c_str();
			}
			else
			{
				v = (long)dwStatus;
			}
		}

		(void)MPC::RegKey_Value_Write( v, HC_REGISTRY_HELPSVC, L"SetupProblems" );
	}

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT Local_Uninstall()
{
    __HCP_FUNC_ENTRY( "Local_Uninstall" );

    HRESULT      hr;
	MPC::wstring strGroupName;

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_GROUPNAME, strGroupName ));

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Register the message file into the registry.
    //
    {
        MPC::RegKey rkEventLog;

		if(SUCCEEDED(rkEventLog.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS )) &&
		   SUCCEEDED(rkEventLog.Attach ( c_szRegistryLog                    ))  )
		{
			(void)rkEventLog.Delete( /*fDeep*/true );
		}
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Create our group: "HelpServicesGroup".
    //
    {
        CPCHAccounts acc;

		(void)acc.DeleteGroup( strGroupName.c_str() );
    }

    ////////////////////////////////////////////////////////////////////////////////

    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC      , NULL, /*fRemove*/true, /*fRecreate*/false ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT L"\\UploadLB", NULL, /*fRemove*/true, /*fRecreate*/false ));
    }

	local_RemoveRegistryBackup();

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\core\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_


#include <module.h>


#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <SvcResource.h>

#include <SvcUtils.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <Service.h>
#include <SystemMonitor.h>

#include <AccountsLib.h>
#include <SecurityLib.h>

#include <PCHUpdate.h>

#include <Utility.h>

#include <FileList.h>

#include <JetBlueLib.h>
#include <TaxonomyDatabase.h>
#include <OfflineCache.h>

#include <SAFLib.h>


//
// Setup helper.
//
extern HRESULT Local_Install  ();
extern HRESULT Local_Uninstall();

#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\helpset.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HelpSet.cpp

Abstract:
    This file contains the implementation of the Taxonomy::HelpSet class,
	that is used as an identifier for the set of Help files to operate upon.

Revision History:
    Davide Massarenti   (Dmassare)  11/25/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

MPC::wstring Taxonomy::HelpSet::m_strSKU_Machine;
long         Taxonomy::HelpSet::m_lLCID_Machine;

////////////////////

HRESULT Taxonomy::HelpSet::SetMachineInfo( /*[in]*/ const InstanceBase& inst )
{
    m_strSKU_Machine = inst.m_ths.m_strSKU;
    m_lLCID_Machine  = inst.m_ths.m_lLCID;

	return S_OK;
}

DWORD Taxonomy::HelpSet::GetMachineLCID()
{
    return ::GetSystemDefaultLCID();
}

DWORD Taxonomy::HelpSet::GetUserLCID()
{
    return MAKELCID( ::GetUserDefaultUILanguage(), SORTIDFROMLCID( GetMachineLCID() ) );
}

void Taxonomy::HelpSet::GetLCIDDisplayString( /*[in]*/ long lLCID, /*[out]*/ MPC::wstring& str )
{
	WCHAR rgTmp[256];

	if(::GetLocaleInfoW( lLCID, LOCALE_SLANGUAGE, rgTmp, MAXSTRLEN(rgTmp) ))
	{
		str = rgTmp;
	}
}

////////////////////

Taxonomy::HelpSet::HelpSet( /*[in]*/ LPCWSTR szSKU ,
							/*[in]*/ long    lLCID )
{
	(void)Initialize( szSKU, lLCID );
}

Taxonomy::HelpSet::HelpSet( /*[in]*/ const HelpSet& ths )
{
	*this = ths;
}

Taxonomy::HelpSet& Taxonomy::HelpSet::operator=( /*[in]*/ const HelpSet& ths )
{
    m_strSKU = ths.m_strSKU;
    m_lLCID  = ths.m_lLCID ;

	return *this;
}	

////////////////////

HRESULT Taxonomy::HelpSet::Initialize( /*[in]*/ LPCWSTR szSKU ,
									   /*[in]*/ long    lLCID )
{
	m_strSKU = STRINGISPRESENT(szSKU) ? szSKU : m_strSKU_Machine.c_str();
	m_lLCID  =                 lLCID  ? lLCID : m_lLCID_Machine;

	return S_OK;
}

HRESULT Taxonomy::HelpSet::Initialize( /*[in]*/ LPCWSTR szSKU      ,
									   /*[in]*/ LPCWSTR szLanguage )
{
	return Initialize( szSKU, STRINGISPRESENT(szLanguage) ? _wtol( szLanguage ) : 0 );
}

////////////////////

bool Taxonomy::HelpSet::IsMachineHelp() const
{
    return !_wcsicmp( GetSKU     () ,  GetMachineSKU     () ) &&
                      GetLanguage() == GetMachineLanguage()    ;
}

////////////////////

bool Taxonomy::HelpSet::operator==( /*[in]*/ const HelpSet& sel ) const
{
    return !_wcsicmp( GetSKU	 () ,  sel.GetSKU	  () ) &&
                      GetLanguage() == sel.GetLanguage()    ;
}

bool Taxonomy::HelpSet::operator<( /*[in]*/ const HelpSet& sel ) const
{
	int iCmp = _wcsicmp( GetSKU(), sel.GetSKU() );

	if(iCmp == 0)
	{
		iCmp = (int)(GetLanguage() - sel.GetLanguage());
	}

	return (iCmp < 0);
}


HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::HelpSet& val )
{
	HRESULT hr;

	if(SUCCEEDED(hr = (stream >> val.m_strSKU)) &&
	   SUCCEEDED(hr = (stream >> val.m_lLCID ))  )
	{
		hr = S_OK;
	}

	return hr;
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::HelpSet& val )
{
	HRESULT hr;

	if(SUCCEEDED(hr = (stream << val.m_strSKU)) &&
	   SUCCEEDED(hr = (stream << val.m_lLCID ))  )
	{
		hr = S_OK;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\cache.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    Cache.cpp

Abstract:
    Handles caching of database lookups.

Revision History:

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const DWORD l_dwVersion           = 0x01314351; // QC1 01
static const DWORD l_dwSizeThresholdHIGH = 2048*1024;
static const DWORD l_dwSizeThresholdLOW  = 1024*1024;

static const DATE  l_dSaveThreshold      = (60.0/86400.0); // 60 seconds.

static const WCHAR l_szBase  [] = HC_ROOT_HELPSVC_CONFIG L"\\Cache";
static const WCHAR l_szIndex [] = L"Directory.bin";
static const WCHAR l_szQuery [] = L"Query_%08x.bin";
static const WCHAR l_szBackup[] = L".bak";

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::Cache::NodeEntry& val )
{
    __HCP_FUNC_ENTRY( "Taxonomy::operator>> Taxonomy::Cache::NodeEntry" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_rs_data );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::Cache::NodeEntry& val )
{
    __HCP_FUNC_ENTRY( "Taxonomy::operator<< Taxonomy::Cache::NodeEntry" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_rs_data );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

Taxonomy::Cache::NodeEntry::NodeEntry()
{
    m_rs_data.m_ID_parent = -1;
    m_rs_data.m_ID_node   = -1;
}


bool Taxonomy::Cache::NodeEntry::operator<( /*[in]*/ NodeEntry const &en ) const
{
    long lCmp = (m_rs_data.m_ID_parent - en.m_rs_data.m_ID_parent);

    if(lCmp == 0)
    {
        lCmp = MPC::StrICmp( m_rs_data.m_strEntry, en.m_rs_data.m_strEntry );
    }

    return (lCmp < 0);
}

bool Taxonomy::Cache::NodeEntry::operator==( /*[in]*/ long ID ) const
{
    return m_rs_data.m_ID_node == ID;
}


Taxonomy::Cache::NodeEntry::MatchNode::MatchNode( /*[in]*/ long ID )
{
    m_ID = ID; // long m_ID;
}

bool Taxonomy::Cache::NodeEntry::MatchNode::operator()( /*[in]*/ Taxonomy::Cache::NodeEntry const &en ) const
{
    return en == m_ID;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::Cache::QueryEntry& val )
{
    __HCP_FUNC_ENTRY( "Taxonomy::operator>> Taxonomy::Cache::QueryEntry" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strID     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_iType     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_iSequence );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fNull     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_dwSize    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_dLastUsed );

    val.m_fRemoved = false;


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::Cache::QueryEntry& val )
{
    __HCP_FUNC_ENTRY( "Taxonomy::operator<< Taxonomy::Cache::QueryEntry" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strID     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_iType     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_iSequence );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fNull     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_dwSize    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_dLastUsed );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

Taxonomy::Cache::QueryEntry::QueryEntry()
{
                                           // MPC::wstring m_strID;
   m_iType     = OfflineCache::ET_INVALID; // int          m_iType;
   m_iSequence = 0;                        // int          m_iSequence;
   m_fNull     = true;                     // bool         m_fNull;
                                           //
   m_dwSize    = 0;                        // DWORD        m_dwSize;
   m_dLastUsed = 0;                        // DATE         m_dLastUsed;
   m_fRemoved  = true;                     // bool         m_fRemoved;
}


bool Taxonomy::Cache::QueryEntry::operator<( /*[in]*/ QueryEntry const &en ) const
{
    int iCmp = MPC::StrCmp( m_strID, en.m_strID );

    if(iCmp == 0)
    {
        iCmp = (m_iType - en.m_iType);
    }

    return (iCmp < 0);
}

////////////////////////////////////////

void Taxonomy::Cache::QueryEntry::Touch()
{
    m_dLastUsed = MPC::GetLocalTime();
    m_fRemoved  = false;
}

HRESULT Taxonomy::Cache::QueryEntry::GetFile( /*[out]*/ MPC::wstring& strFile )
{
    WCHAR rgTmp[64]; swprintf( rgTmp, l_szQuery, m_iSequence );

    strFile = rgTmp;

    return S_OK;
}

////////////////////////////////////////

HRESULT Taxonomy::Cache::QueryEntry::Store( /*[in]*/ MPC::StorageObject&              disk  ,
                                            /*[in]*/ const CPCHQueryResultCollection* pColl )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::QueryEntry::Store" );

    HRESULT             hr;
    MPC::StorageObject* child;
    MPC::wstring        strFile;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFile( strFile ));


    m_fNull = (pColl->Size() == 0);

    __MPC_EXIT_IF_METHOD_FAILS(hr, disk.GetChild( strFile.c_str(), child, STGM_READWRITE, (m_fNull == false) ? STGTY_STREAM : 0 ));
    if(m_fNull == false)
    {
        if(child)
        {
            CComPtr<IStream> stream;

            __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
            if(stream)
            {
                STATSTG statstg;

                __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->SaveToCache( stream ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Stat( &statstg, STATFLAG_NONAME ));
                m_dwSize = statstg.cbSize.LowPart;
            }
        }
    }
    else
    {
        if(child)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, child->Delete());
        }
    }

    Touch();
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::QueryEntry::Retrieve( /*[in]*/ MPC::StorageObject&        disk  ,
                                               /*[in]*/ CPCHQueryResultCollection* pColl )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::QueryEntry::Retrieve" );

    HRESULT hr;


    if(m_fNull == false)
    {
        MPC::StorageObject* child;
        MPC::wstring        strFile;


        __MPC_EXIT_IF_METHOD_FAILS(hr, GetFile( strFile ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, disk.GetChild( strFile.c_str(), child, STGM_READWRITE, 0 ));
        if(child)
        {
            CComPtr<IStream> stream;

            __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
            if(stream)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->LoadFromCache( stream ));
            }
        }
    }

    Touch();
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::QueryEntry::Release( /*[in]*/ MPC::StorageObject& disk )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::QueryEntry::Release" );

    HRESULT hr;


    if(m_fNull == false)
    {
        MPC::StorageObject* child;
        MPC::wstring        strFile;


        __MPC_EXIT_IF_METHOD_FAILS(hr, GetFile( strFile ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, disk.GetChild( strFile.c_str(), child, STGM_READWRITE, 0 ));
        if(child)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, child->Delete());
        }
    }

    m_fRemoved = true;
    hr         = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool Taxonomy::Cache::SortEntries::operator()( /*[in]*/ QueryEntry* const &left, /*[in]*/ QueryEntry* const &right ) const
{
    return (left->m_dLastUsed < right->m_dLastUsed);
}

////////////////////////////////////////////////////////////////////////////////

//
// ITSS.DLL is broken under IA64....
//
#ifdef _IA64_
#define CACHEDHELPSET_STORAGETOUSE false
#else
#define CACHEDHELPSET_STORAGETOUSE true
#endif

Taxonomy::Cache::CachedHelpSet::CachedHelpSet() : m_disk( STGM_READWRITE, /*fITSS*/CACHEDHELPSET_STORAGETOUSE )
{
    Init();
}


Taxonomy::Cache::CachedHelpSet::~CachedHelpSet()
{
    if(m_fDirty)
    {
        (void)EnsureInSync( true );
    }

    //
    // Copy working file as the backup.
    //
    if(m_fLoaded)
    {
        MPC::wstring strFileBack = m_strFile; strFileBack += l_szBackup;

        if(SUCCEEDED(m_disk.Compact()))
        {
            (void)MPC::MoveFile( m_strFile, strFileBack );
        }
    }
}

Taxonomy::Cache::CachedHelpSet::CachedHelpSet( /*[in]*/ const CachedHelpSet& chs ) : m_disk( STGM_READWRITE, /*fITSS*/CACHEDHELPSET_STORAGETOUSE )
{
    Init();

    m_ths     = chs.m_ths;     // Taxonomy::HelpSet  m_ths;
    m_strFile = chs.m_strFile; // MPC::wstring       m_strFile;
                               // MPC::StorageObject m_disk;
                               //
                               // bool               m_fLoaded;
                               // bool               m_fDirty;
                               // bool               m_fMarkedForLoad;
                               // DATE               m_dLastSaved;
                               // long               m_lTopNode;
                               // NodeEntrySet       m_setNodes;
                               // QueryEntrySet      m_setQueries;
                               // int                m_iLastSequence;
}

Taxonomy::Cache::CachedHelpSet& Taxonomy::Cache::CachedHelpSet::operator=( /*[in]*/ const CachedHelpSet& chs )
{
    Clean();

    m_ths     = chs.m_ths;     // Taxonomy::HelpSet  m_ths;
    m_strFile = chs.m_strFile; // MPC::wstring       m_strFile;
                               // MPC::StorageObject m_disk;
                               //
                               // bool               m_fLoaded;
                               // bool               m_fDirty;
                               // bool               m_fMarkedForLoad;
                               // DATE               m_dLastSaved;
                               // long               m_lTopNode;
                               // NodeEntrySet       m_setNodes;
                               // QueryEntrySet      m_setQueries;
                               // int                m_iLastSequence;

    return *this;
}

bool Taxonomy::Cache::CachedHelpSet::operator<( /*[in]*/ CachedHelpSet const &hs ) const
{
    return m_ths < hs.m_ths;
}

////////////////////////////////////////////////////////////////////////////////

void Taxonomy::Cache::CachedHelpSet::Init()
{
                              // Taxonomy::HelpSet  m_ths;
                              // MPC::wstring       m_strFile;
                              // MPC::StorageObject m_disk;
                              //
    m_fLoaded        = false; // bool               m_fLoaded;
    m_fDirty         = false; // bool               m_fDirty;
    m_fMarkedForLoad = false; // bool               m_fMarkedForLoad;
    m_dLastSaved     = 0;     // DATE               m_dLastSaved;
    m_lTopNode       = -1;    // long               m_lTopNode;
                              // NodeEntrySet       m_setNodes;
                              // QueryEntrySet      m_setQueries;
    m_iLastSequence  = 1;     // int                m_iLastSequence;
}

void Taxonomy::Cache::CachedHelpSet::Clean()
{
                              // Taxonomy::HelpSet  m_ths;
                              // MPC::wstring       m_strFile;
    m_disk.Release();         // MPC::StorageObject m_disk;
                              //
    m_fLoaded       = false;  // bool               m_fLoaded;
    m_fDirty        = false;  // bool               m_fDirty;
                              // DATE               m_dLastSaved;
    m_lTopNode      = -1;     // long               m_lTopNode;
    m_setNodes      .clear(); // NodeEntrySet       m_setNodes;
    m_setQueries    .clear(); // QueryEntrySet      m_setQueries;
    m_iLastSequence = 1;      // int                m_iLastSequence;
}

HRESULT Taxonomy::Cache::CachedHelpSet::Load()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::Load" );

    HRESULT             hr;
    MPC::StorageObject* child;


    Clean();


    DEBUG_AppendPerf( DEBUG_PERF_CACHE_L1, "Loading Taxonomy Cache" );


    //
    // Copy the backup on top of the working file.
    //
    {
        MPC::wstring strFileBack = m_strFile; strFileBack += l_szBackup;

        (void)MPC::DeleteFile(              m_strFile );
        (void)MPC::CopyFile  ( strFileBack, m_strFile );
    }


    if(FAILED(m_disk.Exists()))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_disk.Create());
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_disk.GetChild( l_szIndex, child, STGM_READWRITE, 0 ));
    if(child)
    {
        CComPtr<IStream> stream;

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
        if(stream)
        {
            MPC::Serializer_IStream   streamReal( stream     );
            MPC::Serializer_Buffering streamBuf ( streamReal );
            DWORD                     dwVer;

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> dwVer          ); if(dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_iLastSequence);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_lTopNode     );
            DEBUG_AppendPerf( DEBUG_PERF_CACHE_L1, "Loading Taxonomy Cache : nodes" );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_setNodes     );
            DEBUG_AppendPerf( DEBUG_PERF_CACHE_L1, "Loading Taxonomy Cache : queries" );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_setQueries   );
        }
    }
    DEBUG_AppendPerf( DEBUG_PERF_CACHE_L1, "Loaded Taxonomy Cache" );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr)) Clean();

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::Save()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::Save" );

    HRESULT             hr;
    MPC::StorageObject* child;


    if(FAILED(m_disk.Exists()))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_disk.Create());
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_disk.GetChild( l_szIndex, child, STGM_READWRITE, STGTY_STREAM ));
    if(child)
    {
        CComPtr<IStream> stream;

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
        if(stream)
        {
            MPC::Serializer_IStream   streamReal( stream     );
            MPC::Serializer_Buffering streamBuf ( streamReal );

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << l_dwVersion    );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_iLastSequence);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_lTopNode     );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_setNodes     );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_setQueries   );

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());
        }
    }

#if 0
    ////////////////////////////////////////////////////////////////////////////////
    //
    // DEBUG CODE
    //
    {
        USES_CONVERSION;

        HHK::Writer     writer;
        CHAR            rgBuf[1024];
        QueryEntryIter  it;
        SortEntries     Pr;
        SortedEntryVec  vec;
        SortedEntryIter it2;

        strFile += L".debug";

        __MPC_EXIT_IF_METHOD_FAILS(hr, writer.Init( strFile.c_str() ));

        for(it = m_setQueries.begin(); it != m_setQueries.end(); it++)
        {
            vec.push_back( &(*it) );
        }

        std::sort( vec.begin(), vec.end(), Pr );

        for(it2 = vec.begin(); it2 != vec.end(); it2++)
        {
            QueryEntry* en = *it2;

            sprintf( rgBuf, "%80s: %1d %3d %5d %1d %5.12g\n",
                     W2A( en->m_strID.c_str() ),
                          en->m_iType          ,
                          en->m_iSequence      ,
                     (int)en->m_dwSize         ,
                     (int)en->m_fRemoved       ,
                          en->m_dLastUsed      );

            __MPC_EXIT_IF_METHOD_FAILS(hr, writer.OutputLine( rgBuf ));
        }
    }
    //
    // DEBUG CODE
    //
    ////////////////////////////////////////////////////////////////////////////////
#endif

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::EnsureInSync( /*[in]*/ bool fForceSave )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::EnsureInSync" );

    HRESULT hr;


    if(m_fLoaded == false)
    {
        m_fDirty = false;
        m_disk   = m_strFile.c_str();

        __MPC_EXIT_IF_METHOD_FAILS(hr, Load());

        m_dLastSaved = MPC::GetSystemTime();
        m_fLoaded    = true;
    }

    if(m_fDirty)
    {
        DATE dNow = MPC::GetSystemTime();

        if(fForceSave == false)
        {
            if(dNow - m_dLastSaved > l_dSaveThreshold)
            {
                fForceSave = true;
            }
        }

        if(fForceSave)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Save());

            m_dLastSaved = dNow;
            m_fDirty     = false;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::Cache::CachedHelpSet::GenerateDefaultQueries( /*[in]*/ Taxonomy::Settings& ts      ,
                                                                /*[in]*/ Taxonomy::Updater&  updater ,
                                                                /*[in]*/ long                ID      ,
                                                                /*[in]*/ long                lLevel  )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::GenerateDefaultQueries" );

    HRESULT                            hr;
    CComPtr<CPCHQueryResultCollection> coll;
    MPC::wstring                       strPath;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &coll ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, BuildNodePath( ID, strPath, /*fParent*/false ));

    //
    // Build the queries.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupNode          ( strPath.c_str(),                       coll )); coll->Erase();
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupSubNodes      ( strPath.c_str(), /*fVisibleOnly*/true, coll )); coll->Erase();
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupNodesAndTopics( strPath.c_str(), /*fVisibleOnly*/true, coll )); coll->Erase();
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupTopics        ( strPath.c_str(), /*fVisibleOnly*/true, coll )); coll->Erase();


    //
    // Recurse for sub-levels.
    //
    if(lLevel++ < 3)
    {
        MatchSet  res;
        MatchIter it;

        __MPC_EXIT_IF_METHOD_FAILS(hr, LocateSubNodes( ID, /*fRecurse*/false, /*fOnlyVisible*/true, res ));

        for(it=res.begin(); it!=res.end(); it++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateDefaultQueries( ts, updater, *it, lLevel ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::GenerateDefaultQueries( /*[in]*/ Taxonomy::Settings& ts      ,
                                                                /*[in]*/ Taxonomy::Updater&  updater )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::GenerateDefaultQueries" );

    HRESULT        hr;
    static  WCHAR* c_rgNodes[] = { L"", L"_SYSTEM_", L"UNMAPPED" };

    for(int i=0; i<ARRAYSIZE(c_rgNodes); i++)
    {
        long                   id  = m_lTopNode;
        MPC::WStringVector     vec;
        MPC::WStringVectorIter it;
        NodeEntryIter          it2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SplitAtDelimiter( vec, c_rgNodes[i], L"/" ));

        for(it = vec.begin(); it != vec.end(); it++)
        {
            if(!LocateNode( id, it->c_str(), it2 )) break;

            id = it2->m_rs_data.m_ID_node;
        }

        if(it == vec.end())
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateDefaultQueries( ts, updater, id, 0 ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}



HRESULT Taxonomy::Cache::CachedHelpSet::PrePopulate( /*[in]*/ Cache* parent )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::PrePopulate" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    //
    // This opens the database, walks through all the nodes in the taxonomy and makes a copy in the cache.
    //
    DEBUG_AppendPerf( DEBUG_PERF_CACHE_L1, "PrePopulating Taxonomy Cache" );
    {
        Taxonomy::Settings     ts( m_ths );
        JetBlue::SessionHandle handle;
        JetBlue::Database*     db;
        Taxonomy::Updater      updater;
        Taxonomy::RS_Taxonomy* rs;
        bool                   fFound;


        __MPC_EXIT_IF_METHOD_FAILS(hr, ts.GetDatabase( handle, db, /*fReadOnly*/true ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init  ( ts,     db, parent            ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, updater.GetTaxonomy( &rs ));

        m_lTopNode = -1;
        m_setNodes.clear();
        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
            NodeEntry en;

            en.m_rs_data = *rs;
            if(!en.m_rs_data.m_fValid__ID_parent)
            {
                en.m_rs_data.m_ID_parent = -1;

                m_lTopNode = en.m_rs_data.m_ID_node;
            }

            m_setNodes.insert( en );

            __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
        }

        m_fDirty = true;
        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync( true ));

        DEBUG_AppendPerf( DEBUG_PERF_CACHE_L1, "PrePopulating Taxonomy Cache : Nodes done" );

        //
        // Walk through the first 3 level of nodes and pre-generate the queries.
        //
        // We disable offline flushing of the root index, because it gets changed too often...
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, OfflineCache::Root::s_GLOBAL->DisableSave(             ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateDefaultQueries                   ( ts, updater ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync                             ( true        ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, OfflineCache::Root::s_GLOBAL->EnableSave (             ));
    }
    DEBUG_AppendPerf( DEBUG_PERF_CACHE_L1, "PrePopulated Taxonomy Cache : Nodes done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::Erase()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::Erase" );

    HRESULT hr;

    Clean();

    {
        MPC::wstring strFileBack = m_strFile; strFileBack += l_szBackup;

		(void)MPC::DeleteFile( m_strFile  , /*fForce*/true, /*fDelayed*/false );
        (void)MPC::DeleteFile( strFileBack, /*fForce*/true, /*fDelayed*/false );
    }


    //
    // Propagate change to the offline cache.
    //
    {
        OfflineCache::Handle handle;

        if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Locate( m_ths, handle )))
        {
            if(SUCCEEDED(handle->RemoveQueries()))
            {
                (void)OfflineCache::Root::s_GLOBAL->Flush();
            }
        }
    }


    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::PrepareToLoad()
{
    m_fMarkedForLoad = true;

    return S_OK;
}

HRESULT Taxonomy::Cache::CachedHelpSet::LoadIfMarked()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::LoadIfMarked" );

    HRESULT hr;


    if(m_fMarkedForLoad)
    {
        m_fMarkedForLoad = false;

        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

        //
        // Load the JetBlue database.
        //
        {
            Taxonomy::Settings     ts( m_ths );
            JetBlue::SessionHandle handle;
            JetBlue::Database*     db;

            __MPC_EXIT_IF_METHOD_FAILS(hr, ts.GetDatabase( handle, db, /*fReadOnly*/true ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Cache::CachedHelpSet::MRU()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::MRU" );

    HRESULT        hr;
    QueryEntryIter it;
    DWORD          dwSizeTot = 0;


    //
    // Get total cache size.
    //
    for(it = m_setQueries.begin(); it != m_setQueries.end(); it++)
    {
        if(it->m_fRemoved == false)
        {
            dwSizeTot += it->m_dwSize;
        }
    }

    //
    // If the total size of the cache is bigger than a certain value, start to purge from the least used query.
    //
    if(dwSizeTot > l_dwSizeThresholdHIGH)
    {
        SortEntries     Pr;
        SortedEntryVec  vec;
        SortedEntryIter it2;

        for(it = m_setQueries.begin(); it != m_setQueries.end(); it++)
        {
            if(it->m_fRemoved == false)
            {
                vec.push_back( &(*it) );
            }
        }

        std::sort( vec.begin(), vec.end(), Pr );

        for(it2 = vec.begin(); it2 != vec.end(); it2++)
        {
            QueryEntry* en = *it2;

            __MPC_EXIT_IF_METHOD_FAILS(hr, en->Release( m_disk ));

            m_fDirty   = true;
            dwSizeTot -= en->m_dwSize;

            if(dwSizeTot < l_dwSizeThresholdLOW) break;
        }

    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

bool Taxonomy::Cache::CachedHelpSet::LocateNode( /*[in] */ long           ID_parent ,
                                                 /*[in] */ LPCWSTR        szEntry   ,
                                                 /*[out]*/ NodeEntryIter& it        )
{
    NodeEntry en;

    en.m_rs_data.m_ID_parent =          ID_parent;
    en.m_rs_data.m_strEntry  = SAFEWSTR(szEntry);

    it = m_setNodes.find( en );
    return (it != m_setNodes.end());
}

HRESULT Taxonomy::Cache::CachedHelpSet::LocateNode( /*[in] */ long              ID_parent ,
                                                    /*[in] */ LPCWSTR           szEntry   ,
                                                    /*[out]*/ RS_Data_Taxonomy& rs_data   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::LocateNode" );

    HRESULT       hr;
    NodeEntryIter it;


    rs_data.m_ID_node = -1;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());


    if(LocateNode( ID_parent, szEntry, it ) == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    rs_data = it->m_rs_data;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::LocateSubNodes( /*[in] */ long      ID_node      ,
                                                        /*[in] */ bool      fRecurse     ,
                                                        /*[in] */ bool      fOnlyVisible ,
                                                        /*[out]*/ MatchSet& res          )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::LocateSubNodes" );

    HRESULT            hr;
    NodeEntry          en;
    NodeEntryIterConst it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());


    en.m_rs_data.m_ID_parent = ID_node;

    it = m_setNodes.lower_bound( en );
    while(it != m_setNodes.end() && it->m_rs_data.m_ID_parent == ID_node)
    {
        if(fOnlyVisible == false || it->m_rs_data.m_fVisible)
        {
            res.insert( it->m_rs_data.m_ID_node );

            if(fRecurse)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, LocateSubNodes( it->m_rs_data.m_ID_node, /*fRecurse*/true, fOnlyVisible, res ));
            }
        }

        it++;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::LocateNodesFromURL( /*[in] */ LPCWSTR   szURL ,
                                                            /*[out]*/ MatchSet& res   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::LocateNodesFromURL" );

    HRESULT            hr;
    NodeEntryIterConst it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    for(it = m_setNodes.begin(); it != m_setNodes.end(); it++)
    {
        if(!MPC::StrICmp( szURL, it->m_rs_data.m_strDescriptionURI ))
        {
            res.insert( it->m_rs_data.m_ID_node );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::CachedHelpSet::BuildNodePath( /*[in] */ long          ID      ,
                                                       /*[out]*/ MPC::wstring& strPath ,
                                                       /*[in] */ bool          fParent )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::BuildNodePath" );

    HRESULT            hr;
    NodeEntryIterConst it;
    MPC::wstring       strTmp;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());


    strTmp .reserve( 1024 );
    strPath.reserve( 1024 );

    strPath = L"";

    while(ID != m_lTopNode)
    {
        NodeEntry::MatchNode cmp( ID );

        it = std::find_if( m_setNodes.begin(), m_setNodes.end(), cmp );
        if(it == m_setNodes.end())
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
        }

        if(fParent == false)
        {
            strTmp = it->m_rs_data.m_strEntry;
            if(strPath.size())
            {
                strTmp += L"/";
                strTmp += strPath;
            }
            strPath = strTmp;
        }
        else
        {
            fParent = true;
        }

        ID = it->m_rs_data.m_ID_parent;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::Cache::CachedHelpSet::LocateQuery( /*[in] */ LPCWSTR      szID    ,
                                                     /*[in] */ int          iType   ,
                                                     /*[out]*/ QueryEntry* &pEntry  ,
                                                     /*[in] */ bool         fCreate )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::CachedHelpSet::LocateQuery" );

    HRESULT        hr;
    QueryEntry     en;
    QueryEntryIter it;


    pEntry = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());


    en.m_strID = SAFEWSTR(szID);
    en.m_iType = iType;

    it = m_setQueries.find( en );
    if(it == m_setQueries.end())
    {
        if(fCreate == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
        }

        it = m_setQueries.insert( en ).first;

        it->m_iSequence = m_iLastSequence++;
    }
    else
    {
        if(fCreate == false)
        {
            if(it->m_fRemoved)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
            }
        }
    }


    pEntry             = &(*it);
    pEntry->m_fRemoved = false;
    m_fDirty           = true;
    hr                 = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Taxonomy::Cache::Cache()
{
    // CacheSet m_skus;

    (void)MPC::_MPC_Module.RegisterCallback( this, (void (Taxonomy::Cache::*)())Shutdown );
}

Taxonomy::Cache::~Cache()
{
    MPC::_MPC_Module.UnregisterCallback( this );

    Shutdown();
}

////////////////////

Taxonomy::Cache* Taxonomy::Cache::s_GLOBAL( NULL );

HRESULT Taxonomy::Cache::InitializeSystem()
{
    if(s_GLOBAL == NULL)
    {
        s_GLOBAL = new Taxonomy::Cache;
    }

    return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void Taxonomy::Cache::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

////////////////////

void Taxonomy::Cache::Shutdown()
{
    m_skus.clear();
}

HRESULT Taxonomy::Cache::Locate( /*[in] */ const Taxonomy::HelpSet& ths ,
                                 /*[out]*/ CacheIter&               it  )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::Locate" );

    HRESULT                      hr;
    CachedHelpSet                hs;
    MPC::SmartLock<_ThreadModel> lock( this );


    hs.m_ths = ths;
    it = m_skus.find( hs );
    if(it == m_skus.end())
    {
        WCHAR rgTmp[MAX_PATH]; _snwprintf( rgTmp, MAXSTRLEN(rgTmp), L"%s\\%s_%ld.dat", l_szBase, hs.m_ths.GetSKU(), hs.m_ths.GetLanguage() );

        it = m_skus.insert( hs ).first;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( it->m_strFile = rgTmp ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir               ( it->m_strFile         ));

        it->m_fDirty = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT Taxonomy::Cache::PrePopulate( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::PrePopulate" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->PrePopulate( this ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::Erase( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::Erase" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->Erase());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::PrepareToLoad( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::PrepareToLoad" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->PrepareToLoad());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::LoadIfMarked( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::LoadIfMarked" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->LoadIfMarked());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::Cache::LocateNode( /*[in] */ const Taxonomy::HelpSet& ths       ,
                                     /*[in] */ long                     ID_parent ,
                                     /*[in] */ LPCWSTR                  szEntry   ,
                                     /*[out]*/ RS_Data_Taxonomy&        rs_data   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::LocateNode" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->LocateNode( ID_parent, szEntry, rs_data ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::LocateSubNodes( /*[in] */ const Taxonomy::HelpSet& ths          ,
                                         /*[in] */ long                     ID_node      ,
                                         /*[in] */ bool                     fRecurse     ,
                                         /*[in] */ bool                     fOnlyVisible ,
                                         /*[out]*/ MatchSet&                res          )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::LocateSubNodes" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->LocateSubNodes( ID_node, fRecurse, fOnlyVisible, res ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::LocateNodesFromURL( /*[in] */ const Taxonomy::HelpSet& ths   ,
                                             /*[in] */ LPCWSTR                  szURL ,
                                             /*[out]*/ MatchSet&                res   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::LocateNodesFromURL" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->LocateNodesFromURL( szURL, res ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::BuildNodePath( /*[in] */ const Taxonomy::HelpSet& ths     ,
                                        /*[in] */ long                     ID      ,
                                        /*[out]*/ MPC::wstring&            strPath ,
                                        /*[in] */ bool                     fParent )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::BuildNodePath" );

    HRESULT                      hr;
    CacheIter                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->BuildNodePath( ID, strPath, fParent ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::Cache::StoreQuery( /*[in]*/ const Taxonomy::HelpSet&         ths   ,
                                     /*[in]*/ LPCWSTR                          szID  ,
                                     /*[in]*/ int                              iType ,
                                     /*[in]*/ const CPCHQueryResultCollection* pColl )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::StoreQuery" );

    HRESULT                      hr;
    CacheIter                    it;
    QueryEntry*                  pEntry;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->LocateQuery( szID, iType, pEntry, true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pEntry->Store( it->m_disk, pColl ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->MRU         ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, it->EnsureInSync());

    //
    // Propagate change to the offline cache.
    //
    {
        OfflineCache::Handle handle;

        if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Locate( it->m_ths, handle )))
        {
            if(handle->AreYouInterested( szID, iType ))
            {
                if(SUCCEEDED(handle->Store( szID, iType, pColl )))
                {
                    (void)OfflineCache::Root::s_GLOBAL->Flush();
                }
            }
        }
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Cache::RetrieveQuery( /*[in]*/ const Taxonomy::HelpSet&   ths   ,
                                        /*[in]*/ LPCWSTR                    szID  ,
                                        /*[in]*/ int                        iType ,
                                        /*[in]*/ CPCHQueryResultCollection* pColl )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Cache::Retrieve" );

    HRESULT                      hr;
    CacheIter                    it;
    QueryEntry*                  pEntry;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( ths, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->LocateQuery( szID, iType, pEntry, false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pEntry->Retrieve( it->m_disk, pColl ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->EnsureInSync());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\installeddatabasestore.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    InstalledDatabaseStore.cpp


Abstract:
    This file contains the implementation of the Taxonomy::InstalledInstanceStore class,
    which controls the set of Topic Databases installed on the machine.

Revision History:
    Davide Massarenti   (Dmassare)  05/01/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <SAFLIB.h>

#include <SEConfig.h>

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_DB_BUGREPT   [] = L"bugrept.cab";
static const WCHAR c_DB_RCBDY     [] = L"rcBuddy.cab";
static const WCHAR c_DB_PSS       [] = L"pss.cab";
static const WCHAR c_DB_NEWSGROUPS[] = L"newsgroups.cab";

static const WCHAR c_REG_BACKUP	[] = L"PackageStore";
static const WCHAR c_REG_CRC   	[] = L"CRC_Disk";
static const WCHAR c_REG_CRC_BAK[] = L"CRC_Registry";

////////////////////////////////////////////////////////////////////////////////

LPCWSTR const Taxonomy::Strings::s_file_PackageDescription      = L"package_description.xml";

LPCWSTR const Taxonomy::Strings::s_tag_root_PackageDescription  = L"HELPCENTERPACKAGE";

LPCWSTR const Taxonomy::Strings::s_tag_root_HHT                 = L"METADATA";

LPCWSTR const Taxonomy::Strings::s_tag_root_SAF                 = L"SAFConfig";

////////////////////////////////////////////////////////////////////////////////

static void local_GetFileForCRC( /*[out]*/ MPC::wstring& strDest ,
								 /*[in]*/  LPCWSTR       szValue )
{
	strDest  = HC_ROOT_HELPSVC_PKGSTORE L"\\";
	strDest += szValue;

	MPC::SubstituteEnvVariables( strDest );
}

static HRESULT local_OpenForRead( /*[in/out]*/ MPC::RegKey& rkBase )
{
	__HCP_FUNC_ENTRY( "local_OpenForRead" );

	HRESULT hr;

	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SetRoot( HKEY_LOCAL_MACHINE              ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Attach ( HC_REGISTRY_HELPSVC L"\\Backup" ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

static HRESULT local_OpenForWrite( /*[in/out]*/ MPC::RegKey& rkBase )
{
	__HCP_FUNC_ENTRY( "local_OpenForWrite" );

	HRESULT hr;

	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SetRoot( HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Attach ( HC_REGISTRY_HELPSVC L"\\Backup"    ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Create (                                    ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

static HRESULT local_CreateCRC( /*[in]*/ MPC::RegKey* rkBase  ,
								/*[in]*/ LPCWSTR      szValue ,
								/*[in]*/ IStream*     stream  )
{
	__HCP_FUNC_ENTRY( "local_CreateCRC" );

	HRESULT       hr;
	LARGE_INTEGER li = { 0, 0 };
	DWORD         dwCRC; MPC::InitCRC( dwCRC );


	__MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( li, STREAM_SEEK_SET, NULL ));


 	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( dwCRC, stream ));

	if(rkBase)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase->Write( dwCRC, szValue ));
	}
	else
	{
		MPC::wstring             strDest;
		CComPtr<MPC::FileStream> stream2;
		ULONG                    cb;

		local_GetFileForCRC( strDest, szValue );

		__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Init( strDest.c_str(), stream2 ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, stream2->Write( &dwCRC, sizeof(dwCRC), &cb )); stream2.Release();

		__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Finalize( strDest.c_str(), stream2 ));
	}


	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

static HRESULT local_CheckCRC( /*[in]*/ MPC::RegKey* rkBase  ,
							   /*[in]*/ LPCWSTR      szValue ,
							   /*[in]*/ IStream*     stream  )
{
	__HCP_FUNC_ENTRY( "local_CheckCRC" );

	HRESULT hr;
	DWORD   dwCRC;
	bool    fFound = false;


	if(rkBase)
	{
		if(FAILED(rkBase->Read( dwCRC, fFound, szValue ))) fFound = false;
	}
	else
	{
		MPC::wstring             strDest;
		CComPtr<MPC::FileStream> stream2;

		local_GetFileForCRC( strDest, szValue );

		if(SUCCEEDED(SVC::SafeLoad( strDest.c_str(), stream2 )))
		{
			ULONG cb;

			if(SUCCEEDED(stream2->Read( &dwCRC, sizeof(dwCRC), &cb )) && cb == sizeof(dwCRC))
			{
				fFound = true;
			}
		}
	}
	
	if(fFound)
	{

		LARGE_INTEGER li = { 0, 0 };
		DWORD         dwCRC2; MPC::InitCRC( dwCRC2 );


		__MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( li, STREAM_SEEK_SET, NULL ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( dwCRC2, stream ));

		if(dwCRC != dwCRC2)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////

static HRESULT local_AddPackage( /*[in    ]*/ Taxonomy::InstalledInstanceStore* store   ,
                                 /*[in/out]*/ MPC::wstring&                     strTmp  ,
                                 /*[in    ]*/ const MPC::wstring&               strDir  ,
                                 /*[in    ]*/ LPCWSTR                           szExtra ,
                                 /*[in    ]*/ const Taxonomy::HelpSet&          ths     )
{
    __HCP_FUNC_ENTRY( "local_AddPackage" );

    HRESULT               hr;
    Taxonomy::PackageIter it;
    bool                  fFound;


    strTmp = strDir; strTmp.append( szExtra );

    __MPC_EXIT_IF_METHOD_FAILS(hr, store->Package_Add( strTmp.c_str(), NULL, &ths, /*fInsertAtTop*/true, fFound, it ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile   ( strTmp                                            ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Instance::InitializeFromBase( /*[in]*/ const InstanceBase& base, /*[in]*/ bool fSystem, /*[in]*/ bool fMUI )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Instance::InitializeFromBase" );

    HRESULT            hr;
    Taxonomy::Settings ts( base.m_ths );

    ((InstanceBase&)*this) = base;

    m_fSystem = fSystem;
    m_fMUI    = fMUI;


	if(fSystem)
	{
        //
        // Set machine-wide defaults.
        //
		__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::HelpSet::SetMachineInfo           (  base ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, OfflineCache::Root::s_GLOBAL->SetMachineInfo( *this ));
	}


    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.BaseDir     ( m_strSystem   , /*fExpand*/false                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.HelpFilesDir( m_strHelpFiles, /*fExpand*/false, /*fMUI*/m_fMUI ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.DatabaseDir ( m_strDatabaseDir                                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.DatabaseFile( m_strDatabaseFile                                ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.IndexFile   ( m_strIndexFile                                   ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Instance::Import( /*[in]*/ LPCWSTR szFile, /*[in/out]*/ DWORD* pdwCRC )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Instance::Import" );

    HRESULT      hr;
	MPC::wstring strFileDst;


	__MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName  (         strFileDst         ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile( szFile, strFileDst.c_str() ));

	::SetFileAttributesW( strFileDst.c_str(), FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM );

	if(pdwCRC)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( *pdwCRC, strFileDst.c_str() ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Instance::Remove()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Instance::Remove" );

    HRESULT      hr;
	MPC::wstring strFileDst;


	__MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName    ( strFileDst ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( strFileDst ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

Taxonomy::InstalledInstance::InstalledInstance()
{
                     			 // Instance             m_inst;
                     			 // ProcessedPackageList m_lst;
    m_fInvalidated   	= false; // bool                 m_fInvalidated;
    m_fRecreateCache 	= true;  // bool                 m_fRecreateCache;
    m_fCreateIndex      = true;  // bool                 m_fCreateIndex;
    m_fCreateIndexForce = true;  // bool                 m_fCreateIndexForce;
	m_dwCRC             = 0;     // DWORD                m_dwCRC;
                     			 //
    m_dwRef          	= 0;     // DWORD                m_dwRef;          // VOLATILE
}

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::InstalledInstance& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream >> val.m_inst        		)) &&
       SUCCEEDED(hr = (stream >> val.m_lst         		)) &&
       SUCCEEDED(hr = (stream >> val.m_fInvalidated		)) &&
       SUCCEEDED(hr = (stream >> val.m_fRecreateCache   )) &&
       SUCCEEDED(hr = (stream >> val.m_fCreateIndex     )) &&
       SUCCEEDED(hr = (stream >> val.m_fCreateIndexForce)) &&
       SUCCEEDED(hr = (stream >> val.m_dwCRC            ))  )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::InstalledInstance& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream << val.m_inst        		)) &&
       SUCCEEDED(hr = (stream << val.m_lst         		)) &&
       SUCCEEDED(hr = (stream << val.m_fInvalidated		)) &&
       SUCCEEDED(hr = (stream << val.m_fRecreateCache   )) &&
       SUCCEEDED(hr = (stream << val.m_fCreateIndex     )) &&
       SUCCEEDED(hr = (stream << val.m_fCreateIndexForce)) &&
       SUCCEEDED(hr = (stream << val.m_dwCRC            ))  )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT Taxonomy::InstalledInstance::InstallFiles( /*[in]*/ bool                    fAlsoHelpFiles ,
                                                   /*[in]*/ InstalledInstanceStore* store          )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstance::InstallFiles" );

    HRESULT            hr;
    Taxonomy::Settings ts( m_inst.m_ths );
    Installer::Package pkg;
    MPC::wstring       strDir_System;
    MPC::wstring       strDir_HelpFiles;
    MPC::wstring       strDir_Database;
    MPC::wstring       strFile_Database;
    MPC::wstring       strFile_SetupImage;
	bool               fReinstall = (store == NULL);

    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.BaseDir     ( strDir_System   , /*fExpand*/false                        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.HelpFilesDir( strDir_HelpFiles, /*fExpand*/false, /*fMUI*/m_inst.m_fMUI ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.DatabaseDir ( strDir_Database                                           ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.DatabaseFile( strFile_Database                                          ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_DATABASE  , /*fRemove*/true          , /*fRecreate*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_INDEX     , /*fRemove*/true          , /*fRecreate*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_SYSTEM    , /*fRemove*/true          , /*fRecreate*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_SYSTEM_OEM, /*fRemove*/true          , /*fRecreate*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_VENDORS   , /*fRemove*/true          , /*fRecreate*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_HELPFILES , /*fRemove*/fAlsoHelpFiles, /*fRecreate*/true ));

    //
    // Change the ACL for system directories.
    //
    {
        CPCHSecurityDescriptorDirect sdd;
        MPC::wstring                 strGroupName;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_GROUPNAME, strGroupName ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Initialize());

        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.SetGroup( strGroupName.c_str() ));


        //
        //   LOCAL SYSTEM, Admin, Admins : any access.
        //   Everyone                    : read and execute.
        //
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Add( (PSID)&sdd.s_SystemSid                     ,
                                                ACCESS_ALLOWED_ACE_TYPE                    ,
                                                OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ,
                                                FILE_ALL_ACCESS                            ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Add( (PSID)&sdd.s_Alias_AdminsSid               ,
                                                ACCESS_ALLOWED_ACE_TYPE                    ,
                                                OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ,
                                                FILE_ALL_ACCESS                            ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Add( (PSID)&sdd.s_EveryoneSid                   ,
                                                ACCESS_ALLOWED_ACE_TYPE                    ,
                                                OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ,
                                                FILE_GENERIC_READ | FILE_GENERIC_EXECUTE   ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, strDir_System                            ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, strDir_System, HC_HELPSET_SUB_DATABASE   ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, strDir_System, HC_HELPSET_SUB_INDEX      ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, strDir_System, HC_HELPSET_SUB_SYSTEM     ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, strDir_System, HC_HELPSET_SUB_SYSTEM_OEM ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, strDir_System, HC_HELPSET_SUB_VENDORS    ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, strDir_System, HC_HELPSET_SUB_HELPFILES  ));
    }


	{
		bool  fReload = false;

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_inst.GetFileName( strFile_SetupImage         ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init          ( strFile_SetupImage.c_str() ));

		if(m_dwCRC)
		{
			DWORD dwCRC;

			if(FAILED(MPC::ComputeCRC( dwCRC, strFile_SetupImage.c_str() )) || m_dwCRC != dwCRC) fReload = true;
		}

		if(fReload == false)
		{
			if(FAILED(pkg.Load())) fReload = true;
		}

		//
		// If the package has been corrupted, try to restore from BINARIES.
		//
		if(fReload)
		{
			MPC::WStringList lst;
			MPC::WStringIter it;

			__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::LocateDataArchive( HC_ROOT_HELPSVC_BINARIES, lst ));

			for(it = lst.begin(); it != lst.end(); it++)
			{
				if(SUCCEEDED(pkg.Init( it->c_str() )) &&
				   SUCCEEDED(pkg.Load(             ))  )
				{
					if(pkg.GetData().m_ths == m_inst.m_ths)
					{
						__MPC_EXIT_IF_METHOD_FAILS(hr, m_inst.Import( it->c_str(), &m_dwCRC ));
						break;
					}
				}
			}
			if(it == lst.end())
			{
				__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
			}
		}
	}


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Phase Two: install files.
    //
    {
        static const Installer::PURPOSE c_allowedFull[] =
        {
            Installer::PURPOSE_DATABASE,
            Installer::PURPOSE_PACKAGE ,
            Installer::PURPOSE_UI      ,
            Installer::PURPOSE_INVALID ,
        };

        static const Installer::PURPOSE c_allowedReinstall[] =
        {
            Installer::PURPOSE_DATABASE,
        ////Installer::PURPOSE_PACKAGE , Don't extract system packages on a reinstall.
            Installer::PURPOSE_UI      ,
            Installer::PURPOSE_INVALID ,
        };

        __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Install( fReinstall ? c_allowedReinstall : c_allowedFull, m_inst.m_fSystem ? NULL : strDir_System.c_str() ));
    }

    if(m_inst.m_fSystem || m_inst.m_fMUI)
    {
        if(store)
        {
            MPC::wstring strTmp;

            __MPC_EXIT_IF_METHOD_FAILS(hr, local_AddPackage( store, strTmp, strDir_Database, c_DB_NEWSGROUPS, m_inst.m_ths ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, local_AddPackage( store, strTmp, strDir_Database, c_DB_PSS    	, m_inst.m_ths ));
// No Remote Assistence on IA64
#ifndef WIN64	
            __MPC_EXIT_IF_METHOD_FAILS(hr, local_AddPackage( store, strTmp, strDir_Database, c_DB_RCBDY  	, m_inst.m_ths ));
#endif	 
// Only available on Beta releases.
#if 0
            __MPC_EXIT_IF_METHOD_FAILS(hr, local_AddPackage( store, strTmp, strDir_Database, c_DB_BUGREPT	, m_inst.m_ths ));
#endif
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstance::UninstallFiles( /*[in]*/ bool fAlsoHelpFiles )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstance::UninstallFiles" );

    USES_CONVERSION;

    HRESULT            	 hr;
    Taxonomy::Settings 	 ts( m_inst.m_ths );
    MPC::wstring       	 strDir_System;
    MPC::wstring       	 strFile_Database;
	SearchEngine::Config cfg;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.BaseDir     ( strDir_System   , /*fExpand*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ts.DatabaseFile( strFile_Database                   ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, JetBlue::SessionPool::s_GLOBAL->ReleaseDatabase( W2A( strFile_Database.c_str() ) ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg::             s_GLOBAL->RemoveSKU      ( m_inst.m_ths                    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cfg                           . ResetSKU       ( m_inst.m_ths                    ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_DATABASE  , /*fRemove*/true, /*fRecreate*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_INDEX     , /*fRemove*/true, /*fRecreate*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_SYSTEM    , /*fRemove*/true, /*fRecreate*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_SYSTEM_OEM, /*fRemove*/true, /*fRecreate*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_VENDORS   , /*fRemove*/true, /*fRecreate*/false ));

    if(fAlsoHelpFiles)
    {
        if(!m_inst.m_fMUI)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, HC_HELPSET_SUB_HELPFILES, /*fRemove*/true, /*fRecreate*/false ));
        }

        if(!m_inst.m_fSystem)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( strDir_System, NULL, /*fRemove*/true, /*fRecreate*/false ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

Taxonomy::LockingHandle::LockingHandle()
{
    m_main        = NULL; // InstalledInstanceStore* m_main;
    m_logPrevious = NULL; // Logger*                 m_logPrevious;
}

Taxonomy::LockingHandle::~LockingHandle()
{
    Release();
}

void Taxonomy::LockingHandle::Attach( /*[in]*/ InstalledInstanceStore* main ,
                                      /*[in]*/ Logger*                 log  )
{
    Release();

    main->Lock();

    m_main        = main;
    m_logPrevious = main->m_log;

    if(log) main->m_log = log;
}

void Taxonomy::LockingHandle::Release()
{
    if(m_main)
    {
        m_main->m_log = m_logPrevious; m_logPrevious = NULL;

        m_main->Unlock(); m_main = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////

Taxonomy::InstalledInstanceStore::InstalledInstanceStore()
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::InstalledInstanceStore" );

                                                                       // InstanceList          m_lstInstances;
                                                                       // PackageList           m_lstPackages;
                                                                       // InstalledInstanceList m_lstSKUs;
                                                                       //
                                                                       //
    MPC::SubstituteEnvVariables( m_strStore = HC_HELPSVC_STORE_SKUS ); // MPC::wstring          m_strStore;
    m_fLoaded   = false;                                               // bool                  m_fLoaded;
    m_fDirty    = false;                                               // bool                  m_fDirty;
    m_log       = NULL;                                                // Logger*               m_log;
                                                                       //
    m_dwRecurse = 0;                                                   // DWORD                 m_dwRecurse;
                                                                       //
	m_fShutdown = false;                                               // bool                  m_fShutdown;
}

Taxonomy::InstalledInstanceStore::~InstalledInstanceStore()
{
    (void)EnsureInSync();
}

////////////////////

Taxonomy::InstalledInstanceStore* Taxonomy::InstalledInstanceStore::s_GLOBAL( NULL );

HRESULT Taxonomy::InstalledInstanceStore::InitializeSystem()
{
    if(s_GLOBAL == NULL)
    {
        s_GLOBAL = new Taxonomy::InstalledInstanceStore;
    }

    return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void Taxonomy::InstalledInstanceStore::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

////////////////////////////////////////

void Taxonomy::InstalledInstanceStore::Shutdown()
{
	LockingHandle handle;

	m_fShutdown = true;

	if(SUCCEEDED(GrabControl( handle, NULL ))) // This will wait until the rest of the system has release the object.
	{
		(void)EnsureInSync();
	}
}

void Taxonomy::InstalledInstanceStore::Clean()
{
    m_lstInstances.clear();
    m_lstPackages .clear();
    m_lstSKUs     .clear();
}

HRESULT Taxonomy::InstalledInstanceStore::Load()
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::Load" );

    HRESULT hr;
	bool    fSystemSet = false;

	if(FAILED(LoadFromDisk    ( m_strStore.c_str() )) && 
	   FAILED(LoadFromRegistry(                    ))  )
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
	}

	for(InstalledInstanceIter it = m_lstSKUs.begin(); it != m_lstSKUs.end(); it++)
	{
		Taxonomy::Instance& data = it->m_inst;

		if(data.m_fSystem)
		{
			if(fSystemSet)
			{
				data.m_fSystem = false; // No other sku can be SYSTEM!!
			}
			else
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::Settings::SetMachineInfo( data ));
				fSystemSet = true;
			}
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::LoadFromDisk( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::LoadFromDisk" );

    HRESULT                  hr;
	CComPtr<MPC::FileStream> stream;


    Clean();

	__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeLoad ( szFile, stream ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadFromStream(         stream ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, local_CheckCRC( NULL, c_REG_CRC, stream ));


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::LoadFromRegistry()
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::LoadFromRegistry" );

    HRESULT          hr;
	MPC::RegKey      rkBase;
	CComPtr<IStream> stream;
	CComVariant      v;
	bool             fFound;


    Clean();

	__MPC_EXIT_IF_METHOD_FAILS(hr, local_OpenForRead( rkBase ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( v, fFound, c_REG_BACKUP ));
	if(!fFound)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertVariantToIStream( &v, &stream ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadFromStream          	   (      stream ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, local_CheckCRC( &rkBase, c_REG_CRC_BAK, stream ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::LoadFromStream( /*[in]*/ IStream* stream )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::LoadFromStream" );

    HRESULT                   hr;
	MPC::Serializer_IStream   streamGen ( stream    );
	MPC::Serializer_Buffering streamGen2( streamGen );
	DWORD                     dwVer;


	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 >> dwVer); if(dwVer != s_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 >> m_lstInstances);
	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 >> m_lstPackages );
	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 >> m_lstSKUs     );

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::InstalledInstanceStore::Save()
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::Save" );

    HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, SaveToDisk( m_strStore.c_str() ));

	//
	// Ignore failures on backup.
	//
	(void)SaveToRegistry();

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::SaveToDisk( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::SaveToDisk" );

    HRESULT                  hr;
	CComPtr<MPC::FileStream> stream;


	__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Init    ( szFile, stream ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, SaveToStream          (         stream ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Finalize( szFile, stream ));

	if(SUCCEEDED(SVC::SafeLoad( szFile, stream )))
	{
		(void)local_CreateCRC( NULL, c_REG_CRC, stream );
	}


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::SaveToRegistry()
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::SaveToRegistry" );

    HRESULT          hr;
	MPC::RegKey      rkBase;
	CComPtr<IStream> stream;
	CComVariant      v;


	__MPC_EXIT_IF_METHOD_FAILS(hr, local_OpenForWrite( rkBase ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal	   ( NULL, TRUE, &stream                  ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, SaveToStream           	   (              stream                  ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertIStreamToVariant(              stream, v               ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.put_Value            (                      v, c_REG_BACKUP ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, local_CreateCRC( &rkBase, c_REG_CRC_BAK, stream ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::SaveToStream( /*[in]*/ IStream* stream )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::SaveToStream" );

    HRESULT                   hr;
	MPC::Serializer_IStream   streamGen ( stream    );
	MPC::Serializer_Buffering streamGen2( streamGen );


	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 << s_dwVersion);

	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 << m_lstInstances);
	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 << m_lstPackages );
	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 << m_lstSKUs     );

	__MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2.Flush());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::InstalledInstanceStore::EnsureInSync()
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::EnsureInSync" );

    HRESULT hr;


    if(m_fLoaded == false)
    {
        m_fLoaded = true;

        if(FAILED(Load()))
        {
            Clean();
        }
    }

    if(m_fDirty == true)
    {
        m_fDirty = false;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Save());
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::InstalledInstanceStore::InUse_Lock( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_BEGIN_PROPERTY_PUT( "Taxonomy::InstalledInstanceStore::InUse_Lock", hr );

    InstalledInstanceIter it;
    bool                  fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, SKU_Find( ths, fFound, it ));
    if(fFound)
    {
        it->m_dwRef++;
    }

    __HCP_END_PROPERTY(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::InUse_Unlock( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_BEGIN_PROPERTY_PUT( "Taxonomy::InstalledInstanceStore::InUse_Unlock", hr );

    InstalledInstanceIter it;
    bool                  fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, SKU_Find( ths, fFound, it ));
    if(fFound && it->m_dwRef)
    {
        it->m_dwRef--;
    }

    __HCP_END_PROPERTY(hr);
}


HRESULT Taxonomy::InstalledInstanceStore::GrabControl( /*[in]*/ LockingHandle& handle,
                                                       /*[in]*/ Logger*        log    )
{
    HRESULT hr;

    handle.Attach( this, log );

    if(FAILED(hr = EnsureInSync()))
    {
        handle.Release();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::InstalledInstanceStore::Instance_GetList( /*[out]*/ InstanceIterConst& itBegin, /*[out]*/ InstanceIterConst& itEnd )
{
    itBegin = m_lstInstances.begin();
    itEnd   = m_lstInstances.end  ();

    return S_OK;
}

HRESULT Taxonomy::InstalledInstanceStore::Package_GetList( /*[out]*/ PackageIterConst& itBegin, /*[out]*/ PackageIterConst& itEnd )
{
    itBegin = m_lstPackages.begin();
    itEnd   = m_lstPackages.end  ();

    return S_OK;
}

HRESULT Taxonomy::InstalledInstanceStore::SKU_GetList( /*[out]*/ InstalledInstanceIterConst& itBegin, /*[out]*/ InstalledInstanceIterConst& itEnd )
{
    itBegin = m_lstSKUs.begin();
    itEnd   = m_lstSKUs.end  ();

    return S_OK;
}

////////////////////

HRESULT Taxonomy::InstalledInstanceStore::Instance_Find( /*[in ]*/ const Taxonomy::HelpSet& ths    ,
                                                         /*[out]*/ bool&                    fFound ,
                                                         /*[out]*/ InstanceIter&            it     )
{
    fFound = false;


    for(it = m_lstInstances.begin(); it != m_lstInstances.end(); it++)
    {
        if(it->m_ths == ths)
        {
            fFound = true;
            break;
        }
    }

    return S_OK;
}

HRESULT Taxonomy::InstalledInstanceStore::Instance_Add( /*[in ]*/ LPCWSTR         szFile ,
                                                        /*[in ]*/ const Instance& data   ,
                                                        /*[out]*/ bool&           fFound ,
                                                        /*[out]*/ InstanceIter&   it     )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::Instance_Add" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Instance_Find( data.m_ths, fFound, it ));
    if(!fFound)
    {
        it = m_lstInstances.insert( m_lstInstances.end(), data ); it->SetTimeStamp();

		__MPC_EXIT_IF_METHOD_FAILS(hr, it->Import( szFile, NULL ));

        m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::Instance_Remove( /*[in]*/ InstanceIter& it )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::Instance_Remove" );

    HRESULT      hr;
    MPC::wstring strFileDst;
    bool         fFound;


    //
    // Uninstall SKU.
    //
    {
        InstalledInstanceIter itSKU;

        __MPC_EXIT_IF_METHOD_FAILS(hr, SKU_Find( it->m_ths, fFound, itSKU ));
        if(fFound)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, SKU_Remove( itSKU ));
        }
    }

    //
    // Remove any built-in package from this instance.
    //
    {
		Logger      logTmp;
        Logger*     log = (m_log ? m_log : &logTmp);
        PackageIter itPackage;

        for(itPackage = m_lstPackages.begin(); itPackage != m_lstPackages.end(); )
        {
            PackageIter itPackage2 =  itPackage++; // Copy iterator to protect against deletion.
            Package&    pkg        = *itPackage2;

            if(pkg.m_fBuiltin && it->Match( pkg ))
            {
                (void)pkg.Remove( *log );

                m_lstPackages.erase( itPackage2 );

                m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
            }
        }
    }


	__MPC_EXIT_IF_METHOD_FAILS(hr, it->Remove());


    m_lstInstances.erase( it );


    m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::InstalledInstanceStore::Package_Find( /*[in ]*/ const Package& pkg    ,
                                                        /*[out]*/ bool&          fFound ,
                                                        /*[out]*/ PackageIter&   it     )
{
    fFound = false;


    for(it = m_lstPackages.begin(); it != m_lstPackages.end(); it++)
    {
        if(it->Compare( pkg ) == 0)
        {
            fFound = true;
            break;
        }
    }

    return S_OK;
}

HRESULT Taxonomy::InstalledInstanceStore::Package_Add( /*[in ]*/ LPCWSTR                  szFile       ,
                                                       /*[in ]*/ MPC::Impersonation*      imp          ,
                                                       /*[in ]*/ const Taxonomy::HelpSet* ths          ,
                                                       /*[in ]*/ bool                     fInsertAtTop ,
                                                       /*[out]*/ bool&                    fFound       ,
                                                       /*[out]*/ PackageIter&             it           )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::Package_Add" );

    HRESULT hr;
	Logger  logTmp;
	Logger* log = (m_log ? m_log : &logTmp);
    Package pkg;
    long    lSequence = 1;


    if(ths)
    {
        WCHAR rgLCID[64];

        pkg.m_fBuiltin    = true;
        pkg.m_strSKU      =        ths->GetSKU     ();
        pkg.m_strLanguage = _ltow( ths->GetLanguage(), rgLCID, 10 );
    }

    //
    // Found a suitable sequence number.
    //

    for(it = m_lstPackages.begin(); it != m_lstPackages.end(); it++)
    {
        if(lSequence <= it->m_lSequence) lSequence = it->m_lSequence + 1;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Import      ( *log, szFile, lSequence, imp ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Authenticate( *log                         ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Package_Find( pkg, fFound, it ));
    if(fFound)
    {
		if(it->m_dwCRC != pkg.m_dwCRC) // CRC differs, different package?
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, Package_Remove( it ));

			fFound = false;
		}
	}

	if(fFound)
	{
        pkg.m_fTemporary = true; // Delete the copy...
    }
    else
    {
        if (fInsertAtTop)
        {
            it = m_lstPackages.insert( m_lstPackages.begin(), pkg );
        }
        else
        {
            it = m_lstPackages.insert( m_lstPackages.end(), pkg );
        }

        m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
    }

	//
	// Check if have an installed SKU that actually matches this package.
	//
	{
        InstalledInstanceIter itSKU;

        for(itSKU = m_lstSKUs.begin(); itSKU != m_lstSKUs.end(); itSKU++)
        {
            InstalledInstance& sku = *itSKU;

			if(sku.m_inst.Match( *it ))
			{
				break;
			}
		}
		if(itSKU == m_lstSKUs.end())
		{
			log->WriteLog( -1, L"\nWARNING: the package cannot be applied to any of the installed SKUs\n\n" );
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::Package_Remove( /*[in]*/ PackageIter& it )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::Package_Remove" );

    HRESULT hr;
	Logger  logTmp;
	Logger* log = (m_log ? m_log : &logTmp);
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, it->Remove( *log ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, State_InvalidatePackage( it->m_lSequence ));

    m_lstPackages.erase( it );
    m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::InstalledInstanceStore::SKU_Find( /*[in ]*/ const Taxonomy::HelpSet& ths    ,
                                                    /*[out]*/ bool&                    fFound ,
                                                    /*[out]*/ InstalledInstanceIter&   it     )
{
    fFound = false;


    for(it = m_lstSKUs.begin(); it != m_lstSKUs.end(); it++)
    {
        if(it->m_inst.m_ths == ths)
        {
            fFound = true;
            break;
        }
    }

    return S_OK;
}

HRESULT Taxonomy::InstalledInstanceStore::SKU_Add( /*[in ]*/ const Instance&        data   ,
                                                   /*[out]*/ bool&                  fFound ,
                                                   /*[out]*/ InstalledInstanceIter& it     )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::SKU_Add" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, SKU_Find( data.m_ths, fFound, it ));
    if(!fFound)
    {
        it = m_lstSKUs.insert( m_lstSKUs.end() );

        it->m_inst = data; it->m_inst.SetTimeStamp();

        m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

        __MPC_EXIT_IF_METHOD_FAILS(hr, it->InstallFiles( /*fAlsoHelpFiles*/true, this ));

        //
        // Propagate change to the offline cache.
        //
        if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Import( it->m_inst )))
        {
            (void)OfflineCache::Root::s_GLOBAL->Flush();
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::SKU_Updated( /*[in]*/ InstalledInstanceIter& it )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::SKU_Updated" );

    HRESULT hr;
    bool    fFound;


    it->m_inst.SetTimeStamp();
    m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());


    //
    // Propagate change to the offline cache.
    //
    {
        if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Import( it->m_inst )))
        {
            (void)OfflineCache::Root::s_GLOBAL->Flush();
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::SKU_Remove( /*[in]*/ InstalledInstanceIter& it )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::SKU_Remove" );

    HRESULT hr;


    if(m_dwRef)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BUSY);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, it->UninstallFiles( /*fAlsoHelpFiles*/true ));


    //
    // Propagate change to the offline cache.
    //
    {
        if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Remove( it->m_inst.m_ths )))
        {
            (void)OfflineCache::Root::s_GLOBAL->Flush();
        }
    }

    m_lstSKUs.erase( it );
    m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::InstalledInstanceStore::State_InvalidateSKU( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ bool fAlsoDatabase )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::State_InvalidateSKU" );

    HRESULT               hr;
    InstalledInstanceIter itSKU;


    for(itSKU = m_lstSKUs.begin(); itSKU != m_lstSKUs.end(); itSKU++)
    {
        InstalledInstance& sku = *itSKU;

        if(sku.m_inst.m_ths == ths)
        {
            ProcessedPackageIter itProcessedPackage;

            if(fAlsoDatabase) sku.m_fInvalidated = true;

            for(itProcessedPackage = sku.m_lst.begin(); itProcessedPackage != sku.m_lst.end(); itProcessedPackage++)
            {
                itProcessedPackage->m_fProcessed = false;
            }
        }
    }

    m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::InstalledInstanceStore::State_InvalidatePackage( /*[in]*/ long lSequence )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::State_InvalidatePackage" );

    HRESULT               hr;
    InstalledInstanceIter itSKU;


    for(itSKU = m_lstSKUs.begin(); itSKU != m_lstSKUs.end(); itSKU++)
    {
        InstalledInstance&   sku = *itSKU;
        ProcessedPackageIter itProcessedPackage;

        for(itProcessedPackage = sku.m_lst.begin(); itProcessedPackage != sku.m_lst.end(); itProcessedPackage++)
        {
            if(itProcessedPackage->m_lSequence == lSequence) break;
        }

        if(itProcessedPackage != sku.m_lst.end())
        {
            sku.m_lst.erase( itProcessedPackage );
            sku.m_fInvalidated = true;

            for(itProcessedPackage = sku.m_lst.begin(); itProcessedPackage != sku.m_lst.end(); itProcessedPackage++)
            {
                itProcessedPackage->m_fProcessed = false;
            }

            m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::InstalledInstanceStore::MakeReady( /*[in]*/ InstallationEngine& engine, /*[in]*/ bool fNoOp, /*[in]*/ bool& fWorkToProcess )
{
    __HCP_FUNC_ENTRY( "Taxonomy::InstalledInstanceStore::MakeReady" );

    HRESULT hr;
	int     iRepeat  = 0;
    bool    fRepeat  = true;
    bool    fRecurse = false;

    //
    // Already processing the list of packages.
    //
    if(m_dwRecurse)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    fRecurse = true;
    m_dwRecurse++;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    fWorkToProcess = false;

    while(fRepeat && IsShutdown() == false)
    {
        InstalledInstanceIter itSKU;

		// If we are rebuilding too many times, abort the process, to protect against endless looping.
		if(iRepeat++ >= 5) break;

        fRepeat = false;

        for(itSKU = m_lstSKUs.begin(); itSKU != m_lstSKUs.end() && IsShutdown() == false; itSKU++)
        {
            InstalledInstance& sku                 = *itSKU;
			bool               fProcessedSomething = false;

			engine.ResetModificationFlags();

            if(sku.m_fInvalidated)
            {
                if(fNoOp)
                {
                    fWorkToProcess = true;
                }
                else
                {
                    if(m_log)
                    {
                        m_log->WriteLog( -1, L"\nRestoring original database for %s (Language: %d)\n\n", sku.m_inst.m_ths.GetSKU(), sku.m_inst.m_ths.GetLanguage() );
                    }

                    __MPC_EXIT_IF_METHOD_FAILS(hr, sku.UninstallFiles( /*fAlsoHelpFiles*/false       ));
                    __MPC_EXIT_IF_METHOD_FAILS(hr, sku.InstallFiles  ( /*fAlsoHelpFiles*/false, NULL ));

                    sku.m_fInvalidated      = false;
					sku.m_fRecreateCache 	= true;
					sku.m_fCreateIndex      = true;
					sku.m_fCreateIndexForce = true;
                    m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

                    fRepeat = true;
                }
            }
            else
            {
                PackageIter itPackage;

                for(itPackage = m_lstPackages.begin(); itPackage != m_lstPackages.end(); itPackage++)
                {
                    Package& pkg = *itPackage;

                    if(sku.m_inst.Match( pkg ))
                    {
                        ProcessedPackageIter itProcessedPackage;

                        for(itProcessedPackage = sku.m_lst.begin(); itProcessedPackage != sku.m_lst.end(); itProcessedPackage++)
                        {
                            if(itProcessedPackage->m_lSequence == pkg.m_lSequence) break;
                        }
                        if(itProcessedPackage == sku.m_lst.end())
                        {
                            itProcessedPackage = sku.m_lst.insert( sku.m_lst.end() );

                            itProcessedPackage->m_lSequence = pkg.m_lSequence;

                            m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
                        }

                        {
                            ProcessedPackage& ppkg = *itProcessedPackage;

                            if(ppkg.m_fDisabled ) continue;
                            if(ppkg.m_fProcessed) continue;

                            if(fNoOp)
                            {
                                fWorkToProcess = true;
                            }
                            else
                            {
                                hr = engine.ProcessPackage( sku, pkg );
                                if(FAILED(hr))
                                {
									if(IsShutdown())
									{
										State_InvalidateSKU( sku.m_inst.m_ths, /*fAlsoDatabase*/true );
										
										__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
									}

                                    if(sku.m_fInvalidated)
                                    {
                                        ; // Already invalidated.
                                    }
                                    else
                                    {
                                        ppkg.m_fDisabled = true;

                                        sku.m_fInvalidated = true;
										iRepeat            = 0; // Reset repeat counter on a bad package.

                                        for(itProcessedPackage = sku.m_lst.begin(); itProcessedPackage != sku.m_lst.end(); itProcessedPackage++)
                                        {
                                            itProcessedPackage->m_fProcessed = false;
                                        }
                                    }

                                    fRepeat = true;
                                }
                                else
                                {
                                    if(engine.m_fTaxonomyModified)
                                    {
                                        //
                                        // Update the timestamp.
                                        //
                                        sku.m_inst.SetTimeStamp();
                                    }

                                    ppkg.m_fProcessed   = true;
									fProcessedSomething = true;
                                }

                                m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
                            }
                        }
                    }

                    if(fRepeat) break;
                }
            }

			if(!sku.m_fInvalidated)
			{
				if(engine.m_fTaxonomyModified)
				{
					sku.m_fRecreateCache = true;

					m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
				}

				if(fProcessedSomething)
				{
					sku.m_fCreateIndex      = true;
					sku.m_fCreateIndexForce = engine.m_fRecreateIndex;
					
					m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
				}
			}

            if(fRepeat) break;

			////////////////////

			if(sku.m_fCreateIndex)
			{
				if(FAILED(hr = engine.RecreateIndex( sku, sku.m_fCreateIndexForce )))
				{
					;
				}

				sku.m_fCreateIndex      = false;
				sku.m_fCreateIndexForce = false;

				m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
			}

			if(sku.m_fRecreateCache)
			{
				if(SUCCEEDED(Taxonomy::Cache::s_GLOBAL->Erase      ( sku.m_inst.m_ths )) &&
				   SUCCEEDED(Taxonomy::Cache::s_GLOBAL->PrePopulate( sku.m_inst.m_ths ))  )
				{
					;
				}

				//
				// Propagate settings to the offline cache.
				//
				if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->SetReady( true )))
				{
					(void)OfflineCache::Root::s_GLOBAL->Flush();
				}

				sku.m_fRecreateCache = false;

				m_fDirty = true; __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
			}
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fRecurse) m_dwRecurse--;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\instancebase.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    InstanceBase.cpp


Abstract:
    This file contains the implementation of the Taxonomy::InstanceBase class,
    which controls the set of files for a specific SKU.

Revision History:
    Davide Massarenti   (Dmassare)  24/03/2001
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

Taxonomy::InstanceBase::InstanceBase()
{
                         // Taxonomy::HelpSet m_ths;
                         // MPC::wstring      m_strDisplayName;
                         // MPC::wstring      m_strProductID;
                         // MPC::wstring      m_strVersion;
                         //
    m_fDesktop  = false; // bool              m_fDesktop;
    m_fServer   = false; // bool              m_fServer;
    m_fEmbedded = false; // bool              m_fEmbedded;
}

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::InstanceBase& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream >> val.m_ths           )) &&
       SUCCEEDED(hr = (stream >> val.m_strDisplayName)) &&
       SUCCEEDED(hr = (stream >> val.m_strProductID  )) &&
       SUCCEEDED(hr = (stream >> val.m_strVersion    )) &&

       SUCCEEDED(hr = (stream >> val.m_fDesktop      )) &&
       SUCCEEDED(hr = (stream >> val.m_fServer       )) &&
       SUCCEEDED(hr = (stream >> val.m_fEmbedded     ))  )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::InstanceBase& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream << val.m_ths           )) &&
       SUCCEEDED(hr = (stream << val.m_strDisplayName)) &&
       SUCCEEDED(hr = (stream << val.m_strProductID  )) &&
       SUCCEEDED(hr = (stream << val.m_strVersion    )) &&

       SUCCEEDED(hr = (stream << val.m_fDesktop      )) &&
       SUCCEEDED(hr = (stream << val.m_fServer       )) &&
       SUCCEEDED(hr = (stream << val.m_fEmbedded     ))  )
    {
        hr = S_OK;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////

bool Taxonomy::InstanceBase::Match( /*[in]*/  LPCWSTR szSKU      ,
                                    /*[in]*/  LPCWSTR szLanguage )
{
    while(1)
    {
        if(STRINGISPRESENT(szSKU))
        {
            if(!_wcsicmp( szSKU, L"All" ))
            {
                ;
            }
            else if(!_wcsicmp( szSKU, L"Server" ))
            {
                if(m_fServer == false) break;
            }
            else if(!_wcsicmp( szSKU, L"Desktop" ))
            {
                if(m_fDesktop == false) break;
            }
            else if(!_wcsicmp( szSKU, L"Embedded" ))
            {
                if(m_fEmbedded == false) break;
            }
            else
            {
                if(_wcsicmp( szSKU, m_ths.GetSKU() ) != 0) break;
            }
        }

        if(STRINGISPRESENT(szLanguage))
        {
            if(!_wcsicmp( szLanguage, L"All" ))
            {
                ;
            }
            else
            {
                if(_wtol( szLanguage ) != m_ths.GetLanguage()) break;
            }
        }

        return true;
    }

    return false;
}

bool Taxonomy::InstanceBase::Match( /*[in]*/ const Package& pkg )
{
    return Match( pkg.m_strSKU.c_str(), pkg.m_strLanguage.c_str() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\instance.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Instance.cpp


Abstract:
    This file contains the implementation of the Taxonomy::Instance class,
    which controls the set of files for a specific SKU.

Revision History:
    Davide Massarenti   (Dmassare)  24/03/2001
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

Taxonomy::Instance::Instance()
{
    m_fSystem      = false; // bool         m_fSystem;
    m_fMUI         = false; // bool         m_fMUI;
    m_fExported    = false; // bool         m_fExported;
    m_dLastUpdated = 0;     // DATE         m_dLastUpdated;
                            //
                            // MPC::wstring m_strLocation;
                            // MPC::wstring m_strHelpFiles;
                            // MPC::wstring m_strDatabaseDir;
                            // MPC::wstring m_strDatabaseFile;
                            // MPC::wstring m_strIndexFile;
                            // MPC::wstring m_strIndexDisplayName;
}

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::Instance& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream >> (InstanceBase&)val   	  )) &&
													  	  
       SUCCEEDED(hr = (stream >> val.m_fSystem        	  )) &&
       SUCCEEDED(hr = (stream >> val.m_fMUI			  	  )) &&
       SUCCEEDED(hr = (stream >> val.m_fExported	  	  )) &&
       SUCCEEDED(hr = (stream >> val.m_dLastUpdated	  	  )) &&
													  	  
       SUCCEEDED(hr = (stream >> val.m_strSystem	  	  )) &&
       SUCCEEDED(hr = (stream >> val.m_strHelpFiles	  	  )) &&
       SUCCEEDED(hr = (stream >> val.m_strDatabaseDir 	  )) &&
       SUCCEEDED(hr = (stream >> val.m_strDatabaseFile	  )) &&
       SUCCEEDED(hr = (stream >> val.m_strIndexFile       )) &&
       SUCCEEDED(hr = (stream >> val.m_strIndexDisplayName))  )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::Instance& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream << (InstanceBase&)val   	  )) &&
													  	  
       SUCCEEDED(hr = (stream << val.m_fSystem        	  )) &&
       SUCCEEDED(hr = (stream << val.m_fMUI			  	  )) &&
       SUCCEEDED(hr = (stream << val.m_fExported	  	  )) &&
       SUCCEEDED(hr = (stream << val.m_dLastUpdated	  	  )) &&
													  	  
       SUCCEEDED(hr = (stream << val.m_strSystem	  	  )) &&
       SUCCEEDED(hr = (stream << val.m_strHelpFiles	  	  )) &&
       SUCCEEDED(hr = (stream << val.m_strDatabaseDir 	  )) &&
       SUCCEEDED(hr = (stream << val.m_strDatabaseFile	  )) &&
       SUCCEEDED(hr = (stream << val.m_strIndexFile       )) &&
       SUCCEEDED(hr = (stream << val.m_strIndexDisplayName))  )
    {
        hr = S_OK;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////

static const DWORD l_dwVersion = 0x01534854; // THS 01

HRESULT Taxonomy::Instance::LoadFromStream( /*[in]*/ IStream *pStm )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Instance::LoadFromStream" );

    HRESULT                   hr;
    MPC::Serializer_IStream   stream ( pStm   );
    MPC::Serializer_Buffering stream2( stream );
    DWORD                     dwVer;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream2 >> dwVer); if(dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream2 >> *this);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Instance::SaveToStream( /*[in]*/ IStream* pStm ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Instance::SaveToStream" );

    HRESULT                   hr;
    MPC::Serializer_IStream   stream ( pStm   );
    MPC::Serializer_Buffering stream2( stream );


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream2 << l_dwVersion);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream2 << *this      );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream2.Flush());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void Taxonomy::Instance::SetTimeStamp()
{
    m_dLastUpdated = MPC::GetLocalTime();
}

HRESULT Taxonomy::Instance::GetFileName( /*[out]*/ MPC::wstring& strFile )
{
    WCHAR rgBuf[MAX_PATH]; _snwprintf( rgBuf, MAXSTRLEN(rgBuf), L"%s\\instance_%s_%ld.cab", HC_ROOT_HELPSVC_PKGSTORE, m_ths.GetSKU(), m_ths.GetLanguage() ); rgBuf[MAXSTRLEN(rgBuf)] = 0;

    return MPC::SubstituteEnvVariables( strFile = rgBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\mergedhhk.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MergedHHK.cpp

Abstract:
    This file contains the implementation of the classes used to parse and
    process HHK files.

Revision History:
    Davide Massarenti   (Dmassare)  12/18/99
        created

******************************************************************************/

#include <stdafx.h>

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
#define DEBUG_REGKEY  HC_REGISTRY_HELPSVC L"\\Debug"
#define DEBUG_DUMPHHK L"DUMPHHK"

static bool m_fInitialized = false;
static bool m_fDumpHHK     = false;

static void Local_ReadDebugSettings()
{
	__HCP_FUNC_ENTRY( "Local_ReadDebugSettings" );

	HRESULT     hr;
	MPC::RegKey rkBase;
	bool        fFound;

	if(m_fInitialized) __MPC_FUNC_LEAVE;

	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.SetRoot( HKEY_LOCAL_MACHINE ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Attach ( DEBUG_REGKEY       ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.Exists ( fFound             ));

	if(fFound)
	{
		CComVariant vValue;
				
		__MPC_EXIT_IF_METHOD_FAILS(hr, rkBase.get_Value( vValue, fFound, DEBUG_DUMPHHK ));
		if(fFound && vValue.vt == VT_I4)
		{
			m_fDumpHHK = vValue.lVal ? true : false;
		}
	}

	m_fInitialized = true;

	__HCP_FUNC_CLEANUP;
}

static void Local_DumpStream( /*[in]*/ LPCWSTR szFile, /*[in]*/ IStream* streamIN, /*[in]*/ HRESULT hrIN )
{
	__HCP_FUNC_ENTRY( "Local_DumpStream" );

	static int               iSeq = 0;
	HRESULT                  hr;
	CComPtr<MPC::FileStream> streamOUT;

	Local_ReadDebugSettings();

	if(m_fDumpHHK)
    {
		USES_CONVERSION;

        WCHAR 		   rgBuf [MAX_PATH];
		CHAR  		   rgBuf2[      64];
		ULARGE_INTEGER liWritten;

        swprintf( rgBuf , L"C:\\TMP\\dump_%d.hhk", iSeq++        );
		sprintf ( rgBuf2, "%s\n"                 , W2A( szFile ) );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamOUT ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, streamOUT->InitForWrite( rgBuf ));

		streamOUT->Write( rgBuf2, strlen(rgBuf2), &liWritten.LowPart  );

		if(SUCCEEDED(hrIN) && streamIN)
		{
			STATSTG        statstg;
			LARGE_INTEGER  li;
			ULARGE_INTEGER liRead;

			streamIN->Stat( &statstg, STATFLAG_NONAME );

			streamIN->CopyTo( streamOUT, statstg.cbSize, &liRead, &liWritten );

			li.LowPart  = 0;
			li.HighPart = 0;
			streamIN->Seek( li, STREAM_SEEK_SET, NULL );
		}
    }

	__HCP_FUNC_CLEANUP;
}
#endif

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// ENTITY TABLE SWIPED FROM IE

static const struct
{
    const char* szName;
    int         ch;
} rgEntities[] =
{
        "AElig",        '\306',     // capital AE diphthong (ligature)
        "Aacute",       '\301',     // capital A, acute accent
        "Acirc",        '\302',     // capital A, circumflex accent
        "Agrave",       '\300',     // capital A, grave accent
        "Aring",        '\305',     // capital A, ring
        "Atilde",       '\303',     // capital A, tilde
        "Auml",         '\304',     // capital A, dieresis or umlaut mark
        "Ccedil",       '\307',     // capital C, cedilla
        "Dstrok",       '\320',     // capital Eth, Icelandic
        "ETH",          '\320',     // capital Eth, Icelandic
        "Eacute",       '\311',     // capital E, acute accent
        "Ecirc",        '\312',     // capital E, circumflex accent
        "Egrave",       '\310',     // capital E, grave accent
        "Euml",         '\313',     // capital E, dieresis or umlaut mark
        "Iacute",       '\315',     // capital I, acute accent
        "Icirc",        '\316',     // capital I, circumflex accent
        "Igrave",       '\314',     // capital I, grave accent
        "Iuml",         '\317',     // capital I, dieresis or umlaut mark
        "Ntilde",       '\321',     // capital N, tilde
        "Oacute",       '\323',     // capital O, acute accent
        "Ocirc",        '\324',     // capital O, circumflex accent
        "Ograve",       '\322',     // capital O, grave accent
        "Oslash",       '\330',     // capital O, slash
        "Otilde",       '\325',     // capital O, tilde
        "Ouml",         '\326',     // capital O, dieresis or umlaut mark
        "THORN",        '\336',     // capital THORN, Icelandic
        "Uacute",       '\332',     // capital U, acute accent
        "Ucirc",        '\333',     // capital U, circumflex accent
        "Ugrave",       '\331',     // capital U, grave accent
        "Uuml",         '\334',     // capital U, dieresis or umlaut mark
        "Yacute",       '\335',     // capital Y, acute accent
        "aacute",       '\341',     // small a, acute accent
        "acirc",        '\342',     // small a, circumflex accent
        "acute",        '\264',     // acute accent
        "aelig",        '\346',     // small ae diphthong (ligature)
        "agrave",       '\340',     // small a, grave accent
        "amp",          '\046',     // ampersand
        "aring",        '\345',     // small a, ring
        "atilde",       '\343',     // small a, tilde
        "auml",         '\344',     // small a, dieresis or umlaut mark
        "brkbar",       '\246',     // broken vertical bar
        "brvbar",       '\246',     // broken vertical bar
        "ccedil",       '\347',     // small c, cedilla
        "cedil",        '\270',     // cedilla
        "cent",         '\242',     // small c, cent
        "copy",         '\251',     // copyright symbol (proposed 2.0)
        "curren",       '\244',     // currency symbol
        "deg",          '\260',     // degree sign
        "die",          '\250',     // umlaut (dieresis)
        "divide",       '\367',     // divide sign
        "eacute",       '\351',     // small e, acute accent
        "ecirc",        '\352',     // small e, circumflex accent
        "egrave",       '\350',     // small e, grave accent
        "eth",          '\360',     // small eth, Icelandic
        "euml",         '\353',     // small e, dieresis or umlaut mark
        "frac12",       '\275',     // fraction 1/2
        "frac14",       '\274',     // fraction 1/4
        "frac34",       '\276',     // fraction 3/4*/
        "gt",           '\076',     // greater than
        "hibar",        '\257',     // macron accent
        "iacute",       '\355',     // small i, acute accent
        "icirc",        '\356',     // small i, circumflex accent
        "iexcl",        '\241',     // inverted exclamation
        "igrave",       '\354',     // small i, grave accent
        "iquest",       '\277',     // inverted question mark
        "iuml",         '\357',     // small i, dieresis or umlaut mark
        "laquo",        '\253',     // left angle quote
        "lt",           '\074',     // less than
        "macr",         '\257',     // macron accent
        "micro",        '\265',     // micro sign
        "middot",       '\267',     // middle dot
        "nbsp",         '\240',     // non-breaking space (proposed 2.0)
        "not",          '\254',     // not sign
        "ntilde",       '\361',     // small n, tilde
        "oacute",       '\363',     // small o, acute accent
        "ocirc",        '\364',     // small o, circumflex accent
        "ograve",       '\362',     // small o, grave accent
        "ordf",         '\252',     // feminine ordinal
        "ordm",         '\272',     // masculine ordinal
        "oslash",       '\370',     // small o, slash
        "otilde",       '\365',     // small o, tilde
        "ouml",         '\366',     // small o, dieresis or umlaut mark
        "para",         '\266',     // paragraph sign
        "plusmn",       '\261',     // plus minus
        "pound",        '\243',     // pound sterling
        "quot",         '"',        // double quote
        "raquo",        '\273',     // right angle quote
        "reg",          '\256',     // registered trademark (proposed 2.0)
        "sect",         '\247',     // section sign
        "shy",          '\255',     // soft hyphen (proposed 2.0)
        "sup1",         '\271',     // superscript 1
        "sup2",         '\262',     // superscript 2
        "sup3",         '\263',     // superscript 3
        "szlig",        '\337',     // small sharp s, German (sz ligature)
        "thorn",        '\376',     // small thorn, Icelandic
        "times",        '\327',     // times sign
        "trade",        '\231',     // trademark sign
        "uacute",       '\372',     // small u, acute accent
        "ucirc",        '\373',     // small u, circumflex accent
        "ugrave",       '\371',     // small u, grave accent
        "uml",          '\250',     // umlaut (dieresis)
        "uuml",         '\374',     // small u, dieresis or umlaut mark
        "yacute",       '\375',     // small y, acute accent
        "yen",          '\245',     // yen
        "yuml",         '\377',     // small y, dieresis or umlaut mark
        0, 0
};

static BOOL ReplaceEscapes( PCSTR pszSrc, PSTR pszDst )
{
    if(StrChrA( pszSrc, '&' ) == NULL)
	{
		// If we get here, there are no escape sequences, so copy the string and return.

		if(pszDst != pszSrc) strcpy( pszDst, pszSrc );
		return FALSE;   // nothing changed
	}

    while(*pszSrc)
    {
        if(IsDBCSLeadByte(*pszSrc))
        {
            if(pszSrc[1])
            {
                *pszDst++ = *pszSrc++;
                *pszDst++ = *pszSrc++;
            }
            else
            {
                // leadbyte followed by 0; invalid!
                *pszDst++ = '?';
                break;
            }
        }
        else if(*pszSrc == '&')
        {
            pszSrc++;

            if(*pszSrc == '#')
            {
                // SGML/HTML character entity (decimal)
                pszSrc++;

                for(int val = 0; *pszSrc && *pszSrc != ';'; pszSrc++)
                {
                    if(*pszSrc >= '0' && *pszSrc <= '9')
                    {
                        val = val * 10 + *pszSrc - '0';
                    }
                    else
                    {
                        while(*pszSrc && *pszSrc != ';')
                        {
                            pszSrc++;
                        }
                        break;
                    }
                }

                if(val)
                {
                    *pszDst++ = (char)val;
                }
            }
            else if(*pszSrc)
            {
                char szEntityName[256];
                int  count = 0;

                for(PSTR p = szEntityName; *pszSrc && *pszSrc != ';' && *pszSrc != ' ' && count < sizeof(szEntityName);)
                {
                    *p++ = *pszSrc++;
                    count++;
                }
                *p = 0;

                if(*pszSrc == ';') pszSrc++;

                for(int i = 0; rgEntities[i].szName; i++)
                {
                    if(!strcmp(szEntityName, rgEntities[i].szName))
                    {
                        if(rgEntities[i].ch)
                        {
                            *pszDst++ = (char)rgEntities[i].ch;
                        }
                        break;
                    }
                }
                if(!rgEntities[i].szName)
                {
                    // illegal entity name, put in a block character
                    *pszDst++ = '?';
                }
            }
        }
        else
        {
            // just your usual character...
            *pszDst++ = *pszSrc++;
        }
    }

    *pszDst = 0;

    return TRUE;
}

static void ReplaceCharactersWithEntity( /*[out]*/ MPC::string& strValue  ,
										 /*[out]*/ MPC::string& strBuffer )
{
	LPCSTR szToEscape = strValue.c_str();
	CHAR   ch;
	
	strBuffer.erase();

	while((ch = *szToEscape++))
	{
		switch(ch)
		{
		case '&': strBuffer += "&amp;" ; break;
		case '"': strBuffer += "&quot;"; break;
		case '<': strBuffer += "&lt;"  ; break;
		case '>': strBuffer += "&gt;"  ; break;
		default:  strBuffer += ch      ; break;
		}
	}

	strValue = strBuffer;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

static const char txtBeginList          [] = "UL>";
static const char txtEndList            [] = "/UL>";
static const char txtBeginListItem      [] = "LI";
static const char txtBeginObject        [] = "OBJECT";
static const char txtEndObject          [] = "/OBJECT";

static const char txtParam              [] = "param name";

static const char txtValue              [] = "value";
static const char txtParamKeyword       [] = "Keyword";
static const char txtParamName          [] = "Name";
static const char txtParamSeeAlso       [] = "See Also";
static const char txtParamLocal         [] = "Local";

static const char txtType               [] = "type";
static const char txtSiteMapObject      [] = "text/sitemap";

/////////////////////////////////////////////////////////////////////////////

static const char txtHeader[] = "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n"                            \
                                "<HTML>\n"                                                                      \
                                "<HEAD>\n"                                                                      \
                                "<meta name=\"GENERATOR\" content=\"Microsoft&reg; HTML Help Workshop 4.1\">\n" \
                                "<!-- Sitemap 1.0 -->\n"                                                        \
                                "</HEAD><BODY>\n"                                                               \
                                "<OBJECT type=\"text/site properties\">\n"                                      \
                                "\t<param name=\"FrameName\" value=\"HelpCtrContents\">\n"                      \
                                "</OBJECT>\n"                                                                   \
                                "<UL>\n";

static const char txtTail[] = "</UL>\n"          \
                              "</BODY></HTML>\n";

/////////////////////////////////////////////////////////////////////////////

static const char txtIndent             [] = "\t";

static const char txtNewSection_Open    [] = "\t<LI> <OBJECT type=\"text/sitemap\">\n";
static const char txtNewSection_Close   [] = "\t\t</OBJECT>\n";

static const char txtNewSubSection_Open [] = "\t<UL>\n";
static const char txtNewSubSection_Close[] = "\t</UL>\n";

static const char txtNewParam_Name      [] = "\t\t<param name=\"Name\" value=\"";
static const char txtNewParam_Local     [] = "\t\t<param name=\"Local\" value=\"";
static const char txtNewParam_SeeAlso   [] = "\t\t<param name=\"See Also\" value=\"";
static const char txtNewParam_Close     [] = "\">\n";

static const char txtIndexFirstLevel    [] = "hcp://system/errors/indexfirstlevel.htm";

/////////////////////////////////////////////////////////////////////////////

BOOL HHK::Reader::s_fDBCSSystem = (BOOL)::GetSystemMetrics( SM_DBCSENABLED );
LCID HHK::Reader::s_lcidSystem  =       ::GetUserDefaultLCID();

/////////////////////////////////////////////////////////////////////////////

static void ConvertToAnsi( MPC::string& strANSI, const MPC::wstring& strUNICODE )
{
    USES_CONVERSION;

    strANSI = W2A( strUNICODE.c_str() );
}


////////////////////////////////////////////////////////////////////////////////

void HHK::Entry::MergeURLs( const HHK::Entry& entry )
{
    Entry::UrlIterConst itUrlNew;
    Entry::UrlIter      itUrlOld;

    //
    // Just copy unique URLs.
    //
    for(itUrlNew = entry.m_lstUrl.begin(); itUrlNew != entry.m_lstUrl.end(); itUrlNew++)
    {
        bool fInsert = true;

        for(itUrlOld = m_lstUrl.begin(); itUrlOld != m_lstUrl.end(); itUrlOld++)
        {
            int res = Reader::StrColl( (*itUrlOld).c_str(), (*itUrlNew).c_str() );

            if(res == 0)
            {
                // Same URL, skip it.
                fInsert = false;
                break;
            }

            if(res > 0)
            {
                //
                // Old > New, insert New before Old.
                //
                break;
            }
        }

        //
        // If fInsert is set, we need to insert "New" just before "Old".
        //
        // This work also in the case itUrlOld == end().
        //
        if(fInsert) m_lstUrl.insert( itUrlOld, *itUrlNew );
    }
}


HHK::Section::Section()
{
}

HHK::Section::~Section()
{
    MPC::CallDestructorForAll( m_lstSeeAlso );
}

void HHK::Section::MergeURLs( const Entry& entry )
{
    Section::EntryIter itEntry;
    bool               fInsert = true;


    for(itEntry = m_lstEntries.begin(); itEntry != m_lstEntries.end(); itEntry++)
    {
        Entry& entryOld = *itEntry;
        int    res      = Reader::StrColl( entryOld.m_strTitle.c_str(), entry.m_strTitle.c_str() );

        if(res == 0)
        {
            // Same title, just merge the URLs.
            entryOld.MergeURLs( entry );
            fInsert = false;
            break;
        }

        if(res > 0)
        {
            //
            // Old > New, insert New before Old.
            //
            break;
        }
    }

    //
    // Make a copy, insert it at the right position...
    //
    if(fInsert) m_lstEntries.insert( itEntry, entry );
}

void HHK::Section::MergeSeeAlso( const Section& sec )
{
    Section::SectionIterConst itSec;
    Section::SectionIter      itSecOld;
    Section*                  subsec;
    Section*                  subsecOld;
    int                       res;


    for(itSec = sec.m_lstSeeAlso.begin(); itSec != sec.m_lstSeeAlso.end(); itSec++)
    {
        bool fInsert = true;

        subsec = *itSec;

        for(itSecOld = m_lstSeeAlso.begin(); itSecOld != m_lstSeeAlso.end(); itSecOld++)
        {
            subsecOld = *itSecOld;

            res = Reader::StrColl( subsecOld->m_strTitle.c_str(), subsec->m_strTitle.c_str() );

            if(res == 0)
            {
                //
                // Same title, merge the entries.
                //
                Section::EntryIterConst itEntry;

                for(itEntry = subsec->m_lstEntries.begin(); itEntry != subsec->m_lstEntries.end(); itEntry++)
                {
                    subsecOld->MergeURLs( *itEntry );
                }

                fInsert = false;
                break;
            }

            if(res > 0)
            {
                //
                // Old > New, insert New before Old.
                //
                break;
            }
        }

        if(fInsert)
        {
            if((subsecOld = new Section()))
            {
                //
                // Copy everything, except "see also" list.
                //
                *subsecOld = *subsec;
                subsecOld->m_lstSeeAlso.clear();

                m_lstSeeAlso.insert( itSecOld, subsecOld );
            }
        }
    }
}

void HHK::Section::CleanEntries( EntryList& lstEntries )
{
    Section::EntryIterConst itEntry;

    for(itEntry = lstEntries.begin(); itEntry != lstEntries.end(); )
    {
        const Entry& entry = *itEntry;

        if(entry.m_strTitle.length() == 0 ||
           entry.m_lstUrl.size()     == 0  )
        {
            lstEntries.erase( itEntry );
            itEntry = lstEntries.begin();
        }
        else
        {
            itEntry++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

LPCSTR HHK::Reader::StrChr( LPCSTR szString, CHAR cSearch )
{
    if(s_fDBCSSystem)
    {
        CHAR c;

        while((c = *szString))
        {
            while(::IsDBCSLeadByte( c ))
            {
                szString++;

                if(     *szString++  == 0) return NULL;
                if((c = *szString  ) == 0) return NULL;
            }

            if(c == cSearch) return szString;

            szString++;
        }

        return NULL;
    }

    return ::strchr( szString, cSearch );
}

LPCSTR HHK::Reader::StriStr( LPCSTR szString, LPCSTR szSearch )
{
    if(!szString || !szSearch) return NULL;

    LPCSTR szCur =               szString;
    CHAR   ch    = (int)tolower(*szSearch);
    int    cb    =      strlen ( szSearch);

    for(;;)
    {
        while(tolower(*szCur) != ch && *szCur)
        {
            szCur = s_fDBCSSystem ? ::CharNextA( szCur ) : szCur + 1;
        }

        if(!*szCur) return NULL;

        if(::CompareStringA( s_lcidSystem, NORM_IGNORECASE, szCur, cb,  szSearch, cb ) == 2) return szCur;

        szCur = s_fDBCSSystem ? ::CharNextA( szCur ) : szCur + 1;
    }
}

int HHK::Reader::StrColl( LPCSTR szLeft, LPCSTR szRight )
{
      LPSTR szLeftCopy  = (LPSTR)_alloca( strlen( szLeft  ) + 2 );
      LPSTR szRightCopy = (LPSTR)_alloca( strlen( szRight ) + 2 );

      ReplaceEscapes( szLeft , szLeftCopy  );
      ReplaceEscapes( szRight, szRightCopy );

      switch(::CompareStringA( s_lcidSystem, NORM_IGNORECASE, szLeftCopy, -1, szRightCopy, -1 ))
      {
      case CSTR_LESS_THAN   : return -1;
      case CSTR_EQUAL       : return  0;
      case CSTR_GREATER_THAN: return  1;
      }

      return _stricmp( szLeftCopy, szRightCopy );
}

LPCSTR HHK::Reader::ComparePrefix( LPCSTR szString, LPCSTR szPrefix )
{
    int cb = strlen( szPrefix );

    if(_strnicoll( szString, szPrefix, cb ) == 0) return &szString[cb];

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////

HHK::Reader::Reader()
{
                                 // CComPtr<IStream> m_stream;
                                 // CHAR             m_rgBuf[HHK_BUF_SIZE];
    m_szBuf_Pos         = NULL;  // LPSTR            m_szBuf_Pos;
    m_szBuf_End         = NULL;  // LPSTR            m_szBuf_End;
                                 //
                                 // MPC::string      m_strLine;
    m_szLine_Pos        = NULL;  // LPCSTR           m_szLine_Pos;
    m_szLine_End        = NULL;  // LPCSTR           m_szLine_End;
    m_iLevel            = 0;     // int              m_iLevel;
    m_fOpeningBraceSeen = false; // bool             m_fOpeningBraceSeen;
}

HHK::Reader::~Reader()
{
}

/*
HRESULT HHK::Reader::Init( LPCWSTR szFile )

  Initializes the Reader as either a stream coming from a CHM of a plain file.

*/
HRESULT HHK::Reader::Init( LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "HHK::Reader::Init" );

    HRESULT  hr;
    CComBSTR bstrStorageName;
    CComBSTR bstrFilePath;


    if(MPC::MSITS::IsCHM( szFile, &bstrStorageName, &bstrFilePath ))
    {
        USES_CONVERSION;

        m_strStorage  = "ms-its:";
        m_strStorage += OLE2A( SAFEBSTR( bstrStorageName ) );
        m_strStorage += "::/";

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MSITS::OpenAsStream( bstrStorageName, bstrFilePath, &m_stream ));
    }
    else
    {
		CComPtr<MPC::FileStream> fsStream;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &fsStream ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, fsStream->InitForRead( szFile ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, fsStream.QueryInterface( &m_stream ));
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

#ifdef DEBUG
	Local_DumpStream( szFile, m_stream, hr );
#endif

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/*
bool HHK::Reader::ReadNextBuffer()

  Reads the Next Input Buffer into m_rgBuf then resets member variable m_szBuf_Pos to point at the beginning
  of the Buffer and m_szBuf_end to point at the end of the Buffer.

  Returns:  true    - If it could read a buffer
            false   - When at End of File (EOF), or on read error condition.

*/

bool HHK::Reader::ReadNextBuffer()
{
    bool fRes = false;

    if(m_stream)
    {
        HRESULT hr;
        ULONG   cbRead;

        hr = m_stream->Read( m_rgBuf, sizeof(m_rgBuf)-1, &cbRead );

        if(SUCCEEDED(hr) && cbRead)
        {
            m_szBuf_Pos =  m_rgBuf;
            m_szBuf_End = &m_rgBuf[cbRead]; m_szBuf_End[0] = 0; // So it's a string...
            fRes        =  true;
        }
    }

    return fRes;
}

/*
bool HHK::Reader::GetLine():

  Reads the Next Text Line from reader Input Stream

  returns:  true    - if it could read information
            false   - if at Enf of File (EOF).
*/
bool HHK::Reader::GetLine( MPC::wstring* pstrString )
{
    LPSTR szEnd;
    LPSTR szMatch1;
    LPSTR szMatch2;
    int   cb;
    bool  fRes  = false;
    bool  fSkip = true;


    m_strLine.erase();


    for(;;)
    {
        //
        // Make sure the buffer has data, otherwise exit.
        //
        if(IsEndOfBuffer())
        {
            if(ReadNextBuffer() == false)
            {
                //
                // End of file: return 'true' if we got any text.
                //
                if(m_strLine.length()) fRes = true;

                break;
            }
        }

        //
        // Skip initial end of lines...
        //
        if(fSkip)
        {
            if(m_szBuf_Pos[0] == '\r' ||
               m_szBuf_Pos[0] == '\n'  )
            {
                m_szBuf_Pos++;
                continue;
            }

            fSkip = false;
        }


        szMatch1 = (LPSTR)StrChr( m_szBuf_Pos, '\r' );
        szMatch2 = (LPSTR)StrChr( m_szBuf_Pos, '\n' );


        if(szMatch1 == NULL || (szMatch2 && szMatch1 > szMatch2)) szMatch1 = szMatch2; // Pick the first to appear, between \r and \n.


        if(szMatch1 == NULL)
        {
            //
            // End of line not found, save all the buffer.
            //

            cb = m_szBuf_End - m_szBuf_Pos;
            if(cb) fRes = true;

            m_strLine.append( m_szBuf_Pos, cb );
            m_szBuf_Pos = m_szBuf_End;
        }
        else
        {
            cb = szMatch1 - m_szBuf_Pos;
            if(cb) fRes = true;


            m_strLine.append( m_szBuf_Pos, cb );
            m_szBuf_Pos = szMatch1;
            break;
        }
    }

    if(fRes)
    {
        m_szLine_Pos = m_strLine.begin();
        m_szLine_End = m_strLine.end  ();

        //
        // Remove trailing spaces.
        //
        while(m_szLine_End > m_szLine_Pos && m_szLine_End[-1] == ' ')
        {
            --m_szLine_End;
        }

        if(m_szLine_End != m_strLine.end())
        {
            ;
        }
    }
    else
    {
        m_szLine_Pos = NULL;
        m_szLine_End = NULL;
    }

	if(pstrString)
	{
		USES_CONVERSION;

		 *pstrString = A2W( m_strLine.c_str() );
	}

    return fRes;
}

/////////////////////////////////////////////////////////////////////////////
/*
bool HHK::Reader::FirstNonSpace( bool fWrap )

  This function sets the current Reader position to the First non space character it finds.
  If fWrap is set, it can go over End Of Line (EOL) markers.

  Return Value: It reports back whether there is or not a non space character forward from
                the current Reader stream position.

*/
bool HHK::Reader::FirstNonSpace( bool fWrap )
{
    for(;;)
    {
        LPCSTR szMatch;

        while(IsEndOfLine())
        {
            if(fWrap     == false) return false;
            if(GetLine() == false) return false;
        }

        if(s_fDBCSSystem)
        {
            if(IsDBCSLeadByte( *m_szLine_Pos )) break;
        }

        if(m_szLine_Pos[0] != ' ' &&
           m_szLine_Pos[0] != '\t' )
        {
            break;
        }

        m_szLine_Pos++;
    }

    return true;
}
/*
HHK::Reader::FindCharacter( CHAR ch, bool fSkip, bool fWrap ):

  Finds a character within a given Reader Stream. if fWrap is set it goes beyond End of Line characters
  If fSkip is set it instructs the routine to not only find the character, but also to skip it and
  return the first non space character.
*/
bool HHK::Reader::FindCharacter( CHAR ch, bool fSkip, bool fWrap )
{
    for(;;)
    {
        LPCSTR szMatch;

        while(IsEndOfLine())
        {
            if(fWrap     == false) return false;
            if(GetLine() == false) return false;
        }

        szMatch = StrChr( m_szLine_Pos, ch );
        if(szMatch)
        {
            m_szLine_Pos = szMatch;

            if(fSkip) m_szLine_Pos++;
            break;
        }

        m_szLine_Pos = m_szLine_End; // Skip the whole line.
    }

    return fSkip ? FirstNonSpace( fWrap ) : true;
}

bool HHK::Reader::FindDblQuote    ( bool fSkip, bool fWrap ) { return FindCharacter( '"', fSkip, fWrap ); }
bool HHK::Reader::FindOpeningBrace( bool fSkip, bool fWrap ) { return FindCharacter( '<', fSkip, fWrap ); }
bool HHK::Reader::FindClosingBrace( bool fSkip, bool fWrap ) { return FindCharacter( '>', fSkip, fWrap ); }

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// We need to extract <Value> from "<Value>".
//
/////////////////////////////////////////////////////////////////////////////
bool HHK::Reader::GetQuotedString( MPC::string& strString )
{
    LPCSTR szPos;


    strString.erase();


    //
    // Skip past beginning quote.
    //
    if(FindDblQuote() == false) return false;

    for(;;)
    {
        szPos = m_szLine_Pos;

        //
        // Find ending quote of parameter value, but don't skip it.
        //
        if(FindDblQuote( false, false ))
        {
            strString.append( szPos, m_szLine_Pos - szPos );
            break;
        }
        else
        {
            strString.append( szPos, m_szLine_End - szPos );

            if(GetLine() == false) return false;
        }
    }

    //
    // Skip past ending quote.
    //
    return FindDblQuote();
}

/*
bool HHK::Reader::GetValue( MPC::string& strName, MPC::string& strValue )

  We are after '<param name=', we need to extract <Name> and <Value> from '"<Name>" value="<Value>">' ... "
  portion of the line.

  returns:  true    - If syntax is correct and everything was as expected.
            false   - Some unexpected syntactitc error occured.
*/
bool HHK::Reader::GetValue( MPC::string& strName, MPC::string& strValue )
{
    LPCSTR szPos;


    strValue.erase();


    if(GetQuotedString( strName ) == false) return false;


    //
    // Find parameter value.
    //
    for(;;)
    {
        while(IsEndOfLine())
        {
            if(GetLine() == false) return false;
        }

        szPos = StriStr( m_szLine_Pos, txtValue );
        if(szPos)
        {
            m_szLine_Pos = szPos + MAXSTRLEN(txtValue);
            break;
        }
    }

    if(GetQuotedString( strValue ) == false) return false;

    return FindClosingBrace();
}

/////////////////////////////////////////////////////////////////////////////
//
// We are after '<OBJECT', we need to extract <Type> from ' type="<Type>">'
//
/////////////////////////////////////////////////////////////////////////////
bool HHK::Reader::GetType( MPC::string& strType )
{
    LPCSTR szPos;


    strType.erase();


    //
    // Find type text.
    //
    for(;;)
    {
        while(IsEndOfLine())
        {
            if(GetLine() == false) return false;
        }

        szPos = StriStr( m_szLine_Pos, txtType );
        if(szPos)
        {
            m_szLine_Pos = szPos + MAXSTRLEN(txtValue);
            break;
        }
    }

    if(GetQuotedString( strType ) == false) return false;

    return FindClosingBrace();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HHK::Section* HHK::Reader::Parse()
{
    MPC::string strName;
    MPC::string strValue;
    MPC::string strType;
    LPCSTR      szPos;
    Section*    section        = NULL;
    Section*    sectionCurrent = NULL;
    bool        fComplete      = false;

    for(;;)
    {
        if(m_fOpeningBraceSeen)
        {
            m_fOpeningBraceSeen = false;
        }
        else
        {
            if(FindOpeningBrace() == false) break;
        }

        if((szPos = ComparePrefix( m_szLine_Pos, txtParam )))
        {
            m_szLine_Pos = szPos;

            if(GetValue( strName, strValue ) == false) break;
            {
                if(sectionCurrent)
                {
                    if(!StrColl( strName.c_str(), txtParamKeyword ))
                    {
						sectionCurrent->m_strTitle = strValue;
					}
                    else if(!StrColl( strName.c_str(), txtParamName ))
                    {
                        if(sectionCurrent->m_strTitle.length() == 0) // Title of the section.
                        {
                            sectionCurrent->m_strTitle = strValue;
                        }
                        else // Title of the entry.
                        {
                            Section::EntryIter it = sectionCurrent->m_lstEntries.insert( sectionCurrent->m_lstEntries.end() );

                            it->m_strTitle = strValue;
                        }
                    }
                    else if(!StrColl( strName.c_str(), txtParamLocal )) // URL of the entry.
                    {
                        Section::EntryIter it;

                        if(sectionCurrent->m_lstEntries.size())
                        {
                            it = sectionCurrent->m_lstEntries.end();
                            it--;
                        }
                        else
                        {
                            //
                            // No title for this entry, so let's create it without title...
                            //
                            it = sectionCurrent->m_lstEntries.insert( sectionCurrent->m_lstEntries.end() );

							//
							// If it's the first entry, use the keyword as a title.
							//
							if(sectionCurrent->m_lstEntries.size())
							{
								it->m_strTitle = sectionCurrent->m_strTitle;
							}
                        }

                        if(m_strStorage.length())
                        {
                            MPC::string strFullUrl( m_strStorage );
							LPCSTR      szValue = strValue.c_str();

							//
							// If the entry in the HHK is in the form: <file>::/<stream>, drop the last component of the storage base.
							//
							if(strValue.find( "::/" ) != strValue.npos)
							{
								LPCSTR szStart;
								LPCSTR szEnd;


								szStart = strFullUrl.c_str();
								szEnd   = strrchr( szStart, '\\' );
								if(szEnd)
								{
									strFullUrl.resize( (szEnd - szStart) + 1 );
								}

								//
								// Handle the case for "MS-ITS:<file>::/<stream>"
								//
								szStart = strchr( szValue, ':' );
								if(szStart && szStart[1] != ':') szValue = szStart+1;
							}
							else if(strValue.find( ":/" ) != strValue.npos) // If it's a full URL (with a protocol), just add the value.
							{
								strFullUrl = "";
							}

							strFullUrl += szValue;

                            it->m_lstUrl.push_back( strFullUrl );
                        }
                        else
                        {
                            it->m_lstUrl.push_back( strValue );
                        }
                    }
                    else if(!StrColl( strName.c_str(), txtParamSeeAlso )) // See Also
                    {
                        if(sectionCurrent)
                        {
                            sectionCurrent->m_strSeeAlso = strValue;
                        }
                    }
                }
            }
        }
        else if((szPos = ComparePrefix( m_szLine_Pos, txtBeginList )))
        {
            m_szLine_Pos = szPos;
            m_iLevel++;

            if(FirstNonSpace() == false) break;
        }
        else if((szPos = ComparePrefix( m_szLine_Pos, txtEndList )))
        {
            m_szLine_Pos = szPos;
            m_iLevel--;

            if(FirstNonSpace() == false) break;
        }
        else if((szPos = ComparePrefix( m_szLine_Pos, txtBeginListItem )))
        {
            if(section)
            {
                if(m_iLevel == 1)
                {
                    //
                    // Ok, the node is really closed.
                    //
                    // Since we have already read the opening brace for the NEXT node, set the flag.
                    //
                    m_fOpeningBraceSeen = true;
                    return section;
                }
            }

            m_szLine_Pos = szPos;

            if(FindClosingBrace() == false) break;
            if(FindOpeningBrace() == false) break;

            if((szPos = ComparePrefix( m_szLine_Pos, txtBeginObject )))
            {
                m_szLine_Pos = szPos;

                if(GetType( strType ) == false) break;

                //////////////////// New Node ////////////////////

                if(!StrColl( strType.c_str(), txtSiteMapObject ))
                {
                    if(m_iLevel == 1)
                    {
                        section = new Section(); if(section == NULL) break;

                        sectionCurrent = section;
                    }
                    else if(section)
                    {
                        sectionCurrent = new Section(); if(sectionCurrent == NULL) break;

                        section->m_lstSeeAlso.push_back( sectionCurrent );
                    }

                    fComplete = false; // Start of a section/subsection.
                }
            }
        }
        else if((szPos = ComparePrefix( m_szLine_Pos, txtEndObject )))
        {
            m_szLine_Pos = szPos;

            //////////////////// End Node ////////////////////

            if(m_iLevel == 1) // Normal section
            {
                //
                // Ok, node complete, but it's possible to have a <UL> subnode, so wait before exiting.
                //
            }
            else if(m_iLevel == 2) // See Also section
            {
                sectionCurrent = section;
            }

            fComplete = true; // End of a subsection.
        }
    }

    if(section)
    {
        //
        // End of File, but a section has already been parsed, so return it.
        //
        if(fComplete) return section;

        delete section;
    }

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HHK::Writer::Writer()
{
                           // CComPtr<MPC::FileStream> m_stream;
                           // CHAR                     m_rgBuf[HHK_BUF_SIZE];
    m_szBuf_Pos = m_rgBuf; // LPSTR                    m_szBuf_Pos;
}

HHK::Writer::~Writer()
{
    Close();
}

HRESULT HHK::Writer::Init( LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "HHK::Writer::Init" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_stream->InitForWrite( szFile ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtHeader ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HHK::Writer::Close()
{
    __HCP_FUNC_ENTRY( "HHK::Writer::Close" );

    HRESULT hr;


    if(m_stream)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtTail ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, FlushBuffer());

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_stream->Close());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT HHK::Writer::FlushBuffer()
{
    HRESULT hr;
    ULONG   cbWrite = (m_szBuf_Pos - m_rgBuf);
    ULONG   cbWrote;


    if(m_stream)
    {
        if(cbWrite)
        {
            hr = m_stream->Write( m_szBuf_Pos = m_rgBuf, cbWrite, &cbWrote );
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = E_FAIL;
    }


    return hr;
}

HRESULT HHK::Writer::OutputLine( LPCSTR szLine )
{
    HRESULT hr = S_OK;


    if(szLine)
    {
        size_t iLen = strlen( szLine );

        while(iLen)
        {
            size_t iCopy = min( iLen, Available() );

            ::CopyMemory( m_szBuf_Pos, szLine, iCopy );

            m_szBuf_Pos += iCopy;
            szLine      += iCopy;
            iLen        -= iCopy;

            if(iLen)
            {
                if(FAILED(hr = FlushBuffer())) break;
            }
        }
    }


    return hr;
}

HRESULT HHK::Writer::OutputSection( Section* sec )
{
    __HCP_FUNC_ENTRY( "HHK::Writer::OutputSection" );

    HRESULT                   hr;
    Section::SectionIterConst itSec;
    Section*                  subsec;
    Section::EntryIterConst   itEntry;
    Entry::UrlIterConst       itUrl;


    // BUG 135252 - Help Center Content: Broken link from Adapters topic on Help Index
    // This is a UA specific tweak. The condition is present ONLY on single entry
    // Keyword links coming from the DB, which means that their URI does not point
    // inside a .CHM.
    if(sec->m_lstEntries.size() != 0 &&
       sec->m_lstSeeAlso.size() != 0  )
    {
        Section Sec1;

        for(itEntry = sec->m_lstEntries.begin(); itEntry != sec->m_lstEntries.end(); itEntry++)
        {
            itUrl = itEntry->m_lstUrl.begin();

            if(itUrl != itEntry->m_lstUrl.end())
            {
                Section* SubSec1;

				__MPC_EXIT_IF_ALLOC_FAILS(hr, SubSec1, new Section);

                SubSec1->m_strTitle = itEntry->m_strTitle;
                SubSec1->m_lstEntries.push_back( *itEntry );

                Sec1.m_lstSeeAlso.push_back( SubSec1 );
            }
        }

        sec->MergeSeeAlso( Sec1 );
        sec->m_lstEntries.clear();
    }
    // END Fix BUG 135252

    __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewSection_Open      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Name        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( sec->m_strTitle.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close       ));

    sec->CleanEntries( sec->m_lstEntries );
    for(itEntry = sec->m_lstEntries.begin(); itEntry != sec->m_lstEntries.end(); itEntry++)
    {
        const Entry& entry = *itEntry;

        if(entry.m_strTitle.length())
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Name         ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( entry.m_strTitle.c_str() ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close        ));
        }

        for(itUrl = entry.m_lstUrl.begin(); itUrl != entry.m_lstUrl.end(); itUrl++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Local ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( itUrl->c_str()    ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close ));
        }
    }

    if ( sec->m_lstEntries.size() == 0 )
    {
        if(sec->m_strSeeAlso.length())
        {
            if (sec->m_strSeeAlso == sec->m_strTitle)
            {
                // Bug 278906: If this is a first level index entry, with no associated
                // topic, then the See Also will be the same as the Title. Replace the
                // See Also by a pointer to an HTM that asks the user to click on a
                // lower level index entry.
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Local  ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtIndexFirstLevel ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close  ));
            }
            else
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_SeeAlso       ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( sec->m_strSeeAlso.c_str() ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close         ));
            }
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewSection_Close ));

    ////////////////////

    if(sec->m_lstSeeAlso.size())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewSubSection_Open ));

        for(itSec = sec->m_lstSeeAlso.begin(); itSec != sec->m_lstSeeAlso.end(); itSec++)
        {
            subsec = *itSec;

            subsec->CleanEntries( subsec->m_lstEntries );

            if(subsec->m_strSeeAlso.length() == 0 &&
               subsec->m_lstEntries.size()   == 0  ) continue;

            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtIndent          ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewSection_Open ));

            if(subsec->m_strTitle.length())
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtIndent                  ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Name           ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( subsec->m_strTitle.c_str() ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close          ));
            }

            if(subsec->m_strSeeAlso.length())
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtIndent                    ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_SeeAlso          ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( subsec->m_strSeeAlso.c_str() ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close            ));
            }
            else
            {
                for(itEntry = subsec->m_lstEntries.begin(); itEntry != subsec->m_lstEntries.end(); itEntry++)
                {
                    const Entry& entry = *itEntry;

                    if(entry.m_strTitle.length() == 0 ||
                       entry.m_lstUrl.size()     == 0  ) continue;

                    if(entry.m_strTitle.length())
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtIndent                ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Name         ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( entry.m_strTitle.c_str() ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close        ));
                    }

                    for(itUrl = entry.m_lstUrl.begin(); itUrl != entry.m_lstUrl.end(); itUrl++)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtIndent         ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Local ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( itUrl->c_str()    ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewParam_Close ));
                    }
                }
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtIndent           ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewSection_Close ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, OutputLine( txtNewSubSection_Close ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HHK::Merger::Entity::Entity()
{
    m_Section = NULL; // Section* m_Section;
}

HHK::Merger::Entity::~Entity()
{
    if(m_Section)
    {
        delete m_Section;
    }
}

void HHK::Merger::Entity::SetSection( HHK::Section* sec )
{
    if(m_Section)
    {
        delete m_Section;
    }

    m_Section = sec;
}

HHK::Section* HHK::Merger::Entity::GetSection()
{
    return m_Section;
}

HHK::Section* HHK::Merger::Entity::Detach()
{
    HHK::Section* sec = m_Section;

    m_Section = NULL;

   return sec;
}

/////////////////////////////////////////////////////////////////////////////

HHK::Merger::FileEntity::FileEntity( LPCWSTR szFile )
{
    m_strFile = szFile; // MPC::wstring m_strFile;
                        // Reader       m_Input;
}

HHK::Merger::FileEntity::~FileEntity()
{
    SetSection( NULL );
}

HRESULT HHK::Merger::FileEntity::Init()
{
    return m_Input.Init( m_strFile.c_str() );
}

bool HHK::Merger::FileEntity::MoveNext()
{
    HHK::Section* sec = m_Input.Parse();

    SetSection( sec );

    return sec != NULL;
}

long HHK::Merger::FileEntity::Size() const
{
    return 0;
}

/////////////////////////////////////////////////////////////////////////////

bool HHK::Merger::DbEntity::CompareMatches::operator()( /*[in]*/ const HHK::Merger::DbEntity::match* left  ,
                                                        /*[in]*/ const HHK::Merger::DbEntity::match* right ) const
{
    int res = Reader::StrColl( left->strKeyword.c_str(), right->strKeyword.c_str() );

    if(res == 0)
    {
        res = Reader::StrColl( left->strTitle.c_str(), right->strTitle.c_str() );
    }

    return (res < 0);
}

HHK::Merger::DbEntity::DbEntity( /*[in]*/ Taxonomy::Updater& updater, /*[in]*/ Taxonomy::WordSet& setCHM ) : m_updater( updater )
{
                       // Section::SectionList m_lst;
                       // Taxonomy::Updater&   m_updater;
    m_setCHM = setCHM; // Taxonomy::WordSet    m_setCHM;
}

HHK::Merger::DbEntity::~DbEntity()
{
    MPC::CallDestructorForAll( m_lst );
}


HRESULT HHK::Merger::DbEntity::Init()
{
    __HCP_FUNC_ENTRY( "HHK::Merger::DbEntity::Init" );

    HRESULT          hr;
    MatchList        lstMatches;
    MatchIter        itMatches;
    KeywordMap       mapKeywords;
    KeywordIterConst itKeywords;
	TopicMap         mapTopics;
    SortMap          mapSorted;
    SortIter         itSorted;
    bool             fFound;

    //
    // Load all the matches.
    //
    {
        Taxonomy::RS_Matches* rs;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetMatches( &rs ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
            if(rs->m_fHHK)
            {
                itMatches = lstMatches.insert( lstMatches.end() );

                itMatches->ID_keyword = rs->m_ID_keyword;
                itMatches->ID_topic   = rs->m_ID_topic;

				mapTopics[rs->m_ID_topic] = &(*itMatches);
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
        }
    }

    //
    // Load all the keywords.
    //
    {
        Taxonomy::RS_Keywords* rs;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetKeywords( &rs ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
            MPC::string strKeyword; ConvertToAnsi( strKeyword, rs->m_strKeyword );

            mapKeywords[rs->m_ID_keyword] = strKeyword;

            __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
        }
    }

    //
    // Lookup the keyword's strings.
    //
    {
        match* lastKeyword = NULL;


        for(itMatches = lstMatches.begin(); itMatches != lstMatches.end(); itMatches++)
        {
            if(lastKeyword && lastKeyword->ID_keyword == itMatches->ID_keyword)
            {
                itMatches->strKeyword = lastKeyword->strKeyword;
            }
            else
            {
                itKeywords = mapKeywords.find( itMatches->ID_keyword );

                if(itKeywords == mapKeywords.end())
                {
                    ;  // This should NOT happen...
                }
                else
                {
                    itMatches->strKeyword = itKeywords->second;
                }

                lastKeyword = &(*itMatches);
            }
        }
    }

    //
    // Lookup topics.
    //
    {
        Taxonomy::RS_Topics* rs;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTopics( &rs ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
			match* elem;

            if(rs->m_fValid__URI && (elem = mapTopics[rs->m_ID_topic]))
			{
				bool fSkip = false;

				//
				// If the link points to a CHM and it's one of those already merged, skip the topic.
				//
				{
					CComBSTR bstrStorageName;

					if(MPC::MSITS::IsCHM( rs->m_strURI.c_str(), &bstrStorageName ) && bstrStorageName)
					{
						LPCWSTR szEnd = wcsrchr( bstrStorageName, '\\' );
						
						if(szEnd && m_setCHM.count( MPC::wstring( szEnd+1 ) ) > 0)
						{
							fSkip = true;
						}
					}
				}

				if(fSkip == false)
				{
					__MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ExpandURL( rs->m_strURI ));

					ConvertToAnsi( elem->strTitle, rs->m_strTitle );
					ConvertToAnsi( elem->strURI  , rs->m_strURI   );
				}
			}

			__MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
        }
    }

    //
    // Sort topics.
    //
    {
        for(itMatches = lstMatches.begin(); itMatches != lstMatches.end(); itMatches++)
        {
            match* elem  = &(*itMatches);

			//
			// We keep a one-to-one association between ID_topic and match, in order to resolve the Title/URI of a keyword.
			// However, there can be multiple keywords pointing to the same topic.
			// So we need to copy title/URI from the element in the one-to-one association to all the others.
			//
			if(elem->strTitle.length() == 0 ||
			   elem->strURI  .length() == 0  )
			{
				match* elem2 = mapTopics[elem->ID_topic];

				if(elem2 && elem2 != elem)
				{
					elem->strTitle = elem2->strTitle;
					elem->strURI   = elem2->strURI  ;
				}
			}

            if(elem->strKeyword.length() == 0) continue;
            if(elem->strTitle  .length() == 0) continue;
            if(elem->strURI    .length() == 0) continue;

            mapSorted[elem] = elem;
        }
    }

    //
    // Generate sections.
    //
    {
        HHK::Section*           sec    = NULL;
        HHK::Section*           secsub = NULL;
        HHK::Section::EntryIter it;
		MPC::string 			strBuffer;


        for(itSorted = mapSorted.begin(); itSorted != mapSorted.end(); itSorted++)
        {
            match* elem = itSorted->first;

			//
			// Escape all the values, before generating the sections.
			//
			ReplaceCharactersWithEntity( elem->strKeyword, strBuffer );
			ReplaceCharactersWithEntity( elem->strTitle  , strBuffer );
			ReplaceCharactersWithEntity( elem->strURI    , strBuffer );

            if(sec == NULL || sec->m_strTitle != elem->strKeyword)
            {
                if(sec)
                {
                    m_lst.push_back( sec );
                }

                __MPC_EXIT_IF_ALLOC_FAILS(hr, sec, new HHK::Section());
                secsub = NULL;

                it              =       sec->m_lstEntries.insert( sec->m_lstEntries.end() );
                sec->m_strTitle =       elem->strKeyword;
                it->m_strTitle  =       elem->strTitle;
                it->m_lstUrl.push_back( elem->strURI );
            }
            else
            {
                if(secsub == NULL)
                {
                    secsub = sec;
                    __MPC_EXIT_IF_ALLOC_FAILS(hr, sec, new HHK::Section());

                    sec->m_lstSeeAlso.push_back( secsub );
                    sec->m_strTitle    = elem->strKeyword;
                    sec->m_strSeeAlso  = elem->strKeyword;
                    secsub->m_strTitle = it->m_strTitle;
                }

                if(secsub->m_strTitle != elem->strTitle)
                {
                    __MPC_EXIT_IF_ALLOC_FAILS(hr, secsub, new HHK::Section());

                    sec->m_lstSeeAlso.push_back( secsub );
                    secsub->m_strTitle = elem->strTitle;

                    it             = secsub->m_lstEntries.insert( secsub->m_lstEntries.end() );
                    it->m_strTitle = elem->strTitle;
                }

                it->m_lstUrl.push_back( elem->strURI );
            }
        }

        if(sec)
        {
            m_lst.push_back( sec );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

bool HHK::Merger::DbEntity::MoveNext()
{
    Section::SectionIterConst it = m_lst.begin();

    if(it != m_lst.end())
    {
        SetSection( *it );

        m_lst.erase( it );
        return true;
    }
    else
    {
        SetSection( NULL );
        return false;
    }
}

long HHK::Merger::DbEntity::Size() const
{
    return m_lst.size();
}

/////////////////////////////////////////////////////////////////////////////

class Compare
{
public:
    bool operator()( /*[in]*/ HHK::Section* const &left, /*[in]*/ HHK::Section* const &right ) const
    {
        return HHK::Reader::StrColl( left->m_strTitle.c_str(), right->m_strTitle.c_str() ) < 0;
    }
};


HHK::Merger::SortingFileEntity::SortingFileEntity( LPCWSTR szFile ) : m_in( szFile )
{
    // Section::SectionList m_lst;
    // FileEntity           m_in;
}

HHK::Merger::SortingFileEntity::~SortingFileEntity()
{
    MPC::CallDestructorForAll( m_lst );
}

HRESULT HHK::Merger::SortingFileEntity::Init()
{
    HRESULT hr;

    if(SUCCEEDED(hr = m_in.Init()))
    {
        Compare     Pr;
        SectionVec  vec;
        SectionIter itLast;
        SectionIter it;
        Section*    secLast = NULL;
        Section*    sec;

        //
        // Parse the whole file.
        //
        while(m_in.MoveNext())
        {
            vec.push_back( m_in.Detach() );
        }

        //
        // Sort all the sections.
        //
        std::sort( vec.begin(), vec.end(), Pr );

        //
        // Walk through the sections, looking for duplicate keywords to merge.
        //
        // Each section encountered is not added immediately, but kept in "secLast" for comparison with the next one.
        //
        for(it=vec.begin(); it!=vec.end();)
        {
            sec = *it;

            if(secLast)
            {
                if(Reader::StrColl( sec->m_strTitle.c_str(), secLast->m_strTitle.c_str() ) == 0)
                {
                    Section::SectionList lst;

                    //
                    // Collate all the sections with the same keyword in a list and merge them.
                    //
                    lst.push_back( secLast );
                    while(it != vec.end() && Reader::StrColl( (*it)->m_strTitle.c_str(), secLast->m_strTitle.c_str() ) == 0)
                    {
                        lst.push_back( *it++ );
                    }

                    sec = Merger::MergeSections( lst );
                    if(sec == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    //
                    // Queue the merged section and loop.
                    //
                    m_lst.push_back( sec );
                    secLast = NULL;
                    continue;
                }
                else
                {
                    m_lst.push_back( secLast ); *itLast = NULL;
                }
            }

            itLast  = it;
            secLast = sec; it++;
        }

        if(secLast)
        {
            m_lst.push_back( secLast ); *itLast = NULL;
        }

        MPC::CallDestructorForAll( vec );
    }

    return hr;
}

bool HHK::Merger::SortingFileEntity::MoveNext()
{
    Section::SectionIterConst it = m_lst.begin();

    if(it != m_lst.end())
    {
        SetSection( *it );

        m_lst.erase( it );
        return true;
    }
    else
    {
        SetSection( NULL );
        return false;
    }
}

long HHK::Merger::SortingFileEntity::Size() const
{
    return m_lst.size();
}

/////////////////////////////////////////////////////////////////////////////

HHK::Merger::Merger()
{
                          // EntityList m_lst;
                          // EntityList m_lstSelected;
    m_SectionTemp = NULL; // Section*   m_SectionTemp;
}

HHK::Merger::~Merger()
{
    MPC::CallDestructorForAll( m_lst );

    if(m_SectionTemp)
    {
        delete m_SectionTemp;
    }
}

HRESULT HHK::Merger::AddFile( Entity* ent, bool fIgnoreMissing )
{
    HRESULT hr;

    if(ent == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr = ent->Init()))
    {
        m_lst.push_back( ent );
    }
    else
    {
        delete ent;

        if(fIgnoreMissing)
        {
            hr = S_OK;
        }
    }

    return hr;
}

HHK::Section* HHK::Merger::MergeSections( Section::SectionList& lst )
{
    HHK::Section* secMerged = new HHK::Section();

    if(secMerged)
    {
		if(lst.size())
		{
			HHK::Section* sec = *(lst.begin());

			secMerged->m_strTitle = sec->m_strTitle;
		}

        //
        // Move than one section with the same title, need to merge...
        //
        for(HHK::Section::SectionIter it=lst.begin(); it!=lst.end(); it++)
        {
            HHK::Section* sec = *it;

            for(HHK::Section::EntryIterConst itEntry = sec->m_lstEntries.begin(); itEntry != sec->m_lstEntries.end(); itEntry++)
            {
                secMerged->MergeURLs( *itEntry );
            }

            if(sec      ->m_strSeeAlso.length()  > 0 &&
               secMerged->m_strSeeAlso.length() == 0  )
            {
                secMerged->m_strSeeAlso = sec->m_strSeeAlso;
            }

            ////////////////////

            secMerged->MergeSeeAlso( *sec );
        }
    }

    return secMerged;
}

bool HHK::Merger::MoveNext()
{
    HHK::Section*   secLowest = NULL;
    EntityIterConst it;
    EntityIterConst it2;


    if(m_SectionTemp)
    {
        delete m_SectionTemp;

        m_SectionTemp = NULL;
    }

    //
    // If this is the first round ever, select all the entities.
    //
    if(m_lstSelected.size() == 0)
    {
        m_lstSelected = m_lst;
    }


    //
    // First of all, advance all the entity selected in the previous round.
    //
    for(it=m_lstSelected.begin(); it!=m_lstSelected.end(); it++)
    {
        Entity* ent = *it;

        if(ent->MoveNext() == false)
        {
            //
            // End of File for this entity, remove it from the system.
            //
            delete ent;

            it2 = std::find( m_lst.begin(), m_lst.end(), ent );
            if(it2 != m_lst.end())
            {
                m_lst.erase( it2 );
            }

            continue;
        }
    }
    m_lstSelected.clear();

    //
    // No more entities, abort.
    //
    if(m_lst.size() == 0) return false;

    //
    // Select a section with the lowest title.
    //
    for(it=m_lst.begin(); it!=m_lst.end(); it++)
    {
        Entity*       ent = *it;
        HHK::Section* sec = ent->GetSection();

        if(secLowest == NULL || Reader::StrColl( sec->m_strTitle.c_str(), secLowest->m_strTitle.c_str() ) < 0)
        {
            secLowest = sec;
        }
    }

    //
    // Find all the sections with the lowest title.
    //
    for(it=m_lst.begin(); it!=m_lst.end(); it++)
    {
        Entity*       ent = *it;
        HHK::Section* sec = ent->GetSection();

        if(Reader::StrColl( sec->m_strTitle.c_str(), secLowest->m_strTitle.c_str() ) == 0)
        {
            m_lstSelected.push_back( ent );
        }
    }

    if(m_lstSelected.size() > 1)
    {
        Section::SectionList lst;

        for(it=m_lstSelected.begin(); it!=m_lstSelected.end(); it++)
        {
            HHK::Section* sec = (*it)->GetSection();

            lst.push_back( sec );
        }

        m_SectionTemp = MergeSections( lst );
    }

    return true;
}

HHK::Section* HHK::Merger::GetSection()
{
    if(m_SectionTemp)
    {
        return m_SectionTemp;
    }

    if(m_lstSelected.size())
    {
        return (*m_lstSelected.begin())->GetSection();
    }

    return NULL;
}

long HHK::Merger::Size() const
{
    long            lTotal = 0;
    EntityIterConst it;


    for(it=m_lst.begin(); it!=m_lst.end(); it++)
    {
        lTotal += (*it)->Size();
    }

    return lTotal;
}

HRESULT HHK::Merger::PrepareMergedHhk( Writer&            writer      ,
                                       Taxonomy::Updater& updater     ,
									   Taxonomy::WordSet& setCHM      ,
									   MPC::WStringList&  lst         , 
                                       LPCWSTR            szOutputHHK )
{
    __HCP_FUNC_ENTRY( "HHK::Merger::PrepareMergedHhk" );

    HRESULT          hr;
	MPC::WStringIter it;


    //
    // Enumerate all the HHKs to merge.
    //
	for(it=lst.begin(); it!=lst.end(); it++)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, AddFile( new SortingFileEntity( it->c_str() ) ));
	}

	//// Keyword are not merged in the HHK.
	////    __MPC_EXIT_IF_METHOD_FAILS(hr, AddFile( new DbEntity( updater, setCHM ) ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( szOutputHHK ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, writer.Init( szOutputHHK ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HHK::Merger::PrepareSortingOfHhk( HHK::Writer& writer      ,
                                          LPCWSTR      szInputHHK  ,
                                          LPCWSTR      szOutputHHK )
{
    __HCP_FUNC_ENTRY( "HHK::Merger::PrepareSortingOfHhk" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, AddFile( new SortingFileEntity( szInputHHK ) ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, writer.Init( szOutputHHK ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\offlinecache.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    OfflineCache.cpp

Abstract:
    Handles caching of database lookups.

Revision History:
    Davide Massarenti   (Dmassare)  07/17/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT OfflineCache::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ OfflineCache::Query& val )
{
    __HCP_FUNC_ENTRY( "OfflineCache::OfflineCache::operator>> OfflineCache::Query" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strID    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_iType    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_iSequence);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fNull    );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const OfflineCache::Query& val )
{
    __HCP_FUNC_ENTRY( "OfflineCache::operator<< OfflineCache::Query" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strID    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_iType    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_iSequence);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fNull    );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

OfflineCache::Query::Query()
{
                             // MPC::wstring m_strID;
   m_iType     = ET_INVALID; // int          m_iType;
   m_iSequence = 0;          // int          m_iSequence;
   m_fNull     = true;       // bool         m_fNull;
}

HRESULT OfflineCache::Query::InitFile( /*[in ]*/ const MPC::wstring& strDir  ,
                                       /*[out]*/       MPC::wstring& strFile )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Query::InitFile" );

    HRESULT hr;
    WCHAR   rgBuf[64]; swprintf( rgBuf, L"\\%08x.query", m_iSequence );


    strFile  = strDir;
    strFile += rgBuf;


    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::Query::Retrieve( /*[in]*/ const MPC::wstring&         strDir ,
                                       /*[in]*/ CPCHQueryResultCollection* *pColl  )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Query::Retrieve" );

    HRESULT                            hr;
    CComPtr<CPCHQueryResultCollection> coll;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pColl, NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &coll ));


    if(m_fNull == false)
    {
        MPC::wstring             strFile;
        CComPtr<MPC::FileStream> stream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, InitFile     ( strDir , strFile         ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeLoad(          strFile, stream ));


        //
        // Create the collection from the IStream.
        //
        {
            MPC::Serializer_IStream   streamGen ( stream    );
            MPC::Serializer_Buffering streamGen2( streamGen );

            __MPC_EXIT_IF_METHOD_FAILS(hr, coll->Load( streamGen2 ));
        }
    }

    *pColl = coll.Detach();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT OfflineCache::operator>>( /*[in] */ MPC::Serializer&               stream ,
                                  /*[out]*/ OfflineCache::SetOfHelpTopics& val    )
{
    __HCP_FUNC_ENTRY( "OfflineCache::operator>> OfflineCache::SetOfHelpTopics" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_inst      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lstQueries);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_iLastSeq  );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::operator<<( /*[in]*/ MPC::Serializer&                     stream ,
                                  /*[in]*/ const OfflineCache::SetOfHelpTopics& val    )
{
    __HCP_FUNC_ENTRY( "OfflineCache::operator<< OfflineCache::SetOfHelpTopics" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_inst      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lstQueries);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_iLastSeq  );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

OfflineCache::SetOfHelpTopics::SetOfHelpTopics()
{
    m_parent   = NULL; // Root*              m_parent;
                       //
                       // Taxonomy::Instance m_inst;
                       // QueryList          m_lstQueries;
    m_iLastSeq = 0;    // int                m_iLastSeq;
}

////////////////////

HRESULT OfflineCache::SetOfHelpTopics::InitDir( /*[in]*/ MPC::wstring& strDir )
{
    __HCP_FUNC_ENTRY( "OfflineCache::SetOfHelpTopics::InitDir" );

    HRESULT hr;
    WCHAR   rgDir[MAX_PATH];


    _snwprintf( rgDir, MAXSTRLEN(rgDir), L"%s\\%s#%04lx", HC_ROOT_HELPSVC_OFFLINECACHE, m_inst.m_ths.GetSKU(), m_inst.m_ths.GetLanguage() );

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strDir = rgDir ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::SetOfHelpTopics::Find( /*[in] */ LPCWSTR&   szID  ,
                                             /*[in] */ int        iType ,
                                             /*[out]*/ QueryIter& it    )
{
    __HCP_FUNC_ENTRY( "OfflineCache::SetOfHelpTopics::Find" );

    HRESULT hr;


    if(szID == NULL) szID = L"";


    for(it = m_lstQueries.begin(); it != m_lstQueries.end(); it++)
    {
        if(!MPC::StrICmp( it->m_strID ,  szID  ) &&
                          it->m_iType == iType    )
        {
            break;
        }
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

void OfflineCache::SetOfHelpTopics::ConnectToParent( /*[in]*/ Root* parent )
{
    m_parent = parent;
}

////////////////////////////////////////

HRESULT OfflineCache::SetOfHelpTopics::Retrieve( /*[in]*/ LPCWSTR                     szID  ,
                                                 /*[in]*/ int                         iType ,
                                                 /*[in]*/ CPCHQueryResultCollection* *pColl )
{
    __HCP_FUNC_ENTRY( "OfflineCache::SetOfHelpTopics::Retrieve" );

    HRESULT     hr;
    QueryIter   it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pColl, NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Find( szID, iType, it ));
    if(it == m_lstQueries.end())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    //
    // Load from the registry.
    //
    {
        MPC::wstring strDir;

        __MPC_EXIT_IF_METHOD_FAILS(hr, InitDir( strDir ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, it->Retrieve( strDir, pColl ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

OfflineCache::Handle::Handle()
{
    m_main = NULL; // Root*            m_main;
    m_sht  = NULL; // SetOfHelpTopics* m_sht;
}

OfflineCache::Handle::~Handle()
{
    Release();
}

void OfflineCache::Handle::Attach( /*[in]*/ Root* main, /*[in]*/ SetOfHelpTopics* sht )
{
    Release();

    m_main = main; if(main) main->Lock();
    m_sht  = sht;
}

void OfflineCache::Handle::Release()
{
    if(m_main) m_main->Unlock();

    m_main = NULL;
    m_sht  = NULL;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT OfflineCache::operator>>( /*[in] */ MPC::Serializer&    stream ,
                                  /*[out]*/ OfflineCache::Root& val    )
{
    __HCP_FUNC_ENTRY( "OfflineCache::operator>> OfflineCache::Root" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fReady     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_instMachine);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lstSKUs    );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::operator<<( /*[in]*/ MPC::Serializer&          stream ,
                                  /*[in]*/ const OfflineCache::Root& val    )
{
    __HCP_FUNC_ENTRY( "OfflineCache::operator<< OfflineCache::Root" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fReady     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_instMachine);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lstSKUs    );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

OfflineCache::Root::Root( /*[in]*/ bool fMaster ) : m_nmSharedLock( L"GLOBAL\\PCH_OFFLINECACHE", /*fCloseOnRelease*/true )
{
                                     			  // MPC::NamedMutex    m_nmSharedLock;
                                     			  //	
    m_fReady              = false;   			  // bool               m_fReady;
                                     			  // Taxonomy::Instance m_instMachine;
                                     			  // SKUList            m_lstSKUs;
                                     			  //	
    m_fMaster             = fMaster; 			  // bool               m_fMaster;
    m_fLoaded             = false;   			  // bool               m_fLoaded;
    m_fDirty              = false;   			  // bool               m_fDirty;
    m_dwDisableSave       = 0;       			  // DWORD              m_dwDisableSave;
    m_hChangeNotification = INVALID_HANDLE_VALUE; // HANDLE             m_hChangeNotification;
}

OfflineCache::Root::~Root()
{
    (void)Clean();
}

////////////////////

OfflineCache::Root* OfflineCache::Root::s_GLOBAL( NULL );

HRESULT OfflineCache::Root::InitializeSystem( /*[in]*/ bool fMaster )
{
    if(s_GLOBAL == NULL)
    {
        s_GLOBAL = new OfflineCache::Root( fMaster );
    }

    return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void OfflineCache::Root::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

////////////////////

void OfflineCache::Root::Lock()
{
    super::Lock();

    (void)m_nmSharedLock.Acquire( 500 );
}

void OfflineCache::Root::Unlock()
{
    (void)m_nmSharedLock.Release();

    super::Unlock();
}

////////////////////

HRESULT OfflineCache::Root::GetIndexFile( /*[in]*/ MPC::wstring& strIndex )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::GetIndexFile" );

    HRESULT hr;


    strIndex.reserve( MAX_PATH );
    strIndex  = HC_ROOT_HELPSVC_OFFLINECACHE;
    strIndex += L"\\index.dat";

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strIndex ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::Root::Load()
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Load" );

    HRESULT hr;


    //
    // If the content of the offline cache directory has changed, reload everything.
    //
    if(m_hChangeNotification != INVALID_HANDLE_VALUE)
    {
        if(::WaitForSingleObject( m_hChangeNotification, 0 ) != WAIT_TIMEOUT)
        {
            ::FindNextChangeNotification( m_hChangeNotification );
            Clean();
        }
    }

    //
    // Not already loaded, try to load, but without failing.
    //
    if(m_fLoaded == false)
    {
        MPC::wstring             strIndex;
        CComPtr<MPC::FileStream> stream;

        if(SUCCEEDED(GetIndexFile ( strIndex         )) &&
           SUCCEEDED(SVC::SafeLoad( strIndex, stream ))  )
        {
            MPC::Serializer_IStream   streamGen ( stream    );
            MPC::Serializer_Buffering streamGen2( streamGen );
            DWORD                     dwVer;

            if(SUCCEEDED(streamGen2 >> dwVer) && dwVer == s_dwVersion)
            {
                if(SUCCEEDED(streamGen2 >> *this))
                {
                    for(SKUIter it = m_lstSKUs.begin(); it != m_lstSKUs.end(); it++)
                    {
                        it->ConnectToParent( this );
                    }

                    if(m_fMaster == false && m_fReady)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::HelpSet::SetMachineInfo( m_instMachine ));
                    }
                }
                else
                {
                    Clean();
                }
            }

            //
            // Setup change notification, if we are a slave.
            //
            if(m_fMaster == false)
            {
                static const DWORD s_dwNotify = FILE_NOTIFY_CHANGE_FILE_NAME  |
                                                FILE_NOTIFY_CHANGE_DIR_NAME   |
                                                FILE_NOTIFY_CHANGE_ATTRIBUTES |
                                                FILE_NOTIFY_CHANGE_SIZE       |
                                                FILE_NOTIFY_CHANGE_LAST_WRITE |
                                                FILE_NOTIFY_CHANGE_CREATION;

				m_hChangeNotification = ::FindFirstChangeNotificationW( strIndex.c_str(), TRUE, s_dwNotify );
            }
        }

        m_fLoaded = true;
        m_fDirty  = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::Root::Clean()
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Clean" );

    HRESULT hr;


    m_fLoaded = false;
    m_fDirty  = false;

    m_fReady  = false;

    m_lstSKUs.clear();

    if(m_hChangeNotification != INVALID_HANDLE_VALUE)
    {
        ::FindCloseChangeNotification( m_hChangeNotification );

        m_hChangeNotification = INVALID_HANDLE_VALUE;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT OfflineCache::Root::Find( /*[in ]*/ const Taxonomy::HelpSet& ths ,
                                  /*[out]*/ SKUIter&                 it  )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Find" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load());


    for(it = m_lstSKUs.begin(); it != m_lstSKUs.end(); it++)
    {
        if(it->m_inst.m_ths == ths)
        {
            break;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT OfflineCache::Root::Locate( /*[in] */ const Taxonomy::HelpSet& ths    ,
                                    /*[out]*/ Handle&                  handle )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Locate" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    SKUIter                      it;


    handle.Release();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Find( ths, it ));

    if(it == m_lstSKUs.end())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    handle.Attach( this, &(*it) );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT OfflineCache::Root::SetMachineInfo( /*[in]*/ const Taxonomy::Instance& inst )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::SetMachineInfo" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_fMaster)
    {
        Taxonomy::HelpSet ths;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Load());

		m_instMachine = inst;
        m_fDirty      = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

bool OfflineCache::Root::IsReady()
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::IsReady" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load());


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(m_fReady);
}

////////////////////////////////////////

HRESULT OfflineCache::Root::FindMatch( /*[in]*/  LPCWSTR            szSKU      ,
                                       /*[in]*/  LPCWSTR            szLanguage ,
                                       /*[out]*/ Taxonomy::HelpSet& ths        )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::FindMatch" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    SKUIter                      it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load());


    for(it = m_lstSKUs.begin(); it != m_lstSKUs.end(); it++)
    {
        SetOfHelpTopics& sht = *it;

        if(STRINGISPRESENT(szSKU))
        {
            if(!_wcsicmp( szSKU, L"All" ))
            {
                ;
            }
            else if(!_wcsicmp( szSKU, L"Server" ))
            {
                if(sht.m_inst.m_fServer == false) continue;
            }
            else if(!_wcsicmp( szSKU, L"Desktop" ))
            {
                if(sht.m_inst.m_fDesktop == false) continue;
            }
            else if(!_wcsicmp( szSKU, L"Embedded" ))
            {
                if(sht.m_inst.m_fEmbedded == false) continue;
            }
            else
            {
                if(_wcsicmp( szSKU, sht.m_inst.m_ths.GetSKU() ) != 0) continue;
            }
        }

        if(STRINGISPRESENT(szLanguage))
        {
            if(!_wcsicmp( szLanguage, L"All" ))
            {
                ;
            }
            else if(!_wcsicmp( szLanguage, L"MUI" ))
            {
                if(sht.m_inst.m_fMUI == false || GetUserDefaultUILanguage() != sht.m_inst.m_ths.GetLanguage())
                {
                    continue;
                }
            }
            else
            {
                if(_wtol( szLanguage ) != sht.m_inst.m_ths.GetLanguage()) continue;
            }
        }

        ths = sht.m_inst.m_ths;
        break;
    }

    if(it == m_lstSKUs.end())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\logger.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Logger.cpp

Abstract:
    This file contains the implementation of the Taxonomy::Logger class,
	which is used during database updates.

Revision History:
    Davide Massarenti   (Dmassare)  24/03/2001
        created

******************************************************************************/

#include "stdafx.h"

Taxonomy::Logger::Logger()
{
	                 // MPC::FileLog m_obj;
	m_dwLogging = 0; // DWORD        m_dwLogging;
}

Taxonomy::Logger::~Logger()
{
	if(m_dwLogging)
	{
		WriteLog( E_FAIL, L"Forcing closure of log file." );
		EndLog  (                                         );
	}
}

HRESULT Taxonomy::Logger::StartLog( /*[in]*/ LPCWSTR szLocation )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Logger::StartLog" );

    HRESULT hr;

	if(m_dwLogging++ == 0)
	{
		MPC::wstring szFile( szLocation ? szLocation : HC_HCUPDATE_LOGNAME ); MPC::SubstituteEnvVariables( szFile );

		// Attempt to open the log for writing
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_obj.SetLocation( szFile.c_str() ));

		// write it out to log file
		__MPC_EXIT_IF_METHOD_FAILS(hr, WriteLog( -1, L"===========================================\nHCUPDATE Log started\n===========================================" ));
	}

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Logger::EndLog()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Logger::EndLog" );

    HRESULT hr;

	if(m_dwLogging > 0)
	{
		if(m_dwLogging == 1)
		{
			(void)WriteLog( -1, L"===========================================\nHCUPDATE Log ended\n===========================================" );

			__MPC_EXIT_IF_METHOD_FAILS(hr, m_obj.Terminate());
		}

		m_dwLogging--;
	}

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Logger::WriteLogV( /*[in]*/ HRESULT hrRes       ,
                                     /*[in]*/ LPCWSTR szLogFormat ,
                                     /*[in]*/ va_list arglist     )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Logger::WriteLogV" );

    HRESULT hr;
    WCHAR   rgLine[256];
    WCHAR*  pLine = NULL;
    WCHAR*  pLinePtr;


    if(_vsnwprintf( rgLine, MAXSTRLEN(rgLine), szLogFormat, arglist ) == -1)
    {
        const int iSizeMax = 8192;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, pLine, new WCHAR[iSizeMax]);

        _vsnwprintf( pLine, iSizeMax-1, szLogFormat, arglist ); pLine[iSizeMax-1] = 0;

        pLinePtr = pLine;
    }
    else
    {
        rgLine[MAXSTRLEN(rgLine)] = 0;

        pLinePtr = rgLine;
    }

    if(hrRes == -2)
    {
        hrRes = HRESULT_FROM_WIN32(::GetLastError());
    }

    if(hrRes == -1)
    {
        hrRes = S_OK;

		if(m_dwLogging)
		{
	        __MPC_EXIT_IF_METHOD_FAILS(hr, m_obj.LogRecord( L"%s", pLinePtr ));
		}
    }
    else
    {
		if(m_dwLogging)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, m_obj.LogRecord( L"%x - %s", hrRes, pLinePtr ));
		}
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    delete [] pLine;

    if(FAILED(hrRes)) hr = hrRes;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Logger::WriteLog( /*[in]*/ HRESULT hrRes       ,
                                    /*[in]*/ LPCWSTR szLogFormat ,
                                    /*[in]*/ ...                 )
{
    va_list arglist;

    va_start( arglist, szLogFormat );

    return WriteLogV( hrRes, szLogFormat, arglist );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(HELPCTR_SERVICE_DATABASE_STDAFX_H__INCLUDED_)
#define HELPCTR_SERVICE_DATABASE_STDAFX_H__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>


//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>

#include <QueryResult.h>
#include <TaxonomyDatabase.h>
#include <MergedHHK.h>
#include <OfflineCache.h>

#include <SvcUtils.h>

#include <FileList.h>
#include <SecurityLib.h>

//
// Localized strings functions.
//
#include <locres.h>

//
// Localized strings IDs.
//
#include <HCAppRes.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(HELPCTR_SERVICE_DATABASE_STDAFX_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\offlinecache_master.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    OfflineCache_Master.cpp

Abstract:
    Handles caching of database lookups, service-side.

Revision History:
    Davide Massarenti   (Dmassare)  07/17/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT OfflineCache::Query::Store( /*[in]*/ const MPC::wstring&              strDir ,
                                    /*[in]*/ const CPCHQueryResultCollection* pColl  )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Query::Store" );

    HRESULT hr;

    if(m_fNull == false)
    {
        MPC::wstring             strFile;
        CComPtr<MPC::FileStream> stream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, InitFile          ( strDir, strFile         ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Init(         strFile, stream ));

        //
        // Create an IStream from the collection.
        //
        {
            MPC::Serializer_IStream   streamGen ( stream    );
            MPC::Serializer_Buffering streamGen2( streamGen );

            __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->Save( streamGen2 ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2.Flush());
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Finalize( strFile, stream ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::Query::Remove( /*[in]*/ const MPC::wstring& strDir )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Query::Remove" );

    HRESULT hr;

    if(m_fNull == false)
    {
        MPC::wstring strFile;

        __MPC_EXIT_IF_METHOD_FAILS(hr, InitFile( strDir, strFile ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( strFile, /*fForce*/true, /*fDelayed*/false ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool OfflineCache::SetOfHelpTopics::AreYouInterested( /*[in]*/ LPCWSTR szID  ,
                                                      /*[in]*/ int     iType )
{
    int iDepth = 1;

    switch(iType)
    {
    case ET_NODE                  :
    case ET_SUBNODES              :
    case ET_SUBNODES_VISIBLE      :
    case ET_NODESANDTOPICS        :
    case ET_NODESANDTOPICS_VISIBLE:
    case ET_TOPICS                :
    case ET_TOPICS_VISIBLE        : break;

    default                       : return false; // Not interested for now...
    }

    //
    // Count the depth of the taxonomy node, we are only interested in the first two levels.
    //
    if(szID)
    {
        WCHAR c;

        while((c = *szID++))
        {
            if(c == '/') iDepth++;
        }
    }

    if(m_inst.m_fDesktop && iDepth < 4) return true;
    if(                     iDepth < 3) return true;

    return false;
}

HRESULT OfflineCache::SetOfHelpTopics::Store( /*[in]*/ LPCWSTR                          szID  ,
                                              /*[in]*/ int                              iType ,
                                              /*[in]*/ const CPCHQueryResultCollection* pColl )
{
    __HCP_FUNC_ENTRY( "OfflineCache::SetOfHelpTopics::Store" );

    HRESULT     hr;
    QueryIter   it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Find( szID, iType, it ));
    if(it == m_lstQueries.end())
    {
        it = m_lstQueries.insert( m_lstQueries.end() );

        it->m_strID     = szID;
        it->m_iType     = iType;
        it->m_iSequence = m_iLastSeq++;
        it->m_fNull     = (pColl->Size() == 0);

        if(m_parent) __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->SetDirty());
    }

    //
    // Persist to disk.
    //
    if(it->m_fNull == false)
    {
        MPC::wstring strDir;

        __MPC_EXIT_IF_METHOD_FAILS(hr, InitDir( strDir ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, it->Store( strDir, pColl ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::SetOfHelpTopics::RemoveQueries()
{
    __HCP_FUNC_ENTRY( "OfflineCache::SetOfHelpTopics::RemoveQueries" );

    HRESULT      hr;
    MPC::wstring strDir;
    QueryIter    it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, InitDir( strDir ));

    for(it = m_lstQueries.begin(); it != m_lstQueries.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, it->Remove( strDir ));
    }
    m_lstQueries.clear();
    m_iLastSeq = 0;

    {
        MPC::FileSystemObject fso( strDir.c_str() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, fso.DeleteChildren( /*fForce*/true, /*fComplain*/false ));
    }

    if(m_parent) __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->SetDirty());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT OfflineCache::Root::SetDirty()
{
    m_fDirty = true;

    return S_OK;
}

HRESULT OfflineCache::Root::DisableSave()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_dwDisableSave++;

    return S_OK;
}

HRESULT OfflineCache::Root::EnableSave()
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::EnableSave" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    if(m_dwDisableSave)
    {
        if(--m_dwDisableSave == 0)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Save());
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::Root::Save()
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Save" );

    HRESULT hr;


    if(m_fDirty && m_fMaster && m_dwDisableSave == 0) // Only master can write to the registry.
    {
        MPC::wstring             strIndex;
        CComPtr<MPC::FileStream> stream;


        __MPC_EXIT_IF_METHOD_FAILS(hr, GetIndexFile      ( strIndex         ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Init( strIndex, stream ));

        //
        // Create IStream from the collection.
        //
        {
            MPC::Serializer_IStream   streamGen ( stream    );
            MPC::Serializer_Buffering streamGen2( streamGen );
            DWORD                     dwVer = s_dwVersion;

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 << dwVer );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2 << *this );

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamGen2.Flush());
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Finalize( strIndex, stream ));

        m_fDirty = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT OfflineCache::Root::Import( /*[in]*/ const Taxonomy::Instance& inst )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Import" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    SKUIter                      it;


    if(m_fMaster == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }



    __MPC_EXIT_IF_METHOD_FAILS(hr, Find( inst.m_ths, it ));
    if(it == m_lstSKUs.end())
    {
        it = m_lstSKUs.insert( m_lstSKUs.end() );

        it->ConnectToParent( this );
        it->m_inst = inst;

        m_fDirty = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT OfflineCache::Root::Remove( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Remove" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    SKUIter                      it;


    if(m_fMaster == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }



    __MPC_EXIT_IF_METHOD_FAILS(hr, Find( ths, it ));
    if(it != m_lstSKUs.end())
    {
        (void)it->RemoveQueries();

        m_lstSKUs.erase( it );

        m_fDirty = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT OfflineCache::Root::Flush( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::Flush" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_fMaster)
    {
        if(fForce) m_fDirty = true;
    }
    else
    {
        //
        // On the slave side, Flush is like Reload.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Clean());
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, Save());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT OfflineCache::Root::SetReady( /*[in]*/ bool fReady )
{
    __HCP_FUNC_ENTRY( "OfflineCache::Root::SetReady" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    m_fReady = fReady;
    m_fDirty = true;
    hr       = S_OK;


    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\settings.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Settings.cpp

Abstract:
    Handles interaction between a generic user configuration and the related DB.

Revision History:

******************************************************************************/

#include "stdafx.h"

#include <utility.h>

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Settings::SplitNodePath( /*[in]*/  LPCWSTR             szNodeStr ,
                                           /*[out]*/ MPC::WStringVector& vec       )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::SplitNodePath" );

    HRESULT      hr;
    MPC::wstring strFull( L"<ROOT>" );


    if(STRINGISPRESENT(szNodeStr))
    {
        strFull += L"/";
        strFull += szNodeStr;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SplitAtDelimiter( vec, strFull.c_str(), L"/" ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

Taxonomy::Settings::Settings( /*[in]*/ LPCWSTR szSKU, /*[in]*/ long lLCID ) : HelpSet( szSKU, lLCID )
{
}

Taxonomy::Settings::Settings( /*[in]*/ const HelpSet& ths )
{
    *(HelpSet*)this = ths;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Settings::BaseDir( /*[out]*/ MPC::wstring& strRES, /*[in]*/ bool fExpand ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::DatabaseFile" );

    HRESULT hr;


	strRES = HC_HELPSET_ROOT;

	if(IsMachineHelp() == false)
	{
		WCHAR rgDir[MAX_PATH]; _snwprintf( rgDir, MAXSTRLEN(rgDir), L"%s\\%s_%04lx\\", HC_HELPSET_SUB_INSTALLEDSKUS, m_strSKU.c_str(), m_lLCID );

		strRES.append( rgDir );
	}

	if(fExpand)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strRES ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::HelpFilesDir( /*[out]*/ MPC::wstring& strRES, /*[in]*/ bool fExpand, /*[in]*/ bool fMUI ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::DatabaseFile" );

    HRESULT hr;
	WCHAR   rgDir[MAX_PATH];

	if(IsMachineHelp())
	{
		strRES = HC_HELPSVC_HELPFILES_DEFAULT;
	}
	else if(fMUI)
	{
		_snwprintf( rgDir, MAXSTRLEN(rgDir), L"%s\\MUI\\%04lx", HC_HELPSVC_HELPFILES_DEFAULT, m_lLCID );

		strRES = rgDir;
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, BaseDir( strRES, fExpand ));

		strRES.append( HC_HELPSET_SUB_HELPFILES );
	}

	if(fExpand)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strRES ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::DatabaseDir( /*[out]*/ MPC::wstring& strRES ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::DatabaseDir" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, BaseDir( strRES ));

    strRES.append( HC_HELPSET_SUB_DATABASE L"\\" );
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::DatabaseFile( /*[out]*/ MPC::wstring& strRES ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::DatabaseFile" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, DatabaseDir( strRES ));

    strRES.append( HC_HELPSET_SUBSUB_DATABASEFILE );
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::IndexFile( /*[out]*/ MPC::wstring& strRES, /*[in]*/ long lScoped ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::IndexFile" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, BaseDir( strRES ));

	if(lScoped == -1)
	{
		strRES.append( HC_HELPSET_SUB_INDEX L"\\" HC_HELPSET_SUBSUB_INDEXFILE );
	}
	else
	{
		WCHAR rgDir[MAX_PATH];

		_snwprintf( rgDir, MAXSTRLEN(rgDir), HC_HELPSET_SUB_INDEX L"\\scoped_%ld.hhk", lScoped );

		strRES.append( rgDir );
	}

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::GetDatabase( /*[out]*/ JetBlue::SessionHandle& handle    ,
                                         /*[out]*/ JetBlue::Database*&     db        ,
										 /*[in ]*/ bool                    fReadOnly ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::GetDatabase" );

    USES_CONVERSION;

    HRESULT      hr;
    MPC::wstring strDB;


	db = NULL;


	__MPC_EXIT_IF_METHOD_FAILS(hr, DatabaseFile( strDB ));

	for(int pass=0; pass<2; pass++)
	{
		if(SUCCEEDED(hr = JetBlue::SessionPool::s_GLOBAL->GetSession( handle                                                                               )) &&
		   SUCCEEDED(hr = handle->GetDatabase                       ( W2A( strDB.c_str() ), db, /*fReadOnly*/fReadOnly, /*fCreate*/false, /*fRepair*/false ))  )
		{
			break;
		}

		handle.Release();
		db = NULL;

		if(pass == 1) __MPC_SET_ERROR_AND_EXIT(hr, hr);

		//
		// Try to recreate DB...
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSetOfHelpTopics::RebuildSKU( *this ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Settings::LookupNode( /*[in]*/ LPCWSTR                    szNodeStr ,
                                        /*[in]*/ CPCHQueryResultCollection* pColl     ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::LookupNode" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupNode - start : %s", SAFEWSTR( szNodeStr ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupNode( szNodeStr, pColl ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupNode - done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::LookupSubNodes( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                            /*[in]*/ bool                       fVisibleOnly ,
                                            /*[in]*/ CPCHQueryResultCollection* pColl        ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::LookupSubNodes" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupSubNodes - start : %s", SAFEWSTR( szNodeStr ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupSubNodes( szNodeStr, fVisibleOnly, pColl ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupSubNodes - done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::LookupNodesAndTopics( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                                  /*[in]*/ bool                       fVisibleOnly ,
                                                  /*[in]*/ CPCHQueryResultCollection* pColl        ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::LookupNodesAndTopics" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupNodesAndTopics - start : %s", SAFEWSTR( szNodeStr ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupNodesAndTopics( szNodeStr, fVisibleOnly, pColl ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupNodesAndTopics - done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::LookupTopics( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                          /*[in]*/ bool                       fVisibleOnly ,
                                          /*[in]*/ CPCHQueryResultCollection* pColl        ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::LookupTopics" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupTopics - start : %s", SAFEWSTR( szNodeStr ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LookupTopics( szNodeStr, fVisibleOnly, pColl ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LookupTopics - done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::KeywordSearch( /*[in]*/ LPCWSTR                    szQueryStr ,
                                           /*[in]*/ LPCWSTR                    szSubSite  ,
                                           /*[in]*/ CPCHQueryResultCollection* pColl      ,
										   /*[in]*/ MPC::WStringList*          lst        ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::KeywordSearch" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::KeywordSearch - start : '%s' # %s", SAFEWSTR( szQueryStr ), SAFEWSTR( szSubSite ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.KeywordSearch( szQueryStr, szSubSite, pColl, lst ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::KeywordSearch - done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::LocateContext( /*[in]*/ LPCWSTR                    szURL     ,
                                           /*[in]*/ LPCWSTR                    szSubSite ,
                                           /*[in]*/ CPCHQueryResultCollection* pColl     ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::LocateContext" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LocateContext - start : %s # %s", SAFEWSTR( szURL ), SAFEWSTR( szSubSite ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LocateContext( szURL, szSubSite, pColl ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::LocateContext - done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Settings::GatherNodes( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                         /*[in]*/ bool                       fVisibleOnly ,
                                         /*[in]*/ CPCHQueryResultCollection* pColl        ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::GatherNodes" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::GatherNodes - start : %s", SAFEWSTR( szNodeStr ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.GatherNodes( szNodeStr, fVisibleOnly, pColl ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::GatherNodes - done" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Settings::GatherTopics( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                          /*[in]*/ bool                       fVisibleOnly ,
                                          /*[in]*/ CPCHQueryResultCollection* pColl        ) const
{
    __HCP_FUNC_ENTRY( "Taxonomy::Settings::GatherTopics" );

    HRESULT                hr;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::GatherTopics - start : %s", SAFEWSTR( szNodeStr ) );
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase ( handle, db, /*fReadOnly*/true         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( *this,  db, Taxonomy::Cache::s_GLOBAL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.GatherTopics( szNodeStr, fVisibleOnly, pColl ));
    DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"Taxonomy::Settings::GatherTopics - done" );

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\queryresultsbuilder.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    QueryResultsBuilder.cpp

Abstract:
    The classes implementated in this file facilitate the generation of the result set from a DB query.

Revision History:
    Davide Massarenti   (Dmassare)  12/05/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

Taxonomy::QueryResultEntry::QueryResultEntry()
{
    m_ID_node      = -1; // long                     m_ID_node;
    m_ID_topic     = -1; // long                     m_ID_topic;
    m_ID_parent    = -1; // long                     m_ID_parent;
    m_ID_owner     = -1; // long                     m_ID_owner;
    m_lOriginalPos = -1; // long                     m_lOriginalPos;
                         //
                         // CPCHQueryResult::Payload m_data;
}

////////////////////////////////////////

bool Taxonomy::QueryResults::Compare::operator()( /*[in]*/ const QueryResultEntry* left, /*[in]*/ const QueryResultEntry* right ) const
{
    return left->m_data.m_lPos < right->m_data.m_lPos;
}

////////////////////////////////////////

Taxonomy::QueryResults::QueryResults( /*[in]*/ Taxonomy::Updater& updater ) : m_updater( updater )
{
    // Taxonomy::Updater& m_updater;
    // ResultVec          m_vec;
}

Taxonomy::QueryResults::~QueryResults()
{
	Clean();
}

void Taxonomy::QueryResults::Clean()
{
    MPC::CallDestructorForAll( m_vec );
}

HRESULT Taxonomy::QueryResults::AllocateNew( /*[in ]*/ LPCWSTR            szCategory ,
											 /*[out]*/ QueryResultEntry*& qre        )
{
    __HCP_FUNC_ENTRY( "Taxonomy::QueryResults::AllocateNew" );

    HRESULT hr;


    __MPC_EXIT_IF_ALLOC_FAILS(hr, qre, new QueryResultEntry);

    qre->m_data.m_bstrCategory = szCategory;

    m_vec.push_back( qre );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::QueryResults::Sort()
{
    Compare cmp;

    std::sort< ResultIter >( m_vec.begin(), m_vec.end(), cmp );

    return S_OK;
}

////////////////////

HRESULT Taxonomy::QueryResults::Append( /*[in]*/ Taxonomy::RS_Data_Taxonomy* rs         ,
										/*[in]*/ LPCWSTR                     szCategory )
{
    __HCP_FUNC_ENTRY( "Taxonomy::QueryResults::Append" );

    HRESULT           hr;
    QueryResultEntry* qre;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ExpandURL( rs->m_strDescriptionURI ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ExpandURL( rs->m_strIconURI        ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateNew( szCategory, qre ));


    qre->m_ID_node                 = rs->m_ID_node                  ;
    qre->m_ID_topic                = -1                             ;
    qre->m_ID_parent               = rs->m_ID_parent                ;
    qre->m_ID_owner                = rs->m_ID_owner                 ;
    qre->m_lOriginalPos            = rs->m_lPos                     ;

    qre->m_data.m_bstrEntry        = rs->m_strEntry         .c_str();
    qre->m_data.m_bstrTitle        = rs->m_strTitle         .c_str();
    qre->m_data.m_bstrTopicURL     = rs->m_strDescriptionURI.c_str();
    qre->m_data.m_bstrIconURL      = rs->m_strIconURI       .c_str();
    qre->m_data.m_bstrDescription  = rs->m_strDescription   .c_str();
////qre->m_data.m_lType
    qre->m_data.m_lPos             = rs->m_lPos                     ;
    qre->m_data.m_fVisible         = rs->m_fVisible                 ;
    qre->m_data.m_fSubsite         = rs->m_fSubsite                 ;
    qre->m_data.m_lNavModel        = rs->m_lNavModel                ;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::QueryResults::Append( /*[in]*/ Taxonomy::RS_Data_Topics* rs         ,
										/*[in]*/ LPCWSTR                   szCategory )
{
    __HCP_FUNC_ENTRY( "Taxonomy::QueryResults::Append" );

    HRESULT           hr;
    QueryResultEntry* qre;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ExpandURL( rs->m_strURI     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ExpandURL( rs->m_strIconURI ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateNew( szCategory, qre ));

    qre->m_ID_node                 = -1                          ;
    qre->m_ID_topic                = rs->m_ID_topic              ;
    qre->m_ID_parent               = rs->m_ID_node               ;
    qre->m_ID_owner                = rs->m_ID_owner              ;
    qre->m_lOriginalPos            = rs->m_lPos                  ;

////qre->m_data.m_bstrEntry
    qre->m_data.m_bstrTitle        = rs->m_strTitle      .c_str();
    qre->m_data.m_bstrTopicURL     = rs->m_strURI        .c_str();
    qre->m_data.m_bstrIconURL      = rs->m_strIconURI    .c_str();
    qre->m_data.m_bstrDescription  = rs->m_strDescription.c_str();
    qre->m_data.m_lType            = rs->m_lType                 ;
    qre->m_data.m_lPos             = rs->m_lPos                  ;
    qre->m_data.m_fVisible         = rs->m_fVisible              ;
////qre->m_data.m_fSubsite
////qre->m_data.m_lNavModel

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Taxonomy::QueryResults::LookupNodes( /*[in]*/ LPCWSTR szCategory   ,
											 /*[in]*/ long    ID_node      ,
											 /*[in]*/ bool    fVisibleOnly )
{
    __HCP_FUNC_ENTRY( "Taxonomy::QueryResults::LookupNodes" );

    HRESULT                hr;
    Taxonomy::RS_Taxonomy* rsTaxonomy;
    bool                   fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTaxonomy( &rsTaxonomy ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rsTaxonomy->Seek_Children( ID_node, &fFound ));
    while(fFound)
    {
        if(fVisibleOnly == false || rsTaxonomy->m_fVisible)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Append( rsTaxonomy, szCategory ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, rsTaxonomy->Move( 0, 1, &fFound ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::QueryResults::LookupTopics( /*[in]*/ LPCWSTR szCategory   ,
											  /*[in]*/ long    ID_node      ,
											  /*[in]*/ bool    fVisibleOnly )
{
    __HCP_FUNC_ENTRY( "Taxonomy::QueryResults::LookupTopics" );

    HRESULT              hr;
    Taxonomy::RS_Topics* rsTopics;
    bool                 fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTopics( &rsTopics ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rsTopics->Seek_TopicsUnderNode( ID_node, &fFound ));
    while(fFound)
    {
        if(fVisibleOnly == false || rsTopics->m_fVisible)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Append( rsTopics, szCategory ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, rsTopics->Move( 0, 1, &fFound ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

struct InsertionMode
{
    LPCWSTR szMode;
    int     iDir;
    bool    fNodes;
    bool    fTopics;
};


static const struct InsertionMode s_lookup[] =
{
    { L""            ,  1, false, false }, // Synonym of END
    { L"TOP"         , -1, false, false }, 
    { L"BEFORE_NODE" , -1, true , false }, // (INSERTLOCATION = <Entry>)
    { L"BEFORE_TOPIC", -1, false, true  }, // (INSERTLOCATION = <URI>)
    { L"AFTER_NODE"  ,  1, true , false }, // (INSERTLOCATION = <Entry>)
    { L"AFTER_TOPIC" ,  1, false, true  }, // (INSERTLOCATION = <URI>)
    { L"END"         ,  1, false, false }, 
};

HRESULT Taxonomy::QueryResults::MakeRoomForInsert( /*[in ]*/ LPCWSTR szMode  ,
												   /*[in ]*/ LPCWSTR szID    ,
												   /*[in ]*/ long 	 ID_node ,
												   /*[out]*/ long&   lPosRet )
{
    __HCP_FUNC_ENTRY( "Taxonomy::QueryResults::MakeRoomForInsert" );

    HRESULT                hr;
    Taxonomy::RS_Taxonomy* rsTaxonomy;
    Taxonomy::RS_Topics*   rsTopics;
	ResultIterConst        it;
	const InsertionMode*   ptr;
    long                   lPos;
	

	for(lPos = 0, ptr = s_lookup; lPos < ARRAYSIZE(s_lookup); lPos++, ptr++)
	{
		if(!MPC::StrICmp( ptr->szMode, szMode )) break;
	}
	if(lPos == ARRAYSIZE(s_lookup))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTaxonomy( &rsTaxonomy ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTopics  ( &rsTopics   ));

	Clean();

    __MPC_EXIT_IF_METHOD_FAILS(hr, LookupNodes ( NULL, ID_node, /*fVisibleOnly*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LookupTopics( NULL, ID_node, /*fVisibleOnly*/false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Sort());


    //
    // First Pass, reorder the set.
    //
    for(lPos = 1, it = m_vec.begin(); it != m_vec.end(); it++)
    {
        QueryResultEntry* qre = *it;

        qre->m_data.m_lPos = lPos++;
    }

    //
    // Second Pass, find the right position.
    //
	lPosRet = -1;
	if(ptr->fNodes || ptr->fTopics)
	{
		for(it = m_vec.begin(); it != m_vec.end(); it++)
		{
			QueryResultEntry* qre = *it;

			if((ptr->fNodes  && qre->m_ID_node  != -1 && !MPC::StrICmp( szID, qre->m_data.m_bstrEntry    )) ||
			   (ptr->fTopics && qre->m_ID_topic != -1 && !MPC::StrICmp( szID, qre->m_data.m_bstrTopicURL ))  )
			{
				lPosRet = (*it)->m_data.m_lPos;

				if(ptr->iDir > 0) lPosRet++; // Add after the selected element.

				break;
			}
		}
	}

	//
	// Stop not found? Add at the beginning or end.
	//
	if(lPosRet == -1)
	{
		if(ptr->iDir < 0)
		{
			lPosRet = 1;
		}
		else
		{
			lPosRet = m_vec.size() + 1;
		}				
	}

	//
	// Third Pass, move down the elements after the inserted one and reorganize.
	//
	for(it = m_vec.begin(); it != m_vec.end(); it++)
	{
		QueryResultEntry* qre = *it;

		if(qre->m_data.m_lPos >= lPosRet)
		{
			qre->m_data.m_lPos++;
		}

        if(qre->m_data.m_lPos != qre->m_lOriginalPos)
        {
            if(qre->m_ID_node != -1)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, rsTaxonomy->Seek_Node( qre->m_ID_node ));

                rsTaxonomy->m_lPos = qre->m_data.m_lPos;

                __MPC_EXIT_IF_METHOD_FAILS(hr, rsTaxonomy->Update());
            }

            if(qre->m_ID_topic != -1)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, rsTopics->Seek_SingleTopic( qre->m_ID_topic ));

                rsTopics->m_lPos = qre->m_data.m_lPos;

                __MPC_EXIT_IF_METHOD_FAILS(hr, rsTopics->Update());
            }

            qre->m_lOriginalPos = qre->m_data.m_lPos;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::QueryResults::PopulateCollection( /*[in]*/ CPCHQueryResultCollection* pColl )
{
    __HCP_FUNC_ENTRY( "Taxonomy::QueryResults::PopulateCollection" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Sort());

    for(ResultIterConst it = m_vec.begin(); it != m_vec.end(); it++)
    {
        CComPtr<CPCHQueryResult> item;
        QueryResultEntry*        qre = *it;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->CreateItem( &item ));

        item->Initialize( qre->m_data );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\updater.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Updater.cpp

Abstract:
    Handles access to the database.

Revision History:

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR s_DB_LOCATION_ENV[] = L"%HELP_LOCATION%";

#define STAT_CREATED( table )  m_stat.m_ent##table.Created()
#define STAT_MODIFIED( table ) m_stat.m_ent##table.Modified()
#define STAT_DELETED( table )  m_stat.m_ent##table.Deleted()
#define STAT_NOOP( table )     m_stat.m_ent##table.NoOp()

////////////////////////////////////////////////////////////////////////////////

Taxonomy::Updater::WordSetStatus::WordSetStatus()
{
    m_updater   = NULL;       // Updater*          m_updater;
    m_def       = NULL;       // const WordSetDef* m_def;
                              //
                              // WordSet           m_set;
    m_fLoaded   = false;      // bool              m_fLoaded;
    m_fModified = false;      // bool              m_fModified;
}

HRESULT Taxonomy::Updater::WordSetStatus::Close()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::WordSetStatus::Close" );

    HRESULT hr;


    m_updater = NULL;
    m_def     = NULL;

    m_set.clear();
    m_fLoaded   = false;
    m_fModified = false;


    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::WordSetStatus::Init( /*[in]*/ Updater* updater, /*[in]*/ const WordSetDef* def )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::WordSetStatus::Init" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());

    m_updater = updater;
    m_def     = def;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);

}

////////////////////

HRESULT Taxonomy::Updater::WordSetStatus::Load()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::WordSetStatus::Load" );

    HRESULT hr;

    if(m_fLoaded == false)
    {
        MPC::wstring strTokenList;
        bool         fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater->ReadDBParameter( m_def->szName, strTokenList, &fFound ));

        if(m_def->szDefault && strTokenList.size() == 0) strTokenList  = m_def->szDefault;
        if(m_def->szAlwaysPresent                      ) strTokenList += m_def->szAlwaysPresent;

        if(m_def->fSplitAtDelimiter)
        {
            std::vector<MPC::wstring> vec;
            int                       iLen;
            int                       i;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SplitAtDelimiter( vec, strTokenList.c_str(), L" ,\t\n", false, true ));

            iLen = vec.size();
            for(i=0; i<iLen; i++)
            {
                m_set.insert( vec[i] );
            }
        }
        else
        {
            int iLen;
            int i;

            iLen = strTokenList.size();
            for(i=0; i<iLen; i++)
            {
                m_set.insert( MPC::wstring( 1, strTokenList[i] ) );
            }
        }

        m_fLoaded = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::WordSetStatus::Save()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::WordSetStatus::Save" );

    HRESULT hr;


    if(m_fModified)
    {
        MPC::wstring              strTokenList;
        std::vector<MPC::wstring> vec;
        WordIter                  it;
        int                       i;

        vec.resize( m_set.size() );

        for(i=0, it = m_set.begin(); it != m_set.end(); it++, i++)
        {
            vec[i] = *it;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::JoinWithDelimiter( vec, strTokenList, m_def->fSplitAtDelimiter ? L"," : L"" ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater->WriteDBParameter( m_def->szName, strTokenList.c_str() ));

        m_fModified = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::WordSetStatus::Add( /*[in]*/ LPCWSTR szValue )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::WordSetStatus::Add" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load());

    m_set.insert( szValue ); m_fModified = true;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::WordSetStatus::Remove( /*[in]*/ LPCWSTR szValue )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::WordSetStatus::Remove" );

    HRESULT  hr;
    WordIter it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load());

    it = m_set.find( szValue );
    if(it != m_set.end())
    {
        m_set.erase( it ); m_fModified = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static const Taxonomy::Updater::WordSetDef s_SetDef[] =
{
    { L"SET_STOPSIGNS"            , false, L",?" , NULL    }, // UPDATER_SET_STOPSIGNS
    { L"SET_STOPSIGNS_ATENDOFWORD", false, NULL  , NULL    }, // UPDATER_SET_STOPSIGNS_ATENDOFWORD
    { L"SET_STOPWORDS"            , true , NULL  , NULL    }, // UPDATER_SET_STOPWORDS
    { L"SET_OPERATOR_NOT"         , true , L"NOT", L",!"   }, // UPDATER_SET_OPERATOR_NOT
    { L"SET_OPERATOR_AND"         , true , L"AND", L",&,+" }, // UPDATER_SET_OPERATOR_AND
    { L"SET_OPERATOR_OR"          , true , L"OR" , L",||"  }  // UPDATER_SET_OPERATOR_OR
};


Taxonomy::Updater::Updater()
{
                                // Settings           m_ts;
    m_db               = NULL;  // JetBlue::Database* m_db;
    m_cache            = NULL;  // Cache*             m_cache;
    m_fUseCache        = false; // bool               m_fUseCache;
                                //
    m_rsDBParameters   = NULL;  // RS_DBParameters*   m_rsDBParameters;
    m_rsContentOwners  = NULL;  // RS_ContentOwners*  m_rsContentOwners;
    m_rsSynSets        = NULL;  // RS_SynSets*        m_rsSynSets;
    m_rsHelpImage      = NULL;  // RS_HelpImage*      m_rsHelpImage;
    m_rsIndexFiles     = NULL;  // RS_IndexFiles*     m_rsIndexFiles;
    m_rsFullTextSearch = NULL;  // RS_FullTextSearch* m_rsFullTextSearch;
    m_rsScope          = NULL;  // RS_Scope*          m_rsScope;
    m_rsTaxonomy       = NULL;  // RS_Taxonomy*       m_rsTaxonomy;
    m_rsTopics         = NULL;  // RS_Topics*         m_rsTopics;
    m_rsSynonyms       = NULL;  // RS_Synonyms*       m_rsSynonyms;
    m_rsKeywords       = NULL;  // RS_Keywords*       m_rsKeywords;
    m_rsMatches        = NULL;  // RS_Matches*        m_rsMatches;
                                //
    m_ID_owner         = -1;    // long               m_ID_owner;
    m_fOEM             = false; // bool               m_fOEM;
                                //
                                // WordSetStatus      m_sets[UPDATER_SET_OPERATOR_MAX];
                                // JetBlue::Id2Node   m_nodes;
                                // JetBlue::Node2Id   m_nodes_reverse;
                                // 
                                // Updater_Stat       m_stat;
}

Taxonomy::Updater::~Updater()
{
    (void)Close();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::FlushWordSets()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::FlushWordSets" );

    HRESULT hr;
    int     i;

    for(i=UPDATER_SET_STOPSIGNS; i<UPDATER_SET_OPERATOR_MAX; i++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_sets[i].Save());
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Updater::Close()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::Close" );

    HRESULT hr;
    int     i;


    for(i=UPDATER_SET_STOPSIGNS; i<UPDATER_SET_OPERATOR_MAX; i++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_sets[i].Close());
    }

	NodeCache_Clear();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(m_rsDBParameters  ) { delete m_rsDBParameters  ; m_rsDBParameters   = NULL; }
    if(m_rsContentOwners ) { delete m_rsContentOwners ; m_rsContentOwners  = NULL; }
    if(m_rsSynSets       ) { delete m_rsSynSets       ; m_rsSynSets        = NULL; }
    if(m_rsHelpImage     ) { delete m_rsHelpImage     ; m_rsHelpImage      = NULL; }
    if(m_rsIndexFiles    ) { delete m_rsIndexFiles    ; m_rsIndexFiles     = NULL; }
    if(m_rsFullTextSearch) { delete m_rsFullTextSearch; m_rsFullTextSearch = NULL; }
    if(m_rsScope         ) { delete m_rsScope         ; m_rsScope          = NULL; }
    if(m_rsTaxonomy      ) { delete m_rsTaxonomy      ; m_rsTaxonomy       = NULL; }
    if(m_rsTopics        ) { delete m_rsTopics        ; m_rsTopics         = NULL; }
    if(m_rsSynonyms      ) { delete m_rsSynonyms      ; m_rsSynonyms       = NULL; }
    if(m_rsKeywords      ) { delete m_rsKeywords      ; m_rsKeywords       = NULL; }
    if(m_rsMatches       ) { delete m_rsMatches       ; m_rsMatches        = NULL; }

    m_db        = NULL;
    m_cache     = NULL;
    m_fUseCache = false;

    m_ID_owner = -1;
    m_fOEM     = false;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::Init( /*[in]*/ const Settings& ts, /*[in]*/ JetBlue::Database* db, /*[in]*/ Cache* cache )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::Init" );

    HRESULT hr;
    int     i;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());

    m_ts        = ts;
    m_db        = db;
    m_cache     = cache;
    m_fUseCache = (cache != NULL);
    m_strDBLocation = L"";

    for(i=UPDATER_SET_STOPSIGNS; i<UPDATER_SET_OPERATOR_MAX; i++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_sets[i].Init( this, &s_SetDef[i] ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetWordSet( /*[in] */ Updater_Set  id   ,
                                       /*[out]*/ WordSet*    *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetWordSet" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_sets[id].Load());

    if(pVal) *pVal = &m_sets[id].m_set;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetDBParameters( /*[out]*/ RS_DBParameters* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetDBParameters" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsDBParameters == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "DBParameters", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsDBParameters, new RS_DBParameters( tbl ));
    }

    if(pVal) *pVal = m_rsDBParameters;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetContentOwners( /*[out]*/ RS_ContentOwners* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetContentOwners" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsContentOwners == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "ContentOwners", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsContentOwners, new RS_ContentOwners( tbl ));
    }

    if(pVal) *pVal = m_rsContentOwners;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetSynSets( /*[out]*/ RS_SynSets* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetSynSets" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsSynSets == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "SynSets", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsSynSets, new RS_SynSets( tbl ));
    }

    if(pVal) *pVal = m_rsSynSets;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetHelpImage( /*[out]*/ RS_HelpImage* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetHelpImage" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsHelpImage == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "HelpImage", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsHelpImage, new RS_HelpImage( tbl ));
    }

    if(pVal) *pVal = m_rsHelpImage;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetIndexFiles( /*[out]*/ RS_IndexFiles* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetIndexFiles" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsIndexFiles == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "IndexFiles", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsIndexFiles, new RS_IndexFiles( tbl ));
    }

    if(pVal) *pVal = m_rsIndexFiles;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetFullTextSearch( /*[out]*/ RS_FullTextSearch* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetFullTextSearch" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsFullTextSearch == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "FullTextSearch", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsFullTextSearch, new RS_FullTextSearch( tbl ));
    }

    if(pVal) *pVal = m_rsFullTextSearch;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetScope( /*[out]*/ RS_Scope* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetScope" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsScope == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "Scope", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsScope, new RS_Scope( tbl ));
    }

    if(pVal) *pVal = m_rsScope;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetTaxonomy( /*[out]*/ RS_Taxonomy* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetTaxonomy" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsTaxonomy == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "Taxonomy", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsTaxonomy, new RS_Taxonomy( tbl ));
    }

    if(pVal) *pVal = m_rsTaxonomy;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetTopics( /*[out]*/ RS_Topics* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetTopics" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsTopics == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "Topics", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsTopics, new RS_Topics( tbl ));
    }

    if(pVal) *pVal = m_rsTopics;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetSynonyms( /*[out]*/ RS_Synonyms* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetSynonyms" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsSynonyms == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "Synonyms", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsSynonyms, new RS_Synonyms( tbl ));
    }

    if(pVal) *pVal = m_rsSynonyms;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetKeywords( /*[out]*/ RS_Keywords* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetKeywords" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsKeywords == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "Keywords", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsKeywords, new RS_Keywords( tbl ));
    }

    if(pVal) *pVal = m_rsKeywords;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetMatches( /*[out]*/ RS_Matches* *pVal )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GetMatches" );

    HRESULT hr;

    if(pVal) *pVal = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_db);
    __MPC_PARAMCHECK_END();


    if(m_rsMatches == NULL)
    {
        JetBlue::Table* tbl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( "Matches", tbl ));

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rsMatches, new RS_Matches( tbl ));
    }

    if(pVal) *pVal = m_rsMatches;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::DeleteAllTopicsUnderANode( /*[in]*/ RS_Topics* rs       ,
                                                      /*[in]*/ long       ID_node  ,
                                                      /*[in]*/ bool       fCheck   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteAllTopicsUnderANode" );

    HRESULT hr;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Seek_TopicsUnderNode( ID_node, &fFound ));
    while(fFound && rs->m_ID_node == ID_node)
    {
        if(rs->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

        if(fCheck == false)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, GetMatches());

            __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteAllMatchesPointingToTopic( m_rsMatches, rs->m_ID_topic ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Delete()); STAT_DELETED( Topics );
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Updater::DeleteAllSubNodes( /*[in]*/ RS_Taxonomy* rs       ,
                                              /*[in]*/ long         ID_node  ,
                                              /*[in]*/ bool         fCheck   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteAllSubNodes" );

    HRESULT hr;
    bool    fFound;

	
	__MPC_EXIT_IF_METHOD_FAILS(hr, DeleteAllTopicsUnderANode( m_rsTopics, ID_node, fCheck ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Seek_Children( ID_node, &fFound ));
    while(fFound)
    {
        if(rs->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

        {
            RS_Taxonomy subrs( *rs );

            __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteAllSubNodes( &subrs, rs->m_ID_node, fCheck ));
        }

        if(fCheck == false)
        {
			//
			// Keep the node cache in sync.
			//
			NodeCache_Remove( rs->m_ID_node );

            __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Delete()); STAT_DELETED( Taxonomy );
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::DeleteAllMatchesPointingToTopic( /*[in]*/ RS_Matches* rs       ,
                                                            /*[in]*/ long        ID_topic )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteAllMatchesPointingToTopic" );

    HRESULT hr;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Seek_ByTopic( ID_topic, &fFound ));
    while(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Delete()); STAT_DELETED( Matches );

        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::ReadDBParameter( /*[in] */ LPCWSTR        szName   ,
                                            /*[out]*/ MPC::wstring&  strValue ,
                                            /*[out]*/ bool          *pfFound  )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::ReadDBParameter" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDBParameters());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsDBParameters->Seek_ByName( szName, &fFound ));
    if(fFound)
    {
        strValue = m_rsDBParameters->m_strValue;
    }

    if(pfFound)
    {
        *pfFound = fFound;
    }
    else if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, JetBlue::JetERRToHRESULT(JET_errRecordNotFound));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::ReadDBParameter( /*[in] */ LPCWSTR  szName  ,
                                            /*[out]*/ long&    lValue  ,
                                            /*[out]*/ bool    *pfFound )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::ReadDBParameter" );

    HRESULT      hr;
    MPC::wstring strValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ReadDBParameter( szName, strValue, pfFound ));

    lValue = _wtol( strValue.c_str() );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Updater::WriteDBParameter( /*[in]*/ LPCWSTR szName  ,
                                             /*[in]*/ LPCWSTR szValue )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::WriteDBParameter" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDBParameters());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsDBParameters->Seek_ByName( szName, &fFound ));

    JET_SET_FIELD_TRISTATE(m_rsDBParameters,m_strValue,m_fValid__Value,szValue,STRINGISPRESENT(szValue));

    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsDBParameters->Update());
    }
    else
    {
        m_rsDBParameters->m_strName = szName;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsDBParameters->Insert());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::WriteDBParameter( /*[in]*/ LPCWSTR szName ,
                                             /*[in]*/ long    lValue )
{
    WCHAR rgValue[64]; swprintf( rgValue, L"%ld", lValue );

    return WriteDBParameter( szName, rgValue );
}

HRESULT Taxonomy::Updater::AddWordToSet( /*[in]*/ Updater_Set id      ,
                                         /*[in]*/ LPCWSTR     szValue )
{
    return m_sets[id].Add( szValue );
}

HRESULT Taxonomy::Updater::RemoveWordFromSet( /*[in]*/ Updater_Set id, /*[in]*/ LPCWSTR szValue )
{
    return m_sets[id].Remove( szValue );
}

const MPC::wstring& Taxonomy::Updater::GetHelpLocation()
{
    if(m_strDBLocation.size() == 0)
    {
        if(Taxonomy::InstalledInstanceStore::s_GLOBAL)
		{
			Taxonomy::LockingHandle         handle;
			Taxonomy::InstalledInstanceIter it;
			bool                     	    fFound;

			if(SUCCEEDED(Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle           )) && 
			   SUCCEEDED(Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_ts, fFound, it )) && fFound)
			{
				m_strDBLocation = it->m_inst.m_strHelpFiles;
			}
		}

		if(m_strDBLocation.size() == 0)
		{
            m_strDBLocation = HC_HELPSVC_HELPFILES_DEFAULT;
        }
    }

    return m_strDBLocation;
}

HRESULT Taxonomy::Updater::ExpandURL( /*[in/out]*/ MPC::wstring& strURL )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::ExpandURL" );

    HRESULT hr;
    LPCWSTR szEnd;


    GetHelpLocation();


    szEnd = strURL.c_str();
    while((szEnd = wcschr( szEnd, '%' )))
    {
        if(!_wcsnicmp( szEnd, s_DB_LOCATION_ENV, MAXSTRLEN( s_DB_LOCATION_ENV ) ))
        {
            MPC::wstring::size_type pos = szEnd - strURL.c_str();

            strURL.replace( pos, MAXSTRLEN( s_DB_LOCATION_ENV ), m_strDBLocation );
            break;
        }

        szEnd++;
    }

    hr = MPC::SubstituteEnvVariables( strURL );


    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::CollapseURL( /*[in/out]*/ MPC::wstring& strURL )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CollapseURL" );

    HRESULT      hr;
    MPC::wstring strBASE;
    CComBSTR     bstrBASE;
    CComBSTR     bstrURL;
    LPCWSTR      szEnd;


    GetHelpLocation(); (void)MPC::SubstituteEnvVariables( strBASE = m_strDBLocation );

    bstrBASE = strBASE.c_str(); ::CharUpperW( bstrBASE );
    bstrURL  = strURL .c_str(); ::CharUpperW( bstrURL  );

    if(szEnd = wcsstr( bstrURL, bstrBASE ))
    {
        MPC::wstring::size_type pos = szEnd - bstrURL;

        strURL.replace( pos, bstrBASE.Length(), s_DB_LOCATION_ENV );
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::ListAllTheHelpFiles( /*[out]*/ MPC::WStringList& lstFiles )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::ListAllTheHelpFiles" );

    HRESULT  hr;
    WordSet  setFiles;
    WordIter it;
    bool     fFound;


    //
    // Get all the files from the HelpImage list.
    //
    if(SUCCEEDED(GetHelpImage()))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsHelpImage->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
            if(m_rsHelpImage->m_strFile.empty() == false) setFiles.insert( m_rsHelpImage->m_strFile );

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsHelpImage->Move( 0, JET_MoveNext, &fFound ));
        }
    }

    //
    // Get all the CHM and CHQ from the FullTextSearch list.
    //
    if(SUCCEEDED(GetFullTextSearch()))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
            if(m_rsFullTextSearch->m_strCHM.empty() == false) setFiles.insert( m_rsFullTextSearch->m_strCHM );
            if(m_rsFullTextSearch->m_strCHQ.empty() == false) setFiles.insert( m_rsFullTextSearch->m_strCHQ );

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Move( 0, JET_MoveNext, &fFound ));
        }
    }

    //
    // Get all the CHM from the IndexFiles list.
    //
    if(SUCCEEDED(GetIndexFiles()))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
            if(m_rsIndexFiles->m_strStorage.empty() == false) setFiles.insert( m_rsIndexFiles->m_strStorage );

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Move( 0, JET_MoveNext, &fFound ));
        }
    }

    //
    // From a set to a list to a VARIANT.
    //
    for(it = setFiles.begin(); it != setFiles.end(); it++)
    {
        lstFiles.push_back( *it );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GetIndexInfo( /*[out]*/ MPC::wstring& strLocation, /*[out]*/ MPC::wstring& strDisplayName, /*[in]*/ LPCWSTR szScope )
{
	__HCP_FUNC_ENTRY( "Taxonomy::Updater::GetIndexInfo" );

    HRESULT hr;
	long    ID_Scope = -1;
	long    lOwner;


	if(szScope)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, LocateScope( ID_Scope, lOwner, szScope ));
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.IndexFile( strLocation, ID_Scope ));

	strDisplayName = m_rsScope->m_strName;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::DeleteOwner()
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteOwner" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetContentOwners());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsContentOwners->Move( 0, JET_MoveFirst, &fFound ));
    while(fFound)
    {
        if(m_rsContentOwners->m_ID_owner == m_ID_owner)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsContentOwners->Delete()); STAT_DELETED( ContentOwners );
            m_ID_owner = -1;
            break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsContentOwners->Move( 0, JET_MoveNext, &fFound ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateOwner( /*[in] */ LPCWSTR szDN )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateOwner" );

    HRESULT hr;
    bool    fFound;

    m_ID_owner = -1;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetContentOwners());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsContentOwners->Seek_ByVendorID( szDN, &fFound ));
    if(fFound)
    {
        m_ID_owner = m_rsContentOwners->m_ID_owner;
        m_fOEM     = m_rsContentOwners->m_fIsOEM;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::CreateOwner( /*[out]*/ long&   ID_owner,
                                        /*[in] */ LPCWSTR szDN   ,
                                        /*[in] */ bool    fIsOEM )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CreateOwner" );

    HRESULT hr;
    bool    fFound;

    ID_owner = -1;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetContentOwners());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsContentOwners->Seek_ByVendorID( szDN, &fFound ));

    m_rsContentOwners->m_fIsOEM = fIsOEM;

    if(fFound == true)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsContentOwners->Update()); STAT_MODIFIED( ContentOwners );
    }
    else
    {
        m_rsContentOwners->m_strDN = szDN;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsContentOwners->Insert()); STAT_CREATED( ContentOwners );
    }

    ID_owner = m_rsContentOwners->m_ID_owner;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::DeleteSynSet( /*[in]*/ LPCWSTR szName )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteSynSet" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetSynSets());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynSets->Seek_ByPair( szName, m_ID_owner, &fFound ));
    if(fFound)
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynSets->Delete()); STAT_DELETED( SynSets );
    }
	else
	{
		STAT_NOOP( SynSets );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateSynSet( /*[out]*/ long&   ID_synset ,
										 /*[in] */ LPCWSTR szName    )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateSynSet" );

    HRESULT hr;
    bool    fFound;

    ID_synset = -1;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetSynSets());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynSets->Seek_ByPair( szName, m_ID_owner, &fFound ));
    if(fFound)
    {
        ID_synset = m_rsSynSets->m_ID_synset;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::CreateSynSet( /*[out]*/ long&   ID_synset ,
										 /*[in ]*/ LPCWSTR szName    )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CreateSynSet" );

    HRESULT hr;
    bool    fFound;

    ID_synset = -1;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetSynSets());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynSets->Seek_ByPair( szName, m_ID_owner, &fFound ));
    if(!fFound)
    {
        m_rsSynSets->m_strName  = szName;
        m_rsSynSets->m_ID_owner = m_ID_owner;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynSets->Insert()); STAT_CREATED( SynSets );
    }
	else
	{
		STAT_NOOP( SynSets );
	}

    ID_synset = m_rsSynSets->m_ID_synset;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////


HRESULT Taxonomy::Updater::DeleteSynonym( /*[in]*/ long    ID_synset ,
										  /*[in]*/ LPCWSTR szName    )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteSynonym" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetSynonyms());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynonyms->Seek_ByPair( szName, ID_synset, &fFound ));
    if(fFound)
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynonyms->Delete()); STAT_DELETED( Synonyms );
    }
	else
	{
		STAT_NOOP( Synonyms );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::CreateSynonym( /*[in]*/ long    ID_synset ,
										  /*[in]*/ LPCWSTR szName    )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CreateSynonym" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetSynonyms());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynonyms->Seek_ByPair( szName, ID_synset, &fFound ));
    if(!fFound)
    {
        m_rsSynonyms->m_strKeyword = szName;
        m_rsSynonyms->m_ID_synset  = ID_synset;
        m_rsSynonyms->m_ID_owner   = m_ID_owner;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynonyms->Insert()); STAT_CREATED( Synonyms );
    }
	else
	{
		STAT_NOOP( Synonyms );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT Taxonomy::Updater::LocateSynonyms( /*[in ]*/ LPCWSTR           szName      ,
										   /*[out]*/ MPC::WStringList& lst         ,
										   /*[in ]*/ bool              fMatchOwner )
{
	__HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateSynonyms" );

	HRESULT hr;
	bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetSynonyms());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynonyms->Seek_ByName( szName, &fFound ));
    while(fFound)
    {
		if(fMatchOwner == false || m_rsSynonyms->m_ID_owner == m_ID_owner)
		{
			WCHAR rgBuf[64]; swprintf( rgBuf, L"SYNSET_%ld", m_rsSynonyms->m_ID_synset );

			lst.push_back( rgBuf );
		}

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsSynonyms->Move( 0, JET_MoveNext, &fFound ));
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::AddFile( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::AddFile" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetHelpImage());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsHelpImage->Seek_ByFile( szFile, &fFound ));
    if(fFound)
    {
        if(m_rsHelpImage->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

		STAT_NOOP( HelpImage );
    }
    else
    {
        JET_SET_FIELD(m_rsHelpImage,m_ID_owner,m_ID_owner);
        JET_SET_FIELD(m_rsHelpImage,m_strFile ,  szFile  );

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsHelpImage->Insert()); STAT_CREATED( HelpImage );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::RemoveFile( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::RemoveFile" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetHelpImage());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsHelpImage->Seek_ByFile( szFile, &fFound ));
    if(fFound)
    {
        if(m_rsHelpImage->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsHelpImage->Delete()); STAT_DELETED( HelpImage );
    }
	else
	{
		STAT_NOOP( HelpImage );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::AddIndexFile( /*[in]*/ long ID_scope, /*[in]*/ LPCWSTR szStorage, /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::AddIndexFile" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetIndexFiles());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Seek_ByScope( ID_scope, &fFound ));
    while(fFound)
    {
        if(!MPC::StrICmp( m_rsIndexFiles->m_strStorage, szStorage ) &&
           !MPC::StrICmp( m_rsIndexFiles->m_strFile   , szFile    )  )
        {
            if(m_rsIndexFiles->m_ID_owner != m_ID_owner)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
            }

			break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Move( 0, JET_MoveNext, &fFound ));
    }


    JET_SET_FIELD_TRISTATE(m_rsIndexFiles,m_strStorage,m_fValid__Storage,szStorage,STRINGISPRESENT(szStorage));
    JET_SET_FIELD_TRISTATE(m_rsIndexFiles,m_strFile   ,m_fValid__File   ,szFile   ,STRINGISPRESENT(szFile   ));


    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Update()); STAT_MODIFIED( IndexFiles );
    }
    else
    {
        JET_SET_FIELD(m_rsIndexFiles,m_ID_owner,m_ID_owner);
        JET_SET_FIELD(m_rsIndexFiles,m_ID_scope,  ID_scope);

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Insert()); STAT_CREATED( IndexFiles );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::RemoveIndexFile( /*[in]*/ long ID_scope, /*[in]*/ LPCWSTR szStorage, /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::RemoveIndexFile" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetIndexFiles());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Seek_ByScope( ID_scope, &fFound ));
    while(fFound)
    {
        if(!MPC::StrICmp( m_rsIndexFiles->m_strStorage, szStorage ) &&
           !MPC::StrICmp( m_rsIndexFiles->m_strFile   , szFile    )  )
        {
            if(m_rsIndexFiles->m_ID_owner != m_ID_owner)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
            }

			break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Move( 0, JET_MoveNext, &fFound ));
    }

    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsIndexFiles->Delete()); STAT_DELETED( IndexFiles );
    }
	else
	{
		STAT_NOOP( IndexFiles );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::AddFullTextSearchQuery( /*[in]*/ long ID_scope, /*[in]*/ LPCWSTR szCHM, /*[in]*/ LPCWSTR szCHQ )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::AddFullTextSearchQuery" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFullTextSearch());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Seek_ByScope( ID_scope, &fFound ));
    while(fFound)
    {
        if(!MPC::StrICmp( m_rsFullTextSearch->m_strCHM, szCHM ))
        {
            if(m_rsFullTextSearch->m_ID_owner != m_ID_owner)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
            }

            break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Move( 0, JET_MoveNext, &fFound ));
    }


    JET_SET_FIELD_TRISTATE(m_rsFullTextSearch,m_strCHM,m_fValid__CHM, szCHM,STRINGISPRESENT(szCHM));
    JET_SET_FIELD_TRISTATE(m_rsFullTextSearch,m_strCHQ,m_fValid__CHQ, szCHQ,STRINGISPRESENT(szCHQ));


    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Update()); STAT_MODIFIED( FullTextSearch );
    }
    else
    {
        JET_SET_FIELD(m_rsFullTextSearch,m_ID_owner,m_ID_owner);
        JET_SET_FIELD(m_rsFullTextSearch,m_ID_scope,  ID_scope);

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Insert()); STAT_CREATED( FullTextSearch );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::RemoveFullTextSearchQuery( /*[in]*/ long ID_scope, /*[in]*/ LPCWSTR szCHM )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::RemoveFullTextSearchQuery" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFullTextSearch());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Seek_ByScope( ID_scope, &fFound ));
    while(fFound)
    {
        if(!MPC::StrICmp( m_rsFullTextSearch->m_strCHM, szCHM ))
        {
            if(m_rsFullTextSearch->m_ID_owner != m_ID_owner)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
            }

            break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Move( 0, JET_MoveNext, &fFound ));
    }

    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsFullTextSearch->Delete()); STAT_DELETED( FullTextSearch );
    }
	else
	{
		STAT_NOOP( FullTextSearch );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


HRESULT Taxonomy::Updater::RemoveScope( /*[in]*/ long ID_scope )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::RemoveScope" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetScope());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsScope->Seek_ByScope( ID_scope, &fFound ));
    if(fFound)
    {
        if(m_rsScope->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsScope->Delete()); STAT_DELETED( Scope );
    }
	else
	{
		STAT_NOOP( Scope );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateScope( /*[out]*/ long& ID_scope, /*[out]*/ long& ID_owner, /*[in]*/ LPCWSTR szID )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateScope" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetScope());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsScope->Seek_ByID( szID, &fFound ));
    if(fFound)
    {
        ID_scope = m_rsScope->m_ID_scope;
        ID_owner = m_rsScope->m_ID_owner;
    }
    else
    {
        ID_scope = -1;
        ID_owner = -1;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::CreateScope( /*[out]*/ long& ID_scope, /*[in]*/ LPCWSTR szID, /*[in]*/ LPCWSTR szName, /*[in]*/ LPCWSTR szCategory )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CreateScope" );

    HRESULT hr;
    bool    fFound;

    ID_scope = -1;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetScope());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsScope->Seek_ByID( szID, &fFound ));
    if(fFound)
    {
        if(m_rsScope->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }
    }


    JET_SET_FIELD         (m_rsScope,m_strID      ,                   szID                                  );
    JET_SET_FIELD         (m_rsScope,m_strName    ,                   szName                                );
    JET_SET_FIELD_TRISTATE(m_rsScope,m_strCategory,m_fValid__Category,szCategory,STRINGISPRESENT(szCategory));


    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsScope->Update()); STAT_MODIFIED( Scope );
    }
    else
    {
        JET_SET_FIELD(m_rsScope,m_ID_owner, m_ID_owner);

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsScope->Insert()); STAT_CREATED( Scope );
    }

    ID_scope = m_rsScope->m_ID_scope;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool Taxonomy::Updater::NodeCache_FindNode( /*[in ]*/ MPC::wstringUC& strPathUC, /*[out]*/ JetBlue::Id2NodeIter& itNode )
{
	itNode = m_nodes.find( strPathUC );

	return (itNode != m_nodes.end());
}

bool Taxonomy::Updater::NodeCache_FindId( /*[in ]*/ long ID_node, /*[out]*/ JetBlue::Node2IdIter& itId )
{
	itId = m_nodes_reverse.find( ID_node );

	return (itId != m_nodes_reverse.end());
}


void Taxonomy::Updater::NodeCache_Add( /*[in]*/ MPC::wstringUC& strPathUC, /*[in]*/ long ID_node )
{
	m_nodes        [ strPathUC ] = ID_node;
	m_nodes_reverse[ ID_node   ] = strPathUC;
}

void Taxonomy::Updater::NodeCache_Remove( /*[in]*/ long ID_node )
{
	JetBlue::Node2IdIter itId;
	JetBlue::Id2NodeIter itNode;

	itId = m_nodes_reverse.find( ID_node );
	if(itId != m_nodes_reverse.end())
	{
		m_nodes        .erase( itId->second );
		m_nodes_reverse.erase( itId         );
	}
}

void Taxonomy::Updater::NodeCache_Clear()
{
	m_nodes        .clear();
	m_nodes_reverse.clear();
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::DeleteTaxonomyNode( /*[in ]*/ long ID_node )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteTaxonomyNode" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTaxonomy());
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTopics  ());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Seek_Node( ID_node, &fFound ));
    if(fFound)
    {
        if(m_rsTaxonomy->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

        //
        // Before deleting the node, check everything below it can be deleted, then delete it.
        //
        {
            RS_Taxonomy subrs( *m_rsTaxonomy );

            __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteAllSubNodes( &subrs, ID_node, true  ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteAllSubNodes( &subrs, ID_node, false ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Delete()); STAT_DELETED( Taxonomy );

		//
		// Keep the node cache in sync.
		//
		NodeCache_Remove( ID_node );
    }
	else
	{
		STAT_NOOP( Taxonomy );
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateTaxonomyNode( /*[out]*/ long&   ID_node        ,
                                               /*[in ]*/ LPCWSTR szTaxonomyPath ,
                                               /*[in ]*/ bool    fLookForFather )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateTaxonomyNode" );

    HRESULT            	   hr;
    MPC::WStringVector 	   vec;
    MPC::WStringVectorIter it;
	MPC::wstring           strPath;
	MPC::wstringUC         strPathUC;
	JetBlue::Id2NodeIter   itNode;
    long               	   idCurrent = -1;
    int                	   iLast;
    int                	   i;

    ID_node = -1;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTaxonomy());

    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::Settings::SplitNodePath( szTaxonomyPath, vec ));

	it    = vec.begin();
    iLast = vec.size (); if(fLookForFather) iLast--;

    for(i=0; i<iLast; i++, it++)
    {
		//
		// Build partial node path.
		//
		if(strPath.size()) strPath.append( L"/" );
		strPath.append( *it );

		//
		// If we are already seen the node, it's in the cache.
		//
		if(NodeCache_FindNode( strPathUC = strPath, itNode ))
		{
			idCurrent = itNode->second;
		}
		else
		{
			LPCWSTR szEntry = it->c_str();

			if(m_cache == NULL || FAILED(m_cache->LocateNode( m_ts, idCurrent, szEntry, *m_rsTaxonomy )))
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Seek_SubNode( idCurrent, szEntry ));
			}

			idCurrent = m_rsTaxonomy->m_ID_node;

			//
			// Update cache.
			//
			NodeCache_Add( strPathUC, idCurrent );
		}
    }

    ID_node = idCurrent;
    hr      = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::CreateTaxonomyNode( /*[out]*/ long&   ID_node        ,
                                               /*[in ]*/ LPCWSTR szTaxonomyPath ,
                                               /*[in ]*/ LPCWSTR szTitle        ,
                                               /*[in ]*/ LPCWSTR szDescription  ,
                                               /*[in ]*/ LPCWSTR szURI          ,
                                               /*[in ]*/ LPCWSTR szIconURI      ,
                                               /*[in ]*/ bool    fVisible       ,
                                               /*[in ]*/ bool    fSubsite       ,
                                               /*[in ]*/ long    lNavModel      ,
                                               /*[in ]*/ long    lPos           )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CreateTaxonomyNode" );

    HRESULT hr;
    LPCWSTR szEntry;
    long    ID_parent;
	bool    fFound;

    ID_node = -1;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(szTaxonomyPath);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTaxonomy());


    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_parent, szTaxonomyPath, true ));

    //
    // Extract the last component of the Category.
    //
    if((szEntry = wcsrchr( szTaxonomyPath, '/' )))
    {
        szEntry++;
    }
    else
    {
        szEntry = szTaxonomyPath;
    }


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Seek_SubNode( ID_parent, szEntry, &fFound ));
	if(fFound && m_rsTaxonomy->m_ID_owner != m_ID_owner)
	{
		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
	}

	JET_SET_FIELD         (m_rsTaxonomy,m_lPos                                      ,  lPos                                        );
	JET_SET_FIELD_TRISTATE(m_rsTaxonomy,m_ID_parent        ,m_fValid__ID_parent     ,  ID_parent    ,(ID_parent != -1             ));
	JET_SET_FIELD         (m_rsTaxonomy,m_ID_owner                                  ,m_ID_owner                                    );
	JET_SET_FIELD         (m_rsTaxonomy,m_strEntry                                  ,  szEntry                                     );
	JET_SET_FIELD_TRISTATE(m_rsTaxonomy,m_strTitle         ,m_fValid__Title         ,  szTitle      ,STRINGISPRESENT(szTitle      ));
	JET_SET_FIELD_TRISTATE(m_rsTaxonomy,m_strDescription   ,m_fValid__Description   ,  szDescription,STRINGISPRESENT(szDescription));
	JET_SET_FIELD_TRISTATE(m_rsTaxonomy,m_strDescriptionURI,m_fValid__DescriptionURI,  szURI        ,STRINGISPRESENT(szURI        ));
	JET_SET_FIELD_TRISTATE(m_rsTaxonomy,m_strIconURI       ,m_fValid__IconURI       ,  szIconURI    ,STRINGISPRESENT(szIconURI    ));
	JET_SET_FIELD         (m_rsTaxonomy,m_fVisible                                  ,  fVisible                                    );
	JET_SET_FIELD         (m_rsTaxonomy,m_fSubsite                                  ,  fSubsite                                    );
	JET_SET_FIELD         (m_rsTaxonomy,m_lNavModel                                 ,  lNavModel                                   );

	if(fFound)
	{
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Update()); STAT_MODIFIED( Taxonomy );
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Insert()); STAT_CREATED( Taxonomy );
	}

	ID_node = m_rsTaxonomy->m_ID_node;

	{
		JetBlue::Node2IdIter itId;

		if(NodeCache_FindId( ID_parent, itId ))
		{
			MPC::wstring strPath = itId->second;

			strPath.append( L"/"    );
			strPath.append( szEntry );

			//
			// Update cache.
			//
			NodeCache_Add( MPC::wstringUC( strPath ), ID_node );
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::DeleteTopicEntry( /*[in]*/ long ID_topic )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::DeleteTopicEntry" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTopics ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetMatches());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Seek_SingleTopic( ID_topic, &fFound ));
    if(fFound)
    {
        if(m_rsTopics->m_ID_owner != m_ID_owner)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteAllMatchesPointingToTopic( m_rsMatches, ID_topic ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Delete()); STAT_DELETED( Topics );
    }
	else
	{
		STAT_NOOP( Topics );
	}


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateTopicEntry( /*[out]*/ long&   ID_topic    ,
                                             /*[in ]*/ long    ID_node     ,
                                             /*[in ]*/ LPCWSTR szURI       ,
                                             /*[in ]*/ bool    fCheckOwner )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateTopicEntry" );

    HRESULT hr;
    bool    fFound;

    ID_topic = -1;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTopics());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Seek_TopicsUnderNode( ID_node, &fFound ));
    while(fFound)
    {
        if(!MPC::StrICmp( m_rsTopics->m_strURI, szURI ))
        {
            if(fCheckOwner && m_rsTopics->m_ID_owner != m_ID_owner)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
            }

            ID_topic = m_rsTopics->m_ID_topic;
            break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Move( 0, JET_MoveNext, &fFound ));
    }




    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::CreateTopicEntry( /*[out]*/ long&   ID_topic      ,
                                             /*[in]*/  long    ID_node       ,
                                             /*[in]*/  LPCWSTR szTitle       ,
                                             /*[in]*/  LPCWSTR szURI         ,
                                             /*[in]*/  LPCWSTR szDescription ,
                                             /*[in]*/  LPCWSTR szIconURI     ,
                                             /*[in]*/  long    lType         ,
                                             /*[in]*/  bool    fVisible      ,
                                             /*[in]*/  long    lPos          )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CreateTopicEntry" );

    HRESULT hr;
    bool    fFound;

    ID_topic = -1;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(szTitle);
        __MPC_PARAMCHECK_NOTNULL(szURI);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTopics());


    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTopicEntry( ID_topic, ID_node, szURI, /*fCheckOwner*/true ));

    JET_SET_FIELD         (m_rsTopics,m_ID_node                             ,  ID_node                                     );
    JET_SET_FIELD         (m_rsTopics,m_ID_owner                            ,m_ID_owner                                    );
    JET_SET_FIELD_TRISTATE(m_rsTopics,m_strTitle      ,m_fValid__Title      ,  szTitle      ,STRINGISPRESENT(szTitle      ));
    JET_SET_FIELD_TRISTATE(m_rsTopics,m_strURI        ,m_fValid__URI        ,  szURI        ,STRINGISPRESENT(szURI        ));
    JET_SET_FIELD_TRISTATE(m_rsTopics,m_strDescription,m_fValid__Description,  szDescription,STRINGISPRESENT(szDescription));
    JET_SET_FIELD_TRISTATE(m_rsTopics,m_strIconURI    ,m_fValid__IconURI    ,  szIconURI    ,STRINGISPRESENT(szIconURI    ));
    JET_SET_FIELD         (m_rsTopics,m_lType                               ,  lType                                       );
    JET_SET_FIELD         (m_rsTopics,m_lPos                                ,  lPos                                        );
    JET_SET_FIELD         (m_rsTopics,m_fVisible                            ,  fVisible                                    );


    if(ID_topic == -1)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Insert()); STAT_CREATED( Topics );

        ID_topic = m_rsTopics->m_ID_topic;
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Update()); STAT_MODIFIED( Topics );
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::CreateMatch( /*[in]*/ LPCWSTR szKeyword ,
                                        /*[in]*/ long    ID_topic  ,
										/*[in]*/ long    lPriority ,
                                        /*[in]*/ bool    fHHK      )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::CreateMatch" );

    HRESULT hr;
    bool    fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetKeywords());
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetMatches ());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsKeywords->Seek_ByName( szKeyword, &fFound ));
    if(fFound == false)
    {
        JET_SET_FIELD(m_rsKeywords,m_strKeyword,szKeyword);

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsKeywords->Insert()); STAT_CREATED( Keywords );
    }


    JET_SET_FIELD(m_rsMatches,m_ID_topic  ,ID_topic                  );
    JET_SET_FIELD(m_rsMatches,m_ID_keyword,m_rsKeywords->m_ID_keyword);
    JET_SET_FIELD(m_rsMatches,m_lPriority ,lPriority                 );
    JET_SET_FIELD(m_rsMatches,m_fHHK      ,fHHK                      );


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsMatches->Seek_Pair( m_rsKeywords->m_ID_keyword, ID_topic, &fFound ));
	if(fFound)
	{
		if(m_rsMatches->m_lPriority != lPriority ||
		   m_rsMatches->m_fHHK      != fHHK       )
		{
			JET_SET_FIELD(m_rsMatches,m_lPriority,lPriority);
			JET_SET_FIELD(m_rsMatches,m_fHHK     ,fHHK     );

			__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsMatches->Update()); STAT_MODIFIED( Matches );
		}
		else
		{
			STAT_NOOP( Matches );
		}
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_rsMatches->Insert()); STAT_CREATED( Matches );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Updater::MakeRoomForInsert( /*[in ]*/ LPCWSTR szNodeStr ,
                                              /*[in ]*/ LPCWSTR szMode    ,
                                              /*[in ]*/ LPCWSTR szID      ,
                                              /*[out]*/ long&   lPos      )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::MakeRoomForInsert" );

    HRESULT      hr;
    QueryResults qr( *this );
    long         ID_node;


    lPos = -1;


	__MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szNodeStr, false ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, qr.MakeRoomForInsert( szMode, szID, ID_node, lPos ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateSubNodes( /*[in] */ long      ID_node      ,
                                           /*[in] */ bool      fRecurse     ,
										   /*[in] */ bool      fOnlyVisible ,
                                           /*[out]*/ MatchSet& res          )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateSubNodes" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_cache);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cache->LocateSubNodes( m_ts, ID_node, fRecurse, fOnlyVisible, res ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateNodesFromURL( /*[in ]*/ LPCWSTR   szURL ,
											   /*[out]*/ MatchSet& res   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateNodesFromURL" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_cache);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cache->LocateNodesFromURL( m_ts, szURL, res ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LookupNode( /*[in]*/ LPCWSTR                    szNodeStr ,
                                       /*[in]*/ CPCHQueryResultCollection* pColl     )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LookupNode" );

    HRESULT                  hr;
    OfflineCache::Entry_Type et = OfflineCache::ET_NODE;
    QueryResults             qr( *this );
    long                     ID_node;
    MPC::wstring             strParent;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    if(m_fUseCache && m_cache && SUCCEEDED(m_cache->RetrieveQuery( m_ts, szNodeStr, et, pColl )))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    ////////////////////

    //
    // Find the father of the node.
    //
    if(szNodeStr)
    {
        LPCWSTR szEnd = wcsrchr( szNodeStr, '/' );

        if(szEnd)
        {
            strParent.assign( szNodeStr, szEnd );
        }
        else
        {
            ; // Root
        }
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szNodeStr, false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.Append( m_rsTaxonomy, strParent.c_str() ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.PopulateCollection( pColl ));


    ////////////////////

    if(m_fUseCache && m_cache && FAILED(m_cache->StoreQuery( m_ts, szNodeStr, et, pColl )))
    {
        ; // Cache failures are not fatal, don't abort.
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LookupSubNodes( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                           /*[in]*/ bool                       fVisibleOnly ,
                                           /*[in]*/ CPCHQueryResultCollection* pColl        )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LookupSubNodes" );

    HRESULT                  hr;
    OfflineCache::Entry_Type et = fVisibleOnly ? OfflineCache::ET_SUBNODES_VISIBLE : OfflineCache::ET_SUBNODES;
    QueryResults             qr( *this );
    long                     ID_node;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    if(m_fUseCache && m_cache && SUCCEEDED(m_cache->RetrieveQuery( m_ts, szNodeStr, et, pColl )))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szNodeStr, false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.LookupNodes( szNodeStr, ID_node, fVisibleOnly ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.PopulateCollection( pColl ));

    ////////////////////

    if(m_fUseCache && m_cache && FAILED(m_cache->StoreQuery( m_ts, szNodeStr, et, pColl )))
    {
        ; // Cache failures are not fatal, don't abort.
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LookupNodesAndTopics( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                                 /*[in]*/ bool                       fVisibleOnly ,
                                                 /*[in]*/ CPCHQueryResultCollection* pColl        )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LookupNodesAndTopics" );

    HRESULT                  hr;
    OfflineCache::Entry_Type et = fVisibleOnly ? OfflineCache::ET_NODESANDTOPICS_VISIBLE : OfflineCache::ET_NODESANDTOPICS;
    QueryResults             qr( *this );
    long                     ID_node;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    if(m_fUseCache && m_cache && SUCCEEDED(m_cache->RetrieveQuery( m_ts, szNodeStr, et, pColl )))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szNodeStr, false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.LookupNodes ( szNodeStr, ID_node, fVisibleOnly ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.LookupTopics( szNodeStr, ID_node, fVisibleOnly ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.PopulateCollection( pColl ));

    ////////////////////

    if(m_fUseCache && m_cache && FAILED(m_cache->StoreQuery( m_ts, szNodeStr, et, pColl )))
    {
        ; // Cache failures are not fatal, don't abort.
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LookupTopics( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                         /*[in]*/ bool                       fVisibleOnly ,
                                         /*[in]*/ CPCHQueryResultCollection* pColl        )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LookupTopics" );

    HRESULT                  hr;
    OfflineCache::Entry_Type et = fVisibleOnly ? OfflineCache::ET_TOPICS_VISIBLE : OfflineCache::ET_TOPICS;
    QueryResults             qr( *this );
    long                     ID_node;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    if(m_fUseCache && m_cache && SUCCEEDED(m_cache->RetrieveQuery( m_ts, szNodeStr, et, pColl )))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szNodeStr, false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.LookupTopics( szNodeStr, ID_node, fVisibleOnly ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.PopulateCollection( pColl ));

    ////////////////////

    if(m_fUseCache && m_cache && FAILED(m_cache->StoreQuery( m_ts, szNodeStr, et, pColl )))
    {
        ; // Cache failures are not fatal, don't abort.
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::LocateContext( /*[in]*/ LPCWSTR                    szURL     ,
                                          /*[in]*/ LPCWSTR                    szSubSite ,
                                          /*[in]*/ CPCHQueryResultCollection* pColl     )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::LocateContext" );

    HRESULT             hr;
    QueryResults        qr( *this );
    Taxonomy::MatchSet  setNodes;
    Taxonomy::MatchSet  setNodes2;
	Taxonomy::MatchIter it2;
    MPC::wstring        strURL;
    MPC::wstring        strPath;
	long                ID_node;
    bool                fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szURL);
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


	SANITIZEWSTR(szSubSite);


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTopics());


    __MPC_EXIT_IF_METHOD_FAILS(hr, CollapseURL( strURL = szURL ));

    //
    // Locate the subsite.
    //
	__MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szSubSite, false ));

	//
	// Create the set of nodes in the subsite.
	//
	setNodes.insert( ID_node ); // Add the node itself.
	__MPC_EXIT_IF_METHOD_FAILS(hr, LocateSubNodes( ID_node, /*fRecurse*/true, /*fOnlyVisible*/true, setNodes ));

	//
	// Also create the set of nodes matching the URL.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, LocateNodesFromURL( strURL.c_str(), setNodes2 ));


    //
    // For all the topics matching the URL, create an entry.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Seek_ByURI( strURL.c_str(), &fFound ));
    while(fFound)
    {
        long ID_node = m_rsTopics->m_ID_node;

        if(setNodes.find( ID_node ) != setNodes.end())
        {
            if(m_fUseCache && m_cache)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_cache->BuildNodePath( m_ts, ID_node, strPath, /*fParent*/false ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, qr.Append( m_rsTopics, strPath.c_str() ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Move( 0, JET_MoveNext, &fFound ));

    }

    //
    // For all the nodes matching the URL, create an entry.
    //
	for(it2 = setNodes2.begin(); it2 != setNodes2.end(); it2++)
	{
        long ID_node = *it2;

        if(setNodes.find( ID_node ) != setNodes.end())
        {
            if(m_fUseCache && m_cache)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_cache->BuildNodePath( m_ts, ID_node, strPath, /*fParent*/false ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, qr.Append( m_rsTopics, strPath.c_str() ));
        }
	}


    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.PopulateCollection( pColl ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::KeywordSearch( /*[in]*/ LPCWSTR                    szQueryStr ,
                                          /*[in]*/ LPCWSTR                    szSubSite  ,
                                          /*[in]*/ CPCHQueryResultCollection* pColl      ,
										  /*[in]*/ MPC::WStringList*          lst        )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::KeywordSearch" );

    HRESULT                 hr;
    Taxonomy::KeywordSearch ks( *this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szQueryStr);
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ks.Execute( szQueryStr, szSubSite, pColl, lst ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Updater::GatherNodes( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                        /*[in]*/ bool                       fVisibleOnly ,
                                        /*[in]*/ CPCHQueryResultCollection* pColl        )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GatherNodes" );

    HRESULT      hr;
    QueryResults qr( *this );
    MatchSet     setNodes;
    long         ID_node;
    bool         fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szNodeStr, /*fLookForFather*/false                         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateSubNodes    ( ID_node,            /*fRecurse      */true , fVisibleOnly, setNodes ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Move( 0, JET_MoveFirst, &fFound ));
    while(fFound)
    {
        if(fVisibleOnly == false || m_rsTaxonomy->m_fVisible)
        {
            if(setNodes.find( m_rsTaxonomy->m_ID_node ) != setNodes.end())
            {
                MPC::wstring strPath;

                if(m_fUseCache && m_cache)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cache->BuildNodePath( m_ts, m_rsTaxonomy->m_ID_node, strPath, /*fParent*/true ));
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, qr.Append( m_rsTaxonomy, strPath.c_str() ));
            }
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTaxonomy->Move( 0, JET_MoveNext, &fFound ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.PopulateCollection( pColl ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Updater::GatherTopics( /*[in]*/ LPCWSTR                    szNodeStr    ,
                                         /*[in]*/ bool                       fVisibleOnly ,
                                         /*[in]*/ CPCHQueryResultCollection* pColl        )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Updater::GatherTopics" );

    HRESULT            hr;
    Taxonomy::MatchSet setNodes;
    QueryResults       qr( *this );
    long               ID_node;
    bool               fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTopics());

    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateTaxonomyNode( ID_node, szNodeStr, /*fLookForFather*/false                         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LocateSubNodes    ( ID_node,            /*fRecurse      */true , fVisibleOnly, setNodes ));
    setNodes.insert( ID_node ); // Add the node itself.

    //
    // Create an entry for each topic.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Move( 0, JET_MoveFirst, &fFound ));
    while(fFound)
    {
        if(fVisibleOnly == false || m_rsTopics->m_fVisible)
        {
            if(setNodes.find( m_rsTopics->m_ID_node ) != setNodes.end())
            {
                MPC::wstring strPath;

                if(m_fUseCache && m_cache)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cache->BuildNodePath( m_ts, m_rsTaxonomy->m_ID_node, strPath, /*fParent*/false ));
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, qr.Append( m_rsTopics, strPath.c_str() ));
            }
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Move( 0, JET_MoveNext, &fFound ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, qr.PopulateCollection( pColl ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\package.cpp ===
/********************************************************************

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:
    Package.cpp

Abstract:
    Cryptography stuff for hcupdate packages

Revision History:

    Ghim-Sim Chua       (gschua)   07/07/99
        - created

    Davide Massarenti   (dmassare) 03/24/2001
        - moved into database code.

********************************************************************/

#include "stdafx.h"

#include <wintrust.h>
#include <wincrypt.h>
#include <sipbase.h>
#include <softpub.h>

////////////////////////////////////////////////////////////////////////////////

static void local_GetDNInfo( PCCERT_CONTEXT pCC               ,
                             LPCSTR         field             ,
                             LPCWSTR        fieldName         ,
                             MPC::wstring&  strBuf             ,
                             MPC::wstring*  strPlainName = NULL)
{
    WCHAR rgTmp[512];

    if(strBuf.length()) strBuf += L",";

    strBuf += fieldName;

    ::CertGetNameStringW( pCC, CERT_NAME_ATTR_TYPE, 0, (void*)field, rgTmp, MAXSTRLEN(rgTmp) ); rgTmp[MAXSTRLEN(rgTmp)] = 0;

    if(strPlainName) *strPlainName = rgTmp;

    strBuf += rgTmp;
}

////////////////////////////////////////////////////////////////////////////////

Taxonomy::Package::Package()
{
                          // MPC::wstring m_strFileName;
    m_fTemporary = false; // bool         m_fTemporary;
    m_lSequence  = 0;     // long         m_lSequence;
    m_dwCRC      = 0;     // DWORD        m_dwCRC;
                          //
                          // MPC::wstring m_strSKU;
                          // MPC::wstring m_strLanguage;
                          // MPC::wstring m_strVendorID;
                          // MPC::wstring m_strVendorName;
                          // MPC::wstring m_strProductID;
                          // MPC::wstring m_strVersion;
                          //
    m_fMicrosoft = false; // bool         m_fMicrosoft;
    m_fBuiltin   = false; // bool         m_fBuiltin;
}

Taxonomy::Package::~Package()
{
    if(m_fTemporary) Remove( Logger() );
}

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::Package& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream >> val.m_lSequence    )) &&
       SUCCEEDED(hr = (stream >> val.m_dwCRC        )) &&

       SUCCEEDED(hr = (stream >> val.m_strSKU       )) &&
       SUCCEEDED(hr = (stream >> val.m_strLanguage  )) &&
       SUCCEEDED(hr = (stream >> val.m_strVendorID  )) &&
       SUCCEEDED(hr = (stream >> val.m_strVendorName)) &&
       SUCCEEDED(hr = (stream >> val.m_strProductID )) &&
       SUCCEEDED(hr = (stream >> val.m_strVersion   )) &&

       SUCCEEDED(hr = (stream >> val.m_fMicrosoft   )) &&
       SUCCEEDED(hr = (stream >> val.m_fBuiltin     ))  )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::Package& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream << val.m_lSequence    )) &&
       SUCCEEDED(hr = (stream << val.m_dwCRC        )) &&

       SUCCEEDED(hr = (stream << val.m_strSKU       )) &&
       SUCCEEDED(hr = (stream << val.m_strLanguage  )) &&
       SUCCEEDED(hr = (stream << val.m_strVendorID  )) &&
       SUCCEEDED(hr = (stream << val.m_strVendorName)) &&
       SUCCEEDED(hr = (stream << val.m_strProductID )) &&
       SUCCEEDED(hr = (stream << val.m_strVersion   )) &&

       SUCCEEDED(hr = (stream << val.m_fMicrosoft   )) &&
       SUCCEEDED(hr = (stream << val.m_fBuiltin     ))  )
    {
        hr = S_OK;
    }

    return hr;
}

////////////////////

static int local_nCompareVersion( /*[in]*/ DWORD dwVer1, /*[in]*/ DWORD dwBuild1 ,
                                  /*[in]*/ DWORD dwVer2, /*[in]*/ DWORD dwBuild2 )
{
    if(dwVer1 > dwVer2) return 1;
    if(dwVer1 < dwVer2) return -1;

    // dwVer1 == dwVer2
    if(dwBuild1 > dwBuild2) return 1;
    if(dwBuild1 < dwBuild2) return -1;

    return 0;
}

static bool local_fConvertDotVersionStrToDwords( /*[in ]*/ const MPC::wstring& strVer  ,
                                                 /*[out]*/ DWORD&              dwVer   ,
                                                 /*[out]*/ DWORD&              dwBuild )
{
    unsigned int iVerFields[4];

    if(swscanf( strVer.c_str(), L"%u.%u.%u.%u", &iVerFields[0], &iVerFields[1], &iVerFields[2], &iVerFields[3] ) == 4)
    {
        dwVer   = (iVerFields[0] << 16) + iVerFields[1];
        dwBuild = (iVerFields[2] << 16) + iVerFields[3];

        return true;
    }

    return false;
}

int Taxonomy::Package::Compare( /*[in]*/ const Package& pkg, /*[in]*/ DWORD dwMode ) const
{
    int   iCmp = 0;
    DWORD dwVer1;
    DWORD dwVer2;
    DWORD dwBuild1;
    DWORD dwBuild2;

	if(dwMode & c_Cmp_SKU)
	{
		iCmp = MPC::StrICmp( m_strSKU      , pkg.m_strSKU       ); if(iCmp) return iCmp;
		iCmp = MPC::StrICmp( m_strLanguage , pkg.m_strLanguage  ); if(iCmp) return iCmp;
	}

	if(dwMode & c_Cmp_ID)
	{
		iCmp = MPC::StrICmp( m_strVendorID , pkg.m_strVendorID  ); if(iCmp) return iCmp;
		iCmp = MPC::StrICmp( m_strProductID, pkg.m_strProductID ); if(iCmp) return iCmp;
	}

    if(dwMode & c_Cmp_VERSION)
    {
        if(local_fConvertDotVersionStrToDwords(     m_strVersion, dwVer1, dwBuild1 ) &&
           local_fConvertDotVersionStrToDwords( pkg.m_strVersion, dwVer2, dwBuild2 )  )
        {
            iCmp = local_nCompareVersion( dwVer1, dwBuild1, dwVer2, dwBuild2 );
        }
		else
		{
			iCmp = MPC::StrICmp( m_strVersion, pkg.m_strVersion );
		}
    }

    return iCmp;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::Package::GenerateFileName()
{
	HRESULT hr;

	if(m_strFileName.size() == 0)
	{
		WCHAR rgBuf[MAX_PATH]; _snwprintf( rgBuf, MAXSTRLEN(rgBuf), L"%s\\package_%ld.cab", HC_ROOT_HELPSVC_PKGSTORE, m_lSequence ); rgBuf[MAXSTRLEN(rgBuf)] = 0;

		if(FAILED(hr = MPC::SubstituteEnvVariables( m_strFileName = rgBuf ))) return hr;
	}

	return S_OK;
}


HRESULT Taxonomy::Package::Import( /*[in]*/ Logger&             log       ,
								   /*[in]*/ LPCWSTR             szFile    ,
								   /*[in]*/ long                lSequence ,
								   /*[in]*/ MPC::Impersonation* imp       )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Package::Import" );

    HRESULT hr;


    m_fTemporary = true;
    m_lSequence  = lSequence;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateFileName());

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( m_strFileName ));


    if(imp)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::CopyFileWhileImpersonating( szFile, m_strFileName.c_str(), *imp, /*fImpersonateForSource*/true ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile( szFile, m_strFileName.c_str() ));
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( m_dwCRC, m_strFileName.c_str() ));

	::SetFileAttributesW( m_strFileName.c_str(), FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM );

	log.WriteLog( -1, L"\nImported package %s into package store\n\n", szFile );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(FAILED(hr))
	{
		log.WriteLog( hr, L"Failed to copy %s into package store", szFile );
	}

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT local_GetSignerInfo( /*[in]*/ HCRYPTMSG hMsg, /*[in]*/ DWORD index, /*[in/out]*/ BYTE*& pSignerInfo )
{
    __HCP_FUNC_ENTRY( "local_GetSignerInfo" );

	HRESULT hr;
    BYTE* 	pbEncodedSigner = NULL;
	DWORD 	cbEncodedSigner = 0;
    DWORD 	cbSignerInfo    = 0;


	delete [] pSignerInfo; pSignerInfo = NULL;


    //
    // get the encoded signer BLOB
    //
	::CryptMsgGetParam( hMsg, CMSG_ENCODED_SIGNER, index, NULL, &cbEncodedSigner );

	__MPC_EXIT_IF_ALLOC_FAILS(hr, pbEncodedSigner, new BYTE[cbEncodedSigner]);

	__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptMsgGetParam( hMsg, CMSG_ENCODED_SIGNER, index, pbEncodedSigner, &cbEncodedSigner ));


    //
    // decode the EncodedSigner info
    //
	::CryptDecodeObject( PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING, PKCS7_SIGNER_INFO, pbEncodedSigner, cbEncodedSigner, 0, NULL, &cbSignerInfo );

	__MPC_EXIT_IF_ALLOC_FAILS(hr, pSignerInfo, new BYTE[cbSignerInfo]);

	__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptDecodeObject( PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING, PKCS7_SIGNER_INFO,
															  pbEncodedSigner, cbEncodedSigner, 0, pSignerInfo, &cbSignerInfo ));


	hr = S_OK;


	__HCP_FUNC_CLEANUP;

    delete [] pbEncodedSigner;

	__HCP_FUNC_EXIT(hr);
}


HRESULT Taxonomy::Package::Authenticate( /*[in]*/ Logger& log )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Package::Authenticate" );

    HRESULT hr;

    if(m_fBuiltin == false)
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, GenerateFileName());


        //
        // First, verify the signature is valid.
        //
        {
            WINTRUST_DATA      wtdWinTrust;
            WINTRUST_FILE_INFO wtfWinTrustFile;
            GUID               c_guidPubSoftwareTrustProv = WINTRUST_ACTION_GENERIC_VERIFY_V2;


            //
            // set up wintrust file info struct
            //
            ::ZeroMemory( &wtfWinTrustFile, sizeof(wtfWinTrustFile) );

            wtfWinTrustFile.cbStruct      = sizeof(wtfWinTrustFile);
            wtfWinTrustFile.pcwszFilePath = m_strFileName.c_str();
            wtfWinTrustFile.hFile         = NULL;


            //
            // set up wintrust data struct
            //
            ::ZeroMemory( &wtdWinTrust, sizeof(wtdWinTrust) );

            wtdWinTrust.cbStruct      = sizeof(wtdWinTrust);
            wtdWinTrust.dwUnionChoice = WTD_CHOICE_FILE;
            wtdWinTrust.pFile         = &wtfWinTrustFile;
            wtdWinTrust.dwUIChoice    = WTD_UI_NONE; // Whistler special : must always be silent otherwise won't come back

            // Verify the trust of the help package
			if(FAILED(hr = ::WinVerifyTrust( 0, &c_guidPubSoftwareTrustProv, &wtdWinTrust )))
			{
				LPCWSTR szError;

				switch(hr)
				{
				case TRUST_E_SUBJECT_NOT_TRUSTED : szError = L"subject not trusted" ; break;
				case TRUST_E_PROVIDER_UNKNOWN    : szError = L"provider unknown"    ; break;
				case TRUST_E_ACTION_UNKNOWN      : szError = L"action unknown"      ; break;
				case TRUST_E_SUBJECT_FORM_UNKNOWN: szError = L"subject form unknown"; break;
				default:                           szError = L"unknown"             ; break;
				}
			
				__MPC_SET_ERROR_AND_EXIT(hr, log.WriteLog( hr, L"Help package cannot be trusted\nError WinVerifyTrust %s", szError ));
			}
        }

        //
        // Then open the certificate and extract the DN.
        //
		{
			HCRYPTMSG hMsg = NULL;

			m_strVendorID.erase();

			if(::CryptQueryObject( CERT_QUERY_OBJECT_FILE,
								   m_strFileName.c_str(),
								   CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
								   CERT_QUERY_FORMAT_FLAG_BINARY             ,
								   0, NULL, NULL, NULL, NULL, &hMsg, NULL    ))
			{
				HCERTSTORE hCertStore;

				hCertStore = ::CertOpenStore( CERT_STORE_PROV_MSG, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, NULL, (const void *)hMsg );
				if(hCertStore)
				{
					BYTE* rgSignerInfo = NULL;

					if(SUCCEEDED(local_GetSignerInfo( hMsg, 0, rgSignerInfo )))
					{
						PCMSG_SIGNER_INFO pSignerInfo = (PCMSG_SIGNER_INFO)rgSignerInfo;
						CERT_INFO         certInfo; ::ZeroMemory( &certInfo, sizeof(certInfo) );
						PCCERT_CONTEXT    pCertContext;

						certInfo.SerialNumber = pSignerInfo->SerialNumber;
						certInfo.Issuer       = pSignerInfo->Issuer;

						pCertContext = ::CertGetSubjectCertificateFromStore( hCertStore, X509_ASN_ENCODING, &certInfo );
						if(pCertContext)
						{
							local_GetDNInfo( pCertContext, szOID_COMMON_NAME           , L"CN=", m_strVendorID, &m_strVendorName );
							local_GetDNInfo( pCertContext, szOID_LOCALITY_NAME         , L"L=" , m_strVendorID                   );
							local_GetDNInfo( pCertContext, szOID_STATE_OR_PROVINCE_NAME, L"S=" , m_strVendorID                   );
							local_GetDNInfo( pCertContext, szOID_COUNTRY_NAME          , L"C=" , m_strVendorID                   );

							::CertFreeCertificateContext( pCertContext );
						}

						delete [] rgSignerInfo;
					}

					::CertCloseStore( hCertStore, 0 );
				}

				::CryptMsgClose( hMsg );
			}

			if(m_strVendorID.size() == 0)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, log.WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"Help package cannot be trusted: unable to extract signer\n" ));
			}

            //
            // Escape unsafe character in the CertID.
            //
            {
                LPWSTR szCertID = (LPWSTR)m_strVendorID.c_str();

                while(szCertID[0])
                {
                    switch(szCertID[0])
                    {
                    case L'\\':
                    case L'/':
                    case L':':
                    case L'*':
                    case L'?':
                    case L'"':
                    case L'<':
                    case L'>':
                    case L'|':
                        szCertID[0] = L'_';
                    }

                    szCertID++;
                }
            }
        }
    }
    else
    {
        m_strVendorID = HC_MICROSOFT_DN;

        MPC::LocalizeString( IDS_HELPSVC_SEMGR_OWNER, m_strVendorName );

    }

    m_fMicrosoft = (MPC::StrICmp( m_strVendorID, HC_MICROSOFT_DN ) == 0);

	//
	// Extract package info from packagedescription.xml
	//
	{
		MPC::XmlUtil xml;
		bool         fFound;

		__MPC_EXIT_IF_METHOD_FAILS(hr, ExtractPkgDesc( log, xml ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"PRODUCT", L"ID", m_strProductID, fFound ));
		if(fFound == false) // Set some default.
		{
			m_strProductID = L"<default>";
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"VERSION", L"VALUE", m_strVersion, fFound ));
		if(fFound == false) // Set some default.
		{
			m_strVersion = L"1.0.0.0";
		}

		if(m_fBuiltin == false) // System packages inherit SKU/Language from the database.
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"SKU", L"VALUE", m_strSKU, fFound ));
			if(fFound == false) // Not a valid package!!
			{
				__MPC_SET_ERROR_AND_EXIT(hr, log.WriteLog( E_INVALIDARG, L"Missing SKU element" ));
			}
			
			__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"LANGUAGE", L"VALUE", m_strLanguage, fFound ));
			if(fFound == false) // Not a valid package!!
			{
				__MPC_SET_ERROR_AND_EXIT(hr, log.WriteLog( E_INVALIDARG, L"Missing LANGAUGE element" ));
			}
		}
    }

	if(m_lSequence >= 0)
	{
		m_fTemporary = false;
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Package::Remove( /*[in]*/ Logger& log )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Package::Remove" );

    HRESULT hr;

	//
	// There's no private file for this package, nothing to do.
	//
	if(m_lSequence == -1)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

    if(m_lSequence)
    {
        if(SUCCEEDED(GenerateFileName()))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( m_strFileName ));

			log.WriteLog( -1, L"\nRemove package %s [%s] (Vendor: %s) from package store\n\n", m_strProductID.c_str(), m_strVersion.c_str(), m_strVendorID.c_str() );
			
			m_strFileName.erase();
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Package::ExtractFile( /*[in]*/ Logger& log               ,
										/*[in]*/ LPCWSTR szFileDestination ,
										/*[in]*/ LPCWSTR szNameInCabinet   )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Package::ExtractFile" );

    HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, GenerateFileName());


	if(FAILED(hr = MPC::DecompressFromCabinet( m_strFileName.c_str(), szFileDestination, szNameInCabinet )))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, log.WriteLog( hr, L"Error extracting %s from help package", szNameInCabinet ));
	}

    log.WriteLog( S_OK, L"Extracted %s from help package", szNameInCabinet );

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Package::ExtractXMLFile( /*[in]*/ Logger&       log             ,
										   /*[in]*/ MPC::XmlUtil& xml             ,
										   /*[in]*/ LPCWSTR       szTag           ,
										   /*[in]*/ LPCWSTR       szNameInCabinet )
{
    __HCP_FUNC_ENTRY( "Taxonomy::Package::ExtractXMLFile" );

    HRESULT      hr;
	MPC::wstring strTmp;
	bool         fLoaded;


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( strTmp ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, ExtractFile( log, strTmp.c_str(), szNameInCabinet ));

    // load the XML with the root tag
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( strTmp.c_str(), szTag, fLoaded ));
    if(fLoaded == false)
    {
		__MPC_SET_ERROR_AND_EXIT(hr, log.WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"Error invalid XML in %s", szNameInCabinet ));
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

    (void)MPC::RemoveTemporaryFile( strTmp );

	__HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::Package::ExtractPkgDesc( /*[in]*/ Logger&       log ,
										   /*[in]*/ MPC::XmlUtil& xml )
{
	return ExtractXMLFile( log, xml, Taxonomy::Strings::s_tag_root_PackageDescription, Taxonomy::Strings::s_file_PackageDescription );
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Taxonomy::ProcessedPackage::ProcessedPackage()
{
    m_lSequence  = 0;     // long m_lSequence;
    m_fProcessed = false; // bool m_fProcessed;
    m_fDisabled  = false; // bool m_fDisabled;
}

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Taxonomy::ProcessedPackage& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream >> val.m_lSequence )) &&
       SUCCEEDED(hr = (stream >> val.m_fProcessed)) &&
       SUCCEEDED(hr = (stream >> val.m_fDisabled ))  )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Taxonomy::ProcessedPackage& val )
{
    HRESULT hr;

    if(SUCCEEDED(hr = (stream << val.m_lSequence )) &&
       SUCCEEDED(hr = (stream << val.m_fProcessed)) &&
       SUCCEEDED(hr = (stream << val.m_fDisabled ))  )
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\datacollection\datacollection.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    DataCollection.cpp

Abstract:
    This file contains the implementation of the CSAFDataCollection class,
    which implements the data collection functionality.

Revision History:
    Davide Massarenti   (Dmassare)  07/22/99
        created

******************************************************************************/

#include "stdafx.h"

#include "wmixmlt.h"
#include <wbemcli.h>

/////////////////////////////////////////////////////////////////////////////

#define CHECK_MODIFY()  __MPC_EXIT_IF_METHOD_FAILS(hr, CanModifyProperties())
#define CHECK_ABORTED() __MPC_EXIT_IF_METHOD_FAILS(hr, IsCollectionAborted())

#define DATASPEC_DEFAULT  L"<systemdataspec>"
#define DATASPEC_CONFIG   HC_ROOT_HELPSVC_CONFIG L"\\Dataspec.xml"
#define DATASPEC_LOCATION HC_ROOT_HELPSVC_DATACOLL
#define DATASPEC_TEMP     HC_ROOT_HELPSVC_TEMP

#define SAFETY_MARGIN__MEMORY (4*1024*1024)


/////////////////////////////////////////////////////////////////////////////

#define TEXT_TAG_DATACOLLECTION L"DataCollection"

#define TEXT_TAG_SNAPSHOT       L"Snapshot"
#define TEXT_ATTR_TIMESTAMP     L"Timestamp"
#define TEXT_ATTR_TIMEZONE      L"TimeZone"

#define TEXT_TAG_DELTA          L"Delta"
#define TEXT_ATTR_TIMESTAMP_T0  L"Timestamp_T0"
#define TEXT_ATTR_TIMESTAMP_T1  L"Timestamp_T1"

/////////////////////////////////////////////////////////////////////////////

static WCHAR l_CIM_header [] = L"<?xml version=\"1.0\" encoding=\"unicode\"?><CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\"><DECLARATION><DECLGROUP.WITHPATH>";
static WCHAR l_CIM_trailer[] = L"</DECLGROUP.WITHPATH></DECLARATION></CIM>";
static WCHAR l_Select_Pattern[] = L"Select";

static CComVariant l_vPathLevel                 (       3    );
static CComVariant l_vExcludeSystemProperties   ( (bool)true );

static CComBSTR    l_bstrQueryLang              ( L"WQL"                     );
static CComBSTR    l_bstrPathLevel              ( L"PathLevel"               );
static CComBSTR    l_bstrExcludeSystemProperties( L"ExcludeSystemProperties" );

/////////////////////////////////////////////////////////////////////////////

void CSAFDataCollection::CleanQueryResult( QueryResults& qr )
{
    MPC::CallDestructorForAll( qr );
}

HRESULT CSAFDataCollection::StreamFromXML( /*[in]*/  	IXMLDOMDocument*  xdd     ,
                                           /*[in]*/  	bool              fDelete ,
                                           /*[in/out]*/ CComPtr<IStream>& val     )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::StreamFromXML" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;
	MPC::wstring             strTempFile;


    //
    // No XML document, so no stream...
    //
    if(xdd)
	{
		MPC::wstring  strTempPath;
		LARGE_INTEGER li;


		//
		// Generate a unique file name.
		//
		strTempPath = DATASPEC_TEMP; MPC::SubstituteEnvVariables( strTempPath );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( strTempFile, strTempPath.c_str() ));

		//
		// Create a stream for a file.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForReadWrite( strTempFile.c_str() ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, stream->DeleteOnRelease ( fDelete             ));


		//
		// Write the XML DOM to the stream.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, xdd->save( CComVariant( stream ) ));


		//
		// Reset stream to beginning.
		//
		li.LowPart  = 0;
		li.HighPart = 0;
		__MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( li, STREAM_SEEK_SET, NULL ));
	}

	val = stream;
    hr  = S_OK;


    __HCP_FUNC_CLEANUP;

	if(FAILED(hr))
	{
		stream.Release();

		(void)MPC::RemoveTemporaryFile( strTempFile );
	}

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

CSAFDataCollection::CSAFDataCollection()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CSAFDataCollection" );


                                           // MPC::Impersonation              m_imp;
                                           //								  
    m_dsStatus             = DC_NOTACTIVE; // DC_STATUS                       m_dsStatus;
    m_lPercent             = 0;            // long                            m_lPercent;
    m_dwErrorCode          = S_OK;         // DWORD                           m_dwErrorCode;
    m_fScheduled           = false;        // bool                            m_fScheduled;
    m_fCompleted           = false;        // bool                            m_fCompleted;
    m_fWorking             = false;        // bool                            m_fWorking;
                                           // List                            m_lstReports;
    m_hcpdcrcCurrentReport = NULL;         // CSAFDataCollectionReport*       m_hcpdcrcCurrentReport;
                                           //								  
                                           // CComBSTR                        m_bstrMachineData;
                                           // CComBSTR                        m_bstrHistory;
    m_lHistory             = 0;            // long                            m_lHistory;
                                           //								  
                                           // CComPtr<IStream>                m_streamMachineData;
                                           // CComPtr<IStream>                m_streamHistory;
                                           //								  
                                           //								  
                                           // CComBSTR                        m_bstrFilenameT0;
                                           // CComBSTR                        m_bstrFilenameT1;
                                           // CComBSTR                        m_bstrFilenameDiff;
                                           //								  
                                           //								  
                                           // CComPtrThreadNeutral<IDispatch> m_sink_onStatusChange;
                                           // CComPtrThreadNeutral<IDispatch> m_sink_onProgress;
                                           // CComPtrThreadNeutral<IDispatch> m_sink_onComplete;
                                           //								  
    m_lQueries_Done        = 0;            // long                            m_lQueries_Done;
    m_lQueries_Total       = 0;            // long                            m_lQueries_Total;
}

HRESULT CSAFDataCollection::FinalConstruct()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::FinalConstruct" );

    __HCP_FUNC_EXIT(S_OK);
}

void CSAFDataCollection::FinalRelease()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::FinalRelease" );

    (void)Abort();

    Thread_Wait();

    EraseReports();
}

void CSAFDataCollection::EraseReports()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::EraseReports" );

    IterConst                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    //
    // Release all the items.
    //
    MPC::ReleaseAll( m_lstReports );
    m_hcpdcrcCurrentReport = NULL;

    m_streamMachineData = NULL;
    m_streamHistory     = NULL;
}

void CSAFDataCollection::StartOperations()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::StartOperation" );

    MPC::SmartLock<_ThreadModel> lock( this );


    EraseReports();

    m_fWorking   = true;
    m_fCompleted = false;
}

void CSAFDataCollection::StopOperations()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::StartOperation" );

    MPC::SmartLock<_ThreadModel> lock( this );


    m_fWorking = false;
}

HRESULT CSAFDataCollection::ImpersonateCaller()
{
    return m_imp.Impersonate();
}

HRESULT CSAFDataCollection::EndImpersonation()
{
    return m_imp.RevertToSelf();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFDataCollection::ExecLoopCollect()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::ExecLoopCollect" );

    HRESULT                        hr;
    QueryResults                   qr;
    WMIHistory::Database           wmihd;
    WMIHistory::Database           wmihd_MachineData;
    WMIHistory::Database           wmihd_History;
    WMIHistory::Database::ProvList lstQueries_MachineData;
    WMIHistory::Database::ProvList lstQueries_History;
    DC_STATUS                      dcLastState;


    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST );

	__MPC_TRY_BEGIN();

    __MPC_EXIT_IF_METHOD_FAILS(hr, put_Status( DC_COLLECTING )); dcLastState = DC_COLLECTING;

    CHECK_ABORTED();

    //
    // First of all, load and validate the dataspec.
    //
    if(m_bstrMachineData.Length())
    {
		if(MPC::StrICmp( m_bstrMachineData, DATASPEC_DEFAULT ) == 0)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, wmihd_MachineData.Init( NULL, DATASPEC_CONFIG ));
		}
		else
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller());
			__MPC_EXIT_IF_METHOD_FAILS(hr, wmihd_MachineData.Init( NULL, m_bstrMachineData ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation());
		}

        //
        // Filter and count the queries.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, FilterDataSpec( wmihd_MachineData, NULL, lstQueries_MachineData ));
    }

    if(m_bstrHistory.Length())
    {
        //
        // Try to lock the database and load the data spec file.
        //
        while(1)
        {
            if(SUCCEEDED(hr = wmihd.Init( DATASPEC_LOCATION, DATASPEC_CONFIG )))
            {
                break;
            }

            if(hr != HRESULT_FROM_WIN32( WAIT_TIMEOUT ))
            {
                __MPC_FUNC_LEAVE;
            }

            CHECK_ABORTED();
        }
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihd.Load());


        //
        // Filter and count the queries.
        //
		if(MPC::StrICmp( m_bstrHistory, DATASPEC_DEFAULT ) == 0)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, wmihd_History.Init( NULL, DATASPEC_CONFIG ));
		}
		else
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller());
			__MPC_EXIT_IF_METHOD_FAILS(hr, wmihd_History.Init( NULL, m_bstrHistory ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation());
		}

        __MPC_EXIT_IF_METHOD_FAILS(hr, FilterDataSpec( wmihd, &wmihd_History, lstQueries_History ));
    }

    //
    // Then count the number of queries to be executed.
    //
    m_lQueries_Done  = 0;
    m_lQueries_Total = lstQueries_MachineData.size() + lstQueries_History.size();

    CHECK_ABORTED();

    //
    // Execute the collection of Machine Data.
    //
    if(m_bstrMachineData.Length())
    {
        WMIParser::ClusterByClassMap cluster;
        CComPtr<IXMLDOMDocument>     xdd;


        //
        // Collect data from WMI.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ExecDataSpec( qr, cluster, lstQueries_MachineData, true ));

        //
        // Collate all the different streams into only one XML document.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, CollateMachineDataWithTimestamp( qr, cluster, NULL, NULL, &xdd ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, StreamFromXML( xdd, true, m_streamMachineData ));

        //
        // Cleanup everything.
        //
        cluster.clear();
        CleanQueryResult( qr );
    }

    CHECK_ABORTED();

    if(m_bstrHistory.Length())
    {
        WMIParser::ClusterByClassMap cluster;
        CComPtr<IXMLDOMDocument>     xdd;

        //
        // Collect data from WMI.
        //
        // We actually use the queries in our data spec and do only those specified in the history list.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ExecDataSpec( qr, cluster, lstQueries_History, false ));


        //
        // Compute deltas, but don't persist them! (fPersist == false)
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ComputeDelta( qr, cluster, lstQueries_History, false ));

        //
        // Cleanup everything (the data is already stored in files...)
        //
        cluster.clear();
        CleanQueryResult( qr );


        __MPC_EXIT_IF_METHOD_FAILS(hr, try_Status( dcLastState, DC_COMPARING )); dcLastState = DC_COMPARING;

        //
        // Collate all the different snapshots and deltas into only one XML document.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, CollateHistory( wmihd, wmihd_History, &xdd ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, StreamFromXML( xdd, true, m_streamHistory ));
    }

    CHECK_ABORTED();

    Fire_onProgress( this, m_lQueries_Done, m_lQueries_Total );

    __MPC_EXIT_IF_METHOD_FAILS(hr, try_Status( dcLastState, DC_COMPLETED )); dcLastState = DC_COMPLETED;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	__MPC_TRY_CATCHALL(hr);

    (void)EndImpersonation();

    //
    //
    //
    if(FAILED(hr))
    {
        (void)put_ErrorCode( hr        );
        (void)put_Status   ( DC_FAILED );
    }

    //
    // Make sure to delete the temporary WMIParser:Snapshot objects.
    //
    CleanQueryResult( qr );

    //
    // In any case, fire the "onComplete" event, so all the clients exit from loops.
    //
    Fire_onComplete( this, hr );

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    //
    // Anyway, always return a success.
    //
    StopOperations();
    hr = S_OK;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::ExecLoopCompare()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::ExecLoopCompare" );

    HRESULT      hr;
    VARIANT_BOOL fRes;
    DC_STATUS    dcLastState;


    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST );

	__MPC_TRY_BEGIN();

    __MPC_EXIT_IF_METHOD_FAILS(hr, put_Status( DC_COMPARING )); dcLastState = DC_COMPARING;

    CHECK_ABORTED();

    __MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller());
    __MPC_EXIT_IF_METHOD_FAILS(hr, WMIParser::CompareSnapshots( m_bstrFilenameT0, m_bstrFilenameT1, m_bstrFilenameDiff, &fRes ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation());

    if(fRes == VARIANT_FALSE)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, try_Status( dcLastState, DC_NODELTA )); dcLastState = DC_NODELTA;
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, try_Status( dcLastState, DC_COMPLETED )); dcLastState = DC_COMPLETED;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	__MPC_TRY_CATCHALL(hr);

    (void)EndImpersonation();

    //
    //
    //
    if(FAILED(hr))
    {
        (void)put_ErrorCode( hr        );
        (void)put_Status   ( DC_FAILED );
    }

    //
    // In any case, fire the "onComplete" event, so all the clients exit from loops.
    //
    Fire_onComplete( this, hr );

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    //
    // Anyway, always return a success.
    //
    StopOperations();
    hr = S_OK;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFDataCollection::FilterDataSpec( /*[in]*/ WMIHistory::Database&           wmihdQuery  ,
                                            /*[in]*/ WMIHistory::Database*           wmihdFilter ,
                                            /*[in]*/ WMIHistory::Database::ProvList& lstQueries  )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::FilterDataSpec" );

    HRESULT                             hr;
    WMIHistory::Database::ProvIterConst itBegin;
    WMIHistory::Database::ProvIterConst itEnd;
    WMIHistory::Database::ProvIterConst it;


    //
    // Exec each query.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, wmihdQuery.get_Providers( itBegin, itEnd ));
    for(it=itBegin; it!=itEnd; it++)
    {
        WMIHistory::Provider* wmihp = *it;
        MPC::wstring          szNamespace;
        MPC::wstring          szClass;


        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Namespace( szNamespace ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Class    ( szClass     ));


        if(wmihdFilter)
        {
            WMIHistory::Provider* wmihpFilter;

            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihdFilter->find_Provider( NULL, &szNamespace, &szClass, wmihpFilter ));

            //
            // The namespace/class is unknown, skip it.
            //
            if(wmihpFilter == NULL) continue;
        }

        lstQueries.push_back( wmihp );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CSAFDataCollection::ExecDataSpec( /*[in/out]*/ QueryResults&                   qr           ,
                                          /*[in/out]*/ WMIParser::ClusterByClassMap&   cluster      ,
                                          /*[in]*/     WMIHistory::Database::ProvList& lstQueries   ,
                                          /*[in]*/     bool                            fImpersonate )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::ExecDataSpec" );

    HRESULT                             hr;
    WMIHistory::Database::ProvIterConst itBegin = lstQueries.begin();
    WMIHistory::Database::ProvIterConst itEnd   = lstQueries.end();
    WMIHistory::Database::ProvIterConst it;


    //
    // Exec each query.
    //
    for(it=itBegin; it!=itEnd; it++)
    {
        CComPtr<IXMLDOMDocument> xddCollected;
        WMIHistory::Provider*    wmihp = *it;
        MPC::wstring             szNamespace;
        MPC::wstring             szClass;
        MPC::wstring             szWQL;


        Fire_onProgress( this, m_lQueries_Done++, m_lQueries_Total );


        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Namespace( szNamespace ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Class    ( szClass     ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_WQL      ( szWQL       ));

        if(szWQL.length() == 0)
        {
            szWQL  = L"select * from ";
            szWQL += szClass;
        }

        //
        // Create a new item and link it to the system.
        //
        {
            CSAFDataCollectionReport* dcr;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &dcr ));
            m_lstReports.push_back( dcr );

            dcr->m_bstrNamespace   = szNamespace.c_str();
            dcr->m_bstrClass       = szClass    .c_str();
            dcr->m_bstrWQL         = szWQL      .c_str();
            m_hcpdcrcCurrentReport = dcr;
        }


        //
        // Fix for a problem in WMI: namespaces with "/" are not recognized...
        //
        {
            MPC::wstring::size_type pos;

            while((pos = szNamespace.find( '/' )) != szNamespace.npos) szNamespace[pos] = '\\';
        }


        //////////////////////////////////////////////////////////////////////////////////
        //
        // Execute the query, impersonating if requested.
        //
        if(fImpersonate)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller());
        }

        hr = CollectUsingEncoder( szNamespace, szWQL, &xddCollected );
        if(FAILED(hr))
        {
            xddCollected = NULL;

            __MPC_EXIT_IF_METHOD_FAILS(hr, CollectUsingTranslator( szNamespace, szWQL, &xddCollected ));
        }

        if(fImpersonate)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation());
        }
        //
        //
        //
        //////////////////////////////////////////////////////////////////////////////////

        if(xddCollected)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Distribute( xddCollected, qr, cluster ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)EndImpersonation();

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::CollectUsingTranslator( /*[in] */ MPC::wstring&     szNamespace ,
                                                    /*[in] */ MPC::wstring&     szWQL       ,
                                                    /*[out]*/ IXMLDOMDocument* *ppxddDoc    )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CollectUsingTranslator" );

    HRESULT                    hr;
    HRESULT                    hrXML;
    CComBSTR                   bstrNamespace = szNamespace.c_str();
    CComBSTR                   bstrWQL       = szWQL      .c_str();
    CComPtr<IWmiXMLTranslator> pTrans;
    CComPtr<IXMLDOMDocument>   xddDoc;
    CComBSTR                   bstrXML;
    VARIANT_BOOL               fSuccessful;


    *ppxddDoc = NULL;
    CHECK_ABORTED();


    //
    // Create the WMI->XML translator.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_WmiXMLTranslator, NULL, CLSCTX_INPROC_SERVER, IID_IWmiXMLTranslator, (void**)&pTrans ));

    // Set to truncate Qualifiers and have full identity information.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pTrans->put_DeclGroupType  ( wmiXMLDeclGroupWithPath ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pTrans->put_QualifierFilter( wmiXMLFilterNone        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pTrans->put_HostFilter     ( VARIANT_TRUE            ));

    //
    // Execute the query.
    //
    hrXML = pTrans->ExecQuery( bstrNamespace, bstrWQL, &bstrXML );
    if(FAILED(hrXML))
    {
        CComQIPtr<ISupportErrorInfo> sei = pTrans;

        if(sei && SUCCEEDED(sei->InterfaceSupportsErrorInfo( IID_IWmiXMLTranslator )))
        {
            CComPtr<IErrorInfo> ei;

            if(SUCCEEDED(GetErrorInfo( 0, &ei )) && ei)
            {
                ei->GetDescription( &m_hcpdcrcCurrentReport->m_bstrDescription );
            }
        }

        m_hcpdcrcCurrentReport->m_dwErrorCode = hrXML;

        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    //
    // Load the result into an XML DOM object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&xddDoc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->loadXML( bstrXML, &fSuccessful ));
    if(fSuccessful == VARIANT_FALSE)
    {
        CComQIPtr<ISupportErrorInfo> sei = xddDoc;

        if(sei && SUCCEEDED(sei->InterfaceSupportsErrorInfo( IID_IXMLDOMDocument )))
        {
            CComPtr<IErrorInfo> ei;

            if(SUCCEEDED(GetErrorInfo( 0, &ei )))
            {
                ei->GetDescription( &m_hcpdcrcCurrentReport->m_bstrDescription );
            }
        }

        m_hcpdcrcCurrentReport->m_dwErrorCode = ERROR_BAD_FORMAT;

        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }


    //  __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->save( CComVariant( "C:\\dump.xml" ) ));

    //  __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->load( CComVariant( "C:\\dump.xml" ), &fSuccessful ));
    //  if(fSuccessful == VARIANT_FALSE)
    //  {
    //      __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
    //  }


    //
    // Return the pointer to the XML document.
    //
    *ppxddDoc = xddDoc.Detach();
    hr        = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::CollectUsingEncoder( /*[in] */ MPC::wstring&     szNamespace ,
                                                 /*[in] */ MPC::wstring&     szWQL       ,
                                                 /*[out]*/ IXMLDOMDocument* *ppxddDoc    )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CollectUsingEncoder" );

    HRESULT                    hr;
    HRESULT                    hrXML;
	HRESULT                    hrConnect;
    CComBSTR                   bstrNamespace( szNamespace.c_str() );
    CComBSTR                   bstrWQL      ( szWQL      .c_str() );
    CComPtr<IXMLDOMDocument>   xddDoc;
    CComBSTR                   bstrXML;
    VARIANT_BOOL               fSuccessful;

    // Additional Declarations/Definitions for XMLE Usage.

    CComPtr<IWbemContext>         pWbemContext;
    CComPtr<IWbemServices>        pWbemServices;
    CComPtr<IWbemObjectTextSrc>   pWbemTextSrc;
    CComPtr<IEnumWbemClassObject> pWbemEnum;
    CComPtr<IWbemLocator>         pWbemLocator;

    LPWSTR                        szSelect;
    LPWSTR                        szWQLCopy;

    CComBSTR                      bstrModWQL;

    *ppxddDoc = NULL;
    CHECK_ABORTED();


    // Create an instance of WbemObjectTextSrc class (this would fails if the Encoder functionality is not present).
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER, IID_IWbemObjectTextSrc, (void**)&pWbemTextSrc ));

    // Create an instance of the IWbemLocator Interface.
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *)&pWbemLocator ));


    //
    // Got the pointer to the IWbemLocator Service.
    //
    // Connect to the required Namespace using the Locator Service.
    //
    hrConnect = pWbemLocator->ConnectServer( CComBSTR( szNamespace.c_str() ),
                                                                 NULL                           , //using current account for simplicity
                                                                 NULL                           , //using current password for simplicity
                                                                 0L                             , // locale
                                                                 0L                             , // securityFlags
                                                                 NULL                           , // authority (domain for NTLM)
                                                                 NULL                           , // context
                                                                 &pWbemServices                 );

	if(FAILED(hrConnect))
    {
        CComQIPtr<ISupportErrorInfo> sei = pWbemLocator;

        if(sei && SUCCEEDED(sei->InterfaceSupportsErrorInfo( IID_IWbemLocator )))
        {
            CComPtr<IErrorInfo> ei;

            if(SUCCEEDED(GetErrorInfo( 0, &ei )) && ei)
            {
                ei->GetDescription( &m_hcpdcrcCurrentReport->m_bstrDescription );
            }
        }

        m_hcpdcrcCurrentReport->m_dwErrorCode = hrConnect;

        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    //
    // Adjust the security level to IMPERSONATE, to satisfy the flawed WMI requirements....
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SetInterfaceSecurity_ImpLevel( pWbemServices, RPC_C_IMP_LEVEL_IMPERSONATE ));


    //
    // Connected To Namespace.
    //
    // Now execute the query to get EnumObjects.
    // This is the instances got against the query.
    // WBEM_FLAG_FORWARD_ONLY Flag to be used?
    //

    // Append __Path to the WQL query.

    szWQLCopy = bstrWQL;

    //  Search for Select pattern.
    szSelect = StrStrIW(szWQLCopy,l_Select_Pattern);

    if(szSelect != NULL)
    {
        //  Select Pattern Found

        //  Advance the pointer to the end of the pattern so the pointer is
        //  positioned at end of the word "select"

        szSelect += wcslen(l_Select_Pattern);

        bstrModWQL = L"Select __Path, ";
        bstrModWQL.Append(szSelect);

        bstrWQL = bstrModWQL;
    }

    hrXML = pWbemServices->ExecQuery( l_bstrQueryLang, bstrWQL, 0, 0, &pWbemEnum );
    if(FAILED(hrXML))
    {
        CComQIPtr<ISupportErrorInfo> sei = pWbemServices;

        if(sei && SUCCEEDED(sei->InterfaceSupportsErrorInfo( IID_IWbemServices )))
        {
            CComPtr<IErrorInfo> ei;

            if(SUCCEEDED(GetErrorInfo( 0, &ei )) && ei)
            {
                ei->GetDescription( &m_hcpdcrcCurrentReport->m_bstrDescription );
            }
        }

        m_hcpdcrcCurrentReport->m_dwErrorCode = hrXML;

        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    //
    // Adjust the security level to IMPERSONATE, to satisfy the flawed WMI requirements....
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SetInterfaceSecurity_ImpLevel( pWbemEnum, RPC_C_IMP_LEVEL_IMPERSONATE ));


    ////////////////////////////////////////////////////////////////////////////////

    // Create a new WbemContext object.
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void**)&pWbemContext ));

    //
    // For the XML to be conformant with the earlier XMLT format,
    // we need VALUE.OBJECTWITHPATH.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pWbemContext->SetValue( l_bstrPathLevel, 0, &l_vPathLevel ));

    //
    // We don't need the system properties that are returned by
    // default. Hence Exclude them from the output.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pWbemContext->SetValue( l_bstrExcludeSystemProperties, 0, &l_vExcludeSystemProperties ));

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Collate all the instances.
    //
    bstrXML = l_CIM_header;
    while(1)
    {
        CComPtr<IWbemClassObject> pObj;
        CComBSTR                  bstrXMLCurrent;
        ULONG                     uReturned;
        bool                      fProceed;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pWbemEnum->Next( WBEM_INFINITE, 1, &pObj, &uReturned ));

        if(hr == WBEM_S_FALSE || uReturned == 0) break;

        hrXML = pWbemTextSrc->GetText( 0, pObj, WMI_OBJ_TEXT_WMI_DTD_2_0, pWbemContext, &bstrXMLCurrent );
        if(FAILED(hrXML))
        {
            CComQIPtr<ISupportErrorInfo> sei = pWbemTextSrc;

            if(sei && SUCCEEDED(sei->InterfaceSupportsErrorInfo( IID_IWbemObjectTextSrc )))
            {
                CComPtr<IErrorInfo> ei;

                if(SUCCEEDED(GetErrorInfo( 0, &ei )) && ei)
                {
                    ei->GetDescription( &m_hcpdcrcCurrentReport->m_bstrDescription );
                }
            }

            m_hcpdcrcCurrentReport->m_dwErrorCode = hrXML;

            __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
        }

        // Append the individual instance XMLs
        //
        bstrXML.Append( bstrXMLCurrent );
    }
    bstrXML.Append( l_CIM_trailer );

    //
    // Load the result into an XML DOM object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&xddDoc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->loadXML( bstrXML, &fSuccessful ));
    if(fSuccessful == VARIANT_FALSE)
    {
        CComQIPtr<ISupportErrorInfo> sei = xddDoc;

        if(sei && SUCCEEDED(sei->InterfaceSupportsErrorInfo( IID_IXMLDOMDocument )))
        {
            CComPtr<IErrorInfo> ei;

            if(SUCCEEDED(GetErrorInfo( 0, &ei )))
            {
                ei->GetDescription( &m_hcpdcrcCurrentReport->m_bstrDescription );
            }
        }

        m_hcpdcrcCurrentReport->m_dwErrorCode = ERROR_BAD_FORMAT;

        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    // __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->save( CComVariant( "C:\\dump.xml" ) ));

    //
    // Return the pointer to the XML document.
    //
    *ppxddDoc = xddDoc.Detach();
    hr        = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::Distribute( /*[in]    */ IXMLDOMDocument*              pxddDoc ,
                                        /*[in/out]*/ QueryResults&                 qr      ,
                                        /*[in/out]*/ WMIParser::ClusterByClassMap& cluster )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::Distribute" );

    HRESULT               hr;
    MPC::XmlUtil          xml( pxddDoc );
    CComPtr<IXMLDOMNode>  xdnRoot;
    WMIParser::Snapshot  *pwmips = NULL;

    __MPC_EXIT_IF_ALLOC_FAILS(hr, pwmips, new WMIParser::Snapshot());
    qr.push_back( pwmips );

    //
    // Quick fix for broken Incident object: force UNICODE encoding.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.SetVersionAndEncoding( L"1.0", L"unicode" ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot              ( &xdnRoot           ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pwmips->put_Node         (  xdnRoot           ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, WMIParser::DistributeOnCluster( cluster, *pwmips ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::ComputeDelta( /*[in]*/ QueryResults&                   qr         ,
                                          /*[in]*/ WMIParser::ClusterByClassMap&   cluster    ,
                                          /*[in]*/ WMIHistory::Database::ProvList& lstQueries ,
                                          /*[in]*/ bool                            fPersist   )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::ComputeDelta" );

    HRESULT                             hr;
    WMIHistory::Database::ProvIterConst it;


    for(it=lstQueries.begin(); it!=lstQueries.end(); it++)
    {
        WMIHistory::Provider*    wmihp = *it;
        WMIHistory::Data*        wmihpd_T0;
        WMIHistory::Data*        wmihpd_T1;
        WMIHistory::Data*        wmihpd_D1;
        CComPtr<IXMLDOMDocument> xddDoc;
        MPC::wstring             szNamespace;
        MPC::wstring             szClass;


        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Namespace( szNamespace ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Class    ( szClass     ));


        //
        // Collate only the data from current cluster.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, CollateMachineData( qr, cluster, &szNamespace, &szClass, true, &xddDoc ));


        //
        // Save it to a file.
        //
        {
            MPC::XmlUtil xml( xddDoc );

            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->alloc_Snapshot( xml, wmihpd_T1 ));
        }


        //
        // If two snapshots are present, compute the delta.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Snapshot( wmihpd_T0 ));
        if(wmihpd_T0 == NULL)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->insert_Snapshot( wmihpd_T1, fPersist ));
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->ComputeDiff( wmihpd_T0, wmihpd_T1, wmihpd_D1 ));
            if(wmihpd_D1)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->insert_Snapshot( wmihpd_D1, fPersist ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->insert_Snapshot( wmihpd_T1, fPersist ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->remove_Snapshot( wmihpd_T0, fPersist ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::CollateMachineData( /*[in] */ QueryResults&                  qr           ,
                                                /*[in] */ WMIParser::ClusterByClassMap&  cluster      ,
                                                /*[in] */ MPC::wstring*                  pszNamespace ,
                                                /*[in] */ MPC::wstring*                  pszClass     ,
                                                /*[in] */ bool                           fGenerate    ,
                                                /*[out]*/ IXMLDOMDocument*              *ppxddDoc     )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CollateMachineData" );

    HRESULT             hr;
    WMIParser::Snapshot wmips;


    *ppxddDoc = NULL;
    CHECK_ABORTED();


    __MPC_EXIT_IF_METHOD_FAILS(hr, wmips.New());


    if(qr.begin() != qr.end())
    {
        WMIParser::ClusterByClassIter itCluster;

        //
        // For each cluster, enumerate all the instances in it and copy to the new snapshot.
        //
        for(itCluster = cluster.begin(); itCluster != cluster.end(); itCluster++)
        {
            MPC::NocaseCompare          cmp;
            WMIParser::Instance*        inst       = (*itCluster).first;
            WMIParser::Cluster&         subcluster = (*itCluster).second;
            WMIParser::ClusterByKeyIter itSubBegin;
            WMIParser::ClusterByKeyIter itSubEnd;


            //
            // Filter only some classes or namespaces.
            //
            if(pszNamespace)
            {
                MPC::wstring szNamespace;

                __MPC_EXIT_IF_METHOD_FAILS(hr, inst->get_Namespace( szNamespace ));

                //
                // NOTICE: if the namespace is "<UNKNOWN>", then assume a match.
                //
                if(szNamespace != L"<UNKNOWN>")
                {
                    if(!cmp( szNamespace, *pszNamespace )) continue;
                }
            }
            if(pszClass)
            {
                MPC::wstring szClass;

                __MPC_EXIT_IF_METHOD_FAILS(hr, inst->get_Class( szClass ));

                if(!cmp( szClass, *pszClass )) continue;
            }


            //
            // Copy all the instances into the new document.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, subcluster.Enum( itSubBegin, itSubEnd ));
            while(itSubBegin != itSubEnd)
            {
                WMIParser::Instance* pwmipiInst;

                __MPC_EXIT_IF_METHOD_FAILS(hr, wmips.clone_Instance( (*itSubBegin).first, pwmipiInst ));
                fGenerate = true;

                CHECK_ABORTED();
                itSubBegin++;
            }
        }
    }

    //
    // Only return the document if at least one instance is present.
    //
    if(fGenerate)
    {
        CComPtr<IXMLDOMNode> xdnRoot;

        __MPC_EXIT_IF_METHOD_FAILS(hr, wmips.get_Node( &xdnRoot ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRoot->get_ownerDocument( ppxddDoc ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::CollateMachineDataWithTimestamp( /*[in] */ QueryResults&                  qr           ,
                                                             /*[in] */ WMIParser::ClusterByClassMap&  cluster      ,
                                                             /*[in] */ MPC::wstring*                  pszNamespace ,
                                                             /*[in] */ MPC::wstring*                  pszClass     ,
                                                             /*[out]*/ IXMLDOMDocument*              *ppxddDoc     )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CollateMachineDataWithTimestamp" );

    HRESULT                  hr;
    CComPtr<IXMLDOMDocument> xdd;


    *ppxddDoc = NULL;
    CHECK_ABORTED();


    __MPC_EXIT_IF_METHOD_FAILS(hr, CollateMachineData( qr, cluster, NULL, NULL, false, &xdd ));
    if(xdd)
    {
        MPC::XmlUtil         xml;
        CComPtr<IXMLDOMNode> xdnNodeSnapshot;


        //
        // Create the document.
        //
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.New( TEXT_TAG_DATACOLLECTION ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( TEXT_TAG_SNAPSHOT, &xdnNodeSnapshot ));
        }


        //
        // Set the date.
        //
        {
            DATE                  dTimestamp = MPC::GetLocalTime();
            TIME_ZONE_INFORMATION tzi;
            MPC::wstring          szValue;
            bool                  fFound;

            if(::GetTimeZoneInformation( &tzi ) == TIME_ZONE_ID_DAYLIGHT)
            {
                tzi.Bias += tzi.DaylightBias;
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertDateToString( dTimestamp, szValue, /*fGMT*/true, /*fCIM*/true, 0 ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_TIMESTAMP, szValue, fFound, xdnNodeSnapshot ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_TIMEZONE, (LONG)tzi.Bias, fFound, xdnNodeSnapshot ));
        }


        //
        // Insert the CIM tree into the document.
        //
        {
            CComPtr<IXMLDOMNode> xdnNodeToInsert;
            CComPtr<IXMLDOMNode> xdnNodeReplaced;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdd->get_documentElement( (IXMLDOMElement**)&xdnNodeToInsert ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeSnapshot->appendChild( xdnNodeToInsert, &xdnNodeReplaced ));
        }

        //
        // Return the XML blob to the caller.
        //
        {
            CComPtr<IXMLDOMNode> xdnRoot;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot               (  &xdnRoot ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRoot->get_ownerDocument( ppxddDoc  ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::CollateHistory( /*[in] */ WMIHistory::Database&  wmihdQuery  ,
                                            /*[in] */ WMIHistory::Database&  wmihdFilter ,
                                            /*[out]*/ IXMLDOMDocument*      *ppxddDoc    )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CollateHistory" );

    typedef std::vector< LONG >         SeqVector;
    typedef SeqVector::iterator         SeqIter;
    typedef SeqVector::const_iterator   SeqIterConst;

    HRESULT                             hr;
    QueryResults                        qr;
    WMIParser::ClusterByClassMap        cluster;
    WMIHistory::Database::ProvList      prov_lst;
    WMIHistory::Database::ProvIterConst prov_itBegin;
    WMIHistory::Database::ProvIterConst prov_itEnd;
    WMIHistory::Database::ProvIterConst prov_it;
    SeqVector                           seq_vec;
    SeqIterConst                        seq_it;
    MPC::XmlUtil                        xml;
    MPC::wstring                        szValue;
    bool                                fFound;
    long                                lHistory = m_lHistory; // Number of deltas to collect.
    DATE                                dTimestampCurrent;
    DATE                                dTimestampNext;
    TIME_ZONE_INFORMATION               tzi;


    *ppxddDoc = NULL;
    CHECK_ABORTED();


    if(::GetTimeZoneInformation( &tzi ) == TIME_ZONE_ID_DAYLIGHT)
    {
        tzi.Bias += tzi.DaylightBias;
    }


    //
    // Form the list of providers to collate.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, wmihdQuery.get_Providers( prov_itBegin, prov_itEnd ));
    for(prov_it=prov_itBegin; prov_it!=prov_itEnd; prov_it++)
    {
        WMIHistory::Provider* wmihp = *prov_it;
        WMIHistory::Provider* wmihpFilter;
        MPC::wstring          szNamespace;
        MPC::wstring          szClass;


        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Namespace     (        szNamespace                        ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Class         (                      szClass              ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihdFilter.find_Provider( NULL, &szNamespace, &szClass, wmihpFilter ));

        //
        // The namespace/class is known, add it to the list.
        //
        if(wmihpFilter)
        {
            WMIHistory::Provider::DataIterConst itBegin;
            WMIHistory::Provider::DataIterConst itEnd;
            LONG                                lSequence;

            //
            // For each delta, extract the sequence info and add it to a list of UNIQUE sequence numbers.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->enum_Data( itBegin, itEnd ));
            while(itBegin != itEnd)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, (*itBegin++)->get_Sequence( lSequence ));

                if(std::find( seq_vec.begin(), seq_vec.end(), lSequence ) == seq_vec.end())
                {
                    seq_vec.push_back( lSequence );
                }
            }

            prov_lst.push_back( wmihp );
        }
    }

    //
    // The list of dates is empty, so no data is available.
    //
    if(seq_vec.begin() == seq_vec.end())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //
    // Sort the dates from the newest to the oldest.
    //
    std::sort< SeqIter >( seq_vec.begin(), seq_vec.end(), std::greater<LONG>() );

    CHECK_ABORTED();


    //
    // Create the document.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.New( TEXT_TAG_DATACOLLECTION ));


    //
    // First of all, collate the snapshots.
    //
    {
        CComPtr<IXMLDOMDocument> xdd;
        CComPtr<IXMLDOMNode>     xdnNode;
        CComPtr<IXMLDOMNode>     xdnNodeToInsert;
        CComPtr<IXMLDOMNode>     xdnNodeReplaced;


        //
        // Walk through all the providers and load the snapshots.
        //
        for(prov_it=prov_lst.begin(); prov_it!=prov_lst.end(); prov_it++)
        {
            WMIHistory::Data*        wmihpd;
            MPC::XmlUtil             xmlData;
            CComPtr<IXMLDOMDocument> xddData;


            __MPC_EXIT_IF_METHOD_FAILS(hr, (*prov_it)->get_Snapshot( wmihpd ));
            if(wmihpd == NULL) continue;


            //
            // If it's the first provider we see in this round, create the proper element, "Snapshot".
            //
            // As its date, we pick the latest date in the list of dates. This is because not all the snapshots have the
            // same date, when two snapshots are identical, no delta is created and the new snapshot is not stored.
            // But it's guarantee that, if there's a snapshot, its date is greater than any delta's date.
            //
            if(xdnNode == NULL)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->get_TimestampT0( dTimestampCurrent ));


                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( TEXT_TAG_SNAPSHOT, &xdnNode ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertDateToString( dTimestampCurrent, szValue, /*fGMT*/true, /*fCIM*/true, 0 ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_TIMESTAMP, szValue, fFound, xdnNode ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_TIMEZONE, (LONG)tzi.Bias, fFound, xdnNode ));
            }


            //
            // Load the data and distribuite among clusters.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->LoadCIM    (  xmlData              ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlData.GetDocument( &xddData              ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, Distribute         (  xddData, qr, cluster ));
        }


        __MPC_EXIT_IF_METHOD_FAILS(hr, CollateMachineData( qr, cluster, NULL, NULL, false, &xdd ));
        if(xdd)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdd->get_documentElement( (IXMLDOMElement**)&xdnNodeToInsert ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNode->appendChild( xdnNodeToInsert, &xdnNodeReplaced ));
        }


        //
        // Cleanup everything.
        //
        cluster.clear();
        CleanQueryResult( qr );
    }


    //
    // Them, for each date, collate all its deltas.
    //
    for(seq_it=seq_vec.begin(); seq_it!=seq_vec.end(); seq_it++)
    {
        CComPtr<IXMLDOMDocument> xdd;
        CComPtr<IXMLDOMNode>     xdnNode;
        CComPtr<IXMLDOMNode>     xdnNodeToInsert;
        CComPtr<IXMLDOMNode>     xdnNodeReplaced;


        //
        // Walk through all the providers and load data about the current date.
        //
        for(prov_it=prov_lst.begin(); prov_it!=prov_lst.end(); prov_it++)
        {
            WMIHistory::Data*        wmihpd;
            MPC::XmlUtil             xmlData;
            CComPtr<IXMLDOMDocument> xddData;


            __MPC_EXIT_IF_METHOD_FAILS(hr, (*prov_it)->get_Sequence( *seq_it, wmihpd ));
            if(wmihpd == NULL      ) continue;
            if(wmihpd->IsSnapshot()) continue;


            //
            // If it's the first provider we see in this round, create the proper element, "Snapshot" or "Delta".
            //
            if(xdnNode == NULL)
            {
                dTimestampNext = dTimestampCurrent;

                __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->get_TimestampT0( dTimestampCurrent ));

                //
                // Check if we have reached the requested number of deltas.
                //
                if(lHistory-- <= 0) break;

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( TEXT_TAG_DELTA, &xdnNode ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertDateToString( dTimestampCurrent, szValue, /*fGMT*/true, /*fCIM*/true, 0 ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_TIMESTAMP_T0, szValue, fFound, xdnNode ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertDateToString( dTimestampNext, szValue, /*fGMT*/true, /*fCIM*/true, 0 ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_TIMESTAMP_T1, szValue, fFound, xdnNode ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_TIMEZONE, (LONG)tzi.Bias, fFound, xdnNode ));
            }


            //
            // Load the data and distribuite among clusters.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->LoadCIM    (  xmlData              ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlData.GetDocument( &xddData              ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, Distribute         (  xddData, qr, cluster ));
        }


        __MPC_EXIT_IF_METHOD_FAILS(hr, CollateMachineData( qr, cluster, NULL, NULL, false, &xdd ));
        if(xdd)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdd->get_documentElement( (IXMLDOMElement**)&xdnNodeToInsert ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNode->appendChild( xdnNodeToInsert, &xdnNodeReplaced ));
        }


        //
        // Cleanup everything.
        //
        cluster.clear();
        CleanQueryResult( qr );
    }


    //
    // Return the XML blob to the caller.
    //
    {
        CComPtr<IXMLDOMNode> xdnRoot;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnRoot ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRoot->get_ownerDocument( ppxddDoc ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    //
    // Make sure to delete the temporary WMIParser:Snapshot objects.
    //
    CleanQueryResult( qr );

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////
//                      //
// Event Firing Methods //
//                      //
//////////////////////////

HRESULT CSAFDataCollection::Fire_onStatusChange( ISAFDataCollection* hcpdc, tagDC_STATUS dsStatus )
{
    CComVariant pvars[2];


    //
    // Only this part should be inside a critical section, otherwise deadlocks could occur.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        //
        // Disable events if the "onComplete" event has already been sent.
        //
        if(m_fCompleted) return S_OK;
    }

    pvars[1] = hcpdc;
    pvars[0] = dsStatus;

    return FireAsync_Generic( DISPID_SAF_DCE__ONSTATUSCHANGE, pvars, ARRAYSIZE( pvars ), m_sink_onStatusChange );
}

HRESULT CSAFDataCollection::Fire_onProgress( ISAFDataCollection* hcpdc, LONG lDone, LONG lTotal )
{
    CComVariant pvars[3];


    //
    // Only this part should be inside a critical section, otherwise deadlocks could occur.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        //
        // Disable events if the "onComplete" event has already been sent.
        //
        if(m_fCompleted) return S_OK;

        m_lPercent = lTotal ? (lDone * 100.0 / lTotal) : 0;
    }


    pvars[2] = hcpdc;
    pvars[1] = lDone;
    pvars[0] = lTotal;

    return FireAsync_Generic( DISPID_SAF_DCE__ONPROGRESS, pvars, ARRAYSIZE( pvars ), m_sink_onProgress );
}

HRESULT CSAFDataCollection::Fire_onComplete( ISAFDataCollection* hcpdc, HRESULT hrRes )
{
    CComVariant pvars[2];


    //
    // Only this part should be inside a critical section, otherwise deadlocks could occur.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        //
        // Disable events if the "onComplete" event has already been sent.
        //
        if(m_fCompleted) return S_OK;

        m_fCompleted = true;
    }


    pvars[1] = hcpdc;
    pvars[0] = hrRes;

    return FireAsync_Generic( DISPID_SAF_DCE__ONCOMPLETE, pvars, ARRAYSIZE( pvars ), m_sink_onComplete );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////
//                 //
// Utility Methods //
//                 //
/////////////////////

HRESULT CSAFDataCollection::CanModifyProperties()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CanModifyProperties" );

    HRESULT hr = E_ACCESSDENIED;


    if(m_fWorking   == false ||
       m_fCompleted == true   )
    {
        hr = S_OK;
    }


    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::IsCollectionAborted()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::IsCollectionAborted" );

    HRESULT hr;

    //
    // We not only check for explicit abortion, but also for low memory situations.
    // Our code is almost safe, but we have seen that other parts of the system
    // tend to crash on no-memory scenarios.
    //
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FailOnLowMemory( SAFETY_MARGIN__MEMORY ));

    if(Thread_IsAborted() == true)
    {
		__MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////
//                                        //
// Internal Property Manipulation Methods //
//                                        //
////////////////////////////////////////////

HRESULT CSAFDataCollection::put_Status( /*[in]*/ DC_STATUS newVal )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::put_Status" );

    HRESULT hr = try_Status( (DC_STATUS)-1, newVal );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::try_Status( /*[in]*/ DC_STATUS preVal  ,
                                        /*[in]*/ DC_STATUS postVal )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::try_Status" );

    HRESULT                      hr;
    bool                         fChanged = false;
    DC_STATUS                    dsStatus;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(preVal == m_dsStatus ||
       preVal == -1          )
    {
        fChanged   = (m_dsStatus != postVal);
        m_dsStatus = postVal;

        dsStatus   = m_dsStatus;

        //
        // Clean error at start of data collection.
        //
        switch(m_dsStatus)
        {
        case DC_COLLECTING:
        case DC_COMPARING:
            m_dwErrorCode = 0;
            break;
        }
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    lock = NULL; // Release the lock before firing the event.

    //
    // Important, leave these calls outside Locked Sections!!
    //
    if(SUCCEEDED(hr) && fChanged)
    {
        Fire_onStatusChange( this, dsStatus );
    }

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFDataCollection::put_ErrorCode( /*[in]*/ DWORD newVal )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::put_ErrorCode" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    m_dwErrorCode = newVal;
    hr            = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

////////////////
//            //
// Properties //
//            //
////////////////


STDMETHODIMP CSAFDataCollection::get_Status( /*[out]*/ DC_STATUS *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFDataCollection::get_Status",hr,pVal,m_dsStatus);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFDataCollection::get_PercentDone( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFDataCollection::get_PercentDone",hr,pVal,m_lPercent);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFDataCollection::get_ErrorCode( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFDataCollection::get_ErrorCode",hr,pVal,(long)m_dwErrorCode);

    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFDataCollection::get_MachineData_DataSpec( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrMachineData, pVal );
}

STDMETHODIMP CSAFDataCollection::put_MachineData_DataSpec( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFDataCollection::put_MachineData_DataSpec",hr);

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrMachineData, newVal ));


    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CSAFDataCollection::get_History_DataSpec( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrHistory, pVal );
}

STDMETHODIMP CSAFDataCollection::put_History_DataSpec( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFDataCollection::put_History_DataSpec",hr);

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrHistory, newVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFDataCollection::get_History_MaxDeltas( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFDataCollection::get_History_MaxDeltas",hr,pVal,m_lHistory);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFDataCollection::put_History_MaxDeltas( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFDataCollection::put_History_MaxDeltas",hr);

    //
    // Check validity range.
    //
    if(newVal < 0                               ||
       newVal > WMIHISTORY_MAX_NUMBER_OF_DELTAS  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    m_lHistory = newVal;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFDataCollection::get_History_MaxSupportedDeltas( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFDataCollection::get_History_MaxSupportedDeltas",hr,pVal,WMIHISTORY_MAX_NUMBER_OF_DELTAS);

    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFDataCollection::put_onStatusChange( /*[in]*/ IDispatch* function )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::put_onStatusChange" );

    m_sink_onStatusChange = function;

    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CSAFDataCollection::put_onProgress( /*[in]*/ IDispatch* function )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::put_onProgress" );

    m_sink_onProgress = function;

    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CSAFDataCollection::put_onComplete( /*[in]*/ IDispatch* function )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::put_onComplete" );

    m_sink_onComplete = function;

    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CSAFDataCollection::get_Reports( /*[out]*/ IPCHCollection* *ppC )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::get_Reports" );

    HRESULT                      hr;
    IterConst                    it;
    CComPtr<CPCHCollection>      pColl;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC,NULL);
    __MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    //
    // Create the Enumerator and fill it with jobs.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    for(it = m_lstReports.begin(); it != m_lstReports.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( *it ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppC ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////
// Methods //
/////////////

STDMETHODIMP CSAFDataCollection::ExecuteSync()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::ExecuteSync" );

    HRESULT                           hr;
    CComPtr<CSAFDataCollectionEvents> hcpdceEvent;
    CComPtr<ISAFDataCollection>       hcpdc;


    //
    // Create the Wait object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hcpdceEvent ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, QueryInterface( IID_ISAFDataCollection, (void**)&hcpdc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, hcpdceEvent->WaitForCompletion( hcpdc ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFDataCollection::ExecuteAsync()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::ExecuteAsync" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    CHECK_MODIFY();


    //
    // At least a data spec file should be supplied.
    //
    if(m_bstrMachineData.Length() == 0 &&
       m_bstrHistory    .Length() == 0  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    //
    // Release the lock on current object, otherwise a deadlock could occur.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.Initialize());

    //
    // Let's go into read-only mode.
    //
    StartOperations();

    lock = NULL;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, ExecLoopCollect, NULL ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFDataCollection::Abort()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::Abort" );

    MPC::SmartLock<_ThreadModel> lock( this );


    if(FAILED(CanModifyProperties()))
    {
        Thread_Abort();
    }


    __HCP_FUNC_EXIT(S_OK);
}


STDMETHODIMP CSAFDataCollection::MachineData_GetStream( /*[in]*/ IUnknown* *stream )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::MachineData_GetStream" );

    HRESULT hr;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(stream,NULL);
    __MPC_PARAMCHECK_END();

    if(m_streamMachineData)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_streamMachineData.QueryInterface( stream ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFDataCollection::History_GetStream( /*[in]*/ IUnknown* *stream )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::History_GetStream" );

    HRESULT hr;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(stream,NULL);
    __MPC_PARAMCHECK_END();


    if(m_streamHistory)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_streamHistory.QueryInterface( stream ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFDataCollection::CompareSnapshots( /*[in] */ BSTR bstrFilenameT0   ,
                                                   /*[in] */ BSTR bstrFilenameT1   ,
                                                   /*[in] */ BSTR bstrFilenameDiff )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::CompareSnapshots" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilenameT0);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilenameT1);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilenameDiff);
    __MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    m_bstrFilenameT0   = bstrFilenameT0;
    m_bstrFilenameT1   = bstrFilenameT1;
    m_bstrFilenameDiff = bstrFilenameDiff;


    //
    // Release the lock on current object, otherwise a deadlock could occur.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.Initialize());

    //
    // Let's go into read-only mode.
    //
    StartOperations();

    lock = NULL;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, ExecLoopCompare, NULL ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFDataCollection::ExecScheduledCollection()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollection::ExecScheduledCollection" );

    HRESULT                        hr;
    QueryResults                   qr;
    WMIParser::ClusterByClassMap   cluster;
    WMIHistory::Database           wmihd;
    WMIHistory::Database::ProvList lstQueries;
	HANDLE                         hThread;
	int                            iPriority;

	hThread   = ::GetCurrentThread();
	iPriority = ::GetThreadPriority( hThread );

    ::SetThreadPriority( hThread, THREAD_PRIORITY_LOWEST );


    //
    // Try to lock the database and load the data spec file.
    //
    while(1)
    {
        if(SUCCEEDED(hr = wmihd.Init( DATASPEC_LOCATION, DATASPEC_CONFIG )))
        {
            break;
        }

        if(hr != HRESULT_FROM_WIN32( WAIT_TIMEOUT ))
        {
            __MPC_FUNC_LEAVE;
        }
    }
    __MPC_EXIT_IF_METHOD_FAILS(hr, wmihd.Load());

    //
    // Check if enough time has past between two data collections.
    //
    {
        SYSTEMTIME stNow;
        SYSTEMTIME stLatest;


        ::GetLocalTime           (                   &stNow    );
        ::VariantTimeToSystemTime( wmihd.LastTime(), &stLatest );


        if(stNow.wYear  == stLatest.wYear  &&
           stNow.wMonth == stLatest.wMonth &&
           stNow.wDay   == stLatest.wDay    )
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
        }
    }

    m_fScheduled = true;

    //
    // Filter and count the queries.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, FilterDataSpec( wmihd, NULL, lstQueries ));

    //
    // Collect data from WMI.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ExecDataSpec( qr, cluster, lstQueries, false ));


    //
    // Compute deltas.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ComputeDelta( qr, cluster, lstQueries, true ));

    //
    // Persiste the changes to the database.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, wmihd.Save());


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    CleanQueryResult( qr );

    ::SetThreadPriority( hThread, iPriority );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\database\searchresults.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SearchResults.cpp

Abstract:
    This file contains the implementation of the keyword search.

Revision History:
    Davide Massarenti   (Dmassare)  05/28/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

Taxonomy::KeywordSearch::Token::Token()
{
    m_type       = TOKEN_INVALID; // TOKEN        	  m_type;
                                  // MPC::wstring 	  m_strToken;
                                  // WeightedMatchSet m_results;
                                  //
    m_left       = NULL;          // Token*       	  m_left;
    m_right      = NULL;          // Token*       	  m_right;
}

Taxonomy::KeywordSearch::Token::~Token()
{
    if(m_left ) delete m_left;
    if(m_right) delete m_right;
}

//////////////////////////////////////////////////

bool Taxonomy::KeywordSearch::Token::HasNOT()
{
    if(m_type == TOKEN_NOT) return true;

    if(m_left  && m_left ->HasNOT()) return true;
    if(m_right && m_right->HasNOT()) return true;

    return false;
}

bool Taxonomy::KeywordSearch::Token::HasExplicitOperators()
{
    switch(m_type)
    {
    case TOKEN_NOT:
    case TOKEN_AND:
    case TOKEN_OR : return true;
    }

    if(m_left  && m_left ->HasExplicitOperators()) return true;
    if(m_right && m_right->HasExplicitOperators()) return true;

    return false;
}

void Taxonomy::KeywordSearch::Token::AddHit( /*[in]*/ long ID, /*[in]*/ long priority )
{
	std::pair<WeightedMatchIter,bool> ins = m_results.insert( WeightedMatchSet::value_type( ID, 0 ) );

	ins.first->second += priority;
}

HRESULT Taxonomy::KeywordSearch::Token::ExecuteText( /*[in]*/ LPCWSTR      szKeyword  , 
													 /*[in]*/ RS_Keywords* rsKeywords ,
													 /*[in]*/ RS_Matches*  rsMatches  )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::Token::Execute" );

    HRESULT hr;
    bool    fFound;

	__MPC_EXIT_IF_METHOD_FAILS(hr, rsKeywords->Seek_ByName( szKeyword, &fFound ));
	if(fFound)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, rsMatches->Seek_ByKeyword( rsKeywords->m_ID_keyword, &fFound ));
		while(fFound)
		{
			AddHit( rsMatches->m_ID_topic, rsMatches->m_lPriority );

			__MPC_EXIT_IF_METHOD_FAILS(hr, rsMatches->Move( 0, JET_MoveNext, &fFound ));
        }
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::KeywordSearch::Token::Execute( /*[in]*/ MatchSet&    setAllTheTopics ,
												 /*[in]*/ Updater&     updater         , 
                                                 /*[in]*/ RS_Keywords* rsKeywords      ,
                                                 /*[in]*/ RS_Matches*  rsMatches       )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::Token::Execute" );

    HRESULT hr;

    if(m_type == TOKEN_TEXT)
    {
		MPC::WStringList lst;
		MPC::WStringIter it;

		__MPC_EXIT_IF_METHOD_FAILS(hr, ExecuteText( m_strToken.c_str(), rsKeywords, rsMatches ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, updater.LocateSynonyms( m_strToken.c_str(), lst, /*fMatchOwner*/false ));
		for(it=lst.begin(); it!=lst.end(); it++)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, ExecuteText( it->c_str(), rsKeywords, rsMatches ));
		}
    }

    if(m_type == TOKEN_AND_IMPLICIT ||
       m_type == TOKEN_AND           )
    {
        WeightedMatchSet* master;
        WeightedMatchSet* slave;
        WeightedMatchIter it;

        if(m_left  == NULL ||
           m_right == NULL  )
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_left->Execute( setAllTheTopics, updater, rsKeywords, rsMatches ));
        if(m_left->m_results.size() == 0)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_right->Execute( setAllTheTopics, updater, rsKeywords, rsMatches ));
        if(m_right->m_results.size() == 0)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        //
        // Select the shorter for the outer loop (that is linear).
        //
        if(m_left->m_results.size() < m_right->m_results.size())
        {
            master = &m_left ->m_results;
            slave  = &m_right->m_results;
        }
        else
        {
            master = &m_right->m_results;
            slave  = &m_left ->m_results;
        }

        for(it=master->begin(); it!=master->end(); it++)
        {
            if(slave->find( it->first ) != slave->end())
            {
				AddHit( it->first, it->second );
            }
        }
    }

    if(m_type == TOKEN_OR)
    {
        WeightedMatchIter it;

        if(m_left)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_left->Execute( setAllTheTopics, updater, rsKeywords, rsMatches ));

            for(it=m_left->m_results.begin(); it!=m_left->m_results.end(); it++)
            {
				AddHit( it->first, it->second );
            }
        }

        if(m_right)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_right->Execute( setAllTheTopics, updater, rsKeywords, rsMatches ));

            for(it=m_right->m_results.begin(); it!=m_right->m_results.end(); it++)
            {
				AddHit( it->first, it->second );
            }
        }

    }

    if(m_type == TOKEN_NOT)
    {
        MatchIter it;

        if(m_left)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_left->Execute( setAllTheTopics, updater, rsKeywords, rsMatches ));
        }

        for(it=setAllTheTopics.begin(); it!=setAllTheTopics.end(); it++)
        {
            if(m_left == NULL || m_left->m_results.find( *it ) == m_left->m_results.end())
            {
				AddHit( *it, 0 );
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void Taxonomy::KeywordSearch::Token::CollectKeywords( /*[in/out]*/ MPC::WStringList& lst ) const
{
    if(m_type == TOKEN_TEXT)lst.push_back( m_strToken );

	if(m_left ) m_left ->CollectKeywords( lst );
	if(m_right) m_right->CollectKeywords( lst );
}

HRESULT Taxonomy::KeywordSearch::Token::Stringify( /*[in]*/ MPC::wstring& strNewQuery )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::Token::Stringify" );

    HRESULT hr;


    if(m_type == TOKEN_TEXT)
    {
        strNewQuery = m_strToken;
    }
    else
    {
        if(m_left)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_left->Stringify( strNewQuery ));

            if(m_right)
            {
                MPC::wstring strTmp;

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_right->Stringify( strTmp ));

                if(strTmp.size())
                {
                    strNewQuery += L" ";
                    strNewQuery += strTmp;
                }
            }
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_right->Stringify( strNewQuery ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

LPCWSTR Taxonomy::KeywordSearch::SkipWhite( /*[in]*/ LPCWSTR szStr )
{
    while(iswspace( *szStr )) szStr++;

    return szStr;
}

bool Taxonomy::KeywordSearch::IsNotString( /*[in]*/ LPCWSTR szSrc  ,
                                           /*[in]*/ WCHAR   cQuote )
{
    WCHAR c;

    while((c = *++szSrc) && !iswspace( c ) && c != cQuote);

    return (c != cQuote);
}

bool Taxonomy::KeywordSearch::IsQueryChar( WCHAR c )
{
    if(iswspace( c ) ||
       iswcntrl( c ) ||
       c == '"'      ||
       c == '('      ||
       c == ')'       )
    {
        return false;
    }

    return true;
}

////////////////////////////////////////

void Taxonomy::KeywordSearch::RemoveStopSignsAtEnd( /*[in]*/ LPWSTR szText )
{
    WCHAR              c;
    MPC::wstring       strCmp;
    Taxonomy::WordIter itEnd = m_setStopSignsAtEnd->end();
    LPWSTR             szEnd = szText + wcslen( szText );


    while(szEnd > szText)
    {
        strCmp = *--szEnd;

        if(m_setStopSignsAtEnd->find( strCmp ) != itEnd)
        {
            szEnd[0] = ' ';
        }
        else
        {
            break;
        }
    }
}

void Taxonomy::KeywordSearch::RemoveStopSignsWithoutContext( /*[in]*/ LPWSTR szText )
{
    WCHAR              c;
    MPC::wstring       strCmp;
    Taxonomy::WordIter itEnd = m_setStopSignsWithoutContext->end();


    while((c = *szText++))
    {
        strCmp = c;

        if(m_setStopSignsWithoutContext->find( strCmp ) != itEnd)
        {
            szText[-1] = ' ';
        }
    }
}

void Taxonomy::KeywordSearch::CopyAndEliminateExtraWhiteSpace( /*[in]*/ LPCWSTR szSrc, /*[out]*/ LPWSTR szDst )
{
    bool  fWhitespace = false;
    WCHAR c;

    szSrc = SkipWhite( szSrc );

    while((c = *szSrc++))
    {
        if(iswspace(c))
        {
            if(fWhitespace == false)
            {
                *szDst++    = ' ';
                fWhitespace = true;
            }
        }
        else
        {
            *szDst++    = c;
            fWhitespace = false;
        }
    }

    if(fWhitespace) szDst[-1] = 0;
    else            szDst[ 0] = 0;
}

Taxonomy::KeywordSearch::TOKEN Taxonomy::KeywordSearch::NextToken( /*[in/out]*/ LPCWSTR& szSrc   ,
                                                                   /*[out]   */ LPWSTR   szToken )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::NextToken" );

    TOKEN   token = TOKEN_INVALID;
    LPCWSTR szPtr = SkipWhite( szSrc );
    LPWSTR  szDst = szToken;
    WCHAR   c;


    //
    // End of query?
    //
    c = *szPtr;
    if(c == 0)
    {
        token = TOKEN_EMPTY; __MPC_FUNC_LEAVE;
    }


    //
    // Now deal with Quoted String, which may come in the form of "Quoted String" or 'Quoted String'
    //
    if(c == '"')
    {
        WCHAR cQuote = c;

        while((c = *++szPtr) && c != cQuote)
        {
            *szDst++ = c;
        }

        if(c) szPtr++; // Skip past the closing quote.

        token = TOKEN_TEXT; __MPC_FUNC_LEAVE;
    }

    //
    // This is a special case operator which is '||' synonim for OR.
    //
    if(c == '|')
    {
        if(szPtr[1] != '|') { token = TOKEN_INVALID; __MPC_FUNC_LEAVE; }

        szPtr += 2;

        token = TOKEN_OR; __MPC_FUNC_LEAVE;
    }

    //
    // Single Character Tokens we admit are '+', '&', '(' and ')', return as is, and adjust szPtr.
    //
    if(c == '(') { szPtr++; token = TOKEN_PAREN_OPEN ; __MPC_FUNC_LEAVE; }
    if(c == ')') { szPtr++; token = TOKEN_PAREN_CLOSE; __MPC_FUNC_LEAVE; }
//    if(c == '+') { szPtr++; token = TOKEN_OR         ; __MPC_FUNC_LEAVE; }
//    if(c == '&') { szPtr++; token = TOKEN_AND        ; __MPC_FUNC_LEAVE; }
//    if(c == '!') { szPtr++; token = TOKEN_NOT        ; __MPC_FUNC_LEAVE; }

    //
    // Deal with Alphanumerics:
    //
    // KW-A, 0-A, Abcdedd, ABC2_WE all are taken as a single Query Term
    //
    if(IsQueryChar( c ))
    {
        while(c)
        {
            szPtr++; *szDst++ = c;

            if(IsQueryChar( c = *szPtr )) continue;

            //
            // We are not done yet, if stop character was a quote character we need to find out whether a string comes after.
            //
            if(c == '"' && IsNotString( szPtr, c )) continue;

            break;
        }

        *szDst = 0;

        {
            MPC::wstring strCmp( szToken );

            if(m_setOpNOT->find( strCmp ) != m_setOpNOT->end()) { token = TOKEN_NOT; __MPC_FUNC_LEAVE; }
            if(m_setOpAND->find( strCmp ) != m_setOpAND->end()) { token = TOKEN_AND; __MPC_FUNC_LEAVE; }
            if(m_setOpOR ->find( strCmp ) != m_setOpOR ->end()) { token = TOKEN_OR ; __MPC_FUNC_LEAVE; }
        }

        token = TOKEN_TEXT; __MPC_FUNC_LEAVE;
    }

    __HCP_FUNC_CLEANUP;

    szSrc = szPtr; *szDst = 0;

    __HCP_FUNC_EXIT(token);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::KeywordSearch::AllocateQuery( /*[in]*/  const MPC::wstring& strQuery ,
                                                /*[out]*/ LPWSTR&             szInput  ,
                                                /*[out]*/ LPWSTR&             szOutput )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::AllocateQuery" );

    HRESULT hr;


    szInput  = new WCHAR[strQuery.size()+2];
    szOutput = new WCHAR[strQuery.size()+2];

    if(szInput == NULL || szOutput == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    wcscpy( szInput, strQuery.c_str() );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::KeywordSearch::PreprocessQuery( /*[in/out]*/ MPC::wstring& strQuery )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::PreprocessQuery" );

    HRESULT hr;
    LPWSTR  szInput  = NULL;
    LPWSTR  szOutput = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateQuery( strQuery, szInput, szOutput ));


    RemoveStopSignsAtEnd           ( szInput           );
    RemoveStopSignsWithoutContext  ( szInput           );
    CopyAndEliminateExtraWhiteSpace( szInput, szOutput );

    strQuery = szOutput;
    hr       = S_OK;


    __HCP_FUNC_CLEANUP;

    if(szInput ) delete [] szInput;
    if(szOutput) delete [] szOutput;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Taxonomy::KeywordSearch::Parse( /*[in/out]*/ LPCWSTR& szInput, /*[in]*/ LPWSTR szTmpBuf, /*[in]*/ bool fSubExpr, /*[out]*/ Token*& res )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::Parse" );

    HRESULT hr;
    Token*  obj         = NULL;
    Token*  objOp       = NULL;
    Token*  objDangling = NULL;

    while(1)
    {
        TOKEN token = NextToken( szInput, szTmpBuf );

        if(token == TOKEN_EMPTY) break;

        if(token == TOKEN_INVALID)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }


        //
        // Skip stop words.
        //
        if(token == TOKEN_TEXT && m_setStopWords->find( szTmpBuf ) != m_setStopWords->end()) continue;


        if(token == TOKEN_PAREN_CLOSE)
        {
            if(fSubExpr) break;

            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }


        if(token == TOKEN_PAREN_OPEN)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Parse( szInput, szTmpBuf, true, obj ));

            //
            // Empty subexpression? Not allowed...
            //
            if(obj == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

            //
            // Let's treat a subexpression as a value.
            //
            token = TOKEN_TEXT;
        }
        else
        {
            __MPC_EXIT_IF_ALLOC_FAILS(hr, obj, new Token());
            obj->m_type     = token;
            obj->m_strToken = szTmpBuf;
        }


        if(token == TOKEN_TEXT ||
           token == TOKEN_NOT   )
        {
            if(res == NULL) // First token...
            {
                res = obj;
            }
            else if(objDangling) // Last token of a operator...
            {
                if(objDangling->m_type == TOKEN_NOT) objDangling->m_left  = obj;
                else                                 objDangling->m_right = obj;
            }
            else // Implicit AND...
            {
                __MPC_EXIT_IF_ALLOC_FAILS(hr, objOp, new Token());
                objOp->m_type  = TOKEN_AND_IMPLICIT;
                objOp->m_left  = res;
                objOp->m_right = obj;
                res            = objOp;
                objOp          = NULL;
            }

            objDangling = (obj->m_type == TOKEN_NOT) ? obj : NULL;
            obj         =                                    NULL;
        }
        else
        {
            //
            // What's left are binary operators.
            //
            if(res == NULL || objDangling)
            {
                //
                // We need a left part...
                //
                __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
            }

            //
            // Rotate result.
            //
            obj->m_left = res;
            res         = obj;
            objDangling = obj;
            obj         = NULL;
        }
    }

    //
    // Let's make sure operators have the associated data. '
    //
    if(objDangling)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(obj  ) delete obj;
    if(objOp) delete objOp;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::KeywordSearch::GenerateResults( /*[in]*/ Token*                     obj       ,
                                                  /*[in]*/ CPCHQueryResultCollection* pColl     ,
                                                  /*[in]*/ MPC::WStringUCSet&         setURLs   ,
                                                  /*[in]*/ Taxonomy::MatchSet*        psetNodes )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::GenerateResults" );

    HRESULT           hr;
    WeightedMatchIter it;
    bool              fFound;


    for(it=obj->m_results.begin(); it!=obj->m_results.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Seek_SingleTopic( it->first, &fFound ));
        if(fFound)
        {
            MPC::wstringUC strTopicURL = m_rsTopics->m_strURI;

            if(setURLs.find( strTopicURL ) == setURLs.end())
            {
                CComPtr<CPCHQueryResult> item;
                CPCHQueryResult::Payload data;

                //
                // Not under a node? Skip it.
                //
                if(psetNodes && psetNodes->find( m_rsTopics->m_ID_node ) == psetNodes->end()) continue;

                __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->CreateItem( &item ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ExpandURL( m_rsTopics->m_strURI ));

                data.m_bstrTitle       = m_rsTopics->m_strTitle      .c_str();
                data.m_bstrTopicURL    = m_rsTopics->m_strURI        .c_str();
                data.m_bstrDescription = m_rsTopics->m_strDescription.c_str();
                data.m_lType           = m_rsTopics->m_lType                 ;
                data.m_lPriority       = it->second;

                item->Initialize( data );

                setURLs.insert( strTopicURL );
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

Taxonomy::KeywordSearch::KeywordSearch( /*[in]*/ Updater& updater ) : m_updater( updater )
{
                                         // Updater&           m_updater;
                                         //
    m_setStopSignsAtEnd          = NULL; // WordSet*           m_setStopSignsAtEnd;
    m_setStopSignsWithoutContext = NULL; // WordSet*           m_setStopSignsWithoutContext;
    m_setStopWords               = NULL; // WordSet*           m_setStopWords;
    m_setOpNOT                   = NULL; // WordSet*           m_setOpNOT;
    m_setOpAND                   = NULL; // WordSet*           m_setOpAND;
    m_setOpOR                    = NULL; // WordSet*           m_setOpOR;
}

Taxonomy::KeywordSearch::~KeywordSearch()
{
}

HRESULT Taxonomy::KeywordSearch::Execute( /*[in]*/ LPCWSTR                    szQuery   ,
                                          /*[in]*/ LPCWSTR                    szSubsite ,
                                          /*[in]*/ CPCHQueryResultCollection* pColl     ,
										  /*[in]*/ MPC::WStringList*          lst       )
{
    __HCP_FUNC_ENTRY( "Taxonomy::KeywordSearch::Execute" );

    HRESULT             hr;
    MPC::wstring        strCleanedQuery;
    MPC::WStringUCSet   setURLs;
    Taxonomy::MatchSet  setNodes;
    Taxonomy::MatchSet* psetNodes      = NULL;
    Token*              mainQuery      = NULL;
    Token*              stringifyQuery = NULL;
    LPWSTR              szInput        = NULL;
    LPWSTR              szOutput       = NULL;
    LPCWSTR             szToken;

    //
    // Initialize the database stuff.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetWordSet( UPDATER_SET_STOPSIGNS            , &m_setStopSignsWithoutContext ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetWordSet( UPDATER_SET_STOPSIGNS_ATENDOFWORD, &m_setStopSignsAtEnd          ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetWordSet( UPDATER_SET_STOPWORDS            , &m_setStopWords               ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetWordSet( UPDATER_SET_OPERATOR_NOT         , &m_setOpNOT                   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetWordSet( UPDATER_SET_OPERATOR_AND         , &m_setOpAND                   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetWordSet( UPDATER_SET_OPERATOR_OR          , &m_setOpOR                    ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTopics  ( &m_rsTopics   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetKeywords( &m_rsKeywords ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetMatches ( &m_rsMatches  ));

    //
    // Parse the query.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, PreprocessQuery( strCleanedQuery = szQuery          ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateQuery  ( strCleanedQuery, szInput, szOutput ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Parse( szToken = szInput, szOutput, false, mainQuery ));

    if(mainQuery)
    {
        MatchSet  setAllTheTopics;
        MatchIter it;
        bool      fFound;


        if(STRINGISPRESENT(szSubsite))
        {
            long ID_node;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateTaxonomyNode( ID_node, szSubsite, /*fLookForFather*/false                                  ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateSubNodes    ( ID_node           , /*fRecurse      */true , /*fOnlyVisible*/false, setNodes ));
            setNodes.insert( ID_node ); // Add the node itself.

            psetNodes = &setNodes;
        }

        if(mainQuery->HasNOT())
        {
            //
            // Unfortunately, with the NOT operator we need to load all the topics...
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Move( 0, JET_MoveFirst, &fFound ));
            while(fFound)
            {
                setAllTheTopics.insert( m_rsTopics->m_ID_topic );

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_rsTopics->Move( 0, JET_MoveNext, &fFound ));
            }
        }
        else if(mainQuery->HasExplicitOperators() == false && mainQuery->m_type != TOKEN_TEXT)
        {
            //
            // No explicit operators and more than one term, let's try to "stringify" the query...
            //
            MPC::wstring strNewQuery;

            __MPC_EXIT_IF_METHOD_FAILS(hr, mainQuery->Stringify( strNewQuery ));

            __MPC_EXIT_IF_ALLOC_FAILS(hr, stringifyQuery, new Token());
            stringifyQuery->m_type     = TOKEN_TEXT;
            stringifyQuery->m_strToken = strNewQuery;

            __MPC_EXIT_IF_METHOD_FAILS(hr, stringifyQuery->Execute( setAllTheTopics, m_updater, m_rsKeywords, m_rsMatches ));
			if(lst) stringifyQuery->CollectKeywords( *lst );

            __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateResults( stringifyQuery, pColl, setURLs, psetNodes ));
        }


        __MPC_EXIT_IF_METHOD_FAILS(hr, mainQuery->Execute( setAllTheTopics, m_updater, m_rsKeywords, m_rsMatches ));
		if(lst) mainQuery->CollectKeywords( *lst );

        __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateResults( mainQuery, pColl, setURLs, psetNodes ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(mainQuery     ) delete mainQuery;
    if(stringifyQuery) delete stringifyQuery;

    if(szInput ) delete [] szInput;
    if(szOutput) delete [] szOutput;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\datacollection\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>

#include <Debug.h>

//////

#include <DataCollection.h>

#include <Utility.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\datacollection\datacollection_report.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    DataCollection_Reports.cpp

Abstract:
    This file contains the implementation of the CSAFDataCollectionReport classes,
	which implements the data collection error report functionality.

Revision History:
    Davide Massarenti   (Dmassare)  10/07/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

#define REMEMBER_PAGE_DELAY (3)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CSAFDataCollectionReport::CSAFDataCollectionReport()
{
                       // CComBSTR m_bstrNamespace;
                       // CComBSTR m_bstrClass;
                       // CComBSTR m_bstrWQL;
    m_dwErrorCode = 0; // DWORD    m_dwErrorCode;
                       // CComBSTR m_bstrDescription;
}

////////////////////////////////////////

STDMETHODIMP CSAFDataCollectionReport::get_Namespace( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrNamespace, pVal );
}

STDMETHODIMP CSAFDataCollectionReport::get_Class( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrClass, pVal );
}

STDMETHODIMP CSAFDataCollectionReport::get_WQL( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrWQL, pVal );
}

STDMETHODIMP CSAFDataCollectionReport::get_ErrorCode( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFDataCollectionReport::get_ErrorCode",hr,pVal,m_dwErrorCode);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFDataCollectionReport::get_Description( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrDescription, pVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\datacollection\wmixmlt.h ===
// Created by Microsoft (R) C/C++ Compiler Version 13.00.8806 (b2b799f6).
//
// w:\src\admin\pchealth\helpctr\service\datacollection\obj\i386\wmixmlt.tlh
//
// C++ source equivalent of Win32 type library wmixmlt.tlb
// compiler-generated file created 04/09/00 at 11:48:14 - DO NOT EDIT!

#pragma once
#pragma pack(push, 8)

#include <comdef.h>

//
// Forward references and typedefs
//

struct __declspec(uuid("5d7b2a7c-a4e0-11d1-8ae9-00600806d9b6"))
/* dual interface */ IWmiXMLTranslator;
enum WmiXMLFilterEnum;
enum WmiXMLDTDVersionEnum;
enum WmiXMLClassOriginFilterEnum;
enum WmiXMLDeclGroupTypeEnum;
struct /* coclass */ WmiXMLTranslator;

//
// Smart pointer typedef declarations
//

_COM_SMARTPTR_TYPEDEF(IWmiXMLTranslator, __uuidof(IWmiXMLTranslator));

//
// Type library items
//

struct __declspec(uuid("5d7b2a7c-a4e0-11d1-8ae9-00600806d9b6"))
IWmiXMLTranslator : IDispatch
{
    //
    // Raw methods provided by interface
    //

    virtual HRESULT __stdcall get_SchemaURL (
        /*[out,retval]*/ BSTR * strURL ) = 0;
    virtual HRESULT __stdcall put_SchemaURL (
        /*[in]*/ BSTR strURL ) = 0;
    virtual HRESULT __stdcall get_AllowWMIExtensions (
        /*[out,retval]*/ VARIANT_BOOL * bWMIExtensions ) = 0;
    virtual HRESULT __stdcall put_AllowWMIExtensions (
        /*[in]*/ VARIANT_BOOL bWMIExtensions ) = 0;
    virtual HRESULT __stdcall get_QualifierFilter (
        /*[out,retval]*/ enum WmiXMLFilterEnum * iQualifierFilter ) = 0;
    virtual HRESULT __stdcall put_QualifierFilter (
        /*[in]*/ enum WmiXMLFilterEnum iQualifierFilter ) = 0;
    virtual HRESULT __stdcall get_HostFilter (
        /*[out,retval]*/ VARIANT_BOOL * bHostFilter ) = 0;
    virtual HRESULT __stdcall put_HostFilter (
        /*[in]*/ VARIANT_BOOL bHostFilter ) = 0;
    virtual HRESULT __stdcall get_DTDVersion (
        /*[out,retval]*/ enum WmiXMLDTDVersionEnum * iDTDVersion ) = 0;
    virtual HRESULT __stdcall put_DTDVersion (
        /*[in]*/ enum WmiXMLDTDVersionEnum iDTDVersion ) = 0;
    virtual HRESULT __stdcall GetObject (
        /*[in]*/ BSTR strNamespacePath,
        /*[in]*/ BSTR strObjectPath,
        /*[out,retval]*/ BSTR * strXML ) = 0;
    virtual HRESULT __stdcall ExecQuery (
        /*[in]*/ BSTR strNamespacePath,
        /*[in]*/ BSTR strQuery,
        /*[out,retval]*/ BSTR * strXML ) = 0;
    virtual HRESULT __stdcall get_ClassOriginFilter (
        /*[out,retval]*/ enum WmiXMLClassOriginFilterEnum * iClassOriginFilter ) = 0;
    virtual HRESULT __stdcall put_ClassOriginFilter (
        /*[in]*/ enum WmiXMLClassOriginFilterEnum iClassOriginFilter ) = 0;
    virtual HRESULT __stdcall get_IncludeNamespace (
        /*[out,retval]*/ VARIANT_BOOL * bIncludeNamespace ) = 0;
    virtual HRESULT __stdcall put_IncludeNamespace (
        /*[in]*/ VARIANT_BOOL bIncludeNamespace ) = 0;
    virtual HRESULT __stdcall get_DeclGroupType (
        /*[out,retval]*/ enum WmiXMLDeclGroupTypeEnum * iDeclGroupType ) = 0;
    virtual HRESULT __stdcall put_DeclGroupType (
        /*[in]*/ enum WmiXMLDeclGroupTypeEnum iDeclGroupType ) = 0;
};

enum WmiXMLFilterEnum
{
    wmiXMLFilterNone = 0,
    wmiXMLFilterLocal = 1,
    wmiXMLFilterPropagated = 2,
    wmiXMLFilterAll = 3
};

enum WmiXMLDTDVersionEnum
{
    wmiXMLDTDVersion_2_0 = 0
};

enum WmiXMLClassOriginFilterEnum
{
    wmiXMLClassOriginFilterNone = 0,
    wmiXMLClassOriginFilterClass = 1,
    wmiXMLClassOriginFilterInstance = 2,
    wmiXMLClassOriginFilterAll = 3
};

enum WmiXMLDeclGroupTypeEnum
{
    wmiXMLDeclGroup = 0,
    wmiXMLDeclGroupWithName = 1,
    wmiXMLDeclGroupWithPath = 2
};

struct __declspec(uuid("3b418f72-a4d7-11d1-8ae9-00600806d9b6"))
WmiXMLTranslator;
    // [ default ] interface IWmiXMLTranslator

//
// Named GUID constants initializations
//

extern "C" const GUID __declspec(selectany) LIBID_WmiXML =
    {0xdba159c1,0xa4dc,0x11d1,{0x8a,0xe9,0x00,0x60,0x08,0x06,0xa9,0xb6}};
extern "C" const GUID __declspec(selectany) IID_IWmiXMLTranslator =
    {0x5d7b2a7c,0xa4e0,0x11d1,{0x8a,0xe9,0x00,0x60,0x08,0x06,0xd9,0xb6}};
extern "C" const GUID __declspec(selectany) CLSID_WmiXMLTranslator =
    {0x3b418f72,0xa4d7,0x11d1,{0x8a,0xe9,0x00,0x60,0x08,0x06,0xd9,0xb6}};

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\datacollection\datacollection_wait.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    DataCollection_Wait.cpp

Abstract:
    This file contains the implementation of the DIID_DSAFDataCollectionEvents interface,
    which is used in the ExecuteSync method to receive event from a data collection.

Revision History:
    Davide Massarenti   (Dmassare)  07/22/99
        created

******************************************************************************/

#include "stdafx.h"


CSAFDataCollectionEvents::CSAFDataCollectionEvents()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollectionEvents::CSAFDataCollectionEvents" );
}


HRESULT CSAFDataCollectionEvents::FinalConstruct()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollectionEvents::FinalConstruct" );

    HRESULT hr;


    m_hcpdc    = NULL;  // ISAFDataCollection* m_hcpdc;
    m_dwCookie = 0;     // DWORD               m_dwCookie;
    m_hEvent   = NULL;  // HANDLE              m_hEvent;

    //
    // Create the event used to signal the completion of the transfer.
    //
    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hEvent = CreateEvent( NULL, false, false, NULL )));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


void CSAFDataCollectionEvents::FinalRelease()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollectionEvents::FinalRelease" );


    UnregisterForEvents();

    if(m_hEvent)
    {
        CloseHandle( m_hEvent ); m_hEvent = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFDataCollectionEvents::RegisterForEvents( /*[in]*/ ISAFDataCollection* hcpdc )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollectionEvents::RegisterForEvents" );

    HRESULT                           hr;
    CComPtr<DSAFDataCollectionEvents> pCallback;


    m_hcpdc = hcpdc; m_hcpdc->AddRef();

    __MPC_EXIT_IF_METHOD_FAILS(hr, QueryInterface( DIID_DSAFDataCollectionEvents, (void**)&pCallback ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, AtlAdvise( m_hcpdc, pCallback, DIID_DSAFDataCollectionEvents, &m_dwCookie ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CSAFDataCollectionEvents::UnregisterForEvents()
{
    __HCP_FUNC_ENTRY( "CSAFDataCollectionEvents::UnregisterForEvents" );


    if(m_dwCookie)
    {
        if(AtlUnadvise( m_hcpdc, DIID_DSAFDataCollectionEvents, m_dwCookie ) == S_OK)
        {
            m_dwCookie = 0;
        }
    }

    if(m_hcpdc)
    {
        m_hcpdc->Release(); m_hcpdc = NULL;
    }
}

HRESULT CSAFDataCollectionEvents::WaitForCompletion( /*[in]*/ ISAFDataCollection* hcpdc )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollectionEvents::WaitForCompletion" );

    _ASSERT(m_hcpdc == NULL && hcpdc != NULL);

    HRESULT                      hr;
    DC_STATUS                    dsStatus;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, RegisterForEvents( hcpdc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, hcpdc->ExecuteAsync());

    lock = NULL; // Release the lock while waiting.
    ::WaitForSingleObject( m_hEvent, INFINITE );
    lock = this; // Reacquire the lock.

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    UnregisterForEvents();

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFDataCollectionEvents::Invoke( /*[in]    */ DISPID      dispIdMember,
                                          /*[in]    */ REFIID      riid        ,
                                          /*[in]    */ LCID        lcid        ,
                                          /*[in]    */ WORD        wFlags      ,
                                          /*[in/out]*/ DISPPARAMS *pDispParams ,
                                          /*[out]   */ VARIANT    *pVarResult  ,
                                          /*[out]   */ EXCEPINFO  *pExcepInfo  ,
                                          /*[out]   */ UINT       *puArgErr    )
{
    __HCP_FUNC_ENTRY( "CSAFDataCollectionEvents::Invoke" );

    if(dispIdMember == DISPID_SAF_DCE__ONCOMPLETE)
    {
        Lock();

        SetEvent( m_hEvent );

        Unlock();
    }

    __HCP_FUNC_EXIT(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\datacollection\history.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    History.cpp

Abstract:
    This file contains the implementation of the CHCPHistory class,
    which implements the data collection functionality.

Revision History:
    Davide Massarenti   (Dmassare)  07/22/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

#define SAFETY_LIMIT_UPPER (10*1024*1024)
#define SAFETY_LIMIT_LOWER ( 5*1024*1024)

#define DATABASE_VERSION             (1)

#define TEXT_INDEX                   L"history_db.xml"


#define TEXT_TAG_HC_HISTORY          L"HC_History"
#define TEXT_ATTR_HC_VERSION         L"Version"
#define TEXT_ATTR_HC_SEQ             L"Sequence"
#define TEXT_ATTR_HC_TIMESTAMP       L"Timestamp"


#define TEXT_TAG_CIM                 L"CIM"
#define TEXT_TAG_PROVIDER            L"Provider"
#define TEXT_ATTR_PROVIDER_NAMESPACE L"Namespace"
#define TEXT_ATTR_PROVIDER_CLASS     L"Class"


#define TEXT_TAG_CD                  L"CollectedData"
#define TEXT_ATTR_CD_FILE            L"File"
#define TEXT_ATTR_CD_SEQ             L"Sequence"
#define TEXT_ATTR_CD_CRC             L"CRC"
#define TEXT_ATTR_CD_TIMESTAMP_T0    L"Timestamp_T0"
#define TEXT_ATTR_CD_TIMESTAMP_T1    L"Timestamp_T1"


#define TEXT_TAG_DATASPEC            L"DataSpec"
#define TEXT_TAG_WQL                 L"WQL"
#define TEXT_ATTR_WQL_NAMESPACE      L"Namespace"
#define TEXT_ATTR_WQL_CLASS          L"Class"

/////////////////////////////////////////////////////////////////////////////

typedef std::list< MPC::wstring > FileList;
typedef FileList::iterator        FileIter;
typedef FileList::const_iterator  FileIterConst;

class CompareNocase
{
    MPC::NocaseCompare m_cmp;
    MPC::wstring&      m_str;
public:
    explicit CompareNocase( MPC::wstring& str ) : m_str(str) {}

    bool operator()( const MPC::wstring& str ) { return m_cmp( str, m_str ); }
};


/////////////////////////////////////////////////////////////////////////////

static HRESULT Local_ConvertDateToString( /*[in] */ DATE          dDate  ,
                                          /*[out]*/ MPC::wstring& szDate )
{
    //
    // Use CIM conversion.
    //
    return MPC::ConvertDateToString( dDate, szDate, /*fGMT*/false, /*fCIM*/true, 0 );
}

static HRESULT Local_ConvertStringToDate( /*[in] */ const MPC::wstring& szDate ,
                                          /*[out]*/ DATE&               dDate  )
{
	return MPC::ConvertStringToDate( szDate, dDate, /*fGMT*/false, /*fCIM*/true, 0 );
}

////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// WMIHistory::Data Class
//
/////////////////////////////////////////////////////////////////////////////
WMIHistory::Data::Data( /*[in]*/ Provider* wmihp )
{
    m_wmihp        = wmihp;                              // Provider*    m_wmihp;
                                                         // MPC::wstring m_szFile;
    m_lSequence    = wmihp->m_wmihd->m_lSequence_Latest; // LONG         m_lSequence;
    m_dwCRC        = 0;                                  // DWORD        m_dwCRC;
    m_dTimestampT0 = 0;                                  // DATE         m_dTimestampT0;
    m_dTimestampT1 = 0;                                  // DATE         m_dTimestampT1;
    m_fDontDelete  = false;                              // bool         m_fDontDelete;
}

WMIHistory::Data::~Data()
{
    if(m_fDontDelete == false)
    {
        MPC::wstring szFile( m_szFile ); m_wmihp->m_wmihd->GetFullPathName( szFile );

        (void)MPC::DeleteFile( szFile );
    }
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Data::get_File( /*[out]*/ MPC::wstring& szFile )
{
    szFile = m_szFile;

    return S_OK;
}

HRESULT WMIHistory::Data::get_Sequence( /*[out]*/ LONG& lSequence )
{
    lSequence = m_lSequence;

    return S_OK;
}

HRESULT WMIHistory::Data::get_TimestampT0( /*[out]*/ DATE& dTimestampT0 )
{
    dTimestampT0 = m_dTimestampT0;

    return S_OK;
}

HRESULT WMIHistory::Data::get_TimestampT1( /*[out]*/ DATE& dTimestampT1 )
{
    dTimestampT1 = m_dTimestampT1;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

bool WMIHistory::Data::IsSnapshot()
{
    return (m_dTimestampT1 == 0);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Data::LoadCIM( /*[in]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Data::LoadCIM" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmihp->m_wmihd->LoadCIM( m_szFile.c_str(), xml, TEXT_TAG_CIM ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// WMIHistory::Provider Class
//
/////////////////////////////////////////////////////////////////////////////
WMIHistory::Provider::Provider( Database* wmihd )
{
    m_wmihd = wmihd; // Database*    m_wmihd;
                     // DataList     m_lstData;
                     // DataList     m_lstDataTmp;
                     // MPC::wstring m_szNamespace;
                     // MPC::wstring m_szClass;
                     // MPC::wstring m_szWQL;
}

WMIHistory::Provider::~Provider()
{
    MPC::CallDestructorForAll( m_lstData    );
    MPC::CallDestructorForAll( m_lstDataTmp );
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Provider::enum_Data( /*[out]*/ DataIterConst& itBegin ,
                                         /*[out]*/ DataIterConst& itEnd   )
{
    itBegin = m_lstData.begin();
    itEnd   = m_lstData.end  ();

    return S_OK;
}

HRESULT WMIHistory::Provider::get_Namespace( /*[out]*/ MPC::wstring& szNamespace )
{
    szNamespace = m_szNamespace;

    return S_OK;
}

HRESULT WMIHistory::Provider::get_Class( /*[out]*/ MPC::wstring& szClass )
{
    szClass = m_szClass;

    return S_OK;
}

HRESULT WMIHistory::Provider::get_WQL( /*[out]*/ MPC::wstring& szWQL )
{
    szWQL = m_szWQL;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Provider::insert_Snapshot( /*[in]*/ Data* wmihpd   ,
                                               /*[in]*/ bool  fPersist )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Provider::insert_Snapshot" );

    HRESULT hr;


    m_lstData   .remove    ( wmihpd );
    m_lstDataTmp.remove    ( wmihpd );
    m_lstData   .push_front( wmihpd );


    //
    // If we add a new snapshot, we need to link the first delta to it.
    //
    if(wmihpd->IsSnapshot())
    {
        Data* wmihpd_Delta;

        __MPC_EXIT_IF_METHOD_FAILS(hr, get_Delta( 0, wmihpd_Delta ));
        if(wmihpd_Delta)
        {
            wmihpd_Delta->m_dTimestampT1 = wmihpd->m_dTimestampT0;
        }
    }


    //
    // Only keep the snapshot's file if the flag is set.
    //
    if(fPersist) wmihpd->m_fDontDelete = true;

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIHistory::Provider::remove_Snapshot( /*[in]*/ Data* wmihpd   ,
                                               /*[in]*/ bool  fPersist )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Provider::remove_Snapshot" );

    HRESULT hr;


    m_lstData   .remove( wmihpd );
    m_lstDataTmp.remove( wmihpd );

    //
    // Only delete the snapshot's file if the flag is set.
    //
    if(fPersist) wmihpd->m_fDontDelete = false;
    delete wmihpd;

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Provider::alloc_Snapshot( /*[in] */ MPC::XmlUtil& xmlNode ,
                                              /*[out]*/ Data*       & wmihpd  )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Provider::alloc_Snapshot" );

    HRESULT      hr;
    MPC::wstring szFile;
    Data*        wmihpdTmp = NULL;


    wmihpd = NULL;



    //
    // Purge deltas if low on disk space.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureFreeSpace());


    //
    // Generate a new name.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmihd->GetNewUniqueFileName( szFile ));

    //
    // Create a new Collected Data object.
    //
    __MPC_EXIT_IF_ALLOC_FAILS(hr, wmihpdTmp, new Data( this ));
    wmihpdTmp->m_szFile       = szFile;
    wmihpdTmp->m_dTimestampT0 = m_wmihd->m_dTimestamp;

    //
    // Save it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmihd->SaveCIM( szFile.c_str(), xmlNode, wmihpdTmp->m_dwCRC ));
    m_lstDataTmp.push_back( wmihpdTmp );

    //
    // Return the pointer to the caller.
    //
    wmihpd    = wmihpdTmp;
    wmihpdTmp = NULL;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(wmihpdTmp) delete wmihpdTmp;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIHistory::Provider::get_Snapshot( /*[out]*/ Data*& wmihpd )
{
    DataIter it;

    wmihpd = NULL;

    for(it=m_lstData.begin(); it != m_lstData.end(); it++)
    {
        if((*it)->IsSnapshot())
        {
            wmihpd = *it;
            break;
        }
    }

    return S_OK;
}

HRESULT WMIHistory::Provider::get_Delta( /*[in] */ int    iIndex ,
                                         /*[out]*/ Data*& wmihpd )
{
    DataIter it;

    wmihpd = NULL;

    for(it=m_lstData.begin(); it != m_lstData.end(); it++)
    {
        if((*it)->IsSnapshot() == false)
        {
            if(iIndex-- == 0)
            {
                wmihpd = *it;
                break;
            }
        }
    }

    return S_OK;
}

HRESULT WMIHistory::Provider::get_Date( /*[in] */ DATE   dDate  ,
                                        /*[out]*/ Data*& wmihpd )
{
    DataIter it;

    wmihpd = NULL;

    for(it=m_lstData.begin(); it != m_lstData.end(); it++)
    {
        if((*it)->m_dTimestampT0 == dDate)
        {
            wmihpd = *it;
            break;
        }
    }

    return S_OK;
}

HRESULT WMIHistory::Provider::get_Sequence( /*[in]*/  LONG   lSequence ,
                                            /*[out]*/ Data*& wmihpd    )
{
    DataIter it;

    wmihpd = NULL;

    for(it=m_lstData.begin(); it != m_lstData.end(); it++)
    {
        if((*it)->m_lSequence == lSequence)
        {
            wmihpd = *it;
            break;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Provider::ComputeDiff( /*[in] */ Data*  wmihpd_T0 ,
                                           /*[in] */ Data*  wmihpd_T1 ,
                                           /*[out]*/ Data*& wmihpd    )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Provider::ComputeDiff" );

    HRESULT      hr;
    MPC::wstring szFile;


    wmihpd = NULL;


    //
    // Purge deltas if low on disk space.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureFreeSpace());


    //
    // Generate a new name.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmihd->GetNewUniqueFileName( szFile ));

    //
    // Create a new Collected Data object.
    //
    __MPC_EXIT_IF_ALLOC_FAILS(hr, wmihpd, new Data( this ));
    m_lstDataTmp.push_back( wmihpd );

    wmihpd->m_szFile       = szFile;
    wmihpd->m_dTimestampT0 = wmihpd_T0->m_dTimestampT0;
    wmihpd->m_dTimestampT1 = wmihpd_T1->m_dTimestampT0;
    wmihpd->m_lSequence    = wmihpd_T1->m_lSequence - 1; // Decrement by one, so in the sequence order the delta comes before the snapshot.

    {
        MPC::wstring szPreviousFile   = wmihpd_T0->m_szFile; m_wmihd->GetFullPathName( szPreviousFile );
        MPC::wstring szNextFile       = wmihpd_T1->m_szFile; m_wmihd->GetFullPathName( szNextFile     );
        MPC::wstring szDeltaFile      = wmihpd   ->m_szFile; m_wmihd->GetFullPathName( szDeltaFile    );
        CComBSTR     bstrPreviousFile = szPreviousFile.c_str();
        CComBSTR     bstrNextFile     = szNextFile    .c_str();
        CComBSTR     bstrDeltaFile    = szDeltaFile   .c_str();
        VARIANT_BOOL fCreated;

        //
        // Calculate the delta...
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, WMIParser::CompareSnapshots( bstrPreviousFile, bstrNextFile, bstrDeltaFile, &fCreated ));
        if(fCreated == VARIANT_FALSE)
        {
            //
            // No differences, so return a NULL pointer.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, remove_Snapshot( wmihpd )); wmihpd = NULL;
        }
		else
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( wmihpd->m_dwCRC, bstrDeltaFile ));
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIHistory::Provider::EnsureFreeSpace()
{
    __HCP_FUNC_ENTRY( "WMIHistory::Provider::EnsureFreeSpace" );

    HRESULT        hr;
    MPC::wstring   szBase; m_wmihd->GetFullPathName( szBase ); // Get the path of the database.
    ULARGE_INTEGER liFree;
    ULARGE_INTEGER liTotal;


    while(1)
    {
        LONG lMinSequence = -1;
        bool fRemoved     = false;


        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetDiskSpace( szBase, liFree, liTotal ));


        //
        // Enough space, so exit.
        //
        if(liFree.HighPart > 0                  ||
           liFree.LowPart  > SAFETY_LIMIT_UPPER  )
        {
            break;
        }


        //
        // Do two passes, the first to get the lowest sequence number, the second to remove the items.
        //
        for(int pass=0; pass<2; pass++)
        {
            WMIHistory::Database::ProvIterConst prov_itBegin;
            WMIHistory::Database::ProvIterConst prov_itEnd;
            WMIHistory::Database::ProvIterConst prov_it;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmihd->get_Providers( prov_itBegin, prov_itEnd ));
            for(prov_it=prov_itBegin; prov_it!=prov_itEnd; prov_it++)
            {
                Provider* wmihp = *prov_it;

                if(pass == 0)
                {
                    //
                    // First pass, get the lowest sequence number for this provider.
                    //
                    DataIterConst it;

                    for(it=wmihp->m_lstData.begin(); it!=wmihp->m_lstData.end(); it++)
                    {
                        Data* wmihpd = *it;
                        LONG  lSequence;

                        if(wmihpd->IsSnapshot()) continue;

                        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->get_Sequence( lSequence ));

                        if(lMinSequence == -1        ||
                           lMinSequence >  lSequence  )
                        {
                            lMinSequence = lSequence;
                        }
                    }
                }
                else
                {
                    //
                    // Second pass, remove an item from this provider, if it has the lowest sequence number.
                    //
                    Data* wmihpd;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->get_Sequence( lMinSequence, wmihpd ));
                    if(wmihpd)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, wmihp->remove_Snapshot( wmihpd ));
                        fRemoved = true;
                    }
                }
            }
        }

        if(fRemoved == false) break;
    }

    //
    // Too little space, fail.
    //
    if(liFree.HighPart == 0                  &&
       liFree.LowPart   < SAFETY_LIMIT_LOWER  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// WMIHistory::Database Class
//
/////////////////////////////////////////////////////////////////////////////

WMIHistory::Database::Database() : MPC::NamedMutex( NULL )
{
                                               // ProvList     m_lstProviders;
                                               // MPC::wstring m_szBase;
                                               // MPC::wstring m_szSchema;
    m_lSequence         = 0;                   // LONG         m_lSequence;
    m_lSequence_Latest  = 0;                   // LONG         m_lSequence_Latest;
    m_dTimestamp        = MPC::GetLocalTime(); // DATE         m_dTimestamp;
    m_dTimestamp_Latest = 0;                   // DATE         m_dTimestamp_Latest;
}

WMIHistory::Database::~Database()
{
    MPC::CallDestructorForAll( m_lstProviders );
}

void WMIHistory::Database::GetFullPathName( /*[in]*/ MPC::wstring& szFile )
{
    MPC::wstring szFullFile;

    szFullFile = m_szBase;
    szFullFile.append( L"\\"  );
    szFullFile.append( szFile );

    szFile = szFullFile;
}

HRESULT WMIHistory::Database::GetNewUniqueFileName( /*[in]*/ MPC::wstring& szFile )
{
    WCHAR rgBuf[64];

    swprintf( rgBuf, L"CollectedData_%ld.xml", ++m_lSequence );
    szFile = rgBuf;

    return S_OK;
}

HRESULT WMIHistory::Database::PurgeFiles()
{
    __HCP_FUNC_ENTRY( "WMIHistory::Database::PurgeFiles" );

    HRESULT                          hr;
    MPC::wstring                     szFullFile;
    MPC::FileSystemObject            fso( m_szBase.c_str() );
    MPC::FileSystemObject::List      fso_lst;
    MPC::FileSystemObject::IterConst fso_it;
    FileList                         name_lst;
    FileIterConst                    name_it;
    ProvIter                         it;
    bool                             fRewrite = false;


    //
    // Enumerate all the providers and delete delta files not in time order. Also, remove items refering to non-existing files.
    //
    for(it=m_lstProviders.begin(); it != m_lstProviders.end(); it++)
    {
        Provider::DataIterConst itBegin;
        Provider::DataIterConst itEnd;
        Data*                   wmihpd;

        while(1)
        {
            DATE dTimestamp = 0;

            //
            // Get the time of the last snapshot.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->get_Snapshot( wmihpd ));
            if(wmihpd)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->get_TimestampT0( dTimestamp ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->enum_Data( itBegin, itEnd ));
            for( ;itBegin != itEnd; itBegin++)
            {
                wmihpd = *itBegin;

                //
                // Does the file exist and have the same CRC?
                //
                {
					DWORD dwCRC;

                    szFullFile = wmihpd->m_szFile; GetFullPathName( szFullFile );

                    if(MPC::FileSystemObject::IsFile( szFullFile.c_str() ) == false)
                    {
                        break;
                    }

					if(FAILED(MPC::ComputeCRC( dwCRC, szFullFile.c_str() )) || dwCRC != wmihpd->m_dwCRC)
					{
						break;
					}
                }

                if(wmihpd->IsSnapshot() == false)
                {
                    //
                    // Is timestamp in the proper order?
                    //
                    DATE dTimestampDelta;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->get_TimestampT1( dTimestampDelta ));
                    if(dTimestampDelta != dTimestamp)
                    {
                        break;
                    }
                }

                //
                // Everything is ok, proceed to the next delta.
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, wmihpd->get_TimestampT0( dTimestamp ));
            }

            //
            // No delta has been removed, so break out of the loop.
            //
            if(itBegin == itEnd) break;

            fRewrite = true;
            __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->remove_Snapshot( wmihpd, true ));
        }
    }


    //
    // Create a list of files to be kept. Insert the database itself.
    //
    szFullFile = TEXT_INDEX;
    GetFullPathName   ( szFullFile );
    name_lst.push_back( szFullFile );

    //
    // Insert all the providers' files.
    //
    for(it=m_lstProviders.begin(); it != m_lstProviders.end(); it++)
    {
        Provider::DataIterConst itBegin;
        Provider::DataIterConst itEnd;

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->enum_Data( itBegin, itEnd ));
        while(itBegin != itEnd)
        {
            szFullFile = (*itBegin++)->m_szFile;
            GetFullPathName   ( szFullFile );
            name_lst.push_back( szFullFile );
        }
    }

    ////////////////////////////////////////

    //
    // Inspect the database directory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.CreateDir( true ));


    //
    // Delete any subdirectory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFolders( fso_lst ));
    for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->Delete( true, false ));
    }
    fso_lst.clear();

    //
    // For each file, if it's not in the database, delete it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFiles( fso_lst ));
    for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->get_Path( szFullFile ));

        name_it = std::find_if( name_lst.begin(), name_lst.end(), CompareNocase( szFullFile ) );
        if(name_it == name_lst.end())
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->Delete( false, false ));
        }
    }
    fso_lst.clear();

    //
    // In case an entry has been removed, rewrite the DB to disk.
    //
    if(fRewrite)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, Save());
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Database::Init( /*[in]*/ LPCWSTR szBase   ,
                                    /*[in]*/ LPCWSTR szSchema )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Database::Init" );

    HRESULT      hr;
    MPC::XmlUtil xml;
    bool         fLoaded;
    bool         fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szSchema);
    __MPC_PARAMCHECK_END();


    m_szSchema = szSchema; MPC::SubstituteEnvVariables( m_szSchema );
    if(szBase)
    {
        m_szBase = szBase; MPC::SubstituteEnvVariables( m_szBase );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_szBase ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetLock( 100 ));
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( m_szSchema.c_str(), TEXT_TAG_DATASPEC, fLoaded, &fFound ));
    if(fLoaded == false ||
       fFound  == false  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_OPEN_FAILED);
    }
    else
    {
        CComPtr<IXMLDOMNodeList> xdnlList;
        CComPtr<IXMLDOMNode>     xdnNode;
        MPC::wstring             szValue;
        CComVariant              vValue;


        //
        // Parse WQLs.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( TEXT_TAG_WQL, &xdnlList ));
        for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
        {
            Provider* wmihp;


            //
            // Create a new provider.
            //
            __MPC_EXIT_IF_ALLOC_FAILS(hr, wmihp, new Provider( this ));
            m_lstProviders.push_back( wmihp );

            //
            // Read its properties.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, TEXT_ATTR_WQL_NAMESPACE, szValue, fFound, xdnNode ));
            if(fFound == false)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
            }
            wmihp->m_szNamespace = szValue;


            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, TEXT_ATTR_WQL_CLASS, szValue, fFound, xdnNode ));
            if(fFound == false)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
            }
            wmihp->m_szClass = szValue;


            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, vValue, fFound, xdnNode ));
            if(fFound)
            {
                if(SUCCEEDED(vValue.ChangeType( VT_BSTR )))
                {
                    wmihp->m_szWQL = OLE2W( vValue.bstrVal );
                }
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIHistory::Database::Load()
{
    __HCP_FUNC_ENTRY( "WMIHistory::Database::Load" );

    HRESULT      hr;
    MPC::XmlUtil xml;


    //
    // Load the database.
    //
	if(SUCCEEDED(LoadCIM( TEXT_INDEX, xml, TEXT_TAG_HC_HISTORY )))
    {
        CComPtr<IXMLDOMNodeList> xdnlList;
        CComPtr<IXMLDOMNode>     xdnNode;
        MPC::wstring             szValue;
        bool                     fFound;
        LONG                     lVersion;


        //
        // First of all, check database version.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, TEXT_ATTR_HC_VERSION, lVersion, fFound ));
        if(fFound && lVersion == DATABASE_VERSION)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, TEXT_ATTR_HC_SEQ, m_lSequence, fFound ));
            m_lSequence_Latest = m_lSequence;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, TEXT_ATTR_HC_TIMESTAMP, szValue, fFound ));
            if(fFound)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ConvertStringToDate( szValue, m_dTimestamp_Latest ));
            }

            //
            // Enumerate all the PROVIDER elements.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( TEXT_TAG_PROVIDER, &xdnlList ));
            for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
            {
                Provider*    wmihp;
                MPC::wstring szNamespace;
                MPC::wstring szClass;


                //
                // Read the attributes.
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, TEXT_ATTR_PROVIDER_NAMESPACE, szValue, fFound, xdnNode ));
                if(fFound)
                {
                    szNamespace = szValue;
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, TEXT_ATTR_PROVIDER_CLASS, szValue, fFound, xdnNode ));
                if(fFound)
                {
                    szClass = szValue;
                }

                //
                // If the provider is present in the Schema, parse it.
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, find_Provider( NULL, &szNamespace, &szClass, wmihp ));
                if(wmihp)
                {
                    MPC::XmlUtil             xmlSub( xdnNode );
                    CComPtr<IXMLDOMNodeList> xdnlSubList;
                    CComPtr<IXMLDOMNode>     xdnSubNode;


                    //
                    // Enumerate all the COLLECTEDDATA elements.
                    //
                    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSub.GetNodes( TEXT_TAG_CD, &xdnlSubList ));
                    for(;SUCCEEDED(hr = xdnlSubList->nextNode( &xdnSubNode )) && xdnSubNode != NULL; xdnSubNode = NULL)
                    {
                        MPC::wstring szTimestamp;
                        MPC::wstring szFile;
                        LONG         lSequence    = 0;
						long         lCRC         = 0;
                        DATE         dTimestampT0 = 0;
                        DATE         dTimestampT1 = 0;

                        //
                        // Read the attributes.
                        //
                        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSub.GetAttribute( NULL, TEXT_ATTR_CD_FILE, szFile, fFound, xdnSubNode ));

                        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSub.GetAttribute( NULL, TEXT_ATTR_CD_SEQ, lSequence, fFound, xdnSubNode ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSub.GetAttribute( NULL, TEXT_ATTR_CD_CRC, lCRC     , fFound, xdnSubNode ));

                        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSub.GetAttribute( NULL, TEXT_ATTR_CD_TIMESTAMP_T0, szTimestamp, fFound, xdnSubNode ));
                        if(fFound)
                        {
                            __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ConvertStringToDate( szTimestamp, dTimestampT0 ));
                        }

                        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSub.GetAttribute( NULL, TEXT_ATTR_CD_TIMESTAMP_T1, szTimestamp, fFound, xdnSubNode ));
                        if(fFound)
                        {
                            __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ConvertStringToDate( szTimestamp, dTimestampT1 ));
                        }


                        if(szFile.length() && dTimestampT0 != 0)
                        {
                            Data* wmihpd;

                            //
                            // Create a new Collected Data object.
                            //
                            __MPC_EXIT_IF_ALLOC_FAILS(hr, wmihpd, new Data( wmihp ));
                            wmihp->m_lstData.push_back( wmihpd );

                            wmihpd->m_szFile       = szFile;
                            wmihpd->m_lSequence    = lSequence;
                            wmihpd->m_dwCRC        = lCRC;
                            wmihpd->m_dTimestampT0 = dTimestampT0;
                            wmihpd->m_dTimestampT1 = dTimestampT1;
                            wmihpd->m_fDontDelete  = true;
                        }
                    }
                }
            }
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, PurgeFiles());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIHistory::Database::Save()
{
    __HCP_FUNC_ENTRY( "WMIHistory::Database::Save" );

    HRESULT      hr;
    MPC::XmlUtil xml;
    ProvIter     it;
    MPC::wstring szValue;
    bool         fFound;


    //
    // Create a new database.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.New( TEXT_TAG_HC_HISTORY ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_HC_VERSION, (LONG)DATABASE_VERSION, fFound ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_HC_SEQ, m_lSequence, fFound ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ConvertDateToString( m_dTimestamp, szValue ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_HC_TIMESTAMP, szValue, fFound ));


    //
    // Enumerate all the providers.
    //
    for(it=m_lstProviders.begin(); it != m_lstProviders.end(); it++)
    {
        Provider*               wmihp = *it;
        Provider::DataIterConst itSub;
        CComPtr<IXMLDOMNode>    xdnNode;
        long                    lMaxDeltas = WMIHISTORY_MAX_NUMBER_OF_DELTAS;

        //
        // Don't generate a "Provider" element if there's no data associated with it.
        //
        if(wmihp->m_lstData.size() == 0)
        {
            continue;
        }

        //
        // Create a PROVIDER element.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( TEXT_TAG_PROVIDER, &xdnNode ));

        //
        // Set its attributes.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_PROVIDER_NAMESPACE, wmihp->m_szNamespace, fFound, xdnNode ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_PROVIDER_CLASS    , wmihp->m_szClass    , fFound, xdnNode ));

        //
        // Enumerate all the collected data entries.
        //
        for(itSub=wmihp->m_lstData.begin(); itSub != wmihp->m_lstData.end(); itSub++)
        {
            Data* wmihpd = *itSub;

            if(lMaxDeltas-- < 0) // Don't count initial snapshot.
            {
                //
                // Exceed maximum number of deltas, start purgeing oldest ones.
                //
                wmihpd->m_fDontDelete = false;
            }
            else
            {
                CComPtr<IXMLDOMNode> xdnSubNode;

                //
                // Create a COLLECTEDDATA element.
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( TEXT_TAG_CD, &xdnSubNode, xdnNode ));

                //
                // Set its attributes.
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_CD_FILE, wmihpd->m_szFile   , fFound, xdnSubNode ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_CD_SEQ , wmihpd->m_lSequence, fFound, xdnSubNode ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_CD_CRC , wmihpd->m_dwCRC    , fFound, xdnSubNode ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ConvertDateToString( wmihpd->m_dTimestampT0, szValue ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_CD_TIMESTAMP_T0, szValue, fFound, xdnSubNode ));

                if(wmihpd->m_dTimestampT1)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ConvertDateToString( wmihpd->m_dTimestampT1, szValue ));
                    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, TEXT_ATTR_CD_TIMESTAMP_T1, szValue, fFound, xdnSubNode ));
                }
            }
        }
    }

	{
		DWORD dwCRC; // Not used.

		__MPC_EXIT_IF_METHOD_FAILS(hr, SaveCIM( TEXT_INDEX, xml, dwCRC ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Database::get_Providers( /*[out]*/ ProvIterConst& itBegin ,
                                             /*[out]*/ ProvIterConst& itEnd   )
{
    itBegin = m_lstProviders.begin();
    itEnd   = m_lstProviders.end  ();

    return S_OK;
}

HRESULT WMIHistory::Database::find_Provider( /*[in]*/ ProvIterConst*      it         ,
                                             /*[in]*/ const MPC::wstring* szNamespace,
                                             /*[in]*/ const MPC::wstring* szClass    ,
                                             /*[in]*/ Provider*         & wmihp      )
{
    ProvIterConst      itFake;
    MPC::NocaseCompare cmp;


    wmihp = NULL;

    //
    // If the caller hasn't provider an iterator, provide a local one,
    // pointing to the beginning of the list.
    //
    if(it == NULL)
    {
        it = &itFake; itFake = m_lstProviders.begin();
    }

    while(*it != m_lstProviders.end())
    {
        Provider* prov = *(*it)++;

        if((szNamespace == NULL || cmp( *szNamespace, prov->m_szNamespace )) &&
           (szClass     == NULL || cmp( *szClass    , prov->m_szClass     ))  )
        {
            wmihp = prov;
            break;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIHistory::Database::LoadCIM( /*[in]*/ LPCWSTR       szFile ,
                                       /*[in]*/ MPC::XmlUtil& xml    ,
                                       /*[in]*/ LPCWSTR       szTag  )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Database::LoadCIM" );

    HRESULT      hr;
    MPC::wstring szFullFile = szFile; GetFullPathName( szFullFile );
	bool         fLoaded;
    bool         fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( szFullFile.c_str(), szTag, fLoaded, &fFound ));
	if(fLoaded == false ||
       fFound  == false  )
	{
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
	}


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT WMIHistory::Database::SaveCIM( /*[in]*/  LPCWSTR       szFile ,
                                       /*[in]*/  MPC::XmlUtil& xml    ,
									   /*[out]*/ DWORD&        dwCRC  )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Database::SaveCIM" );

    HRESULT      hr;
    MPC::wstring szFullFile = szFile; GetFullPathName( szFullFile );


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Save       (        szFullFile.c_str() ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( dwCRC, szFullFile.c_str() ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIHistory::Database::GetLock( /*[in]*/ DWORD dwMilliseconds )
{
    __HCP_FUNC_ENTRY( "WMIHistory::Database::GetLock" );

    HRESULT hr;
    WCHAR   szMutexName[MAX_PATH];
    LPWSTR  szPos;


    //
    // If the database directory is set, protect it using a mutex.
    //
    if(m_szBase.length())
    {
        swprintf( szMutexName, L"PCHMUTEX_%s", m_szBase.c_str() );

        //
        // Make sure no strange characters are present in the mutex name.
        //
        for(szPos=szMutexName; *szPos; szPos++)
        {
            *szPos = (WCHAR)towlower( *szPos );

            if(*szPos == ':'  ||
               *szPos == '/'  ||
               *szPos == '\\'  )
            {
                *szPos = '_';
            }
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, SetName( szMutexName    ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, Acquire( dwMilliseconds ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\hcupdate\processhht.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pkgdesc.cpp

Abstract:
    Functions related to package description file processing

Revision History:

    Ghim-Sim Chua       (gschua)   07/07/99
        - created

********************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

HRESULT HCUpdate::Engine::GetNodeDepth( /*[in]*/ LPCWSTR szCategory, /*[out]*/ int& iDepth )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::GetNodeDepth" );

    HRESULT            hr;
    MPC::WStringVector vec;

    iDepth = 0;
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::Settings::SplitNodePath( szCategory, vec ));
    iDepth = vec.size();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::CheckNode( /*[in] */ LPCWSTR szCategory ,
                                     /*[out]*/ bool&   fExist     ,
                                     /*[out]*/ bool&   fCanCreate )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::CheckNode" );

	const HRESULT          hrDenied = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    HRESULT                hr;
    Taxonomy::RS_Taxonomy* rs;

    fExist     = false;
    fCanCreate = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTaxonomy( &rs ));


    //
    // Check if node already exists.
    //
    {
        long ID_node;

        if(SUCCEEDED(m_updater.LocateTaxonomyNode( ID_node, szCategory, false )))
        {
            //
            // Make sure it's owned by the same entity. Microsoft can however grab a node from an OEM.
            //
            if(IsMicrosoft() == false)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Seek_Node( ID_node ));
                if(rs->m_ID_owner != m_updater.GetOwner())
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hrDenied, L"ERROR: node already exists" ));
                }
            }


            fCanCreate = true;
            fExist     = true;

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }


    //
    // Check if it is Microsoft.
    //
    if(IsMicrosoft())
    {
        fCanCreate = true;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Check number of nodes created already (only during normal package update).
    //
    if(m_sku)
    {
        bool fFound;
		bool fOwnerOfParent = false;
        int  iCount         = 0;
		int  iLimit;
        int  iDepth;
		int  iMinLevel;
        long ID_parent;


        __MPC_EXIT_IF_METHOD_FAILS(hr, GetNodeDepth( szCategory, iDepth ));


        //
        // Get the parent node
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateTaxonomyNode( ID_parent, szCategory, true ));

        //
        // Check if node is to be created as a child of a node of the same owner.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Seek_Node( ID_parent ));
        if(rs->m_ID_owner == m_updater.GetOwner())
        {
			fOwnerOfParent = true;
        }

        ////////////////////

		if(m_sku->m_inst.m_fServer)
		{
			//
			// Mininum level of insertion: 3 (2 for OEM)
			//
			// Top-level nodes: only one per OEM, nothing for NTCC.
			// Other nodes    : any number for OEM and NTCC owning the parent, 1 otherwise.
			//
			iMinLevel = m_updater.IsOEM() ? 2 : 3;

			switch(iDepth)
			{
			case 0:
			case 1:
				iLimit = 0;
				break;

			case 2:
				if(m_updater.IsOEM())
				{
					iLimit = 1;
				}
				else
				{
					iLimit = 0;
				}
				break;

			default:
				if(m_updater.IsOEM() || fOwnerOfParent)
				{
					iLimit = -1;
				}
				else
				{
					iLimit = 1;
				}
				break;
			}
		}

		if(m_sku->m_inst.m_fDesktop)
		{
			//
			// Mininum level of insertion: 4 (2 for OEM)
			//
			// Top-level nodes   : only one per OEM, nothing for NTCC.
			// Second-level nodes: 3 nodes per OEM, nothing for NTCC.
			// Other nodes       : any number for OEM and NTCC owning the parent, 1 otherwise.
			//
			iMinLevel = m_updater.IsOEM() ? 2 : 4;

			switch(iDepth)
			{
			case 0:
			case 1:
				iLimit = 0;
				break;

			case 2:
				if(m_updater.IsOEM())
				{
					iLimit = 1;
				}
				else
				{
					iLimit = 0;
				}
				break;

			case 3:
				if(m_updater.IsOEM())
				{
					iLimit = 3;
				}
				else
				{
					iLimit = 0;
				}
				break;

			default:
				if(m_updater.IsOEM() || fOwnerOfParent)
				{
					iLimit = -1;
				}
				else
				{
					iLimit = 1;
				}
				break;
			}
		}

		if(iDepth < iMinLevel)
		{
			LPCWSTR szSuffix;

			switch(iMinLevel)
			{
			case 1 : szSuffix = L"st"; break;
			case 2 : szSuffix = L"nd"; break;
			case 3 : szSuffix = L"rd"; break;
			default: szSuffix = L"th"; break;
			}

			__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hrDenied,
												   L"ERROR: Nodes can only be created starting from the %d%s level down for %s SKUs",
												   iMinLevel, szSuffix, m_sku->m_inst.m_fServer ? L"SERVER" : L"DESKTOP" ));
		}

		if(iLimit > 0)
		{
			//
			// Count number of nodes at the same level.
			//
			__MPC_EXIT_IF_METHOD_FAILS(hr, rs->Seek_Children( ID_parent, &fFound ));
			while(fFound)
			{
				if(rs->m_ID_owner == m_updater.GetOwner())
				{
					iCount++;
				}

				__MPC_EXIT_IF_METHOD_FAILS(hr, rs->Move( 0, JET_MoveNext, &fFound ));
			}

			if(iCount >= iLimit)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hrDenied, L"ERROR: allowed number of nodes (%d) to be created exceeded", iLimit ));
			}
		}

		if(iLimit == 0)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hrDenied, L"ERROR: the current Vendor privileges don't allow the creation of such a node" ));
		}

        fCanCreate = true;
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::CheckTopic( /*[in]*/ long    ID_node    ,
                                      /*[in]*/ LPCWSTR szURI      ,
                                      /*[in]*/ LPCWSTR szCategory )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::CheckTopic" );

    HRESULT                hr;
    Taxonomy::RS_Taxonomy* rsTaxonomy;
	Taxonomy::RS_Topics*   rsTopics;


    //
    // Check if URI is empty
    //
    if(!STRINGISPRESENT(szURI))
    {
        //
        // BUGBUG: Production tool doesn't check for this and the currently checked-in HHTs break...
        //
        if(m_fCreationMode == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"ERROR: URI cannot be empty" ));
        }
    }

    //
    // Check if it is Microsoft or OEM
    //
    if(IsMicrosoft() || m_updater.IsOEM())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


	if(m_sku)
	{
		//
		// Check if parent node owner is same
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTaxonomy( &rsTaxonomy ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, rsTaxonomy->Seek_Node( ID_node ));
		if(rsTaxonomy->m_ID_owner != m_updater.GetOwner())
		{
			bool fFound;
			int  iDepth;
			int  iCount = 0;

			//
			// If not the same owner, then we have to check if another topic exists with the same owner
			//
			__MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetTopics( &rsTopics ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, rsTopics->Seek_TopicsUnderNode( ID_node, &fFound ));
			while(fFound && rsTopics->m_ID_node == ID_node)
			{
				//
				// If the topic owner is the same, see if it is an update
				// If it is not, then we cannot add anymore since each CC can only have one topic in each node
				//
				if(rsTopics->m_ID_owner == m_updater.GetOwner())
				{
					//
					// Count if it is not an update
					//
					if(MPC::StrICmp( rsTopics->m_strURI, szURI ) != 0)
					{
						iCount++;
					}
				}

				__MPC_EXIT_IF_METHOD_FAILS(hr, rsTopics->Move( 0, JET_MoveNext, &fFound ));
			}
			
			if(iCount > 0)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"ERROR: allowed number of topics to be created exceeded" ));
			}


			//
			// Check the depth/level of the node being inserted
			//
			__MPC_EXIT_IF_METHOD_FAILS(hr, GetNodeDepth( szCategory, iDepth ));

			if(m_sku->m_inst.m_fServer && iDepth <= 2)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"ERROR: Topics can only be added starting from the 2nd level down for SERVER SKUs" ));				
			}

			if(m_sku->m_inst.m_fDesktop && iDepth <= 3)
			{		
				__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"ERROR: Topics can only be added starting from the 3nd level down for DESKTOP SKUs" ));				
			}
		}
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);

}

////////////////////////////////////////////////////////////////////////////////

HRESULT HCUpdate::Engine::InsertNode( /*[in]*/ Action  idAction      ,
                                      /*[in]*/ LPCWSTR szCategory    ,
                                      /*[in]*/ LPCWSTR szEntry       ,
                                      /*[in]*/ LPCWSTR szTitle       ,
                                      /*[in]*/ LPCWSTR szDescription ,
                                      /*[in]*/ LPCWSTR szURI         ,
                                      /*[in]*/ LPCWSTR szIconURI     ,
                                      /*[in]*/ bool    fVisible      ,
                                      /*[in]*/ bool    fSubsite      ,
                                      /*[in]*/ long    lNavModel     ,
                                      /*[in]*/ long    lPos          )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::InsertNode" );

    HRESULT      hr;
    MPC::wstring strFullNode;
    bool         fExists;
    bool         fCanCreate;

    WriteLog( S_OK, L"Inserting Node '%s' into Category '%s'", szEntry, szCategory );


    //
    // Create full path for the new node.
    //
    if(szCategory && szCategory[0])
    {
        strFullNode  = szCategory;
        strFullNode += L"/";
    }
    strFullNode += szEntry;


    //
    // Check if can insert node
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CheckNode( strFullNode.c_str(), fExists, fCanCreate ));
    if(fCanCreate)
    {
        long ID_node;

        //
        // Get the parent node.
        //
        if(FAILED(hr = m_updater.LocateTaxonomyNode( ID_node, strFullNode.c_str(), true )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error cannot obtain parent title to insert node: %s", strFullNode.c_str() ));
        }

        //
        // Create node.
        //
        if(FAILED(hr = m_updater.CreateTaxonomyNode( ID_node, strFullNode.c_str(), szTitle, szDescription, szURI, szIconURI, fVisible, fSubsite, lNavModel, lPos )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error inserting Node: %s", strFullNode.c_str() ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::InsertTaxonomy( /*[in]*/ MPC::XmlUtil& oXMLUtil ,
                                          /*[in]*/ IXMLDOMNode*  poNode   )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::InsertTaxonomy" );

    HRESULT      hr;
    bool         fFound;
    WCHAR        rgURI    [MAX_PATH];
    WCHAR        rgIconURI[MAX_PATH];
    Action       idAction;
    MPC::wstring strAction;
    MPC::wstring strCategory;
    MPC::wstring strEntry;
    MPC::wstring strURI;
    MPC::wstring strIconURI;
    MPC::wstring strTitle;
    MPC::wstring strDescription;
    MPC::wstring strVisible;
    MPC::wstring strSubsite;
    MPC::wstring strNavModel;
    MPC::wstring strInsertMode;
    MPC::wstring strInsertLocation;
    long         lType     =  1;
    long         lPos      = -1;
    bool         fVisible  = true;
    bool         fSubsite  = false;
    long         lNavModel = QR_DEFAULT;
    long         ID_node   = -1;
    long         ID_topic  = -1;


    HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_ACTION                 , strAction        , fFound, poNode);
    HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_TAXONOMY_CATEGORY      , strCategory      , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_ENTRY         , strEntry         , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_URI           , strURI           , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_ICONURI       , strIconURI       , fFound, poNode);
    HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_TAXONOMY_TITLE         , strTitle         , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_DESCRIPTION   , strDescription   , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_TYPE          , lType            , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_VISIBLE       , strVisible       , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_SUBSITE       , strSubsite       , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_NAVMODEL      , strNavModel      , fFound, poNode);

    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_INSERTMODE    , strInsertMode    , fFound, poNode);
    HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_TAXONOMY_INSERTLOCATION, strInsertLocation, fFound, poNode);

    __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction  ( strAction  .c_str(), idAction              ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LookupBoolean ( strVisible .c_str(), fVisible , true       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LookupBoolean ( strSubsite .c_str(), fSubsite , false      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LookupNavModel( strNavModel.c_str(), lNavModel, QR_DEFAULT ));

    {
        int pos;

        //
        // Remove trailing slashes.
        //
        pos = strCategory.size() - 1;
        while(pos >= 0 && strCategory[pos] == '/')
        {
            strCategory.erase( pos--, 1 );
        }

        //
        // Remove double slashes.
        //
        pos = strCategory.size() - 1;
        while(pos > 0)
        {
            if(strCategory[pos] == '/' && strCategory[pos-1] == '/')
            {
                strCategory.erase( pos, 1 );
            }

            pos--;
        }
    }

    // <NODE NodeType="Group" Key="1"  Title="Help &amp; Information:"/>
    // <NODE NodeType="Group" Key="2"  Title="Common Questions:"/>
    // <NODE NodeType="Group" Key="3"  Title="Troubleshooting:"/>
    // <NODE NodeType="Group" Key="4"  Title="Technical Resources:"/>
    // <NODE NodeType="Group" Key="5"  Title="Tours &amp; Tutorials:"/>
    // <NODE NodeType="Group" Key="6"  Title="Help Files:"/>
    // <NODE NodeType="Group" Key="7"  Title="Fix a problem:"/>
    // <NODE NodeType="Group" Key="8"  Title="Pick a task:"/>
    // <NODE NodeType="Group" Key="9"  Title="Overviews, Articles, and Tutorials:"/>
    // <NODE NodeType="Group" Key="10" Title="References:"/>
    if(lType < 1 || lType > 10)
    {
        lType = 1;
    }

    //
    // Get the complete URLs for the link.
    //
    if(strURI.size())
    {
        AppendVendorDir( strURI.c_str(), m_pkg->m_strVendorID.c_str(), NULL, rgURI, MAXSTRLEN(rgURI) );
    }
    else
    {
        rgURI[0] = 0;
    }

    if(strIconURI.size())
    {
        AppendVendorDir( strIconURI.c_str(), m_pkg->m_strVendorID.c_str(), NULL, rgIconURI, MAXSTRLEN(rgIconURI) );
    }
    else
    {
        rgIconURI[0] = 0;
    }


    if(FAILED(m_updater.LocateTaxonomyNode( ID_node, strCategory.c_str(), /*fLookForFather*/false )))
    {
        if(idAction == ACTION_ADD)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"Error category '%s' does not exist", strCategory.c_str() ));
        }
        else
        {
            WriteLog( S_OK, L"Category not found. Skipping deletion..." );
        }
    }

    if(idAction == ACTION_ADD)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.MakeRoomForInsert( strCategory.c_str(), strInsertMode.c_str(), strInsertLocation.c_str(), lPos ));
    }


    //
    // Check if inserting nodes
    //
    if(strEntry.empty() == false)
    {
        if(idAction == ACTION_ADD)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, InsertNode( idAction               ,
                                                       strCategory   .c_str() ,
                                                       strEntry      .c_str() ,
                                                       strTitle      .c_str() ,
                                                       strDescription.c_str() ,
                                                       rgURI                  ,
                                                       rgIconURI              ,
                                                       fVisible               ,
                                                       fSubsite               ,
                                                       lNavModel              ,
                                                       lPos                   ));
        }
        else if(idAction == ACTION_DELETE)
        {
            MPC::wstring strFull( strCategory );

            if(strFull.size())
            {
                if(strEntry.size())
                {
                    strFull += L"/";
                    strFull += strEntry;
                }
            }
            else
            {
                strFull = strEntry;
            }

            WriteLog( S_OK, L"Deleting Node '%s' from Category '%s'", strEntry.c_str(), strCategory.c_str() );

            if(SUCCEEDED(m_updater.LocateTaxonomyNode( ID_node, strFull.c_str(), /*fLookForFather*/false )))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.DeleteTaxonomyNode( ID_node ));
            }
        }
    }
    else
    {
        WriteLog( S_OK, L"Processing Taxonomy entry : Category : %s, URI : %s, Title : %s, Desc : %s", strCategory.c_str(), rgURI, strTitle.c_str(), strDescription.c_str() );

        if(idAction == ACTION_ADD)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, CheckTopic(ID_node, rgURI, strCategory.c_str()));

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.CreateTopicEntry( ID_topic               ,
                                                                       ID_node                ,
                                                                       strTitle      .c_str() ,
                                                                       rgURI                  ,
                                                                       strDescription.c_str() ,
                                                                       rgIconURI              ,
                                                                       lType                  ,
                                                                       fVisible               ,
                                                                       lPos                   ));

            //
            // Retrieve all the keywords and insert them into table
            //
            {
                CComPtr<IXMLDOMNodeList> poKeywordNodeList;

                //
                // Get all the keyword tags
                //
                if(FAILED(hr = poNode->selectNodes( CComBSTR(PCH_XQL_TOPIC_KEYWORDS), &poKeywordNodeList)))
                {
                    PCH_MACRO_DEBUG( L"Error querying taxonomy nodes in HHT file" );
                }
                else if(poKeywordNodeList)
                {
                    CComPtr<IXMLDOMNode> poKeywordNode;

                    //
                    // Process all the nodes.
                    //
                    for(;SUCCEEDED(hr = poKeywordNodeList->nextNode( &poKeywordNode )) && poKeywordNode != NULL; poKeywordNode.Release())
                    {
                        MPC::wstring strKeyword;

						PCH_MACRO_CHECK_ABORT(hr);

                        //
                        // Get the value from the XML keyword tag.
                        //
                        if(FAILED(hr = oXMLUtil.GetValue( NULL, strKeyword, fFound, poKeywordNode )) || fFound == false)
                        {
                            PCH_MACRO_DEBUG( L"Error getting keyword value" );
                        }
                        else
                        {
							MPC::WStringList lst;
							MPC::WStringIter it;
                            MPC::wstring 	 strHHK;
                            bool         	 fHHK;
							long         	 lPriority;

                            //
                            // Get the optional attribute.
                            //
                            HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_KEYWORD_HHK, strHHK, fFound, poKeywordNode);
                            __MPC_EXIT_IF_METHOD_FAILS(hr, LookupBoolean( strHHK.c_str(), fHHK, true ));

							//
							// Non-trusted certificates aren't allowed to set the priority of a match.
							//
							if(IsMicrosoft() == false && m_updater.IsOEM() == false) lPriority = 0;

                            HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_KEYWORD_PRIORITY, lPriority, fFound, poKeywordNode);

							//
							// Look up for synonyms (Microsoft updates only use Microsoft synsets).
							//
							__MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateSynonyms( strKeyword.c_str(), lst, /*fMatchOwner*/IsMicrosoft() ));
							if(lst.size() == 0 || lPriority != 0)
							{
								if(FAILED(hr = m_updater.CreateMatch( strKeyword.c_str(), ID_topic, lPriority, fHHK )))
								{
									__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error updating keyword in database: %s", strKeyword.c_str() ));
								}
							}

							for(it=lst.begin(); it!=lst.end(); it++)
							{
								if(FAILED(hr = m_updater.CreateMatch( it->c_str(), ID_topic, 0, fHHK )))
								{
									__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error updating keyword in database: %s", strKeyword.c_str() ));
								}
							}
                        }
                    }
                }
            }
        }
        else if(idAction == ACTION_DELETE)
        {
            if(ID_node != -1 && SUCCEEDED(m_updater.LocateTopicEntry( ID_topic, ID_node, rgURI, /*fCheckOwner*/true )))
            {
                if(FAILED(hr = m_updater.DeleteTopicEntry( ID_topic )))
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error attempting to remove node: %s", rgURI ));
                }
            }
            else
            {
                WriteLog( S_OK, L"Topic not found. Nothing to delete..." );
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT HCUpdate::Engine::UpdateStopSign( /*[in]*/ Action idAction, /*[in]*/ const MPC::wstring& strContext, /*[in]*/ const MPC::wstring& strStopSign )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::UpdateStopSign" );

    HRESULT               hr;
    Taxonomy::Updater_Set id;

    //
    // Check if stop sign is only a single character
    //
    if(strStopSign.size () != 1 ||
       strContext .empty()       )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    id = (MPC::StrICmp( strContext, L"ENDOFWORD" ) == 0) ? Taxonomy::UPDATER_SET_STOPSIGNS_ATENDOFWORD : Taxonomy::UPDATER_SET_STOPSIGNS;


    switch(idAction)
    {
    case ACTION_ADD   : __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddWordToSet     ( id, strStopSign.c_str() )); break;
    case ACTION_DELETE: __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveWordFromSet( id, strStopSign.c_str() )); break;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::UpdateStopWord( /*[in]*/ Action idAction, /*[in]*/ const MPC::wstring& strStopWord )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::UpdateStopWord" );

    HRESULT hr;

    //
    // Check parameters
    //
    if(strStopWord.empty())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    switch(idAction)
    {
    case ACTION_ADD   : __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddWordToSet     ( Taxonomy::UPDATER_SET_STOPWORDS, strStopWord.c_str() )); break;
    case ACTION_DELETE: __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveWordFromSet( Taxonomy::UPDATER_SET_STOPWORDS, strStopWord.c_str() )); break;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::UpdateOperator( /*[in]*/ Action idAction, /*[in]*/ const MPC::wstring& strOperator, /*[in]*/ const MPC::wstring& strOperation )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::UpdateOperator" );

    HRESULT               hr;
    Taxonomy::Updater_Set id;

    //
    // Check parameters
    //
    if(strOperator .empty() ||
       strOperation.empty()  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    {
        LPCWSTR szOperation = strOperation.c_str();

        if(_wcsicmp( szOperation, L"AND" ) == 0)
        {
            id = Taxonomy::UPDATER_SET_OPERATOR_AND;
        }
        else if(_wcsicmp( szOperation, L"OR" ) == 0)
        {
            id = Taxonomy::UPDATER_SET_OPERATOR_OR;
        }
        else if(_wcsicmp( szOperation, L"NOT" ) == 0)
        {
            id = Taxonomy::UPDATER_SET_OPERATOR_NOT;
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }
    }


    switch(idAction)
    {
    case ACTION_ADD   : __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddWordToSet     ( id, strOperator.c_str() )); break;
    case ACTION_DELETE: __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveWordFromSet( id, strOperator.c_str() )); break;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
*
*  FUNCTION    :    ProcessHHTFile
*
*  DESCRIPTION :    Processes the HHT file in the following manner :
*                   1.  Extract the HHT information from XML data blob
*                   2.  Check to see what action to take
*                   3.  If adding a HHT entry :
*                       a.  Check to see if TopicURL is a URI
*                       b.  If URL, insert as is
*                       c.  if not URI append vendor's dir as prefix
*                       d.  Insert HHT entry into Topic table
*                       e.  Get the OID and insert all keywords into keyword table
*                   4.  If deleting a HHT entry :
*                       a.  Check if entry exists by getting OID
*                       b.  If exists, delete HHT entry using OID
*                       c.  Delete all corresponding keywords using OID
*
*  INPUTS      :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT HCUpdate::Engine::ProcessHHTFile( /*[in]*/ LPCWSTR       szHHTName ,
                                          /*[in]*/ MPC::XmlUtil& oXMLUtil  )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::ProcessHHTFile" );

    HRESULT hr;
    bool    fFound;


    WriteLog( S_OK, L"Processing HHT file: %s", szHHTName );

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Update SCOPE sections
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_SCOPES, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strID;
            MPC::wstring               strName;
            MPC::wstring               strCategory;
            long                       ID_scope;
            long                       ID_owner;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_ACTION        , strAction  , fFound, poNode );
                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_SCOPE_ID      , strID      , fFound, poNode );
                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_SCOPE_NAME    , strName    , fFound, poNode );
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_SCOPE_CATEGORY, strCategory, fFound, poNode );

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                WriteLog( S_OK, L"Processing Scope : %s : ID : %s, Category : %s", s_ActionText[idAction], strID.c_str(), strCategory.c_str() );


                //
                // Check if it is adding helpfiles
                //
                if(idAction == ACTION_ADD)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.CreateScope( ID_scope, strID.c_str(), strName.c_str(), strCategory.c_str() ));
                }
                else if(idAction == ACTION_DELETE)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateScope( ID_scope, ID_owner, strID.c_str() ));
                    if(ID_scope != -1)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveScope( ID_scope ));
                    }
                }

                m_fRecreateIndex = true;
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Update FTS files
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_FTS, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strCHMname;
            MPC::wstring               strCHQname;
            MPC::wstring               strScope;
            long                       ID_scope;
            long                       ID_owner;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_ACTION        , strAction , fFound, poNode );
                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_HELPFILE_CHM  , strCHMname, fFound, poNode );
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_HELPFILE_CHQ  , strCHQname, fFound, poNode );
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_HELPFILE_SCOPE, strScope  , fFound, poNode ); if(!fFound) strScope = PCH_STR_SCOPE_DEFAULT;

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                WriteLog( S_OK, L"Processing Full Text Search : %s : CHM : %s, CHQ : %s", s_ActionText[idAction], strCHMname.c_str(), strCHQname.c_str() );


                __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateScope( ID_scope, ID_owner, strScope.c_str() ));

                //
                // Check if it is adding helpfiles
                //
                if(idAction == ACTION_ADD)
                {
                    if(ID_scope == -1)
                    {
                        __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"Error scope '%s' does not exist", strScope.c_str() ));
                    }

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddFullTextSearchQuery( ID_scope, strCHMname.c_str(), strCHQname.c_str() ));
                }
                else if(idAction == ACTION_DELETE)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveFullTextSearchQuery( ID_scope, strCHMname.c_str() ));
                }

                m_fRecreateIndex = true;
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Update HHK files
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_INDEX, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strCHMname;
            MPC::wstring               strHHKname;
            MPC::wstring               strScope;
            long                       ID_scope;
            long                       ID_owner;


            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_ACTION        , strAction , fFound, poNode );
                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_HELPFILE_CHM  , strCHMname, fFound, poNode );
                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_HELPFILE_HHK  , strHHKname, fFound, poNode );
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_HELPFILE_SCOPE, strScope  , fFound, poNode ); if(!fFound) strScope = PCH_STR_SCOPE_DEFAULT;

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                WriteLog( S_OK, L"Processing Index : %s : CHM : %s, HHK : %s", s_ActionText[idAction], strCHMname.c_str(), strHHKname.c_str() );


                __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateScope( ID_scope, ID_owner, strScope.c_str() ));

                //
                // Check if it is adding helpfiles
                //
                if(idAction == ACTION_ADD)
                {
                    if(ID_scope == -1)
                    {
                        __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"Error scope '%s' does not exist", strScope.c_str() ));
                    }

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddIndexFile( ID_scope, strCHMname.c_str(), strHHKname.c_str() ));
                }
                else if(idAction == ACTION_DELETE)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveIndexFile( ID_scope, strCHMname.c_str(), strHHKname.c_str() ));
                }

                m_fRecreateIndex = true;
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Update files for the Help Image.
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_HELPIMAGE, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strCHMname;
            MPC::wstring               strCHQname;
            MPC::wstring               strOTHname;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_ACTION        , strAction , fFound, poNode );
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_HELPFILE_CHM  , strCHMname, fFound, poNode );
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_HELPFILE_CHQ  , strCHQname, fFound, poNode );
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_HELPFILE_OTHER, strOTHname, fFound, poNode );

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                WriteLog( S_OK, L"Processing HelpImage : %s : CHM : %s, CHQ : %s, OTHER : %s", s_ActionText[idAction], strCHMname.c_str(), strCHQname.c_str(), strOTHname.c_str() );

                //
                // Check if it is adding helpfiles
                //
                if(idAction == ACTION_ADD)
                {
                    if(strCHMname.size()) { __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddFile( strCHMname.c_str() )); }
                    if(strCHQname.size()) { __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddFile( strCHQname.c_str() )); }
                    if(strOTHname.size()) { __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.AddFile( strOTHname.c_str() )); }
                }
                else if(idAction == ACTION_DELETE)
                {
                    if(strCHMname.size()) { __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveFile( strCHMname.c_str() )); }
                    if(strCHQname.size()) { __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveFile( strCHQname.c_str() )); }
                    if(strOTHname.size()) { __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.RemoveFile( strOTHname.c_str() )); }
                }
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Update StopSigns
    //
    if(IsMicrosoft())
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_STOPSIGN, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strContext;
            MPC::wstring               strStopSign;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_ACTION           , strAction  , fFound, poNode );
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_STOPSIGN_CONTEXT , strContext , fFound, poNode );
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_STOPSIGN_STOPSIGN, strStopSign, fFound, poNode );

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                WriteLog( S_OK, L"Processing StopSign : %s : StopSign : %s, Context : %s", s_ActionText[idAction], strStopSign.c_str(), strContext.c_str() );

                __MPC_EXIT_IF_METHOD_FAILS(hr, UpdateStopSign( idAction, strContext, strStopSign ));
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Update StopWords
    //
    if(IsMicrosoft())
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_STOPWORD, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strStopSign;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_ACTION           , strAction  , fFound, poNode );
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_STOPWORD_STOPWORD, strStopSign, fFound, poNode );

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                WriteLog( S_OK, L"Processing StopWord : %s : StopWord : %s", s_ActionText[idAction], strStopSign.c_str() );

                __MPC_EXIT_IF_METHOD_FAILS(hr, UpdateStopWord( idAction, strStopSign ));
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Update Operator
    //
    if(IsMicrosoft())
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_OPERATOR, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strOperator;
            MPC::wstring               strOperation;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_ACTION            , strAction   , fFound, poNode);
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_OPERATOR_OPERATION, strOperation, fFound, poNode);
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_OPERATOR_OPERATOR , strOperator , fFound, poNode);

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                WriteLog( S_OK, L"Processing Operator : %s : Operator : %s, Operation : %s", s_ActionText[idAction], strOperator.c_str(), strOperation.c_str() );

                __MPC_EXIT_IF_METHOD_FAILS(hr, UpdateOperator( idAction, strOperator, strOperation ));
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Update SYNTABLE sections
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_SYNSET, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode>       poNode;
            Action                     idAction;
            MPC::wstring               strAction;
            MPC::wstring               strID;
			long                       ID_synset;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_ACTION   , strAction  , fFound, poNode );
                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_SYNSET_ID, strID      , fFound, poNode );

				if(strAction.size())
				{
					__MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));
				}
				else
				{
					idAction = ACTION_ADD;
				}

                WriteLog( S_OK, L"Processing SynSet : %s : ID : %s", s_ActionText[idAction], strID.c_str() );


                //
                // Check if it is adding helpfiles
                //
                if(idAction == ACTION_ADD)
                {
					if(FAILED(hr = m_updater.CreateSynSet( ID_synset, strID.c_str() )))
					{
						__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error updating synset in database: %s", strID.c_str() ));
					}

					{
						CComPtr<IXMLDOMNodeList> poSynonymNodeList;
		
						//
						// Get all the synonym tags
						//
						if(FAILED(hr = poNode->selectNodes( CComBSTR(PCH_XQL_SYNONYM), &poSynonymNodeList)))
						{
							PCH_MACRO_DEBUG( L"Error querying synset synonyms in HHT file" );
						}
						else if(poSynonymNodeList)
						{
							CComPtr<IXMLDOMNode> poSynonymNode;
		
							//
							// Process all the nodes.
							//
							for(;SUCCEEDED(hr = poSynonymNodeList->nextNode( &poSynonymNode )) && poSynonymNode != NULL; poSynonymNode.Release())
							{
								MPC::wstring strSynonym;
		
								PCH_MACRO_CHECK_ABORT(hr);

								//
								// Get the value from the XML synonym tag.
								//
								if(FAILED(hr = oXMLUtil.GetValue( NULL, strSynonym, fFound, poSynonymNode )) || fFound == false)
								{
									PCH_MACRO_DEBUG( L"Error getting synonym value" );
								}
								else
								{
									Action       idAction2;
									MPC::wstring strAction2;

									HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_ACTION, strAction2, fFound, poNode );
									if(fFound)
									{
										__MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction2.c_str(), idAction2 ));
									}
									else
									{
										idAction2 = ACTION_ADD;
									}
									
									if(idAction2 == ACTION_ADD)
									{
										hr = m_updater.CreateSynonym( ID_synset, strSynonym.c_str() );
									}
									else if(idAction == ACTION_DELETE)
									{
										hr = m_updater.DeleteSynonym( ID_synset, strSynonym.c_str() );
									}
									else
									{
										hr = S_OK;
									}

									if(FAILED(hr))
									{
										__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error updating synonym in database: %s", strSynonym.c_str() ));
									}
								}
							}
						}
					}
                }
                else if(idAction == ACTION_DELETE)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.DeleteSynSet( strID.c_str() ));
                }
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Insert Taxonomy entries.
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_TAXONOMY, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error querying taxonomy nodes in HHT file" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            CComPtr<IXMLDOMNode> poNode;


            //
            // Process all the nodes.
            //
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
                JetBlue::TransactionHandle transaction;

				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, InsertTaxonomy( oXMLUtil, poNode ));
                }
                HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
                m_fTaxonomyModified = true;
            }
        }
    }

    {
        JetBlue::TransactionHandle transaction;

        HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.FlushWordSets());
        }
        HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
    }

    ////////////////////////////////////////////////////////////////////////////////

    WriteLog( S_OK, L"Processed HHT file: %s", szHHTName );

    ////////////////////////////////////////////////////////////////////////////////

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        WriteLog( hr, L"Error processing HHT file: %s", szHHTName );
    }

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\hostingserver\dload.c ===
#include <windows.h>
#include <delayimp.h>

////////////////////////////////////////////////////////////////////////////////

static HRESULT WINAPI hook_HRESULT()
{
	return HRESULT_FROM_WIN32( ERROR_PROC_NOT_FOUND );
}

static VOID* WINAPI hook_NULL()
{
	SetLastError( ERROR_PROC_NOT_FOUND );

	return NULL;
}

////////////////////////////////////////////////////////////////////////////////

FARPROC WINAPI HELPHOST_DelayLoadFailureHook( UINT unReason, PDelayLoadInfo pDelayInfo )
{
	if(!lstrcmpiA( pDelayInfo->szDll, "shell32.dll" ))
	{
		return (FARPROC)hook_HRESULT;
	}

	// WININET.dll
	// URLMON.dll

	return (FARPROC)hook_NULL; // Also covers hook_ZERO and hook_FALSE.
}

// we assume DELAYLOAD_VERSION >= 0x0200
PfnDliHook __pfnDliFailureHook2 = HELPHOST_DelayLoadFailureHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\hcupdate\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    Include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently

Revision History:
    Ghim-Sim Chua       (gschua)   07/07/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__9C155541_7DB5_11D3_A14F_00C04F45E825__INCLUDED_)
#define AFX_STDAFX_H__9C155541_7DB5_11D3_A14F_00C04F45E825__INCLUDED_

#include <module.h>

#include <windows.h>
#include <winbase.h>

#include <conio.h>
#include <fstream.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

// Trace Stuff
#include <HCP_trace.h>
#include <MPC_main.h>
#include <MPC_utils.h> // Several utility things, also includes Mpc_common.
#include <MPC_xml.h>
#include <MPC_com.h>
#include <MPC_streams.h>

#include <SvcResource.h>

#include <locres.h>
#include <HCAppRes.h>
#include <ProjectConstants.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <MergedHHK.h>
#include <ContentStoreMgr.h>

#include <SAFLib.h>

#include <NewsLib.h>

#include <seconfig.h>
#include <SearchEngineLib.h>

#include <Service.h>
#include <Utility.h>
#include <SvcUtils.h>

#include <PCHUpdate.h>

////////////////////////////////////////////////////////////////////////////////

//
// Define macros
//

#define PCH_MACRO_CHECK_STRINGW(hr, szString, uErrorMsg)                                           \
    if(szString == NULL || wcslen(szString) == 0)                                                  \
    {                                                                                              \
        HCUpdate::Engine::WriteLog( hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), uErrorMsg ); \
        __MPC_FUNC_LEAVE;                                                                          \
    }

#define PCH_MACRO_CHECK_STRINGA(hr, szString, uErrorMsg)                                           \
    if(szString == NULL || strlen(szString) == 0)                                                  \
    {                                                                                              \
        HCUpdate::Engine::WriteLog( hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), uErrorMsg ); \
        __MPC_FUNC_LEAVE;                                                                          \
    }

#define PCH_MACRO_CHECK_STRING(hr, szString, uErrorMsg)                                            \
    if(szString.size() == 0)                                                                       \
    {                                                                                              \
        HCUpdate::Engine::WriteLog( hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), uErrorMsg ); \
        __MPC_FUNC_LEAVE;                                                                          \
    }

#if DEBUG
#define PCH_MACRO_DEBUG( str ) WriteLog( S_OK, str )
#define PCH_MACRO_DEBUG2( str, arg ) WriteLog( S_OK, str, arg )
#else
#define PCH_MACRO_DEBUG( str )
#define PCH_MACRO_DEBUG2( str, arg )
#endif

#define PCH_MACRO_CHECK_ABORT(hr) if(IsAborted()) __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT)

////////////////////////////////////////////////////////////////////////////////

#define     PCH_SAFETYMARGIN                 (20*1024*1024)

#define     PCH_STR_TRUE                     L"true"
#define     PCH_STR_FALSE                    L"false"

#define     PCH_MSFT_DN                      HC_MICROSOFT_DN

#define     PCH_STR_VENDOR_PATH              HC_ROOT_HELPSVC_VENDORS
#define     PCH_STR_SYS_PATH                 HC_ROOT_HELPSVC_SYSTEM
#define     PCH_STR_VENDOR_URL               L"hcp://%s/%s"

#define     PCH_STR_SCOPE_DEFAULT            L"<SYSTEM>"

////////////////////////////////////////////////////////////////////////////////

#define     PCH_TAG_ACTION                   L"ACTION"
#define     PCH_TAG_FILE                     L"FILE"
#define     PCH_TAG_SOURCE                   L"SOURCE"
#define     PCH_TAG_URI                      L"URI"
#define     PCH_TAG_SYS                      L"SYS"
#define     PCH_TAG_SYSHELP                  L"SYSHELP"

#define     PCH_XQL_SAF                      L"./CONFIG/SAF"
#define     PCH_XQL_INSTALLFILE              L"./INSTALL_CONTENT/FILE"
#define     PCH_XQL_TRUSTED                  L"./TRUSTED_CONTENT/TRUSTED"
#define     PCH_XQL_HHT                      L"./METADATA/HHT"

#define     PCH_XQL_SE                       L"./SEARCHENGINES/WRAPPER"
#define     PCH_TAG_SE_ID                    L"ID"
#define     PCH_TAG_SE_CLSID                 L"CLSID"
#define     PCH_TAG_SE_DATA                  L"DATA"

////////////////////////////////////////////////////////////////////////////////

#define     PCH_XQL_OEM                      L"./NODEOWNERS/OWNER"
#define     PCH_TAG_OEM_DN                   L"DN"

#define     PCH_XQL_SCOPES                   L"./SCOPE_DEFINITION/SCOPE"
#define     PCH_TAG_SCOPE_ID                 L"ID"
#define     PCH_TAG_SCOPE_NAME               L"DISPLAYNAME"
#define     PCH_TAG_SCOPE_CATEGORY           L"CATEGORY"

#define     PCH_XQL_FTS                      L"./FTS/HELPFILE"
#define     PCH_XQL_INDEX                    L"./INDEX/HELPFILE"
#define     PCH_XQL_HELPIMAGE                L"./HELPIMAGE/HELPFILE"
#define     PCH_TAG_HELPFILE_CHM             L"CHM"
#define     PCH_TAG_HELPFILE_CHQ             L"CHQ"
#define     PCH_TAG_HELPFILE_HHK             L"HHK"
#define     PCH_TAG_HELPFILE_SCOPE           L"SCOPE"
#define     PCH_TAG_HELPFILE_OTHER           L"OTHER"

#define     PCH_XQL_STOPSIGN                 L"./STOPSIGN_ENTRIES/STOPSIGN"
#define     PCH_TAG_STOPSIGN_CONTEXT         L"CONTEXT"
#define     PCH_TAG_STOPSIGN_STOPSIGN        L"STOPSIGN"

#define     PCH_XQL_STOPWORD                 L"./STOPWORD_ENTRIES/STOPWORD"
#define     PCH_TAG_STOPWORD_STOPWORD        L"STOPWORD"

#define     PCH_XQL_OPERATOR                 L"./OPERATOR_ENTRIES/OPERATOR"
#define     PCH_TAG_OPERATOR_OPERATION       L"OPERATION"
#define     PCH_TAG_OPERATOR_OPERATOR        L"OPERATOR"

#define     PCH_XQL_SYNSET                   L"./SYNTABLE/SYNSET"
#define     PCH_TAG_SYNSET_ID                L"ID"
#define     PCH_XQL_SYNONYM                  L"./SYNONYM"

#define     PCH_XQL_TAXONOMY                 L"./TAXONOMY_ENTRIES/TAXONOMY_ENTRY"
#define     PCH_TAG_TAXONOMY_CATEGORY        L"CATEGORY"
#define     PCH_TAG_TAXONOMY_ENTRY           L"ENTRY"
#define     PCH_TAG_TAXONOMY_URI             L"URI"
#define     PCH_TAG_TAXONOMY_ICONURI         L"ICONURI"
#define     PCH_TAG_TAXONOMY_TITLE           L"TITLE"
#define     PCH_TAG_TAXONOMY_DESCRIPTION     L"DESCRIPTION"
#define     PCH_TAG_TAXONOMY_TYPE            L"TYPE"
#define     PCH_TAG_TAXONOMY_VISIBLE         L"VISIBLE"
#define     PCH_TAG_TAXONOMY_SUBSITE         L"SUBSITE"
#define     PCH_TAG_TAXONOMY_NAVMODEL        L"NAVIGATIONMODEL"
#define     PCH_TAG_TAXONOMY_INSERTMODE      L"INSERTMODE"
#define     PCH_TAG_TAXONOMY_INSERTLOCATION  L"INSERTLOCATION"

#define     PCH_XQL_TOPIC_KEYWORDS           L"./KEYWORD"
#define     PCH_TAG_KEYWORD_PRIORITY         L"PRIORITY"
#define     PCH_TAG_KEYWORD_HHK              L"HHK"

////////////////////////////////////////////////////////////////////////////////

#define     PCH_XQL_NEWSROOT		         L"./UPDATEHEADLINES/HEADLINE"

#define     PCH_TAG_NEWS_ICON			     L"ICON"
#define     PCH_TAG_NEWS_TITLE				 L"TITLE"
#define     PCH_TAG_NEWS_LINK				 L"LINK"
#define     PCH_TAG_NEWS_DESCRIPTION		 L"DESCRIPTION"
#define     PCH_TAG_NEWS_TIMEOUT			 L"TIMEOUT"
#define     PCH_TAG_NEWS_EXPIRYDATE			 L"EXPIRYDATE"

////////////////////////////////////////////////////////////////////////////////

#define HCUPDATE_GETATTRIBUTE(hr,xml,name,var,fFound,node)                                \
    if(FAILED(hr = xml.GetAttribute( NULL, name, var, fFound, node )) || fFound == false) \
    {                                                                                     \
        if(fFound == false) hr = E_INVALIDARG;                                            \
        WriteLog( hr, L"Error getting attribute '%s'", name ); __MPC_FUNC_LEAVE;          \
    }

#define HCUPDATE_GETATTRIBUTE_OPT(hr,xml,name,var,fFound,node)         \
    if(FAILED(hr = xml.GetAttribute( NULL, name, var, fFound, node ))) \
    {                                                                  \
        PCH_MACRO_DEBUG2( L"Error getting attribute '%s'", name );     \
    }

#define HCUPDATE_BEGIN_TRANSACTION(hr,trans)                             \
	if(FAILED(hr = trans.Begin( m_sess )))                               \
    {                                                                    \
        WriteLog(hr, L"Error beginning transaction" ); __MPC_FUNC_LEAVE; \
    }

#define HCUPDATE_COMMIT_TRANSACTION(hr,trans)                             \
	if(FAILED(hr = trans.Commit()))                                       \
    {                                                                     \
        WriteLog(hr, L"Error committing transaction" ); __MPC_FUNC_LEAVE; \
    }

////////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9C155541_7DB5_11D3_A14F_00C04F45E825__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\hcupdate\pkgdesc.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pkgdesc.cpp

Abstract:
    Functions related to package description file processing

Revision History:

    Ghim-Sim Chua       (gschua)   07/07/99
        - created

********************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

const LPCWSTR HCUpdate::Engine::s_ActionText[] = { L"ADD", L"DELETE" };

////////////////////////////////////////////////////////////////////////////////

long HCUpdate::Engine::CountNodes( /*[in]*/ IXMLDOMNodeList* poNodeList )
{
    long lCount = 0;

    if(poNodeList)
    {
        (void)poNodeList->get_length( &lCount );
    }

    return lCount;
}

////////////////////////////////////////////////////////////////////////////////

void HCUpdate::Engine::DeleteTempFile( /*[in/out]*/ MPC::wstring& szFile )
{
    if(FAILED(MPC::RemoveTemporaryFile( szFile )))
    {
        WriteLog( HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE), L"Error cannot delete temporary file" );
    }
}

HRESULT HCUpdate::Engine::PrepareTempFile( /*[in/out]*/ MPC::wstring& szFile )
{
    DeleteTempFile( szFile );

    return MPC::GetTemporaryFileName( szFile );
}

HRESULT HCUpdate::Engine::LookupAction( /*[in] */ LPCWSTR szAction ,
                                        /*[out]*/ Action& id       )
{
    if(szAction)
    {
        if(_wcsicmp( szAction, L"ADD" ) == 0)
        {
            id = ACTION_ADD; return S_OK;
        }

        if(_wcsicmp( szAction, L"DEL" ) == 0)
        {
            id = ACTION_DELETE; return S_OK;
        }
    }

    return WriteLog( HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION), L"Error Unknown action used to install trusted content" );
}

HRESULT HCUpdate::Engine::LookupBoolean( /*[in] */ LPCWSTR szString ,
                                         /*[out]*/ bool&   fVal     ,
                                         /*[in] */ bool    fDefault )
{
    if(szString[0] == 0)
    {
        fVal = fDefault; return S_OK;
    }

    if(_wcsicmp( szString, L"TRUE" ) == 0 ||
       _wcsicmp( szString, L"1"    ) == 0 ||
       _wcsicmp( szString, L"ON"   ) == 0  )
    {
        fVal = true; return S_OK;
    }

    if(_wcsicmp( szString, L"FALSE" ) == 0 ||
       _wcsicmp( szString, L"0"     ) == 0 ||
       _wcsicmp( szString, L"OFF"   ) == 0  )
    {
        fVal = false; return S_OK;
    }


    fVal = false; return S_OK;
}

HRESULT HCUpdate::Engine::LookupNavModel( /*[in] */ LPCWSTR szString ,
                                          /*[out]*/ long&   lVal     ,
                                          /*[in] */ long    lDefault )
{
    if(_wcsicmp( szString, L"DEFAULT" ) == 0) { lVal = QR_DEFAULT; return S_OK; }
    if(_wcsicmp( szString, L"DESKTOP" ) == 0) { lVal = QR_DESKTOP; return S_OK; }
    if(_wcsicmp( szString, L"SERVER"  ) == 0) { lVal = QR_SERVER ; return S_OK; }

    lVal = lDefault; return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
*
*  FUNCTION    :    AppendVendorDir
*
*  DESCRIPTION :    Checks to see if it is a URL, if not, appends the correct path in front
*
*  INPUTS      :
*
*  RETURNS     :
*
*  COMMENTS    :    Rules :
*                   1. Apply environment variable (%env%) changes to URI string
*                   2. Check if it has a '://' substring, if so it is a URL, do nothing and return
*                   3. Check if there is a ':\' or ':/' substring, if so it has a fixed path, do nothing and return
*                   4. Assume it is a relative path, prefix with vendor directory and return
*
*****************************************************************************/
HRESULT HCUpdate::Engine::AppendVendorDir( /*[in] */ LPCWSTR szURL     ,
                                           /*[in] */ LPCWSTR szOwnerID ,
                                           /*[in] */ LPCWSTR szWinDir  ,
                                           /*[out]*/ LPWSTR  szDest    ,
                                           /*[in] */ int     iMaxLen   )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::AppendVendorDir" );

    HRESULT hr;
    LPWSTR  rgTemp  = NULL;
    LPWSTR  rgTemp2 = NULL;

    __MPC_EXIT_IF_ALLOC_FAILS(hr, rgTemp, new WCHAR[iMaxLen]);
    wcsncpy( rgTemp, szURL, iMaxLen );


    //
    // Check for :/ or :\ substring. If so, ignore.
    //
    if(_wcsnicmp( rgTemp, L"app:", 4 ) == 0 ||
       wcsstr   ( rgTemp, L":/"      )      ||
       wcsstr   ( rgTemp, L":\\"     )       )
    {
        wcscpy( szDest, rgTemp ); // Just copy straight since it is either a URL or fixed path.
    }
    else // Assume relative path.
    {
        int i = 0;

        //
        // Skip the initial slashes.
        //
        while(rgTemp[i] == '\\' ||
              rgTemp[i] == '/'   )
        {
            i++;
        }

        //
        // If 'szWinDir' is not null, then a straight file path is required, otherwise a URL is required.
        //
        if(szWinDir)
        {
            MPC::wstring strRoot;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.BaseDir( strRoot )); strRoot.append( HC_HELPSET_SUB_VENDORS );

            _snwprintf( szDest, iMaxLen-1, L"%s\\%s\\%s", strRoot.c_str(), szOwnerID, &rgTemp[i] ); szDest[iMaxLen-1] = 0;

            //
            // Replace all / with \ character.
            //
            while(szDest[0])
            {
                if(szDest[0] == '/')
                {
                    szDest[0] = '\\';
                }
                szDest++;
            }
        }
        else
        {
            const int iSizeMax = INTERNET_MAX_PATH_LENGTH;
            DWORD dwSize       = iMaxLen-1;

            __MPC_EXIT_IF_ALLOC_FAILS(hr, rgTemp2, new WCHAR[iSizeMax]);

            _snwprintf( rgTemp2, iSizeMax-1, PCH_STR_VENDOR_URL, szOwnerID, &rgTemp[i] ); rgTemp2[iSizeMax-1] = 0;

            ::InternetCanonicalizeUrlW( rgTemp2, szDest, &dwSize, ICU_ENCODE_SPACES_ONLY );

            //
            // Replace all \ with / character.
            //
            while(szDest[0])
            {
                if(szDest[0] == _T('\\'))
                {
                    szDest[0] = _T('/');
                }
                szDest++;
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    delete [] rgTemp;
    delete [] rgTemp2;

    __HCP_FUNC_EXIT(hr);
}

/*****************************************************************************
*
*  FUNCTION    :    ProcessRegisterContent
*
*  DESCRIPTION :    Registers trusted content with the content store
*
*  INPUTS      :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT HCUpdate::Engine::ProcessRegisterContent( /*[in]*/ Action  idAction ,
                                                  /*[in]*/ LPCWSTR szURI    )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::ProcessRegisterContent" );

    HRESULT hr;
    HRESULT hr2;
    WCHAR   rgDestPath[MAX_PATH];
    bool    fCSLocked = false;


    PCH_MACRO_CHECK_STRINGW(hr, szURI, L"Error missing URI attribute");

    //
    // Get the complete URL for the link.
    //
    AppendVendorDir( szURI, m_pkg->m_strVendorID.c_str(), NULL, rgDestPath, MAXSTRLEN(rgDestPath) );

    WriteLog( S_OK, L"Registering trusted content : %s : %s", s_ActionText[idAction], rgDestPath );

    //
    // Initialize the content store for processing.
    //
    if(FAILED(hr = CPCHContentStore::s_GLOBAL->Acquire()))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error initializing the content store" ));
    }
    fCSLocked = true;

    if(idAction == ACTION_ADD)
    {
        if(FAILED(hr = CPCHContentStore::s_GLOBAL->Add( rgDestPath, m_pkg->m_strVendorID.c_str(), m_pkg->m_strVendorName.c_str() )))
        {
            if(hr == E_PCH_URI_EXISTS)
            {
                PCH_MACRO_DEBUG( L"Trusted content already registered" );
            }
            else
            {
                PCH_MACRO_DEBUG( L"Error Register trusted content failed" );
            }
        }
        else
        {
            PCH_MACRO_DEBUG( L"Trusted content registered" );
        }
    }
    else if(idAction == ACTION_DELETE)
    {
        if(FAILED(hr = CPCHContentStore::s_GLOBAL->Remove( rgDestPath, m_pkg->m_strVendorID.c_str(), m_pkg->m_strVendorName.c_str() )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error Remove trusted content failed" ));
        }

        PCH_MACRO_DEBUG( L"Trusted content removed" );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fCSLocked)
    {
        if(FAILED(hr2 = CPCHContentStore::s_GLOBAL->Release( true )))
        {
            WriteLog( hr2, L"Error committing into Content Store" );
        }
    }

    if(FAILED(hr))
    {
        WriteLog( hr, L"Error processing registered content" );
    }

    __HCP_FUNC_EXIT(hr);
}

/*****************************************************************************
*
*  FUNCTION    :    ProcessInstallFile
*
*  DESCRIPTION :    Extracts files to be installed and moves them to the vendor's
*                   private directory
*
*  INPUTS      :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT HCUpdate::Engine::ProcessInstallFile( /*[in]*/ Action  idAction      ,
                                              /*[in]*/ LPCWSTR szSource      ,
                                              /*[in]*/ LPCWSTR szDestination ,
                                              /*[in]*/ bool    fSys          ,
                                              /*[in]*/ bool    fSysHelp      )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::ProcessInstallFile" );

    HRESULT      hr;
    WCHAR        rgDestPath[MAX_PATH];
    MPC::wstring strRoot;


    if(m_updater.IsOEM() != true)
    {
        if(fSys     == true ||
           fSysHelp == true  )
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( S_OK, L"Ignoring install file : %s because certificate does not have enough priviliges to install into Sys or SysHelp locations.", szDestination ));
        }
    }

    WriteLog( S_OK, L"Installing file : %s : %s", s_ActionText[idAction], szDestination );

    PCH_MACRO_CHECK_STRINGW(hr, szDestination, L"Error missing URI attribute");

    // Check if system file modification.
    if(fSys || fSysHelp)
    {
        //
        // Destination/uri must be relative to system folder.
        // We don't allow a destination to contain ".."
        //
        if(wcsstr( szDestination, L".." ))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), L"Error install file has '..' in its path and is not allowed." ));
        }

        if(fSys)
        {
			//
			// Only Microsoft can actually write to the SYSTEM directory, OEMs write to the SYSTEM_OEM one.
			//
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.BaseDir( strRoot )); strRoot.append( IsMicrosoft() ? HC_HELPSET_SUB_SYSTEM : HC_HELPSET_SUB_SYSTEM_OEM );
        }

        if(fSysHelp)
        {
            if(FAILED(hr = AcquireDatabase()))
            {
                __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error finding database to update" ));
            }

            strRoot = m_updater.GetHelpLocation();

            ReleaseDatabase();
        }
    }

    //
    // Destination/uri must be relative
    // If destination contains the ":" or "\\" char, it must be fullpath.
    //
    if(wcsstr( szDestination, L":"    ) ||
       wcsstr( szDestination, L"\\\\" )  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), L"Error install file has fullpath, must be relative" ));
    }

    if(fSys || fSysHelp)
    {
        MPC::SubstituteEnvVariables( strRoot );

        //
        // If system folder.
        //
        _snwprintf( rgDestPath, MAXSTRLEN(rgDestPath), L"%s\\%s", strRoot.c_str(), szDestination ); rgDestPath[MAXSTRLEN(rgDestPath)] = 0;
    }
    else
    {
        //
        // If regular vendor folder.
        //
        AppendVendorDir( szDestination, m_pkg->m_strVendorID.c_str(), m_strWinDir.c_str(), rgDestPath, MAXSTRLEN(rgDestPath) );
    }


    // Adjust slashes.
    {
        LPWSTR szDest = rgDestPath;

        while(szDest[0])
        {
            if(szDest[0] == '/')
            {
                szDest[0] = '\\';
            }
            szDest++;
        }
    }

    // Change the mode to read/write so that file can be replaced.
    (void)::SetFileAttributesW( rgDestPath, FILE_ATTRIBUTE_NORMAL );

    if(idAction == ACTION_ADD)
    {
        // Source must not be empty.
        if(!STRINGISPRESENT( szSource ))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), L"Error - missing SOURCE attribute" ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FailOnLowDiskSpace( HC_ROOT, PCH_SAFETYMARGIN ));

        // Create the directory if it hasn't been created already
        if(FAILED(hr = MPC::MakeDir( rgDestPath )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error creating directory for %s", rgDestPath ));
        }

        // Extract the file and store it in the vendor's private storage area
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pkg->ExtractFile( m_log, rgDestPath, szSource ));
    }
    else
    {
        MPC::FileSystemObject fso( rgDestPath );

        if(fso.IsDirectory())
        {
            if(fSys || fSysHelp)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( S_OK, L"Ignoring directory delete command on '%s', it only works for Vendor's directories.", rgDestPath ));
            }
        }

        if(FAILED(fso.Delete( /*fForce*/true, /*fComplain*/true )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( -2, L"Error deleting installation file: %s", rgDestPath ));
        }
    }

    PCH_MACRO_DEBUG( L"Installed file" );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        WriteLog( hr, L"Error processing installation file" );
    }

    __HCP_FUNC_EXIT(hr);
}

/*****************************************************************************
*
*  FUNCTION    :    ProcessSAFFile
*
*  DESCRIPTION :    Hand the SAF file over to the SAF lib for registration or removal
*
*  INPUTS      :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT HCUpdate::Engine::ProcessSAFFile( /*[in]*/ Action        idAction  ,
                                          /*[in]*/ LPCWSTR       szSAFName ,
                                          /*[in]*/ MPC::XmlUtil& oXMLUtil  )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::ProcessSAFFile" );

    HRESULT           hr;
    CSAFChannelRecord cr;

    WriteLog( S_OK, L"Processing SAF file : %s : %s. OwnerName : %s, Owner ID : %s", s_ActionText[idAction], szSAFName,
              m_pkg->m_strVendorName.c_str(), m_pkg->m_strVendorID.c_str() );

    cr.m_ths            = m_ts;
    cr.m_bstrVendorID   = m_pkg->m_strVendorID  .c_str();
    cr.m_bstrVendorName = m_pkg->m_strVendorName.c_str();

    if(idAction == ACTION_ADD)
    {
        if(FAILED(hr = CSAFReg::s_GLOBAL->RegisterSupportChannel( cr, oXMLUtil )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error RegisterSupportChannel on SAF file failed" ));
        }

        WriteLog( S_OK, L"SAF file registered" );
    }
    else if(idAction == ACTION_DELETE)
    {
        if(FAILED(hr = CSAFReg::s_GLOBAL->RemoveSupportChannel( cr, oXMLUtil )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error RemoveSupportChannel on SAF file failed" ));
        }

        WriteLog( S_OK, L"SAF file removed" );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        WriteLog( hr, L"Error processing SAF file" );
    }

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
*
*  FUNCTION    :    ProcessPackage
*
*  DESCRIPTION :    Reads the help_description package and processes the various sections
*
*  INPUTS      :
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT HCUpdate::Engine::ProcessPackage( /*[in]*/ 	Taxonomy::InstalledInstance& sku ,
                                          /*[in]*/ 	Taxonomy::Package&           pkg )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::ProcessPackage" );

    HRESULT      hr;
    MPC::XmlUtil oXMLUtil;
	bool         fIsMachineHelp = (sku.m_inst.m_fSystem || sku.m_inst.m_fMUI);
    bool         fDB            = false;
    bool         fFound;


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Now let's validate that we have enough disk space on the drive
    //
    {
        ULARGE_INTEGER liFree;
        ULARGE_INTEGER liTotal;
        bool           fEnoughSpace = false;

        if(SUCCEEDED(MPC::GetDiskSpace( m_strWinDir, liFree, liTotal )))
        {
            fEnoughSpace = (liFree.QuadPart > (ULONGLONG)10e6);
        }

        if(fEnoughSpace == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( STG_E_MEDIUMFULL, L"Error insufficient disk space for update operation." ));
        }
    }

    //
    // We cannot process a generic package if a database is already in use!!
    //
    if(m_sess || m_db)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( E_FAIL, L"Recursive invocation of HCUpdate!" ));
    }

    m_ts  = sku.m_inst.m_ths;
    m_sku = &sku;
    m_pkg = &pkg;


	WriteLog( -1, L"\nProcessing package %s [%s] (Vendor: %s) from package store, %s/%d\n\n", pkg.m_strProductID.c_str() ,
			                                                                           		  pkg.m_strVersion  .c_str() ,
			                                                                           		  pkg.m_strVendorID .c_str() ,
			                                                                           		  m_ts.GetSKU()              ,
			                                                                           		  m_ts.GetLanguage()         );

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Check if it is OEM owner
    //
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, AcquireDatabase()); fDB = true;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateOwner( m_pkg->m_strVendorID.c_str() ));

        if(m_updater.GetOwner() == -1)
        {
            long idOwner;

            // Create the owner without OEM privs
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.CreateOwner( idOwner, m_pkg->m_strVendorID.c_str(), /*fIsOEM*/false ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateOwner(          m_pkg->m_strVendorID.c_str()                  ));
        }
    }

    if(m_updater.IsOEM())
    {
        WriteLog( S_OK, L"Update package has OEM credentials of %s", m_pkg->m_strVendorID.c_str() );
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pkg->ExtractPkgDesc( m_log, oXMLUtil ));

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Insert OEMs
    //
    if(m_updater.IsOEM())
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_OEM, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
			JetBlue::TransactionHandle transaction;
            CComPtr<IXMLDOMNode> 	   poNode;
            MPC::wstring         	   strDN;
            long                 	   ID_owner;

            //
            // Process all the nodes.
            //
            HCUPDATE_BEGIN_TRANSACTION(hr,transaction);
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_OEM_DN, strDN, fFound, poNode );

				PCH_MACRO_CHECK_ABORT(hr);

                if(strDN.size() > 0)
                {
                    WriteLog( S_OK, L"Registering '%s' as OEM", strDN.c_str() );

                    // insert it into the content owner's table, making it an OEM.
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.CreateOwner( ID_owner, strDN.c_str(), true ));
                }
            }
            HCUPDATE_COMMIT_TRANSACTION(hr,transaction);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Insert Search Engines
    //
    if(fIsMachineHelp && m_updater.IsOEM())
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_SE, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            CComPtr<IXMLDOMNode> poNode;
            CComPtr<IXMLDOMNode> poDataNode;
            Action               idAction;
            MPC::wstring         strAction;
            MPC::wstring         strCLSID;
            MPC::wstring         strID;
            CComBSTR             bstrData;
			SearchEngine::Config cfg;

            //
            // Process all the nodes.
            //
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_ACTION  , strAction, fFound, poNode );
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_SE_ID   , strID    , fFound, poNode );
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_SE_CLSID, strCLSID , fFound, poNode );

                //
                // Get the data element
                //
                if(FAILED(poNode->selectSingleNode( PCH_TAG_SE_DATA, &poDataNode )))
                {
                    PCH_MACRO_DEBUG2( L"Error getting data for search engine %s", strID.c_str());
                }
                if(FAILED(poDataNode->get_xml(&bstrData)))
                {
                    PCH_MACRO_DEBUG2( L"Error extracting xml data for search engine %s", strID.c_str());
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                //
                // Check if it is adding search engines
                //
                if(idAction == ACTION_ADD)
                {
                    WriteLog( S_OK, L"Adding Search Engine : Name : %s, CLSID : %s", strID.c_str(), strCLSID.c_str() );

                    // register the search engine
                    __MPC_EXIT_IF_METHOD_FAILS(hr, cfg.RegisterWrapper( m_ts, strID.c_str(), m_pkg->m_strVendorID.c_str(), strCLSID.c_str(), bstrData ));
                }
                else if(idAction == ACTION_DELETE)
                {
                    WriteLog( S_OK, L"Deleting Search Engine : Name : %s, CLSID : %s", strID.c_str(), strCLSID.c_str() );

                    // unregister the search engine
                    __MPC_EXIT_IF_METHOD_FAILS(hr, cfg.UnRegisterWrapper( m_ts, strID.c_str(), m_pkg->m_strVendorID.c_str() ));
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Search & process saf config files
    //
    if(fIsMachineHelp && m_updater.IsOEM())
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_SAF, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            CComPtr<IXMLDOMNode> poNode;
            Action               idAction;
            MPC::wstring         strAction;
            MPC::wstring         strFilename;


            //
            // Process all the nodes.
            //
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
                MPC::XmlUtil xmlSAF;

				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_ACTION, strAction  , fFound, poNode);
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_FILE  , strFilename, fFound, poNode);

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                // Extract the SAF file into the temp directory
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_pkg->ExtractXMLFile( m_log, xmlSAF, Taxonomy::Strings::s_tag_root_SAF, strFilename.c_str() ));

                // process the SAF file
                __MPC_EXIT_IF_METHOD_FAILS(hr, ProcessSAFFile( idAction, strFilename.c_str(), xmlSAF ));
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Search & install help content
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_INSTALLFILE, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            CComPtr<IXMLDOMNode> poNode;
            Action               idAction;
            MPC::wstring         strAction;
            MPC::wstring         strSource;
            MPC::wstring         strDest;
            MPC::wstring         strSys;
            MPC::wstring         strSysHelp;
            bool                 fSys;
            bool                 fSysHelp;

            //
            // Process all the nodes.
            //
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_ACTION , strAction , fFound, poNode);
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_SOURCE , strSource , fFound, poNode);
                HCUPDATE_GETATTRIBUTE    (hr, oXMLUtil, PCH_TAG_URI    , strDest   , fFound, poNode);
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_SYS    , strSys    , fFound, poNode);
                HCUPDATE_GETATTRIBUTE_OPT(hr, oXMLUtil, PCH_TAG_SYSHELP, strSysHelp, fFound, poNode);


                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction ( strAction .c_str(), idAction        ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupBoolean( strSys    .c_str(), fSys    , false ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupBoolean( strSysHelp.c_str(), fSysHelp, false ));

                //
                // If the package is not the machine SKU, you don't want to install contents other than System Help Files.
                //
                if(fIsMachineHelp == false)
                {
                    if(fSys     == true ) continue;
                    if(fSysHelp == false) continue;
                }

                // install the file
                __MPC_EXIT_IF_METHOD_FAILS(hr, ProcessInstallFile( idAction, strSource.c_str(), strDest.c_str(), fSys, fSysHelp ));
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Search & register trusted content
    //
    if(fIsMachineHelp && m_updater.IsOEM())
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_TRUSTED, &poNodeList )))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            CComPtr<IXMLDOMNode> poNode;
            Action               idAction;
            MPC::wstring         strAction;
            MPC::wstring         strURI;

            //
            // Process all the nodes.
            //
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
				PCH_MACRO_CHECK_ABORT(hr);

                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_ACTION, strAction, fFound, poNode);
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_URI   , strURI   , fFound, poNode);

                __MPC_EXIT_IF_METHOD_FAILS(hr, LookupAction( strAction.c_str(), idAction ));

                // register the content
                __MPC_EXIT_IF_METHOD_FAILS(hr, ProcessRegisterContent( idAction, strURI.c_str() ));
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Search & process hht files
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if(FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_HHT, &poNodeList)))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description xml" );
        }
        else if(CountNodes(poNodeList) > 0)
        {
            CComPtr<IXMLDOMNode> poNode;
            MPC::wstring         strFilename;

            //
            // Process all the nodes.
            //
            for(;SUCCEEDED(hr = poNodeList->nextNode( &poNode )) && poNode != NULL; poNode.Release())
            {
                MPC::XmlUtil xmlHHT;

				PCH_MACRO_CHECK_ABORT(hr);

                // get the filename
                HCUPDATE_GETATTRIBUTE(hr, oXMLUtil, PCH_TAG_FILE, strFilename, fFound, poNode);

                // Extract the HHT file into the temp directory
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_pkg->ExtractXMLFile( m_log, xmlHHT, Taxonomy::Strings::s_tag_root_HHT, strFilename.c_str() ));

                // process the HHT file
                __MPC_EXIT_IF_METHOD_FAILS(hr, ProcessHHTFile( strFilename.c_str(), xmlHHT ));
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Search and add News content
    //
    {
        CComPtr<IXMLDOMNodeList> poNodeList;

        if (FAILED(hr = oXMLUtil.GetNodes( PCH_XQL_NEWSROOT, &poNodeList)))
        {
            PCH_MACRO_DEBUG( L"Error processing package_description.xml" );
        }
        else 
        {
	        if(CountNodes(poNodeList) > 0)
	        {
	            CComPtr<IXMLDOMNode>  poNodeHeadline;
	            MPC::wstring          strCurrentSKU;
	            LPCWSTR               szCurrentSKU   = m_ts.GetSKU     ();
	            long                  lCurrentLCID   = m_ts.GetLanguage();
	            News::UpdateHeadlines uhUpdate;
	            MPC::wstring          strIcon;
	            MPC::wstring          strTitle;
	            MPC::wstring          strLink;
	            MPC::wstring          strDescription;
	            MPC::wstring          strExpiryDate;
	            CComBSTR              strTimeOutDays;
	            int                   nTimeOutDays;
	            DATE                  dExpiryDate;
	            long                  lIndex;


	            // Strip off the number from the SKU
				{
					LPCWSTR szEnd = wcschr( szCurrentSKU, '_' );
					size_t  len   = szEnd ? szEnd - szCurrentSKU : wcslen( szCurrentSKU );

					strCurrentSKU.assign( szCurrentSKU, len );
				}

	            // Get all the news items and return them in the reverse order
	            __MPC_EXIT_IF_METHOD_FAILS(hr, poNodeList->get_length( &lIndex ));
	            for(--lIndex; lIndex >= 0; --lIndex)
	            {
	            	if(SUCCEEDED(hr = poNodeList->get_item( lIndex, &poNodeHeadline )) && poNodeHeadline != NULL)
	            	{        
						PCH_MACRO_CHECK_ABORT(hr);

					//// Quick fix for 357806 - ignore the ICON attribute
					////__MPC_EXIT_IF_METHOD_FAILS(hr, oXMLUtil.GetAttribute(NULL, PCH_TAG_NEWS_ICON       , strIcon       , fFound, poNodeHeadline));
		                __MPC_EXIT_IF_METHOD_FAILS(hr, oXMLUtil.GetAttribute(NULL, PCH_TAG_NEWS_TITLE      , strTitle      , fFound, poNodeHeadline));
		                __MPC_EXIT_IF_METHOD_FAILS(hr, oXMLUtil.GetAttribute(NULL, PCH_TAG_NEWS_LINK       , strLink	   , fFound, poNodeHeadline));
		                __MPC_EXIT_IF_METHOD_FAILS(hr, oXMLUtil.GetAttribute(NULL, PCH_TAG_NEWS_DESCRIPTION, strDescription, fFound, poNodeHeadline));
		                __MPC_EXIT_IF_METHOD_FAILS(hr, oXMLUtil.GetAttribute(NULL, PCH_TAG_NEWS_TIMEOUT	   , strTimeOutDays, fFound, poNodeHeadline));
		                __MPC_EXIT_IF_METHOD_FAILS(hr, oXMLUtil.GetAttribute(NULL, PCH_TAG_NEWS_EXPIRYDATE , strExpiryDate , fFound, poNodeHeadline));

		                // Make the necessary conversions
		                if(FAILED(hr = MPC::ConvertStringToDate( strExpiryDate, dExpiryDate, /*fGMT*/false, /*fCIM*/false, -1 )))
		                {
		                    dExpiryDate = 0;
		                }

		                if(strTimeOutDays.Length() > 0)
		                {
		                    nTimeOutDays = _wtoi(strTimeOutDays);
		                }
		                else
		                {
		                    nTimeOutDays = 0;
		                }

		                // Finally add the headlines - make sure that the title and link are not empty strings
		                if(strTitle.length() > 0 && strLink.length() > 0)
		                {
		                    __MPC_EXIT_IF_METHOD_FAILS(hr, uhUpdate.Add( lCurrentLCID, strCurrentSKU, strIcon, strTitle, strLink, strDescription, nTimeOutDays, dExpiryDate ));
		                }
		                else
		                {
		                	WriteLog(S_OK, L"Skipping headlines no. %d because attribute TITLE or attribute LINK was not found", lIndex + 1);
		                }

						poNodeHeadline.Release();             
					}
	            }
	            WriteLog(S_OK, L"Headlines were successfully processed");
	        }
	        else
	        {
	        	WriteLog(S_OK, L"No headlines items found");
	        }
	    }
	}

    hr = S_OK;

    ////////////////////////////////////////////////////////////////////////////////

    __HCP_FUNC_CLEANUP;

    if(fDB)
    {
        ReleaseDatabase();
    }

    ////////////////////

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::RecreateIndex( /*[in]*/ Taxonomy::InstalledInstance& sku, /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::RecreateIndex" );

    HRESULT hr;

    m_ts  = sku.m_inst.m_ths;
    m_sku = &sku;
    m_pkg = NULL;

	if(FAILED(hr = InternalCreateIndex( fForce ? VARIANT_TRUE : VARIANT_FALSE )))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error merging index" ));
	}

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\service\hcupdate\pchupdate.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCHUpdate.cpp

Abstract:
    This file contains the implementation of the HCUpdate::Engine class.

Revision History:
    Ghim-Sim Chua       (gschua)   12/20/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

static const DWORD c_AllowedUsers = MPC::IDENTITY_SYSTEM    |
                                    MPC::IDENTITY_ADMIN     |
                                    MPC::IDENTITY_ADMINS    |
                                    MPC::IDENTITY_POWERUSERS;

/////////////////////////////////////////////////////////////////////////////
// HCUpdate::Engine

HCUpdate::Engine::Engine()
{
                             // MPC::wstring                 m_strWinDir;
                             //
                             // Taxonomy::Updater            m_updater;
                             // Taxonomy::Settings           m_ts;
    m_sku           = NULL;  // Taxonomy::InstalledInstance* m_sku;
    m_pkg           = NULL;  // Taxonomy::Package*           m_pkg;
                             //
    m_fCreationMode = false; // bool                         m_fCreationMode;
    m_dwRefCount    = 0;     // DWORD                        m_dwRefCount;
                             // JetBlue::SessionHandle       m_handle;
    m_sess          = NULL;  // JetBlue::Session*            m_sess;
    m_db            = NULL;  // JetBlue::Database*           m_db;
}

HRESULT HCUpdate::Engine::FinalConstruct()
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::FinalConstruct" );

    HRESULT hr;

    //
    // get windows directory
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( m_strWinDir = L"%WINDIR%" ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void HCUpdate::Engine::FinalRelease()
{
    (void)m_updater.Close();

    m_handle.Release();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT HCUpdate::Engine::WriteLog( /*[in]*/ HRESULT hrRes       ,
                                    /*[in]*/ LPCWSTR szLogFormat ,
                                    /*[in]*/ ...                 )
{
    va_list arglist;

    va_start( arglist, szLogFormat );

    return WriteLogV( hrRes, szLogFormat, arglist );
}

////////////////////////////////////////////////////////////////////////////////

HRESULT HCUpdate::Engine::AcquireDatabase()
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::AcquireDatabase" );

    HRESULT hr;


    if(m_dwRefCount == 0)
    {
        if(m_db == NULL) m_fCreationMode = false;

        if(m_fCreationMode)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.Init( m_ts, m_db, /* Cache* */NULL )); // Don't use any cache for the database!!


            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.LocateOwner( m_pkg->m_strVendorID.c_str() ));
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.GetDatabase( m_handle, m_db, /*fReadOnly*/false ));
            m_sess = m_handle;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.Init( m_ts, m_db, /* Cache* */NULL )); // Don't use any cache for the database!!
        }
    }

    m_dwRefCount++;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        WriteLog( hr, L"Error finding database to update" );
    }

    __HCP_FUNC_EXIT(hr);
}

void HCUpdate::Engine::ReleaseDatabase()
{
    if(m_dwRefCount > 0)
    {
        if(--m_dwRefCount == 0)
        {
            (void)m_updater.Close();

            m_handle.Release();

            m_sess = NULL;
            m_db   = NULL;

			if(m_fCreationMode)
			{
				struct Dump
				{
					LPCWSTR                         szText;
					Taxonomy::Updater_Stat::Entity* ent;
				};

				Taxonomy::Updater_Stat& stat    = m_updater.Stat();
				Dump                    rgBuf[] =
				{
					{ L"ContentOwners ", &stat.m_entContentOwners  },
					{ L"SynSets       ", &stat.m_entSynSets        },
					{ L"HelpImage     ", &stat.m_entHelpImage      },
					{ L"IndexFiles    ", &stat.m_entIndexFiles     },
					{ L"FullTextSearch", &stat.m_entFullTextSearch },
					{ L"Scope         ", &stat.m_entScope          },
					{ L"Taxonomy      ", &stat.m_entTaxonomy       },
					{ L"Topics        ", &stat.m_entTopics         },
					{ L"Synonyms      ", &stat.m_entSynonyms       },
					{ L"Keywords      ", &stat.m_entKeywords       },
					{ L"Matches       ", &stat.m_entMatches        },
				};

				WriteLog( -1, L"\nStatistics:\n\n" );

				for(int i=0; i<ARRAYSIZE(rgBuf); i++)
				{
					Dump& d = rgBuf[i];

					WriteLog( -1, L"  %s : Created: %8d, Modified: %8d, Deleted: %8d", d.szText, d.ent->m_iCreated, d.ent->m_iModified, d.ent->m_iDeleted );
				}

				WriteLog( -1, L"\n\n" );
			}
        }
    }
}

////////////////////////////////////////////////////////////////////////////////

HRESULT HCUpdate::Engine::SetSkuInfo( /*[in]*/ LPCWSTR szSKU, /*[in]*/ long lLCID )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_ts.Initialize( szSKU, lLCID );
}

HRESULT HCUpdate::Engine::InternalCreateIndex( /*[in]*/ VARIANT_BOOL bForce )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::InternalCreateIndex" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    Taxonomy::RS_Scope*          rsScope;
    Taxonomy::RS_IndexFiles*     rsIndex;
    HHK::Writer*                 writer  = NULL;
    bool                         fDB     = false;
    long                         lTotal  = 0;
    long                         lDone   = 0;


    __MPC_EXIT_IF_METHOD_FAILS(hr, AcquireDatabase()); fDB = true;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetScope     ( &rsScope ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.GetIndexFiles( &rsIndex ));


    for(int pass=0; pass<2; pass++)
    {
        bool fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, rsScope->Move( 0, JET_MoveFirst, &fFound ));
        while(fFound)
        {
            MPC::wstring      strBase;
            MPC::wstring      strIndex;
            Taxonomy::WordSet setCHM;
            MPC::WStringList  lst;
            MPC::WStringIter  it;
            DATE              dIndex;
            bool              fCreate = (bForce == VARIANT_TRUE);
            bool              fFound2;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.HelpFilesDir( strBase                                                                            )); strBase += L"\\";
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.IndexFile   ( strIndex, MPC::StrICmp( rsScope->m_strID, L"<SYSTEM>" ) ? rsScope->m_ID_scope : -1 ));

            dIndex = MPC::GetLastModifiedDate( strIndex );

            __MPC_EXIT_IF_METHOD_FAILS(hr, rsIndex->Seek_ByScope( rsScope->m_ID_scope, &fFound2 ));
            while(fFound2)
            {
                MPC::wstring strURL;

                strURL  = L"ms-its:%HELP_LOCATION%\\";
                strURL += rsIndex->m_strStorage;
                strURL += L"::";
                strURL += rsIndex->m_strFile;

                setCHM.insert( rsIndex->m_strStorage );

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_updater.ExpandURL( strURL ));

                lst.push_back( strURL );


                if(!fCreate && bForce == VARIANT_FALSE)
                {
                    MPC::wstring strFile( strBase ); strFile += rsIndex->m_strStorage;;
                    DATE         dFile = MPC::GetLastModifiedDate( strFile );

                    if(dFile && dFile > dIndex) fCreate = true;
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, rsIndex->Move( 0, JET_MoveNext, &fFound2 ));
            }


            if(fCreate)
            {
                if(pass == 0)
                {
                    lTotal++;
                }
                else
                {
                    HHK::Merger merger;
					
					PCH_MACRO_CHECK_ABORT(hr);

                    __MPC_EXIT_IF_ALLOC_FAILS(hr, writer, new HHK::Writer);

					WriteLog( S_OK, L"Recreating index for scope '%s'", rsScope->m_strID.c_str() );

                    __MPC_EXIT_IF_METHOD_FAILS(hr, merger.PrepareMergedHhk( *writer, m_updater, setCHM, lst, strIndex.c_str() ));


                    while(merger.MoveNext())
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, writer->OutputSection( merger.GetSection() ));
                    }

                    delete writer; writer = NULL;

					WriteLog( S_OK, L"Successfully merged index" );

					lDone++;
                }
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, rsScope->Move( 0, JET_MoveNext, &fFound ));
        }

        if(pass == 0 && lTotal == 0) break; // Nothing to do.
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    delete writer;

    if(fDB)
    {
        ReleaseDatabase();
    }

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::InternalUpdatePkg( /*[in]*/ LPCWSTR szPathname   ,
                                             /*[in]*/ bool    fImpersonate )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::InternalUpdatePkg" );

    HRESULT                           hr;
    MPC::SmartLock<_ThreadModel>      lock( this );
    Taxonomy::InstalledInstanceStore* store = Taxonomy::InstalledInstanceStore::s_GLOBAL;
    Taxonomy::LockingHandle           handle;
    Taxonomy::InstanceIter            it;
    bool                              fFound;
    bool                              fLogStarted = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(store);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FailOnLowDiskSpace( HC_ROOT, PCH_SAFETYMARGIN ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, store->GrabControl( handle, &m_log ));


    if(STRINGISPRESENT(szPathname))
    {
        Taxonomy::PackageIter it;
        MPC::Impersonation    imp;

        if(fImpersonate)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize());
        }

        if(!fLogStarted)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, StartLog()); fLogStarted = true;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, store->Package_Add( szPathname, fImpersonate ? &imp : NULL, NULL, /*fInsertAtTop*/false, fFound, it ));
        if(fFound)
        {
            WriteLog( -1, L"Package has already been processed" );
        }
    }

    //
    // Only start log if there's something to process.
    //
    if(!fLogStarted)
    {
        bool fWorkToProcess;

        __MPC_EXIT_IF_METHOD_FAILS(hr, store->MakeReady( *this, /*fNoOp*/true, fWorkToProcess ));
        if(fWorkToProcess)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, StartLog()); fLogStarted = true;
        }
    }

    if(fLogStarted)
    {
        bool fWorkToProcess;

        __MPC_EXIT_IF_METHOD_FAILS(hr, store->MakeReady( *this, /*fNoOp*/false, fWorkToProcess ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fLogStarted) EndLog();

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::InternalRemovePkg( /*[in]*/ LPCWSTR            szPathname   ,
                                             /*[in]*/ Taxonomy::Package* pkg          ,
                                             /*[in]*/ bool               fImpersonate )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::InternalRemovePkg" );

    HRESULT                           hr;
    MPC::SmartLock<_ThreadModel>      lock( this );
    Taxonomy::InstalledInstanceStore* store = Taxonomy::InstalledInstanceStore::s_GLOBAL;
    Taxonomy::LockingHandle           handle;
    Taxonomy::Package                 pkgTmp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(store);
        if(!pkg) __MPC_PARAMCHECK_STRING_NOT_EMPTY(szPathname);
    __MPC_PARAMCHECK_END();


    //
    // start log file
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, StartLog());

    __MPC_EXIT_IF_METHOD_FAILS(hr, store->GrabControl( handle, &m_log ));

    if(!pkg)
    {
        MPC::Impersonation imp;

        if(fImpersonate)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize());
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, pkgTmp.Import      ( m_log, szPathname, -2, fImpersonate ? &imp : NULL ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pkgTmp.Authenticate( m_log                                             ));

        pkg = &pkgTmp;
    }

    {
        Taxonomy::PackageIter it;
        bool                  fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, store->Package_Find( *pkg, fFound, it ));
        if(fFound)
        {
            bool fWorkToProcess;

            __MPC_EXIT_IF_METHOD_FAILS(hr, store->Package_Remove( it ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, store->MakeReady( *this, /*fNoOp*/false, fWorkToProcess ));
        }
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    //
    // end the log
    //
    EndLog();

    __HCP_FUNC_EXIT(hr);
}

HRESULT HCUpdate::Engine::ForceSystemRestore()
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::ForceSystemRestore" );

    HRESULT                           	 hr;
    MPC::SmartLock<_ThreadModel>      	 lock( this );
    Taxonomy::InstalledInstanceStore* 	 store = Taxonomy::InstalledInstanceStore::s_GLOBAL;
    Taxonomy::LockingHandle           	 handle;
	Taxonomy::InstalledInstanceIterConst itBegin;
	Taxonomy::InstalledInstanceIterConst itEnd;
	bool                              	 fWorkToProcess;


    //
    // start log file
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, StartLog());

    __MPC_EXIT_IF_METHOD_FAILS(hr, store->GrabControl( handle, &m_log ));

	//
	// Invalidate all SKUs.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, store->SKU_GetList( itBegin, itEnd ));
	for(; itBegin != itEnd; itBegin++)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, store->State_InvalidateSKU( itBegin->m_inst.m_ths, /*fAlsoDatabase*/true ));
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, store->MakeReady( *this, /*fNoOp*/false, fWorkToProcess ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    //
    // end the log
    //
    EndLog();

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT HCUpdate::Engine::PopulateDatabase( /*[in]*/ LPCWSTR            szCabinet ,
                                            /*[in]*/ LPCWSTR            szHHTFile ,
											/*[in]*/ LPCWSTR            szLogFile ,
                                            /*[in]*/ LPCWSTR            szSKU     ,
                                            /*[in]*/ long               lLCID     ,
                                            /*[in]*/ JetBlue::Session*  sess      ,
                                            /*[in]*/ JetBlue::Database* db        )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::CreateDatabase" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    WCHAR                        rgLCID[64];
    Taxonomy::Package            pkg;
    bool                         fDB = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(sess);
        __MPC_PARAMCHECK_NOTNULL(db);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szHHTFile);
    __MPC_PARAMCHECK_END();


    m_fCreationMode = true;
    m_sess          = sess;
    m_db            = db;


    m_pkg                = &pkg;
    m_pkg->m_strFileName = szCabinet;                  // MPC::wstring m_strFileName; // VOLATILE
    m_pkg->m_fTemporary  = false;                      // bool         m_fTemporary;  // VOLATILE Used for packages not yet authenticated.
                                                       // long         m_lSequence;
                                                       // DWORD        m_dwCRC;
                                                       //
    m_pkg->m_strSKU      = szSKU;                      // MPC::wstring m_strSKU;
    m_pkg->m_strLanguage = _ltow( lLCID, rgLCID, 10 ); // MPC::wstring m_strLanguage;
                                                       // MPC::wstring m_strVendorID;
                                                       // MPC::wstring m_strVendorName;
                                                       // MPC::wstring m_strProductID;
                                                       // MPC::wstring m_strVersion;
                                                       //
    m_pkg->m_fMicrosoft  = true;                       // bool         m_fMicrosoft;
    m_pkg->m_fBuiltin    = true;                       // bool         m_fBuiltin;   // Used for packages installed as part of the setup.



    //
    // start log file
    //
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_log.StartLog( szLogFile ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pkg->Authenticate( m_log ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, AcquireDatabase()); fDB = true;


    {
        MPC::XmlUtil oXMLUtil;
        bool         fLoaded;

        //
        // Load the XML with the root tag.
        //
        if(FAILED(hr = oXMLUtil.Load( szHHTFile, Taxonomy::Strings::s_tag_root_HHT, fLoaded )))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( hr, L"Error loading HHT file" ));
        }
        if(fLoaded == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, WriteLog( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), L"Invalid HHT file" ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, ProcessHHTFile( szHHTFile, oXMLUtil ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fDB)
    {
        ReleaseDatabase();
    }

    //
    // end the log
    //
    EndLog();

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP HCUpdate::Engine::get_VersionList( /*[in]*/ IPCHCollection* *ppVC )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::get_VersionList" );

    HRESULT                           hr;
    Taxonomy::LockingHandle           handle;
    Taxonomy::InstalledInstanceStore* store = Taxonomy::InstalledInstanceStore::s_GLOBAL;
    CComPtr<CPCHCollection>           pColl;
    CComPtr<VersionItem>              pObj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppVC,NULL);
        __MPC_PARAMCHECK_NOTNULL(store);
    __MPC_PARAMCHECK_END();


    //
    // Create the Enumerator and fill it with jobs.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, store->GrabControl( handle, &m_log ));

    {
        Taxonomy::PackageIterConst itPackageBegin;
        Taxonomy::PackageIterConst itPackageEnd;

        __MPC_EXIT_IF_METHOD_FAILS(hr, store->Package_GetList( itPackageBegin, itPackageEnd ));

        for(Taxonomy::PackageIterConst itPackage = itPackageBegin; itPackage != itPackageEnd; itPackage++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj ));

            pObj->m_pkg = *itPackage;

            __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pObj )); pObj.Release();
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppVC ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP HCUpdate::Engine::LatestVersion( /*[in]*/          BSTR     bstrVendorID  ,
                                              /*[in]*/          BSTR     bstrProductID ,
                                              /*[in,optional]*/ VARIANT  vSKU          ,
                                              /*[in,optional]*/ VARIANT  vLanguage     ,
                                              /*[out, retval]*/ BSTR    *pVal          )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::LatestVersion" );

    HRESULT                           hr;
    Taxonomy::LockingHandle           handle;
    Taxonomy::InstalledInstanceStore* store = Taxonomy::InstalledInstanceStore::s_GLOBAL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
        __MPC_PARAMCHECK_NOTNULL(store);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, store->GrabControl( handle, &m_log ));

    {
        Taxonomy::PackageIterConst itPackageBegin;
        Taxonomy::PackageIterConst itPackageEnd;
		Taxonomy::Package          pkgTmp;
        const Taxonomy::Package*   best = NULL;

        pkgTmp.m_strVendorID  = bstrVendorID;
        pkgTmp.m_strProductID = bstrProductID;

        __MPC_EXIT_IF_METHOD_FAILS(hr, store->Package_GetList( itPackageBegin, itPackageEnd ));

        for(Taxonomy::PackageIterConst itPackage = itPackageBegin; itPackage != itPackageEnd; itPackage++)
        {
            const Taxonomy::Package& pkg = *itPackage;

			if(pkg.Compare( pkgTmp, Taxonomy::Package::c_Cmp_ID ) == 0)
            {
                if(vSKU     .vt == VT_BSTR && MPC::StrICmp( pkg.m_strSKU     , vSKU     .bstrVal )) continue;
                if(vLanguage.vt == VT_BSTR && MPC::StrICmp( pkg.m_strLanguage, vLanguage.bstrVal )) continue;

                if(best)
                {
                    if(best->Compare( pkg, Taxonomy::Package::c_Cmp_VERSION ) >= 0) continue;
                }

                best = &pkg;
            }
        }

        if(best)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( best->m_strVersion.c_str(), pVal ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP HCUpdate::Engine::CreateIndex( /*[in         ]*/ VARIANT_BOOL bForce    ,
                                            /*[in,optional]*/ VARIANT      vSKU      ,
                                            /*[in,optional]*/ VARIANT      vLanguage )
{
    __HCP_FUNC_ENTRY( "HCUpdate::Engine::CreateIndex" );

    HRESULT     hr;
    CComVariant vLocal_SKU;
    CComVariant vLocal_Language;
    BSTR        bstrSKU;
    long        lLCID;


    (void)vLocal_SKU     .ChangeType( VT_BSTR, &vSKU      );
    (void)vLocal_Language.ChangeType( VT_I4  , &vLanguage );


    bstrSKU = (vLocal_SKU     .vt == VT_BSTR ? vLocal_SKU     .bstrVal : NULL);
    lLCID   = (vLocal_Language.vt == VT_I4   ? vLocal_Language.lVal    : 0   );


    if(bstrSKU || lLCID)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, SetSkuInfo( bstrSKU, lLCID ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, InternalCreateIndex( bForce ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP HCUpdate::Engine::UpdatePkg( /*[in]*/ BSTR         bstrPathname ,
                                          /*[in]*/ VARIANT_BOOL bSilent      )
{
    HRESULT hr;

    if(SUCCEEDED(hr = MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL, c_AllowedUsers )))
    {
        hr = InternalUpdatePkg( bstrPathname, /*fImpersonate*/true );
    }

    return hr;
}

STDMETHODIMP HCUpdate::Engine::RemovePkg( /*[in]*/ BSTR bstrPathname )
{
    HRESULT hr;

    if(SUCCEEDED(hr = MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL, c_AllowedUsers )))
    {
        hr = InternalRemovePkg( bstrPathname, NULL, /*fImpersonate*/true );
    }

    return hr;
}

STDMETHODIMP HCUpdate::Engine::RemovePkgByID( /*[in]*/ 			BSTR 	bstrVendorID  ,
											  /*[in]*/ 			BSTR 	bstrProductID ,
											  /*[in,optional]*/ VARIANT vVersion      )
{
	__HCP_FUNC_ENTRY( "HCUpdate::Engine::RemovePkgByID" );

    HRESULT                      	  hr;
    MPC::SmartLock<_ThreadModel> 	  lock( this );
    Taxonomy::InstalledInstanceStore* store = Taxonomy::InstalledInstanceStore::s_GLOBAL;
    bool                              fLogStarted = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(store);
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrVendorID);
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrProductID);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL, c_AllowedUsers ));

	{
		Taxonomy::LockingHandle handle;
		Taxonomy::Package       pkgTmp;
		DWORD                   dwMode;

        pkgTmp.m_strVendorID  = bstrVendorID;
        pkgTmp.m_strProductID = bstrProductID;


		if(vVersion.vt == VT_BSTR && vVersion.bstrVal)
		{
			pkgTmp.m_strVersion = vVersion.bstrVal;

			dwMode = Taxonomy::Package::c_Cmp_ID | Taxonomy::Package::c_Cmp_VERSION;
		}
		else
		{
			dwMode = Taxonomy::Package::c_Cmp_ID;
		}

	
		__MPC_EXIT_IF_METHOD_FAILS(hr, store->GrabControl( handle, &m_log ));

		while(1)
		{
			Taxonomy::PackageIterConst it;
			Taxonomy::PackageIterConst itBegin;
			Taxonomy::PackageIterConst itEnd;

			__MPC_EXIT_IF_METHOD_FAILS(hr, store->Package_GetList( itBegin, itEnd ));
			for(it=itBegin; it!=itEnd; it++)
			{
				PCH_MACRO_CHECK_ABORT(hr);

				if(it->Compare( pkgTmp, dwMode ) == 0)
				{
					i