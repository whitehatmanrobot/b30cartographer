 = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id214_match && (object) Reader.NamespaceURI == (object)id33_httpmicrosoftcomwsdlmimetextMatching)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read96_MimeTextMatch(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.ServiceDescriptionFormatExtension Read95_ServiceDescriptionFormatExtension(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id33_httpmicrosoftcomwsdlmimetextMatching))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id35_MimeTextBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id33_httpmicrosoftcomwsdlmimetextMatching))
                    return Read94_MimeTextBinding(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"ServiceDescriptionFormatExtension", @"http://microsoft.com/wsdl/mime/textMatching/");
        }

        System.Web.Services.Description.MimeTextMatch Read96_MimeTextMatch(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id32_MimeTextMatch && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id33_httpmicrosoftcomwsdlmimetextMatching))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.MimeTextMatch o = new System.Web.Services.Description.MimeTextMatch();
            System.Web.Services.Description.MimeTextMatchCollection a_7 = (System.Web.Services.Description.MimeTextMatchCollection)o.@Matches;
            bool[] paramsRead = new bool[8];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id169_type && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Type = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Group = System.Xml.XmlConvert.ToInt32(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id215_capture && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Capture = System.Xml.XmlConvert.ToInt32(Reader.Value);
                    paramsRead[3] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id216_repeats && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@RepeatsString = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id161_pattern && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Pattern = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id217_ignoreCase && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IgnoreCase = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[6] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id214_match && (object) Reader.NamespaceURI == (object)id33_httpmicrosoftcomwsdlmimetextMatching)) {
                        if ((object)(a_7) == null) Reader.Skip(); else a_7.Add(Read96_MimeTextMatch(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.SoapBodyBinding Read97_SoapBodyBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id46_SoapBodyBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.SoapBodyBinding o = new System.Web.Services.Description.SoapBodyBinding();
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id170_use && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Use = Read98_SoapBindingUse(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id218_encodingStyle && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Encoding = Reader.Value;
                    paramsRead[3] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id219_parts && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@PartsString = ToXmlNmTokens(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.SoapBindingUse Read98_SoapBindingUse(string s) {
            switch (s) {
                case @"encoded": return System.Web.Services.Description.SoapBindingUse.@Encoded;
                case @"literal": return System.Web.Services.Description.SoapBindingUse.@Literal;
                default: throw CreateUnknownConstantException(s, typeof(System.Web.Services.Description.SoapBindingUse));
            }
        }

        System.Web.Services.Description.SoapHeaderBinding Read99_SoapHeaderBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id45_SoapHeaderBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.SoapHeaderBinding o = new System.Web.Services.Description.SoapHeaderBinding();
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id9_message && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Message = ToXmlQualifiedName(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id195_part && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Part = ToXmlNmToken(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id170_use && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Use = Read98_SoapBindingUse(Reader.Value);
                    paramsRead[3] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id218_encodingStyle && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Encoding = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[6] && ((object) Reader.LocalName == (object)id220_headerfault && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        o.@Fault = Read100_SoapHeaderFaultBinding(false, true);
                        paramsRead[6] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.SoapHeaderFaultBinding Read100_SoapHeaderFaultBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id44_SoapHeaderFaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.SoapHeaderFaultBinding o = new System.Web.Services.Description.SoapHeaderFaultBinding();
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id9_message && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Message = ToXmlQualifiedName(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id195_part && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Part = ToXmlNmToken(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id170_use && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Use = Read98_SoapBindingUse(Reader.Value);
                    paramsRead[3] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id218_encodingStyle && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Encoding = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.OutputBinding Read101_OutputBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id18_OutputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.OutputBinding o = new System.Web.Services.Description.OutputBinding();
            System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a_2 = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id209_header && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read99_SoapHeaderBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id213_multipartRelated && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read92_MimeMultipartRelatedBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id207_body && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read97_SoapBodyBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id210_mimeXml && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read91_MimeXmlBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id208_content && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read89_MimeContentBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id206_text && (object) Reader.NamespaceURI == (object)id33_httpmicrosoftcomwsdlmimetextMatching)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read94_MimeTextBinding(false, true));
                    }
                    else {
                        a_2.Add((System.Xml.XmlElement)ReadXmlNode(false));
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.FaultBinding Read102_FaultBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id17_FaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.FaultBinding o = new System.Web.Services.Description.FaultBinding();
            System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a_2 = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id200_fault && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read103_SoapFaultBinding(false, true));
                    }
                    else {
                        a_2.Add((System.Xml.XmlElement)ReadXmlNode(false));
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.SoapFaultBinding Read103_SoapFaultBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id43_SoapFaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.SoapFaultBinding o = new System.Web.Services.Description.SoapFaultBinding();
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id170_use && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Use = Read98_SoapBindingUse(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id218_encodingStyle && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Encoding = Reader.Value;
                    paramsRead[3] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.Service Read104_Service(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id15_Service && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.Service o = new System.Web.Services.Description.Service();
            System.Web.Services.Description.PortCollection a_1 = (System.Web.Services.Description.PortCollection)o.@Ports;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[2] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNCName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id221_port && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read105_Port(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.Port Read105_Port(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id14_Port && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.Port o = new System.Web.Services.Description.Port();
            System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a_1 = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[2] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNCName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id11_binding && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Binding = ToXmlQualifiedName(Reader.Value);
                    paramsRead[3] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id222_address && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read107_SoapAddressBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id222_address && (object) Reader.NamespaceURI == (object)id49_httpschemasxmlsoaporgwsdlhttp)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read106_HttpAddressBinding(false, true));
                    }
                    else {
                        a_1.Add((System.Xml.XmlElement)ReadXmlNode(false));
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.HttpAddressBinding Read106_HttpAddressBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id50_HttpAddressBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.HttpAddressBinding o = new System.Web.Services.Description.HttpAddressBinding();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id121_location && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Location = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.SoapAddressBinding Read107_SoapAddressBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id42_SoapAddressBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.SoapAddressBinding o = new System.Web.Services.Description.SoapAddressBinding();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id121_location && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Location = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        protected override void InitCallbacks() {
        }

        public object Read109_definitions() {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                if (((object) Reader.LocalName == (object)id223_definitions && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o = Read1_ServiceDescription(true, true);
                }
                else {
                    throw CreateUnknownNodeException();
                }
            }
            else {
                UnknownNode(null);
            }
            return (object)o;
        }

        System.String id160_whiteSpace;
        System.String id41_httpschemasxmlsoaporgwsdlsoap;
        System.String id113_XmlSchema;
        System.String id175_complexContent;
        System.String id37_MimePart;
        System.String id158_minInclusive;
        System.String id209_header;
        System.String id176_simpleContent;
        System.String id84_XmlSchemaAnyAttribute;
        System.String id219_parts;
        System.String id208_content;
        System.String id59_XmlSchemaAnnotation;
        System.String id163_fixed;
        System.String id137_complexType;
        System.String id220_headerfault;
        System.String id23_OperationFault;
        System.String id14_Port;
        System.String id97_XmlSchemaFractionDigitsFacet;
        System.String id64_XmlSchemaIdentityConstraint;
        System.String id126_elementFormDefault;
        System.String id67_XmlSchemaKeyref;
        System.String id54_HttpBinding;
        System.String id76_XmlSchemaContent;
        System.String id118_SoapBindingStyle;
        System.String id42_SoapAddressBinding;
        System.String id145_source;
        System.String id24_OperationOutput;
        System.String id178_choice;
        System.String id72_XmlSchemaGroupBase;
        System.String id18_OutputBinding;
        System.String id89_XmlSchemaMinExclusiveFacet;
        System.String id207_body;
        System.String id189_refer;
        System.String id218_encodingStyle;
        System.String id166_default;
        System.String id204_style;
        System.String id46_SoapBodyBinding;
        System.String id103_XmlSchemaSimpleTypeUnion;
        System.String id162_value;
        System.String id82_XmlSchemaSimpleContent;
        System.String id11_binding;
        System.String id128_id;
        System.String id173_block;
        System.String id45_SoapHeaderBinding;
        System.String id69_XmlSchemaGroupRef;
        System.String id1_ServiceDescription;
        System.String id206_text;
        System.String id29_Message;
        System.String id117_XmlSchemaContentProcessing;
        System.String id85_XmlSchemaAttributeGroupRef;
        System.String id70_XmlSchemaElement;
        System.String id56_httpwwww3org2001XMLSchema;
        System.String id101_XmlSchemaMinLengthFacet;
        System.String id100_XmlSchemaLengthFacet;
        System.String id223_definitions;
        System.String id114_XmlSchemaForm;
        System.String id15_Service;
        System.String id25_OperationInput;
        System.String id167_form;
        System.String id171_processContents;
        System.String id119_SoapBindingUse;
        System.String id144_appinfo;
        System.String id87_XmlSchemaAttributeGroup;
        System.String id121_location;
        System.String id138_annotation;
        System.String id141_list;
        System.String id191_field;
        System.String id187_unique;
        System.String id188_key;
        System.String id2_httpschemasxmlsoaporgwsdl;
        System.String id157_minExclusive;
        System.String id203_transport;
        System.String id139_schemaLocation;
        System.String id213_multipartRelated;
        System.String id105_XmlSchemaSimpleTypeList;
        System.String id4_Item;
        System.String id122_schema;
        System.String id200_fault;
        System.String id177_sequence;
        System.String id110_XmlSchemaInclude;
        System.String id95_XmlSchemaWhiteSpaceFacet;
        System.String id28_MessagePart;
        System.String id83_XmlSchemaComplexContent;
        System.String id57_XmlSchemaDocumentation;
        System.String id164_memberTypes;
        System.String id108_XmlSchemaSimpleType;
        System.String id142_restriction;
        System.String id43_SoapFaultBinding;
        System.String id99_XmlSchemaMaxLengthFacet;
        System.String id190_selector;
        System.String id151_maxInclusive;
        System.String id62_XmlSchemaGroup;
        System.String id115_XmlSchemaDerivationMethod;
        System.String id180_extension;
        System.String id86_XmlSchemaAttribute;
        System.String id22_OperationMessage;
        System.String id63_XmlSchemaXPath;
        System.String id135_group;
        System.String id5_name;
        System.String id77_XmlSchemaSimpleContentExtension;
        System.String id6_documentation;
        System.String id50_HttpAddressBinding;
        System.String id197_parameterOrder;
        System.String id60_XmlSchemaAnnotated;
        System.String id124_blockDefault;
        System.String id88_XmlSchemaFacet;
        System.String id199_input;
        System.String id94_XmlSchemaPatternFacet;
        System.String id74_XmlSchemaChoice;
        System.String id216_repeats;
        System.String id116_XmlSchemaUse;
        System.String id143_union;
        System.String id107_XmlSchemaComplexType;
        System.String id192_xpath;
        System.String id49_httpschemasxmlsoaporgwsdlhttp;
        System.String id168_ref;
        System.String id165_anyAttribute;
        System.String id210_mimeXml;
        System.String id36_httpschemasxmlsoaporgwsdlmime;
        System.String id65_XmlSchemaKey;
        System.String id30_Types;
        System.String id90_XmlSchemaMinInclusiveFacet;
        System.String id98_XmlSchemaTotalDigitsFacet;
        System.String id48_SoapBinding;
        System.String id52_HttpUrlEncodedBinding;
        System.String id33_httpmicrosoftcomwsdlmimetextMatching;
        System.String id91_XmlSchemaMaxExclusiveFacet;
        System.String id9_message;
        System.String id73_XmlSchemaAll;
        System.String id130_include;
        System.String id172_abstract;
        System.String id79_XmlSchemaComplexContentRestriction;
        System.String id214_match;
        System.String id125_finalDefault;
        System.String id68_XmlSchemaParticle;
        System.String id134_element;
        System.String id20_OperationBinding;
        System.String id212_urlEncoded;
        System.String id93_XmlSchemaEnumerationFacet;
        System.String id44_SoapHeaderFaultBinding;
        System.String id109_XmlSchemaExternal;
        System.String id123_attributeFormDefault;
        System.String id150_length;
        System.String id80_XmlSchemaComplexContentExtension;
        System.String id140_final;
        System.String id17_FaultBinding;
        System.String id222_address;
        System.String id129_redefine;
        System.String id194_system;
        System.String id179_all;
        System.String id34_ServiceDescriptionFormatExtension;
        System.String id174_mixed;
        System.String id71_XmlSchemaAny;
        System.String id154_enumeration;
        System.String id215_capture;
        System.String id27_PortType;
        System.String id159_maxLength;
        System.String id16_MessageBinding;
        System.String id153_fractionDigits;
        System.String id196_operation;
        System.String id217_ignoreCase;
        System.String id53_HttpOperationBinding;
        System.String id170_use;
        System.String id132_notation;
        System.String id39_MimeXmlBinding;
        System.String id155_totalDigits;
        System.String id32_MimeTextMatch;
        System.String id55_XmlSchemaObject;
        System.String id136_attributeGroup;
        System.String id66_XmlSchemaUnique;
        System.String id133_attribute;
        System.String id104_XmlSchemaSimpleTypeRestriction;
        System.String id19_InputBinding;
        System.String id182_maxOccurs;
        System.String id169_type;
        System.String id183_any;
        System.String id8_types;
        System.String id146_lang;
        System.String id195_part;
        System.String id106_XmlSchemaType;
        System.String id198_output;
        System.String id81_XmlSchemaContentModel;
        System.String id185_substitutionGroup;
        System.String id21_Binding;
        System.String id120_namespace;
        System.String id112_XmlSchemaRedefine;
        System.String id184_nillable;
        System.String id205_soapAction;
        System.String id193_public;
        System.String id186_keyref;
        System.String id61_XmlSchemaNotation;
        System.String id35_MimeTextBinding;
        System.String id38_MimeMultipartRelatedBinding;
        System.String id10_portType;
        System.String id152_maxExclusive;
        System.String id202_verb;
        System.String id131_simpleType;
        System.String id161_pattern;
        System.String id75_XmlSchemaSequence;
        System.String id78_XmlSchemaSimpleContentRestriction;
        System.String id127_version;
        System.String id148_itemType;
        System.String id26_Operation;
        System.String id31_Import;
        System.String id51_HttpUrlReplacementBinding;
        System.String id92_XmlSchemaMaxInclusiveFacet;
        System.String id211_urlReplacement;
        System.String id102_XmlSchemaSimpleTypeContent;
        System.String id13_DocumentableItem;
        System.String id47_SoapOperationBinding;
        System.String id221_port;
        System.String id181_minOccurs;
        System.String id40_MimeContentBinding;
        System.String id156_minLength;
        System.String id12_service;
        System.String id147_httpwwww3orgXML1998namespace;
        System.String id111_XmlSchemaImport;
        System.String id58_XmlSchemaAppInfo;
        System.String id149_base;
        System.String id7_import;
        System.String id3_targetNamespace;
        System.String id201_required;
        System.String id96_XmlSchemaNumericFacet;

        protected override void InitIDs() {
            id160_whiteSpace = Reader.NameTable.Add(@"whiteSpace");
            id41_httpschemasxmlsoaporgwsdlsoap = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/wsdl/soap/");
            id113_XmlSchema = Reader.NameTable.Add(@"XmlSchema");
            id175_complexContent = Reader.NameTable.Add(@"complexContent");
            id37_MimePart = Reader.NameTable.Add(@"MimePart");
            id158_minInclusive = Reader.NameTable.Add(@"minInclusive");
            id209_header = Reader.NameTable.Add(@"header");
            id176_simpleContent = Reader.NameTable.Add(@"simpleContent");
            id84_XmlSchemaAnyAttribute = Reader.NameTable.Add(@"XmlSchemaAnyAttribute");
            id219_parts = Reader.NameTable.Add(@"parts");
            id208_content = Reader.NameTable.Add(@"content");
            id59_XmlSchemaAnnotation = Reader.NameTable.Add(@"XmlSchemaAnnotation");
            id163_fixed = Reader.NameTable.Add(@"fixed");
            id137_complexType = Reader.NameTable.Add(@"complexType");
            id220_headerfault = Reader.NameTable.Add(@"headerfault");
            id23_OperationFault = Reader.NameTable.Add(@"OperationFault");
            id14_Port = Reader.NameTable.Add(@"Port");
            id97_XmlSchemaFractionDigitsFacet = Reader.NameTable.Add(@"XmlSchemaFractionDigitsFacet");
            id64_XmlSchemaIdentityConstraint = Reader.NameTable.Add(@"XmlSchemaIdentityConstraint");
            id126_elementFormDefault = Reader.NameTable.Add(@"elementFormDefault");
            id67_XmlSchemaKeyref = Reader.NameTable.Add(@"XmlSchemaKeyref");
            id54_HttpBinding = Reader.NameTable.Add(@"HttpBinding");
            id76_XmlSchemaContent = Reader.NameTable.Add(@"XmlSchemaContent");
            id118_SoapBindingStyle = Reader.NameTable.Add(@"SoapBindingStyle");
            id42_SoapAddressBinding = Reader.NameTable.Add(@"SoapAddressBinding");
            id145_source = Reader.NameTable.Add(@"source");
            id24_OperationOutput = Reader.NameTable.Add(@"OperationOutput");
            id178_choice = Reader.NameTable.Add(@"choice");
            id72_XmlSchemaGroupBase = Reader.NameTable.Add(@"XmlSchemaGroupBase");
            id18_OutputBinding = Reader.NameTable.Add(@"OutputBinding");
            id89_XmlSchemaMinExclusiveFacet = Reader.NameTable.Add(@"XmlSchemaMinExclusiveFacet");
            id207_body = Reader.NameTable.Add(@"body");
            id189_refer = Reader.NameTable.Add(@"refer");
            id218_encodingStyle = Reader.NameTable.Add(@"encodingStyle");
            id166_default = Reader.NameTable.Add(@"default");
            id204_style = Reader.NameTable.Add(@"style");
            id46_SoapBodyBinding = Reader.NameTable.Add(@"SoapBodyBinding");
            id103_XmlSchemaSimpleTypeUnion = Reader.NameTable.Add(@"XmlSchemaSimpleTypeUnion");
            id162_value = Reader.NameTable.Add(@"value");
            id82_XmlSchemaSimpleContent = Reader.NameTable.Add(@"XmlSchemaSimpleContent");
            id11_binding = Reader.NameTable.Add(@"binding");
            id128_id = Reader.NameTable.Add(@"id");
            id173_block = Reader.NameTable.Add(@"block");
            id45_SoapHeaderBinding = Reader.NameTable.Add(@"SoapHeaderBinding");
            id69_XmlSchemaGroupRef = Reader.NameTable.Add(@"XmlSchemaGroupRef");
            id1_ServiceDescription = Reader.NameTable.Add(@"ServiceDescription");
            id206_text = Reader.NameTable.Add(@"text");
            id29_Message = Reader.NameTable.Add(@"Message");
            id117_XmlSchemaContentProcessing = Reader.NameTable.Add(@"XmlSchemaContentProcessing");
            id85_XmlSchemaAttributeGroupRef = Reader.NameTable.Add(@"XmlSchemaAttributeGroupRef");
            id70_XmlSchemaElement = Reader.NameTable.Add(@"XmlSchemaElement");
            id56_httpwwww3org2001XMLSchema = Reader.NameTable.Add(@"http://www.w3.org/2001/XMLSchema");
            id101_XmlSchemaMinLengthFacet = Reader.NameTable.Add(@"XmlSchemaMinLengthFacet");
            id100_XmlSchemaLengthFacet = Reader.NameTable.Add(@"XmlSchemaLengthFacet");
            id223_definitions = Reader.NameTable.Add(@"definitions");
            id114_XmlSchemaForm = Reader.NameTable.Add(@"XmlSchemaForm");
            id15_Service = Reader.NameTable.Add(@"Service");
            id25_OperationInput = Reader.NameTable.Add(@"OperationInput");
            id167_form = Reader.NameTable.Add(@"form");
            id171_processContents = Reader.NameTable.Add(@"processContents");
            id119_SoapBindingUse = Reader.NameTable.Add(@"SoapBindingUse");
            id144_appinfo = Reader.NameTable.Add(@"appinfo");
            id87_XmlSchemaAttributeGroup = Reader.NameTable.Add(@"XmlSchemaAttributeGroup");
            id121_location = Reader.NameTable.Add(@"location");
            id138_annotation = Reader.NameTable.Add(@"annotation");
            id141_list = Reader.NameTable.Add(@"list");
            id191_field = Reader.NameTable.Add(@"field");
            id187_unique = Reader.NameTable.Add(@"unique");
            id188_key = Reader.NameTable.Add(@"key");
            id2_httpschemasxmlsoaporgwsdl = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/wsdl/");
            id157_minExclusive = Reader.NameTable.Add(@"minExclusive");
            id203_transport = Reader.NameTable.Add(@"transport");
            id139_schemaLocation = Reader.NameTable.Add(@"schemaLocation");
            id213_multipartRelated = Reader.NameTable.Add(@"multipartRelated");
            id105_XmlSchemaSimpleTypeList = Reader.NameTable.Add(@"XmlSchemaSimpleTypeList");
            id4_Item = Reader.NameTable.Add(@"");
            id122_schema = Reader.NameTable.Add(@"schema");
            id200_fault = Reader.NameTable.Add(@"fault");
            id177_sequence = Reader.NameTable.Add(@"sequence");
            id110_XmlSchemaInclude = Reader.NameTable.Add(@"XmlSchemaInclude");
            id95_XmlSchemaWhiteSpaceFacet = Reader.NameTable.Add(@"XmlSchemaWhiteSpaceFacet");
            id28_MessagePart = Reader.NameTable.Add(@"MessagePart");
            id83_XmlSchemaComplexContent = Reader.NameTable.Add(@"XmlSchemaComplexContent");
            id57_XmlSchemaDocumentation = Reader.NameTable.Add(@"XmlSchemaDocumentation");
            id164_memberTypes = Reader.NameTable.Add(@"memberTypes");
            id108_XmlSchemaSimpleType = Reader.NameTable.Add(@"XmlSchemaSimpleType");
            id142_restriction = Reader.NameTable.Add(@"restriction");
            id43_SoapFaultBinding = Reader.NameTable.Add(@"SoapFaultBinding");
            id99_XmlSchemaMaxLengthFacet = Reader.NameTable.Add(@"XmlSchemaMaxLengthFacet");
            id190_selector = Reader.NameTable.Add(@"selector");
            id151_maxInclusive = Reader.NameTable.Add(@"maxInclusive");
            id62_XmlSchemaGroup = Reader.NameTable.Add(@"XmlSchemaGroup");
            id115_XmlSchemaDerivationMethod = Reader.NameTable.Add(@"XmlSchemaDerivationMethod");
            id180_extension = Reader.NameTable.Add(@"extension");
            id86_XmlSchemaAttribute = Reader.NameTable.Add(@"XmlSchemaAttribute");
            id22_OperationMessage = Reader.NameTable.Add(@"OperationMessage");
            id63_XmlSchemaXPath = Reader.NameTable.Add(@"XmlSchemaXPath");
            id135_group = Reader.NameTable.Add(@"group");
            id5_name = Reader.NameTable.Add(@"name");
            id77_XmlSchemaSimpleContentExtension = Reader.NameTable.Add(@"XmlSchemaSimpleContentExtension");
            id6_documentation = Reader.NameTable.Add(@"documentation");
            id50_HttpAddressBinding = Reader.NameTable.Add(@"HttpAddressBinding");
            id197_parameterOrder = Reader.NameTable.Add(@"parameterOrder");
            id60_XmlSchemaAnnotated = Reader.NameTable.Add(@"XmlSchemaAnnotated");
            id124_blockDefault = Reader.NameTable.Add(@"blockDefault");
            id88_XmlSchemaFacet = Reader.NameTable.Add(@"XmlSchemaFacet");
            id199_input = Reader.NameTable.Add(@"input");
            id94_XmlSchemaPatternFacet = Reader.NameTable.Add(@"XmlSchemaPatternFacet");
            id74_XmlSchemaChoice = Reader.NameTable.Add(@"XmlSchemaChoice");
            id216_repeats = Reader.NameTable.Add(@"repeats");
            id116_XmlSchemaUse = Reader.NameTable.Add(@"XmlSchemaUse");
            id143_union = Reader.NameTable.Add(@"union");
            id107_XmlSchemaComplexType = Reader.NameTable.Add(@"XmlSchemaComplexType");
            id192_xpath = Reader.NameTable.Add(@"xpath");
            id49_httpschemasxmlsoaporgwsdlhttp = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/wsdl/http/");
            id168_ref = Reader.NameTable.Add(@"ref");
            id165_anyAttribute = Reader.NameTable.Add(@"anyAttribute");
            id210_mimeXml = Reader.NameTable.Add(@"mimeXml");
            id36_httpschemasxmlsoaporgwsdlmime = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/wsdl/mime/");
            id65_XmlSchemaKey = Reader.NameTable.Add(@"XmlSchemaKey");
            id30_Types = Reader.NameTable.Add(@"Types");
            id90_XmlSchemaMinInclusiveFacet = Reader.NameTable.Add(@"XmlSchemaMinInclusiveFacet");
            id98_XmlSchemaTotalDigitsFacet = Reader.NameTable.Add(@"XmlSchemaTotalDigitsFacet");
            id48_SoapBinding = Reader.NameTable.Add(@"SoapBinding");
            id52_HttpUrlEncodedBinding = Reader.NameTable.Add(@"HttpUrlEncodedBinding");
            id33_httpmicrosoftcomwsdlmimetextMatching = Reader.NameTable.Add(@"http://microsoft.com/wsdl/mime/textMatching/");
            id91_XmlSchemaMaxExclusiveFacet = Reader.NameTable.Add(@"XmlSchemaMaxExclusiveFacet");
            id9_message = Reader.NameTable.Add(@"message");
            id73_XmlSchemaAll = Reader.NameTable.Add(@"XmlSchemaAll");
            id130_include = Reader.NameTable.Add(@"include");
            id172_abstract = Reader.NameTable.Add(@"abstract");
            id79_XmlSchemaComplexContentRestriction = Reader.NameTable.Add(@"XmlSchemaComplexContentRestriction");
            id214_match = Reader.NameTable.Add(@"match");
            id125_finalDefault = Reader.NameTable.Add(@"finalDefault");
            id68_XmlSchemaParticle = Reader.NameTable.Add(@"XmlSchemaParticle");
            id134_element = Reader.NameTable.Add(@"element");
            id20_OperationBinding = Reader.NameTable.Add(@"OperationBinding");
            id212_urlEncoded = Reader.NameTable.Add(@"urlEncoded");
            id93_XmlSchemaEnumerationFacet = Reader.NameTable.Add(@"XmlSchemaEnumerationFacet");
            id44_SoapHeaderFaultBinding = Reader.NameTable.Add(@"SoapHeaderFaultBinding");
            id109_XmlSchemaExternal = Reader.NameTable.Add(@"XmlSchemaExternal");
            id123_attributeFormDefault = Reader.NameTable.Add(@"attributeFormDefault");
            id150_length = Reader.NameTable.Add(@"length");
            id80_XmlSchemaComplexContentExtension = Reader.NameTable.Add(@"XmlSchemaComplexContentExtension");
            id140_final = Reader.NameTable.Add(@"final");
            id17_FaultBinding = Reader.NameTable.Add(@"FaultBinding");
            id222_address = Reader.NameTable.Add(@"address");
            id129_redefine = Reader.NameTable.Add(@"redefine");
            id194_system = Reader.NameTable.Add(@"system");
            id179_all = Reader.NameTable.Add(@"all");
            id34_ServiceDescriptionFormatExtension = Reader.NameTable.Add(@"ServiceDescriptionFormatExtension");
            id174_mixed = Reader.NameTable.Add(@"mixed");
            id71_XmlSchemaAny = Reader.NameTable.Add(@"XmlSchemaAny");
            id154_enumeration = Reader.NameTable.Add(@"enumeration");
            id215_capture = Reader.NameTable.Add(@"capture");
            id27_PortType = Reader.NameTable.Add(@"PortType");
            id159_maxLength = Reader.NameTable.Add(@"maxLength");
            id16_MessageBinding = Reader.NameTable.Add(@"MessageBinding");
            id153_fractionDigits = Reader.NameTable.Add(@"fractionDigits");
            id196_operation = Reader.NameTable.Add(@"operation");
            id217_ignoreCase = Reader.NameTable.Add(@"ignoreCase");
            id53_HttpOperationBinding = Reader.NameTable.Add(@"HttpOperationBinding");
            id170_use = Reader.NameTable.Add(@"use");
            id132_notation = Reader.NameTable.Add(@"notation");
            id39_MimeXmlBinding = Reader.NameTable.Add(@"MimeXmlBinding");
            id155_totalDigits = Reader.NameTable.Add(@"totalDigits");
            id32_MimeTextMatch = Reader.NameTable.Add(@"MimeTextMatch");
            id55_XmlSchemaObject = Reader.NameTable.Add(@"XmlSchemaObject");
            id136_attributeGroup = Reader.NameTable.Add(@"attributeGroup");
            id66_XmlSchemaUnique = Reader.NameTable.Add(@"XmlSchemaUnique");
            id133_attribute = Reader.NameTable.Add(@"attribute");
            id104_XmlSchemaSimpleTypeRestriction = Reader.NameTable.Add(@"XmlSchemaSimpleTypeRestriction");
            id19_InputBinding = Reader.NameTable.Add(@"InputBinding");
            id182_maxOccurs = Reader.NameTable.Add(@"maxOccurs");
            id169_type = Reader.NameTable.Add(@"type");
            id183_any = Reader.NameTable.Add(@"any");
            id8_types = Reader.NameTable.Add(@"types");
            id146_lang = Reader.NameTable.Add(@"lang");
            id195_part = Reader.NameTable.Add(@"part");
            id106_XmlSchemaType = Reader.NameTable.Add(@"XmlSchemaType");
            id198_output = Reader.NameTable.Add(@"output");
            id81_XmlSchemaContentModel = Reader.NameTable.Add(@"XmlSchemaContentModel");
            id185_substitutionGroup = Reader.NameTable.Add(@"substitutionGroup");
            id21_Binding = Reader.NameTable.Add(@"Binding");
            id120_namespace = Reader.NameTable.Add(@"namespace");
            id112_XmlSchemaRedefine = Reader.NameTable.Add(@"XmlSchemaRedefine");
            id184_nillable = Reader.NameTable.Add(@"nillable");
            id205_soapAction = Reader.NameTable.Add(@"soapAction");
            id193_public = Reader.NameTable.Add(@"public");
            id186_keyref = Reader.NameTable.Add(@"keyref");
            id61_XmlSchemaNotation = Reader.NameTable.Add(@"XmlSchemaNotation");
            id35_MimeTextBinding = Reader.NameTable.Add(@"MimeTextBinding");
            id38_MimeMultipartRelatedBinding = Reader.NameTable.Add(@"MimeMultipartRelatedBinding");
            id10_portType = Reader.NameTable.Add(@"portType");
            id152_maxExclusive = Reader.NameTable.Add(@"maxExclusive");
            id202_verb = Reader.NameTable.Add(@"verb");
            id131_simpleType = Reader.NameTable.Add(@"simpleType");
            id161_pattern = Reader.NameTable.Add(@"pattern");
            id75_XmlSchemaSequence = Reader.NameTable.Add(@"XmlSchemaSequence");
            id78_XmlSchemaSimpleContentRestriction = Reader.NameTable.Add(@"XmlSchemaSimpleContentRestriction");
            id127_version = Reader.NameTable.Add(@"version");
            id148_itemType = Reader.NameTable.Add(@"itemType");
            id26_Operation = Reader.NameTable.Add(@"Operation");
            id31_Import = Reader.NameTable.Add(@"Import");
            id51_HttpUrlReplacementBinding = Reader.NameTable.Add(@"HttpUrlReplacementBinding");
            id92_XmlSchemaMaxInclusiveFacet = Reader.NameTable.Add(@"XmlSchemaMaxInclusiveFacet");
            id211_urlReplacement = Reader.NameTable.Add(@"urlReplacement");
            id102_XmlSchemaSimpleTypeContent = Reader.NameTable.Add(@"XmlSchemaSimpleTypeContent");
            id13_DocumentableItem = Reader.NameTable.Add(@"DocumentableItem");
            id47_SoapOperationBinding = Reader.NameTable.Add(@"SoapOperationBinding");
            id221_port = Reader.NameTable.Add(@"port");
            id181_minOccurs = Reader.NameTable.Add(@"minOccurs");
            id40_MimeContentBinding = Reader.NameTable.Add(@"MimeContentBinding");
            id156_minLength = Reader.NameTable.Add(@"minLength");
            id12_service = Reader.NameTable.Add(@"service");
            id147_httpwwww3orgXML1998namespace = Reader.NameTable.Add(@"http://www.w3.org/XML/1998/namespace");
            id111_XmlSchemaImport = Reader.NameTable.Add(@"XmlSchemaImport");
            id58_XmlSchemaAppInfo = Reader.NameTable.Add(@"XmlSchemaAppInfo");
            id149_base = Reader.NameTable.Add(@"base");
            id7_import = Reader.NameTable.Add(@"import");
            id3_targetNamespace = Reader.NameTable.Add(@"targetNamespace");
            id201_required = Reader.NameTable.Add(@"required");
            id96_XmlSchemaNumericFacet = Reader.NameTable.Add(@"XmlSchemaNumericFacet");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\protocolreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProtocolReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Web.Services.Description {
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.Security.Permissions;

    /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public abstract class ProtocolReflector {
        ServiceDescriptionReflector reflector;
        LogicalMethodInfo method;
        Operation operation;
        OperationBinding operationBinding;
        Port port;
        PortType portType;
        Binding binding;
        WebMethodAttribute methodAttr;
        Message inputMessage;
        Message outputMessage;
        MessageCollection headerMessages;
        ServiceDescription bindingServiceDescription;
        CodeIdentifiers portNames;

        internal void Initialize(ServiceDescriptionReflector reflector) {
            this.reflector = reflector;
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.Service"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Service Service {
            get { return reflector.Service; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ServiceDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription ServiceDescription {
            get { return reflector.ServiceDescription; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ServiceDescriptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionCollection ServiceDescriptions {
            get { return reflector.ServiceDescriptions; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.Schemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemas Schemas {
            get { return reflector.Schemas; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.SchemaExporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaExporter SchemaExporter {
            get { return reflector.SchemaExporter; }
        }
        
        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ReflectionImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlReflectionImporter ReflectionImporter {
            get { return reflector.ReflectionImporter; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.DefaultNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DefaultNamespace {
            get { return reflector.ServiceAttribute.Namespace; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ServiceUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ServiceUrl {
            get { return reflector.ServiceUrl; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ServiceType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type ServiceType {
            get { return reflector.ServiceType; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.Method"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public LogicalMethodInfo Method {
            get { return method; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Binding Binding {
            get { return binding; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.PortType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PortType PortType {
            get { return portType; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.Port"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Port Port {
            get { return port; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.Operation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Operation Operation {
            get { return operation; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.OperationBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationBinding OperationBinding {
            get { return operationBinding; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.MethodAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebMethodAttribute MethodAttribute {
            get { return methodAttr; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.Methods"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public LogicalMethodInfo[] Methods {
            get { return reflector.Methods; }
        }

        internal Hashtable ReflectionContext {
            get { return reflector.ReflectionContext; }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.InputMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message InputMessage {
            get {
                if (inputMessage == null) {
                    string messageName = methodAttr.MessageName.Length == 0 ? Method.Name : methodAttr.MessageName;
                    bool diffNames = messageName != Method.Name;

                    inputMessage = new Message();
                    inputMessage.Name = messageName + ProtocolName + "In";

                    OperationInput input = new OperationInput();
                    if (diffNames) input.Name = messageName;
                    input.Message = new XmlQualifiedName(inputMessage.Name, bindingServiceDescription.TargetNamespace);
                    operation.Messages.Add(input);

                    OperationBinding.Input = new InputBinding();
                    if (diffNames) OperationBinding.Input.Name = messageName;
                }
                return inputMessage;
            }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.OutputMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message OutputMessage {
            get {
                if (outputMessage == null) {
                    string messageName = methodAttr.MessageName.Length == 0 ? Method.Name : methodAttr.MessageName;
                    bool diffNames = messageName != Method.Name;

                    outputMessage = new Message();
                    outputMessage.Name = messageName + ProtocolName + "Out";

                    OperationOutput output = new OperationOutput();
                    if (diffNames) output.Name = messageName;
                    output.Message = new XmlQualifiedName(outputMessage.Name, bindingServiceDescription.TargetNamespace);
                    operation.Messages.Add(output);

                    OperationBinding.Output = new OutputBinding();
                    if (diffNames) OperationBinding.Output.Name = messageName;
                }
                return outputMessage;
            }
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.HeaderMessages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageCollection HeaderMessages {
            get {
                if (headerMessages == null) {
                    headerMessages = new MessageCollection(bindingServiceDescription);
                }
                return headerMessages;
            }
        }

        void MoveToMethod(LogicalMethodInfo method) {
            this.method = method;
            this.methodAttr = WebMethodReflector.GetAttribute(method);
        }

        class ReflectedBinding {
            public WebServiceBindingAttribute bindingAttr;
            public ArrayList methodList;
        }

        internal void Reflect() {
            Hashtable reflectedBindings = new Hashtable();
           
            for (int i = 0; i < reflector.Methods.Length; i++) {
                MoveToMethod(reflector.Methods[i]);
                string bindingName = ReflectMethodBinding();
                if (bindingName == null) bindingName = string.Empty;
                ReflectedBinding reflectedBinding = (ReflectedBinding)reflectedBindings[bindingName];
                if (reflectedBinding == null) {
                    reflectedBinding = new ReflectedBinding();
                    if (bindingName.Length == 0) {
                        reflectedBinding.bindingAttr = new WebServiceBindingAttribute();
                    }
                    else {
                        reflectedBinding.bindingAttr = WebServiceBindingReflector.GetAttribute(method, bindingName);
                    }
                    reflectedBindings.Add(bindingName, reflectedBinding);
                }
                if (reflectedBinding.methodList == null)
                    reflectedBinding.methodList = new ArrayList();
                if (reflectedBinding.bindingAttr.Location.Length == 0) {
                    reflectedBinding.methodList.Add(method);
                }
                else {
                    AddImport(reflectedBinding.bindingAttr.Namespace, reflectedBinding.bindingAttr.Location);
                }
            }

            foreach (ReflectedBinding reflectedBinding in reflectedBindings.Values) {
                ReflectBinding(reflectedBinding);
            }
        }

        void AddImport(string ns, string location) {
            foreach (Import import in ServiceDescription.Imports) {
                if (import.Namespace == ns && import.Location == location) {
                    return;
                }
            }
            Import newImport = new Import();
            newImport.Namespace = ns;
            newImport.Location = location;
            ServiceDescription.Imports.Add(newImport);
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.GetServiceDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription GetServiceDescription(string ns) {
            ServiceDescription description = ServiceDescriptions[ns];
            if (description == null) {
                description = new ServiceDescription();
                description.TargetNamespace = ns;
                ServiceDescriptions.Add(description);
            }
            return description;
        }

        void ReflectBinding(ReflectedBinding reflectedBinding) {
            string bindingName = reflectedBinding.bindingAttr.Name;
            string bindingNamespace = reflectedBinding.bindingAttr.Namespace;
            if (bindingName.Length == 0) bindingName = Service.Name + ProtocolName;
            if (bindingNamespace.Length == 0) bindingNamespace = ServiceDescription.TargetNamespace;
            
            if (reflectedBinding.bindingAttr.Location.Length > 0) {
                // If a URL is specified for the WSDL, file, then we just import the
                // binding from there instead of generating it in this WSDL file.
                portType = null;
                binding = null;
            }
            else {
                bindingServiceDescription = GetServiceDescription(bindingNamespace);
                CodeIdentifiers bindingNames = new CodeIdentifiers();
                foreach (Binding b in bindingServiceDescription.Bindings)
                    bindingNames.AddReserved(b.Name);

                bindingName = bindingNames.AddUnique(bindingName, binding);

                portType = new PortType();
                binding = new Binding();
                portType.Name = bindingName;
                binding.Name = bindingName;
                binding.Type = new XmlQualifiedName(portType.Name, bindingNamespace);
                bindingServiceDescription.Bindings.Add(binding);
                bindingServiceDescription.PortTypes.Add(portType);
            }
            
            if (portNames == null) {
                portNames = new CodeIdentifiers();
                foreach (Port p in Service.Ports)
                    portNames.AddReserved(p.Name);
            }

            port = new Port();
            port.Binding = new XmlQualifiedName(bindingName, bindingNamespace);
            port.Name = portNames.AddUnique(bindingName, port);
            Service.Ports.Add(port);
            
            BeginClass();

            foreach (LogicalMethodInfo method in reflectedBinding.methodList) {

                MoveToMethod(method);

                operation = new Operation();
                operation.Name = method.Name;
                operation.Documentation = methodAttr.Description;

                operationBinding = new OperationBinding();
                operationBinding.Name = operation.Name;

                inputMessage = null;
                outputMessage = null;
                headerMessages = null;

                if (ReflectMethod()) {
                    if (inputMessage != null) bindingServiceDescription.Messages.Add(inputMessage);
                    if (outputMessage != null) bindingServiceDescription.Messages.Add(outputMessage);
                    if (headerMessages != null) {
                        foreach (Message headerMessage in headerMessages) {
                            bindingServiceDescription.Messages.Add(headerMessage);
                        }
                    }
                    binding.Operations.Add(operationBinding);
                    portType.Operations.Add(operation);
                }
            }

            EndClass();
        }

        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ProtocolName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract string ProtocolName { get; }

        // These overridable methods have no parameters.  The subclass uses properties on this
        // base object to obtain the information.  This allows us to grow the set of
        // information passed to the methods over time w/o breaking anyone.   They are protected
        // instead of public because this object is passed to extensions and we don't want
        // those calling these methods.
        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.BeginClass"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void BeginClass() { }
        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ReflectMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract bool ReflectMethod();
        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.ReflectMethodBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string ReflectMethodBinding() { return string.Empty; }
        /// <include file='doc\ProtocolReflector.uex' path='docs/doc[@for="ProtocolReflector.EndClass"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void EndClass() { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\servicedescriptionreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceDescriptionReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.Security.Permissions;
    using System.Web.Services.Configuration;
    using System.IO;

    /// <include file='doc\ServiceDescriptionReflector.uex' path='docs/doc[@for="ServiceDescriptionReflector"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public class ServiceDescriptionReflector {
        ProtocolReflector[] reflectors, reflectorsWithPost;
        ServiceDescriptionCollection descriptions = new ServiceDescriptionCollection();
        XmlSchemas schemas = new XmlSchemas();
        ServiceDescriptionCollection descriptionsWithPost;
        XmlSchemas schemasWithPost;
        WebServiceAttribute serviceAttr;
        ServiceDescription description;
        Service service;
        LogicalMethodInfo[] methods;
        XmlSchemaExporter exporter;
        XmlReflectionImporter importer;
        Type serviceType;
        string serviceUrl;
        Hashtable reflectionContext;

        /// <include file='doc\ServiceDescriptionReflector.uex' path='docs/doc[@for="ServiceDescriptionReflector.ServiceDescriptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionCollection ServiceDescriptions {
            get { return descriptions; }
        }

        /// <include file='doc\ServiceDescriptionReflector.uex' path='docs/doc[@for="ServiceDescriptionReflector.Schemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemas Schemas {
            get { return schemas; }
        }
        
        internal ServiceDescriptionCollection ServiceDescriptionsWithPost {
            get { return descriptionsWithPost; }
        }
        
        internal XmlSchemas SchemasWithPost {
            get { return schemasWithPost; }
        }

        internal ServiceDescription ServiceDescription {
            get { return description; }
        }

        internal Service Service {
            get { return service; }
        }

        internal Type ServiceType {
            get { return serviceType; }
        }

        internal LogicalMethodInfo[] Methods {
            get { return methods; }
        }

        internal string ServiceUrl {
            get { return serviceUrl; }
        }

        internal XmlSchemaExporter SchemaExporter {
            get { return exporter; }
        }

        internal XmlReflectionImporter ReflectionImporter {
            get { return importer; }
        }

        internal WebServiceAttribute ServiceAttribute {
            get { return serviceAttr; }
        }

        internal Hashtable ReflectionContext {
            get {
                if (reflectionContext == null)
                    reflectionContext = new Hashtable();
                return reflectionContext;
            }
        }

        /// <include file='doc\ServiceDescriptionReflector.uex' path='docs/doc[@for="ServiceDescriptionReflector.ServiceDescriptionReflector"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionReflector() {
            Type[] reflectorTypes = WebServicesConfiguration.Current.ProtocolReflectorTypes;
            reflectors = new ProtocolReflector[reflectorTypes.Length];
            for (int i = 0; i < reflectors.Length; i++) {
                ProtocolReflector reflector = (ProtocolReflector)Activator.CreateInstance(reflectorTypes[i]);
                reflector.Initialize(this);
                reflectors[i] = reflector;
            }
            ProtocolsEnum enabledProtocols = WebServicesConfiguration.Current.EnabledProtocols;
            if ((enabledProtocols & ProtocolsEnum.HttpPost) == 0 && (enabledProtocols & ProtocolsEnum.HttpPostLocalhost) != 0) {
                reflectorsWithPost = new ProtocolReflector[reflectors.Length + 1];
                for (int i = 0; i < reflectorsWithPost.Length - 1; i++) {
                    ProtocolReflector reflector = (ProtocolReflector) Activator.CreateInstance(reflectorTypes[i]);
                    reflector.Initialize(this);
                    reflectorsWithPost[i] = reflector;
                }
                ProtocolReflector reflectorWithPost = new HttpPostProtocolReflector();
                reflectorWithPost.Initialize(this);
                reflectorsWithPost[reflectorsWithPost.Length - 1] = reflectorWithPost;
            }
        }
        
        private void ReflectInternal(ProtocolReflector[] reflectors) {
            description = new ServiceDescription();
            description.TargetNamespace = serviceAttr.Namespace;
            ServiceDescriptions.Add(description);

            service = new Service();
            service.Name = serviceAttr.Name;
            if (service.Name == null || service.Name.Length == 0) 
                service.Name = serviceType.Name;
            service.Documentation = serviceAttr.Description;
            description.Services.Add(service);

            reflectionContext = new Hashtable();
            exporter = new XmlSchemaExporter(description.Types.Schemas);
            importer = SoapReflector.CreateXmlImporter(serviceAttr.Namespace, SoapReflector.ServiceDefaultIsEncoded(serviceType));
            WebMethodReflector.IncludeTypes(methods, importer);

            for (int i = 0; i < reflectors.Length; i++) {
                reflectors[i].Reflect();
            }
        }

        /// <include file='doc\ServiceDescriptionReflector.uex' path='docs/doc[@for="ServiceDescriptionReflector.Reflect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Reflect(Type type, string url) {
            serviceType = type;
            serviceUrl = url;
            
            serviceAttr = WebServiceReflector.GetAttribute(type);

            methods = WebMethodReflector.GetMethods(type);
            CheckForDuplicateMethods(methods);

            descriptionsWithPost = descriptions;
            schemasWithPost = schemas;

            if (reflectorsWithPost != null) {
                ReflectInternal(reflectorsWithPost);

                descriptions = new ServiceDescriptionCollection();
                schemas = new XmlSchemas();
            }
            
            ReflectInternal(reflectors);

            XmlSchema[] descriptionSchemas = new XmlSchema[ServiceDescription.Types.Schemas.Count];
            ServiceDescription.Types.Schemas.CopyTo(descriptionSchemas, 0);
            // if defining interfaces, we move all schemas to the external collection
            // since the types therein may be referenced from any of the sdls
            bool externalizeSchemas = ServiceDescriptions.Count > 1;
            foreach (XmlSchema schema in descriptionSchemas) {
                // we always move dataset schemas to the external schema's collection.
                if (externalizeSchemas || XmlSchemas.IsDataSet(schema)) {
                    ServiceDescription.Types.Schemas.Remove(schema);
                    Schemas.Add(schema);
                }
            }
            
        }

        void CheckForDuplicateMethods(LogicalMethodInfo[] methods) {
            Hashtable messageNames = new Hashtable();
            foreach (LogicalMethodInfo method in methods) {
                WebMethodAttribute attribute = WebMethodReflector.GetAttribute(method);
                string messageName = attribute.MessageName;
                if (messageName.Length == 0) messageName = method.Name;
                LogicalMethodInfo existingMethod = (LogicalMethodInfo)messageNames[messageName];
                if (existingMethod != null) {
                    throw new InvalidOperationException(Res.GetString(Res.BothAndUseTheMessageNameUseTheMessageName3, method, existingMethod, messageName));
                }
                messageNames.Add(messageName, method);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\servicedescriptionimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceDescriptionImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;
    using System.Web.Services.Configuration;
    using System.Xml;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportWarnings"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ServiceDescriptionImportWarnings {
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportWarnings.NoCodeGenerated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoCodeGenerated = 0x1,
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportWarnings.OptionalExtensionsIgnored"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OptionalExtensionsIgnored = 0x2,
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportWarnings.RequiredExtensionsIgnored"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RequiredExtensionsIgnored = 0x4,
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportWarnings.UnsupportedOperationsIgnored"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        UnsupportedOperationsIgnored = 0x8,
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportWarnings.UnsupportedBindingsIgnored"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        UnsupportedBindingsIgnored = 0x10,
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportWarnings.NoMethodsGenerated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoMethodsGenerated = 0x20,
    }

    /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportStyle"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ServiceDescriptionImportStyle {
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportStyle.Client"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Client,
        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImportStyle.Server"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Server
    }

    /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public class ServiceDescriptionImporter {
        ServiceDescriptionImportStyle style = ServiceDescriptionImportStyle.Client;
        ServiceDescriptionCollection serviceDescriptions = new ServiceDescriptionCollection();
        XmlSchemas schemas = new XmlSchemas(); // those external to SDLs
        XmlSchemas allSchemas = new XmlSchemas(); // all schemas, incl. those inside SDLs
        string protocolName;
        ProtocolImporter[] importers;
        XmlSchemas abstractSchemas = new XmlSchemas(); // all schemas containing abstract types
        XmlSchemas concreteSchemas = new XmlSchemas(); // all "real" xml schemas 

        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter.ServiceDescriptionImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionImporter() {
            Type[] importerTypes = WebServicesConfiguration.Current.ProtocolImporterTypes;
            importers = new ProtocolImporter[importerTypes.Length];
            for (int i = 0; i < importers.Length; i++) {
                importers[i] = (ProtocolImporter)Activator.CreateInstance(importerTypes[i]);
                importers[i].Initialize(this);
            }
        }

        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter.ServiceDescriptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionCollection ServiceDescriptions {
            get { return serviceDescriptions; }
        }

        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter.Schemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemas Schemas {
            get { return schemas; }
        }

        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter.Style"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionImportStyle Style {
            get { return style; }
            set { style = value; }
        }

        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter.ProtocolName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String ProtocolName {
            get { return protocolName == null ? string.Empty : protocolName; }
            set { protocolName = value; }
        }

        ProtocolImporter FindImporterByName(string protocolName) {
            for (int i = 0; i < importers.Length; i++) {
                ProtocolImporter importer = importers[i];
                if (string.Compare(ProtocolName, importer.ProtocolName, true, CultureInfo.InvariantCulture) == 0) {
                    return importer;
                }
            }
            // SOAP12: disable soap 1.2 proxy generation
            if (string.Compare(ProtocolName, "Soap12", true, CultureInfo.InvariantCulture) == 0) {
                throw new InvalidOperationException(Res.GetString(Res.WebSoap12NotSupported));
            }
            throw new ArgumentException(Res.GetString(Res.ProtocolWithNameIsNotRecognized1, protocolName), "protocolName");
        }

        internal XmlSchemas AllSchemas {
            get { return allSchemas; }
        }

        internal XmlSchemas AbstractSchemas {
            get { return abstractSchemas; }
        }

        internal XmlSchemas ConcreteSchemas {
            get { return concreteSchemas; }
        }

        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter.AddServiceDescription"]/*' />
        public void AddServiceDescription(ServiceDescription serviceDescription, string appSettingUrlKey, string appSettingBaseUrl) {
            if (serviceDescription == null)
                throw new ArgumentNullException("serviceDescription");

            serviceDescription.AppSettingUrlKey = appSettingUrlKey;
            serviceDescription.AppSettingBaseUrl = appSettingBaseUrl;
            ServiceDescriptions.Add(serviceDescription);
        }

        /// <include file='doc\ServiceDescriptionImporter.uex' path='docs/doc[@for="ServiceDescriptionImporter.Import"]/*' />
        public ServiceDescriptionImportWarnings Import(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit) {
            if (codeCompileUnit != null) {
                codeCompileUnit.ReferencedAssemblies.Add("System.dll");
                codeCompileUnit.ReferencedAssemblies.Add("System.Xml.dll");
                codeCompileUnit.ReferencedAssemblies.Add("System.Web.Services.dll");
            }

            return Import(codeNamespace);
        }

        private void FindUse(MessagePart part, out bool isEncoded, out bool isLiteral) {
            isEncoded = false;
            isLiteral = false;
            string messageName = part.Message.Name;
            Operation associatedOperation = null;
            ServiceDescription description = part.Message.ServiceDescription;
            foreach (PortType portType in description.PortTypes) {
                foreach (Operation operation in portType.Operations) {
                    foreach (OperationMessage message in operation.Messages) {
                        if (message.Message.Equals(new XmlQualifiedName(part.Message.Name, description.TargetNamespace))) {
                            associatedOperation = operation;
                            FindUse(associatedOperation, description, messageName, ref isEncoded, ref isLiteral);
                        }
                    }
                }
            }
            if (associatedOperation == null)
                FindUse(null, description, messageName, ref isEncoded, ref isLiteral);
        }

        private void FindUse(Operation operation, ServiceDescription description, string messageName, ref bool isEncoded, ref bool isLiteral) {
            string targetNamespace = description.TargetNamespace;
            foreach (Binding binding in description.Bindings) {
                if (operation != null && !new XmlQualifiedName(operation.PortType.Name, targetNamespace).Equals(binding.Type))
                    continue;
                foreach (OperationBinding bindingOperation in binding.Operations) {
                    if (bindingOperation.Input != null) foreach (object extension in bindingOperation.Input.Extensions) {
                        if (operation != null) {
                            SoapBodyBinding body = extension as SoapBodyBinding;
                            if (body != null && operation.IsBoundBy(bindingOperation)) {
                                if (body.Use == SoapBindingUse.Encoded)
                                    isEncoded = true;
                                else if (body.Use == SoapBindingUse.Literal)
                                    isLiteral = true;
                            }
                        }
                        else {
                            SoapHeaderBinding header = extension as SoapHeaderBinding;
                            if (header != null && header.Message.Name == messageName) {
                                if (header.Use == SoapBindingUse.Encoded)
                                    isEncoded = true;
                                else if (header.Use == SoapBindingUse.Literal)
                                    isLiteral = true;
                            }
                        }
                    }
                    if (bindingOperation.Output != null) foreach (object extension in bindingOperation.Output.Extensions) {
                        if (operation != null) {
                            if (operation.IsBoundBy(bindingOperation)) {
                                SoapBodyBinding body = extension as SoapBodyBinding;
                                if (body != null) {
                                    if (body.Use == SoapBindingUse.Encoded)
                                        isEncoded = true;
                                    else if (body.Use == SoapBindingUse.Literal)
                                        isLiteral = true;
                                }
                                else if (extension is MimeXmlBinding)
                                    isLiteral = true;
                            }
                        }
                        else {
                            SoapHeaderBinding header = extension as SoapHeaderBinding;
                            if (header != null && header.Message.Name == messageName) {
                                if (header.Use == SoapBindingUse.Encoded)
                                    isEncoded = true;
                                else if (header.Use == SoapBindingUse.Literal)
                                    isLiteral = true;
                            }
                        }
                    }
                }
            }
        }

        private ServiceDescriptionImportWarnings Import(CodeNamespace codeNamespace) {
            allSchemas = new XmlSchemas();
            foreach (XmlSchema schema in schemas) {
                allSchemas.Add(schema);
            }

            foreach (ServiceDescription description in serviceDescriptions) {
                foreach (XmlSchema schema in description.Types.Schemas) {
                    allSchemas.Add(schema);
                }
            }

            // Segregate the schemas containing abstract types from those 
            // containing regular XML definitions.  This is important because
            // when you import something returning the ur-type (object), then
            // you need to import ALL types/elements within ALL schemas.  We
            // don't want the RPC-based types leaking over into the XML-based
            // element definitions.  This also occurs when you have derivation:
            // we need to search the schemas for derived types: but WHICH schemas
            // should we search.
            foreach (ServiceDescription description in serviceDescriptions) {
                foreach (Message message in description.Messages) {
                    foreach (MessagePart part in message.Parts) {
                        bool isEncoded;
                        bool isLiteral;
                        FindUse(part, out isEncoded, out isLiteral);
                        if (part.Element != null && !part.Element.IsEmpty) {
                            if (isEncoded) throw new Exception(Res.GetString(Res.CanTSpecifyElementOnEncodedMessagePartsPart, part.Name, message.Name));
                            string ns = part.Element.Namespace;
                            XmlSchema schema = allSchemas[ns];
                            if (schema != null) {
                                if (isEncoded && abstractSchemas[ns] == null)
                                    abstractSchemas.Add(schema);
                                if (isLiteral && concreteSchemas[ns] == null)
                                    concreteSchemas.Add(schema);
                            }
                        }
                        if (part.Type != null && !part.Type.IsEmpty) {
                            string ns = part.Type.Namespace;
                            XmlSchema schema = allSchemas[ns];
                            if (schema != null) {
                                if (isEncoded && abstractSchemas[ns] == null)
                                    abstractSchemas.Add(schema);
                                if (isLiteral && concreteSchemas[ns] == null)
                                    concreteSchemas.Add(schema);
                            }
                        }
                    }
                }
            }
            foreach (XmlSchemas schemas in new XmlSchemas[] { abstractSchemas, concreteSchemas }) {
                XmlSchemas additionalSchemas = new XmlSchemas();
                foreach (XmlSchema schema in schemas) {
                    foreach (object include in schema.Includes) {
                        if (include is XmlSchemaImport) {
                            XmlSchemaImport import = (XmlSchemaImport) include;
                            if (import.Schema != null && !schemas.Contains(import.Schema) && !additionalSchemas.Contains(import.Schema))
                                additionalSchemas.Add(import.Schema);
                            else if (import.Namespace != null && allSchemas[import.Namespace] != null && schemas[import.Namespace] == null && additionalSchemas[import.Namespace] == null)
                                additionalSchemas.Add(allSchemas[import.Namespace]);
                        }
                    }
                }
                foreach (XmlSchema schema in additionalSchemas)
                    schemas.Add(schema);
            }

            // If a schema was not referenced by either a literal or an encoded message part,
            // add it to both collections. There's no way to tell which it should be.
            foreach (XmlSchema schema in allSchemas) {
                if (!abstractSchemas.Contains(schema) && !concreteSchemas.Contains(schema)) {
                    abstractSchemas.Add(schema);
                    concreteSchemas.Add(schema);
                }
            }

            if (ProtocolName.Length > 0) {
                // If a protocol was specified, only try that one
                ProtocolImporter importer = FindImporterByName(ProtocolName);
                if (importer.GenerateCode(codeNamespace)) return importer.Warnings;
            }
            else {
                // Otherwise, do "best" protocol (first one that generates something)
                for (int i = 0; i < importers.Length; i++) {
                    ProtocolImporter importer = importers[i];
                    if (importer.GenerateCode(codeNamespace))
                        return importer.Warnings;
                }
            }

            return ServiceDescriptionImportWarnings.NoCodeGenerated;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\servicedescription.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceDescription.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Xml;
    using System.IO;
    using System.Reflection;
    using System.ComponentModel;
    using System.CodeDom;
    using System.Text;
    using System.Web.Services.Configuration;
    using System.Diagnostics;

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription"]/*' />
    /// <devdoc>
    /// 
    /// </devdoc>
    [XmlRoot("definitions", Namespace=ServiceDescription.Namespace)]
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class ServiceDescription : DocumentableItem {
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string Namespace = "http://schemas.xmlsoap.org/wsdl/";
        Types types;
        ImportCollection imports;
        MessageCollection messages;
        PortTypeCollection portTypes;
        BindingCollection bindings;
        ServiceCollection services;
        string name;
        string targetNamespace;
        ServiceDescriptionFormatExtensionCollection extensions;
        ServiceDescriptionCollection parent;
        string appSettingUrlKey;
        string appSettingBaseUrl;
        string retrievalUrl;
        static XmlSerializer serializer;
        static XmlSerializerNamespaces namespaces;

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.RetrievalUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public string RetrievalUrl {
            get { return retrievalUrl == null ? string.Empty : retrievalUrl; }
            set { retrievalUrl = value; }
        }

        internal void SetParent(ServiceDescriptionCollection parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.ServiceDescriptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescriptionCollection ServiceDescriptions {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Imports"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("import")]
        public ImportCollection Imports {
            get { if (imports == null) imports = new ImportCollection(this); return imports; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Types"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("types")]
        public Types Types {
            get { if (types == null) types = new Types(); return types; }
            set { types = value; }
        }

        private bool ShouldSerializeTypes() { return Types.HasItems(); }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Messages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("message")]
        public MessageCollection Messages {
            get { if (messages == null) messages = new MessageCollection(this); return messages; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.PortTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("portType")]
        public PortTypeCollection PortTypes {
            get { if (portTypes == null) portTypes = new PortTypeCollection(this); return portTypes; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Bindings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("binding")]
        public BindingCollection Bindings {
            get { if (bindings == null) bindings = new BindingCollection(this); return bindings; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Services"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("service")]
        public ServiceCollection Services {
            get { if (services == null) services = new ServiceCollection(this); return services; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescriptionFormatExtensionCollection Extensions {
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.TargetNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("targetNamespace")]
        public string TargetNamespace {
            get { return targetNamespace; }
            set { targetNamespace = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NMTOKEN")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        // This is a special serializer that hardwires to the generated
        // ServiceDescriptionSerializer. To regenerate the serializer
        // Turn on KEEPTEMPFILES 
        // Restart server
        // Run wsdl as follows
        //   wsdl <URL_FOR_VALID_ASMX_FILE>?wsdl
        // Goto windows temp dir (usually \winnt\temp)
        // and get the latest generated .cs file
        // Change namespace to 'System.Web.Services.Description'
        // Change class names to ServiceDescriptionSerializationWriter
        // and ServiceDescriptionSerializationReader
        // Make the classes internal
        // Ensure the public Write method is Write108_definitions (If not
        // change Serialize to call the new one)
        // Ensure the public Read method is Read109_definitions (If not
        // change Deserialize to call the new one)
        internal class ServiceDescriptionSerializer : XmlSerializer {
            protected override XmlSerializationReader CreateReader() {
                return new ServiceDescriptionSerializationReader();
            }
            protected override XmlSerializationWriter CreateWriter() {
                return new ServiceDescriptionSerializationWriter();
            }
            public override bool CanDeserialize(System.Xml.XmlReader xmlReader){
                return xmlReader.IsStartElement("definitions", "http://schemas.xmlsoap.org/wsdl/");
            }
            protected override void Serialize(Object objectToSerialize, XmlSerializationWriter writer){
                ((ServiceDescriptionSerializationWriter)writer).Write108_definitions(objectToSerialize);
            }
            protected override object Deserialize(XmlSerializationReader reader){
                return ((ServiceDescriptionSerializationReader)reader).Read109_definitions();
            }
        }
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Serializer"]/*' />
        /// <devdoc>
        /// Returns the serializer for processing web service calls.  The serializer is customized according
        /// to settings in config.web.
        /// <internalonly/>
        /// <internalonly/>
        /// </devdoc>
        [XmlIgnore]
        public static XmlSerializer Serializer {
            get { 
                if (serializer == null) {
                    WebServicesConfiguration config = WebServicesConfiguration.Current;
                    XmlAttributeOverrides overrides = new XmlAttributeOverrides();
                    XmlSerializerNamespaces ns = new XmlSerializerNamespaces();
                    ns.Add("s", XmlSchema.Namespace);
                    WebServicesConfiguration.LoadXmlFormatExtensions(config.ServiceDescriptionFormatExtensionTypes, overrides, ns);
                    namespaces = ns;
                    if (config.ServiceDescriptionExtended)
                        serializer = new XmlSerializer(typeof(ServiceDescription), overrides);
                    else
                        serializer = new ServiceDescriptionSerializer();
                }
                return serializer;
            }
        }

        internal string AppSettingBaseUrl {
            get { return appSettingBaseUrl; }
            set { appSettingBaseUrl = value; }
        }

        internal string AppSettingUrlKey {
            get { return appSettingUrlKey; }
            set { appSettingUrlKey = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static ServiceDescription Read(TextReader textReader) {
            XmlTextReader reader = new XmlTextReader(textReader);	
            reader.WhitespaceHandling = WhitespaceHandling.Significant;
            reader.XmlResolver = null;
            return Read(reader);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Read1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static ServiceDescription Read(Stream stream) {
            XmlTextReader reader = new XmlTextReader(stream);
            reader.WhitespaceHandling = WhitespaceHandling.Significant;
            reader.XmlResolver = null;
            return Read(reader);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Read2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static ServiceDescription Read(XmlReader reader) {
            return (ServiceDescription)Serializer.Deserialize(reader);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Read3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static ServiceDescription Read(string fileName) {
            StreamReader reader = new StreamReader(fileName, Encoding.Default, true);
            try {
                return Read(reader);
            }
            finally {
                reader.Close();
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.CanRead"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool CanRead(XmlReader reader) {
            return Serializer.CanDeserialize(reader);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Write"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(string fileName) {
            StreamWriter writer = new StreamWriter(fileName);
            try {
                Write(writer);
            }
            finally {
                writer.Close();
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Write1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(TextWriter writer) {
            XmlTextWriter xmlWriter = new XmlTextWriter(writer);
            xmlWriter.Formatting = Formatting.Indented;
            xmlWriter.Indentation = 2;
            Write(xmlWriter);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Write2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(Stream stream) {
            TextWriter writer = new StreamWriter(stream);
            Write(writer);
            writer.Flush();
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescription.Write3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(XmlWriter writer) {
            XmlSerializer serializer = Serializer;
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces(namespaces);
            for (int i = 0; i < Types.Schemas.Count; i++) {
                string tns = Types.Schemas[i].TargetNamespace;
                if (tns != null && tns.Length > 0) {
                    ns.Add("s" + i.ToString(), tns);
                }
            }
            for (int i = 0; i < Imports.Count; i++) {
                Import import = Imports[i];
                if (import.Namespace.Length > 0) {
                    ns.Add("i" + i.ToString(), import.Namespace);
                }
            }
            if (this.TargetNamespace != null && this.TargetNamespace.Length != 0) {
                ns.Add("tns", this.TargetNamespace);
            }
            serializer.Serialize(writer, this, ns);
        }
    }


    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Import"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class Import : DocumentableItem {
        string ns;
        string location;
        ServiceDescription parent;

        internal void SetParent(ServiceDescription parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Import.ServiceDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription ServiceDescription {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Import.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("namespace")]
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Import.Location"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("location")]
        public string Location {
            get { return location == null ? string.Empty : location; }
            set { location = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="DocumentableItem"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class DocumentableItem {
        string documentation; 

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="DocumentableItem.Documentation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("documentation"), DefaultValue("")]
        public string Documentation {
            get { return documentation == null ? string.Empty : documentation; }
            set { documentation = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Port"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class Port : DocumentableItem {
        ServiceDescriptionFormatExtensionCollection extensions;
        string name;
        XmlQualifiedName binding = XmlQualifiedName.Empty;
        Service parent;

        internal void SetParent(Service parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Port.Service"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Service Service {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Port.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescriptionFormatExtensionCollection Extensions {
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Port.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NCName")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Port.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("binding")]
        public XmlQualifiedName Binding {
            get { return binding; }
            set { binding = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Service"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class Service : DocumentableItem {
        ServiceDescriptionFormatExtensionCollection extensions;
        PortCollection ports;
        string name;
        ServiceDescription parent;

        internal void SetParent(ServiceDescription parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Service.ServiceDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription ServiceDescription {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Service.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescriptionFormatExtensionCollection Extensions {
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Service.Ports"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("port")]
        public PortCollection Ports {
            get { if (ports == null) ports = new PortCollection(this); return ports; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Service.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NCName")]
        public string Name {
            get { return name; }
            set { name = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBinding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class FaultBinding : MessageBinding {
        ServiceDescriptionFormatExtensionCollection extensions;

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBinding.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override ServiceDescriptionFormatExtensionCollection Extensions { 
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageBinding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class MessageBinding : DocumentableItem {
        OperationBinding parent;
        string name;

        internal void SetParent(OperationBinding parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageBinding.OperationBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationBinding OperationBinding {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageBinding.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NMTOKEN")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageBinding.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public abstract ServiceDescriptionFormatExtensionCollection Extensions { get; }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="InputBinding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class InputBinding : MessageBinding {
        ServiceDescriptionFormatExtensionCollection extensions; 

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="InputBinding.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override ServiceDescriptionFormatExtensionCollection Extensions { 
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OutputBinding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class OutputBinding : MessageBinding {
        ServiceDescriptionFormatExtensionCollection extensions; 

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OutputBinding.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override ServiceDescriptionFormatExtensionCollection Extensions { 
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBinding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class OperationBinding : DocumentableItem {
        ServiceDescriptionFormatExtensionCollection extensions; 
        string name;
        FaultBindingCollection faults;
        InputBinding input;
        OutputBinding output;
        Binding parent;

        internal void SetParent(Binding parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBinding.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Binding Binding {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBinding.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NCName")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBinding.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescriptionFormatExtensionCollection Extensions { 
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBinding.Input"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("input")]
        public InputBinding Input {
            get { return input; }
            set { input = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBinding.Output"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("output")]
        public OutputBinding Output {
            get { return output; }
            set { output = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBinding.Faults"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("fault")]
        public FaultBindingCollection Faults {
            get { if (faults == null) faults = new FaultBindingCollection(this); return faults; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Binding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class Binding : DocumentableItem {
        ServiceDescriptionFormatExtensionCollection extensions; 
        OperationBindingCollection operations; 
        string name;
        XmlQualifiedName type = XmlQualifiedName.Empty;
        ServiceDescription parent;

        internal void SetParent(ServiceDescription parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Binding.ServiceDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription ServiceDescription {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Binding.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescriptionFormatExtensionCollection Extensions { 
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Binding.Operations"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("operation")]
        public OperationBindingCollection Operations {
            get { if (operations == null) operations = new OperationBindingCollection(this); return operations; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Binding.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NCName")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Binding.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("type")]
        public XmlQualifiedName Type {
            get { 
                if ((object)type == null) return XmlQualifiedName.Empty;
                return type; 
            }
            set { type = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessage"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class OperationMessage : DocumentableItem {
        string name;
        XmlQualifiedName message = XmlQualifiedName.Empty;
        Operation parent;

        internal void SetParent(Operation parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessage.Operation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Operation Operation {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessage.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NMTOKEN")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessage.Message"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("message")]
        public XmlQualifiedName Message {
            get { return message; }
            set { message = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFault"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class OperationFault : OperationMessage {
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationInput"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class OperationInput : OperationMessage {
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationOutput"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class OperationOutput : OperationMessage {
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class Operation : DocumentableItem {
        string name;
        string[] parameters;
        OperationMessageCollection messages;
        OperationFaultCollection faults;
        PortType parent;

        internal void SetParent(PortType parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation.PortType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PortType PortType {
            get { return parent; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NCName")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation.ParameterOrderString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("parameterOrder"), DefaultValue("")]
        public string ParameterOrderString {
            get { 
                if (parameters == null) return string.Empty;
                StringBuilder builder = new StringBuilder();
                for (int i = 0; i < parameters.Length; i++) {
                    if (i > 0) builder.Append(' ');
                    builder.Append(parameters[i]);
                }
                return builder.ToString(); 
            }
            set {
                if (value == null)
                    parameters = null;
                else
                    parameters = value.Split(new char[] {' '});
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation.ParameterOrder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public string[] ParameterOrder {
            get { return parameters; }
            set { parameters = value; }
        }


        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation.Messages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("input", typeof(OperationInput)), 
        XmlElement("output", typeof(OperationOutput))]
        public OperationMessageCollection Messages {
            get { if (messages == null) messages = new OperationMessageCollection(this); return messages; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation.Faults"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("fault")]
        public OperationFaultCollection Faults {
            get { if (faults == null) faults = new OperationFaultCollection(this); return faults; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Operation.IsBoundBy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsBoundBy(OperationBinding operationBinding) {
            if (operationBinding.Name != Name) return false;
            OperationMessage input = Messages.Input;
            if (input != null) {
                if (operationBinding.Input == null) return false;

                string portTypeInputName = GetMessageName(Name, input.Name, true);
                string bindingInputName = GetMessageName(operationBinding.Name, operationBinding.Input.Name, true);
                if (bindingInputName != portTypeInputName) return false;
            }
            else if (operationBinding.Input != null)
                return false;
                
            OperationMessage output = Messages.Output;
            if (output != null) {
                if (operationBinding.Output == null) return false;

                string portTypeOutputName = GetMessageName(Name, output.Name, false);
                string bindingOutputName = GetMessageName(operationBinding.Name, operationBinding.Output.Name, false);
                if (bindingOutputName != portTypeOutputName) return false;
            }
            else if (operationBinding.Output != null)
                return false;
            return true;
        }

        private string GetMessageName(string operationName, string messageName, bool isInput){
            if (messageName != null && messageName.Length > 0)
                return messageName;
            
            switch (Messages.Flow) {
                case OperationFlow.RequestResponse:
                    if (isInput)
                        return operationName + "Request";
                    return operationName + "Response";
                case OperationFlow.OneWay:
                    if (isInput)
                        return operationName;
                    Debug.Assert(isInput == true, "Oneway flow cannot have an output message");
                    return null;
                /*Cases not supported
                case OperationFlow.SolicitResponse:
                    if (isInput)
                        return operationName + "Solicit";
                    return operationName + "Response";
                case OperationFlow.Notification:
                    if (!isInput)
                        return operationName;
                    Debug.Assert(isInput == false, "Notification flow cannot have an input message");
                    return null;
                 */
            }
            Debug.Assert(false, "Unknown message flow");
            return null;
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class PortType : DocumentableItem {
        string name;
        OperationCollection operations;
        ServiceDescription parent;

        internal void SetParent(ServiceDescription parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortType.ServiceDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription ServiceDescription {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortType.Operations"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("operation")]
        public OperationCollection Operations {
            get { if (operations == null) operations = new OperationCollection(this); return operations; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortType.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NCName")]
        public string Name {
            get { return name; }
            set { name = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Message"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class Message : DocumentableItem {
        string name;
        MessagePartCollection parts;
        ServiceDescription parent;

        internal void SetParent(ServiceDescription parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Message.ServiceDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription ServiceDescription {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Message.Parts"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("part")]
        public MessagePartCollection Parts {
            get { if (parts == null) parts = new MessagePartCollection(this); return parts; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Message.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NCName")]
        public string Name {
            get { return name; }
            set { name = value; }
        }


        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Message.FindPartsByName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessagePart[] FindPartsByName(string[] partNames) {
            MessagePart[] partArray = new MessagePart[partNames.Length];
            for (int i = 0; i < partNames.Length; i++) {
                partArray[i] = FindPartByName(partNames[i]);
            }
            return partArray;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Message.FindPartByName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessagePart FindPartByName(string partName) {
            for (int i = 0; i < parts.Count; i++) {
                MessagePart part = parts[i];
                if (part.Name == partName) return part;
            }
            throw new ArgumentException(Res.GetString(Res.MissingMessagePartForMessageFromNamespace3, partName, Name, ServiceDescription.TargetNamespace), "partName");
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePart"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class MessagePart : DocumentableItem {
        string name;
        XmlQualifiedName type = XmlQualifiedName.Empty;
        XmlQualifiedName element = XmlQualifiedName.Empty;
        Message parent;

        internal void SetParent(Message parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePart.Message"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message Message {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePart.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name", DataType="NMTOKEN")]
        public string Name {
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePart.Element"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("element")]
        public XmlQualifiedName Element {
            get { return element; }
            set { element = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePart.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("type")]
        public XmlQualifiedName Type {
            get { 
                if ((object)type == null) return XmlQualifiedName.Empty;
                return type; 
            }
            set { type = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Types"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class Types : DocumentableItem {
        XmlSchemas schemas;
        ServiceDescriptionFormatExtensionCollection extensions;

        internal bool HasItems() { 
            return (schemas != null && schemas.Count > 0) ||
                (extensions != null && extensions.Count > 0);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Types.Schemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("schema", typeof(XmlSchema), Namespace=XmlSchema.Namespace)]
        public XmlSchemas Schemas {
            get { if (schemas == null) schemas = new XmlSchemas(); return schemas; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="Types.Extensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescriptionFormatExtensionCollection Extensions {
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class ServiceDescriptionFormatExtensionCollection : ServiceDescriptionBaseCollection {
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.ServiceDescriptionFormatExtensionCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionFormatExtensionCollection(object parent) : base(parent) { }

        ArrayList handledElements;
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object this[int index] {
            get { return (object)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(object extension) {
            return List.Add(extension);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, object extension) {
            List.Insert(index, extension);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(object extension) {
            return List.IndexOf(extension);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(object extension) {
            return List.Contains(extension);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(object extension) {
            List.Remove(extension);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(object[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.Find"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Find(Type type) {
            for (int i = 0; i < List.Count; i++) {
                object item = List[i];
                if (type.IsAssignableFrom(item.GetType())) {
                    ((ServiceDescriptionFormatExtension)item).Handled = true;
                    return item;
                }
            }
            return null;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.FindAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object[] FindAll(Type type) {
            ArrayList list = new ArrayList();
            for (int i = 0; i < List.Count; i++) {
                object item = List[i];
                if (type.IsAssignableFrom(item.GetType())) {
                    ((ServiceDescriptionFormatExtension)item).Handled = true;
                    list.Add(item);
                }
            }
            return (object[])list.ToArray(type);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.Find1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElement Find(string name, string ns) {
            for (int i = 0; i < List.Count; i++) {
                XmlElement element = List[i] as XmlElement;
                if (element != null && element.LocalName == name && element.NamespaceURI == ns) {
                    SetHandled(element);
                    return element;
                }
            }
            return null;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.FindAll1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElement[] FindAll(string name, string ns) {
            ArrayList list = new ArrayList();
            for (int i = 0; i < List.Count; i++) {
                XmlElement element = List[i] as XmlElement;
                if (element != null && element.LocalName == name && element.NamespaceURI == ns) {
                    SetHandled(element);
                    list.Add(element);
                }
            }
            return (XmlElement[])list.ToArray(typeof(XmlElement));
        }

        void SetHandled(XmlElement element) {
            if (handledElements == null) 
                handledElements = new ArrayList();
            if (!handledElements.Contains(element))
                handledElements.Add(element);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.IsHandled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsHandled(object item) {
            if (item is XmlElement)
                return IsHandled((XmlElement)item);
            else
                return ((ServiceDescriptionFormatExtension)item).Handled;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.IsRequired"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsRequired(object item) {
            if (item is XmlElement)
                return IsRequired((XmlElement)item);
            else
                return ((ServiceDescriptionFormatExtension)item).Required;
        }

        bool IsHandled(XmlElement element) {
            if (handledElements == null) return false;
            return handledElements.Contains(element);
        }

        bool IsRequired(XmlElement element) {
            XmlAttribute requiredAttr = element.Attributes["required", ServiceDescription.Namespace];
            if (requiredAttr == null || requiredAttr.Value == null) return false; // not required, by default
            return XmlConvert.ToBoolean(requiredAttr.Value);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            if (value is ServiceDescriptionFormatExtension) ((ServiceDescriptionFormatExtension)value).SetParent(parent);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtensionCollection.OnValidate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnValidate(object value) {
            if (!(value is XmlElement || value is ServiceDescriptionFormatExtension)) 
                throw new ArgumentException(Res.GetString(Res.OnlyXmlElementsOrTypesDerivingFromServiceDescriptionFormatExtension0), "value");
            base.OnValidate(value);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtension"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class ServiceDescriptionFormatExtension {
        object parent; 
        bool required;
        bool handled;

        internal void SetParent(object parent) {
            this.parent = parent;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtension.Parent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Parent {
            get { return parent; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtension.Required"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("required", Namespace=ServiceDescription.Namespace), DefaultValue(false)]
        public bool Required {
            get { return required; }
            set { required = value; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionFormatExtension.Handled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public bool Handled {
            get { return handled; }
            set { handled = value; }
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFlow"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum OperationFlow {
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFlow.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None,
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFlow.OneWay"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OneWay,
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFlow.Notification"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Notification,
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFlow.RequestResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RequestResponse,
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFlow.SolicitResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SolicitResponse,
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class OperationMessageCollection : ServiceDescriptionBaseCollection {
        internal OperationMessageCollection(Operation operation) : base(operation) { }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationMessage this[int index] {
            get { return (OperationMessage)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(OperationMessage operationMessage) {
            return List.Add(operationMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, OperationMessage operationMessage) {
            List.Insert(index, operationMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(OperationMessage operationMessage) {
            return List.IndexOf(operationMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(OperationMessage operationMessage) {
            return List.Contains(operationMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(OperationMessage operationMessage) {
            List.Remove(operationMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(OperationMessage[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.Input"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationInput Input {
            get { 
                for (int i = 0; i < List.Count; i++) {
                    OperationInput input = List[i] as OperationInput;
                    if (input != null) {
                        return input;
                    }
                }
                return null;
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.Output"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationOutput Output {
            get {
                for (int i = 0; i < List.Count; i++) {
                    OperationOutput output = List[i] as OperationOutput;
                    if (output != null) {
                        return output;
                    }
                }
                return null;
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.Flow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationFlow Flow {
            get {
                if (List.Count == 0) {
                    return OperationFlow.None;
                }
                else if (List.Count == 1) {
                    if (List[0] is OperationInput) {
                        return OperationFlow.OneWay;
                    }
                    else {
                        return OperationFlow.Notification;
                    }
                }
                else {
                    if (List[0] is OperationInput) {
                        return OperationFlow.RequestResponse;
                    }
                    else {
                        return OperationFlow.SolicitResponse;
                    }
                }
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((OperationMessage)value).SetParent((Operation)parent);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.OnInsert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnInsert(int index, object value) {
            if (Count > 1 || (Count == 1 && value.GetType() == List[0].GetType()))
                throw new InvalidOperationException(Res.GetString(Res.WebDescriptionTooManyMessages));
            
            base.OnInsert(index, value);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.OnSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnSet(int index, object oldValue, object newValue) {
            if (oldValue.GetType() != newValue.GetType()) throw new InvalidOperationException(Res.WebDescriptionTooManyMessages);
            base.OnSet(index, oldValue, newValue);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationMessageCollection.OnValidate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnValidate(object value) {
            if (!(value is OperationInput || value is OperationOutput))
                throw new ArgumentException(Res.GetString(Res.OnlyOperationInputOrOperationOutputTypes), "value");
            base.OnValidate(value);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class ImportCollection : ServiceDescriptionBaseCollection {
        internal ImportCollection(ServiceDescription serviceDescription) : base(serviceDescription) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Import this[int index] {
            get { return (Import)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(Import import) {
            return List.Add(import);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, Import import) {
            List.Insert(index, import);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(Import import) {
            return List.IndexOf(import);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(Import import) {
            return List.Contains(import);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(Import import) {
            List.Remove(import);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Import[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ImportCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((Import)value).SetParent((ServiceDescription)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class MessageCollection : ServiceDescriptionBaseCollection {
        internal MessageCollection(ServiceDescription serviceDescription) : base(serviceDescription) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message this[int index] {
            get { return (Message)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(Message message) {
            return List.Add(message);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, Message message) {
            List.Insert(index, message);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(Message message) {
            return List.IndexOf(message);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(Message message) {
            return List.Contains(message);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(Message message) {
            List.Remove(message);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Message[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message this[string name] {
            get { return (Message)Table[name]; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((Message)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessageCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((Message)value).SetParent((ServiceDescription)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class PortCollection : ServiceDescriptionBaseCollection {
        internal PortCollection(Service service) : base(service) { }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Port this[int index] {
            get { return (Port)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(Port port) {
            return List.Add(port);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, Port port) {
            List.Insert(index, port);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(Port port) {
            return List.IndexOf(port);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(Port port) {
            return List.Contains(port);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(Port port) {
            List.Remove(port);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Port[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Port this[string name] {
            get { return (Port)Table[name]; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((Port)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((Port)value).SetParent((Service)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class PortTypeCollection : ServiceDescriptionBaseCollection {
        internal PortTypeCollection(ServiceDescription serviceDescription) : base(serviceDescription) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PortType this[int index] {
            get { return (PortType)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(PortType portType) {
            return List.Add(portType);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, PortType portType) {
            List.Insert(index, portType);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(PortType portType) {
            return List.IndexOf(portType);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(PortType portType) {
            return List.Contains(portType);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(PortType portType) {
            List.Remove(portType);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(PortType[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PortType this[string name] {
            get { return (PortType)Table[name]; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((PortType)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="PortTypeCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((PortType)value).SetParent((ServiceDescription)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class BindingCollection : ServiceDescriptionBaseCollection {
        internal BindingCollection(ServiceDescription serviceDescription) : base(serviceDescription) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Binding this[int index] {
            get { return (Binding)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(Binding binding) {
            return List.Add(binding);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, Binding binding) {
            List.Insert(index, binding);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(Binding binding) {
            return List.IndexOf(binding);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(Binding binding) {
            return List.Contains(binding);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(Binding binding) {
            List.Remove(binding);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Binding[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Binding this[string name] {
            get { return (Binding)Table[name]; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((Binding)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="BindingCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((Binding)value).SetParent((ServiceDescription)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class ServiceCollection : ServiceDescriptionBaseCollection {
        internal ServiceCollection(ServiceDescription serviceDescription) : base(serviceDescription) { }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Service this[int index] {
            get { return (Service)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(Service service) {
            return List.Add(service);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, Service service) {
            List.Insert(index, service);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(Service service) {
            return List.IndexOf(service);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(Service service) {
            return List.Contains(service);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(Service service) {
            List.Remove(service);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Service[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Service this[string name] {
            get { return (Service)Table[name]; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((Service)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((Service)value).SetParent((ServiceDescription)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class MessagePartCollection : ServiceDescriptionBaseCollection {
        internal MessagePartCollection(Message message) : base(message) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessagePart this[int index] {
            get { return (MessagePart)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(MessagePart messagePart) {
            return List.Add(messagePart);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, MessagePart messagePart) {
            List.Insert(index, messagePart);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(MessagePart messagePart) {
            return List.IndexOf(messagePart);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(MessagePart messagePart) {
            return List.Contains(messagePart);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(MessagePart messagePart) {
            List.Remove(messagePart);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(MessagePart[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessagePart this[string name] {
            get { return (MessagePart)Table[name]; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((MessagePart)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="MessagePartCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((MessagePart)value).SetParent((Message)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class OperationBindingCollection : ServiceDescriptionBaseCollection {
        internal OperationBindingCollection(Binding binding) : base(binding) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationBinding this[int index] {
            get { return (OperationBinding)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(OperationBinding bindingOperation) {
            return List.Add(bindingOperation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, OperationBinding bindingOperation) {
            List.Insert(index, bindingOperation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(OperationBinding bindingOperation) {
            return List.IndexOf(bindingOperation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(OperationBinding bindingOperation) {
            return List.Contains(bindingOperation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(OperationBinding bindingOperation) {
            List.Remove(bindingOperation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(OperationBinding[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationBindingCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((OperationBinding)value).SetParent((Binding)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class FaultBindingCollection : ServiceDescriptionBaseCollection {
        internal FaultBindingCollection(OperationBinding operationBinding) : base(operationBinding) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public FaultBinding this[int index] {
            get { return (FaultBinding)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(FaultBinding bindingOperationFault) {
            return List.Add(bindingOperationFault);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, FaultBinding bindingOperationFault) {
            List.Insert(index, bindingOperationFault);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(FaultBinding bindingOperationFault) {
            return List.IndexOf(bindingOperationFault);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(FaultBinding bindingOperationFault) {
            return List.Contains(bindingOperationFault);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(FaultBinding bindingOperationFault) {
            List.Remove(bindingOperationFault);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(FaultBinding[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public FaultBinding this[string name] {
            get { return (FaultBinding)Table[name]; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((FaultBinding)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="FaultBindingCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((FaultBinding)value).SetParent((OperationBinding)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class OperationCollection : ServiceDescriptionBaseCollection {
        internal OperationCollection(PortType portType) : base(portType) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Operation this[int index] {
            get { return (Operation)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(Operation operation) {
            return List.Add(operation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, Operation operation) {
            List.Insert(index, operation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(Operation operation) {
            return List.IndexOf(operation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(Operation operation) {
            return List.Contains(operation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(Operation operation) {
            List.Remove(operation);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Operation[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((Operation)value).SetParent((PortType)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class OperationFaultCollection : ServiceDescriptionBaseCollection {
        internal OperationFaultCollection(Operation operation) : base(operation) { }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationFault this[int index] {
            get { return (OperationFault)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(OperationFault operationFaultMessage) {
            return List.Add(operationFaultMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, OperationFault operationFaultMessage) {
            List.Insert(index, operationFaultMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(OperationFault operationFaultMessage) {
            return List.IndexOf(operationFaultMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(OperationFault operationFaultMessage) {
            return List.Contains(operationFaultMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(OperationFault operationFaultMessage) {
            List.Remove(operationFaultMessage);
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(OperationFault[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationFault this[string name] {
            get { return (OperationFault)Table[name]; }
        }
        
        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            return ((OperationFault)value).Name;
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="OperationFaultCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetParent(object value, object parent) {
            ((OperationFault)value).SetParent((Operation)parent);
        }
    }

    /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class ServiceDescriptionBaseCollection : CollectionBase {
        Hashtable table; // CONSIDER, better implementation
        object parent;

        internal ServiceDescriptionBaseCollection(object parent) {
            this.parent = parent;
        }

        void SetParents(object parent) {
            for (int i = 0; i < List.Count; i++) {
                SetParent(List[i], parent);
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection.Table"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual IDictionary Table { 
            get { if (table == null) table = new Hashtable(); return table; }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string GetKey(object value) {
            return null; // returning null means there is no key
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection.SetParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void SetParent(object value, object parent) {
            // default is that the item has no parent
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection.OnInsertComplete"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnInsertComplete(int index, object value) {
            AddValue(value);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection.OnRemove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnRemove(int index, object value) {
            RemoveValue(value);
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection.OnClear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnClear() {
            for (int i = 0; i < List.Count; i++) {
                RemoveValue(List[i]);
            }
        }

        /// <include file='doc\ServiceDescription.uex' path='docs/doc[@for="ServiceDescriptionBaseCollection.OnSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnSet(int index, object oldValue, object newValue) {
            RemoveValue(oldValue);
            AddValue(newValue);
        }
       
        void AddValue(object value) {
            string key = GetKey(value);
            if (key != null) {
                try {
                    Table.Add(key, value);
                }
                catch (Exception e) {
                    if (Table[key] != null) {
                        throw new ArgumentException(GetDuplicateMessage(value.GetType(), key.ToString()), e.InnerException);
                    }
                    else {
                        throw e;
                    }
                }
            }
            SetParent(value, parent);
        }

        void RemoveValue(object value) {
            string key = GetKey(value);
            if (key != null) Table.Remove(key);
            SetParent(value, null);
        }

        static string GetDuplicateMessage(Type type, string elemName) {
            string message = null;
            if (type == typeof(ServiceDescriptionFormatExtension)) 
                message = Res.GetString(Res.WebDuplicateFormatExtension, elemName);
            else if (type == typeof(OperationMessage)) 
                message = Res.GetString(Res.WebDuplicateOperationMessage, elemName);
            else if (type == typeof(Import)) 
                message = Res.GetString(Res.WebDuplicateImport, elemName);
            else if (type == typeof(Message)) 
                message = Res.GetString(Res.WebDuplicateMessage, elemName);
            else if (type == typeof(Port)) 
                message = Res.GetString(Res.WebDuplicatePort, elemName);
            else if (type == typeof(PortType)) 
                message = Res.GetString(Res.WebDuplicatePortType, elemName);
            else if (type == typeof(Binding)) 
                message = Res.GetString(Res.WebDuplicateBinding, elemName);
            else if (type == typeof(Service)) 
                message = Res.GetString(Res.WebDuplicateService, elemName);
            else if (type == typeof(MessagePart)) 
                message = Res.GetString(Res.WebDuplicateMessagePart, elemName);
            else if (type == typeof(OperationBinding)) 
                message = Res.GetString(Res.WebDuplicateOperationBinding, elemName);
            else if (type == typeof(FaultBinding)) 
                message = Res.GetString(Res.WebDuplicateFaultBinding, elemName);
            else if (type == typeof(Operation)) 
                message = Res.GetString(Res.WebDuplicateOperation, elemName);
            else if (type == typeof(OperationFault)) 
                message = Res.GetString(Res.WebDuplicateOperationFault, elemName);
            else
                message = Res.GetString(Res.WebDuplicateUnknownElement, type, elemName);

            return message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soap12formatextensions.cs ===
//------------------------------------------------------------------------------
// <copyright file="Soap12FormatExtensions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Soap12FormatExtensions.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Description {
    using System.Xml;
    using System.Xml.Serialization;
    using System.ComponentModel;
    using System.Text;
    using System.Web.Services.Configuration;
    using System.Web.Services.Protocols;

    /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12Binding"]/*' />
    [XmlFormatExtension("binding", Soap12Binding.Namespace, typeof(Binding))]
    [XmlFormatExtensionPrefix("soap12", Soap12Binding.Namespace)]
    [XmlFormatExtensionPrefix("soap12enc", Soap12.Namespace)]
    internal sealed class Soap12Binding : SoapBinding {

        /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12Binding.Namespace"]/*' />
        public new const string Namespace="http://schemas.xmlsoap.org/wsdl/soap12/";
        /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12Binding.HttpTransport"]/*' />
        public new const string HttpTransport = "http://schemas.xmlsoap.org/soap/http";
    }

    /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12OperationBinding"]/*' />
    [XmlFormatExtension("operation", Soap12Binding.Namespace, typeof(OperationBinding))]
    internal sealed class Soap12OperationBinding : SoapOperationBinding {
        bool soapActionRequired;
        Soap12OperationBinding duplicateBySoapAction;
        Soap12OperationBinding duplicateByRequestElement;
        SoapReflectedMethod method;

        /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12OperationBinding.SoapActionRequired"]/*' />
        [XmlAttribute("soapActionRequired"), DefaultValue(false)]
        public bool SoapActionRequired {
            get { return soapActionRequired; }
            set { soapActionRequired = value; }
        }

        // these are used by Soap12ProtocolReflector in WSDL generation
        internal SoapReflectedMethod Method {
            get { return method; }
            set { method = value; }
        }
        
        internal Soap12OperationBinding DuplicateBySoapAction {
            get { return duplicateBySoapAction; }
            set { duplicateBySoapAction = value; }
        }

        internal Soap12OperationBinding DuplicateByRequestElement {
            get { return duplicateByRequestElement; }
            set { duplicateByRequestElement = value; }
        }
    }

    /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12BodyBinding"]/*' />
    [XmlFormatExtension("body", Soap12Binding.Namespace, typeof(InputBinding), typeof(OutputBinding), typeof(MimePart))]
    internal sealed class Soap12BodyBinding : SoapBodyBinding {
    }

    /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12FaultBinding"]/*' />
    [XmlFormatExtension("fault", Soap12Binding.Namespace, typeof(FaultBinding))]
    internal sealed class Soap12FaultBinding : SoapFaultBinding {
    }

    /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12HeaderBinding"]/*' />
    [XmlFormatExtension("header", Soap12Binding.Namespace, typeof(InputBinding), typeof(OutputBinding))]
    internal sealed class Soap12HeaderBinding : SoapHeaderBinding {
    }

    /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12HeaderFaultBinding"]/*' />
    internal sealed class Soap12HeaderFaultBinding : SoapHeaderFaultBinding {
    }

    /// <include file='doc\Soap12FormatExtensions.uex' path='docs/doc[@for="Soap12AddressBinding"]/*' />
    [XmlFormatExtension("address", Soap12Binding.Namespace, typeof(Port))]
    internal sealed class Soap12AddressBinding : SoapAddressBinding {
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soap12protocolimporter.cs ===
//------------------------------------------------------------------------------
//  <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//     Copyright (c) Microsoft Corporation. All Rights Reserved.                
//     Information Contained Herein is Proprietary and Confidential.            
//  </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;
    using System.Web.Services.Configuration;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Security.Permissions;
    using System.Globalization;
    
    /// <include file='doc\Soap12ProtocolImporter.uex' path='docs/doc[@for="Soap12ProtocolImporter"]/*' />
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    internal class Soap12ProtocolImporter : SoapProtocolImporter {

        public override string ProtocolName {
            get { return "Soap12"; }
        }

        protected override bool IsBindingSupported() {
            Soap12Binding soapBinding = (Soap12Binding)Binding.Extensions.Find(typeof(Soap12Binding));
            if (soapBinding == null) return false;

            if (GetTransport(soapBinding.Transport) == null) {
                UnsupportedBindingWarning(Res.GetString(Res.ThereIsNoSoapTransportImporterThatUnderstands1, soapBinding.Transport));
                return false;
            }
                            
            return true;
        }

        protected override bool IsSoapEncodingPresent(string uriList) {
            int iStart = 0;
            do {
                iStart = uriList.IndexOf(Soap12.Encoding, iStart);
                if (iStart < 0)
                    break;
                int iEnd = iStart + Soap12.Encoding.Length;
                if (iStart == 0 || uriList[iStart-1] == ' ')
                    if (iEnd == uriList.Length || uriList[iEnd] == ' ')
                        return true;
                iStart = iEnd;
            } while (iStart < uriList.Length);

            // not soap 1.2 encoding. let's detect the soap 1.1 encoding and give a better error message.
            // otherwise just default to the normal "encoding style not supported" error.
            if (base.IsSoapEncodingPresent(uriList))
                UnsupportedOperationBindingWarning(Res.GetString(Res.WebSoap11EncodingStyleNotSupported1, Soap12.Encoding));

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soap12protocolreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="Soap12ProtocolReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.Web.Services.Configuration;

    internal class Soap12ProtocolReflector : SoapProtocolReflector {
        Hashtable requestElements;
        Hashtable actions;
        XmlQualifiedName soap11PortType;

        public override string ProtocolName {
            get { return "Soap12"; }
        }

        protected override void BeginClass() {
            requestElements = new Hashtable();
            actions = new Hashtable();
            soap11PortType = null;
            
            base.BeginClass();
        }

        protected override bool ReflectMethod() {
            if (base.ReflectMethod()) {
                if (Binding != null) {
                    // SoapMethod.portType tracks the first portType created for this method
                    // we want to make sure there's only one portType and set of messages per method
                    // so we delete ours if an existing portType already exists for this method.
                    soap11PortType = SoapMethod.portType;
                    if (soap11PortType != Binding.Type)
                        HeaderMessages.Clear();
                }
                return true;
            }
            return false;
        }

        protected override void EndClass() {
            if (PortType == null || Binding == null) return; // external binding;
            
            if (soap11PortType != null && soap11PortType != Binding.Type) {
                // we want to share soap 1.1's portType and messages so we delete ours and reference theirs
                foreach (Operation op in PortType.Operations) {
                    foreach (OperationMessage msg in op.Messages) {
                        ServiceDescription sd = GetServiceDescription(msg.Message.Namespace);
                        if (sd != null) {
                            Message m = sd.Messages[msg.Message.Name];
                            if (m != null)
                                sd.Messages.Remove(m);
                        }
                    }
                }

                Binding.Type = soap11PortType;
                PortType.ServiceDescription.PortTypes.Remove(PortType);
            }
        }

        protected override SoapBinding CreateSoapBinding(SoapBindingStyle style) {
            Soap12Binding soapBinding = new Soap12Binding();
            soapBinding.Transport = Soap12Binding.HttpTransport;
            soapBinding.Style = style;
            return soapBinding;
        }

        protected override SoapAddressBinding CreateSoapAddressBinding(string serviceUrl) {
            Soap12AddressBinding soapAddress = new Soap12AddressBinding();
            soapAddress.Location = serviceUrl;
            return soapAddress;
        }

        protected override SoapOperationBinding CreateSoapOperationBinding(SoapBindingStyle style, string action) {
            Soap12OperationBinding soapOperation = new Soap12OperationBinding();
            soapOperation.SoapAction = action;
            soapOperation.Style = style;
            soapOperation.Method = SoapMethod;

            DealWithAmbiguity(action, SoapMethod.requestElementName.ToString(), soapOperation);
            
            return soapOperation;
        }

        protected override SoapBodyBinding CreateSoapBodyBinding(SoapBindingUse use, string ns) {
            Soap12BodyBinding soapBodyBinding = new Soap12BodyBinding();
            soapBodyBinding.Use = use;
            if (use == SoapBindingUse.Encoded)
                soapBodyBinding.Encoding = Soap12.Encoding;
            soapBodyBinding.Namespace = ns;
            return soapBodyBinding;
        }

        protected override SoapHeaderBinding CreateSoapHeaderBinding(XmlQualifiedName message, string partName, SoapBindingUse use) {
            Soap12HeaderBinding soapHeaderBinding = new Soap12HeaderBinding();
            soapHeaderBinding.Message = message;
            soapHeaderBinding.Part = partName;
            soapHeaderBinding.Use = use;
            if (use == SoapBindingUse.Encoded)
                soapHeaderBinding.Encoding = Soap12.Encoding;
            return soapHeaderBinding;
        }

        private void DealWithAmbiguity(string action, string requestElement, Soap12OperationBinding operation) {

            Soap12OperationBinding duplicateActionOperation = (Soap12OperationBinding)actions[action];
            if (duplicateActionOperation != null) {
                operation.DuplicateBySoapAction = duplicateActionOperation;
                duplicateActionOperation.DuplicateBySoapAction = operation;
                CheckOperationDuplicates(duplicateActionOperation);
            }
            else
                actions[action] = operation;

            Soap12OperationBinding duplicateRequestElementOperation = (Soap12OperationBinding)requestElements[requestElement];
            if (duplicateRequestElementOperation != null) {
                operation.DuplicateByRequestElement = duplicateRequestElementOperation;
                duplicateRequestElementOperation.DuplicateByRequestElement = operation;
                CheckOperationDuplicates(duplicateRequestElementOperation);
            }
            else
                requestElements[requestElement] = operation;

            CheckOperationDuplicates(operation);
        }

        private void CheckOperationDuplicates(Soap12OperationBinding operation) {
            // we require soap action if we can't route on request element 
            if (operation.DuplicateByRequestElement != null) {
                // except if we also can't route on soap action, which is an error
                if (operation.DuplicateBySoapAction != null)
                    throw new InvalidOperationException(Res.GetString(Res.TheMethodsAndUseTheSameRequestElementAndSoapActionXmlns6, operation.Method.name, operation.DuplicateByRequestElement.Method.name, operation.Method.requestElementName.Name, operation.Method.requestElementName.Namespace, operation.DuplicateBySoapAction.Method.name, operation.Method.action));
                else
                    operation.SoapActionRequired = true;
            }
            else
                operation.SoapActionRequired = false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soapextensionimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapExtensionImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {
    using System.CodeDom;
    using System.Security.Permissions;

    /// <include file='doc\SoapExtensionImporter.uex' path='docs/doc[@for="SoapExtensionImporter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public abstract class SoapExtensionImporter {
        SoapProtocolImporter protocolImporter;

        /// <include file='doc\SoapExtensionImporter.uex' path='docs/doc[@for="SoapExtensionImporter.ImportMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void ImportMethod(CodeAttributeDeclarationCollection metadata);

        /// <include file='doc\SoapExtensionImporter.uex' path='docs/doc[@for="SoapExtensionImporter.ImportContext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapProtocolImporter ImportContext {
            get { return protocolImporter; }
            set { protocolImporter = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soapextensionreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapExtensionReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.Security.Permissions;

    /// <include file='doc\SoapExtensionReflector.uex' path='docs/doc[@for="SoapExtensionReflector"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public abstract class SoapExtensionReflector {
        ProtocolReflector protocolReflector;

        /// <include file='doc\SoapExtensionReflector.uex' path='docs/doc[@for="SoapExtensionReflector.ReflectMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void ReflectMethod();

        /// <include file='doc\SoapExtensionReflector.uex' path='docs/doc[@for="SoapExtensionReflector.ReflectionContext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ProtocolReflector ReflectionContext {
            get { return protocolReflector; }
            set { protocolReflector = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soapformatextensions.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapFormatExtensions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   SoapFormatExtensions.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Description {
    using System.Xml;
    using System.Xml.Serialization;
    using System.ComponentModel;
    using System.Text;
    using System.Web.Services.Configuration;

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBinding"]/*' />
    [XmlFormatExtension("binding", SoapBinding.Namespace, typeof(Binding))]
    [XmlFormatExtensionPrefix("soap", SoapBinding.Namespace)]
    [XmlFormatExtensionPrefix("soapenc", "http://schemas.xmlsoap.org/soap/encoding/")]
    public class SoapBinding : ServiceDescriptionFormatExtension {
        SoapBindingStyle style;
        string transport;

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBinding.Namespace"]/*' />
        public const string Namespace="http://schemas.xmlsoap.org/wsdl/soap/";
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBinding.HttpTransport"]/*' />
        public const string HttpTransport = "http://schemas.xmlsoap.org/soap/http";

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBinding.Transport"]/*' />
        [XmlAttribute("transport")]
        public string Transport {
            get { return transport == null ? string.Empty : transport; }
            set { transport = value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBinding.Style"]/*' />
        [XmlAttribute("style"), DefaultValue(SoapBindingStyle.Default)]
        public SoapBindingStyle Style {
            get { return style; }
            set { style =  value; }
        }
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingStyle"]/*' />
    public enum SoapBindingStyle {
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingStyle.Default"]/*' />
        [XmlIgnore]
        Default,
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingStyle.Document"]/*' />
        [XmlEnum("document")]
        Document,
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingStyle.Rpc"]/*' />
        [XmlEnum("rpc")]
        Rpc,
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapOperationBinding"]/*' />
    [XmlFormatExtension("operation", SoapBinding.Namespace, typeof(OperationBinding))]
    public class SoapOperationBinding : ServiceDescriptionFormatExtension {
        string soapAction;
        SoapBindingStyle style;

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapOperationBinding.SoapAction"]/*' />
        [XmlAttribute("soapAction")]
        public string SoapAction {
            get { return soapAction == null ? string.Empty : soapAction; }
            set { soapAction =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapOperationBinding.Style"]/*' />
        [XmlAttribute("style"), DefaultValue(SoapBindingStyle.Default)]
        public SoapBindingStyle Style {
            get { return style; }
            set { style =  value; }
        }
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBodyBinding"]/*' />
    [XmlFormatExtension("body", SoapBinding.Namespace, typeof(InputBinding), typeof(OutputBinding), typeof(MimePart))]
    public class SoapBodyBinding : ServiceDescriptionFormatExtension {
        SoapBindingUse use;
        string ns;
        string encoding;
        string[] parts;

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBodyBinding.Use"]/*' />
        [XmlAttribute("use"), DefaultValue(SoapBindingUse.Default)]
        public SoapBindingUse Use {
            get { return use; }
            set { use =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBodyBinding.Namespace"]/*' />
        [XmlAttribute("namespace"), DefaultValue("")]
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBodyBinding.Encoding"]/*' />
        [XmlAttribute("encodingStyle"), DefaultValue("")]
        public string Encoding {
            get { return encoding == null ? string.Empty : encoding; }
            set { encoding =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBodyBinding.PartsString"]/*' />
        [XmlAttribute("parts", DataType="NMTOKENS")]
        public string PartsString {
            get { 
                if (parts == null) 
                    return null;
                StringBuilder builder = new StringBuilder();
                for (int i = 0; i < parts.Length; i++) {
                    if (i > 0) builder.Append(' ');
                    builder.Append(parts[i]);
                }
                return builder.ToString(); 
            }
            set {
                if (value == null)
                    parts = null;
                else
                    parts = value.Split(new char[] {' '});
            }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBodyBinding.Parts"]/*' />
        [XmlIgnore]
        public string[] Parts {
            get { return parts; }
            set { parts = value; }
        }
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingUse"]/*' />
    public enum SoapBindingUse {
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingUse.Default"]/*' />
        [XmlIgnore]
        Default,
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingUse.Encoded"]/*' />
        [XmlEnum("encoded")]
        Encoded,
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapBindingUse.Literal"]/*' />
        [XmlEnum("literal")]
        Literal,
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapFaultBinding"]/*' />
    [XmlFormatExtension("fault", SoapBinding.Namespace, typeof(FaultBinding))]
    public class SoapFaultBinding : ServiceDescriptionFormatExtension {
        SoapBindingUse use;
        string ns;
        string encoding;

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapFaultBinding.Use"]/*' />
        [XmlAttribute("use"), DefaultValue(SoapBindingUse.Default)]
        public SoapBindingUse Use {
            get { return use; }
            set { use =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapFaultBinding.Namespace"]/*' />
        [XmlAttribute("namespace")]
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapFaultBinding.Encoding"]/*' />
        [XmlAttribute("encodingStyle")]
        public string Encoding {
            get { return encoding == null ? string.Empty : encoding; }
            set { encoding =  value; }
        }
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding"]/*' />
    [XmlFormatExtension("header", SoapBinding.Namespace, typeof(InputBinding), typeof(OutputBinding))]
    public class SoapHeaderBinding : ServiceDescriptionFormatExtension {
        XmlQualifiedName message = XmlQualifiedName.Empty;
        string part;
        SoapBindingUse use;
        string encoding;
        string ns;
        bool mapToProperty;
        SoapHeaderFaultBinding fault;

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding.MapToProperty"]/*' />
        [XmlIgnore]
        public bool MapToProperty {
            get { return mapToProperty; }
            set { mapToProperty = value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding.Message"]/*' />
        [XmlAttribute("message")]
        public XmlQualifiedName Message {
            get { return message; }
            set { message = value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding.Part"]/*' />
        [XmlAttribute("part", DataType="NMTOKEN")]
        public string Part {
            get { return part; }
            set { part = value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding.Use"]/*' />
        [XmlAttribute("use"), DefaultValue(SoapBindingUse.Default)]
        public SoapBindingUse Use {
            get { return use; }
            set { use =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding.Encoding"]/*' />
        [XmlAttribute("encodingStyle"), DefaultValue("")]
        public string Encoding {
            get { return encoding == null ? string.Empty : encoding; }
            set { encoding =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding.Namespace"]/*' />
        [XmlAttribute("namespace"), DefaultValue("")]
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns =  value; }
        }
        
        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderBinding.Fault"]/*' />
        [XmlElement("headerfault")]
        public SoapHeaderFaultBinding Fault {
            get { return fault; }
            set { fault = value; }
        }
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderFaultBinding"]/*' />
    public class SoapHeaderFaultBinding : ServiceDescriptionFormatExtension {
        XmlQualifiedName message = XmlQualifiedName.Empty;
        string part;
        SoapBindingUse use;
        string encoding;
        string ns;

       /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderFaultBinding.Message"]/*' />
        [XmlAttribute("message")]
        public XmlQualifiedName Message {
            get { return message; }
            set { message = value; }
        }

       /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderFaultBinding.Part"]/*' />
        [XmlAttribute("part", DataType="NMTOKEN")]
        public string Part {
            get { return part; }
            set { part = value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderFaultBinding.Use"]/*' />
        [XmlAttribute("use"), DefaultValue(SoapBindingUse.Default)]
        public SoapBindingUse Use {
            get { return use; }
            set { use =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderFaultBinding.Encoding"]/*' />
        [XmlAttribute("encodingStyle"), DefaultValue("")]
        public string Encoding {
            get { return encoding == null ? string.Empty : encoding; }
            set { encoding =  value; }
        }

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapHeaderFaultBinding.Namespace"]/*' />
        [XmlAttribute("namespace"), DefaultValue("")]
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns =  value; }
        }
    }

    /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapAddressBinding"]/*' />
    [XmlFormatExtension("address", SoapBinding.Namespace, typeof(Port))]
    public class SoapAddressBinding : ServiceDescriptionFormatExtension {
        string location;

        /// <include file='doc\SoapFormatExtensions.uex' path='docs/doc[@for="SoapAddressBinding.Location"]/*' />
        [XmlAttribute("location")]
        public string Location {
            get { return location == null ? string.Empty : location; }
            set { location =  value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soaptransportimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapTransportImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {
    using System.CodeDom;
    using System.Security.Permissions;

    /// <include file='doc\SoapTransportImporter.uex' path='docs/doc[@for="SoapTransportImporter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class SoapTransportImporter {
        SoapProtocolImporter protocolImporter;

        /// <include file='doc\SoapTransportImporter.uex' path='docs/doc[@for="SoapTransportImporter.IsSupportedTransport"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract bool IsSupportedTransport(string transport);
        /// <include file='doc\SoapTransportImporter.uex' path='docs/doc[@for="SoapTransportImporter.ImportClass"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void ImportClass();

        /// <include file='doc\SoapTransportImporter.uex' path='docs/doc[@for="SoapTransportImporter.ImportContext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapProtocolImporter ImportContext {
            get { return protocolImporter; }
            set { protocolImporter = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\contractsearchpattern.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContractSearchPattern.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.Security.Permissions;

    /// <include file='doc\ContractSearchPattern.uex' path='docs/doc[@for="ContractSearchPattern"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class ContractSearchPattern : DiscoverySearchPattern {
        /// <include file='doc\ContractSearchPattern.uex' path='docs/doc[@for="ContractSearchPattern.Pattern"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Pattern {
            get {
                return "*.asmx";
            }
        }
        /// <include file='doc\ContractSearchPattern.uex' path='docs/doc[@for="ContractSearchPattern.GetDiscoveryReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override DiscoveryReference GetDiscoveryReference(string filename) {
            return new ContractReference(filename + "?wsdl", filename);
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\webcodegenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebCodeGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    
    using System;
    using System.Collections;
    using System.IO;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Diagnostics;
    using System.Reflection;
    using System.ComponentModel;
    using System.Xml.Serialization;

    internal enum CodeFlags {
        IsPublic = 0x1,
        IsAbstract = 0x2,
        IsStruct = 0x4,
        IsConstant = 0x8,
        IsByRef = 0x10,
        IsOut = 0x20
    }

    internal class WebCodeGenerator {
        internal static string[] GetNamespacesForTypes(Type[] types) {
            Hashtable names = new Hashtable();
            for (int i = 0; i < types.Length; i++) {
                string name = types[i].FullName;
                int dot = name.LastIndexOf('.');
                if (dot > 0)
                    names[name.Substring(0, dot)] = types[i];
            }
            string[] ns = new string[names.Keys.Count];
            names.Keys.CopyTo(ns, 0);
            return ns;
        }

        internal static void AddImports(CodeNamespace codeNamespace, string[] namespaces) {
            Debug.Assert(codeNamespace != null, "Inalid (null) CodeNamespace");
            foreach (string ns in namespaces)
                codeNamespace.Imports.Add(new CodeNamespaceImport(ns));
        }

        internal static CodeMemberField AddField(CodeTypeDeclaration codeClass, string fieldTypeName, string fieldName, CodeExpression initializer, CodeAttributeDeclarationCollection metadata, CodeFlags flags) {
            CodeMemberField field = new CodeMemberField(fieldTypeName, fieldName);
            field.InitExpression = initializer;
            field.CustomAttributes = metadata;
            if ((flags & CodeFlags.IsPublic) != 0)
                field.Attributes = (field.Attributes & ~MemberAttributes.AccessMask) | MemberAttributes.Public;
            // CONSIDER, stefanph: CodeDom doesn't support const. It should.
            codeClass.Members.Add(field);
            return field;
        }

        internal static CodeConstructor AddConstructor(CodeTypeDeclaration codeClass, string[] parameterTypeNames, string[] parameterNames, CodeAttributeDeclarationCollection metadata, CodeFlags flags) {
            CodeConstructor ctor = new CodeConstructor();

            if ((flags & CodeFlags.IsPublic) != 0)
                ctor.Attributes = (ctor.Attributes & ~MemberAttributes.AccessMask) | MemberAttributes.Public;
            if ((flags & CodeFlags.IsAbstract) != 0)
                ctor.Attributes = MemberAttributes.Abstract;

            ctor.CustomAttributes = metadata;

            Debug.Assert(parameterTypeNames.Length == parameterNames.Length, "invalid set of parameters");
            for (int i = 0; i < parameterTypeNames.Length; i++) {
                CodeParameterDeclarationExpression param = new CodeParameterDeclarationExpression(parameterTypeNames[i], parameterNames[i]);
                ctor.Parameters.Add(param);
            }
            codeClass.Members.Add(ctor);
            return ctor;
        }

        internal static CodeMemberMethod AddMethod(CodeTypeDeclaration codeClass, string methodName, 
            CodeFlags[] parameterFlags, string[] parameterTypeNames, string[] parameterNames, 
            string returnTypeName, CodeAttributeDeclarationCollection metadata, CodeFlags flags) {

            return AddMethod(codeClass, methodName, parameterFlags, 
                parameterTypeNames, parameterNames, new CodeAttributeDeclarationCollection[0],
                returnTypeName, metadata, flags);
        }

        internal static CodeMemberMethod AddMethod(CodeTypeDeclaration codeClass, string methodName, 
            CodeFlags[] parameterFlags, string[] parameterTypeNames, string[] parameterNames, 
            CodeAttributeDeclarationCollection[] parameterAttributes, string returnTypeName, CodeAttributeDeclarationCollection metadata, CodeFlags flags) {

            CodeMemberMethod method = new CodeMemberMethod();
            method.Name = methodName;
            method.ReturnType = new CodeTypeReference(returnTypeName);
            method.CustomAttributes = metadata;

            if ((flags & CodeFlags.IsPublic) != 0)
                method.Attributes = (method.Attributes & ~MemberAttributes.AccessMask) | MemberAttributes.Public;
            if ((flags & CodeFlags.IsAbstract) != 0)
                method.Attributes = (method.Attributes & ~MemberAttributes.ScopeMask) | MemberAttributes.Abstract;

            Debug.Assert(parameterFlags.Length == parameterTypeNames.Length && parameterTypeNames.Length == parameterNames.Length, "invalid set of parameters");
            for (int i = 0; i < parameterNames.Length; i++) {
                CodeParameterDeclarationExpression param = new CodeParameterDeclarationExpression(parameterTypeNames[i], parameterNames[i]);
                
                if ((parameterFlags[i] & CodeFlags.IsByRef) != 0)
                    param.Direction = FieldDirection.Ref;
                else if ((parameterFlags[i] & CodeFlags.IsOut) != 0)
                    param.Direction = FieldDirection.Out;

                if (i < parameterAttributes.Length) {
                    param.CustomAttributes = parameterAttributes[i];
                }
                method.Parameters.Add(param);
            }
            codeClass.Members.Add(method);
            return method;
        }

        internal static CodeTypeDeclaration AddClass(CodeNamespace codeNamespace, string className, string baseClassName, string[] implementedInterfaceNames, CodeAttributeDeclarationCollection metadata, CodeFlags flags) {
            CodeTypeDeclaration codeClass = CreateClass(className, baseClassName, implementedInterfaceNames, metadata, flags);
            codeNamespace.Types.Add(codeClass);
            return codeClass;
        }

        internal static CodeTypeDeclaration CreateClass(string className, string baseClassName, string[] implementedInterfaceNames, CodeAttributeDeclarationCollection metadata, CodeFlags flags) {
            CodeTypeDeclaration codeClass = new CodeTypeDeclaration(className);
            if (baseClassName != null && baseClassName.Length > 0)
                codeClass.BaseTypes.Add(baseClassName);
            foreach (string interfaceName in implementedInterfaceNames)
                codeClass.BaseTypes.Add(interfaceName);
            codeClass.IsStruct = (flags & CodeFlags.IsStruct) != 0;
            if ((flags & CodeFlags.IsPublic) != 0)
                codeClass.TypeAttributes |= TypeAttributes.Public;
            else
                codeClass.TypeAttributes &= ~TypeAttributes.Public;
            if ((flags & CodeFlags.IsAbstract) != 0)
                codeClass.TypeAttributes |= TypeAttributes.Abstract;
            else
                codeClass.TypeAttributes &= ~TypeAttributes.Abstract;

            codeClass.CustomAttributes = metadata;
            return codeClass;
        }

        internal static CodeAttributeDeclarationCollection AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeAttributeArgument[] arguments) {
            if (metadata == null) metadata = new CodeAttributeDeclarationCollection();
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(type.FullName, arguments);
            metadata.Add(attribute);
            return metadata;    
        }

        internal static CodeAttributeDeclarationCollection AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeExpression[] arguments) {
            return AddCustomAttribute(metadata, type, arguments, new string[0], new CodeExpression[0]);    
        }

        internal static CodeAttributeDeclarationCollection AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeExpression[] parameters, string[] propNames, CodeExpression[] propValues) {
            Debug.Assert(propNames.Length == propValues.Length, "propNames.Length !=  propValues.Length");
            int count = (parameters == null ? 0: parameters.Length) + (propNames == null ? 0 : propNames.Length);
            CodeAttributeArgument[] arguments = new CodeAttributeArgument[count];

            for (int i = 0; i < parameters.Length; i++)
                arguments[i] = new CodeAttributeArgument(null, parameters[i]);

            for (int i = 0; i < propNames.Length; i++)
                arguments[parameters.Length+i] = new CodeAttributeArgument(propNames[i], propValues[i]);

            return AddCustomAttribute(metadata, type, arguments);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soaphttptransportimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapHttpTransportImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {
    using System.CodeDom;
    using System.Web.Services.Protocols;

    internal class SoapHttpTransportImporter : SoapTransportImporter {
        public override bool IsSupportedTransport(string transport) {
            return transport == SoapBinding.HttpTransport;
        }

        public override void ImportClass() {
            // grab this here so it gets marked "handled" for both client and server
            SoapAddressBinding soapAddress = ImportContext.Port == null ? null : (SoapAddressBinding)ImportContext.Port.Extensions.Find(typeof(SoapAddressBinding));
            if (ImportContext.Style == ServiceDescriptionImportStyle.Client) {
                ImportContext.CodeTypeDeclaration.BaseTypes.Add(typeof(SoapHttpClientProtocol).FullName);                                
                CodeConstructor ctor = WebCodeGenerator.AddConstructor(ImportContext.CodeTypeDeclaration, new string[0], new string[0], null, CodeFlags.IsPublic);
                ctor.Comments.Add(new CodeCommentStatement("<remarks/>", true));
                if (ImportContext is Soap12ProtocolImporter) {
                    // add version code
                    CodeTypeReferenceExpression versionEnumTypeReference = new CodeTypeReferenceExpression(typeof(SoapProtocolVersion));
                    CodeFieldReferenceExpression versionEnumFieldReference = new CodeFieldReferenceExpression(versionEnumTypeReference, Enum.Format(typeof(SoapProtocolVersion), SoapProtocolVersion.Soap12, "G"));
                    CodePropertyReferenceExpression versionPropertyReference = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "SoapVersion");
                    CodeAssignStatement assignVersionStatement = new CodeAssignStatement(versionPropertyReference, versionEnumFieldReference);
                    ctor.Statements.Add(assignVersionStatement);
                }
                ServiceDescription serviceDescription = ImportContext.Binding.ServiceDescription;
                string url = (soapAddress != null) ? soapAddress.Location : null;
                string urlKey = serviceDescription.AppSettingUrlKey;
                string baseUrl =  serviceDescription.AppSettingBaseUrl;
                ProtocolImporterUtil.GenerateConstructorStatements(ctor, url, urlKey, baseUrl);
            }
            else {
                ImportContext.CodeTypeDeclaration.BaseTypes.Add(typeof(WebService).FullName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soapprotocolimporter.cs ===
//------------------------------------------------------------------------------
//  <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//     Copyright (c) Microsoft Corporation. All Rights Reserved.                
//     Information Contained Herein is Proprietary and Confidential.            
//  </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Web.Services.Configuration;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Security.Permissions;
    using System.Globalization;
    
    internal class SoapParameters {
        XmlMemberMapping ret;
        ArrayList parameters = new ArrayList();
        ArrayList inParameters = new ArrayList();
        ArrayList outParameters = new ArrayList();
        int checkSpecifiedCount;
        int inCheckSpecifiedCount;
        int outCheckSpecifiedCount;

        internal SoapParameters(XmlMembersMapping request, XmlMembersMapping response, string[] parameterOrder, CodeIdentifiers identifiers) {
            ArrayList requestList = new ArrayList();
            ArrayList responseList = new ArrayList();

            AddMappings(requestList, request);
            if (response != null) AddMappings(responseList, response);

            if (parameterOrder != null) {
                for (int i = 0; i < parameterOrder.Length; i++) {
                    string elementName = parameterOrder[i];
                    XmlMemberMapping requestMapping = FindMapping(requestList, elementName);
                    SoapParameter parameter = new SoapParameter();
                    if (requestMapping != null) {
                        if (RemoveByRefMapping(responseList, requestMapping))
                            parameter.codeFlags = CodeFlags.IsByRef;
                        parameter.mapping = requestMapping;
                        requestList.Remove(requestMapping);
                        AddParameter(parameter);
                    }
                    else {
                        XmlMemberMapping responseMapping = FindMapping(responseList, elementName);
                        if (responseMapping != null) {
                            parameter.codeFlags = CodeFlags.IsOut;
                            parameter.mapping = responseMapping;
                            responseList.Remove(responseMapping);
                            AddParameter(parameter);
                        }
                    }
                }
            }

            foreach (XmlMemberMapping requestMapping in requestList) {
                SoapParameter parameter = new SoapParameter();
                if (RemoveByRefMapping(responseList, requestMapping))
                    parameter.codeFlags = CodeFlags.IsByRef;
                parameter.mapping = requestMapping;
                AddParameter(parameter);
            }

            if (responseList.Count > 0) {
                if (!((XmlMemberMapping) responseList[0]).CheckSpecified) {
                    ret = (XmlMemberMapping)responseList[0];
                    responseList.RemoveAt(0);
                }
                foreach (XmlMemberMapping responseMapping in responseList) {
                    SoapParameter parameter = new SoapParameter();
                    parameter.mapping = responseMapping;
                    parameter.codeFlags = CodeFlags.IsOut;
                    AddParameter(parameter);
                }
            }

            foreach (SoapParameter parameter in parameters) {
                parameter.name = identifiers.MakeUnique(CodeIdentifier.MakeValid(parameter.mapping.MemberName));
            }
        }

        void AddParameter(SoapParameter parameter) {
            parameters.Add(parameter);
            if (parameter.mapping.CheckSpecified) {
                checkSpecifiedCount++;
            }
            if (parameter.IsByRef) {
                inParameters.Add(parameter);
                outParameters.Add(parameter);
                if (parameter.mapping.CheckSpecified) {
                    inCheckSpecifiedCount++;
                    outCheckSpecifiedCount++;
                }
            } else if (parameter.IsOut) {
                outParameters.Add(parameter);
                if (parameter.mapping.CheckSpecified)
                    outCheckSpecifiedCount++;
            }
            else {
                inParameters.Add(parameter);
                if (parameter.mapping.CheckSpecified)
                    inCheckSpecifiedCount++;
            }
        }

        static bool RemoveByRefMapping(ArrayList responseList, XmlMemberMapping requestMapping) {
            XmlMemberMapping responseMapping = FindMapping(responseList, requestMapping.ElementName);
            if (responseMapping == null) return false;
            if (requestMapping.TypeFullName != responseMapping.TypeFullName) return false;
            if (requestMapping.Namespace != responseMapping.Namespace) return false;
            if (requestMapping.MemberName != responseMapping.MemberName) return false;
            responseList.Remove(responseMapping);
            return true;
        }

        static void AddMappings(ArrayList mappingsList, XmlMembersMapping mappings) {
            for (int i = 0; i < mappings.Count; i++) {
                mappingsList.Add(mappings[i]);
            }
        }

        static XmlMemberMapping FindMapping(ArrayList mappingsList, string elementName) {
            foreach (XmlMemberMapping mapping in mappingsList)
                if (mapping.ElementName == elementName)
                    return mapping;
            return null;
        }

        internal XmlMemberMapping Return {
            get { return ret; }
        }

        internal IList Parameters {
            get { return parameters; }
        }

        internal IList InParameters {
            get { return inParameters; }
        }

        internal IList OutParameters {
            get { return outParameters; }
        }
        
        internal int CheckSpecifiedCount {
            get { return checkSpecifiedCount; }
        }
        
        internal int InCheckSpecifiedCount {
            get { return inCheckSpecifiedCount; }
        }
        
        internal int OutCheckSpecifiedCount {
            get { return outCheckSpecifiedCount; }
        }
    }

    internal class SoapParameter {
        internal CodeFlags codeFlags;
        internal string name;
        internal XmlMemberMapping mapping;
        internal string specifiedName;

        internal bool IsOut {
            get { return (codeFlags & CodeFlags.IsOut) != 0; }
        }

        internal bool IsByRef {
            get { return (codeFlags & CodeFlags.IsByRef) != 0; }
        }

        internal static string[] GetTypeFullNames(IList parameters, int specifiedCount) {
            string[] typeFullNames = new string[parameters.Count + specifiedCount];
            GetTypeFullNames(parameters, typeFullNames, 0, specifiedCount);
            return typeFullNames;
        }

        internal static void GetTypeFullNames(IList parameters, string[] typeFullNames, int start, int specifiedCount) {
            int specified = 0;
            for (int i = 0; i < parameters.Count; i++) {
                typeFullNames[i + start + specified] = ((SoapParameter)parameters[i]).mapping.TypeFullName;
                if (((SoapParameter) parameters[i]).mapping.CheckSpecified) {
                    specified++;
                    typeFullNames[i + start + specified] = typeof(bool).FullName;
                }
            }
        }

        internal static string[] GetNames(IList parameters, int specifiedCount) {
            string[] names = new string[parameters.Count + specifiedCount];
            GetNames(parameters, names, 0, specifiedCount);
            return names;
        }

        internal static void GetNames(IList parameters, string[] names, int start, int specifiedCount) {
            int specified = 0;
            for (int i = 0; i < parameters.Count; i++) {
                names[i + start + specified] = ((SoapParameter)parameters[i]).name;
                if (((SoapParameter) parameters[i]).mapping.CheckSpecified) {
                    specified++;
                    names[i + start + specified] = ((SoapParameter) parameters[i]).specifiedName;
                }
            }
        }

        internal static CodeFlags[] GetCodeFlags(IList parameters, int specifiedCount) {
            CodeFlags[] codeFlags = new CodeFlags[parameters.Count + specifiedCount];
            GetCodeFlags(parameters, codeFlags, 0, specifiedCount);
            return codeFlags;
        }

        internal static void GetCodeFlags(IList parameters, CodeFlags[] codeFlags, int start, int specifiedCount) {
            int specified = 0;
            for (int i = 0; i < parameters.Count; i++) {
                codeFlags[i + start + specified] = ((SoapParameter)parameters[i]).codeFlags;
                if (((SoapParameter) parameters[i]).mapping.CheckSpecified) {
                    specified++;
                    codeFlags[i + start + specified] = ((SoapParameter) parameters[i]).codeFlags;
                }
            }
        }
    }

    internal class GlobalSoapHeader {
        internal string fieldName;        
        internal XmlTypeMapping mapping;  
        internal bool isEncoded;      
    }
    
    internal class LocalSoapHeader {
        internal SoapHeaderDirection direction;        
        internal string fieldName;        
    }
            
    /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class SoapProtocolImporter : ProtocolImporter {
        XmlSchemaImporter xmlImporter;
        XmlCodeExporter xmlExporter;
        SoapSchemaImporter soapImporter;
        SoapCodeExporter soapExporter;
        CodeIdentifiers identifiers;
        ArrayList xmlMembers = new ArrayList();        
        ArrayList soapMembers = new ArrayList();
        Hashtable headers = new Hashtable();
        ArrayList propertyNames = new ArrayList();
        ArrayList propertyValues = new ArrayList();
        SoapExtensionImporter[] extensions;
        SoapTransportImporter transport;
        SoapBinding soapBinding;
        ArrayList codeClasses = new ArrayList();

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.ProtocolName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ProtocolName {
            get { return "Soap"; }
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.SoapBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapBinding SoapBinding {
            get { return soapBinding; }
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.SoapImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapSchemaImporter SoapImporter {
            get { return soapImporter; }
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.XmlImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaImporter XmlImporter {
            get { return xmlImporter; }
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.XmlExporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlCodeExporter XmlExporter {
            get { return xmlExporter; }
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.SoapExporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapCodeExporter SoapExporter {
            get { return soapExporter; }
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.BeginNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void BeginNamespace() {
            identifiers = new CodeIdentifiers();
            soapImporter = new SoapSchemaImporter(AbstractSchemas, ClassNames);
            xmlImporter = new XmlSchemaImporter(ConcreteSchemas, ClassNames);
            xmlExporter = new XmlCodeExporter(this.CodeNamespace);
            soapExporter = new SoapCodeExporter(this.CodeNamespace);
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.EndNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void EndNamespace() {
            foreach (GlobalSoapHeader soapHeader in headers.Values) {
                if (soapHeader.isEncoded)
                    soapExporter.ExportTypeMapping(soapHeader.mapping);
                else
                    xmlExporter.ExportTypeMapping(soapHeader.mapping);
            }

            foreach (XmlMembersMapping member in xmlMembers)
                xmlExporter.ExportMembersMapping(member);

            foreach (XmlMembersMapping member in soapMembers)
                soapExporter.ExportMembersMapping(member);

            // NOTE, erikc, we are sharing the SoapInclude and XmlInclude attributes of the 
            // class among ALL classes generated, This is probably OK, since doing to per 
            // class would probably result in the same set of includes if the user
            // has object as a return value (meaning 'all' types are OK).
            foreach (CodeTypeDeclaration codeClass in codeClasses) {
                if (codeClass.CustomAttributes == null)
                    codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();
                foreach (CodeAttributeDeclaration attribute in xmlExporter.IncludeMetadata) {
                    codeClass.CustomAttributes.Add(attribute);
                }
                foreach (CodeAttributeDeclaration attribute in soapExporter.IncludeMetadata) {
                    codeClass.CustomAttributes.Add(attribute);
                }
            }
            CodeGenerator.ValidateIdentifiers(CodeNamespace);
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.IsBindingSupported"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool IsBindingSupported() {
            SoapBinding soapBinding = (SoapBinding)Binding.Extensions.Find(typeof(SoapBinding));
            if (soapBinding == null || soapBinding.GetType() != typeof(SoapBinding)) return false;

            if (GetTransport(soapBinding.Transport) == null) {
                UnsupportedBindingWarning(Res.GetString(Res.ThereIsNoSoapTransportImporterThatUnderstands1, soapBinding.Transport));
                return false;
            }

            return true;
        }

        internal SoapTransportImporter GetTransport(string transport) {
            foreach (Type type in WebServicesConfiguration.Current.SoapTransportImporterTypes) {
                SoapTransportImporter transportImporter = (SoapTransportImporter)Activator.CreateInstance(type);
                transportImporter.ImportContext = this;
                if (transportImporter.IsSupportedTransport(transport)) return transportImporter;
            }
            return null;
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.BeginClass"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override CodeTypeDeclaration BeginClass() {
            identifiers.Clear();
            soapBinding = (SoapBinding)Binding.Extensions.Find(typeof(SoapBinding));
            transport = GetTransport(soapBinding.Transport);

            Type[] requiredTypes = new Type[] { typeof(SoapDocumentMethodAttribute), typeof(XmlAttributeAttribute), typeof(WebService), typeof(Object), typeof(DebuggerStepThroughAttribute), typeof(DesignerCategoryAttribute) };
            WebCodeGenerator.AddImports(this.CodeNamespace, WebCodeGenerator.GetNamespacesForTypes(requiredTypes));
            CodeTypeDeclaration codeClass = WebCodeGenerator.CreateClass(this.ClassName, null, 
                new string[0], null, CodeFlags.IsPublic | (Style == ServiceDescriptionImportStyle.Client ? 0 : CodeFlags.IsAbstract));

            codeClass.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();
            if (Style == ServiceDescriptionImportStyle.Client) {
                codeClass.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DebuggerStepThroughAttribute).FullName));
                codeClass.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DesignerCategoryAttribute).FullName, 
                    new CodeAttributeArgument[] {
                        new CodeAttributeArgument(new CodePrimitiveExpression("code")),
                    }));
            }

            CodeAttributeArgument[] arguments = new CodeAttributeArgument[] {
                new CodeAttributeArgument("Name", new CodePrimitiveExpression(Binding.Name)),
                new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(Binding.ServiceDescription.TargetNamespace))
            };
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(WebServiceBindingAttribute).FullName, arguments);
            codeClass.CustomAttributes.Add(attribute);

            codeClasses.Add(codeClass);
            return codeClass;
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.EndClass"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void EndClass() { 
            transport.ImportClass();
            soapBinding = null;
        }

        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.IsOperationFlowSupported"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool IsOperationFlowSupported(OperationFlow flow) {
            return flow == OperationFlow.OneWay || flow == OperationFlow.RequestResponse;
        }

        void BeginMetadata() {
            propertyNames.Clear();
            propertyValues.Clear();
        }

        bool MetadataPropertiesAdded {
            get { return propertyNames.Count > 0; }
        }

        void AddMetadataProperty(string name, object value) {
            AddMetadataProperty(name, new CodePrimitiveExpression(value));
        }

        void AddMetadataProperty(string name, CodeExpression expr) {
            propertyNames.Add(name);
            propertyValues.Add(expr);
        }

        void EndMetadata(CodeAttributeDeclarationCollection metadata, Type attributeType, string parameter) {
            CodeExpression[] parameters;
            if (parameter == null) {
                parameters = new CodeExpression[0];
            }
            else {
                parameters = new CodeExpression[1] { new CodePrimitiveExpression(parameter) };
            }
            WebCodeGenerator.AddCustomAttribute(metadata, attributeType, parameters, 
                                  (string[])propertyNames.ToArray(typeof(string)), 
                                  (CodeExpression[])propertyValues.ToArray(typeof(CodeExpression)));
        }

        void GenerateExtensionMetadata(CodeAttributeDeclarationCollection metadata) {
            if (extensions == null) {
                Type[] extensionTypes = WebServicesConfiguration.Current.SoapExtensionImporterTypes;
                extensions = new SoapExtensionImporter[extensionTypes.Length];
                for (int i = 0; i < extensions.Length; i++) {
                    SoapExtensionImporter extension = (SoapExtensionImporter)Activator.CreateInstance(extensionTypes[i]);
                    extension.ImportContext = this;
                    extensions[i] = extension;
                }
            }
            foreach (SoapExtensionImporter extension in extensions) {
                extension.ImportMethod(metadata);
            }
        }

        void PrepareHeaders(MessageBinding messageBinding) {
            // By default, map all headers to properties on the generated class
            // ExtensionImporters can modify this behavior by clearing the flag
            SoapHeaderBinding[] headers = (SoapHeaderBinding[])messageBinding.Extensions.FindAll(typeof(SoapHeaderBinding));
            foreach (SoapHeaderBinding header in headers) {
                header.MapToProperty = true;
            }
        }

        void GenerateHeaders(CodeAttributeDeclarationCollection metadata, SoapBindingUse use, MessageBinding requestMessage, MessageBinding responseMessage) { 
            Hashtable localHeaders = new Hashtable();                                                                                           

            for (int i = 0; i < 2; ++ i) {                                                                                                                                                 
                MessageBinding messageBinding;
                SoapHeaderDirection direction;
                if (i == 0) {
                    messageBinding = requestMessage;
                    direction = SoapHeaderDirection.In;
                }
                else if (responseMessage != null) {
                    messageBinding = responseMessage;
                    direction = SoapHeaderDirection.Out;
                }                    
                else
                    continue;                                                                                                                                                     
                    
                SoapHeaderBinding[] headerBindings = (SoapHeaderBinding[])messageBinding.Extensions.FindAll(typeof(SoapHeaderBinding));
                foreach (SoapHeaderBinding header in headerBindings) {
                    // Skip headers which should not be mapped to properties (extension importers can control this)
                    if (!header.MapToProperty) continue;
                    
                    if (use != header.Use) throw new InvalidOperationException(Res.GetString(Res.WebDescriptionHeaderAndBodyUseMismatch));
                    if (use == SoapBindingUse.Encoded && !IsSoapEncodingPresent(header.Encoding) )
                        throw new InvalidOperationException(Res.GetString(Res.WebUnknownEncodingStyle, header.Encoding));
                    
                    Message message = ServiceDescriptions.GetMessage(header.Message);
                    if (message == null) throw new InvalidOperationException(Res.GetString(Res.MissingMessage2, header.Message.Name, header.Message.Namespace));

                    MessagePart part = message.FindPartByName(header.Part);
                    if (part == null) throw new InvalidOperationException(Res.GetString(Res.MissingMessagePartForMessageFromNamespace3, part.Name, header.Message.Name, header.Message.Namespace));

                    XmlTypeMapping mapping;
                    string key;
                    if (use == SoapBindingUse.Encoded) {
                        if (part.Type.IsEmpty) throw new InvalidOperationException(Res.GetString(Res.WebDescriptionPartTypeRequired, part.Name, header.Message.Name, header.Message.Namespace));
                        if (!part.Element.IsEmpty) UnsupportedOperationBindingWarning(Res.GetString(Res.WebDescriptionPartElementWarning, part.Name, header.Message.Name, header.Message.Namespace));
                        mapping = soapImporter.ImportDerivedTypeMapping(part.Type, typeof(SoapHeader), true);
                        key = "type=" + part.Type.ToString();
                    }
                    else {
                        if (part.Element.IsEmpty) throw new InvalidOperationException(Res.GetString(Res.WebDescriptionPartElementRequired, part.Name, header.Message.Name, header.Message.Namespace));
                        if (!part.Type.IsEmpty) UnsupportedOperationBindingWarning(Res.GetString(Res.WebDescriptionPartTypeWarning, part.Name, header.Message.Name, header.Message.Namespace));
                        mapping = xmlImporter.ImportDerivedTypeMapping(part.Element, typeof(SoapHeader), true);
                        key = "element=" + part.Element.ToString();
                    }
                    LocalSoapHeader localHeader = (LocalSoapHeader)localHeaders[key];
                    if (localHeader == null) {
                        GlobalSoapHeader globalHeader = (GlobalSoapHeader)headers[key];
                        if (globalHeader == null) {
                            globalHeader = new GlobalSoapHeader();
                            globalHeader.isEncoded = use == SoapBindingUse.Encoded;
                            string fieldName = CodeIdentifier.MakeValid(mapping.ElementName);
                            if (fieldName == mapping.TypeName) fieldName += "Value";
                            fieldName = identifiers.AddUnique(fieldName, mapping);
                            globalHeader.fieldName = fieldName;
                            WebCodeGenerator.AddField(CodeTypeDeclaration, mapping.TypeFullName, globalHeader.fieldName, null, null, CodeFlags.IsPublic);
                            globalHeader.mapping = mapping;
                            headers.Add(key, globalHeader);                                            
                        }
                        
                        localHeader = new  LocalSoapHeader();                                                    
                        localHeader.fieldName = globalHeader.fieldName;
                        localHeader.direction = direction;
                        localHeaders.Add(key, localHeader);
                    }
                    else {
                        if (localHeader.direction != direction)
                            localHeader.direction = SoapHeaderDirection.InOut;
                    }                                                                                                                 
                }
            }
            
            foreach (LocalSoapHeader soapHeader in localHeaders.Values) {
                BeginMetadata();
                if (soapHeader.direction == SoapHeaderDirection.Out) {
                    AddMetadataProperty("Direction", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapHeaderDirection).FullName), SoapHeaderDirection.Out.ToString()));
                }                
                else if (soapHeader.direction == SoapHeaderDirection.InOut) { 
                    AddMetadataProperty("Direction", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapHeaderDirection).FullName), SoapHeaderDirection.InOut.ToString()));
                }                
                
                EndMetadata(metadata, typeof(SoapHeaderAttribute), soapHeader.fieldName);
            }
        }       
        
        /// <include file='doc\SoapProtocolImporter.uex' path='docs/doc[@for="SoapProtocolImporter.GenerateMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override CodeMemberMethod GenerateMethod() {
            Message requestMessage;
            Message responseMessage;
            string[] parameterOrder;
            SoapBodyBinding soapRequestBinding;
            SoapBodyBinding soapResponseBinding;
            MessageBinding requestBinding;
            MessageBinding responseBinding;

            SoapOperationBinding soapOperationBinding = (SoapOperationBinding)this.OperationBinding.Extensions.Find(typeof(SoapOperationBinding));
            if (soapOperationBinding == null) throw OperationBindingSyntaxException(Res.GetString(Res.MissingSoapOperationBinding0));

            SoapBindingStyle soapBindingStyle = soapOperationBinding.Style;
            if (soapBindingStyle == SoapBindingStyle.Default)
                soapBindingStyle = SoapBinding.Style;
            if (soapBindingStyle == SoapBindingStyle.Default)
                soapBindingStyle = SoapBindingStyle.Document;

            parameterOrder = this.Operation.ParameterOrder;

            requestMessage = this.InputMessage;
            requestBinding = this.OperationBinding.Input;
            soapRequestBinding = (SoapBodyBinding)this.OperationBinding.Input.Extensions.Find(typeof(SoapBodyBinding));
            if (soapRequestBinding == null) {
                UnsupportedOperationBindingWarning(Res.GetString(Res.MissingSoapBodyInputBinding0));
                return null;
            }

            if (this.Operation.Messages.Output != null) {
                responseMessage = this.OutputMessage;
                responseBinding = this.OperationBinding.Output;
                soapResponseBinding = (SoapBodyBinding)this.OperationBinding.Output.Extensions.Find(typeof(SoapBodyBinding));
                if (soapResponseBinding == null) {
                    UnsupportedOperationBindingWarning(Res.GetString(Res.MissingSoapBodyOutputBinding0));
                    return null;
                }
            }
            else {
                responseMessage = null;
                responseBinding = null;
                soapResponseBinding = null;
            }

            CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();

            PrepareHeaders(requestBinding);
            if (responseBinding != null) PrepareHeaders(responseBinding);

            string requestMessageName, responseMessageName;
            requestMessageName = this.Operation.Name; // per WSDL 1.1 sec 3.5
            responseMessageName = requestMessageName + "Response";

            GenerateExtensionMetadata(metadata);
            GenerateHeaders(metadata, soapRequestBinding.Use, requestBinding, responseBinding);

            MessagePart[] requestParts = GetMessageParts(requestMessage, soapRequestBinding);
            bool hasWrapper;
            if (!CheckMessageStyles(MethodName, requestParts, soapRequestBinding, soapBindingStyle, out hasWrapper))
                return null;

            MessagePart[] responseParts = null;
            if (responseMessage != null) {
                responseParts = GetMessageParts(responseMessage, soapResponseBinding);
                bool responseHasWrapper;
                if (!CheckMessageStyles(MethodName, responseParts, soapResponseBinding, soapBindingStyle, out responseHasWrapper)) 
                    return null;

                // since we're using a potentially inaccurate heuristic to determine whether there's a wrapper,
                // if we disagree about the request and response we should assume there isn't a wrapper.
                if (hasWrapper != responseHasWrapper)
                    hasWrapper = false;
            }

            bool wrapperNamesMatter = soapBindingStyle != SoapBindingStyle.Rpc && hasWrapper;

            XmlMembersMapping request = ImportMessage(requestMessageName, requestParts, soapRequestBinding, soapBindingStyle, hasWrapper);
            if (request == null) return null;

            XmlMembersMapping response = null;

            if (responseMessage != null) {
                response = ImportMessage(responseMessageName, responseParts, soapResponseBinding, soapBindingStyle, hasWrapper);
                if (response == null) return null;
            }

            string methodName = CodeIdentifier.MakeValid(this.Operation.Name);
            string uniqueMethodName = identifiers.AddUnique(methodName, this.Operation);
            bool differentNames = methodName != uniqueMethodName;

            CodeIdentifiers localIdentifiers = new CodeIdentifiers();
            localIdentifiers.AddReserved(uniqueMethodName);

            SoapParameters parameters = new SoapParameters(request, response, parameterOrder, identifiers);

            foreach (SoapParameter param in parameters.Parameters) {
                param.name = localIdentifiers.AddUnique(param.name, null);
                if (param.mapping.CheckSpecified)
                    param.specifiedName = localIdentifiers.AddUnique(param.name + "Specified", null);
            }

            if (!(Style == ServiceDescriptionImportStyle.Client) || differentNames) {
                BeginMetadata();
                if (differentNames) AddMetadataProperty("MessageName", uniqueMethodName);
                EndMetadata(metadata, typeof(WebMethodAttribute), null);
            }

            BeginMetadata();
            if (wrapperNamesMatter && request.ElementName.Length > 0 && request.ElementName != uniqueMethodName)
                AddMetadataProperty("RequestElementName", request.ElementName);
            if (request.Namespace != null)
                AddMetadataProperty("RequestNamespace", request.Namespace);
            if (response == null) {
                AddMetadataProperty("OneWay", true);                    
            }
            else {
                if (wrapperNamesMatter && response.ElementName.Length > 0 && response.ElementName != (uniqueMethodName + "Response"))
                    AddMetadataProperty("ResponseElementName", response.ElementName);
                if (response.Namespace != null)
                    AddMetadataProperty("ResponseNamespace", response.Namespace);                                     
            }                
            if (soapBindingStyle == SoapBindingStyle.Rpc) {
                EndMetadata(metadata, typeof(SoapRpcMethodAttribute), soapOperationBinding.SoapAction);
            }
            else {
                AddMetadataProperty("Use", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapBindingUse).FullName), Enum.Format(typeof(SoapBindingUse), soapRequestBinding.Use, "G")));
                AddMetadataProperty("ParameterStyle", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapParameterStyle).FullName), Enum.Format(typeof(SoapParameterStyle), hasWrapper ? SoapParameterStyle.Wrapped : SoapParameterStyle.Bare, "G")));
                EndMetadata(metadata, typeof(SoapDocumentMethodAttribute), soapOperationBinding.SoapAction);
            }
                        
            CodeAttributeDeclarationCollection[] paramsMetadata = new CodeAttributeDeclarationCollection[parameters.Parameters.Count + parameters.CheckSpecifiedCount];
            int j = 0;
            CodeAttributeDeclaration ignoreAttribute = new CodeAttributeDeclaration(typeof(XmlIgnoreAttribute).FullName);
            foreach (SoapParameter parameter in parameters.Parameters) {
                paramsMetadata[j] = new CodeAttributeDeclarationCollection();
                if (soapRequestBinding.Use == SoapBindingUse.Encoded)
                    soapExporter.AddMappingMetadata(paramsMetadata[j], parameter.mapping, parameter.name != parameter.mapping.MemberName);
                else {
                    xmlExporter.AddMappingMetadata(paramsMetadata[j], parameter.mapping, parameter.IsOut ? response.Namespace : request.Namespace, parameter.name != parameter.mapping.MemberName);
                    if (parameter.mapping.CheckSpecified) {
                        j++;
                        paramsMetadata[j] = new CodeAttributeDeclarationCollection();
                        xmlExporter.AddMappingMetadata(paramsMetadata[j], parameter.mapping, parameter.IsOut ? response.Namespace : request.Namespace, parameter.specifiedName != parameter.mapping.MemberName + "Specified");
                        paramsMetadata[j].Add(ignoreAttribute);
                    }
                }
                j++;
            }

            CodeMemberMethod mainCodeMethod = WebCodeGenerator.AddMethod(this.CodeTypeDeclaration, methodName, 
                                        SoapParameter.GetCodeFlags(parameters.Parameters, parameters.CheckSpecifiedCount),
                                        SoapParameter.GetTypeFullNames(parameters.Parameters, parameters.CheckSpecifiedCount),
                                        SoapParameter.GetNames(parameters.Parameters, parameters.CheckSpecifiedCount),
                                        paramsMetadata,
                                        parameters.Return == null ? typeof(void).FullName : parameters.Return.TypeFullName, 
                                        metadata, 
                                        CodeFlags.IsPublic | (Style == ServiceDescriptionImportStyle.Client ? 0 : CodeFlags.IsAbstract));

            mainCodeMethod.Comments.Add(new CodeCommentStatement("<remarks/>", true));

            if (parameters.Return != null) {
                if (soapRequestBinding.Use == SoapBindingUse.Encoded)
                    soapExporter.AddMappingMetadata(mainCodeMethod.ReturnTypeCustomAttributes, parameters.Return, parameters.Return.ElementName != uniqueMethodName + "Result");
                else
                    xmlExporter.AddMappingMetadata(mainCodeMethod.ReturnTypeCustomAttributes, parameters.Return, response.Namespace, parameters.Return.ElementName != uniqueMethodName + "Result");
            }

            string resultsName = localIdentifiers.MakeUnique("results");

            if (Style == ServiceDescriptionImportStyle.Client) {
                metadata = new CodeAttributeDeclarationCollection();

                CodeExpression[] invokeParams = new CodeExpression[2];
                CreateInvokeParams(invokeParams, uniqueMethodName, parameters.InParameters, parameters.InCheckSpecifiedCount);
                CodeExpression invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Invoke", invokeParams);
                WriteReturnMappings(mainCodeMethod, invoke, parameters, resultsName);

                int inCount = parameters.InParameters.Count + parameters.InCheckSpecifiedCount;

                string[] asyncParameterTypes = new string[inCount + 2];
                SoapParameter.GetTypeFullNames(parameters.InParameters, asyncParameterTypes, 0, parameters.InCheckSpecifiedCount);
                asyncParameterTypes[inCount] = typeof(AsyncCallback).FullName;
                asyncParameterTypes[inCount + 1] = typeof(object).FullName;

                string[] asyncParameterNames = new string[inCount + 2];
                SoapParameter.GetNames(parameters.InParameters, asyncParameterNames, 0, parameters.InCheckSpecifiedCount);
                asyncParameterNames[inCount] = "callback";
                asyncParameterNames[inCount + 1] = "asyncState";

                CodeFlags[] asyncParameterFlags = new CodeFlags[inCount + 2];

                CodeMemberMethod beginCodeMethod = WebCodeGenerator.AddMethod(this.CodeTypeDeclaration, "Begin" + uniqueMethodName, 
                                            asyncParameterFlags,
                                            asyncParameterTypes, 
                                            asyncParameterNames, 
                                            typeof(IAsyncResult).FullName, 
                                            metadata, 
                                            CodeFlags.IsPublic);

                beginCodeMethod.Comments.Add(new CodeCommentStatement("<remarks/>", true));

                invokeParams = new CodeExpression[4];
                CreateInvokeParams(invokeParams, uniqueMethodName, parameters.InParameters, parameters.InCheckSpecifiedCount);
                invokeParams[2] = new CodeArgumentReferenceExpression("callback");
                invokeParams[3] = new CodeArgumentReferenceExpression("asyncState");

                invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "BeginInvoke", invokeParams);
                beginCodeMethod.Statements.Add(new CodeMethodReturnStatement(invoke));

                int outCount = parameters.OutParameters.Count + parameters.OutCheckSpecifiedCount;
                string[] asyncReturnTypes = new string[outCount + 1];
                SoapParameter.GetTypeFullNames(parameters.OutParameters, asyncReturnTypes, 1, parameters.OutCheckSpecifiedCount);
                asyncReturnTypes[0] = typeof(IAsyncResult).FullName;

                string[] asyncReturnNames = new string[outCount + 1];
                SoapParameter.GetNames(parameters.OutParameters, asyncReturnNames, 1, parameters.OutCheckSpecifiedCount);
                asyncReturnNames[0] = "asyncResult";

                CodeFlags[] asyncReturnFlags = new CodeFlags[outCount + 1];
                for (int i = 0; i < outCount; i++)
                    asyncReturnFlags[i + 1] = CodeFlags.IsOut;

                CodeMemberMethod codeMethod = WebCodeGenerator.AddMethod(this.CodeTypeDeclaration, "End" + uniqueMethodName, 
                                            asyncReturnFlags, 
                                            asyncReturnTypes, 
                                            asyncReturnNames, 
                                            parameters.Return == null ? typeof(void).FullName : parameters.Return.TypeFullName, 
                                            metadata, 
                                            CodeFlags.IsPublic);

                codeMethod.Comments.Add(new CodeCommentStatement("<remarks/>", true));

                CodeExpression invokeParam = new CodeArgumentReferenceExpression("asyncResult");
                invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "EndInvoke", new CodeExpression[] { invokeParam });

                WriteReturnMappings(codeMethod, invoke, parameters, resultsName);
            }
            return mainCodeMethod;
        }

        void WriteReturnMappings(CodeMemberMethod codeMethod, CodeExpression invoke, SoapParameters parameters, string resultsName) {
            if (parameters.Return == null && parameters.OutParameters.Count == 0) {
                codeMethod.Statements.Add(new CodeExpressionStatement(invoke));
            }
            else {
                codeMethod.Statements.Add(new CodeVariableDeclarationStatement(typeof(object[]), resultsName, invoke));

                int count = parameters.Return == null ? 0 : 1;
                for (int i = 0; i < parameters.OutParameters.Count; i++) {
                    SoapParameter parameter = (SoapParameter)parameters.OutParameters[i];
                    CodeExpression target = new CodeArgumentReferenceExpression(parameter.name);
                    CodeExpression value = new CodeArrayIndexerExpression();
                    ((CodeArrayIndexerExpression)value).TargetObject = new CodeVariableReferenceExpression(resultsName);
                    ((CodeArrayIndexerExpression)value).Indices.Add(new CodePrimitiveExpression(count++));
                    value = new CodeCastExpression(parameter.mapping.TypeFullName, value);
                    codeMethod.Statements.Add(new CodeAssignStatement(target, value));
                    if (parameter.mapping.CheckSpecified) {
                        target = new CodeArgumentReferenceExpression(parameter.name + "Specified");
                        value = new CodeArrayIndexerExpression();
                        ((CodeArrayIndexerExpression) value).TargetObject = new CodeVariableReferenceExpression(resultsName);
                        ((CodeArrayIndexerExpression)value).Indices.Add(new CodePrimitiveExpression(count++));
                        value = new CodeCastExpression(typeof(bool).FullName, value);
                        codeMethod.Statements.Add(new CodeAssignStatement(target, value));
                    }
                }

                if (parameters.Return != null) {
                    CodeExpression value = new CodeArrayIndexerExpression();
                    ((CodeArrayIndexerExpression)value).TargetObject = new CodeVariableReferenceExpression(resultsName);
                    ((CodeArrayIndexerExpression)value).Indices.Add(new CodePrimitiveExpression(0));
                    value = new CodeCastExpression(parameters.Return.TypeFullName, value);
                    codeMethod.Statements.Add(new CodeMethodReturnStatement(value));
                }
            }
        }

        void CreateInvokeParams(CodeExpression[] invokeParams, string methodName, IList parameters, int checkSpecifiedCount) {
            invokeParams[0] = new CodePrimitiveExpression(methodName);

            CodeExpression[] values = new CodeExpression[parameters.Count + checkSpecifiedCount];
            int value = 0;
            for (int i = 0; i < parameters.Count; i++) {
                SoapParameter parameter = (SoapParameter)parameters[i];
                values[value++] = new CodeArgumentReferenceExpression(parameter.name);
                if (parameter.mapping.CheckSpecified)
                    values[value++] = new CodeArgumentReferenceExpression(parameter.specifiedName);
            }
            invokeParams[1] = new CodeArrayCreateExpression(typeof(object).FullName, values);
        }

        // returns false if we didn't like the message -- otherwise caller is safe to use body binding and binding style
        bool CheckMessageStyles(string messageName, MessagePart[] parts, SoapBodyBinding soapBodyBinding, SoapBindingStyle soapBindingStyle, out bool hasWrapper) {
            hasWrapper = false;
            if (soapBodyBinding.Use == SoapBindingUse.Literal) {
                if (soapBindingStyle == SoapBindingStyle.Rpc) {
                    UnsupportedOperationBindingWarning(Res.GetString(Res.TheCombinationOfStyleRpcWithUseLiteralIsNot0));
                    return false;
                }
                if (parts.Length == 1 && !parts[0].Type.IsEmpty) {
                    // special top-level any case
                    if (!parts[0].Element.IsEmpty) {
                        UnsupportedOperationBindingWarning(Res.GetString(Res.SpecifyingATypeForUseLiteralMessagesIs0));
                        return false;
                    }
                    XmlMembersMapping membersMapping = xmlImporter.ImportAnyType(parts[0].Type, parts[0].Name);
                    if (membersMapping == null)
                        return false;
                    return true;
                }
                else {
                    foreach (MessagePart part in parts) {
                        if (!part.Type.IsEmpty) {
                            UnsupportedOperationBindingWarning(Res.GetString(Res.SpecifyingATypeForUseLiteralMessagesIs0));
                            return false;
                        }
                        if (part.Element.IsEmpty) {
                            UnsupportedOperationBindingWarning(Res.GetString(Res.EachMessagePartInAUseLiteralMessageMustSpecify0));
                            return false;
                        }
                    }
                }
            }
            else if (soapBodyBinding.Use == SoapBindingUse.Encoded) {
                if (!IsSoapEncodingPresent(soapBodyBinding.Encoding)) {
                    UnsupportedOperationBindingWarning(Res.GetString(Res.TheEncodingIsNotSupported1, soapBodyBinding.Encoding));
                    return false;
                }
                foreach (MessagePart part in parts) {
                    if (!part.Element.IsEmpty) {
                        UnsupportedOperationBindingWarning(Res.GetString(Res.SpecifyingAnElementForUseEncodedMessageParts0));
                        return false;
                    }
                    if (part.Type.IsEmpty) {
                        UnsupportedOperationBindingWarning(Res.GetString(Res.EachMessagePartInAnUseEncodedMessageMustSpecify0));
                        return false;
                    }
                }
            }

            if (soapBindingStyle == SoapBindingStyle.Rpc) {
                return true;
            }
            else if (soapBindingStyle == SoapBindingStyle.Document) {
                // NOTE, erikc.  WSDL doesn't really let us figure out whether a document is
                // in fact a struct containing parameters, so we apply a little heuristic here
                // in order to produce the appropriate programming model.
                hasWrapper = (parts.Length == 1 && string.Compare(parts[0].Name, "parameters", false, CultureInfo.InvariantCulture) == 0);
                return true;
            }
            return false;
        }
        
        protected virtual bool IsSoapEncodingPresent(string uriList) {
            int iStart = 0;
            do {
                iStart = uriList.IndexOf(Soap.Encoding, iStart);
                if (iStart < 0)
                    return false;
                int iEnd = iStart + Soap.Encoding.Length;
                if (iStart == 0 || uriList[iStart-1] == ' ')
                    if (iEnd == uriList.Length || uriList[iEnd] == ' ')
                        return true;
                iStart = iEnd;
            } while (iStart < uriList.Length);
            return false;
        }

        MessagePart[] GetMessageParts(Message message, SoapBodyBinding soapBodyBinding) {
            MessagePart[] parts;
            if (soapBodyBinding.Parts == null) {
                parts = new MessagePart[message.Parts.Count];
                message.Parts.CopyTo(parts, 0);
            }
            else {
                parts = message.FindPartsByName(soapBodyBinding.Parts);
            }
            return parts;
        }

        XmlMembersMapping ImportMessage(string messageName, MessagePart[] parts, SoapBodyBinding soapBodyBinding, SoapBindingStyle soapBindingStyle, bool wrapped) {
            if (soapBodyBinding.Use == SoapBindingUse.Encoded)
                return ImportEncodedMessage(messageName, parts, soapBodyBinding, wrapped);
            else
                return ImportLiteralMessage(parts, soapBodyBinding, wrapped);
        }

        XmlMembersMapping ImportEncodedMessage(string messageName, MessagePart[] parts, SoapBodyBinding soapBodyBinding, bool wrapped) {
            XmlMembersMapping membersMapping;
            if (wrapped) {
                SoapSchemaMember schemaMember = new SoapSchemaMember();
                schemaMember.MemberName = parts[0].Name;
                schemaMember.MemberType = parts[0].Type;
                membersMapping = soapImporter.ImportMembersMapping(messageName, soapBodyBinding.Namespace, schemaMember);
            }
            else {
                SoapSchemaMember[] schemaMembers = new SoapSchemaMember[parts.Length];
                for (int i = 0; i < schemaMembers.Length; i++) {
                    MessagePart part = parts[i];
                    SoapSchemaMember schemaMember = new SoapSchemaMember();
                    schemaMember.MemberName = part.Name;
                    schemaMember.MemberType = part.Type;
                    schemaMembers[i] = schemaMember;
                }
                membersMapping = soapImporter.ImportMembersMapping(messageName, soapBodyBinding.Namespace, schemaMembers);
            } 
            soapMembers.Add(membersMapping);
            return membersMapping;
        }

        XmlMembersMapping ImportLiteralMessage(MessagePart[] parts, SoapBodyBinding soapBodyBinding, bool wrapped) {
            XmlMembersMapping membersMapping;
            if (wrapped) {
                membersMapping = xmlImporter.ImportMembersMapping(parts[0].Element);
            }
            else {
                if (parts.Length == 1 && !parts[0].Type.IsEmpty) {
                    // special case for <any> at root
                    // we know this will work because we tried it earlier in CheckMessageStyles.
                    membersMapping = xmlImporter.ImportAnyType(parts[0].Type, parts[0].Name);
                    xmlMembers.Add(membersMapping);
                    return membersMapping;
                }
                XmlQualifiedName[] names = new XmlQualifiedName[parts.Length];
                for (int i = 0; i < parts.Length; i++)
                    names[i] = parts[i].Element;
                membersMapping = xmlImporter.ImportMembersMapping(names);
            }
            xmlMembers.Add(membersMapping);
            return membersMapping;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoveryclientdocuments.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryClientDocuments.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    
    using System.Collections;
    using System.Diagnostics;
    using System.Security.Permissions;

    /// <include file='doc\DiscoveryClientDocuments.uex' path='docs/doc[@for="DiscoveryClientDocumentCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryClientDocumentCollection : DictionaryBase {

        /// <include file='doc\DiscoveryClientDocuments.uex' path='docs/doc[@for="DiscoveryClientDocumentCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object this[string url] {
            get {
                return Dictionary[url];
            }
            set {
                Dictionary[url] = value;
            }
        }

        /// <include file='doc\DiscoveryClientDocuments.uex' path='docs/doc[@for="DiscoveryClientDocumentCollection.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Keys {
            get { return Dictionary.Keys; }
        }

        /// <include file='doc\DiscoveryClientDocuments.uex' path='docs/doc[@for="DiscoveryClientDocumentCollection.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return Dictionary.Values;
            }
        }

        /// <include file='doc\DiscoveryClientDocuments.uex' path='docs/doc[@for="DiscoveryClientDocumentCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(string url, object value) {
            Dictionary.Add(url, value);
        }

        /// <include file='doc\DiscoveryClientDocuments.uex' path='docs/doc[@for="DiscoveryClientDocumentCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(string url) {
            return Dictionary.Contains(url);
        }

        /// <include file='doc\DiscoveryClientDocuments.uex' path='docs/doc[@for="DiscoveryClientDocumentCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(string url) {
            Dictionary.Remove(url);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\contractreference.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContractReference.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;
    using System.Net;
    using System.Xml.Serialization;
    using System.Web.Services.Description;
    using System.IO;
    using System.Xml;
    using System.Xml.Schema;
    using System.Web.Services.Protocols;
    using System.Text;
    using System.Collections;

    /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlRoot("contractRef", Namespace=ContractReference.Namespace)]
    public class ContractReference : DiscoveryReference {

        /// <include file='doc\contractreference.uex' path='docs/doc[@for="contractreference.namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string Namespace = "http://schemas.xmlsoap.org/disco/scl/";

        private string docRef;
        private string reference;

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.ContractReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ContractReference() {
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.ContractReference1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ContractReference(string href) {
            Ref = href;
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.ContractReference2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ContractReference(string href, string docRef) {
            Ref = href;
            DocRef = docRef;
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.Ref"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("ref")]
        public string Ref {
            get {
                return reference;
            }
            set {
                reference = value;
            }
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.DocRef"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("docRef")]
        public string DocRef {
            get {
                return docRef;
            }
            set {
                docRef = value;
            }
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override string Url {
            get {
                return Ref;
            }
            set {
                Ref = value;
            }
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.Contract"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public ServiceDescription Contract {
            get {
                if (ClientProtocol == null)
                    throw new InvalidOperationException(Res.GetString(Res.WebMissingClientProtocol));
                object document = ClientProtocol.Documents[Url];
                if (document == null) {
                    Resolve();
                    document = ClientProtocol.Documents[Url];
                }
                ServiceDescription contract = document as ServiceDescription;
                if (contract == null) {
                    throw new InvalidOperationException(Res.GetString(Res.WebInvalidDocType, 
                                                      typeof(ServiceDescription).FullName,
                                                      document == null ? string.Empty: document.GetType().FullName,
                                                      Url));
                }
                return contract;
            }
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.DefaultFilename"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override string DefaultFilename {
            get {
                string fileName = Contract.Name;
                if (fileName == null || fileName.Length == 0)
                    fileName = FilenameFromUrl(Url);
                return Path.ChangeExtension(fileName, ".wsdl");
            }
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.WriteDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteDocument(object document, Stream stream) {
            ((ServiceDescription) document).Write(new StreamWriter(stream, new UTF8Encoding(false)));
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.ReadDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ReadDocument(Stream stream) {
            return ServiceDescription.Read(stream);
        }

        /// <include file='doc\ContractReference.uex' path='docs/doc[@for="ContractReference.Resolve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal override void Resolve(string contentType, Stream stream) {
            if (ContentType.IsHtml(contentType))
                throw new InvalidContentTypeException(Res.GetString(Res.WebInvalidContentType, contentType), contentType);
            ServiceDescription serviceDescription = ClientProtocol.Documents[Url] as ServiceDescription;
            if( serviceDescription == null ) {
                serviceDescription = ServiceDescription.Read(stream);
                serviceDescription.RetrievalUrl = Url;
                ClientProtocol.Documents[Url] = serviceDescription;
            }

            ClientProtocol.References[Url] = this;
            
            ArrayList importUrls = new ArrayList();
            foreach (Import import in serviceDescription.Imports)
                if (import.Location != null)
                    importUrls.Add(import.Location);
            foreach (XmlSchema schema in serviceDescription.Types.Schemas)
                foreach (XmlSchemaObject includeObject in schema.Includes) {
                    XmlSchemaImport import = includeObject as XmlSchemaImport;
                    if (import != null) {
                        if (import.SchemaLocation != null)
                            importUrls.Add(import.SchemaLocation);
                        continue;
                    }
                    XmlSchemaInclude include = includeObject as XmlSchemaInclude;
                    if (include != null && include.SchemaLocation != null)
                        importUrls.Add(include.SchemaLocation);
                }                
                
            foreach (string urlFromImport in importUrls) {
                // make the (possibly) relative Uri in the contract fully qualified with respect to the contract URL
                string importUrl = new Uri(new Uri(Url, true), urlFromImport, true).ToString();
                if( ClientProtocol.Documents[importUrl] != null ) {
                    continue;
                }

                string oldUrl = importUrl;
                try {
                    stream = ClientProtocol.Download(ref importUrl, ref contentType);
                    try {
                        //Proceed only if not been here before
                        if( ClientProtocol.Documents[importUrl] == null ) {
                            XmlTextReader reader = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
                            reader.WhitespaceHandling = WhitespaceHandling.Significant;
                            reader.XmlResolver = null;
                            //Resolve on WSDL and XSD will go recursivelly
                            if (ServiceDescription.CanRead(reader)) {
                                ServiceDescription doc = ServiceDescription.Read(reader);
                                doc.RetrievalUrl = importUrl;
                                ClientProtocol.Documents[importUrl] = doc;
                                ContractReference contractReference = new ContractReference(importUrl, null);
                                contractReference.ClientProtocol = ClientProtocol;
                                try {
                                    contractReference.Resolve(contentType, stream);
                                }
                                catch {
                                    contractReference.Url = oldUrl;
                                }
                            }
                            else if (reader.IsStartElement("schema", XmlSchema.Namespace)) {
                                ClientProtocol.Documents[importUrl] = XmlSchema.Read(reader, null);
                                SchemaReference schemaReference = new SchemaReference(importUrl);
                                schemaReference.ClientProtocol = ClientProtocol;
                                try {
                                    schemaReference.Resolve(contentType, stream);
                                }
                                catch {
                                    schemaReference.Url = oldUrl;
                                }
                            }
                            // If it's not XML, or we don't know what kind of XML it is, skip the file.  The user 
                            // will have to download the dependent file(s) manually, but at least we will continue 
                            // to discover files instead of throwing an exception.
                        }
                    }
                    finally {
                        stream.Close();
                    }
                }
                catch (Exception e) {
                    throw new InvalidDocumentContentsException(Res.GetString(Res.TheWSDLDocumentContainsLinksThatCouldNotBeResolved, importUrl), e);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\soapprotocolreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapProtocolReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.Web.Services.Configuration;

    internal class SoapProtocolReflector : ProtocolReflector {
        // SoapProtocolInfo protocolInfo;
        ArrayList mappings = new ArrayList();
        SoapExtensionReflector[] extensions;
        SoapReflectedMethod soapMethod;

        public override string ProtocolName { 
            get { return "Soap"; } 
        }

        internal SoapReflectedMethod SoapMethod {
            get { return soapMethod; }
        }

        internal SoapReflectionImporter SoapImporter {
            get { 
                SoapReflectionImporter soapImporter = ReflectionContext[typeof(SoapReflectionImporter)] as SoapReflectionImporter;
                if (soapImporter == null) {
                    soapImporter = SoapReflector.CreateSoapImporter(DefaultNamespace, SoapReflector.ServiceDefaultIsEncoded(ServiceType));
                    ReflectionContext[typeof(SoapReflectionImporter)] = soapImporter;
                }
                return soapImporter;
            }
        }

        internal SoapSchemaExporter SoapExporter {
            get { 
                SoapSchemaExporter soapExporter = ReflectionContext[typeof(SoapSchemaExporter)] as SoapSchemaExporter;
                if (soapExporter == null) {
                    soapExporter = new SoapSchemaExporter(ServiceDescription.Types.Schemas);
                    ReflectionContext[typeof(SoapSchemaExporter)] = soapExporter;
                }
                return soapExporter;
            }
        }

        protected override bool ReflectMethod() {
            soapMethod = ReflectionContext[Method] as SoapReflectedMethod;
            if (soapMethod == null) {
                soapMethod = SoapReflector.ReflectMethod(Method, false, ReflectionImporter, SoapImporter, DefaultNamespace);
                ReflectionContext[Method] = soapMethod;
                soapMethod.portType = Binding != null ? Binding.Type : null;
            }
            WebMethodAttribute methodAttr = WebMethodReflector.GetAttribute(Method);

            OperationBinding.Extensions.Add(CreateSoapOperationBinding(soapMethod.rpc ? SoapBindingStyle.Rpc : SoapBindingStyle.Document, soapMethod.action));

            CreateMessage(soapMethod.rpc, soapMethod.use, soapMethod.paramStyle, InputMessage, OperationBinding.Input, soapMethod.requestMappings);
            if (!soapMethod.oneWay)
                CreateMessage(soapMethod.rpc, soapMethod.use, soapMethod.paramStyle, OutputMessage, OperationBinding.Output, soapMethod.responseMappings);
          
            CreateHeaderMessages(soapMethod.name, soapMethod.use, soapMethod.inHeaderMappings, soapMethod.outHeaderMappings, soapMethod.headers);

            if (soapMethod.rpc && soapMethod.methodInfo.OutParameters.Length > 0)
                Operation.ParameterOrder = GetParameterOrder(soapMethod.methodInfo);

            AllowExtensionsToReflectMethod();

            return true;
        }

        void CreateHeaderMessages(string methodName, SoapBindingUse use, XmlMembersMapping inHeaderMappings, XmlMembersMapping outHeaderMappings, SoapReflectedHeader[] headers) {
            // CONSIDER, alexdej: support headerfault.
            if (use == SoapBindingUse.Encoded) {
                SoapExporter.ExportMembersMapping(inHeaderMappings, false);
                if (outHeaderMappings != null)
                    SoapExporter.ExportMembersMapping(outHeaderMappings, false);
            }
            else {
                SchemaExporter.ExportMembersMapping(inHeaderMappings);
                if (outHeaderMappings != null)
                    SchemaExporter.ExportMembersMapping(outHeaderMappings);
            }

            CodeIdentifiers identifiers = new CodeIdentifiers();
            int inCount = 0, outCount = 0;
            for (int i = 0; i < headers.Length; i++) {
                SoapReflectedHeader soapHeader = headers[i];
                if (!soapHeader.custom) continue;
                
                XmlMemberMapping member;
                if ((soapHeader.direction & SoapHeaderDirection.In) != 0) {
                    member = inHeaderMappings[inCount++];
                    if (soapHeader.direction != SoapHeaderDirection.In)
                        outCount++;
                }
                else {
                    member = outHeaderMappings[outCount++];
                }

                MessagePart part = new MessagePart();
                part.Name = member.ElementName;
                if (use == SoapBindingUse.Encoded)
                    part.Type = new XmlQualifiedName(member.TypeName, member.TypeNamespace);
                else
                    part.Element = new XmlQualifiedName(member.ElementName, member.Namespace);
                
                Message message = new Message();
                message.Name = identifiers.AddUnique(methodName + part.Name, message);
                message.Parts.Add(part);
                HeaderMessages.Add(message);

                ServiceDescriptionFormatExtension soapHeaderBinding = CreateSoapHeaderBinding(new XmlQualifiedName(message.Name, Binding.ServiceDescription.TargetNamespace), part.Name, use);
                
                if ((soapHeader.direction & SoapHeaderDirection.In) != 0)
                    OperationBinding.Input.Extensions.Add(soapHeaderBinding);
                if ((soapHeader.direction & (SoapHeaderDirection.Out | SoapHeaderDirection.Fault)) != 0)
                    OperationBinding.Output.Extensions.Add(soapHeaderBinding);
             }
        }

        void CreateMessage(bool rpc, SoapBindingUse use, SoapParameterStyle paramStyle, Message message, MessageBinding messageBinding, XmlMembersMapping members) {
            bool wrapped = paramStyle != SoapParameterStyle.Bare;

            if (use == SoapBindingUse.Encoded)
                CreateEncodedMessage(message, messageBinding, members, wrapped && !rpc);
            else
                CreateLiteralMessage(message, messageBinding, members, wrapped);
        }

        void CreateEncodedMessage(Message message, MessageBinding messageBinding, XmlMembersMapping members, bool wrapped) {
            SoapExporter.ExportMembersMapping(members, wrapped);

            if (wrapped) {
                MessagePart part = new MessagePart();
                part.Name = "parameters";
                part.Type = new XmlQualifiedName(members.TypeName, members.TypeNamespace);
                message.Parts.Add(part);
            }
            else {
                for (int i = 0; i < members.Count; i++) {
                    XmlMemberMapping member = members[i];
                    MessagePart part = new MessagePart();
                    part.Name = member.ElementName;
                    part.Type = new XmlQualifiedName(member.TypeName, member.TypeNamespace);
                    message.Parts.Add(part);
                }
            }

            messageBinding.Extensions.Add(CreateSoapBodyBinding(SoapBindingUse.Encoded, members.Namespace));
        }

        void CreateLiteralMessage(Message message, MessageBinding messageBinding, XmlMembersMapping members, bool wrapped) {
            if (members.Count == 1 && members[0].Any && members[0].ElementName.Length == 0 && !wrapped) {
                string typeName = SchemaExporter.ExportAnyType(members[0].Namespace);
                MessagePart part = new MessagePart();
                part.Name = members[0].MemberName;
                part.Type = new XmlQualifiedName(typeName, members[0].Namespace);
                message.Parts.Add(part);
            }
            else {
                SchemaExporter.ExportMembersMapping(members);
                if (wrapped) {
                    MessagePart part = new MessagePart();
                    part.Name = "parameters";
                    part.Element = new XmlQualifiedName(members.ElementName, members.Namespace);
                    message.Parts.Add(part);
                }
                else {
                    for (int i = 0; i < members.Count; i++) {
                        XmlMemberMapping member = members[i];
                        MessagePart part = new MessagePart();
                        part.Name = member.MemberName;
                        part.Element = new XmlQualifiedName(member.ElementName, member.Namespace);
                        message.Parts.Add(part);
                    }
                }
            }

            messageBinding.Extensions.Add(CreateSoapBodyBinding(SoapBindingUse.Literal, null));
        }

        static string[] GetParameterOrder(LogicalMethodInfo methodInfo) {
            ParameterInfo[] parameters = methodInfo.Parameters;
            string[] parameterOrder = new string[parameters.Length];
            for (int i = 0; i < parameters.Length; i++) {
                parameterOrder[i] = parameters[i].Name;
            }
            return parameterOrder;
        }

        protected override string ReflectMethodBinding() { 
            return SoapReflector.GetSoapMethodBinding(Method);
        }

        protected override void BeginClass() {
            if (Binding != null) {
                SoapBindingStyle style;
                if (SoapReflector.GetSoapServiceAttribute(ServiceType) is SoapRpcServiceAttribute)
                    style = SoapBindingStyle.Rpc;
                else
                    style = SoapBindingStyle.Document;
                Binding.Extensions.Add(CreateSoapBinding(style));
                SoapReflector.IncludeTypes(Methods, SoapImporter);
            }

            Port.Extensions.Add(CreateSoapAddressBinding(ServiceUrl));
        }

        void AllowExtensionsToReflectMethod() {
            if (extensions == null) {
                Type[] extensionTypes = WebServicesConfiguration.Current.SoapExtensionReflectorTypes;
                extensions = new SoapExtensionReflector[extensionTypes.Length];
                for (int i = 0; i < extensions.Length; i++) {
                    SoapExtensionReflector extension = (SoapExtensionReflector)Activator.CreateInstance(extensionTypes[i]);
                    extension.ReflectionContext = this;
                    extensions[i] = extension;
                }
            }
            foreach (SoapExtensionReflector extension in extensions) {
                extension.ReflectMethod();
            }
        }

        protected virtual SoapBinding CreateSoapBinding(SoapBindingStyle style) {
            SoapBinding soapBinding = new SoapBinding();
            soapBinding.Transport = SoapBinding.HttpTransport;
            soapBinding.Style = style;
            return soapBinding;
        }

        protected virtual SoapAddressBinding CreateSoapAddressBinding(string serviceUrl) {
            SoapAddressBinding soapAddress = new SoapAddressBinding();
            soapAddress.Location = serviceUrl;
            return soapAddress;
        }

        protected virtual SoapOperationBinding CreateSoapOperationBinding(SoapBindingStyle style, string action) {
            SoapOperationBinding soapOperation = new SoapOperationBinding();
            soapOperation.SoapAction = action;
            soapOperation.Style = style;
            return soapOperation;
        }

        protected virtual SoapBodyBinding CreateSoapBodyBinding(SoapBindingUse use, string ns) {
            SoapBodyBinding soapBodyBinding = new SoapBodyBinding();
            soapBodyBinding.Use = use;
            if (use == SoapBindingUse.Encoded)
                soapBodyBinding.Encoding = Soap.Encoding;
            soapBodyBinding.Namespace = ns;
            return soapBodyBinding;
        }

        protected virtual SoapHeaderBinding CreateSoapHeaderBinding(XmlQualifiedName message, string partName, SoapBindingUse use) {
            SoapHeaderBinding soapHeaderBinding = new SoapHeaderBinding();
            soapHeaderBinding.Message = message;
            soapHeaderBinding.Part = partName;
            soapHeaderBinding.Use = use;
            if (use == SoapBindingUse.Encoded)
                soapHeaderBinding.Encoding = Soap.Encoding;
            return soapHeaderBinding;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoverydocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System.Xml.Serialization;
    using System.Xml;
    using System.IO;
    using System;
    using System.Text;
    using System.Collections;
    using System.Web.Services.Configuration;

    /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlRoot("discovery", Namespace=DiscoveryDocument.Namespace)]
    public sealed class DiscoveryDocument {

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string Namespace = "http://schemas.xmlsoap.org/disco/";

        private ArrayList references = new ArrayList();

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.DiscoveryDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryDocument() {
        }

        // NOTE, stefanph: This property is not really ignored by the xml serializer. Instead,
        // the attributes that would go here are configured in WebServicesConfiguration's
        // DiscoveryDocumentSerializer property.
        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.References"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public IList References {
            get {
                return references;
            }
        }

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static DiscoveryDocument Read(Stream stream) {
            XmlTextReader r = new XmlTextReader(stream);
            r.WhitespaceHandling = WhitespaceHandling.Significant;
            r.XmlResolver = null;
            return Read(r);
        }

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.Read1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static DiscoveryDocument Read(TextReader reader) {
            XmlTextReader r = new XmlTextReader(reader);
            r.WhitespaceHandling = WhitespaceHandling.Significant;
            r.XmlResolver = null;
            return Read(r);
        }

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.Read2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static DiscoveryDocument Read(XmlReader xmlReader) {
            return (DiscoveryDocument) WebServicesConfiguration.Current.DiscoveryDocumentSerializer.Deserialize(xmlReader);
        }

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.CanRead"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool CanRead(XmlReader xmlReader) {
            return WebServicesConfiguration.Current.DiscoveryDocumentSerializer.CanDeserialize(xmlReader);
        }

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.Write"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(TextWriter writer) {
            XmlTextWriter xmlWriter = new XmlTextWriter(writer);
            xmlWriter.Formatting = Formatting.Indented;
            xmlWriter.Indentation = 2;
            Write(xmlWriter);
        }

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.Write1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(Stream stream) {
            TextWriter writer = new StreamWriter(stream, new UTF8Encoding(false));
            Write(writer);
        }

        /// <include file='doc\DiscoveryDocument.uex' path='docs/doc[@for="DiscoveryDocument.Write2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(XmlWriter writer) {
            XmlSerializer serializer = WebServicesConfiguration.Current.DiscoveryDocumentSerializer;
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces();
            serializer.Serialize(writer, this, ns);
        }


    }


    // This is a special serializer that hardwires to the generated
    // ServiceDescriptionSerializer. To regenerate the serializer
    // Turn on KEEPTEMPFILES 
    // Restart server
    // Run disco as follows
    //   disco <URL_FOR_VALID_ASMX_FILE>?disco
    // Goto windows temp dir (usually \winnt\temp)
    // and get the latest generated .cs file
    // Change namespace to 'System.Web.Services.Discovery'
    // Change class names to DiscoveryDocumentSerializationWriter
    // and DiscoveryDocumentSerializationReader
    // Make the classes internal
    // Ensure the public Write method is Write10_discovery (If not
    // change Serialize to call the new one)
    // Ensure the public Read method is Read10_discovery (If not
    // change Deserialize to call the new one)
    internal class DiscoveryDocumentSerializer : XmlSerializer {
        protected override XmlSerializationReader CreateReader() {
            return new DiscoveryDocumentSerializationReader();
        }
        protected override XmlSerializationWriter CreateWriter() {
            return new DiscoveryDocumentSerializationWriter();
        }
        public override bool CanDeserialize(System.Xml.XmlReader xmlReader){
            return xmlReader.IsStartElement("discovery", "http://schemas.xmlsoap.org/disco/");
        }
        protected override void Serialize(Object objectToSerialize, XmlSerializationWriter writer){
            ((DiscoveryDocumentSerializationWriter)writer).Write10_discovery(objectToSerialize);
        }
        protected override object Deserialize(XmlSerializationReader reader){
            return ((DiscoveryDocumentSerializationReader)reader).Read10_discovery();
        }
    }
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoveryclientreferences.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryClientReferences.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    
    using System.Collections;
    using System.Diagnostics;
    using System.Security.Permissions;

    /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryClientReferenceCollection : DictionaryBase {

        /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryReference this[string url] {
            get {
                return (DiscoveryReference) Dictionary[url];
            }
            set {
                Dictionary[url] = value;
            }
        }

        /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Keys {
            get { return Dictionary.Keys; }
        }

        /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return Dictionary.Values;
            }
        }

        /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(DiscoveryReference value) {
            Add(value.Url, value);
        }

        /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(string url, DiscoveryReference value) {
            Dictionary.Add(url, value);
        }

        /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(string url) {
            return Dictionary.Contains(url);
        }

        /// <include file='doc\DiscoveryClientReferences.uex' path='docs/doc[@for="DiscoveryClientReferenceCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(string url) {
            Dictionary.Remove(url);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoveryclientprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryClientProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System.Xml.Serialization;
    using System.IO;
    using System;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Net;
    using System.Collections;
    using System.Diagnostics;
    using System.Web.Services.Configuration;
    using System.Text;
    using System.Security.Permissions;
    using System.Globalization;

    /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class DiscoveryClientProtocol : HttpWebClientProtocol {

        private DiscoveryClientReferenceCollection references = new DiscoveryClientReferenceCollection();
        private DiscoveryClientDocumentCollection documents = new DiscoveryClientDocumentCollection();
        private ArrayList additionalInformation = new ArrayList();
        private DiscoveryExceptionDictionary errors = new DiscoveryExceptionDictionary();

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.DiscoveryClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryClientProtocol()
            : base() {
        }

        internal DiscoveryClientProtocol(HttpWebClientProtocol protocol) : base(protocol) {
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.AdditionalInformation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IList AdditionalInformation {
            get {
                return additionalInformation;
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.Documents"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryClientDocumentCollection Documents {
            get {
                return documents;
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.Errors"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryExceptionDictionary Errors {
            get {
                return errors;
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.References"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryClientReferenceCollection References {
            get {
                return references;
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.Discover"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public DiscoveryDocument Discover(string url) {
            DiscoveryDocument doc = Documents[url] as DiscoveryDocument;
            if (doc != null)
                return doc;

            DiscoveryDocumentReference docRef = new DiscoveryDocumentReference(url);
            docRef.ClientProtocol = this;
            References[url] = docRef;

            Errors.Clear();
            // this will auto-resolve and place the document in the Documents hashtable.
            return docRef.Document;
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.DiscoverAny"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public DiscoveryDocument DiscoverAny(string url) {
            Type[] refTypes = WebServicesConfiguration.Current.DiscoveryReferenceTypes;
            DiscoveryReference discoRef = null;
            string contentType = null;
            Stream stream = Download(ref url, ref contentType);

            Errors.Clear();
            bool allErrorsAreHtmlContentType = true;
            Exception errorInValidDocument = null;
            ArrayList specialErrorMessages = new ArrayList();
            foreach (Type type in refTypes) {
                if (!typeof(DiscoveryReference).IsAssignableFrom(type))
                    continue;
                discoRef = (DiscoveryReference) Activator.CreateInstance(type);
                discoRef.Url = url;
                discoRef.ClientProtocol = this;
                stream.Position = 0;
                Exception e = discoRef.AttemptResolve(contentType, stream);
                if (e == null)
                    break;

                Errors[type.FullName] = e;
                discoRef = null;

                InvalidContentTypeException e2 = e as InvalidContentTypeException;
                if (e2 == null || !ContentType.MatchesBase(e2.ContentType, "text/html"))
                    allErrorsAreHtmlContentType = false;
                
                InvalidDocumentContentsException e3 = e as InvalidDocumentContentsException;
                if (e3 != null) {
                    errorInValidDocument = e;
                    break;
                }

                if (e.InnerException != null && e.InnerException.InnerException == null)
                    specialErrorMessages.Add(e.InnerException.Message);
            }

            if (discoRef == null) {
                if (errorInValidDocument != null) {
                    StringBuilder errorMessage = new StringBuilder(Res.GetString(Res.TheDocumentWasUnderstoodButContainsErrors));
                    while (errorInValidDocument != null) {
                        errorMessage.Append("\n  - ").Append(errorInValidDocument.Message);
                        errorInValidDocument = errorInValidDocument.InnerException;
                    }
                    throw new InvalidOperationException(errorMessage.ToString());
                }
                else if (allErrorsAreHtmlContentType) {
                    throw new InvalidOperationException(Res.GetString(Res.TheHTMLDocumentDoesNotContainDiscoveryInformation));
                }
                else {
                    bool same = specialErrorMessages.Count == Errors.Count && Errors.Count > 0;
                    for (int i = 1; same && i < specialErrorMessages.Count; i++) {
                        if ((string) specialErrorMessages[i-1] != (string) specialErrorMessages[i])
                            same = false;
                    }
                    if (same)
                        throw new InvalidOperationException(Res.GetString(Res.TheDocumentWasNotRecognizedAsAKnownDocumentType, specialErrorMessages[0]));
                    else {
                        Exception e;
                        StringBuilder errorMessage = new StringBuilder(Res.GetString(Res.WebMissingResource, url));
                        foreach (DictionaryEntry entry in Errors) {
                            e = (Exception)(entry.Value);
                            string refType = (string)(entry.Key);
                            if (0 == string.Compare(refType, typeof(ContractReference).FullName, false, CultureInfo.InvariantCulture)) {
                                refType = Res.GetString(Res.WebContractReferenceName);
                            }
                            else if (0 == string.Compare(refType, typeof(SchemaReference).FullName, false, CultureInfo.InvariantCulture)) {
                                refType = Res.GetString(Res.WebShemaReferenceName);
                            }
                            else if (0 == string.Compare(refType, typeof(DiscoveryDocumentReference).FullName, false, CultureInfo.InvariantCulture)) {
                                refType = Res.GetString(Res.WebDiscoveryDocumentReferenceName);
                            }
                            errorMessage.Append("\n- ").Append(Res.GetString(Res.WebDiscoRefReport,
                                                               refType,
                                                               e.Message));
                            while (e.InnerException != null) {
                                errorMessage.Append("\n  - ").Append(e.InnerException.Message);
                                e = e.InnerException;
                            }
                        }
                        throw new InvalidOperationException(errorMessage.ToString());
                    }
                }
            }

            if (discoRef is DiscoveryDocumentReference)
                return ((DiscoveryDocumentReference) discoRef).Document;

            References[discoRef.Url] = discoRef;
            DiscoveryDocument doc = new DiscoveryDocument();
            doc.References.Add(discoRef);
            return doc;
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.Download"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public Stream Download(ref string url) {
            string contentType = null;
            return Download(ref url, ref contentType);
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.Download1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public Stream Download(ref string url, ref string contentType) {
            WebRequest request = GetWebRequest(new Uri(url));
            request.Method = "GET";
            HttpWebRequest httpRequest = request as HttpWebRequest;
            WebResponse response = null;
            try {
                response = GetWebResponse(request);
            }
            catch (Exception e) {
                throw new WebException(Res.GetString(Res.ThereWasAnErrorDownloading0, url), e);
            }
            HttpWebResponse httpResponse = response as HttpWebResponse;
            if (httpResponse != null) {
                if (httpResponse.StatusCode != HttpStatusCode.OK) {
                    string errorMessage = RequestResponseUtils.CreateResponseExceptionString(httpResponse);
                    throw new WebException(Res.GetString(Res.ThereWasAnErrorDownloading0, url), new WebException(errorMessage, null, WebExceptionStatus.ProtocolError, response));
                }
            }
            Stream responseStream = response.GetResponseStream();
            try {
                // Uri.ToString() returns the unescaped version
                url = response.ResponseUri.ToString();
                contentType = response.ContentType;

                if (response.ResponseUri.Scheme == Uri.UriSchemeFtp ||
                    response.ResponseUri.Scheme == Uri.UriSchemeFile) {
                    int dotIndex = response.ResponseUri.AbsolutePath.LastIndexOf('.');
                    if (dotIndex != -1) {
                       switch (response.ResponseUri.AbsolutePath.Substring(dotIndex+1).ToLower(CultureInfo.InvariantCulture)) {
                       case "xml":
                       case "wsdl":
                       case "xsd":
                       case "disco":
                              contentType = ContentType.TextXml;
                              break;
                       default:
                              break;
                       }
                    }
                }

                // need to return a buffered stream (one that supports CanSeek)
                return RequestResponseUtils.StreamToMemoryStream(responseStream);
            }
            finally {
                responseStream.Close();
            }
        }

        private static bool IsFilenameInUse(Hashtable filenames, string path) {
            return filenames[path.ToLower(CultureInfo.InvariantCulture)] != null;
        }

        private static void AddFilename(Hashtable filenames, string path) {
            filenames.Add(path.ToLower(CultureInfo.InvariantCulture), path);
        }

        private static string GetUniqueFilename(Hashtable filenames, string path) {
            if (IsFilenameInUse(filenames, path)) {
                string extension = Path.GetExtension(path);
                string allElse = path.Substring(0, path.Length - extension.Length);
                int append = 0;
                do {
                    path = allElse + append.ToString() + extension;
                    append++;
                } while (IsFilenameInUse(filenames, path));
            }

            AddFilename(filenames, path);
            return path;
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.ReadAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public DiscoveryClientResultCollection ReadAll(string topLevelFilename) {
            XmlSerializer ser = new XmlSerializer(typeof(DiscoveryClientResultsFile));
            Stream file = File.OpenRead(topLevelFilename);
            string topLevelPath = Path.GetDirectoryName(topLevelFilename);
            DiscoveryClientResultsFile results = null;
            try {
                results = (DiscoveryClientResultsFile) ser.Deserialize(file);
                for (int i = 0; i < results.Results.Count; i++) {
                    DiscoveryReference reference = (DiscoveryReference) Activator.CreateInstance(Type.GetType(results.Results[i].ReferenceTypeName));
                    reference.ClientProtocol = this;
                    reference.Url = results.Results[i].Url;
                    Stream docFile = File.OpenRead(Path.Combine(topLevelPath, results.Results[i].Filename));
                    try {
                        Documents[results.Results[i].Url] = reference.ReadDocument(docFile);
                        Debug.Assert(Documents[results.Results[i].Url] != null, "Couldn't deserialize file " + results.Results[i].Filename);
                    }
                    finally {
                        docFile.Close();
                    }
                    References[reference.Url] = reference;
                }
            }
            finally {
                file.Close();
            }

            return results.Results;
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.ResolveAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public void ResolveAll() {
            // Resolve until we reach a 'steady state' (no more references added)
            Errors.Clear();
            int resolvedCount = 0;
            while (resolvedCount != References.Count) {
                resolvedCount = References.Count;
                DiscoveryReference[] refs = new DiscoveryReference[References.Count];
                References.Values.CopyTo(refs, 0);
                for (int i = 0; i < refs.Length; i++) {
                    DiscoveryReference discoRef = refs[i];
                    if (discoRef is DiscoveryDocumentReference) {
                        try {
                            // Resolve discovery document references deeply
                            ((DiscoveryDocumentReference)discoRef).ResolveAll(true);
                        }
                        catch (Exception e) {
                            // don't let the exception out - keep going. Just add it to the list of errors.
                            Errors[discoRef.Url] = e;
                        }
                    }
                    else {
                        try {
                            discoRef.Resolve();
                        }
                        catch (Exception e) {
                            // don't let the exception out - keep going. Just add it to the list of errors.
                            Errors[discoRef.Url] = e;
                        }
                    }
                }
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.ResolveOneLevel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public void ResolveOneLevel() {
            // download everything we have a reference to, but don't recurse.
            Errors.Clear();
            DiscoveryReference[] refs = new DiscoveryReference[References.Count];
            References.Values.CopyTo(refs, 0);
            for (int i = 0; i < refs.Length; i++) {
                try {
                    refs[i].Resolve();
                }
                catch (Exception e) {
                    // don't let the exception out - keep going. Just add it to the list of errors.
                    Errors[refs[i].Url] = e;
                }
            }
        }

        private static string GetRelativePath(string fullPath, string relativeTo) {
            string currentDir = Path.GetDirectoryName(Path.GetFullPath(relativeTo));

            string answer = "";
            while (currentDir.Length > 0) {
                if (currentDir.Length <= fullPath.Length && string.Compare(currentDir, fullPath.Substring(0, currentDir.Length), true, CultureInfo.InvariantCulture) == 0) {
                    answer += fullPath.Substring(currentDir.Length);
                    if (answer.StartsWith("\\"))
                        answer = answer.Substring(1);
                    return answer;
                }
                answer += "..\\";
                if (currentDir.Length < 2)
                    break;
                else {
                    int lastSlash = currentDir.LastIndexOf('\\', currentDir.Length - 2);
                    currentDir = currentDir.Substring(0, lastSlash+1);
                }
            }
            return fullPath;
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.WriteAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public DiscoveryClientResultCollection WriteAll(string directory, string topLevelFilename) {
            DiscoveryClientResultsFile results = new DiscoveryClientResultsFile();
            Hashtable filenames = new Hashtable();
            string topLevelFullPath = Path.Combine(directory, topLevelFilename);

            // write out each of the documents
            DictionaryEntry[] entries = new DictionaryEntry[Documents.Count];
            int i = 0;
            foreach (DictionaryEntry entry in Documents) {
                entries[i++] = entry;
            }
            foreach (DictionaryEntry entry in entries) {
                string url = (string) entry.Key;
                object document = entry.Value;
                if (document == null)
                    continue;
                DiscoveryReference reference = References[url];
                string filename = GetUniqueFilename(filenames, Path.GetFullPath(Path.Combine(directory, reference.DefaultFilename)));
                results.Results.Add(new DiscoveryClientResult(reference.GetType(), url, GetRelativePath(filename, topLevelFullPath)));
                Stream file = File.Create(filename);
                try {
                    reference.WriteDocument(document, file);
                }
                finally {
                    file.Close();
                }
            }

            // write out the file that points to all those documents.
            XmlSerializer ser = new XmlSerializer(typeof(DiscoveryClientResultsFile));
            Stream topLevelFile = File.Create(topLevelFullPath);
            try {
                ser.Serialize(new StreamWriter(topLevelFile, new UTF8Encoding(false)), results);
            }
            finally {
                topLevelFile.Close();
            }

            return results.Results;
        }

        // CONSIDER, stefanph: There was an issue in xml serialization with a collection
        // as the root element. It's fixed now, but removing the class would be a breaking change.
        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.DiscoveryClientResultsFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public sealed class DiscoveryClientResultsFile {
            private DiscoveryClientResultCollection results = new DiscoveryClientResultCollection();
            /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientProtocol.DiscoveryClientResultsFile.Results"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public DiscoveryClientResultCollection Results {
                get {
                    return results;
                }
            }
        }

    }

    /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResultCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryClientResultCollection : CollectionBase {

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResultCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryClientResult this[int i] {
            get {
                return (DiscoveryClientResult) List[i];
            }
            set {
                List[i] = value;
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResultCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(DiscoveryClientResult value) {
            return List.Add(value);
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResultCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(DiscoveryClientResult value) {
            return List.Contains(value);
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResultCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(DiscoveryClientResult value) {
            List.Remove(value);
        }

    }

    /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResult"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryClientResult {
        string referenceTypeName;
        string url;
        string filename;

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResult.DiscoveryClientResult"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryClientResult() {
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResult.DiscoveryClientResult1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryClientResult(Type referenceType, string url, string filename) {
            ReferenceTypeName = referenceType.FullName;
            Url = url;
            Filename = filename;
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResult.ReferenceTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("referenceType")]
        public string ReferenceTypeName {
            get {
                return referenceTypeName;
            }
            set {
                referenceTypeName = value;
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResult.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("url")]
        public string Url {
            get {
                return url;
            }
            set {
                url = value;
            }
        }

        /// <include file='doc\DiscoveryClientProtocol.uex' path='docs/doc[@for="DiscoveryClientResult.Filename"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("filename")]
        public string Filename {
            get {
                return filename;
            }
            set {
                filename = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoverydocumentsearchpattern.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryDocumentSearchPattern.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.Security.Permissions;

    /// <include file='doc\DiscoveryDocumentSearchPattern.uex' path='docs/doc[@for="DiscoveryDocumentSearchPattern"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryDocumentSearchPattern : DiscoverySearchPattern {
        /// <include file='doc\DiscoveryDocumentSearchPattern.uex' path='docs/doc[@for="DiscoveryDocumentSearchPattern.Pattern"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Pattern {
            get {
                return "*.vsdisco";
            }
        }

        /// <include file='doc\DiscoveryDocumentSearchPattern.uex' path='docs/doc[@for="DiscoveryDocumentSearchPattern.GetDiscoveryReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override DiscoveryReference GetDiscoveryReference(string filename) {
            return new DiscoveryDocumentReference(filename);
        }
    }  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoverydocumentlinkspattern.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryDocumentLinksPattern.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.Security.Permissions;

    /// <include file='doc\DiscoveryDocumentLinksPattern.uex' path='docs/doc[@for="DiscoveryDocumentLinksPattern"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class DiscoveryDocumentLinksPattern : DiscoverySearchPattern {
        /// <include file='doc\DiscoveryDocumentLinksPattern.uex' path='docs/doc[@for="DiscoveryDocumentLinksPattern.Pattern"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Pattern {
            get {
                return "*.disco";
            }
        }

        /// <include file='doc\DiscoveryDocumentLinksPattern.uex' path='docs/doc[@for="DiscoveryDocumentLinksPattern.GetDiscoveryReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override DiscoveryReference GetDiscoveryReference(string filename) {
            return new DiscoveryDocumentReference(filename);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoverydocumentserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryDocumentSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   DiscoveryDocumentSerializer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Discovery{
internal class DiscoveryDocumentSerializationWriter : System.Xml.Serialization.XmlSerializationWriter {

        void Write1_DiscoveryDocument(string n, string ns, System.Web.Services.Discovery.DiscoveryDocument o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.DiscoveryDocument))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"DiscoveryDocument", @"http://schemas.xmlsoap.org/disco/");
            {
                System.Collections.IList a = (System.Collections.IList)o.@References;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Discovery.SchemaReference) {
                                Write7_SchemaReference(@"schemaRef", @"http://schemas.xmlsoap.org/disco/schema/", ((System.Web.Services.Discovery.SchemaReference)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Discovery.SoapBinding) {
                                Write9_SoapBinding(@"soap", @"http://schemas.xmlsoap.org/disco/soap/", ((System.Web.Services.Discovery.SoapBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Discovery.DiscoveryDocumentReference) {
                                Write2_DiscoveryDocumentReference(@"discoveryRef", @"http://schemas.xmlsoap.org/disco/", ((System.Web.Services.Discovery.DiscoveryDocumentReference)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Discovery.ContractReference) {
                                Write5_ContractReference(@"contractRef", @"http://schemas.xmlsoap.org/disco/scl/", ((System.Web.Services.Discovery.ContractReference)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write2_DiscoveryDocumentReference(string n, string ns, System.Web.Services.Discovery.DiscoveryDocumentReference o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.DiscoveryDocumentReference))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"DiscoveryDocumentReference", @"http://schemas.xmlsoap.org/disco/");
            WriteAttribute(@"ref", @"", (System.String)o.@Ref);
            WriteEndElement(o);
        }

        void Write3_DiscoveryReference(string n, string ns, System.Web.Services.Discovery.DiscoveryReference o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.DiscoveryReference))
                    ;
                else if (t == typeof(System.Web.Services.Discovery.DiscoveryDocumentReference)) {
                    Write2_DiscoveryDocumentReference(n, ns, (System.Web.Services.Discovery.DiscoveryDocumentReference)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write4_Object(string n, string ns, System.Object o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Object))
                    ;
                else if (t == typeof(System.Web.Services.Discovery.DiscoveryDocument)) {
                    Write1_DiscoveryDocument(n, ns, (System.Web.Services.Discovery.DiscoveryDocument)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Discovery.SoapBinding)) {
                    Write9_SoapBinding(n, ns, (System.Web.Services.Discovery.SoapBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Discovery.DiscoveryReference)) {
                    Write8_DiscoveryReference(n, ns, (System.Web.Services.Discovery.DiscoveryReference)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Discovery.SchemaReference)) {
                    Write7_SchemaReference(n, ns, (System.Web.Services.Discovery.SchemaReference)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Discovery.DiscoveryReference)) {
                    Write6_DiscoveryReference(n, ns, (System.Web.Services.Discovery.DiscoveryReference)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Discovery.ContractReference)) {
                    Write5_ContractReference(n, ns, (System.Web.Services.Discovery.ContractReference)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Discovery.DiscoveryReference)) {
                    Write3_DiscoveryReference(n, ns, (System.Web.Services.Discovery.DiscoveryReference)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Discovery.DiscoveryDocumentReference)) {
                    Write2_DiscoveryDocumentReference(n, ns, (System.Web.Services.Discovery.DiscoveryDocumentReference)o, isNullable, true);
                    return;
                }
                else {
                    WriteTypedPrimitive(n, ns, o, true);
                    return;
                }
            }
            WriteStartElement(n, ns, o);
            WriteEndElement(o);
        }

        void Write5_ContractReference(string n, string ns, System.Web.Services.Discovery.ContractReference o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.ContractReference))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"ContractReference", @"http://schemas.xmlsoap.org/disco/scl/");
            WriteAttribute(@"ref", @"", (System.String)o.@Ref);
            WriteAttribute(@"docRef", @"", (System.String)o.@DocRef);
            WriteEndElement(o);
        }

        void Write6_DiscoveryReference(string n, string ns, System.Web.Services.Discovery.DiscoveryReference o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.DiscoveryReference))
                    ;
                else if (t == typeof(System.Web.Services.Discovery.ContractReference)) {
                    Write5_ContractReference(n, ns, (System.Web.Services.Discovery.ContractReference)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write7_SchemaReference(string n, string ns, System.Web.Services.Discovery.SchemaReference o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.SchemaReference))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SchemaReference", @"http://schemas.xmlsoap.org/disco/schema/");
            WriteAttribute(@"ref", @"", (System.String)o.@Ref);
            if ((System.String)o.@TargetNamespace != null) {
                WriteAttribute(@"targetNamespace", @"", (System.String)o.@TargetNamespace);
            }
            WriteEndElement(o);
        }

        void Write8_DiscoveryReference(string n, string ns, System.Web.Services.Discovery.DiscoveryReference o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.DiscoveryReference))
                    ;
                else if (t == typeof(System.Web.Services.Discovery.SchemaReference)) {
                    Write7_SchemaReference(n, ns, (System.Web.Services.Discovery.SchemaReference)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write9_SoapBinding(string n, string ns, System.Web.Services.Discovery.SoapBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Discovery.SoapBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapBinding", @"http://schemas.xmlsoap.org/disco/soap/");
            WriteAttribute(@"address", @"", (System.String)o.@Address);
            WriteAttribute(@"binding", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Binding));
            WriteEndElement(o);
        }

        protected override void InitCallbacks() {
        }

        public void Write10_discovery(object o) {
            WriteStartDocument();
            if (o == null) {
                WriteNullTagLiteral(@"discovery", @"http://schemas.xmlsoap.org/disco/");
                return;
            }
            TopLevelElement();
            Write1_DiscoveryDocument(@"discovery", @"http://schemas.xmlsoap.org/disco/", ((System.Web.Services.Discovery.DiscoveryDocument)o), true, false);
        }
    }
    internal class DiscoveryDocumentSerializationReader : System.Xml.Serialization.XmlSerializationReader {

        System.Web.Services.Discovery.DiscoveryDocument Read1_DiscoveryDocument(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id1_DiscoveryDocument && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgdisco))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Discovery.DiscoveryDocument o = new System.Web.Services.Discovery.DiscoveryDocument();
            System.Collections.IList a_0 = (System.Collections.IList)o.@References;
            bool[] paramsRead = new bool[1];
            while (Reader.MoveToNextAttribute()) {
                if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id3_schemaRef && (object) Reader.NamespaceURI == (object)id4_httpschemasxmlsoaporgdiscoschema)) {
                        if ((object)(a_0) == null) Reader.Skip(); else a_0.Add(Read7_SchemaReference(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id5_soap && (object) Reader.NamespaceURI == (object)id6_httpschemasxmlsoaporgdiscosoap)) {
                        if ((object)(a_0) == null) Reader.Skip(); else a_0.Add(Read9_SoapBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id7_discoveryRef && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgdisco)) {
                        if ((object)(a_0) == null) Reader.Skip(); else a_0.Add(Read2_DiscoveryDocumentReference(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id8_contractRef && (object) Reader.NamespaceURI == (object)id9_httpschemasxmlsoaporgdiscoscl)) {
                        if ((object)(a_0) == null) Reader.Skip(); else a_0.Add(Read5_ContractReference(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Discovery.DiscoveryDocumentReference Read2_DiscoveryDocumentReference(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id10_DiscoveryDocumentReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgdisco))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Discovery.DiscoveryDocumentReference o = new System.Web.Services.Discovery.DiscoveryDocumentReference();
            bool[] paramsRead = new bool[1];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id11_ref && (object) Reader.NamespaceURI == (object)id12_Item)) {
                    o.@Ref = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Discovery.DiscoveryReference Read3_DiscoveryReference(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DiscoveryReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgdisco))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id10_DiscoveryDocumentReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgdisco))
                    return Read2_DiscoveryDocumentReference(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"DiscoveryReference", @"http://schemas.xmlsoap.org/disco/");
        }

        System.Object Read4_Object(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null)
                    return ReadTypedPrimitive(new System.Xml.XmlQualifiedName("anyType", "http://www.w3.org/2001/XMLSchema"));
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id1_DiscoveryDocument && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgdisco))
                    return Read1_DiscoveryDocument(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id14_SoapBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id6_httpschemasxmlsoaporgdiscosoap))
                    return Read9_SoapBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DiscoveryReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id4_httpschemasxmlsoaporgdiscoschema))
                    return Read8_DiscoveryReference(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id15_SchemaReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id4_httpschemasxmlsoaporgdiscoschema))
                    return Read7_SchemaReference(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DiscoveryReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id9_httpschemasxmlsoaporgdiscoscl))
                    return Read6_DiscoveryReference(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id16_ContractReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id9_httpschemasxmlsoaporgdiscoscl))
                    return Read5_ContractReference(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DiscoveryReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgdisco))
                    return Read3_DiscoveryReference(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id10_DiscoveryDocumentReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgdisco))
                    return Read2_DiscoveryDocumentReference(isNullable, false);
                else
                    return ReadTypedPrimitive((System.Xml.XmlQualifiedName)t);
            }
            System.Object o = new System.Object();
            bool[] paramsRead = new bool[0];
            while (Reader.MoveToNextAttribute()) {
                if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Discovery.ContractReference Read5_ContractReference(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id16_ContractReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id9_httpschemasxmlsoaporgdiscoscl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Discovery.ContractReference o = new System.Web.Services.Discovery.ContractReference();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id11_ref && (object) Reader.NamespaceURI == (object)id12_Item)) {
                    o.@Ref = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id17_docRef && (object) Reader.NamespaceURI == (object)id12_Item)) {
                    o.@DocRef = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Discovery.DiscoveryReference Read6_DiscoveryReference(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DiscoveryReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id9_httpschemasxmlsoaporgdiscoscl))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id16_ContractReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id9_httpschemasxmlsoaporgdiscoscl))
                    return Read5_ContractReference(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"DiscoveryReference", @"http://schemas.xmlsoap.org/disco/scl/");
        }

        System.Web.Services.Discovery.SchemaReference Read7_SchemaReference(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id15_SchemaReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id4_httpschemasxmlsoaporgdiscoschema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Discovery.SchemaReference o = new System.Web.Services.Discovery.SchemaReference();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id11_ref && (object) Reader.NamespaceURI == (object)id12_Item)) {
                    o.@Ref = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id18_targetNamespace && (object) Reader.NamespaceURI == (object)id12_Item)) {
                    o.@TargetNamespace = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Discovery.DiscoveryReference Read8_DiscoveryReference(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DiscoveryReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id4_httpschemasxmlsoaporgdiscoschema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id15_SchemaReference && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id4_httpschemasxmlsoaporgdiscoschema))
                    return Read7_SchemaReference(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"DiscoveryReference", @"http://schemas.xmlsoap.org/disco/schema/");
        }

        System.Web.Services.Discovery.SoapBinding Read9_SoapBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id14_SoapBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id6_httpschemasxmlsoaporgdiscosoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Discovery.SoapBinding o = new System.Web.Services.Discovery.SoapBinding();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id19_address && (object) Reader.NamespaceURI == (object)id12_Item)) {
                    o.@Address = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id20_binding && (object) Reader.NamespaceURI == (object)id12_Item)) {
                    o.@Binding = ToXmlQualifiedName(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }
        protected override void InitCallbacks() {
        }

        public object Read10_discovery() {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                if (((object) Reader.LocalName == (object)id21_discovery && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgdisco)) {
                    o = Read1_DiscoveryDocument(true, true);
                }
                else {
                    throw CreateUnknownNodeException();
                }
            }
            else {
                UnknownNode(null);
            }
            return (object)o;
        }

        System.String id15_SchemaReference;
        System.String id6_httpschemasxmlsoaporgdiscosoap;
        System.String id3_schemaRef;
        System.String id5_soap;
        System.String id21_discovery;
        System.String id7_discoveryRef;
        System.String id16_ContractReference;
        System.String id11_ref;
        System.String id8_contractRef;
        System.String id14_SoapBinding;
        System.String id20_binding;
        System.String id12_Item;
        System.String id1_DiscoveryDocument;
        System.String id18_targetNamespace;
        System.String id10_DiscoveryDocumentReference;
        System.String id17_docRef;
        System.String id19_address;
        System.String id2_httpschemasxmlsoaporgdisco;
        System.String id9_httpschemasxmlsoaporgdiscoscl;
        System.String id4_httpschemasxmlsoaporgdiscoschema;
        System.String id13_DiscoveryReference;

        protected override void InitIDs() {
            id15_SchemaReference = Reader.NameTable.Add(@"SchemaReference");
            id6_httpschemasxmlsoaporgdiscosoap = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/disco/soap/");
            id3_schemaRef = Reader.NameTable.Add(@"schemaRef");
            id5_soap = Reader.NameTable.Add(@"soap");
            id21_discovery = Reader.NameTable.Add(@"discovery");
            id7_discoveryRef = Reader.NameTable.Add(@"discoveryRef");
            id16_ContractReference = Reader.NameTable.Add(@"ContractReference");
            id11_ref = Reader.NameTable.Add(@"ref");
            id8_contractRef = Reader.NameTable.Add(@"contractRef");
            id14_SoapBinding = Reader.NameTable.Add(@"SoapBinding");
            id20_binding = Reader.NameTable.Add(@"binding");
            id12_Item = Reader.NameTable.Add(@"");
            id1_DiscoveryDocument = Reader.NameTable.Add(@"DiscoveryDocument");
            id18_targetNamespace = Reader.NameTable.Add(@"targetNamespace");
            id10_DiscoveryDocumentReference = Reader.NameTable.Add(@"DiscoveryDocumentReference");
            id17_docRef = Reader.NameTable.Add(@"docRef");
            id19_address = Reader.NameTable.Add(@"address");
            id2_httpschemasxmlsoaporgdisco = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/disco/");
            id9_httpschemasxmlsoaporgdiscoscl = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/disco/scl/");
            id4_httpschemasxmlsoaporgdiscoschema = Reader.NameTable.Add(@"http://schemas.xmlsoap.org/disco/schema/");
            id13_DiscoveryReference = Reader.NameTable.Add(@"DiscoveryReference");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoveryexceptiondictionary.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryExceptionDictionary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\DiscoveryExceptionDictionary.uex' path='docs/doc[@for="DiscoveryExceptionDictionary"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryExceptionDictionary : DictionaryBase {

        /// <include file='doc\DiscoveryExceptionDictionary.uex' path='docs/doc[@for="DiscoveryExceptionDictionary.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Exception this[string url] {
            get {
                return (Exception) Dictionary[url];
            }
            set {
                Dictionary[url] = value;
            }
        }

        /// <include file='doc\DiscoveryExceptionDictionary.uex' path='docs/doc[@for="DiscoveryExceptionDictionary.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Keys {
            get { return Dictionary.Keys; }
        }

        /// <include file='doc\DiscoveryExceptionDictionary.uex' path='docs/doc[@for="DiscoveryExceptionDictionary.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return Dictionary.Values;
            }
        }

        /// <include file='doc\DiscoveryExceptionDictionary.uex' path='docs/doc[@for="DiscoveryExceptionDictionary.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(string url, Exception value) {
            Dictionary.Add(url, value);
        }

        /// <include file='doc\DiscoveryExceptionDictionary.uex' path='docs/doc[@for="DiscoveryExceptionDictionary.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(string url) {
            return Dictionary.Contains(url);
        }

        /// <include file='doc\DiscoveryExceptionDictionary.uex' path='docs/doc[@for="DiscoveryExceptionDictionary.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(string url) {
            Dictionary.Remove(url);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoverydocumentreference.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryDocumentReference.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;
    using System.Net;
    using System.Xml;
    using System.Diagnostics;
    using System.IO;
    using System.Xml.Serialization;
    using System.Web.Services.Protocols;
    using System.Web.Services.Configuration;
    using System.Text;
    using System.Globalization;
    
    /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlRoot("discoveryRef", Namespace=DiscoveryDocument.Namespace)]
    public sealed class DiscoveryDocumentReference : DiscoveryReference {

        private string reference;

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.DiscoveryDocumentReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryDocumentReference() {
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.DiscoveryDocumentReference1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryDocumentReference(string href) {
            Ref = href;
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.Ref"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("ref")]
        public string Ref {
            get {
                return reference == null? "" : reference;
            }
            set {
                reference = value;
            }
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.DefaultFilename"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override string DefaultFilename {
            get {
                string filename = FilenameFromUrl(Url);
                return Path.ChangeExtension(filename, ".disco");        // [alexvec] change default extension
            }
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.Document"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public DiscoveryDocument Document {
            get {
                if (ClientProtocol == null)
                    throw new InvalidOperationException(Res.GetString(Res.WebMissingClientProtocol));
                object document = ClientProtocol.Documents[Url];
                if (document == null) {
                    Resolve();
                    document = ClientProtocol.Documents[Url];
                }
                DiscoveryDocument discoDocument = document as DiscoveryDocument;
                if (discoDocument == null) {
                    throw new InvalidOperationException(Res.GetString(Res.WebInvalidDocType, 
                                                      typeof(DiscoveryDocument).FullName,
                                                      document == null? string.Empty: document.GetType().FullName,
                                                      Url));
                }
                return discoDocument;
            }
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.WriteDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteDocument(object document, Stream stream) {
            WebServicesConfiguration.Current.DiscoveryDocumentSerializer.Serialize(new StreamWriter(stream, new UTF8Encoding(false)), document);
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.ReadDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ReadDocument(Stream stream) {
            return WebServicesConfiguration.Current.DiscoveryDocumentSerializer.Deserialize(stream);
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override string Url {
            get { return Ref; }
            set { Ref = value; }
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.GetDocumentNoParse"]/*' />
        /// <devdoc>
        /// Retrieves a discovery document from Url, either out of the ClientProtocol
        /// or from a stream. Does not
        /// </devdoc>
        private static DiscoveryDocument GetDocumentNoParse(ref string url, DiscoveryClientProtocol client) {
            DiscoveryDocument d = (DiscoveryDocument) client.Documents[url];
            if (d != null) {
                return d;
            }

            string contentType = null;               

            Stream stream = client.Download(ref url, ref contentType);
            try {
                XmlTextReader reader = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
                reader.WhitespaceHandling = WhitespaceHandling.Significant;
                reader.XmlResolver = null;
                if (!DiscoveryDocument.CanRead(reader)) {
                    // there is no discovery document at this location
                    ArgumentException exception = new ArgumentException(Res.GetString(Res.WebInvalidFormat));
                    throw new InvalidOperationException(Res.GetString(Res.WebMissingDocument, url), exception);
                }
                return DiscoveryDocument.Read(reader);
            }
            finally {
                stream.Close();
            }
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.Resolve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal override void Resolve(string contentType, Stream stream) {
            DiscoveryDocument document = null;

            if (ContentType.IsHtml(contentType)) {
                string newRef = LinkGrep.SearchForLink(stream);
                if (newRef != null) {
                    string newUrl = new Uri(new Uri(Url, true), newRef, true).ToString();
                    document = GetDocumentNoParse(ref newUrl, ClientProtocol);
                    Url = newUrl;
                }
                else
                    throw new InvalidContentTypeException(Res.GetString(Res.WebInvalidContentType, contentType), contentType);
            }

            if (document == null) { // probably xml...
                XmlTextReader reader = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
                reader.XmlResolver = null;
                reader.WhitespaceHandling = WhitespaceHandling.Significant;
                if (DiscoveryDocument.CanRead(reader)) {
                    // it's a discovery document, so just read it.
                    document = DiscoveryDocument.Read(reader);
                }
                else {
                    // check out the processing instructions before the first tag.  if any of them
                    // match the form specified in the DISCO spec, save the href.
                    stream.Position = 0;
                    XmlTextReader newReader = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
                    newReader.XmlResolver = null;
                    while (newReader.NodeType != XmlNodeType.Element) {
                        if (newReader.NodeType == XmlNodeType.ProcessingInstruction) {
                            // manually parse the PI contents since XmlTextReader won't automatically do it
                            StringBuilder sb = new StringBuilder("<pi ");
                            sb.Append(newReader.Value);
                            sb.Append("/>");
                            XmlTextReader piReader = new XmlTextReader(new StringReader(sb.ToString()));
                            piReader.XmlResolver = null;
                            piReader.Read();
                            string type = piReader["type"];
                            string alternate = piReader["alternate"];
                            string href = piReader["href"];
                            if (type != null && ContentType.MatchesBase(type, ContentType.TextXml)
                                && alternate != null && string.Compare(alternate, "yes", true, CultureInfo.InvariantCulture) == 0
                                && href != null) {
                                // we got a PI with the right attributes

                                // there is a link to a discovery document. follow it after fully qualifying it.
                                string newUrl = new Uri(new Uri(Url, true), href, true).ToString();
                                document = GetDocumentNoParse(ref newUrl, ClientProtocol);
                                Url = newUrl;
                                break;
                            }
                        }
                        newReader.Read();
                    }
                }
            }

            if (document == null) {
                // there is no discovery document at this location
                Exception exception;
                if (ContentType.IsXml(contentType)) {
                    exception = new ArgumentException(Res.GetString(Res.WebInvalidFormat));
                }
                else {
                    exception = new InvalidContentTypeException(Res.GetString(Res.WebInvalidContentType, contentType), contentType);
                }
                throw new InvalidOperationException(Res.GetString(Res.WebMissingDocument, Url), exception);
            }

            ClientProtocol.References[Url] = this;
            ClientProtocol.Documents[Url] = document;

            foreach (object o in document.References) {
                if (o is DiscoveryReference) {
                    DiscoveryReference r = (DiscoveryReference) o;
                    if (r.Url.Length == 0) {
                        throw new InvalidOperationException(Res.GetString(Res.WebEmptyRef, r.GetType().FullName, Url));
                    }
                    r.Url = new Uri(new Uri(Url, true), r.Url, true).ToString();
                    //All inheritors of DiscoveryReference that got URIs relative
                    //to Ref property should adjust them like ContractReference does here.
                    ContractReference cr = r as ContractReference;
                    if( (cr != null) && (cr.DocRef != null) ) {
                        cr.DocRef = new Uri(new Uri(Url, true), cr.DocRef, true).ToString();
                    }
                    r.ClientProtocol = ClientProtocol;
                    ClientProtocol.References[r.Url] = r;
                }
                else
                    ClientProtocol.AdditionalInformation.Add(o);
            }

            return;
        }

        /// <include file='doc\DiscoveryDocumentReference.uex' path='docs/doc[@for="DiscoveryDocumentReference.ResolveAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResolveAll() {
            ResolveAll(true);
        }

        internal void ResolveAll(bool throwOnError) {
            try {
                Resolve();
            }
            catch {
                if (throwOnError)
                    throw;

                // can't continue, because we couldn't find a document.
                return;
            }

            foreach (object o in Document.References) {
                DiscoveryDocumentReference r = o as DiscoveryDocumentReference;
                if (r == null)
                    continue;
                if (ClientProtocol.Documents[r.Url] != null) {
                    continue;
                }
                r.ClientProtocol = ClientProtocol;
                r.ResolveAll(throwOnError);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoveryreference.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryReference.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;
    using System.Xml.Serialization;
    using System.Text.RegularExpressions;
    using System.IO;
    using System.Text;

    /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class DiscoveryReference {

        private DiscoveryClientProtocol clientProtocol;

        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.ClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public DiscoveryClientProtocol ClientProtocol {
            get { return clientProtocol; }
            set { clientProtocol = value; }
        }

        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.DefaultFilename"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public virtual string DefaultFilename {
            get {
                return FilenameFromUrl(Url);
            }
        }

        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.WriteDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void WriteDocument(object document, Stream stream);
        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.ReadDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract object ReadDocument(Stream stream);

        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public abstract string Url {
            get;
            set;
        }

        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.FilenameFromUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static string FilenameFromUrl(string url) {
            // get everything after the last /, not including the one at the end of the string
            int lastSlash = url.LastIndexOf('/', url.Length - 1);
            if (lastSlash >= 0) url = url.Substring(lastSlash + 1);

            // get everything up to the first dot (the filename)
            int firstDot = url.IndexOf('.');
            if (firstDot >= 0) url = url.Substring(0, firstDot);

            // make sure we don't include the question mark and stuff that follows it
            int question = url.IndexOf('?');
            if (question >= 0) url = url.Substring(0, question);

            // keep all readable characters in the filename
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < url.Length; i++) {
                char ch = url[i];
                if (char.IsLetterOrDigit(ch) || ch == '_')
                    sb.Append(ch);
            }
            url = sb.ToString();

            // if nothing left, use a constant
            if (url.Length == 0) url = "item";

            return url;
        }

        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.Resolve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Resolve() {
            if (ClientProtocol == null)
                throw new InvalidOperationException(Res.GetString(Res.WebResolveMissingClientProtocol));

            if (ClientProtocol.Documents[Url] != null)
                return;

            string newUrl = Url;
            string oldUrl = Url;
            string contentType = null;
            Stream stream = ClientProtocol.Download(ref newUrl, ref contentType);
            if (ClientProtocol.Documents[newUrl] != null) {
                Url = newUrl;
                return;
            }
            try {
                Url = newUrl;
                Resolve(contentType, stream);
            }
            catch {
                Url = oldUrl;
                throw;
            }
            finally {
                stream.Close();
            }
        }

        internal Exception AttemptResolve(string contentType, Stream stream) {
            try {
                Resolve(contentType, stream);
                return null;
            }
            catch (Exception e) {
                return e;
            }
        }

        /// <include file='doc\DiscoveryReference.uex' path='docs/doc[@for="DiscoveryReference.Resolve1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal abstract void Resolve(string contentType, Stream stream);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoveryreferences.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryReferences.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\DiscoveryReferences.uex' path='docs/doc[@for="DiscoveryReferenceCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryReferenceCollection : CollectionBase {

        /// <include file='doc\DiscoveryReferences.uex' path='docs/doc[@for="DiscoveryReferenceCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DiscoveryReference this[int i] {
            get {
                return (DiscoveryReference) List[i];
            }
            set {
                List[i] = value;
            }
        }

        /// <include file='doc\DiscoveryReferences.uex' path='docs/doc[@for="DiscoveryReferenceCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(DiscoveryReference value) {
            return List.Add(value);
        }

        /// <include file='doc\DiscoveryReferences.uex' path='docs/doc[@for="DiscoveryReferenceCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(DiscoveryReference value) {
            return List.Contains(value);
        }

        /// <include file='doc\DiscoveryReferences.uex' path='docs/doc[@for="DiscoveryReferenceCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(DiscoveryReference value) {
            List.Remove(value);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\dynamicdiscoverydocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="DynamicDiscoveryDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.IO;
    using System.Collections;
    using System.Xml.Serialization;
    using System.Text;
    
    /// <include file='doc\DynamicDiscoveryDocument.uex' path='docs/doc[@for="DynamicDiscoveryDocument"]/*' />
    /// <devdoc>
    ///    This represents a discovery file.
    /// </devdoc>
    [XmlRoot("dynamicDiscovery", Namespace=DynamicDiscoveryDocument.Namespace)]
    public sealed class DynamicDiscoveryDocument {
        private ExcludePathInfo[] excludePaths = new ExcludePathInfo[0];

        /// <include file='doc\DynamicDiscoveryDocument.uex' path='docs/doc[@for="DynamicDiscoveryDocument.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string Namespace = "urn:schemas-dynamicdiscovery:disco.2000-03-17";

        /// <include file='doc\DynamicDiscoveryDocument.uex' path='docs/doc[@for="DynamicDiscoveryDocument.DynamicDiscoveryDocument"]/*' />
        /// <devdoc>
        ///     Default constructor.
        /// </devdoc>
        public DynamicDiscoveryDocument() {
        }

        /// <include file='doc\DynamicDiscoveryDocument.uex' path='docs/doc[@for="DynamicDiscoveryDocument.ExcludePaths"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("exclude", typeof(ExcludePathInfo))]
        public ExcludePathInfo[] ExcludePaths {
            get {
                return excludePaths;
            }
            set {
                if (value == null)
                    value = new ExcludePathInfo[0];
                excludePaths = value;
            }
        }

        /// <include file='doc\DynamicDiscoveryDocument.uex' path='docs/doc[@for="DynamicDiscoveryDocument.Write"]/*' />
        /// <devdoc>
        ///    Write this instance to a stream.
        /// </devdoc>
        public void Write(Stream stream) {
            XmlSerializer xmlSerializer = new XmlSerializer(typeof(DynamicDiscoveryDocument));
            xmlSerializer.Serialize(new StreamWriter(stream, new UTF8Encoding(false)), this);
        }

        /// <include file='doc\DynamicDiscoveryDocument.uex' path='docs/doc[@for="DynamicDiscoveryDocument.Load"]/*' />
        /// <devdoc>
        ///    Read an instance of WebMethodsFile from a stream.
        /// </devdoc>
        public static DynamicDiscoveryDocument Load(Stream stream) {
            XmlSerializer xmlSerializer = new XmlSerializer(typeof(DynamicDiscoveryDocument));
            return (DynamicDiscoveryDocument) xmlSerializer.Deserialize(stream);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\dynamicdiscosearcher.cs ===
//------------------------------------------------------------------------------
// <copyright file="DynamicDiscoSearcher.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.IO;
    using System.Collections;
    using System.Web;
    using System.Web.Caching;
    using System.Diagnostics;
    using System.Text;
    using System.DirectoryServices;
    using System.Web.Services.Configuration;
    using System.ComponentModel;
    using System.Globalization;
    

    /// <include file='doc\DynamicDiscoSearcher.uex' path='docs/doc[@for="DynamicDiscoSearcher"]/*' />
    /// <devdoc>
    /// Does a recursive search of subdirectories (physical and virtual) to find stuff to
    /// make a disco file from. *.disco files (or whatever the PrimarySearchPattern is) are
    /// treated as end-points - recursion stops where they are found.
    /// It's a base class for DynamicVirtualDiscoSearcher and DynamicPhysicalDiscoSearcher.
    /// </devdoc>
    internal abstract class DynamicDiscoSearcher {

        protected   string                      origUrl;            // original URL to start search
        protected   string[]                    excludedUrls;           // names relative to starting path
        protected   string                      fileToSkipFirst;        // name of file to skip on 1st level
        protected   ArrayList                   filesFound;
        protected   DiscoverySearchPattern[]    primarySearchPatterns = null;
        protected   DiscoverySearchPattern[]    secondarySearchPatterns = null;
        protected   DiscoveryDocument           discoDoc = new DiscoveryDocument();
        protected   Hashtable                   excludedUrlsTable = null;
        protected   int                         subDirLevel = 0;        // current nested level of subdirectory relative to search root

        // -------------------------------------------------------------------------------
        internal DynamicDiscoSearcher(string[] excludeUrlsList) {
            excludedUrls = excludeUrlsList;
            filesFound = new ArrayList();
        }

        // -------------------------------------------------------------------------------
        internal virtual  void SearchInit(string fileToSkipAtBegin)  {
            subDirLevel = 0;
            fileToSkipFirst = fileToSkipAtBegin;
        }

        // -------------------------------------------------------------------------------
        protected bool IsExcluded(string url) {
            if (excludedUrlsTable == null) {
                excludedUrlsTable = new Hashtable();
                foreach (string s in excludedUrls) {
                     Debug.Assert( s != null, "null element in excluded list" );
                     excludedUrlsTable.Add( MakeAbsExcludedPath(s).ToLower(CultureInfo.InvariantCulture), null);
                }
            }

            return excludedUrlsTable.Contains( url.ToLower(CultureInfo.InvariantCulture) );
        }

        // -------------------------------------------------------------------------------
        internal DiscoveryDocument DiscoveryDocument {
            get {
                return discoDoc;
            }
        }

        // -------------------------------------------------------------------------------
        internal DiscoverySearchPattern[] PrimarySearchPattern {
            get {
                if (primarySearchPatterns == null) {
                    // For the primary search the pattern is ".vsdisco"
                    primarySearchPatterns = new DiscoverySearchPattern[] { new DiscoveryDocumentSearchPattern() } ;
                }
                return primarySearchPatterns;
            }
        }

        // -------------------------------------------------------------------------------
        internal DiscoverySearchPattern[] SecondarySearchPattern {
            get {
                if (secondarySearchPatterns == null) {

                //  ******  Get pattern type from Config (no more needed)  *******
                //  Type[] searchPattern = WebServicesConfiguration.Current.DiscoverySearchPatternTypes;
                //  secondarySearchPatterns = new DiscoverySearchPattern[searchPattern.Length];
                //
                //  for (int i = 0; i < searchPattern.Length; i++) {
                //      secondarySearchPatterns[i] = (DiscoverySearchPattern) Activator.CreateInstance(searchPattern[i]);
                //  }

                secondarySearchPatterns = new DiscoverySearchPattern[] { new ContractSearchPattern(),
                                                                         new DiscoveryDocumentLinksPattern() };
                }

                return secondarySearchPatterns;
            }
        }

        // -------------------------------------------------------------------------------
        internal string[] PathsFound {
            get {
                string[] res = new string[filesFound.Count];
                for (int i=0; i < filesFound.Count ; i++ ) {
                    res[i] = (string) filesFound[i];
                }
                return res;
            }
        }

        // -------------------------------------------------------------------------------
        // Invokes searching by patterns in current dir. If needed, initiates further search in subdirectories.
        protected void ScanDirectory(string directory) {
            if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose ) Debug.WriteLine( "DynamicDiscoSearcher.ScanDirectory(): directory=" + directory);
            if ( IsExcluded(directory) )                // what name is meant here?
                return;

            bool primaryFound = ScanDirByPattern(directory, true /*primary*/, PrimarySearchPattern);

            if (!primaryFound)   {
                if (!IsVirtualSearch ) {
                    ScanDirByPattern(directory, false /*secondary*/, SecondarySearchPattern);
                }else {
                    // We restrict second stage of a virtual discovery only to static .disco documents
                    // We assume that starting directory does not need a second stage
                    if (subDirLevel != 0) {
                        DiscoverySearchPattern[] staticDiscoPattern = new DiscoverySearchPattern[] { new DiscoveryDocumentLinksPattern() };
                        ScanDirByPattern(directory, false /*secondary*/, staticDiscoPattern);
                    }
                }

                if ( IsVirtualSearch && subDirLevel > 0 )
                    return;                         // stop search in subdir levels deeper than 1 for virtual search

                subDirLevel++;
                fileToSkipFirst = "";               // do not skip this file on lower levels
                SearchSubDirectories(directory);    // search deeper (indirect recursion)
                subDirLevel--;
            }
        }

        // -------------------------------------------------------------------------------
        // Looks in a physical directory for a file matching whatever the configured pattern is.
        // Returns: 'true' if primary file has been found (and added to Discovery References).
        protected bool ScanDirByPattern(string dir, bool IsPrimary, DiscoverySearchPattern[] patterns) {

            DirectoryInfo directory = GetPhysicalDir(dir);              // comment here
            if ( directory == null )
                return false;
            if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose )
                Debug.WriteLine( "= DynamicDiscoSearcher.ScanDirByPattern(): dir=" + dir + "  Phys.dir=" + directory.Name);

            bool    isFileFound = false;
            for (int i = 0; i < patterns.Length; i++) {
                FileInfo[] files = directory.GetFiles(patterns[i].Pattern);             // search in dir

                foreach (FileInfo file in files) {

                    if ((file.Attributes & FileAttributes.Directory) == 0) {

                        if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose )  Debug.WriteLine( "=== DynamicDiscoSearcher.ScanDirByPattern(): file.Name=" + file.Name + "  fileToSkipFirst=" + fileToSkipFirst);

                        // first skip given (i.e. starting) file
                        if ( String.Compare(file.Name, fileToSkipFirst, true, CultureInfo.InvariantCulture) == 0  ) {       // ignore case compare
                            continue;
                            }

                        string resultName = MakeResultPath(dir, file.Name);
                        filesFound.Add( resultName );
                        discoDoc.References.Add(patterns[i].GetDiscoveryReference(resultName));
                        isFileFound = true;
                    }
                }

            }

        return (IsPrimary && isFileFound);
        }

        // ------------  abstract methods  -----------------

        /// <include file='doc\DynamicDiscoSearcher.uex' path='docs/doc[@for="DynamicDiscoSearcher.Search"]/*' />
        /// <devdoc>
        /// Main function. Searches dir recursively for primary (.vsdisco) and seconary (.asmx) files.
        /// </devdoc>
        internal abstract void Search(string fileToSkipAtBegin);

        // Gets phisycal directory info from its virtual or actual name.
        protected abstract DirectoryInfo GetPhysicalDir(string dir );

        //  Search given directory for subdirectories, feasable for further searching.
        protected abstract void SearchSubDirectories(string directory);

        // Makes result URL found file path from diectory name and short file name.
        protected abstract string MakeResultPath(string dirName, string fileName);

        // Makes exclusion path absolute for quick comparision on search.
        protected abstract string MakeAbsExcludedPath(string pathRelativ);

        // 'true' if search isVirtual
        protected abstract bool IsVirtualSearch { get; }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\excludepathinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExcludePathInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.Xml.Serialization;
    
    /// <include file='doc\ExcludePathInfo.uex' path='docs/doc[@for="ExcludePathInfo"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class ExcludePathInfo {
        private string path = null;

        /// <include file='doc\ExcludePathInfo.uex' path='docs/doc[@for="ExcludePathInfo.ExcludePathInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ExcludePathInfo() {
        }

        /// <include file='doc\ExcludePathInfo.uex' path='docs/doc[@for="ExcludePathInfo.ExcludePathInfo1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ExcludePathInfo(string path) {
            this.path = path;
        }

        /// <include file='doc\ExcludePathInfo.uex' path='docs/doc[@for="ExcludePathInfo.Path"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("path")]
        public string Path {
            get {
                return path;
            }
            set {
                path = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoverysearchpattern.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoverySearchPattern.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.Security.Permissions;

    /// <include file='doc\DiscoverySearchPattern.uex' path='docs/doc[@for="DiscoverySearchPattern"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class DiscoverySearchPattern {
        /// <include file='doc\DiscoverySearchPattern.uex' path='docs/doc[@for="DiscoverySearchPattern.Pattern"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract string Pattern {
            get;
        }

        /// <include file='doc\DiscoverySearchPattern.uex' path='docs/doc[@for="DiscoverySearchPattern.GetDiscoveryReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract DiscoveryReference GetDiscoveryReference(string filename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\dynamicvirtualdiscosearcher.cs ===
//------------------------------------------------------------------------------
// <copyright file="DynamicVirtualDiscoSearcher.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.IO;
    using System.Collections;
    using System.Web;
    using System.Web.Caching;
    using System.Diagnostics;
    using System.Text;
    using System.DirectoryServices;
    using System.Web.Services.Configuration;
    using System.ComponentModel;
    using System.Globalization;
    

    /// <include file='doc\DynamicVirtualDiscoSearcher.uex' path='docs/doc[@for="DynamicVirtualDiscoSearcher"]/*' />
    /// <devdoc>
    /// Does a recursive search of virtual subdirectories to find stuff to
    /// make a disco file from. *.disco files (or whatever the PrimarySearchPattern is) are
    /// treated as end-points - recursion stops where they are found.
    /// </devdoc>
    internal class DynamicVirtualDiscoSearcher : DynamicDiscoSearcher {

        private string  rootPathAsdi;            // ADSI search root path with prefix
        private string  entryPathPrefix;

        private string  startDir;

// If we could get an event back from IIS Admin Object that some directory is addred/removed/renamed
// then the following memeber should become static, so we get 5-10 _times_ performace gain on
// processing .vsdisco in the Web Root
// !!SEE ALSO!! CleanupCache method
        private /*static*/  Hashtable webApps  = new Hashtable();
        private         Hashtable Adsi     = new Hashtable();


        // -------------------------------------------------------------------------------
        internal DynamicVirtualDiscoSearcher(string startDir, string[] excludedUrls, string rootUrl) :
                base(excludedUrls)
        {
            origUrl = rootUrl;
            entryPathPrefix = GetWebServerForUrl( rootUrl ) + "/ROOT";

            this.startDir = startDir;

            string localPath =  (new System.Uri(rootUrl)).LocalPath;
            if ( localPath.Equals("/") ) localPath = "";     // empty local path should be ""
            rootPathAsdi = entryPathPrefix + localPath;
        }

        // -------------------------------------------------------------------------------
        /// <include file='doc\DynamicVirtualDiscoSearcher.uex' path='docs/doc[@for="DynamicVirtualDiscoSearcher.Search"]/*' />
        /// <devdoc>
        /// Main function. Searches dir recursively for primary (.vsdisco) and seconary (.asmx) files.
        /// </devdoc>
        internal override void Search(string fileToSkipAtBegin) {
            SearchInit(fileToSkipAtBegin);
            ScanDirectory( rootPathAsdi );
            CleanupCache();
        }

        // -------------------------------------------------------------------------------
        // Look in virtual subdirectories.
        protected override void SearchSubDirectories(string nameAdsiDir) {

            if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose )  Debug.WriteLine( "DynamicVirtualDiscoSearcher.SearchSubDirectories(): nameAdsiDir=" + nameAdsiDir);

            DirectoryEntry vdir = (DirectoryEntry)Adsi[nameAdsiDir];    //may be already bound
            if (vdir == null) {
                if ( !DirectoryEntry.Exists(nameAdsiDir) )
                    return;
                vdir = new DirectoryEntry(nameAdsiDir);
                Adsi[nameAdsiDir] = vdir;
            }

            foreach (DirectoryEntry obj in vdir.Children) {
                DirectoryEntry child = (DirectoryEntry)Adsi[obj.Path];
                if (child == null) {
                    child = obj;
                    Adsi[obj.Path] = obj;
                }else {
                    obj.Dispose();
                }
                AppSettings settings = GetAppSettings(child);
                if (settings != null) {
                    ScanDirectory(child.Path);                      //go down ADSI path
                }
            }

        }

        // -------------------------------------------------------------------------------
        protected override DirectoryInfo GetPhysicalDir(string dir ) {
            DirectoryEntry vdir = (DirectoryEntry)Adsi[dir];
            if (vdir == null) {
                if (!DirectoryEntry.Exists(dir) ) {
                    return null;
                }
                vdir = new DirectoryEntry(dir);
                Adsi[dir] = vdir;
            }
            try {
                DirectoryInfo directory = null;
                AppSettings settings = GetAppSettings(vdir);
                if (settings == null) {
                    return null;
                }
                if (settings.VPath == null) {                   //SchemaClassName == "IIsWebDirectory"
                    //NOTE This assumes there was a known physical directory
                    //corresponding to a parent WebDirectory.
                    //And incoming 'dir' is a child of that parent.
                    if( !dir.StartsWith(rootPathAsdi) ) {
                        throw new ArgumentException(Res.GetString(Res.WebVirtualDisoRoot,dir,rootPathAsdi),"dir");
                    }
                    string    physicalDir = dir.Substring(rootPathAsdi.Length);
                    physicalDir = physicalDir.Replace('/','\\'); //it always begins with '/' or is empty
                    directory = new DirectoryInfo(startDir + physicalDir);

                }
                else {
                    directory = new DirectoryInfo(settings.VPath);//SchemaClassName == "IIsWebVirtualDir
                }

                if ( directory.Exists )
                    return directory;
            }
            catch (Exception e) {
                if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose ) Debug.WriteLine( "+++ DynamicVirtualDiscoSearcher.GetPhysicalDir(): dir=" + dir + " Exception=" + e.ToString() );
                return null;
            }
            return null;
        }


        // -------------------------------------------------------------------------------
        // Calculate root ADSI virtual directory name (func by 'stefanph').
        private string GetWebServerForUrl(string url) {
            Uri uri = new Uri(url);
            DirectoryEntry w3Service = new DirectoryEntry("IIS://" + uri.Host + "/W3SVC");

            foreach (DirectoryEntry obj in w3Service.Children) {
                DirectoryEntry site = (DirectoryEntry)Adsi[obj.Path];           //may be already bound
                if (site == null) {
                    site = obj;
                    Adsi[obj.Path] = obj;
                }
                else {
                    obj.Dispose();
                }
                AppSettings settings = GetAppSettings(site);

                if (settings == null || settings.Bindings == null) {            //SchemaClassName != "IIsWebServer"
                    continue;
                }

                foreach (string bindingsEntry in settings.Bindings) {
                    if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose ) Debug.WriteLine("GetWebServerForUrl() bindingsEntry=" + bindingsEntry);
                    string[] bindings = bindingsEntry.Split(':');
                    string ip = bindings[0];
                    string port = bindings[1];
                    string hostname = bindings[2];

                    if (Convert.ToInt32(port) != uri.Port)
                        continue;

                    if (uri.HostNameType == UriHostNameType.Dns) {
                        if (hostname.Length == 0 || string.Compare(hostname, uri.Host, true, CultureInfo.InvariantCulture) == 0)
                            return site.Path;
                        }
                    else {
                        if (ip.Length == 0 || string.Compare(ip, uri.Host, true, CultureInfo.InvariantCulture) == 0)
                            return site.Path;
                    }
                }
            }
            return null;
        }

        // -------------------------------------------------------------------------------
        // Makes result URL found file path from diectory name and short file name.
        protected override string MakeResultPath(string dirName, string fileName) {
            string res = origUrl
                   + dirName.Substring(rootPathAsdi.Length, dirName.Length - rootPathAsdi.Length)
                   + '/' +  fileName;
            return res;
        }

        // -------------------------------------------------------------------------------
        // Makes exclusion path absolute for quick comparision on search.
        protected override string MakeAbsExcludedPath(string pathRelativ) {
            return rootPathAsdi + '/' + pathRelativ.Replace('\\', '/');
        }

        // -------------------------------------------------------------------------------
        protected override bool IsVirtualSearch  {
            get { return true; }
        }

        private AppSettings GetAppSettings(DirectoryEntry entry) {
            string      key = entry.Path;                   //this is fast since does not cause bind()
            AppSettings result = null;

            object obj = webApps[key];

            if (obj == null) {
                // We provie a write lock while Hashtable supports multiple readers under single writer
                lock (webApps) {
                    obj = webApps[key];
                    if (obj == null) {                          //make sure other thread not taken care of
                        result = new AppSettings(entry);        //that consumes a 50-2000 ms
                        webApps[key] = result;
                    }
                }
            }
            else {
                result = (AppSettings)obj;
            }
            return result.AccessRead? result: null;         //ignore denied object on upper level
        }

        private void CleanupCache() {
            //Destroy system resources excplicitly since the destructor is called sometime late
            foreach (DictionaryEntry obj in Adsi) {
                ((DirectoryEntry)(obj.Value)).Dispose();
            }
            rootPathAsdi = null;
            entryPathPrefix = null;
            startDir = null;

            Adsi     = null;
//REMOVE NEXT LINE IF the member webApps has turned into static (see webApps declaration line)
            webApps = null;
        }

        private class AppSettings {
            internal  readonly bool   AccessRead = false; // if false the caller will ignore the object
            internal  readonly string[] Bindings = null;  // the field is only for WebServers
            internal  readonly string VPath      = null;  // the filed is only for VirtualDirs

            internal AppSettings(DirectoryEntry entry) {

                string schema = entry.SchemaClassName;
                AccessRead = true;

                if (schema == "IIsWebVirtualDir" || schema == "IIsWebDirectory"){
                    if (!(bool)(entry.Properties["AccessRead"][0])) {
                        AccessRead = false;
                        return;
                    }
                    if (schema == "IIsWebVirtualDir") {
                        VPath = (string) (entry.Properties["Path"][0]);
                    }
                }
                else if (schema == "IIsWebServer") {
                    Bindings =  new string[entry.Properties["ServerBindings"].Count];
                    for (int i = 0; i < Bindings.Length; ++i) {
                        Bindings[i] = (string) (entry.Properties["ServerBindings"][i]);
                    }
                }
                else {
                    //schema is not recognized add to the cache but never look at the object
                    AccessRead = false;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\invalidcontenttypeexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryDocumentReference.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;

    internal class InvalidContentTypeException : Exception {

        private string contentType;

        internal InvalidContentTypeException(string message, string contentType) : base(message) {
            this.contentType = contentType;
        }

        internal string ContentType {
            get {
                return contentType;
            }
            set {
                contentType = value;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\discoveryrequesthandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryRequestHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.IO;
    using System.Collections;
    using System.Web;
    using System.Web.Caching;
    using System.Xml;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Text;
    using System.Web.Services.Protocols;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\DiscoveryRequestHandler.uex' path='docs/doc[@for="DiscoveryRequestHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class DiscoveryRequestHandler : IHttpHandler {

        /// <include file='doc\DiscoveryRequestHandler.uex' path='docs/doc[@for="DiscoveryRequestHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReusable {
            get { return true; }
        }

        /// <include file='doc\DiscoveryRequestHandler.uex' path='docs/doc[@for="DiscoveryRequestHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ProcessRequest(HttpContext context) {
            new PermissionSet(PermissionState.Unrestricted).Demand();
            // string cacheKey;

            string physicalPath = context.Request.PhysicalPath;
            if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose ) Debug.WriteLine("DiscoveryRequestHandle: handling " + physicalPath);

            // Check to see if file exists locally.
            if (File.Exists(physicalPath)) {
                DynamicDiscoveryDocument dynDisco = null;
                FileStream stream = null;
                try {
                    stream = new FileStream(physicalPath, FileMode.Open, FileAccess.Read);
                    XmlTextReader xmlReader = new XmlTextReader(stream);
                    xmlReader.WhitespaceHandling = WhitespaceHandling.Significant;
                    xmlReader.XmlResolver = null;
                    if (xmlReader.IsStartElement("dynamicDiscovery", DynamicDiscoveryDocument.Namespace)) {
                        stream.Position = 0;
                        dynDisco = DynamicDiscoveryDocument.Load(stream);
                    }
                }
                finally {
                    if (stream != null) {
                        stream.Close();
                    }
                }

                if (dynDisco != null) {
                    string[] excludeList = new string[dynDisco.ExcludePaths.Length];
                    string discoFileDirectory = Path.GetDirectoryName(physicalPath);
                    string discoFileName = Path.GetFileName(physicalPath);

                    for (int i = 0; i < excludeList.Length; i++) {
                         // Exclude list now consists of relative paths, so this transformation not needed.
                         // excludeList[i] = Path.Combine(discoFileDirectory, dynDisco.ExcludePaths[i].Path);
                         excludeList[i] = dynDisco.ExcludePaths[i].Path;
                         }

                    // Determine start url path for search
                    DynamicDiscoSearcher searcher;
                    Uri     searchStartUrl =  context.Request.Url;
                    string  searchStartUrlDir = GetDirPartOfPath( searchStartUrl.ToString() );  // URL path without file name
                    string  strLocalPath = GetDirPartOfPath(searchStartUrl.LocalPath);

                    if (  strLocalPath.Length == 0 ||       // no subdir present, host only
                          CompModSwitches.DynamicDiscoveryVirtualSearch.Enabled    // virtual search forced (for test suites).
                        ) {
                        discoFileName = GetFilePartOfPath( searchStartUrl.ToString() );
                        searcher = new DynamicVirtualDiscoSearcher( discoFileDirectory, excludeList, searchStartUrlDir);
                        }
                    else
                        searcher = new DynamicPhysicalDiscoSearcher(discoFileDirectory, excludeList, searchStartUrlDir);

                    if ( CompModSwitches.DynamicDiscoverySearcher.TraceVerbose ) Debug.WriteLine( "*** DiscoveryRequestHandler.ProcessRequest() - startDir: " + searchStartUrlDir + " discoFileName :" + discoFileName);
                    searcher.Search(discoFileName);

                    DiscoveryDocument discoFile = searcher.DiscoveryDocument;

                    MemoryStream memStream = new MemoryStream(1024);
                    StreamWriter writer = new StreamWriter(memStream, new UTF8Encoding(false));
                    discoFile.Write(writer);
                    memStream.Position = 0;
                    byte[] data = new byte[(int)memStream.Length];
                    int bytesRead = memStream.Read(data, 0, data.Length);
                    context.Response.ContentType = ContentType.Compose("text/xml", Encoding.UTF8);
                    context.Response.OutputStream.Write(data, 0, bytesRead);
                }
                else {
                    // Else, just return the disco file
                    context.Response.ContentType = "text/xml";
                    context.Response.WriteFile(physicalPath);
                }
                return;
            }


            // Else, file is not found
            throw new HttpException(404, Res.GetString(Res.WebPathNotFound, context.Request.Path));
        }

        // -------------------------------------------------------------------------
        // Returns part of URL string to the left of the last slash.
        private static string GetDirPartOfPath(string str) {
            int lastSlash = str.LastIndexOf('/');
            return (lastSlash > 0) ? str.Substring(0, lastSlash) : "";
        }

        // -------------------------------------------------------------------------
        // Returns part of URL string to the right of the last slash.
        private static string GetFilePartOfPath(string str) {
            int lastSlash = str.LastIndexOf('/');
            if ( lastSlash < 0 )
                return str;
            else if ( lastSlash == str.Length-1 )
                return "";
            return str.Substring(lastSlash+1);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\dynamicphysicaldiscosearcher.cs ===
//------------------------------------------------------------------------------
// <copyright file="DynamicPhysicalDiscoSearcher.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.IO;
    using System.Collections;
    using System.Web;
    using System.Web.Caching;
    using System.Diagnostics;
    using System.Text;
    using System.DirectoryServices;
    using System.Web.Services.Configuration;
    using System.ComponentModel;

    
    /// <include file='doc\DynamicPhysicalDiscoSearcher.uex' path='docs/doc[@for="DynamicPhysicalDiscoSearcher"]/*' />
    /// <devdoc>
    /// Does a recursive search of virtual subdirectories to find stuff to
    /// make a disco file from. *.disco files (or whatever the PrimarySearchPattern is) are
    /// treated as end-points - recursion stops where they are found.
    /// </devdoc>
    internal class DynamicPhysicalDiscoSearcher : DynamicDiscoSearcher {
    
        private string  startDir;
    
        internal DynamicPhysicalDiscoSearcher(string searchDir, string[] excludedUrls, string startUrl) : 
               base(excludedUrls)
        {
        startDir =  searchDir;
        origUrl = startUrl;
        }
        
        // -------------------------------------------------------------------------------
        internal override void Search(string fileToSkipAtBegin) {
            SearchInit(fileToSkipAtBegin);
            ScanDirectory( startDir );
        }

        // -------------------------------------------------------------------------------
        //  Look in iven directory for subdirectories, feasable for further searching.
        protected override void SearchSubDirectories(string localDir) {
            DirectoryInfo dir = new DirectoryInfo(localDir);
            if (!dir.Exists)
                return;
            DirectoryInfo[] subDirs = dir.GetDirectories();
            
            foreach (DirectoryInfo subDir in subDirs) {
                if (subDir.Name == "." || subDir.Name == ".." ) {
                    continue;
                }
                ScanDirectory( localDir + '\\' + subDir.Name );
            }
        }

        // -------------------------------------------------------------------------------
        protected override DirectoryInfo GetPhysicalDir(string dir ) {
            
            if ( !Directory.Exists(dir) )
                return null;

            DirectoryInfo directory = new DirectoryInfo(dir);
            if ( !directory.Exists )
                return null;

            if( 0 != (directory.Attributes & (FileAttributes.Hidden | FileAttributes.System | FileAttributes.Temporary))) {
                return null;
            }
                                       
            return directory;    
            }    

        // -------------------------------------------------------------------------------
        // Makes result URL found file path from diectory name and short file name.
        protected override string MakeResultPath(string dirName, string fileName) {
            string res = origUrl 
                   + dirName.Substring(startDir.Length, dirName.Length - startDir.Length).Replace('\\','/') 
                   + '/' +  fileName;  
            return  res;
        }
    
        // -------------------------------------------------------------------------------
        // Makes exclusion path absolute for quick comparision on search.
        protected override string MakeAbsExcludedPath(string pathRelativ) {
            return startDir + '\\' + pathRelativ.Replace('/', '\\' );
        }
    
        // -------------------------------------------------------------------------------
        protected override bool IsVirtualSearch  {
            get { return false; }
        }
        
    }
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\invaliddocumentcontentsexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryClientProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;

    internal class InvalidDocumentContentsException : Exception {

        internal InvalidDocumentContentsException(string message) : base(message) {
        }

        internal InvalidDocumentContentsException(string message, Exception inner) : base(message, inner) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\linkgrep.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkGrep.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;
    using System.IO;
    using System.Text.RegularExpressions;
    using System.Web.Services.Protocols;
    using System.Globalization;
    
    internal class LinkGrep {
        private static string ReadEntireStream(TextReader input) {
            char[] buffer = new char[4096];
            int bufferpos = 0;
            int delta;
    
            // CONSIDER, stefanph: this might be more efficient with a StringBuilder.
            for (;;) {
                delta = input.Read(buffer, bufferpos, buffer.Length - bufferpos);
                
                if (delta == 0)
                    break;
    
                bufferpos += delta;
    
                if (bufferpos == buffer.Length) {
                    char[] newbuf = new char[buffer.Length * 2];
                    System.Array.Copy(buffer, 0, newbuf, 0, buffer.Length);
                    buffer = newbuf;
                }
            }
    
            return new string(buffer, 0, bufferpos);
        }

        internal static string SearchForLink(string filename) {
            FileStream stream = null;
            try {
                stream = new FileStream(filename, FileMode.Open);
                return SearchForLink(stream);
            }
            finally {
                if (stream != null) {
                    stream.Close();
                }
            }
        }

        internal static string SearchForLink(Stream stream) {
            string text = null;
            text = ReadEntireStream(new StreamReader(stream));

            int textpos = 0;

            Match match;

            if ((match = doctypeDirectiveRegex.Match(text, textpos)).Success) {
                textpos += match.Length;
            }

            bool oneMatch;
            for (;;) {
                
                // Reset match flag
                oneMatch = false;
                
                // 1: scan for text up to the next tag.
    
                // First case: check for whitespace going all the way to the next tag
                
                if ((match = whitespaceRegex.Match(text, textpos)).Success) {
                    oneMatch = true;
                }
                
                // Second case: there may be some nonwhitespace; scan it
                
                else if ((match = textRegex.Match(text, textpos)).Success) {
                    oneMatch = true;
                }
    
                // we might be done now
                
                textpos += match.Length;
                if (textpos == text.Length)
                    break;
               
                // 2: handle constructs that start with <
    
                // First, check to see if it's a tag
    
                if ((match = tagRegex.Match(text, textpos)).Success)
                {
                    oneMatch = true;
                    string tag = match.Groups["tagname"].Value;

                    if (String.Compare(tag, "link", true, CultureInfo.InvariantCulture) == 0) {
                        CaptureCollection attrnames = match.Groups["attrname"].Captures;
                        CaptureCollection attrvalues = match.Groups["attrval"].Captures;

                        int count = attrnames.Count;
                        bool rightType = false;
                        bool rightRel = false;
                        string href = null;
                        for (int i = 0; i < count; i++) {
                            string attrName = attrnames[i].ToString();
                            string attrValue = attrvalues[i].ToString();
                            if (String.Compare(attrName, "type", true, CultureInfo.InvariantCulture) == 0 &&
                                ContentType.MatchesBase(attrValue, ContentType.TextXml)) {
                                rightType = true;
                            }
                            else if (String.Compare(attrName, "rel", true, CultureInfo.InvariantCulture) == 0 &&
                                String.Compare(attrValue, "alternate", true, CultureInfo.InvariantCulture) == 0) {
                                rightRel = true;
                            }
                            else if (String.Compare(attrName, "href", true, CultureInfo.InvariantCulture) == 0) {
                                href = attrValue;
                            }

                            if (rightType && rightRel && href != null) {
                                // Got a link to a disco file!
                                return href;
                            }
                        }
                    }
                    else if (tag == "body") {
                        // If body begins, get out, since link tags should only be defined in the head
                        break;
                    }

                }
    
                // check to see if it's an end tag
                
                else if ((match = endtagRegex.Match(text, textpos)).Success) {
                    oneMatch = true;
                }
    
                // check to see if it's a comment
    
                else if ((match = commentRegex.Match(text, textpos)).Success) {
                    oneMatch = true;
                }
               
                // we might be done now
                
                textpos += match.Length;

                if (textpos == text.Length)
                    break;

                // If we couldn't get one single match, it means that it's probably not HTML, so bail
                if (!oneMatch) {
                    break;
                }
            }

            return null;
        }
        
        private readonly static Regex tagRegex = new Regex
        (
            "\\G<" +                                    // leading <
            "(?<prefix>[\\w:.-]+(?=:)|):?" +            // optional prefix:
            "(?<tagname>[\\w.-]+)" +                    // tagname
    
            "(?:\\s+" +                                 // zero or more attributes
                "(?<attrprefix>[\\w:.-]+(?=:)|):?" +    //     optional attrprefix:
                "(?<attrname>[\\w.-]+)" +               //     attrname
                "\\s*=\\s*" +                           //     required equals
                "(?:" +                                 //     quoted value
                    "\"(?<attrval>[^\"]*)\"" +          //          double quoted attrval
                    "|'(?<attrval>[^\']*)'" +           //          single quoted attrval
                    "|(?<attrval>[a-zA-Z0-9\\-._:]+)" + //          attrval with no quotes (SGML-approved chars)
                ")" +                                   //     end quoted value
            ")*" +                                      // end attribute
            
            "\\s*(?<empty>/)?>"                         // optional trailing /, and trailing >
        );
            
        private readonly static Regex doctypeDirectiveRegex = new Regex
        (
            @"\G<!doctype\b(([\s\w]+)|("".*""))*>"
        );

        private readonly static Regex endtagRegex = new Regex
        (
            "\\G</" +                                   // leading </
            "(?<prefix>[\\w:-]+(?=:)|):?" +             // optional prefix:
            "(?<tagname>[\\w-]+)\\s*>"                 // tagname
        );
        
        private readonly static Regex commentRegex = new Regex
        (
            "\\G<!--" +                                 // leading <!--
            "(?>[^-]*-)+?" +                            // one or more chunks of text ending with -, minimal
            "->"                                        // trailing ->
    
        );
        
        private readonly static Regex whitespaceRegex = new Regex
        (
            "\\G\\s+" +                                 // at least one char of whitespace
            "(?=<|\\Z)"                                 // ending with either '<' or the end of the string
        );
        
        private readonly static Regex textRegex = new Regex
        (
            "\\G[^<]+"                                  // at least one char on non-'<', maximal
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\xmlschemasearchpattern.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSearchPattern.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {
    using System;
    using System.Security.Permissions;

    /// <include file='doc\XmlSchemaSearchPattern.uex' path='docs/doc[@for="XmlSchemaSearchPattern"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class XmlSchemaSearchPattern : DiscoverySearchPattern {
        /// <include file='doc\XmlSchemaSearchPattern.uex' path='docs/doc[@for="XmlSchemaSearchPattern.Pattern"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Pattern {
            get {
                return "*.xsd";
            }
        }

        /// <include file='doc\XmlSchemaSearchPattern.uex' path='docs/doc[@for="XmlSchemaSearchPattern.GetDiscoveryReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override DiscoveryReference GetDiscoveryReference(string filename) {
            return new SchemaReference(filename);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\interop\callid.cs ===
//------------------------------------------------------------------------------
// <copyright file="CallId.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CallId.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Interop {
    using System;
    using System.Threading;
    using System.Runtime.InteropServices;
    
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct CallId {        
        public string szMachine; 
        public int dwPid;        
        public IntPtr userThread;        
        public long addStackPointer;        
        public string szEntryPoint;
        public string szDestinationMachine;

        public CallId(string machine, int pid, IntPtr userThread, long stackPtr, string entryPoint, string destMachine) {
            this.szMachine = machine;
            this.dwPid = pid;
            this.userThread = userThread;
            this.addStackPointer = stackPtr;
            this.szEntryPoint = entryPoint;
            this.szDestinationMachine = destMachine;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\soapbinding.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapBinding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Diagnostics;

    /// <include file='doc\SoapBinding.uex' path='docs/doc[@for="SoapBinding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlRoot("soap", Namespace=SoapBinding.Namespace)]
    public sealed class SoapBinding {

        /// <include file='doc\SoapBinding.uex' path='docs/doc[@for="SoapBinding.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string Namespace = "http://schemas.xmlsoap.org/disco/soap/";

        private XmlQualifiedName binding;
        private string address = "";

        /// <include file='doc\SoapBinding.uex' path='docs/doc[@for="SoapBinding.Address"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("address")]
        public string Address {
            get { return address; }
            set {
                if (value == null)
                    address = "";
                else
                    address = value;
            }
        }

        /// <include file='doc\SoapBinding.uex' path='docs/doc[@for="SoapBinding.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("binding")]
        public XmlQualifiedName Binding {
            get { return binding; }
            set { binding = value; }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\interop\inotifyconnection2.cs ===
//------------------------------------------------------------------------------
// <copyright file="INotifyConnection2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   INotifyConnection2.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Interop {
    using System;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Security;
    
    [ComImport(), Guid("1AF04045-6659-4aaa-9F4B-2741AC56224B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [SuppressUnmanagedCodeSecurity]
    internal interface INotifyConnection2 {
        [return: MarshalAs(UnmanagedType.Interface)]
        INotifySink2 RegisterNotifySource(
            [In, MarshalAs(UnmanagedType.Interface)] INotifySource2 in_pNotifySource);

        
        void UnregisterNotifySource(
            [In, MarshalAs(UnmanagedType.Interface)] INotifySource2 in_pNotifySource);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\interop\inotifysink2.cs ===
//------------------------------------------------------------------------------
// <copyright file="INotifySink2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Interop {
    using System;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Security;
      
    [ComImport(), Guid("C43CC2F3-90AF-4e93-9112-DFB8B36749B5"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [SuppressUnmanagedCodeSecurity]
    internal interface INotifySink2 {
        
        void OnSyncCallOut(
            [In] CallId callId,
            [Out] out IntPtr out_ppBuffer, // byte**
            [In, Out] ref int inout_pBufferSize); // DWORD*

        
        void OnSyncCallEnter(
            [In] CallId callId,
            [In, MarshalAs(UnmanagedType.LPArray)] byte[] in_pBuffer, // byte*
            [In] int in_BufferSize);

        
        void OnSyncCallReturn(
            [In] CallId callId,
            [In, MarshalAs(UnmanagedType.LPArray)] byte[] in_pBuffer, // byte*
            [In] int in_BufferSize);

        
        void OnSyncCallExit(
            [In] CallId callId,
            [Out] out IntPtr out_ppBuffer, // byte**
            [In, Out] ref int inout_pBufferSize);
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\discovery\schemareference.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaReference.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Services.Discovery {

    using System;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Serialization;
    using System.IO;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Text;

    /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlRoot("schemaRef", Namespace=SchemaReference.Namespace)]
    public sealed class SchemaReference : DiscoveryReference {

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string Namespace = "http://schemas.xmlsoap.org/disco/schema/";

        private string reference;
        private string targetNamespace;

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.SchemaReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SchemaReference() {
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.SchemaReference1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SchemaReference(string url) {
            Ref = url;
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.Ref"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("ref")]
        public string Ref {
            get {
                return reference == null ? "" : reference;
            }
            set {
                reference = value;
            }
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.TargetNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("targetNamespace"), DefaultValue(null)]
        public string TargetNamespace {
            get { return targetNamespace; }
            set { targetNamespace = value; }
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override string Url {
            get { return Ref; }
            set { Ref = value; }
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.WriteDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteDocument(object document, Stream stream) {
            ((XmlSchema)document).Write(new StreamWriter(stream, new UTF8Encoding(false)));
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.ReadDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ReadDocument(Stream stream) {
            return XmlSchema.Read(stream, null);
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.DefaultFilename"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public override string DefaultFilename {
            get {
                string fileName = Schema.Id;
                if (fileName == null || fileName.Length == 0) {
                    fileName = FilenameFromUrl(Url);
                }
                return Path.ChangeExtension(fileName, ".xsd");
            }
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.Schema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchema Schema {
            get {
                if (ClientProtocol == null)
                    throw new InvalidOperationException(Res.GetString(Res.WebMissingClientProtocol));
                object document = ClientProtocol.Documents[Url];
                if (document == null) {
                    Resolve();
                    document = ClientProtocol.Documents[Url];
                }
                XmlSchema schema = document as XmlSchema;
                if (schema == null) {
                    throw new InvalidOperationException(Res.GetString(Res.WebInvalidDocType, 
                                                      typeof(XmlSchema).FullName,
                                                      document == null? string.Empty: document.GetType().FullName,
                                                      Url));
                }
                return schema;
            }
        }

        /// <include file='doc\SchemaReference.uex' path='docs/doc[@for="SchemaReference.Resolve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal override void Resolve(string contentType, Stream stream) {
            if (ContentType.IsHtml(contentType))
                throw new InvalidContentTypeException(Res.GetString(Res.WebInvalidContentType, contentType), contentType);
            XmlSchema schema = ClientProtocol.Documents[Url] as XmlSchema;
            if( schema == null ) {
                schema = XmlSchema.Read(stream, null);
                ClientProtocol.Documents[Url] = schema;
            }

            ClientProtocol.References[Url] = this;

            // now resolve references in the schema.
            foreach (object item in schema.Includes) {
                string location = null;
                try {
                    if (item is XmlSchemaInclude) {
                        location = ((XmlSchemaInclude)item).SchemaLocation;
                        if (location == null) {
                            continue;
                        }
                        location = new Uri(new Uri(Url), location).ToString();
                        SchemaReference includeRef = new SchemaReference(location);
                        includeRef.ClientProtocol = ClientProtocol;
                        ClientProtocol.References[location] = includeRef;
                        includeRef.Resolve();
                    }
                    else if (item is XmlSchemaImport) {
                        location = ((XmlSchemaImport)item).SchemaLocation;
                        if (location == null) {
                            continue;
                        }
                        location = new Uri(new Uri(Url), location).ToString();
                        SchemaReference importRef = new SchemaReference(location);
                        importRef.ClientProtocol = ClientProtocol;
                        ClientProtocol.References[location] = importRef;
                        importRef.Resolve();
                    }
                }
                catch (Exception e) {
                    throw new InvalidDocumentContentsException(Res.GetString(Res.TheSchemaDocumentContainsLinksThatCouldNotBeResolved, location), e);
                }
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\interop\inotifysource2.cs ===
//------------------------------------------------------------------------------
// <copyright file="INotifySource2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   INotifySource2.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Interop {
    using System;
    using System.Threading;
    using System.Runtime.InteropServices;
    
    [ComImport(), Guid("26E7F0F1-B49C-48cb-B43E-78DCD577E1D9"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface INotifySource2 {
        
        void SetNotifyFilter(
            [In] NotifyFilter in_NotifyFilter,
            [In] UserThread in_pUserThreadFilter);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\bufferedresponsestream.cs ===
//------------------------------------------------------------------------------
// <copyright file="BufferedResponseStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
	using System;
	using System.IO;
	using System.Web.Services;

    internal class BufferedResponseStream : Stream {
        Stream outputStream;
        byte[] buffer;
        int position;
        bool flushEnabled = true;

        internal BufferedResponseStream(Stream outputStream, int buffersize) {
            buffer = new byte[buffersize];
            this.outputStream = outputStream;
        }

        public override bool CanRead { get { return false; } }

        public override bool CanSeek { get { return false; } }

        public override bool CanWrite { get { return true; } }

        public override long Length { get { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotSeek)); } }

        public override long Position { 
            get { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotSeek)); } 
            set { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotSeek)); } 
        }

        public override void Close() {
            outputStream.Close();
        }

        internal bool FlushEnabled {
            set { flushEnabled = value; }
        }

        public override void Flush() {
            if (!flushEnabled)
                return; 
            FlushWrite();
        }

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, Object state) {
            throw new NotSupportedException(Res.GetString(Res.StreamDoesNotRead));
        }

        public override int EndRead(IAsyncResult asyncResult) { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotRead)); }

        public override long Seek(long offset, SeekOrigin origin) { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotSeek)); }

        public override void SetLength(long value) { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotSeek)); }

        public override int Read(byte[] buffer, int offset, int count) { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotRead)); }


        public override int ReadByte() { throw new NotSupportedException(Res.GetString(Res.StreamDoesNotRead)); }

        public override void Write(byte[] array, int offset, int count) {
            if (position > 0) {
                int numBytes = buffer.Length - position;   // space left in buffer
                if (numBytes > 0) {
                    if (numBytes > count)
                        numBytes = count;
                    Array.Copy(array, offset, buffer, position, numBytes);
                    position += numBytes;
                    if (count == numBytes) return;
                    offset += numBytes;
                    count -= numBytes;
                }
                FlushWrite();
            }
            // Skip buffer if we have more bytes then will fit in the buffer.
            if (count >= buffer.Length) {
                outputStream.Write(array, offset, count);
                return;
            }

            // Copy remaining bytes into buffer, to write at a later date.
            Array.Copy(array, offset, buffer, position, count);
            position = count;
        }

        private void FlushWrite() {
            if (position > 0) {
                outputStream.Write(buffer, 0, position);
                position = 0;
            }
            outputStream.Flush();
        }

        public override void WriteByte(byte value) {
            if (position == buffer.Length)
                FlushWrite();

            buffer[position++] = value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\anyreturnreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="AnyReturnReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Web.Services;
    using System.Net;

    /// <include file='doc\AnyReturnReader.uex' path='docs/doc[@for="AnyReturnReader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class AnyReturnReader : MimeReturnReader {
        /// <include file='doc\AnyReturnReader.uex' path='docs/doc[@for="AnyReturnReader.Initialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Initialize(object o) {
        }

        /// <include file='doc\AnyReturnReader.uex' path='docs/doc[@for="AnyReturnReader.GetInitializer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetInitializer(LogicalMethodInfo methodInfo) {
            if (methodInfo.IsVoid) return null;
            return this;
        }

        /// <include file='doc\AnyReturnReader.uex' path='docs/doc[@for="AnyReturnReader.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object Read(WebResponse response, Stream responseStream) {
            // caller needs to call close on the stream
            return responseStream;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\interop\userthread.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserThread.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   UserThread.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Interop {
    using System;
    using System.Threading;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal class UserThread {
        internal int pSidBuffer; // byte * to buffer of size dwSidLen.
        internal int dwSidLen;
        internal int dwTid;

        internal UserThread() {
            pSidBuffer = 0;
            dwSidLen = 0;
            dwTid = 0;
        }

        public override bool Equals(object obj) {
            if (! (obj is UserThread)) {
                return false;
            }

            UserThread ut = (UserThread) obj;

            if (ut.dwTid == this.dwTid &&
                ut.pSidBuffer == this.pSidBuffer &&
                ut.dwSidLen == this.dwSidLen) {
                return true;
            }

            return false;
        }

        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\interop\notifyfilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="NotifyFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   NotifyFilter.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Interop {
    using System;
    using System.Threading;
    using System.Runtime.InteropServices;
        
    internal enum NotifyFilter {
        OnSyncCallOut = 0x00000001,
        OnSyncCallEnter = 0x00000002,
        OnSyncCallExit = 0x00000004,
        OnSyncCallReturn  = 0x00000008,
        AllSync = OnSyncCallOut | 
                         OnSyncCallEnter | 
                         OnSyncCallExit | 
                         OnSyncCallReturn,
        All = -1,
        None = 0x00000000
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\htmlformparameterreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlFormParameterReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;

    /// <include file='doc\HtmlFormParameterReader.uex' path='docs/doc[@for="HtmlFormParameterReader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class HtmlFormParameterReader : ValueCollectionParameterReader {
        internal const string MimeType = "application/x-www-form-urlencoded";

        /// <include file='doc\HtmlFormParameterReader.uex' path='docs/doc[@for="HtmlFormParameterReader.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object[] Read(HttpRequest request) {
            if (!ContentType.MatchesBase(request.ContentType, MimeType)) return null;
            return Read(request.Form);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httpgetclientprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpGetClientProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Net;
    using System.IO;

    /// <include file='doc\HttpGetClientProtocol.uex' path='docs/doc[@for="HttpGetClientProtocol"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class HttpGetClientProtocol : HttpSimpleClientProtocol {
        /// <include file='doc\HttpGetClientProtocol.uex' path='docs/doc[@for="HttpGetClientProtocol.HttpGetClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpGetClientProtocol()
            : base() {
        }

        /// <include file='doc\HttpGetClientProtocol.uex' path='docs/doc[@for="HttpGetClientProtocol.GetWebRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override WebRequest GetWebRequest(Uri uri) {
            WebRequest request = base.GetWebRequest(uri);            
            request.Method = "GET";
            return request;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\htmlformparameterwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlFormParameterWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Text;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Net;

    /// <include file='doc\HtmlFormParameterWriter.uex' path='docs/doc[@for="HtmlFormParameterWriter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class HtmlFormParameterWriter : UrlEncodedParameterWriter {
        /// <include file='doc\HtmlFormParameterWriter.uex' path='docs/doc[@for="HtmlFormParameterWriter.UsesWriteRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool UsesWriteRequest { get { return true; } }

        /// <include file='doc\HtmlFormParameterWriter.uex' path='docs/doc[@for="HtmlFormParameterWriter.InitializeRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void InitializeRequest(WebRequest request, object[] values) {
            request.ContentType = ContentType.Compose(HtmlFormParameterReader.MimeType, RequestEncoding);
        }

        /// <include file='doc\HtmlFormParameterWriter.uex' path='docs/doc[@for="HtmlFormParameterWriter.WriteRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteRequest(Stream requestStream, object[] values) {            
            if (values.Length == 0) return;

            // just use ASCII encoding since we're url-escaping everything...
            TextWriter writer = new StreamWriter(requestStream, new ASCIIEncoding());
            Encode(writer, values);                        
            writer.Flush();            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\documentationserverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentationServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Web.Services.Discovery;
    using System.Web.UI;
    using System.Diagnostics;
    using System.Web.Services.Configuration;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Text;
    using System.Net;
    using System.Web.Services.Description;

    internal class DocumentationServerType : ServerType {
        ServiceDescriptionCollection serviceDescriptions, serviceDescriptionsWithPost;
        XmlSchemas schemas, schemasWithPost;
        LogicalMethodInfo methodInfo;

        internal DocumentationServerType(Type type, string uri) : base(typeof(DocumentationServerProtocol)) {
            //
            // parse the uri from a string into a URI object
            //
            Uri uriObject = new Uri(uri, true);
            //
            // and get rid of the query string if there's one
            //
            uri = uriObject.GetLeftPart(UriPartial.Path);
            methodInfo = new LogicalMethodInfo(typeof(DocumentationServerProtocol).GetMethod("Documentation", BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
            ServiceDescriptionReflector reflector = new ServiceDescriptionReflector();
            reflector.Reflect(type, uri);
            schemas = reflector.Schemas;
            serviceDescriptions = reflector.ServiceDescriptions;
            schemasWithPost = reflector.SchemasWithPost;
            serviceDescriptionsWithPost = reflector.ServiceDescriptionsWithPost;
        }
                   
        internal LogicalMethodInfo MethodInfo {
            get { return methodInfo; }
        }

        internal XmlSchemas Schemas {
            get { return schemas; }
        }

        internal ServiceDescriptionCollection ServiceDescriptions {
            get { return serviceDescriptions; }
        }
        
        internal ServiceDescriptionCollection ServiceDescriptionsWithPost {
            get { return serviceDescriptionsWithPost; }
        }
        
        internal XmlSchemas SchemasWithPost {
            get { return schemasWithPost; }
        }
    }

    internal class DocumentationServerProtocolFactory : ServerProtocolFactory {
        protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request){
            if (request.PathInfo.Length > 0)
                return null;

            if (request.HttpMethod != "GET")
                return null;

            return new DocumentationServerProtocol();
        }
    }

    internal sealed class DocumentationServerProtocol : ServerProtocol {
        DocumentationServerType serverType;
        IHttpHandler handler = null;

        private const int MAX_PATH_SIZE = 1024;

        internal override bool Initialize() {

            //
            // see if we already cached a DocumentationServerType
            //
            serverType = (DocumentationServerType)GetFromCache(typeof(DocumentationServerProtocol), Type);
            if (serverType == null) {
                lock(Type){
                    serverType = (DocumentationServerType)GetFromCache(typeof(DocumentationServerProtocol), Type);
                    if (serverType == null) {
                        //
                        // if not create a new DocumentationServerType and cache it
                        //
                        // CONSIDER, use relative urls.
                        serverType = new DocumentationServerType(Type, Request.Url.ToString());
                        AddToCache(typeof(DocumentationServerProtocol), Type, serverType);
                    }
                }
            }

            WebServicesConfiguration config = WebServicesConfiguration.Current;
            if (config.WsdlHelpGeneratorPath != null)
                handler = PageParser.GetCompiledPageInstance(config.WsdlHelpGeneratorVirtualPath,
                                                             config.WsdlHelpGeneratorPath,
                                                             Context);
            return true;                       
        }

        internal override ServerType ServerType {
            get { return serverType; }
        }

        internal override bool IsOneWay {
            get { return false; }            
        }            

        internal override LogicalMethodInfo MethodInfo {
            get { return serverType.MethodInfo; }
        }
        
        internal override object[] ReadParameters() {
            return new object[0];
        }

        internal override void WriteReturns(object[] returnValues, Stream outputStream) {
            try {
                if (handler != null) {
                    Context.Items.Add("wsdls", serverType.ServiceDescriptions);
                    Context.Items.Add("schemas", serverType.Schemas);

                    // conditionally add post-enabled wsdls and schemas to support localhost-only post
                    string localAddr = Context.Request.ServerVariables["LOCAL_ADDR"];
                    string remoteAddr = Context.Request.ServerVariables["REMOTE_ADDR"];
                    if (Context.Request.Url.IsLoopback || (localAddr != null && remoteAddr != null && localAddr == remoteAddr)) {
                        Context.Items.Add("wsdlsWithPost", serverType.ServiceDescriptionsWithPost);
                        Context.Items.Add("schemasWithPost", serverType.SchemasWithPost);
                    }

                    Response.ContentType = "text/html";
                    handler.ProcessRequest(Context);
                }
            }
            catch (Exception e) {
                throw new InvalidOperationException(Res.GetString(Res.HelpGeneratorInternalError), e);
            }
        }

        internal override bool WriteException(Exception e, Stream outputStream) {
            return false;
        }

        internal void Documentation() {
            // This is the "server method" that is called for this protocol
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\discoveryserverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiscoveryServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Web.Services.Description;
    using System.Web.Services.Discovery;
    using System.Web.UI;
    using System.Text;
    using System.Diagnostics;
    using System.Net;
    using System.Web.Services.Configuration;
    using System.Globalization;
    
    internal class DiscoveryServerType : ServerType {
        ServiceDescription description;
        LogicalMethodInfo methodInfo;
        Hashtable schemaTable = new Hashtable();
        Hashtable wsdlTable = new Hashtable();
        DiscoveryDocument discoDoc;

        internal DiscoveryServerType(Type type, string uri) : base(typeof(DiscoveryServerProtocol)) {
            //
            // parse the uri from a string into a Uri object
            //
            Uri uriObject = new Uri(uri, true);
            //
            // and get rid of the query string if there's one
            //
            uri = uriObject.GetLeftPart(UriPartial.Path);
            methodInfo = new LogicalMethodInfo(typeof(DiscoveryServerProtocol).GetMethod("Discover", BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
            ServiceDescriptionReflector reflector = new ServiceDescriptionReflector();
            reflector.Reflect(type, uri);

            XmlSchemas schemas = reflector.Schemas;
            this.description = reflector.ServiceDescription;
            
            // We need to force initialization of ServiceDescription's XmlSerializer since we
            // won't necessarily have the permissions to do it when we actually need it
            XmlSerializer serializer = ServiceDescription.Serializer;

            // add imports to the external schemas
            int count = 0;
            foreach (XmlSchema schema in schemas) {
                // CONSIDER, erikc, seems fragile/brittle to use the index here in the URL
                if (schema.Id == null || schema.Id.Length == 0)
                    schema.Id = "schema" + (++count).ToString();
                foreach (ServiceDescription description in reflector.ServiceDescriptions) {
                    Import import = new Import();
                    import.Namespace = schema.TargetNamespace;
                    import.Location = uri + "?schema=" + schema.Id;
                    description.Imports.Add(import);
                }
                schemaTable.Add(schema.Id, schema);
            }

            // add imports to the other service descriptions
            for (int i = 1; i < reflector.ServiceDescriptions.Count; i++) {
                ServiceDescription description = reflector.ServiceDescriptions[i];
                Import import = new Import();
                import.Namespace = description.TargetNamespace;

                // CONSIDER, erikc, seems kinda brittle to use the index of the description
                // as the URL -- when you add interfaces, reorder methods, etc. this might
                // change which could be irritating.
                string id = "wsdl" + i.ToString();

                import.Location = uri + "?wsdl=" + id;
                reflector.ServiceDescription.Imports.Add(import);
                wsdlTable.Add(id, description);
            }

            discoDoc = new DiscoveryDocument();
            discoDoc.References.Add(new ContractReference(uri + "?wsdl", uri));

            foreach (Service service in reflector.ServiceDescription.Services) {
                foreach (Port port in service.Ports) {
                    SoapAddressBinding soapAddress = (SoapAddressBinding)port.Extensions.Find(typeof(SoapAddressBinding));
                    if (soapAddress != null) {
                        System.Web.Services.Discovery.SoapBinding binding = new System.Web.Services.Discovery.SoapBinding();
                        binding.Binding = port.Binding;
                        binding.Address = soapAddress.Location;
                        discoDoc.References.Add(binding);
                    }
                }
            }
        }

        internal XmlSchema GetSchema(string id) {
            return (XmlSchema)schemaTable[id];
        }


        internal ServiceDescription GetServiceDescription(string id) {
            return (ServiceDescription)wsdlTable[id];
        }

        internal ServiceDescription Description {
            get { return description; }
        }        
                    
        internal LogicalMethodInfo MethodInfo {
            get { return methodInfo; }
        }

        internal DiscoveryDocument Disco {
            get {
                return discoDoc;
            }
        }
    }

    internal class DiscoveryServerProtocolFactory : ServerProtocolFactory {
        protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request){
            if (request.PathInfo.Length > 0)
                return null;

            if (request.HttpMethod != "GET")
                return null;

            string queryString = request.QueryString[null];
            if (queryString == null) queryString = "";
            if (request.QueryString["schema"] == null &&
                  request.QueryString["wsdl"] == null &&
                  string.Compare(queryString, "wsdl", true, CultureInfo.InvariantCulture) != 0 &&
                  string.Compare(queryString, "disco", true, CultureInfo.InvariantCulture) != 0)
                return null;
            
            return new DiscoveryServerProtocol();
        }
    }

    internal sealed class DiscoveryServerProtocol : ServerProtocol {
        DiscoveryServerType serverType;

        internal override bool Initialize() {


            //
            // see if we already cached a DiscoveryServerType
            //
            serverType = (DiscoveryServerType)GetFromCache(typeof(DiscoveryServerProtocol), Type);
            if (serverType == null) {
                lock(Type){
                    serverType = (DiscoveryServerType)GetFromCache(typeof(DiscoveryServerProtocol), Type);
                    if (serverType == null) {
                        //
                        // if not create a new DiscoveryServerType and cache it
                        //
                        serverType = new DiscoveryServerType(Type, Request.Url.ToString());
                        AddToCache(typeof(DiscoveryServerProtocol), Type, serverType);
                    }
                }
            }

            return true;                       
        }

        internal override ServerType ServerType {
            get { return serverType; }
        }

        internal override bool IsOneWay {
            get { return false; }            
        }            

        internal override LogicalMethodInfo MethodInfo {
            get { return serverType.MethodInfo; }
        }
        
        internal override object[] ReadParameters() {
            return new object[0];
        }

        internal override void WriteReturns(object[] returnValues, Stream outputStream) {
            string id = Request.QueryString["schema"];
            Encoding encoding = new UTF8Encoding(false);

            if (id != null) {
                XmlSchema schema = serverType.GetSchema(id);
                if (schema == null) throw new InvalidOperationException(Res.GetString(Res.WebSchemaNotFound));
                Response.ContentType = ContentType.Compose("text/xml", encoding);
                schema.Write(new StreamWriter(outputStream, encoding));
                return;
            }
           
            id = Request.QueryString["wsdl"];
            if (id != null) {
                ServiceDescription description = serverType.GetServiceDescription(id);
                if (description == null) throw new InvalidOperationException(Res.GetString(Res.ServiceDescriptionWasNotFound0));
                Response.ContentType = ContentType.Compose("text/xml", encoding);
                description.Write(new StreamWriter(outputStream, encoding));
                return;
            }

            string queryString = Request.QueryString[null];
            if (queryString != null && string.Compare(queryString, "wsdl", true, CultureInfo.InvariantCulture) == 0) {
                Response.ContentType = ContentType.Compose("text/xml", encoding);
                serverType.Description.Write(new StreamWriter(outputStream, encoding));
                return;
            }

            if (queryString != null && string.Compare(queryString, "disco", true, CultureInfo.InvariantCulture) == 0) {
                Response.ContentType = ContentType.Compose("text/xml", encoding);
                serverType.Disco.Write(new StreamWriter(outputStream, encoding));
                return;
            }


            throw new InvalidOperationException(Res.GetString(Res.internalError0));
        }

        internal override bool WriteException(Exception e, Stream outputStream) {
            Response.Clear();
            Response.ClearHeaders();
            Response.ContentType = ContentType.Compose("text/plain", Encoding.UTF8);
            Response.StatusCode = (int) HttpStatusCode.InternalServerError;
            Response.StatusDescription = Res.GetString(Res.WebRequestErrorStatusDescription);                                             
            StreamWriter writer = new StreamWriter(outputStream, new UTF8Encoding(false));
            writer.WriteLine(GenerateFaultString(e, true));
            writer.Flush();
            return true;
        }

        internal void Discover() {
            // This is the "server method" that is called for this protocol
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httpgetserverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpGetServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    internal class HttpGetServerProtocolFactory : ServerProtocolFactory {
        protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request){
            if (request.PathInfo.Length < 2)
                return null;
            if (request.HttpMethod != "GET")
                return null;

            return new HttpGetServerProtocol();
        }
    }

    internal class HttpGetServerProtocol : HttpServerProtocol {
        internal HttpGetServerProtocol() : base(false) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\clientprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="ClientProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.IO;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Net;
    using System.Threading;
    using System.Text;
    using System.Security.Cryptography.X509Certificates;
    using System.Security.Permissions;

    internal class ClientTypeCache {
        Hashtable cache = new Hashtable();

        internal object this[Type key] {
            get { return cache[key]; }
        }

        internal void Add(Type key, object value) {
            lock(this) {
                if (cache[key] == value) return;
                Hashtable clone = new Hashtable();
                foreach (object k in cache.Keys) {
                    clone.Add(k, cache[k]);
                }
                cache = clone;
                cache[key] = value;
            }
        }
    }

    /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the base class for all web service protocol client proxies that
    ///       use the HTTP protocol.
    ///    </para>
    /// </devdoc>
    public abstract class WebClientProtocol : Component {
        static AsyncCallback getRequestStreamAsyncCallback;
        static AsyncCallback getResponseAsyncCallback;
        static AsyncCallback readResponseAsyncCallback;
        private static ClientTypeCache cache;
        private ICredentials credentials;
        private bool preAuthenticate;
        private Uri uri;
        private int timeout;
        private string connectionGroupName;
        private Encoding requestEncoding;
        private RemoteDebugger debugger;
        private WebRequest pendingSyncRequest;

        static WebClientProtocol() {
            cache = new ClientTypeCache();
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.WebClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected WebClientProtocol() {
            this.timeout = 100000; // should be kept in sync with HttpWebRequest.Timeout default (see private WebRequest.DefaultTimeout)
        }

        internal WebClientProtocol(WebClientProtocol protocol) {
            this.credentials        = protocol.credentials;
            this.uri                = protocol.uri;
            this.timeout            = protocol.timeout;
            this.connectionGroupName= protocol.connectionGroupName;
            this.requestEncoding    = protocol.requestEncoding;
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.Credentials"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICredentials Credentials {
            get {
                return credentials;
            }
            set {
                credentials = value;
            }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.ConnectionGroupName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the name of the connection group to use when making a request.
        ///    </para>
        /// </devdoc>
        [DefaultValue("")]
        public string ConnectionGroupName {
            get { return (connectionGroupName == null) ? string.Empty : connectionGroupName; }
            set { connectionGroupName = value; }
        }

        internal WebRequest PendingSyncRequest {
            get { return pendingSyncRequest; }
            set { pendingSyncRequest = value; }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.PreAuthenticate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether pre-authentication is enabled.
        ///    </para>
        /// </devdoc>
        [DefaultValue(false), WebServicesDescription(Res.ClientProtocolPreAuthenticate)]
        public bool PreAuthenticate {
            get { return preAuthenticate; }
            set { preAuthenticate = value; }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.Url"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the base Uri to the server to use for requests.
        ///    </para>
        /// </devdoc>
        [DefaultValue(""), RecommendedAsConfigurable(true), WebServicesDescription(Res.ClientProtocolUrl)]
        public string Url {
            get { return uri == null ? string.Empty : uri.ToString(); }
            set { uri = new Uri(value); }
        }

        
        internal Uri Uri {
            get { return uri; }
            set { uri = value; }
        }
        
        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.RequestEncoding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the encoding used for making the request.
        ///    </para>
        /// </devdoc>
        [DefaultValue(null), RecommendedAsConfigurable(true), WebServicesDescription(Res.ClientProtocolEncoding)]
        public Encoding RequestEncoding {
            get { return requestEncoding; }
            set { requestEncoding = value; }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.Timeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the timeout (in milliseconds) used for synchronous calls.
        ///    </para>
        /// </devdoc>
        [DefaultValue(100000), RecommendedAsConfigurable(true), WebServicesDescription(Res.ClientProtocolTimeout)]
        public int Timeout {
            get { return timeout; }
            set { timeout = (value < Threading.Timeout.Infinite) ? Threading.Timeout.Infinite : value; }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.Abort"]/*' />
        public virtual void Abort() {
            WebRequest request = PendingSyncRequest;
            if (request != null)
                request.Abort();
        }

        /// <devdoc>
        ///    <para>
        ///     Starts async request processing including async retrieval of the request stream and response.
        ///     Derived classes can use BeginSend
        ///     to help implement their own higher level async methods like BeginInvoke. Derived
        ///     classes can add custom behavior by overriding GetWebRequest, GetWebResponse,
        ///     InitializeAsyncRequest and WriteAsyncRequest methods.
        ///    </para>
        /// </devdoc>
        internal IAsyncResult BeginSend(Uri requestUri, object internalAsyncState, AsyncCallback outerCallback, object outerAsyncState, bool callWriteAsyncRequest) {
            if (readResponseAsyncCallback == null) {
                lock (typeof(WebClientProtocol)) {
                    if (readResponseAsyncCallback == null) {
                        getRequestStreamAsyncCallback = new AsyncCallback(GetRequestStreamAsyncCallback);
                        getResponseAsyncCallback = new AsyncCallback(GetResponseAsyncCallback);
                        readResponseAsyncCallback = new AsyncCallback(ReadResponseAsyncCallback);
                    }
                }
            }
            WebRequest request = GetWebRequest(requestUri);
            WebClientAsyncResult client = new WebClientAsyncResult(this, internalAsyncState, request, outerCallback, outerAsyncState, 0);
            InitializeAsyncRequest(request, internalAsyncState);
            if (callWriteAsyncRequest)
                request.BeginGetRequestStream(getRequestStreamAsyncCallback, client);
            else
                request.BeginGetResponse(getResponseAsyncCallback, client);

            if (!client.IsCompleted)
                client.CombineCompletedSynchronously(false);
            return client;
        }

        static private void ProcessAsyncException(WebClientAsyncResult client, Exception e) {
            WebException webException = e as WebException;
            if (webException != null && webException.Response != null) {
                client.Response = webException.Response;
            }
            else {
                // If we've already completed the call then the exception must have come
                // out of the user callback in which case we need to rethrow it here
                // so that it bubbles up to the AppDomain unhandled exception event.
                if (client.IsCompleted) 
                    throw new InvalidOperationException(Res.GetString(Res.ThereWasAnErrorDuringAsyncProcessing), e);
                else
                    client.Complete(e);
            }
        }

        static private void GetRequestStreamAsyncCallback(IAsyncResult asyncResult) {
            WebClientAsyncResult client = (WebClientAsyncResult)asyncResult.AsyncState;
            client.CombineCompletedSynchronously(asyncResult.CompletedSynchronously);
            try {
                Stream requestStream = client.Request.EndGetRequestStream(asyncResult);
                try {
                    client.ClientProtocol.AsyncBufferedSerialize(client.Request, requestStream, client.InternalAsyncState);
                }
                finally {
                    requestStream.Close();
                }
                client.Request.BeginGetResponse(getResponseAsyncCallback, client);
            }
            catch (Exception e) {
                ProcessAsyncException(client, e);
            }
        }

        static private void GetResponseAsyncCallback(IAsyncResult asyncResult) {
            WebClientAsyncResult client = (WebClientAsyncResult)asyncResult.AsyncState;
            client.CombineCompletedSynchronously(asyncResult.CompletedSynchronously);
            try {
                client.Response = client.ClientProtocol.GetWebResponse(client.Request, asyncResult);
            }
            catch (Exception e) {
                ProcessAsyncException(client, e);
                if(client.Response == null)
                    return;
            }

            ReadAsyncResponse(client);
        }

        static private void ReadAsyncResponse(WebClientAsyncResult client) {
            if (client.Response.ContentLength == 0) {
                client.Complete();
                return;
            }
            try {
                client.ResponseStream = client.Response.GetResponseStream();
                ReadAsyncResponseStream(client);
            }
            catch (Exception e) {
                ProcessAsyncException(client, e);
            }
        }

        static private void ReadAsyncResponseStream(WebClientAsyncResult client) {
            IAsyncResult asyncResult;
            do {
                byte[] buffer = client.Buffer;
                long contentLength = client.Response.ContentLength;
                if (buffer == null)
                    buffer = client.Buffer = new byte[(contentLength == -1) ? 1024 : contentLength];
                else if (contentLength != -1 && contentLength > buffer.Length)
                    buffer = client.Buffer = new byte[contentLength];
                asyncResult = client.ResponseStream.BeginRead(buffer, 0, buffer.Length, readResponseAsyncCallback, client);
                if (!asyncResult.CompletedSynchronously)
                    return;
            }
            while (!ProcessAsyncResponseStreamResult(client, asyncResult));
        }

        static private bool ProcessAsyncResponseStreamResult(WebClientAsyncResult client, IAsyncResult asyncResult) {
            bool complete;
            int bytesRead = client.ResponseStream.EndRead(asyncResult);
            long contentLength = client.Response.ContentLength;
            if (contentLength > 0 && bytesRead == contentLength) {
                // the non-chunked response finished in a single read
                client.ResponseBufferedStream = new MemoryStream(client.Buffer);
                complete = true;
            }
            else if (bytesRead > 0) {
                if (client.ResponseBufferedStream == null) {
                    int capacity = (int) ((contentLength == -1) ? client.Buffer.Length : contentLength);
                    client.ResponseBufferedStream = new MemoryStream(capacity);
                }
                client.ResponseBufferedStream.Write(client.Buffer, 0, bytesRead);
                complete = false;
            }
            else
                complete = true;

            if (complete)
                client.Complete();
            return complete;
        }

        static private void ReadResponseAsyncCallback(IAsyncResult asyncResult) {
            WebClientAsyncResult client = (WebClientAsyncResult)asyncResult.AsyncState;
            client.CombineCompletedSynchronously(asyncResult.CompletedSynchronously);
            if (asyncResult.CompletedSynchronously)
                return;
            try {
                bool complete = ProcessAsyncResponseStreamResult(client, asyncResult);
                if (!complete)
                    ReadAsyncResponseStream(client);
            }
            catch (Exception e) {
                ProcessAsyncException(client, e);
            }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.GetWebRequest"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Creates a new <see cref='System.Net.WebRequest'/> instance for the given url. The base implementation creates a new
        ///     instance using the WebRequest.Create() and then sets request related properties from
        ///     the WebClientProtocol instance. Derived classes can override this method if additional
        ///     properties need to be set on the web request instance.
        ///    </para>
        /// </devdoc>
        protected virtual WebRequest GetWebRequest(Uri uri) {
            if (uri == null)
                throw new InvalidOperationException(Res.GetString(Res.WebMissingPath));
            WebRequest request = (WebRequest)WebRequest.Create(uri);
            PendingSyncRequest = request;
            request.Timeout = this.timeout;
            request.ConnectionGroupName = connectionGroupName;
            request.Credentials = Credentials;
            request.PreAuthenticate = PreAuthenticate;
            if (RemoteDebugger.IsClientCallOutEnabled()) {
                debugger = new RemoteDebugger();
                debugger.NotifyClientCallOut(request);
            }
            else
                debugger = null;
            return request;
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.GetWebResponse"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Gets the <see cref='System.Net.WebResponse'/> from the given request by calling
        ///     GetResponse(). Derived classes can override this method to do additional
        ///     processing on the response instance.
        ///    </para>
        /// </devdoc>
        protected virtual WebResponse GetWebResponse(WebRequest request) {
            WebResponse response = null;
            try {
                response = request.GetResponse();
            }
            catch (WebException e) {
                if (e.Response == null)
                    throw e;
                else
                    response = e.Response;
            }
            finally {
                if (debugger != null)
                    debugger.NotifyClientCallReturn(response);
            }
            return response;
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.GetWebResponse1"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Gets the <see cref='System.Net.WebResponse'/> from the given request by calling
        ///     EndGetResponse(). Derived classes can override this method to do additional
        ///     processing on the response instance. This method is only called during
        ///     async request processing.
        ///    </para>
        /// </devdoc>
        protected virtual WebResponse GetWebResponse(WebRequest request, IAsyncResult result) {
            WebResponse response = request.EndGetResponse(result);
            if (response != null && debugger != null)
                debugger.NotifyClientCallReturn(response);
            return response;
        }

        /// <devdoc>
        ///    <para>
        ///     Called during async request processing to give the derived class an opportunity
        ///     to modify the web request instance before the request stream is retrieved at which
        ///     point the request headers are sent and can no longer be modified. The base implementation
        ///     does nothing.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        internal virtual void InitializeAsyncRequest(WebRequest request, object internalAsyncState) {
            return;
        }

        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        internal virtual void AsyncBufferedSerialize(WebRequest request, Stream requestStream, object internalAsyncState) {
            throw new NotSupportedException(Res.GetString(Res.ProtocolDoesNotAsyncSerialize));
        }

        internal WebResponse EndSend(IAsyncResult asyncResult, ref object internalAsyncState, ref Stream responseStream) {
            if (asyncResult == null) throw new ArgumentNullException(Res.GetString(Res.WebNullAsyncResultInEnd));

            WebClientAsyncResult client = (WebClientAsyncResult)asyncResult;
            if (client.EndSendCalled)
                throw new InvalidOperationException(Res.GetString(Res.CanTCallTheEndMethodOfAnAsyncCallMoreThan));
            client.EndSendCalled = true;
            WebResponse response = client.WaitForResponse();
            internalAsyncState = client.InternalAsyncState;
            responseStream = client.ResponseBufferedStream;
            return response;
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.GetFromCache"]/*' />
        /// <devdoc>
        /// Returns an instance of a client protocol handler from the cache.
        /// </devdoc>
        protected static object GetFromCache(Type type) {
            return cache[type];
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientProtocol.AddToCache"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Add an instance of the client protocol handler to the cache.
        ///    </para>
        /// </devdoc>
        protected static void AddToCache(Type type, object value) {
            cache.Add(type, value);
        }

    }

    /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientAsyncResult"]/*' />
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class WebClientAsyncResult : IAsyncResult {
        private object userAsyncState;
        private bool completedSynchronously;
        private bool isCompleted;
        private ManualResetEvent manualResetEvent;
        private AsyncCallback userCallback;

        internal WebClientProtocol ClientProtocol;
        internal object InternalAsyncState;
        internal Exception Exception;
        internal WebResponse Response;
        internal WebRequest Request;
        internal Stream ResponseStream;
        internal Stream ResponseBufferedStream;
        internal byte[] Buffer;
        internal bool EndSendCalled;

        internal WebClientAsyncResult(WebClientProtocol clientProtocol,
                                      object internalAsyncState,
                                      WebRequest request,
                                      AsyncCallback userCallback,
                                      object userAsyncState,
                                      int retryNumber) {
            this.ClientProtocol = clientProtocol;
            this.InternalAsyncState = internalAsyncState;
            this.userAsyncState= userAsyncState;
            this.userCallback = userCallback;
            this.Request = request;
            this.completedSynchronously = true;
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientAsyncResult.AsyncState"]/*' />
        public object AsyncState  { get { return userAsyncState; } }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientAsyncResult.AsyncWaitHandle"]/*' />
        public WaitHandle AsyncWaitHandle {
            get {
                bool savedIsCompleted = isCompleted;
                if (manualResetEvent == null) {
                    lock (this) {
                        if (manualResetEvent == null)
                            manualResetEvent = new ManualResetEvent(savedIsCompleted);
                    }
                }
                if (!savedIsCompleted && isCompleted)
                    manualResetEvent.Set();
                return (WaitHandle)manualResetEvent;
            }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientAsyncResult.CompletedSynchronously"]/*' />
        public bool CompletedSynchronously {
            get { return completedSynchronously; }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientAsyncResult.IsCompleted"]/*' />
        public bool IsCompleted { get { return isCompleted; } }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="WebClientAsyncResult.Abort"]/*' />
        public void Abort() {
            WebRequest req = Request;
            if (req != null)
                req.Abort();
        }


        internal void Complete() {
            Debug.Assert(!isCompleted, "Complete called more than once.");

            try {
                if (ResponseStream != null) {
                    ResponseStream.Close();
                    ResponseStream = null;
                }

                if (ResponseBufferedStream != null)
                    ResponseBufferedStream.Position = 0;
            }
            catch (Exception e) {
                if (this.Exception == null)
                    this.Exception = e;
            }

            isCompleted = true;

            try {
                if (manualResetEvent != null)
                    manualResetEvent.Set();
            }
            catch (Exception e) {
                if (this.Exception == null)
                    this.Exception = e;
            }

            // We want to let exceptions in user callback to bubble up to
            // threadpool so that AppDomain.UnhandledExceptionEventHandler
            // will get it if one is registered
            if (userCallback != null)
                userCallback(this);
        }

        internal void Complete(Exception e) {
            this.Exception = e;
            Complete();
        }

        internal WebResponse WaitForResponse() {
            if (!isCompleted)
                AsyncWaitHandle.WaitOne();

            if (this.Exception != null)
                throw this.Exception;

           return Response;
        }

        internal void CombineCompletedSynchronously(bool innerCompletedSynchronously) {
            completedSynchronously = completedSynchronously && innerCompletedSynchronously;
        }
    }


    /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class HttpWebClientProtocol : WebClientProtocol {
        private bool allowAutoRedirect;
        private CookieContainer cookieJar = null;
        private X509CertificateCollection clientCertificates;
        private IWebProxy proxy;
        private static string UserAgentDefault = "Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol " + System.Environment.Version.ToString() + ")";
        private string userAgent;
        private bool unsafeAuthenticatedConnectionSharing;
        
        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.HttpWebClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected HttpWebClientProtocol()
            : base() {
            this.allowAutoRedirect  = false;
            this.userAgent          = UserAgentDefault;
            // the right thing to do, for NetClasses to pick up the default
            // GlobalProxySelection settings, is to leave proxy to null
            // (which is the default initialization value)
            // rather than picking up GlobalProxySelection.Select
            // which will never change.
        }

        // used by SoapHttpClientProtocol.Discover
        internal HttpWebClientProtocol(HttpWebClientProtocol protocol)
            : base(protocol) {
            this.allowAutoRedirect  = protocol.allowAutoRedirect;
            this.cookieJar          = protocol.cookieJar;
            this.clientCertificates = protocol.clientCertificates;
            this.proxy              = protocol.proxy;
            this.userAgent          = protocol.userAgent;
        }


        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.AllowAutoRedirect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the client should automatically follow server redirects.
        ///    </para>
        /// </devdoc>
        [DefaultValue(false), WebServicesDescription(Res.ClientProtocolAllowAutoRedirect)]
        public bool AllowAutoRedirect {
            get {
                return allowAutoRedirect;
            }

            set {
                allowAutoRedirect = value;
            }
        }


        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.CookieContainer"]/*' />
        [DefaultValue(null), WebServicesDescription(Res.ClientProtocolCookieContainer)]
        public CookieContainer CookieContainer {
            get {
                return cookieJar;
            }
            set {
                cookieJar = value;
            }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.ClientCertificates"]/*' />
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), WebServicesDescription(Res.ClientProtocolClientCertificates)]
        public X509CertificateCollection ClientCertificates {
            get {
                if (clientCertificates == null) {
                    clientCertificates = new X509CertificateCollection();
                }
                return clientCertificates;
            }
        }

         /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.UserAgent"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Gets or sets the value for the user agent header that is
         ///       sent with each request.
         ///    </para>
         /// </devdoc>
        [WebServicesDescription(Res.ClientProtocolUserAgent)]
        public string UserAgent {
            get { return (userAgent == null) ? string.Empty : userAgent; }
            set { userAgent = value; }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.Proxy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the proxy server to use for requests.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public IWebProxy Proxy {
            get { return proxy; }
            set { proxy = value; }
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.GetWebRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override WebRequest GetWebRequest(Uri uri) {
            WebRequest request = base.GetWebRequest(uri);
            HttpWebRequest httpRequest = request as HttpWebRequest;
            if (httpRequest != null) {
                httpRequest.UserAgent = UserAgent;
                httpRequest.AllowAutoRedirect = allowAutoRedirect;
                httpRequest.AllowWriteStreamBuffering = true;
                httpRequest.SendChunked = false;
                if (unsafeAuthenticatedConnectionSharing != httpRequest.UnsafeAuthenticatedConnectionSharing)
                    httpRequest.UnsafeAuthenticatedConnectionSharing = unsafeAuthenticatedConnectionSharing;
                // if the user has set a proxy explictly then we need to
                // propagate that to the WebRequest, otherwise we'll let NetClasses
                // use their global setting (GlobalProxySelection.Select).
                if (proxy != null) {
                    httpRequest.Proxy = proxy;
                }
                if (clientCertificates != null && clientCertificates.Count > 0) {
                    httpRequest.ClientCertificates.AddRange(clientCertificates);
                }
                httpRequest.CookieContainer = cookieJar;
            }
            return request;
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.GetWebResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override WebResponse GetWebResponse(WebRequest request) {
            WebResponse response = base.GetWebResponse(request);
            return response;
        }

        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.GetWebResponse1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override WebResponse GetWebResponse(WebRequest request, IAsyncResult result) {
            WebResponse response = base.GetWebResponse(request, result);
            return response;
        }
        
        /// <include file='doc\ClientProtocol.uex' path='docs/doc[@for="HttpWebClientProtocol.UnsafeAuthenticatedConnectionSharing"]/*' />
        public bool UnsafeAuthenticatedConnectionSharing {
            get { return unsafeAuthenticatedConnectionSharing; }
            set { unsafeAuthenticatedConnectionSharing = value; }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httpclientprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpClientProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Net;
    using System.Text;

    internal class HttpClientMethod {
        internal Type readerType;
        internal object readerInitializer;
        internal Type writerType;
        internal object writerInitializer;
        internal LogicalMethodInfo methodInfo;
    }

    internal class HttpClientType {
        Hashtable methods = new Hashtable();

        internal HttpClientType(Type type) {
            LogicalMethodInfo[] methodInfos = LogicalMethodInfo.Create(type.GetMethods(), LogicalMethodTypes.Sync);

            Hashtable formatterTypes = new Hashtable();
            for (int i = 0; i < methodInfos.Length; i++) {
                LogicalMethodInfo methodInfo = methodInfos[i];
                try {
                    object[] attributes = methodInfo.GetCustomAttributes(typeof(HttpMethodAttribute));
                    if (attributes.Length == 0) continue;
                    HttpMethodAttribute attribute = (HttpMethodAttribute)attributes[0];
                    HttpClientMethod method = new HttpClientMethod();
                    method.readerType = attribute.ReturnFormatter;
                    method.writerType = attribute.ParameterFormatter;
                    method.methodInfo = methodInfo;
                    AddFormatter(formatterTypes, method.readerType, method);
                    AddFormatter(formatterTypes, method.writerType, method);
                    methods.Add(methodInfo.Name, method);
                }
                catch (Exception e) {
                    throw new InvalidOperationException(Res.GetString(Res.WebReflectionError, methodInfo.DeclaringType.FullName, methodInfo.Name), e);
                }
            }

            foreach (Type t in formatterTypes.Keys) {
                ArrayList list = (ArrayList)formatterTypes[t];
                LogicalMethodInfo[] m = new LogicalMethodInfo[list.Count];
                for (int j = 0; j < list.Count; j++)
                    m[j] = ((HttpClientMethod)list[j]).methodInfo;
                object[] initializers = MimeFormatter.GetInitializers(t, m);
                bool isWriter = typeof(MimeParameterWriter).IsAssignableFrom(t);
                for (int j = 0; j < list.Count; j++) {
                    if (isWriter) {
                        ((HttpClientMethod)list[j]).writerInitializer = initializers[j];
                    }
                    else {
                        ((HttpClientMethod)list[j]).readerInitializer = initializers[j];
                    }
                }
            }
        }

        static void AddFormatter(Hashtable formatterTypes, Type formatterType, HttpClientMethod method) {
            if (formatterType == null) return;
            ArrayList list = (ArrayList)formatterTypes[formatterType];
            if (list == null) {
                list = new ArrayList();
                formatterTypes.Add(formatterType, list);
            }
            list.Add(method);
        }

        internal HttpClientMethod GetMethod(string name) {
            return (HttpClientMethod)methods[name];
        }
    }

    /// <include file='doc\HttpClientProtocol.uex' path='docs/doc[@for="HttpSimpleClientProtocol"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       most of the implementation for communicating with an HTTP web service over HTTP.
    ///    </para>
    /// </devdoc>
    public abstract class HttpSimpleClientProtocol : HttpWebClientProtocol {
        HttpClientType clientType;

        /// <include file='doc\HttpClientProtocol.uex' path='docs/doc[@for="HttpSimpleClientProtocol.HttpSimpleClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Services.Protocols.HttpSimpleClientProtocol'/> class.
        ///    </para>
        /// </devdoc>
        protected HttpSimpleClientProtocol()
            : base() {
            Type type = this.GetType();
            clientType = (HttpClientType)GetFromCache(type);
            if (clientType == null) {
                lock(type){
                    clientType = (HttpClientType)GetFromCache(type);
                    if (clientType == null) {
                        clientType = new HttpClientType(type);
                        AddToCache(type, clientType);
                    }
                }
            }
        }

        /// <include file='doc\HttpClientProtocol.uex' path='docs/doc[@for="HttpSimpleClientProtocol.Invoke"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invokes a method of a HTTP web service.
        ///    </para>
        /// </devdoc>
        protected object Invoke(string methodName, string requestUrl, object[] parameters) {
            WebResponse response = null;
            HttpClientMethod method = GetClientMethod(methodName);
            MimeParameterWriter paramWriter = GetParameterWriter(method);                
            Uri requestUri = new Uri(requestUrl);
            if (paramWriter != null) {
                paramWriter.RequestEncoding = RequestEncoding;
                requestUrl = paramWriter.GetRequestUrl(requestUri.AbsoluteUri, parameters);
                requestUri = new Uri(requestUrl, true);
            }
            WebRequest request = null;
            try {
                request = GetWebRequest(requestUri);
                PendingSyncRequest = request;
                if (paramWriter != null) {
                    paramWriter.InitializeRequest(request, parameters);      
                    // CONSIDER,yannc: in future versions when we allow pluggable protocols
                    //      we may want to let them write in the request stream even
                    //      if there are no parameters.
                    if (paramWriter.UsesWriteRequest) {                        
                        if (parameters.Length == 0)
                            request.ContentLength = 0;
                        else {
                            Stream requestStream = null;
                            try {
                                requestStream = request.GetRequestStream();
                                paramWriter.WriteRequest(requestStream, parameters);
                            }
                            finally {
                                if (requestStream != null) requestStream.Close();
                            }                            
                        }
                    }
                }
                response = GetWebResponse(request);            
                Stream responseStream = null;
                if (response.ContentLength != 0)
                    responseStream = response.GetResponseStream();

                return ReadResponse(method, response, responseStream);
            }
            finally {
                if (request == PendingSyncRequest)
                    PendingSyncRequest = null;
            }
        }


        /// <include file='doc\HttpClientProtocol.uex' path='docs/doc[@for="HttpSimpleClientProtocol.BeginInvoke"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts an asynchronous invocation of a method of a HTTP web service.
        ///    </para>
        /// </devdoc>
        protected IAsyncResult BeginInvoke(string methodName, string requestUrl, object[] parameters, AsyncCallback callback, object asyncState) {
            HttpClientMethod method = GetClientMethod(methodName);
            MimeParameterWriter paramWriter = GetParameterWriter(method);
            Uri requestUri = new Uri(requestUrl);            
            if (paramWriter != null) {
                paramWriter.RequestEncoding = RequestEncoding;
                requestUrl = paramWriter.GetRequestUrl(requestUri.AbsoluteUri, parameters);
                requestUri = new Uri(requestUrl, true);
            }
            InvokeAsyncState invokeState = new InvokeAsyncState(method, paramWriter, parameters);            
            return BeginSend(requestUri, invokeState, callback, asyncState, paramWriter.UsesWriteRequest);
        }


        /// <include file='doc\HttpClientProtocol.uex' path='docs/doc[@for="HttpSimpleClientProtocol.InitializeAsyncRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal override void InitializeAsyncRequest(WebRequest request, object internalAsyncState) {
            InvokeAsyncState invokeState = (InvokeAsyncState)internalAsyncState;
            if (invokeState.ParamWriter.UsesWriteRequest && invokeState.Parameters.Length == 0) 
                request.ContentLength = 0;
        }

        internal override void AsyncBufferedSerialize(WebRequest request, Stream requestStream, object internalAsyncState) {
            InvokeAsyncState invokeState = (InvokeAsyncState)internalAsyncState;
            if (invokeState.ParamWriter != null) {
                invokeState.ParamWriter.InitializeRequest(request, invokeState.Parameters);
                if (invokeState.ParamWriter.UsesWriteRequest && invokeState.Parameters.Length > 0)
                    invokeState.ParamWriter.WriteRequest(requestStream, invokeState.Parameters);                        
            }
        }

        class InvokeAsyncState {            
            internal object[] Parameters;
            internal MimeParameterWriter ParamWriter;
            internal HttpClientMethod Method;            
            internal MemoryStream MemoryStream;

            internal InvokeAsyncState(HttpClientMethod method, MimeParameterWriter paramWriter, object[] parameters) {
                this.Method = method;
                this.ParamWriter = paramWriter;
                this.Parameters = parameters;
            }
        }

        /// <include file='doc\HttpClientProtocol.uex' path='docs/doc[@for="HttpSimpleClientProtocol.EndInvoke"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Ends an asynchronous invocation of a method of a HTTP web service.
        ///    </para>
        /// </devdoc>
        protected object EndInvoke(IAsyncResult asyncResult) {            
            object o = null;
            Stream responseStream = null;
            WebResponse response;
            response = EndSend(asyncResult, ref o, ref responseStream);
            InvokeAsyncState invokeState = (InvokeAsyncState) o;
            return ReadResponse(invokeState.Method, response, responseStream);
        }

        MimeParameterWriter GetParameterWriter(HttpClientMethod method) {
            if (method.writerType == null)
                return null;
            return (MimeParameterWriter)MimeFormatter.CreateInstance(method.writerType, method.writerInitializer);                
        }

        HttpClientMethod GetClientMethod(string methodName) {
            HttpClientMethod method = clientType.GetMethod(methodName);
            if (method == null) throw new ArgumentException(Res.GetString(Res.WebInvalidMethodName, methodName), "methodName");
            return method;
        }

        object ReadResponse(HttpClientMethod method, WebResponse response, Stream responseStream) {
            HttpWebResponse httpResponse = response as HttpWebResponse;
            if (httpResponse != null && (int)httpResponse.StatusCode >= 300)
                throw new WebException(RequestResponseUtils.CreateResponseExceptionString(httpResponse, responseStream), null, 
                    WebExceptionStatus.ProtocolError, httpResponse);

            if (method.readerType == null)
                return null;

            // CONSIDER,yannc: in future versions when we allow additional mime formatters we
            //      : should consider giving them access to the response even if there is no
            //      : response content.
            if (responseStream != null) {
                MimeReturnReader reader = (MimeReturnReader)MimeFormatter.CreateInstance(method.readerType, method.readerInitializer);
                return reader.Read(response, responseStream);                
            }
            else
                return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httppostlocalhostserverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpPostServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System.Net;

    internal class HttpPostLocalhostServerProtocolFactory : ServerProtocolFactory {
        protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request){
            if (request.PathInfo.Length < 2)
                return null;
            if (request.HttpMethod != "POST")
                return null;
            string localAddr = request.ServerVariables["LOCAL_ADDR"];
            string remoteAddr = request.ServerVariables["REMOTE_ADDR"];
            bool isLocal = request.Url.IsLoopback || (localAddr != null && remoteAddr != null && localAddr == remoteAddr);
            if (!isLocal)
                return null;

            return new HttpPostServerProtocol();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httpmethodattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpMethodAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;

    /// <include file='doc\HttpMethodAttribute.uex' path='docs/doc[@for="HttpMethodAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class HttpMethodAttribute : System.Attribute {
        Type returnFormatter;
        Type parameterFormatter;
        
        /// <include file='doc\HttpMethodAttribute.uex' path='docs/doc[@for="HttpMethodAttribute.HttpMethodAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpMethodAttribute() {
            returnFormatter = null;
            parameterFormatter = null;
        }

        /// <include file='doc\HttpMethodAttribute.uex' path='docs/doc[@for="HttpMethodAttribute.HttpMethodAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpMethodAttribute(Type returnFormatter, Type parameterFormatter) {
            this.returnFormatter = returnFormatter;
            this.parameterFormatter = parameterFormatter;
        }
        
        /// <include file='doc\HttpMethodAttribute.uex' path='docs/doc[@for="HttpMethodAttribute.ReturnFormatter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type ReturnFormatter {
            get { return returnFormatter; }
            set { returnFormatter = value; }
        }

        /// <include file='doc\HttpMethodAttribute.uex' path='docs/doc[@for="HttpMethodAttribute.ParameterFormatter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type ParameterFormatter {
            get { return parameterFormatter; }
            set { parameterFormatter = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httppostclientprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpPostClientProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Net;
    using System.IO;

    /// <include file='doc\HttpPostClientProtocol.uex' path='docs/doc[@for="HttpPostClientProtocol"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class HttpPostClientProtocol : HttpSimpleClientProtocol {
        /// <include file='doc\HttpPostClientProtocol.uex' path='docs/doc[@for="HttpPostClientProtocol.HttpPostClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpPostClientProtocol() 
            : base() {
        }

        /// <include file='doc\HttpPostClientProtocol.uex' path='docs/doc[@for="HttpPostClientProtocol.GetWebRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override WebRequest GetWebRequest(Uri uri) {
            WebRequest request = base.GetWebRequest(uri);
            request.Method = "POST";
            return request;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httppostserverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpPostServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    internal class HttpPostServerProtocolFactory : ServerProtocolFactory {
        protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request){
            if (request.PathInfo.Length < 2)
                return null;
            if (request.HttpMethod != "POST")
                return null;

            return new HttpPostServerProtocol();
        }
    }

    internal class HttpPostServerProtocol : HttpServerProtocol {
        internal HttpPostServerProtocol() : base(true) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\matchattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MatchAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MatchAttribute.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Protocols {
    using System;
    using System.Security.Permissions;

    /// <include file='doc\MatchAttribute.uex' path='docs/doc[@for="MatchAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class MatchAttribute : System.Attribute {
        string pattern;
        int group = 1;
        int capture = 0;
        bool ignoreCase = false;
        int repeats = -1;

        /// <include file='doc\MatchAttribute.uex' path='docs/doc[@for="MatchAttribute.MatchAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MatchAttribute(string pattern) {
            this.pattern = pattern;
        }

        /// <include file='doc\MatchAttribute.uex' path='docs/doc[@for="MatchAttribute.Pattern"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Pattern {
            get { return pattern == null ? string.Empty : pattern; }
            set { pattern = value; }
        }
        
        /// <include file='doc\MatchAttribute.uex' path='docs/doc[@for="MatchAttribute.Group"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Group {
            get { return group; }
            set { group = value; }
        }

        /// <include file='doc\MatchAttribute.uex' path='docs/doc[@for="MatchAttribute.Capture"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Capture {
            get { return capture; }
            set { capture = value; }
        }

        /// <include file='doc\MatchAttribute.uex' path='docs/doc[@for="MatchAttribute.IgnoreCase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IgnoreCase {
            get { return ignoreCase; }
            set { ignoreCase = value; }
        }

        /// <include file='doc\MatchAttribute.uex' path='docs/doc[@for="MatchAttribute.MaxRepeats"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int MaxRepeats {
            get { return repeats; }
            set { repeats = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\logicalmethodinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalMethodInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System;
    using System.Web.Services;
    using System.Reflection;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodTypes"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum LogicalMethodTypes {
        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodTypes.Sync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Sync = 0x1,
        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodTypes.Async"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Async = 0x2,
    }


    /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class LogicalMethodInfo {
        MethodInfo methodInfo;
        MethodInfo endMethodInfo;
        ParameterInfo[] inParams;
        ParameterInfo[] outParams;
        ParameterInfo[] parameters;
        Hashtable attributes;
        Type retType;
        ParameterInfo callbackParam;
        ParameterInfo stateParam;
        ParameterInfo resultParam;
        string methodName;
        bool isVoid;
        static object[] emptyObjectArray = new object[0];

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.LogicalMethodInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public LogicalMethodInfo(MethodInfo methodInfo) {
            if (methodInfo.IsStatic) throw new InvalidOperationException(Res.GetString(Res.WebMethodStatic, methodInfo.Name));
            this.methodInfo = methodInfo;
            parameters = methodInfo.GetParameters();
            inParams = GetInParameters(methodInfo, parameters, 0, parameters.Length, false);
            outParams = GetOutParameters(methodInfo, parameters, 0, parameters.Length, false);
            retType = methodInfo.ReturnType;
            isVoid = retType == typeof(void);
            methodName = methodInfo.Name;
            attributes = new Hashtable();
        }

        LogicalMethodInfo(MethodInfo beginMethodInfo, MethodInfo endMethodInfo) {
            this.methodInfo = beginMethodInfo;
            this.endMethodInfo = endMethodInfo;
            methodName = beginMethodInfo.Name.Substring(5);

            ParameterInfo[] beginParamInfos = beginMethodInfo.GetParameters();
            if (beginParamInfos.Length < 2 ||
                beginParamInfos[beginParamInfos.Length - 1].ParameterType != typeof(object) ||
                beginParamInfos[beginParamInfos.Length - 2].ParameterType != typeof(AsyncCallback)) {
                throw new InvalidOperationException(Res.GetString(Res.WebMethodMissingParams, beginMethodInfo.DeclaringType.FullName, beginMethodInfo.Name, 
                        typeof(AsyncCallback).FullName, typeof(object).FullName));
            }

            stateParam = beginParamInfos[beginParamInfos.Length - 1];
            callbackParam = beginParamInfos[beginParamInfos.Length - 2];

            inParams = GetInParameters(beginMethodInfo, beginParamInfos, 0, beginParamInfos.Length - 2, true);

            ParameterInfo[] endParamInfos = endMethodInfo.GetParameters();
            resultParam = endParamInfos[0];
            outParams = GetOutParameters(endMethodInfo, endParamInfos, 1, endParamInfos.Length - 1, true);

            parameters = new ParameterInfo[inParams.Length + outParams.Length];
            inParams.CopyTo(parameters, 0);
            outParams.CopyTo(parameters, inParams.Length);

            retType = endMethodInfo.ReturnType;
            isVoid = retType == typeof(void);
            attributes = new Hashtable();
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            return methodInfo.ToString();
        }

        // This takes in parameters, and returns return value followed by out parameters in an array
        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.Invoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public object[] Invoke(object target, object[] values) {
            if (outParams.Length > 0) {
                object[] newValues = new object[parameters.Length];
                for (int i = 0; i < inParams.Length; i++) {
                    newValues[inParams[i].Position] = values[i];
                }
                values = newValues;
            }
            object returnValue = methodInfo.Invoke(target, values);
            if (outParams.Length > 0) {
                int count = outParams.Length;
                if (!isVoid) count++;
                object[] results = new object[count];
                count = 0;
                if (!isVoid) results[count++] = returnValue;
                for (int i = 0; i < outParams.Length; i++) {
                    results[count++] = values[outParams[i].Position];
                }
                return results;
            }
            else if (isVoid) {
                return emptyObjectArray;
            }
            else {
                return new object[] { returnValue };
            }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.BeginInvoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public IAsyncResult BeginInvoke(object target, object[] values, AsyncCallback callback, object asyncState) {
            object[] asyncValues = new object[values.Length + 2];
            values.CopyTo(asyncValues, 0);
            asyncValues[values.Length] = callback;
            asyncValues[values.Length + 1] = asyncState;
            return (IAsyncResult)methodInfo.Invoke(target, asyncValues);
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.EndInvoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public object[] EndInvoke(object target, IAsyncResult asyncResult) {
            object[] values = new object[outParams.Length + 1];
            values[0] = asyncResult;
            object returnValue = endMethodInfo.Invoke(target, values);
            if (!isVoid) {
                values[0] = returnValue;
                return values;
            }
            else if (outParams.Length > 0) {
                object[] newValues = new object[outParams.Length];
                Array.Copy(values, 1, newValues, 0, newValues.Length);
                return newValues;
            }
            else {
                return emptyObjectArray;
            }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.DeclaringType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type DeclaringType {
            get { return methodInfo.DeclaringType; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return methodName; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.AsyncResultParameter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParameterInfo AsyncResultParameter {
            get { return resultParam; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.AsyncCallbackParameter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParameterInfo AsyncCallbackParameter {
            get { return callbackParam; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.AsyncStateParameter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParameterInfo AsyncStateParameter {
            get { return stateParam; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.ReturnType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type ReturnType {
            get { return retType; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.IsVoid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsVoid {
            get { return isVoid; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.IsAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsAsync {
            get { return endMethodInfo != null; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.InParameters"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParameterInfo[] InParameters {
            get { return inParams; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.OutParameters"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParameterInfo[] OutParameters {
            get { return outParams; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.Parameters"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParameterInfo[] Parameters {
            get { return parameters; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.GetCustomAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object[] GetCustomAttributes(Type type) {
            object[] attrForType = null;
            attrForType = (object[])attributes[type];
            if (attrForType != null)
                return attrForType;
            lock (attributes){
                attrForType = (object[])attributes[type];
                if (attrForType == null){
                    attrForType =  methodInfo.GetCustomAttributes(type, false);
                    attributes[type] = attrForType;
                }
            }
            return attrForType;
        }


        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.GetCustomAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object GetCustomAttribute(Type type) {
            object[] attrs = GetCustomAttributes(type);
            if (attrs.Length == 0) return null;
            return attrs[0];
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.CustomAttributeProvider"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICustomAttributeProvider CustomAttributeProvider {
            // Custom attributes are always on the XXX (sync) or BeginXXX (async) method.
            get { return methodInfo; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.ReturnTypeCustomAttributeProvider"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICustomAttributeProvider ReturnTypeCustomAttributeProvider {
            get { return methodInfo.ReturnTypeCustomAttributes; }
        }

        // Do not use this to property get custom attributes.  Instead use the CustomAttributeProvider 
        // property which automatically handles where the custom attributes belong for async methods
        // (which are actually two methods: BeginXXX and EndXXX).
        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.MethodInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MethodInfo MethodInfo {
            get { return endMethodInfo == null ? methodInfo : null; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.BeginMethodInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MethodInfo BeginMethodInfo {
            get { return methodInfo; }
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.EndMethodInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MethodInfo EndMethodInfo {
            get { return endMethodInfo; }
        }

        static ParameterInfo[] GetInParameters(MethodInfo methodInfo, ParameterInfo[] paramInfos, int start, int length, bool mustBeIn) {
            int count = 0;
            for (int i = 0; i < length; i++) {
                ParameterInfo paramInfo = paramInfos[i + start];
                if (IsInParameter(paramInfo)) {
                    count++;
                }
                else if (mustBeIn) {
                    throw new InvalidOperationException(Res.GetString(Res.WebBadOutParameter, paramInfo.Name, methodInfo.DeclaringType.FullName,  paramInfo.Name));
                }
            }

            ParameterInfo[] ins = new ParameterInfo[count];
            count = 0;
            for (int i = 0; i < length; i++) {
                ParameterInfo paramInfo = paramInfos[i + start];
                if (IsInParameter(paramInfo)) {
                    ins[count++] = paramInfo;
                }
            }
            return ins;
        }

        static ParameterInfo[] GetOutParameters(MethodInfo methodInfo, ParameterInfo[] paramInfos, int start, int length, bool mustBeOut) {
            int count = 0;
            for (int i = 0; i < length; i++) {
                ParameterInfo paramInfo = paramInfos[i + start];
                if (IsOutParameter(paramInfo)) {
                    count++;
                }
                else if (mustBeOut) {
                    throw new InvalidOperationException(Res.GetString(Res.WebInOutParameter, paramInfo.Name, methodInfo.DeclaringType.FullName,  paramInfo.Name));
                }
            }

            ParameterInfo[] outs = new ParameterInfo[count];
            count = 0;
            for (int i = 0; i < length; i++) {
                ParameterInfo paramInfo = paramInfos[i + start];
                if (IsOutParameter(paramInfo)) {
                    outs[count++] = paramInfo;
                }
            }
            return outs;
        }

        static bool IsInParameter(ParameterInfo paramInfo) {
            return !paramInfo.IsOut;
        }

        static bool IsOutParameter(ParameterInfo paramInfo) {
            return paramInfo.IsOut || paramInfo.ParameterType.IsByRef;
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.IsBeginMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool IsBeginMethod(MethodInfo methodInfo) {
            return typeof(IAsyncResult).IsAssignableFrom(methodInfo.ReturnType) &&
                methodInfo.Name.StartsWith("Begin");
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.IsEndMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool IsEndMethod(MethodInfo methodInfo) {
            ParameterInfo[] paramInfos = methodInfo.GetParameters();
            return paramInfos.Length > 0 && 
                typeof(IAsyncResult).IsAssignableFrom(paramInfos[0].ParameterType) &&
                methodInfo.Name.StartsWith("End");
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static LogicalMethodInfo[] Create(MethodInfo[] methodInfos) {
            return Create(methodInfos, LogicalMethodTypes.Async | LogicalMethodTypes.Sync);
        }

        /// <include file='doc\LogicalMethodInfo.uex' path='docs/doc[@for="LogicalMethodInfo.Create1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static LogicalMethodInfo[] Create(MethodInfo[] methodInfos, LogicalMethodTypes types) {
            ArrayList begins = (types & LogicalMethodTypes.Async) != 0 ? new ArrayList() : null;
            Hashtable ends = (types & LogicalMethodTypes.Async) != 0 ? new Hashtable() : null;
            ArrayList syncs = (types & LogicalMethodTypes.Sync) != 0 ? new ArrayList() : null;

            for (int i = 0; i < methodInfos.Length; i++) {
                MethodInfo methodInfo = methodInfos[i];
                if (IsBeginMethod(methodInfo)) {
                    if (begins != null) begins.Add(methodInfo);
                }
                else if (IsEndMethod(methodInfo)) {
                    if (ends != null) ends.Add(methodInfo.Name, methodInfo);
                }
                else {
                    if (syncs != null) syncs.Add(methodInfo);
                }
            }

            int beginsCount = begins == null ? 0 : begins.Count;
            int syncsCount = syncs == null ? 0 : syncs.Count;
            int count = syncsCount + beginsCount;
            LogicalMethodInfo[] methods = new LogicalMethodInfo[count];
            count = 0;
            for (int i = 0; i < syncsCount; i++) {
                methods[count++] = new LogicalMethodInfo((MethodInfo)syncs[i]);
            }
            for (int i = 0; i < beginsCount; i++) {
                MethodInfo beginMethodInfo = (MethodInfo)begins[i];
                string endName = "End" + beginMethodInfo.Name.Substring(5);
                MethodInfo endMethodInfo = (MethodInfo)ends[endName];
                if (endMethodInfo == null) {
                    throw new InvalidOperationException(Res.GetString(Res.WebAsyncMissingEnd, beginMethodInfo.DeclaringType.FullName, beginMethodInfo.Name, endName));
                }
                methods[count++] = new LogicalMethodInfo(beginMethodInfo, endMethodInfo);
            }

            return methods;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\mimereturnreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeReturnReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Net;

    /// <include file='doc\MimeReturnReader.uex' path='docs/doc[@for="MimeReturnReader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class MimeReturnReader : MimeFormatter {
        /// <include file='doc\MimeReturnReader.uex' path='docs/doc[@for="MimeReturnReader.Read"]/*' />
        // It is the responsibility of the MimeReturnReader to call close on the responseStream.
        public abstract object Read(WebResponse response, Stream responseStream);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\mimereturnwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeReturnWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;

    internal abstract class MimeReturnWriter : MimeFormatter {
        internal abstract void Write(HttpResponse response, Stream outputStream, object returnValue);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\mimeformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Security.Permissions;

    /// <include file='doc\MimeFormatter.uex' path='docs/doc[@for="MimeFormatter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class MimeFormatter {
        /// <include file='doc\MimeFormatter.uex' path='docs/doc[@for="MimeFormatter.GetInitializer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract object GetInitializer(LogicalMethodInfo methodInfo);
        /// <include file='doc\MimeFormatter.uex' path='docs/doc[@for="MimeFormatter.Initialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void Initialize(object initializer);

        /// <include file='doc\MimeFormatter.uex' path='docs/doc[@for="MimeFormatter.GetInitializers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual object[] GetInitializers(LogicalMethodInfo[] methodInfos) {
            object[] initializers = new object[methodInfos.Length];
            for (int i = 0; i < initializers.Length; i++)
                initializers[i] = GetInitializer(methodInfos[i]);
            return initializers;
        }

        /// <include file='doc\MimeFormatter.uex' path='docs/doc[@for="MimeFormatter.GetInitializer1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public static object GetInitializer(Type type, LogicalMethodInfo methodInfo) {
            return ((MimeFormatter)Activator.CreateInstance(type)).GetInitializer(methodInfo);
        }

        /// <include file='doc\MimeFormatter.uex' path='docs/doc[@for="MimeFormatter.GetInitializers1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public static object[] GetInitializers(Type type, LogicalMethodInfo[] methodInfos) {
            return ((MimeFormatter)Activator.CreateInstance(type)).GetInitializers(methodInfos);
        }

        /// <include file='doc\MimeFormatter.uex' path='docs/doc[@for="MimeFormatter.CreateInstance"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public static MimeFormatter CreateInstance(Type type, object initializer) {
            MimeFormatter formatter = (MimeFormatter)Activator.CreateInstance(type);
            formatter.Initialize(initializer);
            return formatter;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\mimeparameterreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeParameterReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Security.Permissions;

    /// <include file='doc\MimeParameterReader.uex' path='docs/doc[@for="MimeParameterReader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class MimeParameterReader : MimeFormatter {
        /// <include file='doc\MimeParameterReader.uex' path='docs/doc[@for="MimeParameterReader.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract object[] Read(HttpRequest request);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\httpserverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Xml.Serialization;
    using System.Web.Services.Description;
    using System.Web.Services.Configuration;
    using System.Net;
    using System.Globalization;
    
    internal class HttpServerType : ServerType {
        Hashtable methods = new Hashtable();

        internal HttpServerType(Type type) : base(type) {
            Type[] returnWriterTypes = WebServicesConfiguration.Current.ReturnWriterTypes;
            Type[] parameterReaderTypes = WebServicesConfiguration.Current.ParameterReaderTypes;

            LogicalMethodInfo[] methodInfos = WebMethodReflector.GetMethods(type);
            HttpServerMethod[] methods = new HttpServerMethod[methodInfos.Length];

            object[] initializersByType = new object[returnWriterTypes.Length];
            for (int i = 0; i < initializersByType.Length; i++) {
                initializersByType[i] = MimeFormatter.GetInitializers(returnWriterTypes[i], methodInfos);
            }

            for (int i = 0; i < methodInfos.Length; i++) {
                LogicalMethodInfo methodInfo = methodInfos[i];
                HttpServerMethod method = null;
                if (methodInfo.ReturnType == typeof(void)) {
                    method = new HttpServerMethod();
                }
                else {
                    for (int j = 0; j < returnWriterTypes.Length; j++) {
                        object[] initializers = (object[])initializersByType[j];
                        if (initializers[i] != null) {
                            method = new HttpServerMethod();
                            method.writerInitializer = initializers[i];
                            method.writerType = returnWriterTypes[j];
                            break;
                        }
                    }
                }
                if (method != null) {
                    method.methodInfo = methodInfo;
                    methods[i] = method;
                }
            }

            initializersByType = new object[parameterReaderTypes.Length];
            for (int i = 0; i < initializersByType.Length; i++) {
                initializersByType[i] = MimeFormatter.GetInitializers(parameterReaderTypes[i], methodInfos);
            }

            for (int i = 0; i < methodInfos.Length; i++) {
                HttpServerMethod method = methods[i];
                if (method == null) continue;
                LogicalMethodInfo methodInfo = methodInfos[i];
                if (methodInfo.InParameters.Length > 0) {

                    int count = 0;
                    for (int j = 0; j < parameterReaderTypes.Length; j++) {
                        object[] initializers = (object[])initializersByType[j];
                        if (initializers[i] != null) {
                            count++;
                        }
                    }
                    if (count == 0) {
                        methods[i] = null;
                    }
                    else {
                        method.readerTypes = new Type[count];
                        method.readerInitializers = new object[count];
                        count = 0;
                        for (int j = 0; j < parameterReaderTypes.Length; j++) {
                            object[] initializers = (object[])initializersByType[j];
                            if (initializers[i] != null) {
                                method.readerTypes[count] = parameterReaderTypes[j];
                                method.readerInitializers[count] = initializers[i];
                                count++;
                            }
                        }
                    }
                }
            }

            for (int i = 0; i < methods.Length; i++) {
                HttpServerMethod method = methods[i];
                if (method != null) {
                    WebMethodAttribute methodAttribute = WebMethodReflector.GetAttribute(method.methodInfo);
                    method.name = methodAttribute.MessageName;
                    if (method.name.Length == 0) method.name = method.methodInfo.Name;
                    this.methods.Add(method.name, method);
                }
            }
        }

        internal HttpServerMethod GetMethod(string name) {
            return (HttpServerMethod)methods[name];
        }

        internal HttpServerMethod GetMethodIgnoreCase(string name) {
            foreach (DictionaryEntry entry in methods) {
                HttpServerMethod method = (HttpServerMethod)entry.Value;
                if (String.Compare(method.name, name, true, CultureInfo.InvariantCulture) == 0)
                    return method;
            }
            return null;
        }
    }

    internal class HttpServerMethod {
        internal string name;
        internal LogicalMethodInfo methodInfo;
        internal Type[] readerTypes;
        internal object[] readerInitializers;
        internal Type writerType;
        internal object writerInitializer;
    }

    internal abstract class HttpServerProtocol : ServerProtocol {
        HttpServerMethod serverMethod;
        HttpServerType serverType;
        bool hasInputPayload;

        protected HttpServerProtocol(bool hasInputPayload) { 
            this.hasInputPayload = hasInputPayload;
        }

        internal override bool Initialize() {
            // The derived class better check the verb!

            string methodName = Request.PathInfo.Substring(1);   // Skip leading '/'

            serverType = (HttpServerType)GetFromCache(typeof(HttpServerProtocol), Type);
            if (serverType == null) {
                lock(Type){
                    serverType = (HttpServerType)GetFromCache(typeof(HttpServerProtocol), Type);
                    if (serverType == null) {
                        serverType = new HttpServerType(Type);
                        AddToCache(typeof(HttpServerProtocol), Type, serverType);
                    }
                }
            }

            serverMethod = serverType.GetMethod(methodName);
            if (serverMethod == null) {
                serverMethod = serverType.GetMethodIgnoreCase(methodName);
                if (serverMethod != null) 
                    throw new ArgumentException(Res.GetString(Res.WebInvalidMethodNameCase, methodName, serverMethod.name), "methodName");
                else {
                    // it's possible that the method name came in as UTF-8 but was mangled by IIS so we try it
                    // again as UTF8...
                    string utf8MethodName = Encoding.UTF8.GetString(Encoding.Default.GetBytes(methodName));
                    serverMethod = serverType.GetMethod(utf8MethodName);
                    if (serverMethod == null)
                        throw new InvalidOperationException(Res.GetString(Res.WebInvalidMethodName, methodName));
                }
            }

            return true;
        }

        internal override bool IsOneWay {
            get { return false; }            
        }                                                                           
                                                                     
        internal override LogicalMethodInfo MethodInfo {
            get { return serverMethod.methodInfo; }
        }

        internal override ServerType ServerType {
            get { return serverType; }
        }
        
        internal override object[] ReadParameters() {
            if (serverMethod.readerTypes == null) return new object[0];
            for (int i = 0; i < serverMethod.readerTypes.Length; i++) {
                if (!hasInputPayload) {
                    // only allow URL parameters if doesn't have payload
                    if (serverMethod.readerTypes[i] != typeof(UrlParameterReader)) continue;
                }
                else {
                    // don't allow URL params if has payload
                    if (serverMethod.readerTypes[i] == typeof(UrlParameterReader)) continue;
                }
                MimeParameterReader reader = (MimeParameterReader)MimeFormatter.CreateInstance(serverMethod.readerTypes[i], 
                                                                                               serverMethod.readerInitializers[i]);
                
                object[] parameters = reader.Read(Request);
                if (parameters != null) return parameters;                                                                                    
            }
            if (!hasInputPayload)
                throw new InvalidOperationException(Res.GetString(Res.WebInvalidRequestFormat));
            else
                throw new InvalidOperationException(Res.GetString(Res.WebInvalidRequestFormatDetails, Request.ContentType));
        }

        internal override void WriteReturns(object[] returnValues, Stream outputStream) {
            if (serverMethod.writerType == null) return;            
            MimeReturnWriter writer = (MimeReturnWriter)MimeFormatter.CreateInstance(serverMethod.writerType,
                                                                                     serverMethod.writerInitializer);
            writer.Write(Response, outputStream, returnValues[0]);
        }

        internal override bool WriteException(Exception e, Stream outputStream) {            
            Response.Clear();
            Response.ClearHeaders();
            Response.ContentType = ContentType.Compose("text/plain", Encoding.UTF8);
            Response.StatusCode = (int) HttpStatusCode.InternalServerError;
            Response.StatusDescription = Res.GetString(Res.WebRequestErrorStatusDescription);                                             
            StreamWriter writer = new StreamWriter(outputStream, new UTF8Encoding(false));
            writer.WriteLine(GenerateFaultString(e, true));
            writer.Flush(); 
            return true;                           
        }

        internal static bool AreUrlParametersSupported(LogicalMethodInfo methodInfo) {
            if (methodInfo.OutParameters.Length > 0) return false;
            ParameterInfo[] parameters = methodInfo.InParameters;
            for (int i = 0; i < parameters.Length; i++) {
                ParameterInfo parameter = parameters[i];
                Type parameterType = parameter.ParameterType;
                if (parameterType.IsArray) {
                    if (!ScalarFormatter.IsTypeSupported(parameterType.GetElementType())) 
                        return false;
                }
                else {
                    if (!ScalarFormatter.IsTypeSupported(parameterType))
                        return false;
                }
            }
            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\nopreturnreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="NopReturnReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   NopReturnReader.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Net;

    /// <include file='doc\NopReturnReader.uex' path='docs/doc[@for="NopReturnReader"]/*' />
    public class NopReturnReader : MimeReturnReader {
        /// <include file='doc\NopReturnReader.uex' path='docs/doc[@for="NopReturnReader.GetInitializer"]/*' />
        public override object GetInitializer(LogicalMethodInfo methodInfo) {
            return this;
        }

        /// <include file='doc\NopReturnReader.uex' path='docs/doc[@for="NopReturnReader.Initialize"]/*' />
        public override void Initialize(object initializer) {
        }

        /// <include file='doc\NopReturnReader.uex' path='docs/doc[@for="NopReturnReader.Read"]/*' />
        public override object Read(WebResponse response, Stream responseStream) {
            response.Close();
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\mimeparameterwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeParameterWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Net;
    using System.Text;

    /// <include file='doc\MimeParameterWriter.uex' path='docs/doc[@for="MimeParameterWriter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class MimeParameterWriter : MimeFormatter {
        /// <include file='doc\MimeParameterWriter.uex' path='docs/doc[@for="MimeParameterWriter.UsesWriteRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool UsesWriteRequest { get { return false; } }

        /// <include file='doc\MimeParameterWriter.uex' path='docs/doc[@for="MimeParameterWriter.RequestEncoding"]/*' />
        public virtual Encoding RequestEncoding { 
            get { return null; }
            set { }
        }

        /// <include file='doc\MimeParameterWriter.uex' path='docs/doc[@for="MimeParameterWriter.GetRequestUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual string GetRequestUrl(string url, object[] parameters) {
            return url;
        }

        /// <include file='doc\MimeParameterWriter.uex' path='docs/doc[@for="MimeParameterWriter.InitializeRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void InitializeRequest(WebRequest request, object[] values) {
            return;
        }
    
        /// <include file='doc\MimeParameterWriter.uex' path='docs/doc[@for="MimeParameterWriter.WriteRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteRequest(Stream requestStream, object[] values) {
            return;            
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\patternmatcher.cs ===
//------------------------------------------------------------------------------
// <copyright file="PatternMatcher.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PatternMatcher.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Protocols {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Text.RegularExpressions;
    using System.Security.Permissions;

    /// <include file='doc\PatternMatcher.uex' path='docs/doc[@for="PatternMatcher"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class PatternMatcher {
        MatchType matchType;

        /// <include file='doc\PatternMatcher.uex' path='docs/doc[@for="PatternMatcher.PatternMatcher"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PatternMatcher(Type type) {
            matchType = MatchType.Reflect(type);
        }

        /// <include file='doc\PatternMatcher.uex' path='docs/doc[@for="PatternMatcher.Match"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Match(string text) {
            return matchType.Match(text);
        }
    }

    internal class MatchType {
        Type type;
        MatchField[] fields;

        internal Type Type {
            get { return type; }
        }

        internal static MatchType Reflect(Type type) {
            MatchType matchType = new MatchType();
            matchType.type = type;
            FieldInfo[] fieldInfos = type.GetFields();
            ArrayList list = new ArrayList();
            for (int i = 0; i < fieldInfos.Length; i++) {
                MatchField field = MatchField.Reflect(fieldInfos[i]);
                if (field != null) list.Add(field);
            }
            matchType.fields = (MatchField[])list.ToArray(typeof(MatchField));
            return matchType;
        }

        internal object Match(string text) {
            object target = Activator.CreateInstance(type);
            for (int i = 0; i < fields.Length; i++)
                fields[i].Match(target, text);
            return target;
        }
    }

    internal class MatchField {
        FieldInfo fieldInfo;
        Regex regex;
        int group;
        int capture;
        int maxRepeats;
        MatchType matchType;

        internal void Match(object target, string text) {
            fieldInfo.SetValue(target, matchType == null ? MatchString(text) : MatchClass(text));
        }

        object MatchString(string text) {
            Match m = regex.Match(text);
            if (fieldInfo.FieldType.IsArray) {
                ArrayList matches = new ArrayList();
                int matchCount = 0;
                while (m.Success && matchCount < maxRepeats) {
                    if (m.Groups.Count <= group) 
                        throw BadGroupIndexException(group, fieldInfo.Name, m.Groups.Count - 1);
                    Group g = m.Groups[group];
                    foreach (Capture c in g.Captures) {
                        matches.Add(text.Substring(c.Index, c.Length));
                    }
                    m = m.NextMatch();
                    matchCount++;
                }
                return matches.ToArray(typeof(string));
            }
            else {
                if (m.Success) {
                    if (m.Groups.Count <= group) 
                        throw BadGroupIndexException(group, fieldInfo.Name, m.Groups.Count - 1);
                    Group g = m.Groups[group];
                    if (g.Captures.Count > 0) {
                        if (g.Captures.Count <= capture) 
                            throw BadCaptureIndexException(capture, fieldInfo.Name, g.Captures.Count - 1);
                        Capture c = g.Captures[capture];
                        return text.Substring(c.Index, c.Length);
                    }
                }
                return null;
            }
        }

        object MatchClass(string text) {
            Match m = regex.Match(text);
            if (fieldInfo.FieldType.IsArray) {
                ArrayList matches = new ArrayList();
                int matchCount = 0;
                while (m.Success && matchCount < maxRepeats) {
                    if (m.Groups.Count <= group) 
                        throw BadGroupIndexException(group, fieldInfo.Name, m.Groups.Count - 1);
                    Group g = m.Groups[group];
                    foreach (Capture c in g.Captures) {
                        matches.Add(matchType.Match(text.Substring(c.Index, c.Length)));
                    }
                    m = m.NextMatch();
                    matchCount++;
                }
                return matches.ToArray(matchType.Type);
            }
            else {
                if (m.Success) {
                    if (m.Groups.Count <= group) 
                        throw BadGroupIndexException(group, fieldInfo.Name, m.Groups.Count - 1);
                    Group g = m.Groups[group];
                    if (g.Captures.Count > 0) {
                        if (g.Captures.Count <= capture) 
                            throw BadCaptureIndexException(capture, fieldInfo.Name, g.Captures.Count - 1);
                        Capture c = g.Captures[capture];
                        return matchType.Match(text.Substring(c.Index, c.Length));
                    }
                }
                return null;
            }
        }

        static Exception BadCaptureIndexException(int index, string matchName, int highestIndex) {
            return new Exception(Res.GetString(Res.WebTextMatchBadCaptureIndex, index, matchName, highestIndex));
        }

        static Exception BadGroupIndexException(int index, string matchName, int highestIndex) {
            return new Exception(Res.GetString(Res.WebTextMatchBadGroupIndex, index, matchName, highestIndex));
        }

        internal static MatchField Reflect(FieldInfo fieldInfo) {
            if (!fieldInfo.IsPublic) return null;
            object[] attrs = fieldInfo.GetCustomAttributes(typeof(MatchAttribute), false);
            if (attrs.Length == 0) return null;
            MatchAttribute attr = (MatchAttribute)attrs[0];
            MatchField field = new MatchField();
            field.regex = new Regex(attr.Pattern, RegexOptions.Singleline | (attr.IgnoreCase ? RegexOptions.IgnoreCase | RegexOptions.CultureInvariant: 0));
            field.group = attr.Group;
            field.capture = attr.Capture;
            field.maxRepeats = attr.MaxRepeats;
            field.fieldInfo = fieldInfo;
            Type fieldType = fieldInfo.FieldType;
            if (field.maxRepeats < 0) // unspecified
                field.maxRepeats = fieldType.IsArray ? int.MaxValue : 1;
            if (fieldType.IsArray) {
                fieldType = fieldType.GetElementType();
            }
            if (fieldType != typeof(string)) {
                field.matchType = MatchType.Reflect(fieldType);
            }
            return field;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\requestresponse.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequestResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System.IO;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Reflection;
    using System.Threading;
    using System.Web;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Net;

    internal class RequestResponseUtils {
        /*
        internal static string UTF8StreamToString(Stream stream) {
            long position = 0;
            if (stream.CanSeek)
                position = stream.Position;
            StreamReader reader = new StreamReader(stream, new System.Text.UTF8Encoding());
            string result = reader.ReadToEnd();
            if (stream.CanSeek)
                stream.Position = position;
            return result;
        }
        */

        // CONSIDER, alexdej: GetEncoding and GetEncoding2 should be merged at some point
        // since GetEncoding2 handles application/* correctly
        internal static Encoding GetEncoding(string contentType) {
            string charset = ContentType.GetCharset(contentType);
            Encoding e = null;
            try {
                if (charset != null && charset.Length > 0) 
                    e = Encoding.GetEncoding(charset);
            }
            catch (Exception) {
            }
            // default to ASCII encoding per RFC 2376/3023
            return e == null ? new ASCIIEncoding() : e;
        }

        internal static Encoding GetEncoding2(string contentType) {
            // default to old text/* behavior for non-application base
            if (!ContentType.MatchesBase(contentType, ContentType.ApplicationBase))
                return GetEncoding(contentType);

            string charset = ContentType.GetCharset(contentType);
            Encoding e = null;
            try {
                if (charset != null && charset.Length > 0) 
                    e = Encoding.GetEncoding(charset);
            }
            catch (Exception) {
            }
            // no default per application/* mime type
            return e;
        }

        internal static string ReadResponse(WebResponse response) {
            return ReadResponse(response, response.GetResponseStream());
        }

        internal static string ReadResponse(WebResponse response, Stream stream) {
            Encoding e = GetEncoding(response.ContentType);            
            if (e == null) e = Encoding.Default;
            StreamReader reader = new StreamReader(stream, e, true);
            try {
                return reader.ReadToEnd();
            }
            finally {
                stream.Close();
            }
        }
        
        // used to copy an unbuffered stream to a buffered stream.
        internal static Stream StreamToMemoryStream(Stream stream) {
            MemoryStream memoryStream = new MemoryStream(1024);
            byte[] buffer = new byte[1024];
            int count;
            while ((count = stream.Read(buffer, 0, buffer.Length)) != 0) {
                memoryStream.Write(buffer, 0, count);
            }
            memoryStream.Position = 0;
            return memoryStream;
        }
        
        internal static string CreateResponseExceptionString(WebResponse response) {
            return CreateResponseExceptionString(response, response.GetResponseStream());
        }

        internal static string CreateResponseExceptionString(WebResponse response, Stream stream) {
            if (response is HttpWebResponse) {
                HttpWebResponse httpResponse = (HttpWebResponse)response;
                int statusCode = (int)httpResponse.StatusCode;
                if (statusCode >= 400 && statusCode != 500)
                    return Res.GetString(Res.WebResponseKnownError, statusCode, httpResponse.StatusDescription);
            }
            
            // CONSIDER, yannc: verify that Content-Type is a text format.  
            string content = ReadResponse(response, stream);
            if (content.Length > 0) {
                StringBuilder sb = new StringBuilder();
                sb.Append(Res.GetString(Res.WebResponseUnknownError));
                sb.Append("\r\n--\r\n");
                sb.Append(content);
                sb.Append("\r\n--");
                sb.Append(".");
                return sb.ToString();
            }
            return String.Empty;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\remotedebugger.cs ===
//------------------------------------------------------------------------------
// <copyright file="RemoteDebugger.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   RemoteDebugger.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Protocols {
    using System;   
    using System.Web.Services;
    using System.Diagnostics;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Web.Services.Interop;
    using System.Reflection;
    using System.Threading;
    using System.Net;
    using System.ComponentModel; // for CompModSwitches

    internal class RemoteDebugger : INotifySource2 {
        private static INotifyConnection2 connection;
        private static bool getConnection = true;
        private INotifySink2 notifySink;
        private NotifyFilter notifyFilter;
        private UserThread userThread;

        private const int INPROC_SERVER = 1;
        private static Guid IID_NotifyConnectionClassGuid = new Guid("12A5B9F0-7A1C-4fcb-8163-160A30F519B5");
        private static Guid IID_NotifyConnection2Guid = new Guid("1AF04045-6659-4aaa-9F4B-2741AC56224B");
        private static string debuggerHeader = "VsDebuggerCausalityData";

        [DebuggerStepThrough]
        [DebuggerHidden]
        internal RemoteDebugger() {
        }

        ~RemoteDebugger() {
            Close();
        }

        internal static bool IsClientCallOutEnabled() {
            bool enabled = false;
            
            try {
                enabled = !CompModSwitches.DisableRemoteDebugging.Enabled && Debugger.IsAttached && Connection != null;
            }
            catch (Exception) {
            }
            return enabled;
        }

        internal static bool IsServerCallInEnabled(ServerProtocol protocol, out string stringBuffer) {
            stringBuffer = null;
            bool enabled = false;
            try {
                if (CompModSwitches.DisableRemoteDebugging.Enabled)
                    return false;

                enabled = protocol.Context.IsDebuggingEnabled && Connection != null;
                if (enabled) {
                    stringBuffer = protocol.Request.Headers[debuggerHeader];
                    enabled = (stringBuffer != null && stringBuffer.Length > 0);
                }
            }
            catch (Exception) {
                enabled = false;
            }
            return enabled;
        }

        private static INotifyConnection2 Connection {
            get {
                if (connection == null && getConnection) {
                    lock (typeof(RemoteDebugger)) {
                        if (connection == null)  {
                            AppDomain.CurrentDomain.DomainUnload += new EventHandler(OnAppDomainUnload);
                            AppDomain.CurrentDomain.ProcessExit += new EventHandler(OnProcessExit);
                            object unk;
                            int result =  UnsafeNativeMethods.CoCreateInstance(ref IID_NotifyConnectionClassGuid, 
                                                                               null, 
                                                                               INPROC_SERVER, 
                                                                               ref IID_NotifyConnection2Guid,
                                                                               out unk);
                            if (result >= 0) // success
                                connection = (INotifyConnection2)unk;
                            else
                                connection = null;
                        }
                        getConnection = false;
                    }
                }
                return connection;
            }
        }


        private INotifySink2 NotifySink {
            get {
                if (this.notifySink == null && Connection != null) {
                   this.notifySink = UnsafeNativeMethods.RegisterNotifySource(Connection, this);
                }
                return this.notifySink;
            }
        }

        internal static void CloseSharedResources() {
            if (connection != null) {
                lock (typeof(RemoteDebugger)) {
                    if (connection != null) {
                        try {
                            Marshal.ReleaseComObject(connection);
                        }
                        catch (Exception) {
                        }
                        connection = null;
                    }
                }
            }
        }

        internal void Close() {
            if (this.notifySink != null && connection != null) {
                lock (typeof(RemoteDebugger)) {
                    if (this.notifySink != null && connection != null) {
                        try {
                            UnsafeNativeMethods.UnregisterNotifySource(connection, this);
                        }
                        catch (Exception) {
                        }
                        this.notifySink = null;
                    }
                }
            }
        }

        [DebuggerStepThrough]
        [DebuggerHidden]
        internal void NotifyClientCallOut(WebRequest request) {
            try {
                if (NotifySink == null) return;

                IntPtr bufferPtr;
                int bufferSize = 0;
                CallId callId = new CallId(null, 0, (IntPtr)0, 0, null, request.RequestUri.Host);

                UnsafeNativeMethods.OnSyncCallOut(NotifySink, callId, out bufferPtr, ref bufferSize);
                if (bufferPtr == IntPtr.Zero) return;
                byte[] buffer = null;
                try {
                    buffer = new byte[bufferSize];
                    Marshal.Copy(bufferPtr, buffer, 0, bufferSize);
                }
                finally {
                    Marshal.FreeCoTaskMem(bufferPtr);
                }
                string bufferString = Convert.ToBase64String(buffer);
                request.Headers.Add(debuggerHeader, bufferString);
            }
            catch (Exception) {
            }
        }

        [DebuggerStepThrough]
        [DebuggerHidden]
        internal void NotifyClientCallReturn(WebResponse response) {
            try {
                if (NotifySink == null) return;

                byte[] buffer = new byte[0];
                if (response != null) {
                    string bufferString = response.Headers[debuggerHeader];
                    if (bufferString != null && bufferString.Length != 0)
                        buffer = Convert.FromBase64String(bufferString);
                }

                CallId callId = new CallId(null, 0, (IntPtr)0, 0, null, null);
                UnsafeNativeMethods.OnSyncCallReturn(NotifySink, callId, buffer, buffer.Length);
            }
            catch (Exception) {
            }

            this.Close();
        }

        [DebuggerStepThrough]
        [DebuggerHidden]
        internal void NotifyServerCallEnter(ServerProtocol protocol, string stringBuffer) {
            try {
                if (NotifySink == null) return;
                StringBuilder methodBuilder = new StringBuilder();
                methodBuilder.Append(protocol.Type.FullName);
                methodBuilder.Append('.');
                methodBuilder.Append(protocol.MethodInfo.Name);
                methodBuilder.Append('(');
                ParameterInfo[] parameterInfos = protocol.MethodInfo.Parameters;
                for (int i = 0; i < parameterInfos.Length; ++ i) {
                    if (i != 0)
                        methodBuilder.Append(',');

                    methodBuilder.Append(parameterInfos[i].ParameterType.FullName);
                }
                methodBuilder.Append(')');

                byte[] buffer = Convert.FromBase64String(stringBuffer);
                CallId callId = new CallId(null, 0, (IntPtr)0, 0, methodBuilder.ToString(), null);
                UnsafeNativeMethods.OnSyncCallEnter(NotifySink, callId, buffer, buffer.Length);
            }
            catch (Exception) {
            }
        }

        [DebuggerStepThrough]
        [DebuggerHidden]
        internal void NotifyServerCallExit(HttpResponse response) {
            try {
                if (NotifySink == null) return;

                IntPtr bufferPtr;
                int bufferSize = 0;
                CallId callId = new CallId(null, 0, (IntPtr)0, 0, null, null);
                UnsafeNativeMethods.OnSyncCallExit(NotifySink, callId, out bufferPtr, ref bufferSize);
                if (bufferPtr == IntPtr.Zero) return;
                byte[] buffer = null;
                try {
                    buffer = new byte[bufferSize];
                    Marshal.Copy(bufferPtr, buffer, 0, bufferSize);
                }
                finally {
                    Marshal.FreeCoTaskMem(bufferPtr);
                }
                string stringBuffer = Convert.ToBase64String(buffer);
                response.AddHeader(debuggerHeader, stringBuffer);
            }
            catch (Exception) {
            }
            
            this.Close();
        }


        private static void OnAppDomainUnload(object sender, EventArgs args) {
            CloseSharedResources();
        }

        private static void OnProcessExit(object sender, EventArgs args) {
            CloseSharedResources();
        }

        void INotifySource2.SetNotifyFilter(NotifyFilter in_NotifyFilter, UserThread in_pUserThreadFilter) {
            notifyFilter = in_NotifyFilter;
            userThread = in_pUserThreadFilter;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\scattergatherstream.cs ===
#if false //deadcode

//------------------------------------------------------------------------------
// <copyright file="ScatterGatherStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.IO;
    using System.Diagnostics;

    internal class ScatterGatherStream : Stream {
        private const int MemStreamMaxLength = Int32.MaxValue;        

        private MemoryChunk headChunk = null;
        private MemoryChunk currentChunk = null;  

        private long chunkSize = 0;
        private int currentOffset = 0;
        private int endOffset = 0;
        private long currentChunkStartPos = 0;

        internal ScatterGatherStream(int chunkSize) {
            this.chunkSize = chunkSize;
            currentChunk = headChunk = AllocateMemoryChunk(this.chunkSize);
            currentOffset = endOffset = 0;
            currentChunkStartPos = 0;
        }

        internal ScatterGatherStream() : this(1024) { }

        public override bool CanRead { get { return true; } }
        public override bool CanSeek { get { return true; } }
        public override bool CanWrite { get { return true; } }
        
        public override void Close() {            
            headChunk = null;
            currentChunk = null;
            endOffset = currentOffset = 0;
            currentChunkStartPos = 0;
        }

        public override void Flush() { }

        public override long Length { 
            get {
                MemoryChunk endChunk;
                return GetLengthInternal(out endChunk);
            }
        }

        private long GetLengthInternal(out MemoryChunk endChunk){
            long length = currentChunkStartPos;
            MemoryChunk chunk = currentChunk;
            while (chunk.Next != null) {
                length += chunk.Buffer.Length;
                chunk = chunk.Next;
            }
            length += endOffset;
            endChunk = chunk;
            return length;
        }

        public override long Position {
            get {
                return Seek(0, SeekOrigin.Current);
            }
             
            set {
                Seek(value, SeekOrigin.Begin);
            }
        }

        
        public override long Seek(long offset, SeekOrigin loc) {
            MemoryChunk chunk  = null;;
            long relativeOffset = 0;
            long absoluteOffset = 0;
            
            if(loc == SeekOrigin.Begin){
                absoluteOffset = offset;
                if(offset >= currentChunkStartPos){
                    chunk = currentChunk;
                    relativeOffset = offset - currentChunkStartPos;
                }
                else{
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else if( loc == SeekOrigin.Current){
                absoluteOffset = offset + currentOffset + currentChunkStartPos;
                if( (offset + currentOffset) > 0){
                    chunk = currentChunk;
                    relativeOffset = offset + currentOffset;
                }
                else {
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else if (loc == SeekOrigin.End){
                MemoryChunk endChunk;
                long length = GetLengthInternal(out endChunk);
                absoluteOffset = offset + length;
                if ( (offset + endOffset) > 0 ) {
                    relativeOffset = offset + endOffset;
                    chunk = endChunk;
                }
                else if(absoluteOffset >= currentChunkStartPos){
                    chunk = currentChunk;
                    relativeOffset = absoluteOffset - currentChunkStartPos;
                }
                else {
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else
                throw new ArgumentOutOfRangeException("loc");

            if (relativeOffset < 0 || relativeOffset > MemStreamMaxLength)
                throw new ArgumentOutOfRangeException("offset");
            long remaining = relativeOffset;
            while (chunk.Next != null) {
                if (remaining < chunk.Buffer.Length){
                    currentChunk = chunk;
                    currentOffset = (int)remaining;
                    currentChunkStartPos = absoluteOffset - currentOffset;
                    remaining = -1;
                    break;
                }
                remaining -= chunk.Buffer.Length;
                chunk = chunk.Next;
            }

            if (remaining >= 0){
                if (remaining <= chunk.Buffer.Length)
                    currentChunk = chunk;
                else {
                    currentChunk = chunk.Next = AllocateMemoryChunk(2*remaining);
                    endOffset = 0;
                }
                currentOffset = (int)remaining;
                currentChunkStartPos = absoluteOffset - currentOffset;
                SyncEndOffset();                
            }

            return absoluteOffset;
        }
        
        public override void SetLength(long absNewLen) {
            if (absNewLen < 0 || absNewLen > MemStreamMaxLength)
                throw new ArgumentOutOfRangeException("offset");

            MemoryChunk chunk;
            bool currentPastEnd;
            long relNewLen;
            if(absNewLen >= currentChunkStartPos){
                currentPastEnd = false;
                chunk = currentChunk;
                relNewLen = absNewLen - currentChunkStartPos;
            }
            else {
                currentPastEnd = true;
                chunk = headChunk;
                relNewLen = absNewLen;
            }
            long startPos = 0;
            MemoryChunk endChunk = null;
            while (chunk != null) {
                long endPos = startPos + chunk.Buffer.Length;
                if(endPos > relNewLen){
                    chunk.Next = null;
                    endOffset = (int)(relNewLen - startPos);
                    if(chunk == currentChunk)
                        currentOffset = min(currentOffset, endOffset);
                    else if(currentPastEnd){
                        currentChunk = chunk;
                        currentOffset = endOffset;
                        currentChunkStartPos = absNewLen - currentOffset;
                    }
                    return;
                }
                startPos = endPos;
                endChunk = chunk;
                chunk = chunk.Next;
            }
            //assert(endChunk != null)
            endChunk.Next = AllocateMemoryChunk((int)(absNewLen - startPos));
            endOffset = (int)(absNewLen - startPos);
        }
        
        
        
        public override int Read(byte[] buffer, int offset, int count) {
            byte[] chunkBuffer = currentChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
            if (currentChunk.Next == null)
                chunkSize = endOffset;

            int bytesRead = 0;
        
            while (count > 0) {
                if (currentOffset == chunkSize) {
                    // exit if no more chunks are currently available
                    if (currentChunk.Next == null)
                        break;

                    currentChunkStartPos += currentChunk.Buffer.Length;
                    currentChunk = currentChunk.Next;
                    currentOffset = 0;
                    chunkBuffer = currentChunk.Buffer;
                    chunkSize = chunkBuffer.Length;
                    if (currentChunk.Next == null)
                        chunkSize = endOffset;
                }

                int readCount = min(count, chunkSize - currentOffset);
                Buffer.BlockCopy(chunkBuffer, currentOffset, buffer, offset, readCount);
                offset += readCount;
                count -= readCount;
                currentOffset += readCount;
                bytesRead += readCount;
            }

            return bytesRead;
        }

        byte[] oneByteBuffer = new byte[1];
        public override int ReadByte(){
            if(Read(oneByteBuffer, 0, 1) == 1)
                return oneByteBuffer[0];
            return -1;
        }
                
        public override void Write(byte[] buffer, int offset, int count) {
            byte[] chunkBuffer = currentChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
    
            while (count > 0) {
                if (currentOffset == chunkSize) {
                    // allocate a new chunk if the current one is full
                    if(currentChunk.Next == null){
                        currentChunk.Next = AllocateMemoryChunk(count);
                        endOffset = 0;
                    }
                    currentChunkStartPos += currentChunk.Buffer.Length;
                    currentChunk = currentChunk.Next;
                    currentOffset = 0;
                        
                    chunkBuffer = currentChunk.Buffer;
                    chunkSize = chunkBuffer.Length;
                }
                             
                int copyCount = min(count, chunkSize - endOffset);
                Buffer.BlockCopy(buffer, offset, chunkBuffer, endOffset, copyCount);
                offset += copyCount;
                count -= copyCount;
                currentOffset += copyCount;
                SyncEndOffset();
            }            
        }

        public override void WriteByte(byte value) {
            oneByteBuffer[0] = value;
            Write(oneByteBuffer, 0, 1);
        }

        internal bool GetNextBuffer(out byte[] buffer, out int byteOffset, out int byteCount) {
            buffer = null;
            byteOffset = 0;
            byteCount = 0;
            if (currentChunk == null || headChunk == null || (currentChunk.Next == null && currentOffset == endOffset))
                return false;

            buffer = currentChunk.Buffer;
            if (currentChunk.Next == null) {
                byteCount = endOffset;
                currentOffset = endOffset;
            }
            else {
                currentChunkStartPos += currentChunk.Buffer.Length;
                currentChunk = currentChunk.Next;
                byteCount = buffer.Length;
                currentOffset = 0;
            }
            return true;
        }

        // copy entire buffer into an array
        internal virtual byte[] ToArray() {
            int length = (int)Length; // this will throw if stream is closed
            byte[] copy = new byte[length];

            MemoryChunk backupReadChunk = currentChunk;
            int backupReadOffset = currentOffset;

            currentChunk = headChunk;
            currentOffset = 0;            
            Read(copy, 0, length);

            currentChunk = backupReadChunk;
            currentOffset = backupReadOffset;           
            
            return copy;
        }      


        // write remainder of this stream to another stream
        internal virtual void WriteTo(Stream stream) {
            if (stream == null)
                throw new ArgumentNullException("stream");

            byte[] chunkBuffer = currentChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
            if (currentChunk.Next == null)
                chunkSize = endOffset;

            // following code mirrors Read() logic (currentChunk/currentOffset should
            //   point just past last byte of last chunk when done)

            for (;;){ // loop until end of chunks is found
                if (currentOffset == chunkSize) {
                    // exit if no more chunks are currently available
                    if (currentChunk.Next == null)
                        break;

                    currentChunkStartPos += currentChunk.Buffer.Length;
                    currentChunk = currentChunk.Next;
                    currentOffset = 0;
                    chunkBuffer = currentChunk.Buffer;
                    chunkSize = chunkBuffer.Length;
                    if (currentChunk.Next == null)
                        chunkSize = endOffset;
                }

                int writeCount = chunkSize - currentOffset;
                stream.Write(chunkBuffer, currentOffset, writeCount);
                currentOffset = chunkSize;
            }
                
        } 



        private static int min(int a, int b) { return a < b ? a : b;}

        private MemoryChunk AllocateMemoryChunk(long newSize) {
            if(newSize > chunkSize) chunkSize = newSize;
            MemoryChunk chunk = new MemoryChunk();
            chunk.Buffer = new byte[chunkSize];
            chunkSize*=2;//nexttime alloc more
            chunk.Next = null;
            return chunk;
        }

        private void SyncEndOffset() {
            if (currentChunk.Next == null && currentOffset > endOffset) 
                endOffset = currentOffset;
        }

        private class MemoryChunk {
            internal byte[] Buffer = null;
            internal MemoryChunk Next = null;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\servertype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServerType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Web.Services.Description;

    internal class ServerType {
        Type type;

        internal ServerType(Type type) {
            this.type = type;
        }

        internal Type Type {
            get { return type; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soap11serverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.IO;
    using System.Net;
    using System.Reflection;
    using System.Text;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Serialization;
    using System.Web.Services.Configuration;
    using System.Web.Services.Description;

    internal class Soap11ServerProtocolHelper : SoapServerProtocolHelper {
        internal Soap11ServerProtocolHelper(SoapServerProtocol protocol) : base(protocol) {
        }

        internal Soap11ServerProtocolHelper(SoapServerProtocol protocol, string requestNamespace) : base(protocol, requestNamespace) {
        }

        internal override SoapProtocolVersion Version { 
            get { return SoapProtocolVersion.Soap11; }
        }
        internal override ProtocolsEnum Protocol {
            get { return ProtocolsEnum.HttpSoap; }
        }
        internal override string EnvelopeNs { 
            get { return Soap.Namespace; } 
        }
        internal override string EncodingNs { 
            get { return Soap.Encoding; } 
        }
        internal override string HttpContentType { 
            get { return ContentType.TextXml; } 
        }

        internal override SoapServerMethod RouteRequest() {
            object methodKey;
            
            string methodUriString = ServerProtocol.Request.Headers[Soap.Action];
            if (methodUriString == null)
                throw new SoapException(Res.GetString(Res.UnableToHandleRequestActionRequired0), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace));

            if (ServerType.routingOnSoapAction) {
                if (methodUriString.StartsWith("\"") && methodUriString.EndsWith("\""))
                    methodUriString = methodUriString.Substring(1, methodUriString.Length - 2);
                    
                methodKey = HttpUtility.UrlDecode(methodUriString);
            }
            else {
                try {
                    methodKey = GetRequestElement();
                }
                catch (SoapException) {
                    throw;
                }
                catch (Exception e) {
                    throw new SoapException(Res.GetString(Res.TheRootElementForTheRequestCouldNotBeDetermined0), new XmlQualifiedName(Soap.ServerCode, Soap.Namespace), e);
                }
            }

            SoapServerMethod method = ServerType.GetMethod(methodKey);
            if (method == null) {
                if (ServerType.routingOnSoapAction)
                    throw new SoapException(Res.GetString(Res.WebHttpHeader, Soap.Action, (string) methodKey), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace));
                else
                    throw new SoapException(Res.GetString(Res.TheRequestElementXmlnsWasNotRecognized2, ((XmlQualifiedName) methodKey).Name, ((XmlQualifiedName) methodKey).Namespace), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace));
            }
            
            return method;
        }
        
        internal override void SetResponseErrorCode(HttpResponse response, SoapException soapException) {
            response.StatusCode = (int) HttpStatusCode.InternalServerError;
            response.StatusDescription = Res.GetString(Res.WebRequestErrorStatusDescription);
        }

        internal override void WriteFault(XmlWriter writer, SoapException soapException) {
            SoapServerMessage message = ServerProtocol.Message;
            writer.WriteStartDocument();
            writer.WriteStartElement("soap", Soap.Envelope, Soap.Namespace);
            writer.WriteAttributeString("xmlns", "soap", null, Soap.Namespace);
            writer.WriteAttributeString("xmlns", "xsi", null, XmlSchema.InstanceNamespace);
            writer.WriteAttributeString("xmlns", "xsd", null, XmlSchema.Namespace);
            if (ServerProtocol.ServerMethod != null)
                SoapHeaderHandling.WriteHeaders(writer, ServerProtocol.ServerMethod.outHeaderSerializer, message.Headers, ServerProtocol.ServerMethod.outHeaderMappings, SoapHeaderDirection.Fault, ServerProtocol.ServerMethod.use == SoapBindingUse.Encoded, ServerType.serviceNamespace, ServerType.serviceDefaultIsEncoded, Soap.Namespace);
            else
                SoapHeaderHandling.WriteUnknownHeaders(writer, message.Headers, Soap.Namespace);
            writer.WriteStartElement(Soap.Body, Soap.Namespace);
            
            writer.WriteStartElement(Soap.Fault, Soap.Namespace);
            writer.WriteStartElement(Soap.FaultCode, "");
            XmlQualifiedName code = TranslateFaultCode(soapException.Code);
            if (code.Namespace != null && code.Namespace.Length > 0 && writer.LookupPrefix(code.Namespace) == null)
                writer.WriteAttributeString("xmlns", "q0", null, code.Namespace);
            writer.WriteQualifiedName(code.Name, code.Namespace);
            writer.WriteEndElement();
            writer.WriteElementString(Soap.FaultString, "", ServerProtocol.GenerateFaultString(soapException));
            // Only write an actor element if the actor was specified (it's optional for end-points)
            string actor = soapException.Actor;
            if (actor.Length > 0)
                writer.WriteElementString(Soap.FaultActor, "", actor);
            
            // Only write a FaultDetail element if exception is related to the body (not a header)
            if (!(soapException is SoapHeaderException)) {
                if (soapException.Detail == null) {
                    writer.WriteStartElement(Soap.FaultDetail, "");
                    writer.WriteEndElement();
                }
                else {
                    soapException.Detail.WriteTo(writer);
                }
            }
            writer.WriteEndElement();
            
            writer.WriteEndElement();
            writer.WriteEndElement();
            writer.Flush();
        }
        
        private static XmlQualifiedName TranslateFaultCode(XmlQualifiedName code) {
            if (code.Namespace == Soap.Namespace) {
                return code;
            }
            else if (code.Namespace == Soap12.Namespace) {
                if (code.Name == Soap12.ReceiverCode)
                    return SoapException.ServerFaultCode;
                else if (code.Name == Soap12.SenderCode)
                    return SoapException.ClientFaultCode;
                else if (code.Name == Soap12.MustUnderstandCode)
                    return SoapException.MustUnderstandFaultCode;
                else if (code.Name == Soap12.VersionMismatchCode)
                    return SoapException.VersionMismatchFaultCode;
            }
            return code;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\serverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Web.Services.Description;
    using System.Web.Caching;
    using System.ComponentModel;
    using System.Text;
    using System.Net;
    using System.Web.Services;

    internal abstract class ServerProtocol {
        Type type;
        HttpRequest request;
        HttpResponse response;
        HttpContext context;
        object target;
        WebMethodAttribute methodAttr;

        internal void SetContext(Type type, HttpContext context, HttpRequest request, HttpResponse response) {
            this.type = type;
            this.context = context;
            this.request = request;
            this.response = response;
            Initialize();
        }

        internal virtual void CreateServerInstance() {
            target = Activator.CreateInstance(ServerType.Type);
            WebService service = target as WebService;
            if (service != null)
                service.SetContext(context);
        }

        internal virtual void DisposeServerInstance() {
            if (target == null) return;
            IDisposable disposable = target as IDisposable;
            if (disposable != null)
                disposable.Dispose();
            target = null;
        }

        internal HttpContext Context {
            get { return context; }
        }

        internal HttpRequest Request {
            get { return request; }
        }

        internal HttpResponse Response {
            get { return response; }
        }

        internal Type Type {
            get { return type; }
        }

        internal object Target {
            get { return target; }
        }

        internal virtual bool WriteException(Exception e, Stream outputStream) {
            // return true if exception should not be re-thrown to ASP.NET
            return false;
        }

        internal abstract bool Initialize();
        internal abstract object[] ReadParameters();
        internal abstract void WriteReturns(object[] returns, Stream outputStream);
        internal abstract LogicalMethodInfo MethodInfo { get;}
        internal abstract ServerType ServerType { get;}
        internal abstract bool IsOneWay { get;}
        internal virtual Exception OnewayInitException { get {return null;}}

        internal WebMethodAttribute MethodAttribute {
            get {
                if (methodAttr == null)
                    methodAttr = WebMethodReflector.GetAttribute(MethodInfo);
                return methodAttr;
            }
        }
                
        internal string GenerateFaultString(Exception e) {
            return GenerateFaultString(e, false);
        }

        // CONSIDER, alexdej: I just added this overload to fix #94390. we should reconsider
        // this interface if/when ServerProtocol becomes public
        internal string GenerateFaultString(Exception e, bool htmlEscapeMessage) {
            //If the user has specified it's a development server (versus a production server) in ASP.NET config,
            //then we should just return e.ToString instead of extracting the list of messages.            
            StringBuilder builder = new StringBuilder();            
            if (Context != null && !Context.IsCustomErrorEnabled) 
                builder.Append(e.ToString());
            else {                
                for (Exception inner = e; inner != null; inner = inner.InnerException) {
                    string text = HttpUtility.HtmlEncode(inner.Message);
                    if (text.Length == 0) text = e.GetType().Name;
                    builder.Append(text);
                    if (inner.InnerException != null) builder.Append(" --> ");
                }                
            }
            
            return builder.ToString();
        }

        internal void WriteOneWayResponse() {        
            context.Response.ContentType = null;
            Response.StatusCode = (int) HttpStatusCode.Accepted;
        }

                
        string CreateKey(Type protocolType, Type serverType) {
            //
            // we want to use the hostname to cache since for documentation, WSDL
            // contains the cache hostname, but we definitely don't want to cache the query string!
            //            
            string protocolTypeName = protocolType.FullName;
            string serverTypeName = serverType.FullName; 
            string typeHandleString = serverType.TypeHandle.Value.ToString();
            string url = Request.Url.GetLeftPart(UriPartial.Path);
            int length = protocolTypeName.Length + url.Length + serverTypeName.Length + typeHandleString.Length;
            StringBuilder sb = new StringBuilder(length);
            sb.Append(protocolTypeName);
            sb.Append(url);
            sb.Append(serverTypeName);
            sb.Append(typeHandleString);                
            return sb.ToString();
        }

        protected void AddToCache(Type protocolType, Type serverType, object value) {
            HttpRuntime.Cache.Insert(CreateKey(protocolType, serverType), 
                value, 
                new CacheDependency(Request.PhysicalPath),
                Cache.NoAbsoluteExpiration,
                Cache.NoSlidingExpiration,
                CacheItemPriority.NotRemovable,
                null);
        }

        protected object GetFromCache(Type protocolType, Type serverType) {
            return HttpRuntime.Cache.Get(CreateKey(protocolType, serverType));
        }
    }
    
    internal abstract class ServerProtocolFactory {

        internal ServerProtocol Create(Type type, HttpContext context, HttpRequest request, HttpResponse response, out bool abortProcessing) {
            ServerProtocol serverProtocol = null;
            abortProcessing = false;
            try {
                serverProtocol = CreateIfRequestCompatible(request);
                if (serverProtocol!=null)
                    serverProtocol.SetContext(type, context, request, response);
                return serverProtocol;
            }
            catch (Exception e) {
                abortProcessing = true;
                if (serverProtocol != null) {
                    // give the protocol a shot at handling the error in a custom way
                    if (!serverProtocol.WriteException(e, serverProtocol.Response.OutputStream))
                        throw new InvalidOperationException(Res.GetString(Res.UnableToHandleRequest0), e);
                }
                return null;
            }

        }

        protected abstract ServerProtocol CreateIfRequestCompatible(HttpRequest request);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\scalars.cs ===
//------------------------------------------------------------------------------
// <copyright file="Scalars.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System.Web.Services;
    using System.Collections;
    using System.Globalization;
    using System.Reflection;
    using System;
    using System.Text;
    
    internal class ScalarFormatter {

        internal static string ToString(object value) {
            if (value == null) 
                return string.Empty;
            else if (value is string)
                return (string)value;
            else if (value.GetType().IsEnum)
                return EnumToString(value);
            else
                return (string)Convert.ToString(value);
        }

        internal static object FromString(string value, Type type) {
            try {
                if (type == typeof(string))
                    return value;
                else if (type.IsEnum)
                    return (object)EnumFromString(value, type);
                else
                    return Convert.ChangeType(value, type);
            }
            catch (Exception e) {
                throw new ArgumentException(Res.GetString(Res.WebChangeTypeFailed, value, type.FullName), "type", e);
            }
        }

        static object EnumFromString(string value, Type type) {
            return Enum.Parse(type, value);
        }

        static string EnumToString(object value) {
            return Enum.Format(value.GetType(), value, "G");
        }

        // We support: whatever Convert supports, and Enums
        internal static bool IsTypeSupported(Type type) {
            if (type.IsEnum) return true;
            return (
                type == typeof(int) ||
                type == typeof(string) ||
                type == typeof(long) ||
                type == typeof(byte) ||
                type == typeof(sbyte) ||
                type == typeof(short) ||
                type == typeof(bool) ||
                type == typeof(char) ||
                type == typeof(float) ||
                type == typeof(decimal) ||
                type == typeof(DateTime) ||
                type == typeof(UInt16) ||
                type == typeof(UInt32) ||
                type == typeof(UInt64) ||
                type == typeof(double));
        }
    }

    internal class UrlEncoder {
        private const int Max16BitUtf8SequenceLength = 4;

        internal static string EscapeString(string s, Encoding e) {
            return EscapeStringInternal(s, e == null ? new ASCIIEncoding() : e, false);
        }

        internal static string UrlEscapeString(string s, Encoding e) {
            return EscapeStringInternal(s, e == null ? new ASCIIEncoding() : e, true);
        }

        private static string EscapeStringInternal(string s, Encoding e, bool escapeUriStuff) {
            if (s == null) return null;
            
            byte[] bytes = e.GetBytes(s);
            StringBuilder sb = new StringBuilder(bytes.Length);
            for (int i = 0; i < bytes.Length; i++) {
                byte b = bytes[i];
                char c = (char)b;
                if (b > 0x7f || b < 0x20 || c == '%' || (escapeUriStuff && !IsSafe(c))) {
                    HexEscape8(sb, c);
                }
                else {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }

        /*
        // alexdej: adapted from UrlEscapeStringUnicode below
        internal static string EscapeStringUnicode(string s) {
            int l = s.Length;
            StringBuilder sb = new StringBuilder(l);

            for (int i = 0; i < l; i++) {
                char ch = s[i];
                if ((ch & 0xff80) == 0) {
                    sb.Append(ch);
                }
                else {
                    HexEscape16(sb, ch);
                }
            }

            return sb.ToString();
        }
        */

        // alexdej: copied from System.Web.HttpUtility
        internal static string UrlEscapeStringUnicode(string s) {
            int l = s.Length;
            StringBuilder sb = new StringBuilder(l);

            for (int i = 0; i < l; i++) {
                char ch = s[i];

                if (IsSafe(ch)) {
                    sb.Append(ch);
                }
                else if (ch == ' ') {
                    sb.Append('+');
                }
                else if ((ch & 0xff80) == 0) {  // 7 bit?
                    HexEscape8(sb, ch);
                }
                else { // arbitrary Unicode?
                    HexEscape16(sb, ch);
                }
            }
            return sb.ToString();
        }

        private static void HexEscape8(StringBuilder sb, char c) {
            sb.Append('%');
            sb.Append(HexUpperChars[(c >>  4) & 0xf]);
            sb.Append(HexUpperChars[(c      ) & 0xf]);
        }

        private static void HexEscape16(StringBuilder sb, char c) {
            sb.Append("%u");
            sb.Append(HexUpperChars[(c >> 12) & 0xf]);
            sb.Append(HexUpperChars[(c >>  8) & 0xf]);
            sb.Append(HexUpperChars[(c >>  4) & 0xf]);
            sb.Append(HexUpperChars[(c      ) & 0xf]);
        }

        private static bool IsSafe(char ch) {
            if (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')
                return true;

            switch (ch) {
                case '-':
                case '_':
                case '.':
                case '!':
                case '*':
                case '\'':
                case '(':
                case ')':
                    return true;
            }

            return false;
        }

        internal static readonly char[] HexUpperChars = {
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
        };
    }

    internal class ContentType {
        internal const string TextBase = "text";
        internal const string TextXml     = "text/xml";
        internal const string TextPlain   = "text/plain";
        internal const string TextHtml    = "text/html";

        internal const string ApplicationBase = "application";
        internal const string ApplicationXml = "application/xml";
        internal const string ApplicationSoap = "application/soap+xml";
        internal const string ApplicationOctetStream = "application/octet-stream";

        internal const string ContentEncoding = "Content-Encoding";

        // this returns the "base" part of the contentType/mimeType, e.g. the "text/xml" part w/o
        // the ; CharSet=isoxxx part that sometimes follows.
        internal static string GetBase(string contentType) {
            int semi = contentType.IndexOf(';');
            if (semi >= 0) return contentType.Substring(0, semi);
            return contentType;
        }

        // grabs as follows (and case-insensitive): .*;\s*charset\s*=\s*[\s'"]*(.*)[\s'"]*
        internal static string GetCharset(string contentType) {
            return GetParameter(contentType, "charset");
        }

        internal static string GetAction(string contentType) {
            return GetParameter(contentType, "action");
        }

        private static string GetParameter(string contentType, string paramName) {
            string[] paramDecls = contentType.Split(new char[] { ';' });
            for (int i = 1; i < paramDecls.Length; i++) {
                string paramDecl = paramDecls[i].TrimStart(null);
                if (String.Compare(paramDecl, 0, paramName, 0, paramName.Length, true, CultureInfo.InvariantCulture) == 0) {
                    int equals = paramDecl.IndexOf('=', paramName.Length);
                    if (equals >= 0) 
                        return paramDecl.Substring(equals + 1).Trim(new char[] {' ', '\'', '\"', '\t'});
                }
            }
            return null;
        }

        internal static bool MatchesBase(string contentType, string baseContentType) {
            return string.Compare(GetBase(contentType), baseContentType, true, CultureInfo.InvariantCulture) == 0;
        }

        internal static bool IsSoap(string contentType) {
            string type = GetBase(contentType);
            return (String.Compare(type, ContentType.TextXml, true, CultureInfo.InvariantCulture) == 0) ||
                   (String.Compare(type, ContentType.ApplicationSoap, true, CultureInfo.InvariantCulture) == 0);
        }
        
        internal static bool IsXml(string contentType) {
            string type = GetBase(contentType);
            return (String.Compare(type, ContentType.TextXml, true, CultureInfo.InvariantCulture) == 0) ||
                   (String.Compare(type, ContentType.ApplicationXml, true, CultureInfo.InvariantCulture) == 0);
        }

        internal static bool IsHtml(string contentType) {
            string type = GetBase(contentType);
            return String.Compare(type, ContentType.TextHtml, true, CultureInfo.InvariantCulture) == 0;
        }

        internal static string Compose(string contentType, Encoding encoding) {
            return Compose(contentType, encoding, null);
        }

        internal static string Compose(string contentType, Encoding encoding, string action) {
            if (encoding == null && action == null) return contentType;

            StringBuilder sb = new StringBuilder(contentType);
            if (encoding != null) {
                sb.Append("; charset=");
                sb.Append(encoding.WebName);
            }
            if (action != null) {
                sb.Append("; action=\"");
                sb.Append(action);
                sb.Append("\"");
            }
            return sb.ToString();
        }
    }

    internal class MemberHelper {
        static object[] emptyObjectArray = new object[0];

        internal static void SetValue(MemberInfo memberInfo, object target, object value) {
            if (memberInfo is FieldInfo ) {
                ((FieldInfo)memberInfo).SetValue(target, value);
            }
            else {
                ((PropertyInfo)memberInfo).SetValue(target, value, emptyObjectArray);
            }
        }

        internal static object GetValue(MemberInfo memberInfo, object target) {
            if (memberInfo is FieldInfo) {
                return ((FieldInfo)memberInfo).GetValue(target);
            }
            else {
                return ((PropertyInfo)memberInfo).GetValue(target, emptyObjectArray);
            }
        }

        internal static bool IsStatic(MemberInfo memberInfo) {
            if (memberInfo is FieldInfo)
                return ((FieldInfo)memberInfo).IsStatic;
            else
                return false;
        }

        internal static bool CanRead(MemberInfo memberInfo) {
            if (memberInfo is FieldInfo)
                return true;
            else
                return ((PropertyInfo)memberInfo).CanRead;
        }

        internal static bool CanWrite(MemberInfo memberInfo) {
            if (memberInfo is FieldInfo)
                return true;
            else
                return ((PropertyInfo)memberInfo).CanWrite;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapclientmessage.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapClientMessage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class SoapClientMessage : SoapMessage {
        SoapClientMethod method;
        SoapHttpClientProtocol protocol;
        string url;

        internal SoapExtension[] initializedExtensions;

        internal SoapClientMessage(SoapHttpClientProtocol protocol, SoapClientMethod method, string url) {
            this.method = method;
            this.protocol = protocol;
            this.url = url;
        }

        /*
        internal override bool IsInitialized {
            get { return true; }
        }
        */

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.OneWay"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool OneWay {
            get { return method.oneWay; }
        }

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.Client"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHttpClientProtocol Client {
            get { return protocol; }
        }

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.MethodInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override LogicalMethodInfo MethodInfo {
            get { return method.methodInfo; }
        }
    
        /*
        internal override SoapReflectedExtension[] Extensions {
            get { return method.extensions; }
        }

        internal override object[] ExtensionInitializers {
            get { return method.extensionInitializers; }
        }
        */

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Url {
            get { return url; }
        }

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.Action"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Action {
            get { return method.action; }
        }

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.SoapVersion"]/*' />
        // SOAP12: made this internal
        internal override SoapProtocolVersion SoapVersion {
            get { return protocol.SoapVersion == SoapProtocolVersion.Default ? SoapProtocolVersion.Soap11 : protocol.SoapVersion; }
        }

        internal SoapClientMethod Method {
            get { return method; }
        }

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.EnsureOutStage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void EnsureOutStage() {
            EnsureStage(SoapMessageStage.AfterDeserialize);
        }

        /// <include file='doc\SoapClientMessage.uex' path='docs/doc[@for="SoapClientMessage.EnsureInStage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void EnsureInStage(){
            EnsureStage(SoapMessageStage.BeforeSerialize);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapdocumentmethodattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapDocumentMethodAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Web.Services.Description;

    /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class SoapDocumentMethodAttribute : System.Attribute {
        string action;
        string requestName;
        string responseName;
        string requestNamespace;
        string responseNamespace;
        bool oneWay;
        SoapBindingUse use = SoapBindingUse.Default;
        SoapParameterStyle style = SoapParameterStyle.Default;
        string binding;
        
        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.SoapDocumentMethodAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapDocumentMethodAttribute() {
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.SoapDocumentMethodAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapDocumentMethodAttribute(string action) {
            this.action = action;
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.Action"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Action {
            get { return action; }
            set { action = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.OneWay"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool OneWay {
            get { return oneWay; }
            set { oneWay = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.RequestNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string RequestNamespace {
            get { return requestNamespace; }
            set { requestNamespace = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.ResponseNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ResponseNamespace {
            get { return responseNamespace; }
            set { responseNamespace = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.RequestElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string RequestElementName {
            get { return requestName == null ? string.Empty : requestName; }
            set { requestName = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.ResponseElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ResponseElementName {
            get { return responseName == null ? string.Empty : responseName; }
            set { responseName = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.Use"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapBindingUse Use {
            get { return use; }
            set { use = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.ParameterStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapParameterStyle ParameterStyle {
            get { return style; }
            set { style = value; }
        }

        /// <include file='doc\SoapDocumentMethodAttribute.uex' path='docs/doc[@for="SoapDocumentMethodAttribute.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Binding {
            get { return binding == null ? string.Empty : binding; }
            set { binding = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soap12serverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.IO;
    using System.Net;
    using System.Reflection;
    using System.Text;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Serialization;
    using System.Web.Services.Configuration;
    using System.Web.Services.Description;

    internal class Soap12ServerProtocolHelper : SoapServerProtocolHelper {
        internal Soap12ServerProtocolHelper(SoapServerProtocol protocol) : base(protocol) {
        }

        internal Soap12ServerProtocolHelper(SoapServerProtocol protocol, string requestNamespace) : base(protocol, requestNamespace) {
        }

        internal override SoapProtocolVersion Version { 
            get { return SoapProtocolVersion.Soap12; }
        }
        internal override ProtocolsEnum Protocol {
            get { return ProtocolsEnum.HttpSoap12; }
        }
        internal override string EnvelopeNs { 
            get { return Soap12.Namespace; } 
        }
        internal override string EncodingNs { 
            get { return Soap12.Encoding; } 
        }
        internal override string HttpContentType { 
            get { return ContentType.ApplicationSoap; } 
        }
        
        internal override SoapServerMethod RouteRequest() {
            string action = ContentType.GetAction(ServerProtocol.Request.ContentType);

            SoapServerMethod method = null;
            bool duplicateAction = false, duplicateRequestElement = false;

            if (action != null && action.Length > 0) {
                action = HttpUtility.UrlDecode(action);
                method = ServerType.GetMethod(action);
                if (method != null) {
                    if (ServerType.GetDuplicateMethod(action) != null) {
                        method = null;
                        duplicateAction = true;
                    }
                }
            }

            XmlQualifiedName requestElement = new XmlQualifiedName("", "");
            if (method == null) {
                // try request element
                requestElement = GetRequestElement();
                method = ServerType.GetMethod(requestElement);
                if (method != null) {
                    if (ServerType.GetDuplicateMethod(requestElement) != null) {
                        method = null;
                        duplicateRequestElement = true;
                    }
                }
            }

            if (method == null) {
                // try to figure out what happened...
                if (action == null || action.Length == 0) {
                    // they didn't send a soap action and we couldn't route on request element
                    // require soap action for future requests:
                    throw new SoapException(Res.GetString(Res.UnableToHandleRequestActionRequired0), Soap12FaultCodes.SenderFaultCode);
                }
                else if (duplicateAction) {
                    // what went wrong with the request element?
                    if (duplicateRequestElement) {
                        // server's fault -- nothing the client could have done to prevent this
                        throw new SoapException(Res.GetString(Res.UnableToHandleRequest0), Soap12FaultCodes.ReceiverFaultCode);
                    }
                    else {
                        // probably client's fault -- we didn't recognize the request element they sent
                        throw new SoapException(Res.GetString(Res.TheRequestElementXmlnsWasNotRecognized2, requestElement.Name, requestElement.Namespace), Soap12FaultCodes.SenderFaultCode);
                    }
                }
                else {
                    // neither action nor request element worked out for us. since they sent an action,
                    // we'll suggest they do a better job next time
                    throw new SoapException(Res.GetString(Res.UnableToHandleRequestActionNotRecognized1, action), Soap12FaultCodes.SenderFaultCode);
                }
            }

            return method;
        }

        internal override void SetResponseErrorCode(HttpResponse response, SoapException soapException) {
            if (soapException.Subcode != null && soapException.Subcode.Code == Soap12FaultCodes.UnsupportedMediaTypeFaultCode) {
                response.StatusCode = (int) HttpStatusCode.UnsupportedMediaType;
                response.StatusDescription = Res.GetString(Res.WebUnsupportedMediaTypeStatusDescription);
                soapException.ClearSubcode();
            }
            else if (SoapException.IsClientFaultCode(soapException.Code)) {
                response.StatusCode = (int) HttpStatusCode.BadRequest;
                response.StatusDescription = Res.GetString(Res.WebBadRequestStatusDescription);
            }
            else {
                response.StatusCode = (int) HttpStatusCode.InternalServerError;
                response.StatusDescription = Res.GetString(Res.WebRequestErrorStatusDescription);
            }
        }

        internal override void WriteFault(XmlWriter writer, SoapException soapException) {
            writer.WriteStartDocument();
            writer.WriteStartElement("soap", Soap.Envelope, Soap12.Namespace);
            writer.WriteAttributeString("xmlns", "soap", null, Soap12.Namespace);
            writer.WriteAttributeString("xmlns", "xsi", null, XmlSchema.InstanceNamespace);
            writer.WriteAttributeString("xmlns", "xsd", null, XmlSchema.Namespace);
            if (ServerProtocol.ServerMethod != null)
                SoapHeaderHandling.WriteHeaders(writer, ServerProtocol.ServerMethod.outHeaderSerializer, ServerProtocol.Message.Headers, ServerProtocol.ServerMethod.outHeaderMappings, SoapHeaderDirection.Fault, ServerProtocol.ServerMethod.use == SoapBindingUse.Encoded, ServerType.serviceNamespace, ServerType.serviceDefaultIsEncoded, Soap12.Namespace);
            else
                SoapHeaderHandling.WriteUnknownHeaders(writer, ServerProtocol.Message.Headers, Soap12.Namespace);

            writer.WriteStartElement(Soap.Body, Soap12.Namespace);
            
            writer.WriteStartElement(Soap.Fault, Soap12.Namespace);
            writer.WriteStartElement(Soap12.FaultCode, Soap12.Namespace);
            WriteFaultCodeValue(writer, TranslateFaultCode(soapException.Code), soapException.Subcode);
            writer.WriteEndElement(); // </faultcode>
            writer.WriteElementString(Soap12.FaultReason, Soap12.Namespace, ServerProtocol.GenerateFaultString(soapException));
            // Only write an actor element if the actor was specified (it's optional for end-points)
            string actor = soapException.Actor;
            if (actor.Length > 0)
                writer.WriteElementString(Soap12.FaultNode, Soap12.Namespace, actor);

            string role = soapException.Role;
            if (role.Length > 0)
                writer.WriteElementString(Soap12.FaultRole, Soap12.Namespace, role);

            // Only write a FaultDetail element if exception is related to the body (not a header)
            if (!(soapException is SoapHeaderException)) {
                if (soapException.Detail == null) {
                    writer.WriteStartElement(Soap12.FaultDetail, Soap12.Namespace);
                    writer.WriteEndElement();
                }
                else {
                    soapException.Detail.WriteTo(writer);
                }
            }
            writer.WriteEndElement();
            
            writer.WriteEndElement();
            writer.WriteEndElement();
            writer.Flush();
        }

        private static void WriteFaultCodeValue(XmlWriter writer, XmlQualifiedName code, SoapFaultSubcode subcode) {
            if (code == null) return;
            writer.WriteStartElement(Soap12.FaultCodeValue, Soap12.Namespace);
            if (code.Namespace != null && code.Namespace.Length > 0 && writer.LookupPrefix(code.Namespace) == null)
                writer.WriteAttributeString("xmlns", "q0", null, code.Namespace);
            writer.WriteQualifiedName(code.Name, code.Namespace);
            writer.WriteEndElement(); // </value>
            if (subcode != null) {
                writer.WriteStartElement(Soap12.FaultSubcode, Soap12.Namespace);
                WriteFaultCodeValue(writer, subcode.Code, subcode.Subcode);
                writer.WriteEndElement(); // </subcode>
            }
        }

        private static XmlQualifiedName TranslateFaultCode(XmlQualifiedName code) {
            // note that we're allowing user-defined codes at the top-level here which technically
            // is not allowed by the soap 1.2 spec.
            
            if (code.Namespace == Soap.Namespace) {
                if (code.Name == Soap.ServerCode)
                    return Soap12FaultCodes.ReceiverFaultCode;
                else if (code.Name == Soap.ClientCode)
                    return Soap12FaultCodes.SenderFaultCode;
                else if (code.Name == Soap.MustUnderstandCode)
                    return Soap12FaultCodes.MustUnderstandFaultCode;
                else if (code.Name == Soap.VersionMismatchCode)
                    return Soap12FaultCodes.VersionMismatchFaultCode;
            }
            return code;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapclientprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapClientProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Text;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Xml;
    using System.Diagnostics;
    using System.Xml.Schema;
    using System.Web.Services.Description;
    using System.Web.Services.Discovery;
    using System.Web.Services.Configuration;
    using System.Net;


    // this class writes 'href' and 'id' attribute values in a special form
    // it used for writting encoded headers
    internal class XmlSpecialTextWriter : XmlTextWriter {
        bool isWritingId = false;
        bool encodeIds = false;
        SoapProtocolVersion version;
        string refName = "href";

        internal XmlSpecialTextWriter(TextWriter w) : base(w) {}
        internal XmlSpecialTextWriter(TextWriter w, SoapProtocolVersion version) : base(w) {
            Version = version; // set property
        }
        internal XmlSpecialTextWriter(Stream s, Encoding e) : base(s, e) {}

        public override void WriteString(string text) {
            if (encodeIds && isWritingId) {
                if (null != text  && text.Length > 0) {
                    if (text.StartsWith("#")) {
                        base.WriteString("#h_");
                        base.WriteString(text.Substring(1));
                    }
                    else {
                        base.WriteString("h_");
                        base.WriteString(text);
                    }
                }
                isWritingId = false;
            }
            else {
                base.WriteString(text);
            }
        }
        public override void WriteStartAttribute(string prefix, string localName, string ns) {
            if (prefix == null && (ns == null || ns.Length == 0) && (localName == "id" || localName == refName)) {
                isWritingId = true;
            }
            base.WriteStartAttribute(prefix, localName, ns);
        }

        internal bool EncodeIds {
            get { return encodeIds; }
            set { encodeIds = value; }
        }

        internal SoapProtocolVersion Version {
            get { return version; }
            set { 
                version = value;
                refName = version == SoapProtocolVersion.Soap12 ? "ref" : "href";
            }
        }
    }

    internal class SoapClientType {
        Hashtable methods = new Hashtable();
        WebServiceBindingAttribute binding;

        internal SoapReflectedExtension[] HighPriExtensions;
        internal SoapReflectedExtension[] LowPriExtensions;
        internal object[] HighPriExtensionInitializers;
        internal object[] LowPriExtensionInitializers;

        internal string serviceNamespace;
        internal bool serviceDefaultIsEncoded;

        internal SoapClientType(Type type) {
            LogicalMethodInfo[] methodInfos = LogicalMethodInfo.Create(type.GetMethods(BindingFlags.Public | BindingFlags.Instance), LogicalMethodTypes.Sync);
            ArrayList mappings = new ArrayList();
            ArrayList soapMethodList = new ArrayList();
            this.binding = WebServiceBindingReflector.GetAttribute(type);
            if (this.binding == null) throw new InvalidOperationException(Res.GetString(Res.WebClientBindingAttributeRequired));
            // Note: Service namespace is taken from WebserviceBindingAttribute and not WebserviceAttribute because
            // the generated proxy does not have a WebServiceAttribute; however all have a WebServiceBindingAttribute. 
            serviceNamespace = binding.Namespace;
            serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(type);
            SoapReflectionImporter soapImporter = SoapReflector.CreateSoapImporter(serviceNamespace, serviceDefaultIsEncoded);
            XmlReflectionImporter xmlImporter = SoapReflector.CreateXmlImporter(serviceNamespace, serviceDefaultIsEncoded);
            WebMethodReflector.IncludeTypes(methodInfos, xmlImporter);
            SoapReflector.IncludeTypes(methodInfos, soapImporter);
 
            SoapExtensionType[] extensionTypes = WebServicesConfiguration.Current.SoapExtensionTypes;
            ArrayList highPri = new ArrayList();
            ArrayList lowPri = new ArrayList();
            for (int i = 0; i < extensionTypes.Length; i++) {
                SoapReflectedExtension extension = new SoapReflectedExtension(extensionTypes[i].Type, null, extensionTypes[i].Priority);
                if (extensionTypes[i].Group == SoapExtensionType.PriorityGroup.High)
                    highPri.Add(extension);
                else
                    lowPri.Add(extension);
            }
            HighPriExtensions = (SoapReflectedExtension[]) highPri.ToArray(typeof(SoapReflectedExtension));
            LowPriExtensions = (SoapReflectedExtension[]) lowPri.ToArray(typeof(SoapReflectedExtension));
            Array.Sort(HighPriExtensions);
            Array.Sort(LowPriExtensions);
            HighPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, HighPriExtensions);
            LowPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, LowPriExtensions);
 
            for (int i = 0; i < methodInfos.Length; i++) {
                LogicalMethodInfo methodInfo = methodInfos[i];
                SoapReflectedMethod soapMethod = SoapReflector.ReflectMethod(methodInfo, true, xmlImporter, soapImporter, serviceNamespace);
                if (soapMethod == null) continue;
                soapMethodList.Add(soapMethod);
                mappings.Add(soapMethod.requestMappings);
                if (soapMethod.responseMappings != null) mappings.Add(soapMethod.responseMappings);
                mappings.Add(soapMethod.inHeaderMappings);
                if (soapMethod.outHeaderMappings != null) mappings.Add(soapMethod.outHeaderMappings);
            }

            XmlSerializer[] serializers = XmlSerializer.FromMappings((XmlMapping[])mappings.ToArray(typeof(XmlMapping)));
            int count = 0;
            for (int i = 0; i < soapMethodList.Count; i++) {
                SoapReflectedMethod soapMethod = (SoapReflectedMethod)soapMethodList[i];
                SoapClientMethod clientMethod = new SoapClientMethod();
                clientMethod.parameterSerializer = serializers[count++]; 
                if (soapMethod.responseMappings != null) clientMethod.returnSerializer = serializers[count++];
                clientMethod.inHeaderSerializer = serializers[count++];
                if (soapMethod.outHeaderMappings != null) clientMethod.outHeaderSerializer = serializers[count++];
                clientMethod.action = soapMethod.action;
                clientMethod.oneWay = soapMethod.oneWay;
                clientMethod.rpc = soapMethod.rpc;
                clientMethod.use = soapMethod.use;
                clientMethod.paramStyle = soapMethod.paramStyle;
                clientMethod.methodInfo = soapMethod.methodInfo;
                clientMethod.extensions = soapMethod.extensions;
                clientMethod.extensionInitializers = SoapReflectedExtension.GetInitializers(clientMethod.methodInfo, soapMethod.extensions);
                ArrayList inHeaders = new ArrayList();
                ArrayList outHeaders = new ArrayList();
                for (int j = 0; j < soapMethod.headers.Length; j++) {
                    SoapHeaderMapping mapping = new SoapHeaderMapping();
                    SoapReflectedHeader soapHeader = soapMethod.headers[j];
                    mapping.memberInfo = soapHeader.memberInfo;
                    mapping.repeats = soapHeader.repeats;
                    mapping.custom = soapHeader.custom;
                    mapping.direction = soapHeader.direction;
                    mapping.headerType = soapHeader.headerType;
                    if ((mapping.direction & SoapHeaderDirection.In) != 0)
                        inHeaders.Add(mapping);
                    if ((mapping.direction & (SoapHeaderDirection.Out | SoapHeaderDirection.Fault)) != 0)
                        outHeaders.Add(mapping);
                }
                clientMethod.inHeaderMappings = (SoapHeaderMapping[])inHeaders.ToArray(typeof(SoapHeaderMapping));
                if (clientMethod.outHeaderSerializer != null)
                    clientMethod.outHeaderMappings = (SoapHeaderMapping[])outHeaders.ToArray(typeof(SoapHeaderMapping));
                methods.Add(soapMethod.name, clientMethod);
            }
        }

        internal SoapClientMethod GetMethod(string name) {
            return (SoapClientMethod)methods[name];
        }

        internal WebServiceBindingAttribute Binding {
            get { return binding; }
        }
    }

    internal class SoapClientMethod {
        internal XmlSerializer returnSerializer;
        internal XmlSerializer parameterSerializer;
        internal XmlSerializer inHeaderSerializer;
        internal XmlSerializer outHeaderSerializer;
        internal string action;
        internal LogicalMethodInfo methodInfo;
        internal SoapHeaderMapping[] inHeaderMappings;
        internal SoapHeaderMapping[] outHeaderMappings;
        internal SoapReflectedExtension[] extensions;
        internal object[] extensionInitializers;
        internal bool oneWay;
        internal bool rpc;
        internal SoapBindingUse use;
        internal SoapParameterStyle paramStyle;
    }

    /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies most of the implementation for communicating with a SOAP web service over HTTP.
    ///    </para>
    /// </devdoc>
    public class SoapHttpClientProtocol : HttpWebClientProtocol {
        SoapClientType clientType;
        SoapProtocolVersion version = SoapProtocolVersion.Default;

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.SoapHttpClientProtocol"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Services.Protocols.SoapHttpClientProtocol'/> class.
        ///    </para>
        /// </devdoc>
        public SoapHttpClientProtocol() 
            : base() {
            Type type = this.GetType();
            clientType = (SoapClientType)GetFromCache(type);
            if (clientType == null) {
                lock(type){
                    clientType = (SoapClientType)GetFromCache(type);
                    if (clientType == null) {
                        clientType = new SoapClientType(type);
                        AddToCache(type, clientType);
                    }
                }
            }
        }

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.Discover"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Discover() {
            if (clientType.Binding == null)
                throw new InvalidOperationException(Res.GetString(Res.DiscoveryIsNotPossibleBecauseTypeIsMissing1, this.GetType().FullName));
            DiscoveryClientProtocol disco = new DiscoveryClientProtocol(this);            
            DiscoveryDocument doc = disco.Discover(Url);
            foreach (object item in doc.References) {
                System.Web.Services.Discovery.SoapBinding soapBinding = item as System.Web.Services.Discovery.SoapBinding;
                if (soapBinding != null) {
                    if (clientType.Binding.Name == soapBinding.Binding.Name &&
                        clientType.Binding.Namespace == soapBinding.Binding.Namespace) {
                        Url = soapBinding.Address;
                        return;
                    }
                }
            }
            throw new InvalidOperationException(Res.GetString(Res.TheBindingNamedFromNamespaceWasNotFoundIn3, clientType.Binding.Name, clientType.Binding.Namespace, Url));
        }

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.GetWebRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override WebRequest GetWebRequest(Uri uri) {            
            WebRequest request = base.GetWebRequest(uri);            
            return request;
        }

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.SoapVersion"]/*' />
        //[WebServicesDescription(Res.ClientProtocolSoapVersion)]
        // SOAP12: made this internal
        internal SoapProtocolVersion SoapVersion {
            get { return version; }
            set { version = value; }
        }

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.Invoke"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invokes a method of a SOAP web service.
        ///    </para>
        /// </devdoc>
        protected object[] Invoke(string methodName, object[] parameters) {
            WebResponse response = null;                      
            WebRequest request = null;
            try {
                request = GetWebRequest(Uri);
                // CONSIDER,yannc: when we expose protocol extensibility we will want a better way to set/clear this.
                PendingSyncRequest = request;
                SoapClientMessage message = BeforeSerialize(request, methodName, parameters);            
                Stream requestStream = request.GetRequestStream();            
                try {                                
                    message.SetStream(requestStream);
                    Serialize(message);           
                }                        
                finally {
                    requestStream.Close();
                }

                response = GetWebResponse(request);
                Stream responseStream = null;
                try {
                    responseStream = response.GetResponseStream();
                    return ReadResponse(message, response, responseStream, false);
                }
                finally {
                    if (responseStream != null)
                        responseStream.Close();
                }
            }
            finally {
                if (request == PendingSyncRequest)
                    PendingSyncRequest = null;
            }
        }

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.BeginInvoke"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts an asynchronous invocation of a method of a SOAP web
        ///       service.
        ///    </para>
        /// </devdoc>
        protected IAsyncResult BeginInvoke(string methodName, object[] parameters, AsyncCallback callback, object asyncState) {
            InvokeAsyncState invokeState = new InvokeAsyncState(methodName, parameters);
            return BeginSend(Uri, invokeState, callback, asyncState, true);
        }

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.InitializeAsyncRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal override void InitializeAsyncRequest(WebRequest request, object internalAsyncState) {
            InvokeAsyncState invokeState = (InvokeAsyncState)internalAsyncState;
            invokeState.Message = BeforeSerialize(request, invokeState.MethodName, invokeState.Parameters);            
        }

        internal override void AsyncBufferedSerialize(WebRequest request, Stream requestStream, object internalAsyncState) {
            InvokeAsyncState invokeState = (InvokeAsyncState)internalAsyncState;
            SoapClientMessage message = invokeState.Message;
            message.SetStream(requestStream);
            Serialize(invokeState.Message);
        }

        class InvokeAsyncState {
            public string MethodName;
            public object[] Parameters;
            public SoapClientMessage Message;

            public InvokeAsyncState(string methodName, object[] parameters) {
                this.MethodName = methodName;
                this.Parameters = parameters;
            }
        }

        /// <include file='doc\SoapClientProtocol.uex' path='docs/doc[@for="SoapHttpClientProtocol.EndInvoke"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Ends an asynchronous invocation of a method of a remote SOAP web service.
        ///    </para>
        /// </devdoc>
        protected object[] EndInvoke(IAsyncResult asyncResult) {
            object o = null;
            Stream responseStream = null;
            try {
                WebResponse response = EndSend(asyncResult, ref o, ref responseStream);
                InvokeAsyncState invokeState = (InvokeAsyncState)o;
                return ReadResponse(invokeState.Message, response, responseStream, true);
            }
            finally {
                if (responseStream != null)
                    responseStream.Close();
            }
        }

        private static Array CombineExtensionsHelper(Array array1, Array array2, Array array3, Type elementType) {
            int length = array1.Length + array2.Length + array3.Length;
            if (length == 0)
                return null;
            Array result = null;
            if (elementType == typeof(SoapReflectedExtension))
                result = new SoapReflectedExtension[length];
            else if (elementType == typeof(object))
                result  = new object[length];
            else
                throw new ArgumentException(Res.GetString(Res.ElementTypeMustBeObjectOrSoapReflectedException),"elementType");
            
            int pos = 0;
            Array.Copy(array1, 0, result, pos, array1.Length);
            pos += array1.Length;
            Array.Copy(array2, 0, result, pos, array2.Length);
            pos += array2.Length;
            Array.Copy(array3, 0, result, pos, array3.Length);
            return result;
        }

        private string EnvelopeNs {
            get { 
                return this.version == SoapProtocolVersion.Soap12 ? Soap12.Namespace : Soap.Namespace; 
            }
        }

        private string EncodingNs {
            get { 
                return this.version == SoapProtocolVersion.Soap12 ? Soap12.Encoding : Soap.Encoding; 
            }
        }

        private string HttpContentType {
            get { 
                return this.version == SoapProtocolVersion.Soap12 ? ContentType.ApplicationSoap : ContentType.TextXml; 
            }
        }

        SoapClientMessage BeforeSerialize(WebRequest request, string methodName, object[] parameters) {
            if (parameters == null) throw new ArgumentNullException("parameters");
            SoapClientMethod method = clientType.GetMethod(methodName);
            if (method == null) throw new ArgumentException(Res.GetString(Res.WebInvalidMethodName, methodName));            

            // Run BeforeSerialize extension pass. Extensions are not allowed
            // to write into the stream during this pass.
            SoapReflectedExtension[] allExtensions = (SoapReflectedExtension[])CombineExtensionsHelper(clientType.HighPriExtensions, method.extensions, clientType.LowPriExtensions, typeof(SoapReflectedExtension));
            object[] allExtensionInitializers = (object[])CombineExtensionsHelper(clientType.HighPriExtensionInitializers, method.extensionInitializers, clientType.LowPriExtensionInitializers, typeof(object));
            SoapExtension[] initializedExtensions = SoapMessage.InitializeExtensions(allExtensions, allExtensionInitializers);
            SoapClientMessage message = new SoapClientMessage(this, method, Url);
            message.initializedExtensions = initializedExtensions;
            if (initializedExtensions != null)
                message.SetExtensionStream(new SoapExtensionStream());
            message.InitExtensionStreamChain(message.initializedExtensions);            

            string soapAction = UrlEncoder.EscapeString(method.action, Encoding.UTF8);
            message.SetStage(SoapMessageStage.BeforeSerialize);
            if (this.version == SoapProtocolVersion.Soap12)
                message.ContentType = ContentType.Compose(ContentType.ApplicationSoap, RequestEncoding != null ? RequestEncoding : Encoding.UTF8, soapAction);
            else
                message.ContentType = ContentType.Compose(ContentType.TextXml, RequestEncoding != null ? RequestEncoding : Encoding.UTF8);
            message.SetParameterValues(parameters);
            SoapHeaderHandling.GetHeaderMembers(message.Headers, this, method.inHeaderMappings, SoapHeaderDirection.In, true);
            message.RunExtensions(message.initializedExtensions);

            // Last chance to set request headers            
            request.ContentType = message.ContentType;
            if (message.ContentEncoding != null && message.ContentEncoding.Length > 0)
                request.Headers[ContentType.ContentEncoding] = message.ContentEncoding;

            request.Method = "POST";
            if (this.version != SoapProtocolVersion.Soap12 && request.Headers[Soap.Action] == null) {
                StringBuilder actionStringBuilder = new StringBuilder(soapAction.Length + 2);            
                actionStringBuilder.Append('"');
                actionStringBuilder.Append(soapAction);
                actionStringBuilder.Append('"');
                request.Headers.Add(Soap.Action, actionStringBuilder.ToString());                
            }

            return message;
        }

        void Serialize(SoapClientMessage message) {
            Stream stream = message.Stream;            
            SoapClientMethod method = message.Method;
            bool isEncoded = method.use == SoapBindingUse.Encoded;            
            // Serialize the message.  
            string envelopeNs = EnvelopeNs;
            string encodingNs = EncodingNs;
            StreamWriter sw = new StreamWriter(stream, RequestEncoding != null ? RequestEncoding : new UTF8Encoding(false), 128);
            XmlTextWriter writer = isEncoded && message.Headers.Count > 0 ? new XmlSpecialTextWriter(sw, version) : new XmlTextWriter(sw);
            writer.WriteStartDocument();
            writer.WriteStartElement("soap", Soap.Envelope, envelopeNs);
            writer.WriteAttributeString("xmlns", "soap", null, envelopeNs);
            if (isEncoded) {
                writer.WriteAttributeString("xmlns", "soapenc", null, encodingNs);
                writer.WriteAttributeString("xmlns", "tns", null, clientType.serviceNamespace);
                writer.WriteAttributeString("xmlns", "types", null, SoapReflector.GetEncodedNamespace(clientType.serviceNamespace, clientType.serviceDefaultIsEncoded));
            }
            writer.WriteAttributeString("xmlns", "xsi", null, XmlSchema.InstanceNamespace);
            writer.WriteAttributeString("xmlns", "xsd", null, XmlSchema.Namespace);
            SoapHeaderHandling.WriteHeaders(writer, method.inHeaderSerializer, message.Headers, method.inHeaderMappings, SoapHeaderDirection.In, isEncoded, clientType.serviceNamespace, clientType.serviceDefaultIsEncoded, envelopeNs);
            writer.WriteStartElement(Soap.Body, envelopeNs);
            if (isEncoded)
                writer.WriteAttributeString("soap", Soap.EncodingStyle, null, encodingNs);
            // SOAP12: not using encodingStyle
            //method.parameterSerializer.Serialize(writer, message.GetParameterValues(), null, isEncoded ? encodingNs : null);
            method.parameterSerializer.Serialize(writer, message.GetParameterValues(), null);
            writer.WriteEndElement();
            writer.WriteEndElement();
            writer.Flush();

            // run the after serialize extension pass. 
            message.SetStage(SoapMessageStage.AfterSerialize);
            message.RunExtensions(message.initializedExtensions);
        }

        object[] ReadResponse(SoapClientMessage message, WebResponse response, Stream responseStream, bool asyncCall) {
            SoapClientMethod method = message.Method;

            // CONSIDER,yannc: use the SoapExtensionStream here as well so we throw exceptions
            //      : if the extension touches stream properties/methods in before deserialize.
            // note that if there is an error status code then the response might be content-type=text/plain.
            HttpWebResponse httpResponse = response as HttpWebResponse;
            int statusCode = httpResponse != null ? (int)httpResponse.StatusCode : -1;
            if (statusCode >= 300 && statusCode != 500 && statusCode != 400)
                throw new WebException(RequestResponseUtils.CreateResponseExceptionString(httpResponse, responseStream), null, 
                    WebExceptionStatus.ProtocolError, httpResponse);

            message.Headers.Clear();
            message.SetStream(responseStream);
            message.InitExtensionStreamChain(message.initializedExtensions);

            message.SetStage(SoapMessageStage.BeforeDeserialize);
            message.ContentType = response.ContentType;
            message.ContentEncoding = response.Headers[ContentType.ContentEncoding];
            message.RunExtensions(message.initializedExtensions);

            if (method.oneWay && (httpResponse == null || (int)httpResponse.StatusCode != 500)) {
                return new object[0];
            }

            // this statusCode check is just so we don't repeat the contentType check we did above
            if (!ContentType.IsSoap(message.ContentType)) {
                // special-case 400 since we exempted it above on the off-chance it might be a soap 1.2 sender fault. 
                // based on the content-type, it looks like it's probably just a regular old 400
                if (statusCode == 400) 
                    throw new WebException(RequestResponseUtils.CreateResponseExceptionString(httpResponse, responseStream), null, 
                        WebExceptionStatus.ProtocolError, httpResponse);
                else
                    throw new InvalidOperationException(Res.GetString(Res.WebResponseContent, message.ContentType, HttpContentType) +
                                    "\r\n" +
                                    RequestResponseUtils.CreateResponseExceptionString(response, responseStream));
            }

            Encoding enc = RequestResponseUtils.GetEncoding(message.ContentType);

            // perf fix: changed buffer size passed to StreamReader
            int bufferSize;
            if (asyncCall || httpResponse == null)
                bufferSize = 512;
            else {
                int contentLength = (int)httpResponse.ContentLength;
                if (contentLength == -1)
                    bufferSize = 8000;
                else if (contentLength <= 16000)
                    bufferSize = contentLength;
                else
                    bufferSize = 16000;
            }
            XmlTextReader reader;
            if (enc != null)
                reader = new XmlTextReader(new StreamReader(message.Stream, enc, true, bufferSize));
            else
                // CONSIDER: do i need to pass a buffer size somehow?
                reader = new XmlTextReader(message.Stream);
            
            reader.Normalization = true;
            reader.XmlResolver = null;
            reader.MoveToContent();
            // should be able to handle no ns, soap 1.1 ns, or soap 1.2 ns
            string encodingNs = EncodingNs;
            string envelopeNs = reader.NamespaceURI;
            if (envelopeNs == null || envelopeNs.Length == 0)
                // ok to omit namespace -- assume correct version
                reader.ReadStartElement(Soap.Envelope);
            else if (reader.NamespaceURI == Soap.Namespace)
                reader.ReadStartElement(Soap.Envelope, Soap.Namespace);
            else if (reader.NamespaceURI == Soap12.Namespace)
                reader.ReadStartElement(Soap.Envelope, Soap12.Namespace);
            else
                throw new SoapException(Res.GetString(Res.WebInvalidEnvelopeNamespace, envelopeNs, EnvelopeNs), SoapException.VersionMismatchFaultCode);

            reader.MoveToContent();
            SoapHeaderHandling headerHandler = new SoapHeaderHandling();
            headerHandler.ReadHeaders(reader, method.outHeaderSerializer, message.Headers, method.outHeaderMappings, SoapHeaderDirection.Out | SoapHeaderDirection.Fault, envelopeNs, method.use == SoapBindingUse.Encoded ? encodingNs : null);
            reader.MoveToContent();
            reader.ReadStartElement(Soap.Body, envelopeNs);
            reader.MoveToContent();
            if (reader.IsStartElement(Soap.Fault, envelopeNs)) {
                message.SetException(ReadSoapException(reader));
            } 
            else {
                if (method.oneWay) {
                    reader.Skip();
                    message.SetParameterValues(new object[0]);
                }
                else {
                    // SOAP12: not using encodingStyle
                    //message.SetParameterValues((object[])method.returnSerializer.Deserialize(reader, method.use == SoapBindingUse.Encoded ? encodingNs : null));
                    message.SetParameterValues((object[])method.returnSerializer.Deserialize(reader));
                }
            }

            while (reader.NodeType == XmlNodeType.Whitespace) reader.Skip();
            if (reader.NodeType == XmlNodeType.None) reader.Skip();
            else reader.ReadEndElement();
            while (reader.NodeType == XmlNodeType.Whitespace) reader.Skip();
            if (reader.NodeType == XmlNodeType.None) reader.Skip();
            else reader.ReadEndElement();

            message.SetStage(SoapMessageStage.AfterDeserialize);
            message.RunExtensions(message.initializedExtensions);
            SoapHeaderHandling.SetHeaderMembers(message.Headers, this, method.outHeaderMappings, SoapHeaderDirection.Out | SoapHeaderDirection.Fault, true);

            if (message.Exception != null) throw message.Exception;
            return message.GetParameterValues();        
        }

        SoapException ReadSoapException(XmlReader reader) {
            XmlQualifiedName faultCode = XmlQualifiedName.Empty;
            string faultString = null;
            string faultActor = null;
            string faultRole = null;
            XmlNode detail = null;
            SoapFaultSubcode subcode = null;
            bool soap12 = (reader.NamespaceURI == Soap12.Namespace);
            if (reader.IsEmptyElement) {
                reader.Skip();
            }
            else {
                reader.ReadStartElement();
                reader.MoveToContent();
                while (reader.NodeType != XmlNodeType.EndElement && reader.NodeType != XmlNodeType.None) {
                    if (reader.NamespaceURI == Soap.Namespace || reader.NamespaceURI == Soap12.Namespace || reader.NamespaceURI == null || reader.NamespaceURI.Length == 0) {
                        if (reader.LocalName == Soap.FaultCode || reader.LocalName == Soap12.FaultCode) {
                            if (soap12)
                                faultCode = ReadSoap12FaultCode(reader, out subcode);
                            else
                                faultCode = ReadFaultCode(reader);
                        }
                        else if (reader.LocalName == Soap.FaultString || reader.LocalName == Soap12.FaultReason) {
                            faultString = reader.ReadElementString();
                        }
                        else if (reader.LocalName == Soap.FaultActor || reader.LocalName == Soap12.FaultNode) {
                            faultActor = reader.ReadElementString();
                        }
                        else if (reader.LocalName == Soap.FaultDetail || reader.LocalName == Soap12.FaultDetail) {
                            detail = new XmlDocument().ReadNode(reader);
                        }
                        else if (reader.LocalName == Soap12.FaultRole) {
                            faultRole = reader.ReadElementString();
                        }
                        else {
                            reader.Skip();
                        }
                    }
                    else {
                        reader.Skip();
                    }
                    reader.MoveToContent();
                }
                while (reader.NodeType == XmlNodeType.Whitespace) reader.Skip();
                if (reader.NodeType == XmlNodeType.None) reader.Skip();
                else reader.ReadEndElement();
            }
            if (detail != null)
                return new SoapException(faultString, faultCode, faultActor, faultRole, detail, subcode, null);
            else
                return new SoapHeaderException(faultString, faultCode, faultActor, faultRole, subcode, null);
        }

        private XmlQualifiedName ReadSoap12FaultCode(XmlReader reader, out SoapFaultSubcode subcode) {
            ArrayList codes = new ArrayList();
            SoapFaultSubcode code = ReadSoap12FaultCodesRecursive(reader, 0);
            if (code == null) {
                subcode = null;
                return null;
            }
            else {
                subcode = code.Subcode;
                return code.Code;
            }
        }
         
        private SoapFaultSubcode ReadSoap12FaultCodesRecursive(XmlReader reader, int depth) {
            if (depth > 100) return null;
            if (reader.IsEmptyElement) {
                reader.Skip();
                return null;
            }
            XmlQualifiedName code = null;
            SoapFaultSubcode subcode = null;
            reader.ReadStartElement();
            reader.MoveToContent();
            while (reader.NodeType != XmlNodeType.EndElement && reader.NodeType != XmlNodeType.None) {
                if (reader.NamespaceURI == Soap12.Namespace || reader.NamespaceURI == null || reader.NamespaceURI.Length == 0) {
                    if (reader.LocalName == Soap12.FaultCodeValue) {
                        code = ReadFaultCode(reader);
                    }
                    else if (reader.LocalName == Soap12.FaultSubcode) {
                        subcode = ReadSoap12FaultCodesRecursive(reader, depth + 1);
                    }
                    else {
                        reader.Skip();
                    }
                }
                else {
                    reader.Skip();
                }
                reader.MoveToContent();
            }
            while (reader.NodeType == XmlNodeType.Whitespace) reader.Skip();
            if (reader.NodeType == XmlNodeType.None) reader.Skip();
            else reader.ReadEndElement();
            return new SoapFaultSubcode(code, subcode);
        }

        private XmlQualifiedName ReadFaultCode(XmlReader reader) {
            if (reader.IsEmptyElement) {
                reader.Skip();
                return null;
            }
            reader.ReadStartElement();
            string qnameValue = reader.ReadString();
            int colon = qnameValue.IndexOf(":");
            string ns = reader.NamespaceURI;
            if (colon >= 0) {
                string prefix = qnameValue.Substring(0, colon);
                ns = reader.LookupNamespace(prefix);
                if (ns == null)
                    throw new InvalidOperationException(Res.GetString(Res.WebQNamePrefixUndefined, prefix));
            }
            reader.ReadEndElement();
            
            return new XmlQualifiedName(qnameValue.Substring(colon+1), ns);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapextensionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapExtensionAttribute.uex' path='docs/doc[@for="SoapExtensionAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class SoapExtensionAttribute : System.Attribute {

        /// <include file='doc\SoapExtensionAttribute.uex' path='docs/doc[@for="SoapExtensionAttribute.ExtensionType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract Type ExtensionType {
            get;
        }

        /// <include file='doc\SoapExtensionAttribute.uex' path='docs/doc[@for="SoapExtensionAttribute.Priority"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract int Priority {
            get; set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapdocumentserviceattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapDocumentServiceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System;
    using System.Web.Services.Description;
    using System.Reflection;
    using System.Xml.Serialization;

    /// <include file='doc\SoapDocumentServiceAttribute.uex' path='docs/doc[@for="SoapDocumentServiceAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class SoapDocumentServiceAttribute : Attribute {
        SoapBindingUse use = SoapBindingUse.Default;
        SoapParameterStyle paramStyle = SoapParameterStyle.Default;
        SoapServiceRoutingStyle routingStyle = SoapServiceRoutingStyle.SoapAction;

        /// <include file='doc\SoapDocumentServiceAttribute.uex' path='docs/doc[@for="SoapDocumentServiceAttribute.SoapDocumentServiceAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapDocumentServiceAttribute() {
        }

        /// <include file='doc\SoapDocumentServiceAttribute.uex' path='docs/doc[@for="SoapDocumentServiceAttribute.SoapDocumentServiceAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapDocumentServiceAttribute(SoapBindingUse use) {
            this.use = use;
        }

        /// <include file='doc\SoapDocumentServiceAttribute.uex' path='docs/doc[@for="SoapDocumentServiceAttribute.SoapDocumentServiceAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapDocumentServiceAttribute(SoapBindingUse use, SoapParameterStyle paramStyle) {
            this.use = use;
            this.paramStyle = paramStyle;
        }

        /// <include file='doc\SoapDocumentServiceAttribute.uex' path='docs/doc[@for="SoapDocumentServiceAttribute.Use"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapBindingUse Use {
            get { return use; }
            set { use = value; }
        }

        /// <include file='doc\SoapDocumentServiceAttribute.uex' path='docs/doc[@for="SoapDocumentServiceAttribute.ParameterStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapParameterStyle ParameterStyle {
            get { return paramStyle; }
            set { paramStyle = value; }
        }

        /// <include file='doc\SoapDocumentServiceAttribute.uex' path='docs/doc[@for="SoapDocumentServiceAttribute.RoutingStyle"]/*' />
        public SoapServiceRoutingStyle RoutingStyle {
            get { return routingStyle; }
            set { routingStyle = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapextension.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapExtension.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapExtension.uex' path='docs/doc[@for="SoapExtension"]/*' />
    public abstract class SoapExtension {

        /// <include file='doc\SoapExtension.uex' path='docs/doc[@for="SoapExtension.GetInitializer"]/*' />
        public abstract object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute);

        /// <include file='doc\SoapExtension.uex' path='docs/doc[@for="SoapExtension.GetInitializer1"]/*' />
        public abstract object GetInitializer(Type serviceType);

        /// <include file='doc\SoapExtension.uex' path='docs/doc[@for="SoapExtension.Initialize"]/*' />
        public abstract void Initialize(object initializer);

        /// <include file='doc\SoapExtension.uex' path='docs/doc[@for="SoapExtension.ProcessMessage"]/*' />
        public abstract void ProcessMessage(SoapMessage message);
        
        /// <include file='doc\SoapExtension.uex' path='docs/doc[@for="SoapExtension.ChainStream"]/*' />
        public virtual Stream ChainStream(Stream stream) {
            return stream;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Xml;
    using System.Xml.Serialization;

    /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException"]/*' />
    /// <devdoc>
    ///    <para>SoapException is the only mechanism for raising exceptions when a Web
    ///       Method is called over SOAP. A SoapException can either be generated
    ///       by the .Net Runtime or by a Web Service Method.
    ///       The .Net Runtime can generate an SoapException, if a response to a request
    ///       that is malformed. A Web Service Method can generate a SoapException by simply
    ///       generating an Exception within the Web Service Method, if the client accessed the method
    ///       over SOAP. Any time a Web Service Method throws an exception, that exception
    ///       is caught on the server and wrapped inside a new SoapException.</para>
    /// </devdoc>
    public class SoapException : SystemException {
        XmlQualifiedName code = XmlQualifiedName.Empty;
        string actor;
        string role;
        System.Xml.XmlNode detail;
        SoapFaultSubcode subcode;

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.ServerFaultCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly XmlQualifiedName ServerFaultCode = new XmlQualifiedName(Soap.ServerCode, Soap.Namespace);
        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.ClientFaultCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly XmlQualifiedName ClientFaultCode = new XmlQualifiedName(Soap.ClientCode, Soap.Namespace);
        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.VersionMismatchFaultCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly XmlQualifiedName VersionMismatchFaultCode = new XmlQualifiedName(Soap.VersionMismatchCode, Soap.Namespace);
        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.MustUnderstandFaultCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly XmlQualifiedName MustUnderstandFaultCode = new XmlQualifiedName(Soap.MustUnderstandCode, Soap.Namespace);
        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.DetailElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        // NOTE, stefanph: The SOAP 1.1 is unclear on whether the detail element can or should be qualified.
        // Based on consensus about the intent, we will not qualify it.
        public static readonly XmlQualifiedName DetailElementName = new XmlQualifiedName(Soap.FaultDetail, "");

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.IsServerFaultCode"]/*' />
        internal static bool IsServerFaultCode(XmlQualifiedName code) {
            return code == ServerFaultCode || code == Soap12FaultCodes.ReceiverFaultCode;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.IsClientFaultCode"]/*' />
        internal static bool IsClientFaultCode(XmlQualifiedName code) {
            return code == ClientFaultCode || code == Soap12FaultCodes.SenderFaultCode;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.IsVersionMismatchFaultCode"]/*' />
        internal static bool IsVersionMismatchFaultCode(XmlQualifiedName code) {
            return code == VersionMismatchFaultCode || code == Soap12FaultCodes.VersionMismatchFaultCode;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.IsMustUnderstandFaultCode"]/*' />
        internal static bool IsMustUnderstandFaultCode(XmlQualifiedName code) {
            return code == MustUnderstandFaultCode || code == Soap12FaultCodes.MustUnderstandFaultCode;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.Protocols.SoapException'/> class, setting <see cref='System.Exception.Message'/> to <paramref name="message"/>, <see cref='System.Web.Services.Protocols.SoapException.Code'/> to
        /// <paramref name="code"/> and <see cref='System.Web.Services.Protocols.SoapException.Actor'/> to <paramref name="actor"/>.</para>
        /// </devdoc>
        public SoapException(string message, XmlQualifiedName code, string actor) : base(message) { 
            this.code = code;
            this.actor = actor;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.Protocols.SoapException'/> class, setting <see cref='System.Exception.Message'/> to 
        /// <paramref name="message"/>, <see cref='System.Web.Services.Protocols.SoapException.Code'/> to <paramref name="code, 
        ///    "/><see cref='System.Web.Services.Protocols.SoapException.Actor'/> to <paramref name="actor
        ///    "/>and <see cref='System.Exception.InnerException'/> to <paramref name="innerException"/> .</para>
        /// </devdoc>
        public SoapException(string message, XmlQualifiedName code, string actor, Exception innerException) : base(message, innerException) { 
            this.code = code;
            this.actor = actor;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.Protocols.SoapException'/> class, setting <see cref='System.Exception.Message'/> to
        /// <paramref name="message "/>and<paramref name=" "/>
        /// <see cref='System.Web.Services.Protocols.SoapException.Code'/> 
        /// to <paramref name="code"/>.</para>
        /// </devdoc>
        public SoapException(string message, XmlQualifiedName code) : base(message) { 
            this.code = code;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.Protocols.SoapException'/> class, setting <see cref='System.Exception.Message'/> to
        /// <paramref name="message"/>, <see cref='System.Web.Services.Protocols.SoapException.Code'/> to <paramref name="code "/>and 
        /// <see cref='System.Exception.InnerException'/> 
        /// to <paramref name="innerException"/>.</para>
        /// </devdoc>
        public SoapException(string message, XmlQualifiedName code, Exception innerException) : base(message, innerException) { 
            this.code = code;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapException(string message, XmlQualifiedName code, string actor, System.Xml.XmlNode detail) : base(message) {
            this.code = code;
            this.actor = actor;
            this.detail = detail;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapException(string message, XmlQualifiedName code, string actor, System.Xml.XmlNode detail, Exception innerException) : base(message, innerException) {
            this.code = code;
            this.actor = actor;
            this.detail = detail;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException6"]/*' />
        // SOAP12: made this internal
        internal SoapException(string message, XmlQualifiedName code, SoapFaultSubcode subcode) : base(message) {
            this.code = code;
            this.subcode = subcode;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.SoapException7"]/*' />
        // SOAP12: made this internal
        internal SoapException(string message, XmlQualifiedName code, string actor, string role, System.Xml.XmlNode detail, SoapFaultSubcode subcode, Exception innerException) : base(message, innerException) {
            this.code = code;
            this.actor = actor;
            this.role = role;
            this.detail = detail;
            this.subcode = subcode;
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.Actor"]/*' />
        /// <devdoc>
        ///    The piece of code that caused the exception.
        ///    Typically, an URL to a Web Service Method.
        /// </devdoc>
        public string Actor {
            get { return actor == null ? string.Empty : actor; }
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.Node"]/*' />
        // this is semantically the same as Actor so we use the same field but we offer a second property
        // in case the user is thinking in soap 1.2
        // SOAP12: made this internal
        internal string Node {
            get { return actor == null ? string.Empty : actor; }
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.Role"]/*' />
        // SOAP12: made this internal
        internal string Role {
            get { return role == null ? string.Empty : role; }
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.Code"]/*' />
        /// <devdoc>
        ///    <para>The type of error that occurred.</para>
        /// </devdoc>
        public XmlQualifiedName Code {    
            get { return code; }
        }

        // the <soap:detail> element. If null, the <detail> element was not present in the <fault> element.
        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.Detail"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public System.Xml.XmlNode Detail {
            get {
                return detail;
            }
        }

        /// <include file='doc\SoapException.uex' path='docs/doc[@for="SoapException.Subcode"]/*' />
        // SOAP12: made this internal
        internal SoapFaultSubcode Subcode {
            get {
                return subcode; 
            }
        }

        // helper function that allows us to pass dummy subcodes around but clear them before they get to the user
        internal void ClearSubcode() {
            if (subcode != null)
                subcode = subcode.Subcode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapextensionstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapExtensionStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
	using System;
	using System.IO;
	using System.Web.Services;

    internal class SoapExtensionStream : Stream {
        internal Stream innerStream;
        bool streamReady;

        internal SoapExtensionStream() {
        }

        private bool EnsureStreamReady() {
            if (streamReady) return true;
            throw new InvalidOperationException(Res.GetString(Res.WebBadStreamState));            
        }

        public override bool CanRead {
            get {
                EnsureStreamReady();
                return innerStream.CanRead;
            }
        }

        public override bool CanSeek {
            get {
                EnsureStreamReady();
                return innerStream.CanSeek;
            }
        }

        public override bool CanWrite {
            get {
                EnsureStreamReady();
                return innerStream.CanWrite;
            }
        }

        public override long Length {
            get {
                EnsureStreamReady();
                return innerStream.Length;
            }
        }

        public override long Position {
            get {
                EnsureStreamReady();
                return innerStream.Position;
            }
            set {
                EnsureStreamReady();
                innerStream.Position = value;
            }
        }

        public override void Close() {
            EnsureStreamReady();
            innerStream.Close();
        }

        public override void Flush() {
            EnsureStreamReady();
            innerStream.Flush();
        }

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, Object state) {
            EnsureStreamReady();
            return innerStream.BeginRead(buffer, offset, count, callback, state);
        }

        public override int EndRead(IAsyncResult asyncResult) {
            EnsureStreamReady();
            return innerStream.EndRead(asyncResult);
        }

        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, Object state) {
            EnsureStreamReady();
            return innerStream.BeginWrite(buffer, offset, count, callback, state);
        }

        public override void EndWrite(IAsyncResult asyncResult) {
            EnsureStreamReady();
            innerStream.EndWrite(asyncResult);
        }

        public override long Seek(long offset, SeekOrigin origin) {
            EnsureStreamReady();
            return innerStream.Seek(offset, origin);
        }

        public override void SetLength(long value) {
            EnsureStreamReady();
            innerStream.SetLength(value);
        }

        public override int Read(byte[] buffer, int offset, int count) {
            EnsureStreamReady();
            return innerStream.Read(buffer, offset, count);
        }

        public override int ReadByte() {
            EnsureStreamReady();
            return innerStream.ReadByte();
        }

        public override void Write(byte[] buffer, int offset, int count) {
            EnsureStreamReady();
            innerStream.Write(buffer, offset, count);
        }

        public override void WriteByte(byte value) {
            EnsureStreamReady();
            innerStream.WriteByte(value);
        }

        internal void SetInnerStream(Stream stream) {
            innerStream = stream;
        }

        internal void SetStreamReady() {
            streamReady = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapfaultcodes.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Xml;
    using System.Xml.Serialization;

    /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes"]/*' />
    internal sealed class Soap12FaultCodes {

        private Soap12FaultCodes() {
        }

        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.ReceiverFaultCode"]/*' />
        public static readonly XmlQualifiedName ReceiverFaultCode = new XmlQualifiedName(Soap12.ReceiverCode, Soap12.Namespace);
        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.SenderFaultCode"]/*' />
        public static readonly XmlQualifiedName SenderFaultCode = new XmlQualifiedName(Soap12.SenderCode, Soap12.Namespace);
        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.VersionMismatchFaultCode"]/*' />
        public static readonly XmlQualifiedName VersionMismatchFaultCode = new XmlQualifiedName(Soap12.VersionMismatchCode, Soap12.Namespace);
        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.MustUnderstandFaultCode"]/*' />
        public static readonly XmlQualifiedName MustUnderstandFaultCode = new XmlQualifiedName(Soap12.MustUnderstandCode, Soap12.Namespace);
        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.DataEncodingUnknownFaultCode"]/*' />
        public static readonly XmlQualifiedName DataEncodingUnknownFaultCode = new XmlQualifiedName(Soap12.DataEncodingUnknownCode, Soap12.Namespace);

        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.RpcProcedureNotPresentFaultCode"]/*' />
        public static readonly XmlQualifiedName RpcProcedureNotPresentFaultCode = new XmlQualifiedName(Soap12.RpcProcedureNotPresentSubcode, Soap12.RpcNamespace);
        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.RpcBadArgumentsFaultCode"]/*' />
        public static readonly XmlQualifiedName RpcBadArgumentsFaultCode = new XmlQualifiedName(Soap12.RpcBadArgumentsSubcode, Soap12.RpcNamespace);
    
        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.EncodingMissingIDFaultCode"]/*' />
        public static readonly XmlQualifiedName EncodingMissingIDFaultCode = new XmlQualifiedName(Soap12.EncodingMissingIDFaultSubcode, Soap12.Encoding);
        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="Soap12FaultCodes.EncodingUntypedValueFaultCode"]/*' />
        public static readonly XmlQualifiedName EncodingUntypedValueFaultCode = new XmlQualifiedName(Soap12.EncodingUntypedValueFaultSubcode, Soap12.Encoding);
    
        internal static readonly XmlQualifiedName UnsupportedMediaTypeFaultCode = new XmlQualifiedName("UnsupportedMediaType", "http://microsoft.com/soap/");
    }

    /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="SoapFaultSubcode"]/*' />
    internal class SoapFaultSubcode {
        XmlQualifiedName code;
        SoapFaultSubcode subcode;

        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="SoapFaultSubcode.SoapFaultSubcode"]/*' />
        public SoapFaultSubcode(XmlQualifiedName code) : this(code, null) {
        }

        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="SoapFaultSubcode.SoapFaultSubcode1"]/*' />
        public SoapFaultSubcode(XmlQualifiedName code, SoapFaultSubcode subcode) {
            this.code = code;
            this.subcode = subcode;
        }

        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="SoapFaultSubcode.Code"]/*' />
        public XmlQualifiedName Code {
            get { return code; }
        }

        /// <include file='doc\SoapFaultCodes.uex' path='docs/doc[@for="SoapFaultSubcode.Subcode"]/*' />
        public SoapFaultSubcode Subcode {
            get { return subcode; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapheader.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapHeader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Xml;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;
    using System.Threading;
    using System.Security.Permissions;
    
    /// <include file='doc\SoapHeader.uex' path='docs/doc[@for="SoapHeader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlType(IncludeInSchema=false), SoapType(IncludeInSchema=false)]
    public abstract class SoapHeader {
        string actor;
        bool mustUnderstand;
        bool didUnderstand;
        internal SoapProtocolVersion version = SoapProtocolVersion.Default;

        /// <include file='doc\SoapHeader.uex' path='docs/doc[@for="SoapHeader.MustUnderstandEncoded"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("mustUnderstand", Namespace="http://schemas.xmlsoap.org/soap/envelope/"),
         SoapAttribute("mustUnderstand", Namespace="http://schemas.xmlsoap.org/soap/envelope/"), 
         DefaultValue("0")]
        public string EncodedMustUnderstand {
            get { return version != SoapProtocolVersion.Soap12 && MustUnderstand ? "1" : "0"; }
            set {
                switch(value){
                    case "false":
                    case "0" : MustUnderstand = false; break;
                    case "true":
                    case "1" : MustUnderstand = true; break;
                    default  : throw new ArgumentException(Res.GetString(Res.WebHeaderInvalidMustUnderstand, value));
                }
            }
        }

        /// <include file='doc\SoapHeader.uex' path='docs/doc[@for="SoapHeader.EncodedMustUnderstand12"]/*' />
        [XmlAttribute("mustUnderstand", Namespace=Soap12.Namespace),
        SoapAttribute("mustUnderstand", Namespace=Soap12.Namespace), 
        DefaultValue("0")]
        // SOAP12: made this internal
        internal string EncodedMustUnderstand12 {
            get { return version != SoapProtocolVersion.Soap11 && MustUnderstand ? "1" : "0"; }
            set {
                EncodedMustUnderstand = value;
            }
        }

        /// <include file='doc\SoapHeader.uex' path='docs/doc[@for="SoapHeader.MustUnderstand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore, SoapIgnore]
        public bool MustUnderstand {
            get { return InternalMustUnderstand; }
            set { InternalMustUnderstand = value; }
        }

        internal virtual bool InternalMustUnderstand {
            [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
            get { return mustUnderstand; }
            [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
            set { mustUnderstand = value; }
        }

        /// <include file='doc\SoapHeader.uex' path='docs/doc[@for="SoapHeader.Actor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("actor", Namespace="http://schemas.xmlsoap.org/soap/envelope/"), 
         SoapAttribute("actor", Namespace="http://schemas.xmlsoap.org/soap/envelope/"), 
         DefaultValue("")]
        public string Actor {
            get { return version != SoapProtocolVersion.Soap12 ? InternalActor : ""; }
            set { InternalActor = value; }
        }

        /// <include file='doc\SoapHeader.uex' path='docs/doc[@for="SoapHeader.Role"]/*' />
        [XmlAttribute("role", Namespace=Soap12.Namespace), 
        SoapAttribute("role", Namespace=Soap12.Namespace), 
        DefaultValue("")]
        // SOAP12: made this internal
        internal string Role {
            get { return version != SoapProtocolVersion.Soap11 ? InternalActor : ""; }
            set { InternalActor = value; }
        }

        internal virtual string InternalActor {
            [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
            get { return actor == null ? string.Empty : actor; }
            [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
            set { actor = value; }
        }

        /// <include file='doc\SoapHeader.uex' path='docs/doc[@for="SoapHeader.DidUnderstand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore, SoapIgnore]
        public bool DidUnderstand {
            get { return didUnderstand; }
            set { didUnderstand = value; }
        }
    }

    internal class SoapHeaderMapping {
        internal Type headerType;
        internal bool repeats;
        internal bool custom;
        internal SoapHeaderDirection direction;
        internal MemberInfo memberInfo;
    }

    internal class SoapHeaderHandling {

        SoapHeaderCollection unknownHeaders;
        SoapHeaderCollection unreferencedHeaders;
        int currentThread;
        string envelopeNs;

        void OnUnknownElement(object sender, XmlElementEventArgs e) {
            if (Thread.CurrentThread.GetHashCode() != this.currentThread) return;
            if (e.Element == null) return;
            SoapUnknownHeader header = new SoapUnknownHeader();
            header.Element = e.Element;
            unknownHeaders.Add(header);
        }

        void OnUnreferencedObject(object sender, UnreferencedObjectEventArgs e) {
            if (Thread.CurrentThread.GetHashCode() != this.currentThread) return;
            object o = e.UnreferencedObject;
            if (o == null) return;
            if (typeof(SoapHeader).IsAssignableFrom(o.GetType())) {
                unreferencedHeaders.Add((SoapHeader)o);
            }
        }

        internal void ReadHeaders(XmlReader reader, XmlSerializer serializer, SoapHeaderCollection headers, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, string envelopeNs, string encodingStyle) {
            reader.MoveToContent();
            if (!reader.IsStartElement(Soap.Header, envelopeNs)) return;
            if (reader.IsEmptyElement) { reader.Skip(); return; }

            this.unknownHeaders = new SoapHeaderCollection();
            this.unreferencedHeaders = new SoapHeaderCollection();
            // thread hash code is used to differentiate between deserializations in event callbacks
            this.currentThread = Thread.CurrentThread.GetHashCode();
            this.envelopeNs = envelopeNs;

            XmlElementEventHandler unknownHandler = new XmlElementEventHandler(this.OnUnknownElement);
            UnreferencedObjectEventHandler unreferencedHandler = new UnreferencedObjectEventHandler(this.OnUnreferencedObject);

            serializer.UnknownElement += unknownHandler;
            serializer.UnreferencedObject += unreferencedHandler;

            reader.ReadStartElement();
            reader.MoveToContent();
            
            // SOAP12: not using encodingStyle
            //object[] headerValues = (object[])serializer.Deserialize(reader, encodingStyle);
            object[] headerValues = (object[])serializer.Deserialize(reader);
            for (int i = 0; i < headerValues.Length; i++) {
                if (headerValues[i] != null) {
                    SoapHeader header = (SoapHeader)headerValues[i];
                    header.DidUnderstand = true;
                    headers.Add(header);
                }
            }

            serializer.UnknownElement -= unknownHandler;
            serializer.UnreferencedObject -= unreferencedHandler;
            this.currentThread = 0;
            this.envelopeNs = null;

            foreach (SoapHeader header in this.unreferencedHeaders) {
                headers.Add(header);
            }
            this.unreferencedHeaders = null;
            
            foreach (SoapHeader header in this.unknownHeaders) {
                headers.Add(header);
            }
            this.unknownHeaders = null;

            while (reader.NodeType == XmlNodeType.Whitespace) reader.Skip();

            if (reader.NodeType == XmlNodeType.None) reader.Skip();
            else reader.ReadEndElement();
        }

        internal static void WriteHeaders(XmlWriter writer, XmlSerializer serializer, SoapHeaderCollection headers, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, bool isEncoded, string defaultNs, bool serviceDefaultIsEncoded, string envelopeNs) {
            if (headers.Count == 0) return;
            if (isEncoded && writer is XmlSpecialTextWriter) {
                ((XmlSpecialTextWriter)writer).EncodeIds = true;
            }
            writer.WriteStartElement(Soap.Header, envelopeNs);
            // SOAP12: always soap 1.1, not using encodingStyle;
            //SoapProtocolVersion version;
            SoapProtocolVersion version = SoapProtocolVersion.Soap11;
            // SOAP12: not using encodingStyle
            /*string encodingStyle;
            if (envelopeNs == Soap12.Namespace) {
                version = SoapProtocolVersion.Soap12;
                encodingStyle = Soap12.Encoding;
            }
            else {
                version = SoapProtocolVersion.Soap11;
                encodingStyle = Soap.Encoding;
            }*/

            int unknownHeaderCount = 0;
            ArrayList otherHeaders = new ArrayList();
            SoapHeader[] headerArray = new SoapHeader[mappings.Length];
            bool[] headerSet = new bool[headerArray.Length];
            for (int i = 0; i < headers.Count; i++) {
                SoapHeader header = headers[i];
                if (header == null) continue;
                int headerPosition;
                header.version = version;
                if (header is SoapUnknownHeader) {
                    otherHeaders.Add(header);
                    unknownHeaderCount++;
                }
                else if ((headerPosition = FindMapping(mappings, header, direction)) >= 0 && !headerSet[headerPosition]) {
                    headerArray[headerPosition] = header;
                    headerSet[headerPosition] = true;
                }
                else {
                    otherHeaders.Add(header);
                }
            }
            int otherHeaderCount = otherHeaders.Count - unknownHeaderCount;
            if (isEncoded && otherHeaderCount > 0) {
                SoapHeader[] newHeaderArray = new SoapHeader[mappings.Length + otherHeaderCount];
                headerArray.CopyTo(newHeaderArray, 0);
                
                // fill in the non-statically known headers (otherHeaders) starting after the statically-known ones
                int count = mappings.Length;
                for (int i = 0; i < otherHeaders.Count; i++) {
                    if (!(otherHeaders[i] is SoapUnknownHeader))
                        newHeaderArray[count++] = (SoapHeader)otherHeaders[i];
                }

                headerArray = newHeaderArray;
            }
                
            // SOAP12: not using encodingStyle
            //serializer.Serialize(writer, headerArray, null, isEncoded ? encodingStyle : null);
            serializer.Serialize(writer, headerArray, null);

            foreach (SoapHeader header in otherHeaders) {
                if (header is SoapUnknownHeader) {
                    SoapUnknownHeader unknown = (SoapUnknownHeader)header;
                    if (unknown.Element != null) 
                        unknown.Element.WriteTo(writer);
                }
                else if (!isEncoded) { // encoded headers already appended to members mapping
                    string ns = SoapReflector.GetLiteralNamespace(defaultNs, serviceDefaultIsEncoded);
                    new XmlSerializer(header.GetType(), ns).Serialize(writer, header);
                }
            }

            // reset the soap version
            for (int i = 0; i < headers.Count; i++) {
                SoapHeader header = headers[i];
                if (header != null)
                    header.version = SoapProtocolVersion.Default;
            }

            writer.WriteEndElement();
            writer.Flush();

            if (isEncoded && writer is XmlSpecialTextWriter) {
                ((XmlSpecialTextWriter)writer).EncodeIds = false;
            }
        }

        internal static void WriteUnknownHeaders(XmlWriter writer, SoapHeaderCollection headers, string envelopeNs) {
            bool first = true;
            foreach (SoapHeader header in headers) {
                SoapUnknownHeader unknown = header as SoapUnknownHeader;
                if (unknown != null) {
                    if (first) {
                        writer.WriteStartElement(Soap.Header, envelopeNs);
                        first = false;
                    }
                    if (unknown.Element != null)
                        unknown.Element.WriteTo(writer);
                }
            }
            if (!first)
                writer.WriteEndElement(); // </soap:Header>
        }

        internal static void SetHeaderMembers(SoapHeaderCollection headers, object target, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, bool client) {
            bool[] headerHandled = new bool[headers.Count];
            for (int i = 0; i < mappings.Length; i++) {
                SoapHeaderMapping mapping = mappings[i];
                if ((mapping.direction & direction) == 0) continue;
                if (mapping.repeats) {
                    ArrayList list = new ArrayList();
                    for (int j = 0; j < headers.Count; j++) {
                        SoapHeader header = headers[j];
                        if (headerHandled[j]) continue;
                        if (mapping.headerType.IsAssignableFrom(header.GetType())) {
                            list.Add(header);
                            headerHandled[j] = true;
                        }
                    }
                    MemberHelper.SetValue(mapping.memberInfo, target, list.ToArray(mapping.headerType));
                }
                else {
                    bool handled = false;
                    for (int j = 0; j < headers.Count; j++) {
                        SoapHeader header = headers[j];
                        if (headerHandled[j]) continue;
                        if (mapping.headerType.IsAssignableFrom(header.GetType())) {
                            if (handled) {
                                header.DidUnderstand = false;
                                continue;
                            }
                            handled = true;
                            MemberHelper.SetValue(mapping.memberInfo, target, header);
                            headerHandled[j] = true;
                        }
                    }
                }
            }
            if (client) {
                for (int i = 0; i < headerHandled.Length; i++) {
                    if (!headerHandled[i]) {
                        SoapHeader header = headers[i];
                        if (header.MustUnderstand && !header.DidUnderstand) {
                            throw new SoapHeaderException(Res.GetString(Res.WebCannotUnderstandHeader, GetHeaderElementName(header)), 
                                new XmlQualifiedName(Soap.MustUnderstandCode, Soap.Namespace));
                        }
                    }
                }
            }
        }

        internal static void GetHeaderMembers(SoapHeaderCollection headers, object target, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, bool client) {
            for (int i = 0; i < mappings.Length; i++) {
                SoapHeaderMapping mapping = mappings[i];
                if ((mapping.direction & direction) == 0) continue;
                object value = MemberHelper.GetValue(mapping.memberInfo, target);
                if (mapping.repeats) {
                    object[] values = (object[])value;
                    if (values == null) continue;
                    for (int j = 0; j < values.Length; j++) {
                        if (values[j] != null) headers.Add((SoapHeader)values[j]);
                    }
                }
                else {
                    if (value != null) headers.Add((SoapHeader)value);
                }
            }
        }

        internal static void EnsureHeadersUnderstood(SoapHeaderCollection headers) {
            for (int i = 0; i < headers.Count; i++) {
                SoapHeader header = headers[i];
                if (header.MustUnderstand && !header.DidUnderstand) {
                    throw new SoapHeaderException(Res.GetString(Res.WebCannotUnderstandHeader, GetHeaderElementName(header)),
                        new XmlQualifiedName(Soap.MustUnderstandCode, Soap.Namespace));
                }
            }
        }

        static int FindMapping(SoapHeaderMapping[] mappings, SoapHeader header, SoapHeaderDirection direction) {
            Type headerType = header.GetType();
            for (int i = 0; i < mappings.Length; i++) {
                SoapHeaderMapping mapping = mappings[i];
                if ((mapping.direction & direction) == 0) continue;
                if (!mapping.custom) continue;
                if (mapping.headerType.IsAssignableFrom(headerType)) {
                    return i;
                }
            }
            return -1;
        }

        static string GetHeaderElementName(Type headerType) {
            XmlReflectionImporter importer = SoapReflector.CreateXmlImporter(null, false);

            XmlTypeMapping mapping = importer.ImportTypeMapping(headerType);
            return mapping.ElementName;
        }

        static string GetHeaderElementName(SoapHeader header) {
            if (header is SoapUnknownHeader) {
                return ((SoapUnknownHeader)header).Element.LocalName;
            }
            else {
                return GetHeaderElementName(header.GetType());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapheaderexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapHeaderException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapHeaderException.uex' path='docs/doc[@for="SoapHeaderException"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class SoapHeaderException : SoapException {
        /// <include file='doc\SoapHeaderException.uex' path='docs/doc[@for="SoapHeaderException.SoapHeaderException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeaderException(string message, XmlQualifiedName code, string actor) 
            : base(message, code, actor) { 
        }

        /// <include file='doc\SoapHeaderException.uex' path='docs/doc[@for="SoapHeaderException.SoapHeaderException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeaderException(string message, XmlQualifiedName code, string actor, Exception innerException) 
            : base(message, code, actor, innerException) { 
        }

        /// <include file='doc\SoapHeaderException.uex' path='docs/doc[@for="SoapHeaderException.SoapHeaderException2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeaderException(string message, XmlQualifiedName code)
            : base(message, code) { 
        }

        /// <include file='doc\SoapHeaderException.uex' path='docs/doc[@for="SoapHeaderException.SoapHeaderException3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeaderException(string message, XmlQualifiedName code, Exception innerException) 
            : base(message, code, innerException) { 
        }

        /// <include file='doc\SoapHeaderException.uex' path='docs/doc[@for="SoapHeaderException.SoapHeaderException4"]/*' />
        // SOAP12: made this internal
        internal SoapHeaderException(string message, XmlQualifiedName code, string actor, string role, SoapFaultSubcode subcode, Exception innerException) 
            : base(message, code, actor, role, null, subcode, innerException) {
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapheaderattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapHeaderAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Xml;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapHeaderAttribute.uex' path='docs/doc[@for="SoapHeaderAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple=true)]
    public sealed class SoapHeaderAttribute : System.Attribute {
        string memberName;
        SoapHeaderDirection direction = SoapHeaderDirection.In;
        bool required = true;

        /// <include file='doc\SoapHeaderAttribute.uex' path='docs/doc[@for="SoapHeaderAttribute.SoapHeaderAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeaderAttribute(string memberName) {
            this.memberName = memberName;
        }

        /// <include file='doc\SoapHeaderAttribute.uex' path='docs/doc[@for="SoapHeaderAttribute.MemberName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MemberName {
            get { return memberName == null ? string.Empty : memberName; }
            set { memberName = value; }
        }

        /// <include file='doc\SoapHeaderAttribute.uex' path='docs/doc[@for="SoapHeaderAttribute.Direction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeaderDirection Direction {
            get { return direction; }
            set { direction = value; }
        }

        /// <include file='doc\SoapHeaderAttribute.uex' path='docs/doc[@for="SoapHeaderAttribute.Required"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Obsolete("This property will be removed from a future version. The presence of a particular header in a SOAP message is no longer enforced", false)]
        public bool Required {
            get { return required; }
            set { required = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapheaderdirection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapHeaderDirection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapHeaderDirection.uex' path='docs/doc[@for="SoapHeaderDirection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum SoapHeaderDirection {
        /// <include file='doc\SoapHeaderDirection.uex' path='docs/doc[@for="SoapHeaderDirection.In"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        In = 0x1,
        /// <include file='doc\SoapHeaderDirection.uex' path='docs/doc[@for="SoapHeaderDirection.Out"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Out = 0x2,
        /// <include file='doc\SoapHeaderDirection.uex' path='docs/doc[@for="SoapHeaderDirection.InOut"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InOut = 0x3,
        /// <include file='doc\SoapHeaderDirection.uex' path='docs/doc[@for="SoapHeaderDirection.Fault"]/*' />
        Fault = 0x4,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapheaders.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapHeaders.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class SoapHeaderCollection : CollectionBase {
        
        /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeader this[int index] {
            get { return (SoapHeader)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(SoapHeader header) {
            return List.Add(header);
        }
        
        /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, SoapHeader header) {
            List.Insert(index, header);
        }
        
        /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(SoapHeader header) {
            return List.IndexOf(header);
        }
        
        /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(SoapHeader header) {
            return List.Contains(header);
        }
        
        /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(SoapHeader header) {
            List.Remove(header);
        }
        
        /// <include file='doc\SoapHeaders.uex' path='docs/doc[@for="SoapHeaderCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(SoapHeader[] array, int index) {
            List.CopyTo(array, index);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapmessage.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapMessage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class SoapMessage {
        SoapMessageStage stage;
        SoapHeaderCollection headers = new SoapHeaderCollection();
        Stream stream;        
        SoapExtensionStream extensionStream;
        string contentType;
        string contentEncoding;
        object[] parameterValues;
        SoapException exception;

        internal SoapMessage() { }

        internal void SetParameterValues(object[] parameterValues) {
            this.parameterValues = parameterValues;
        }

        internal object[] GetParameterValues() {
            return parameterValues;
        }

        internal void SetException(SoapException exception) {
            this.exception = exception;
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.OneWay"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract bool OneWay {
            get;
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.GetInParameterValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object GetInParameterValue(int index) {
            EnsureInStage();
            EnsureNoException();
            if (index < 0 || index >= parameterValues.Length) throw new IndexOutOfRangeException(Res.GetString(Res.indexMustBeBetweenAnd0Inclusive, parameterValues.Length));
            return parameterValues[index];
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.GetOutParameterValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object GetOutParameterValue(int index) {
            EnsureOutStage();
            EnsureNoException();
            if (!MethodInfo.IsVoid) index++;
            if (index < 0 || index >= parameterValues.Length) throw new IndexOutOfRangeException(Res.GetString(Res.indexMustBeBetweenAnd0Inclusive, parameterValues.Length));
            return parameterValues[index];
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.GetReturnValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object GetReturnValue() {
            EnsureOutStage();
            EnsureNoException();
            if (MethodInfo.IsVoid) throw new InvalidOperationException(Res.GetString(Res.WebNoReturnValue));
            return parameterValues[0];
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.EnsureOutStage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void EnsureOutStage();
        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.EnsureInStage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void EnsureInStage();

        void EnsureNoException() {
            if (exception != null) throw new InvalidOperationException(Res.GetString(Res.WebCannotAccessValue), exception);
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.Exception"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapException Exception {
            get { return exception; }
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.MethodInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract LogicalMethodInfo MethodInfo {
            get;
        }

        /*
        internal abstract SoapReflectedExtension[] Extensions {
            get;
        }

        internal abstract object[] ExtensionInitializers {
            get;
        }
        */

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.EnsureStage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void EnsureStage(SoapMessageStage stage) {
            if ((this.stage & stage) == 0) throw new InvalidOperationException(Res.GetString(Res.WebCannotAccessValueStage, this.stage.ToString()));
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.Headers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapHeaderCollection Headers {
            get { return headers; }
        }

        internal void SetStream(Stream stream) {               
            if (extensionStream != null) {
                extensionStream.SetInnerStream(stream);
                extensionStream.SetStreamReady();
                // The extension stream should now be referenced by either this.stream
                // or an extension that has chained it to another stream.
                extensionStream = null;
            }
            else
                this.stream = stream;         
        }

        internal void SetExtensionStream(SoapExtensionStream extensionStream) {
            this.extensionStream = extensionStream;            
            this.stream = extensionStream;            
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.Stream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Stream Stream {
            get { return stream; }
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.ContentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ContentType {
            get { EnsureStage(SoapMessageStage.BeforeSerialize | SoapMessageStage.BeforeDeserialize); return contentType; }
            set { EnsureStage(SoapMessageStage.BeforeSerialize | SoapMessageStage.BeforeDeserialize); contentType = value; }
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.ContentEncoding"]/*' />
        public string ContentEncoding {
            get { EnsureStage(SoapMessageStage.BeforeSerialize | SoapMessageStage.BeforeDeserialize); return contentEncoding; }
            set { EnsureStage(SoapMessageStage.BeforeSerialize | SoapMessageStage.BeforeDeserialize); contentEncoding = value; }
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.Stage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapMessageStage Stage {
            get { return stage; }
        }

        internal void SetStage(SoapMessageStage stage) {
            this.stage = stage;
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract string Url {
            get;
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.Action"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract string Action {
            get;
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.SoapVersion"]/*' />
        // SOAP12: made this internal
        internal virtual SoapProtocolVersion SoapVersion {
            get { return SoapProtocolVersion.Default; }
        }

        /*
        internal abstract bool IsInitialized {
            get;
        }
        */

        internal static SoapExtension[] InitializeExtensions(SoapReflectedExtension[] reflectedExtensions, object[] extensionInitializers) {
            if (reflectedExtensions == null)
                return null;
            SoapExtension[] extensions = new SoapExtension[reflectedExtensions.Length];
            for (int i = 0; i < extensions.Length; i++) {
                extensions[i] = reflectedExtensions[i].CreateInstance(extensionInitializers[i]);
            }
            return extensions;
        }
            
        internal void InitExtensionStreamChain(SoapExtension[] extensions) {
            if (extensions == null)
                return;
            for (int i = 0; i < extensions.Length; i++) {
                stream = extensions[i].ChainStream(stream);
            }
        }

        internal void RunExtensions(SoapExtension[] extensions) {
            if (extensions == null)
                return;

            // Higher priority extensions (earlier in the list) run earlier for deserialization stages,
            // and later for serialization stages
            if ((stage & (SoapMessageStage.BeforeDeserialize | SoapMessageStage.AfterDeserialize)) != 0) {
                for (int i = 0; i < extensions.Length; i++) {
                    extensions[i].ProcessMessage(this);
                }
            }
            else {
                for (int i = extensions.Length - 1; i >= 0; i--) {
                    extensions[i].ProcessMessage(this);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapparameterstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapParameterStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;

    /// <include file='doc\SoapParameterStyle.uex' path='docs/doc[@for="SoapParameterStyle"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum SoapParameterStyle {
        /// <include file='doc\SoapParameterStyle.uex' path='docs/doc[@for="SoapParameterStyle.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Default,
        /// <include file='doc\SoapParameterStyle.uex' path='docs/doc[@for="SoapParameterStyle.Bare"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Bare,                    // parameters appear directly
        /// <include file='doc\SoapParameterStyle.uex' path='docs/doc[@for="SoapParameterStyle.Wrapped"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Wrapped,  // parameters are modeled as a struct
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapmessagestage.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapMessageStage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapMessageStage.uex' path='docs/doc[@for="SoapMessageStage"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum SoapMessageStage {
        /// <include file='doc\SoapMessageStage.uex' path='docs/doc[@for="SoapMessageStage.BeforeSerialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BeforeSerialize = 1,
        /// <include file='doc\SoapMessageStage.uex' path='docs/doc[@for="SoapMessageStage.AfterSerialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AfterSerialize = 2,
        /// <include file='doc\SoapMessageStage.uex' path='docs/doc[@for="SoapMessageStage.BeforeDeserialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BeforeDeserialize = 4,
        /// <include file='doc\SoapMessageStage.uex' path='docs/doc[@for="SoapMessageStage.AfterDeserialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AfterDeserialize = 8
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapprotocolversion.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapParameterStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;

    /// <include file='doc\SoapProtocolVersion.uex' path='docs/doc[@for="SoapProtocolVersion"]/*' />
    // SOAP12: made this internal
    internal enum SoapProtocolVersion {
        /// <include file='doc\SoapProtocolVersion.uex' path='docs/doc[@for="SoapProtocolVersion.Default"]/*' />
        Default,
        /// <include file='doc\SoapProtocolVersion.uex' path='docs/doc[@for="SoapProtocolVersion.Soap11"]/*' />
        Soap11,       
        /// <include file='doc\SoapProtocolVersion.uex' path='docs/doc[@for="SoapProtocolVersion.Soap12"]/*' />
        Soap12,  
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soaprpcmethodattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapRpcMethodAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;

    /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class SoapRpcMethodAttribute : System.Attribute {
        string action;
        string requestName;
        string responseName;
        string requestNamespace;
        string responseNamespace;
        bool oneWay;
        string binding;
        
        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.SoapRpcMethodAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapRpcMethodAttribute() {
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.SoapRpcMethodAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapRpcMethodAttribute(string action) {
            this.action = action;
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.Action"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Action {
            get { return action; }
            set { action = value; }
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.OneWay"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool OneWay {
            get { return oneWay; }
            set { oneWay = value; }
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.RequestNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string RequestNamespace {
            get { return requestNamespace; }
            set { requestNamespace = value; }
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.ResponseNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ResponseNamespace {
            get { return responseNamespace; }
            set { responseNamespace = value; }
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.RequestElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string RequestElementName {
            get { return requestName == null ? string.Empty : requestName; }
            set { requestName = value; }
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.ResponseElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ResponseElementName {
            get { return responseName == null ? string.Empty : responseName; }
            set { responseName = value; }
        }

        /// <include file='doc\SoapRpcMethodAttribute.uex' path='docs/doc[@for="SoapRpcMethodAttribute.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Binding {
            get { return binding == null ? string.Empty : binding; }
            set { binding = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soaprpcserviceattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapRpcServiceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System;
    using System.Reflection;
    using System.Xml.Serialization;

    /// <include file='doc\SoapRpcServiceAttribute.uex' path='docs/doc[@for="SoapRpcServiceAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class SoapRpcServiceAttribute : Attribute {
        SoapServiceRoutingStyle routingStyle = SoapServiceRoutingStyle.SoapAction;

        /// <include file='doc\SoapRpcServiceAttribute.uex' path='docs/doc[@for="SoapRpcServiceAttribute.SoapRpcServiceAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapRpcServiceAttribute() {
        }

        /// <include file='doc\SoapRpcServiceAttribute.uex' path='docs/doc[@for="SoapRpcServiceAttribute.RoutingStyle"]/*' />
        public SoapServiceRoutingStyle RoutingStyle {
            get { return routingStyle; }
            set { routingStyle = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapservermessage.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapServerMessage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class SoapServerMessage : SoapMessage {
        SoapServerProtocol protocol;
        internal SoapExtension[] highPriConfigExtensions;
        internal SoapExtension[] otherExtensions;
        internal SoapExtension[] allExtensions;

        internal SoapServerMessage(SoapServerProtocol protocol) {
            this.protocol = protocol;
        }

        /*
        internal override bool IsInitialized {
            get { return protocol.IsInitialized; }
        }
        */

        /*
        internal override SoapReflectedExtension[] Extensions {
            get { return protocol.ServerMethod.extensions; }
        }

        internal override object[] ExtensionInitializers {
            get { return protocol.ServerMethod.extensionInitializers; }
        }
        */

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.OneWay"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool OneWay {
            get { return protocol.ServerMethod.oneWay; }
        }

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.Url"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Url {
            get { return protocol.Request.Url.ToString(); }
        }

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.Action"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Action {
            get { return protocol.ServerMethod.action; }
        }

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.SoapVersion"]/*' />
        // SOAP12: made this internal
        internal override SoapProtocolVersion SoapVersion {
            get { return protocol.Version; }
        }

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.Server"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Server {
            get { EnsureStage(SoapMessageStage.AfterDeserialize | SoapMessageStage.BeforeSerialize); return protocol.Target; }
        }

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.MethodInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override LogicalMethodInfo MethodInfo {
            get { return protocol.MethodInfo; }
        }

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.EnsureOutStage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void EnsureOutStage() {
            EnsureStage(SoapMessageStage.BeforeSerialize);
        }

        /// <include file='doc\SoapServerMessage.uex' path='docs/doc[@for="SoapServerMessage.EnsureInStage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void EnsureInStage(){
            EnsureStage(SoapMessageStage.AfterDeserialize);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\textreturnreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextReturnReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   TextReturnReader.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Web.Services;
    using System.Text;
    using System.Net;
    using System.Security.Permissions;

    /// <include file='doc\TextReturnReader.uex' path='docs/doc[@for="TextReturnReader"]/*' />
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class TextReturnReader : MimeReturnReader {
        PatternMatcher matcher;

        /// <include file='doc\TextReturnReader.uex' path='docs/doc[@for="TextReturnReader.Initialize"]/*' />
        public override void Initialize(object o) {
            matcher = (PatternMatcher)o;
        }

        /// <include file='doc\TextReturnReader.uex' path='docs/doc[@for="TextReturnReader.GetInitializer"]/*' />
        public override object GetInitializer(LogicalMethodInfo methodInfo) {
            return new PatternMatcher(methodInfo.ReturnType);
        }

        /// <include file='doc\TextReturnReader.uex' path='docs/doc[@for="TextReturnReader.Read"]/*' />
        public override object Read(WebResponse response, Stream responseStream) {
            try {
                string decodedString = RequestResponseUtils.ReadResponse(response);
                return matcher.Match(decodedString);
            }
            finally {
                response.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapserviceroutingstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapServiceRoutingStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    /// <include file='doc\SoapServiceRoutingStyle.uex' path='docs/doc[@for="SoapServiceRoutingStyle"]/*' />
    public enum SoapServiceRoutingStyle {
        /// <include file='doc\SoapServiceRoutingStyle.uex' path='docs/doc[@for="SoapServiceRoutingStyle.SoapAction"]/*' />
        SoapAction,
        /// <include file='doc\SoapServiceRoutingStyle.uex' path='docs/doc[@for="SoapServiceRoutingStyle.MessageElement"]/*' />
        RequestElement,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapunknownheader.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapUnknownHeader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.Web.Services;
    using System.Xml.Serialization;
    using System;
    using System.Reflection;
    using System.Xml;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\SoapUnknownHeader.uex' path='docs/doc[@for="SoapUnknownHeader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class SoapUnknownHeader : SoapHeader {
        XmlElement element;

        /// <include file='doc\SoapUnknownHeader.uex' path='docs/doc[@for="SoapUnknownHeader.Element"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlElement Element {
            get {
                if (element == null) return null;

                if (version == SoapProtocolVersion.Soap12) {
                    // need to fix up mustUnderstand and actor attributes for soap 1.2
                    if (InternalMustUnderstand) {
                        element.SetAttribute(Soap.MustUnderstand, Soap12.Namespace, "1");
                    }
                    element.RemoveAttribute(Soap.MustUnderstand, Soap.Namespace);
                    string actor = InternalActor;
                    if (actor != "") {
                        element.SetAttribute(Soap12.Role, Soap12.Namespace, actor);
                    }
                    element.RemoveAttribute(Soap.Actor, Soap.Namespace);
                }
                else if (version == SoapProtocolVersion.Soap11) {
                    // need to fix up mustUnderstand and actor attributes for soap 1.1
                    if (InternalMustUnderstand) {
                        element.SetAttribute(Soap.MustUnderstand, Soap.Namespace, "1");
                    }
                    element.RemoveAttribute(Soap.MustUnderstand, Soap12.Namespace);
                    string actor = InternalActor;
                    if (actor != "") {
                        element.SetAttribute(Soap.Actor, Soap.Namespace, actor);
                    }
                    element.RemoveAttribute(Soap12.Role, Soap12.Namespace);
                }

                return element; 
            }
            set {
                if (value == null && element != null) {
                    // save off the mustUnderstand/actor values before they go away
                    base.InternalMustUnderstand = InternalMustUnderstand;
                    base.InternalActor = InternalActor;
                }
                element = value;
            }
        }

        internal override bool InternalMustUnderstand {
            get {
                if (element == null) return base.InternalMustUnderstand;

                string elementMustUnderstand = GetElementAttribute(Soap.MustUnderstand, Soap.Namespace, element);
                if (elementMustUnderstand == null) {
                    elementMustUnderstand = GetElementAttribute(Soap.MustUnderstand, Soap12.Namespace, element);
                    if (elementMustUnderstand == null)
                        return false;
                }

                switch (elementMustUnderstand) {
                    case "false":
                    case "0":
                        return false;
                    case "true":
                    case "1":
                        return true;
                    default:
                        return false;
                }
            }
            set {
                base.InternalMustUnderstand = value;
                if (element != null) {
                    if (value)
                        element.SetAttribute(Soap.MustUnderstand, Soap.Namespace, "1");
                    else
                        element.RemoveAttribute(Soap.MustUnderstand, Soap.Namespace);

                    element.RemoveAttribute(Soap.MustUnderstand, Soap12.Namespace);
                }
            }
        }

        internal override string InternalActor {
            get {
                if (element == null) return base.InternalActor;

                string elementActor = GetElementAttribute(Soap.Actor, Soap.Namespace, element);
                if (elementActor == null) {
                    elementActor = GetElementAttribute(Soap12.Role, Soap12.Namespace, element);
                    if (elementActor == null) 
                        return "";
                }
                return elementActor;
            }
            set {
                base.InternalActor = value;
                if (element != null) {
                    if (value == null || value.Length == 0)
                        element.RemoveAttribute(Soap.Actor, Soap.Namespace);
                    else
                        element.SetAttribute(Soap.Actor, Soap.Namespace, value);
                    
                    element.RemoveAttribute(Soap12.Role, Soap12.Namespace);
                }
            }
        }

        private string GetElementAttribute(string name, string ns, XmlElement element) {
            if (element == null)
                return null;
            if (element.Prefix.Length == 0 && element.NamespaceURI == ns) {
                if (element.HasAttribute(name))
                    return element.GetAttribute(name);
                else
                    return null;
            }
            else {
                if (element.HasAttribute(name, ns))
                    return element.GetAttribute(name, ns);
                else
                    return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\urlencodedparameterwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="UrlEncodedParameterWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Text;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;

    /// <include file='doc\UrlEncodedParameterWriter.uex' path='docs/doc[@for="UrlEncodedParameterWriter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class UrlEncodedParameterWriter : MimeParameterWriter {
        ParameterInfo[] paramInfos;
        int numberEncoded;
        Encoding encoding;

        /// <include file='doc\UrlEncodedParameterWriter.uex' path='docs/doc[@for="UrlEncodedParameterWriter.RequestEncoding"]/*' />
        public override Encoding RequestEncoding {
            get { return encoding; }
            set { encoding = value; }
        }

        /// <include file='doc\UrlEncodedParameterWriter.uex' path='docs/doc[@for="UrlEncodedParameterWriter.GetInitializer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetInitializer(LogicalMethodInfo methodInfo) {
            if (!ValueCollectionParameterReader.IsSupported(methodInfo)) return null;
            return methodInfo.InParameters;
        }

        /// <include file='doc\UrlEncodedParameterWriter.uex' path='docs/doc[@for="UrlEncodedParameterWriter.Initialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Initialize(object initializer) {
            this.paramInfos = (ParameterInfo[])initializer;
        }

        /// <include file='doc\UrlEncodedParameterWriter.uex' path='docs/doc[@for="UrlEncodedParameterWriter.Encode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void Encode(TextWriter writer, object[] values) {
            numberEncoded = 0;
            for (int i = 0; i < paramInfos.Length; i++) {
                ParameterInfo paramInfo = paramInfos[i];
                if (paramInfo.ParameterType.IsArray) {
                    Array array = (Array)values[i];
                    for (int j = 0; j < array.Length; j++) {
                        Encode(writer, paramInfo.Name, array.GetValue(j));
                    }
                }
                else {
                    Encode(writer, paramInfo.Name, values[i]);
                }
            }
        }

        /// <include file='doc\UrlEncodedParameterWriter.uex' path='docs/doc[@for="UrlEncodedParameterWriter.Encode1"]/*' />
        protected void Encode(TextWriter writer, string name, object value) {
            if (numberEncoded > 0) writer.Write('&');
            writer.Write(UrlEncode(name));
            writer.Write('=');
            writer.Write(UrlEncode(ScalarFormatter.ToString(value)));
            numberEncoded++;
        }

        string UrlEncode(string value) {
            if (encoding != null)
                return UrlEncoder.UrlEscapeString(value, encoding);
            else
                return UrlEncoder.UrlEscapeStringUnicode(value);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapserverprotocol.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapServerProtocol.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Xml;
    using System.Xml.Schema;
    using System.Web.Services.Description;
    using System.Text;
    using System.Net;
    using System.Web.Services.Configuration;

    internal class SoapServerType : ServerType {
        Hashtable methods = new Hashtable();
        Hashtable duplicateMethods = new Hashtable();

        internal SoapReflectedExtension[] HighPriExtensions;
        internal SoapReflectedExtension[] LowPriExtensions;
        internal object[] HighPriExtensionInitializers;
        internal object[] LowPriExtensionInitializers;

        internal string serviceNamespace;
        internal bool serviceDefaultIsEncoded;
        internal bool routingOnSoapAction;
        internal ProtocolsEnum versionsSupported;

        internal SoapServerType(Type type, ProtocolsEnum versionsSupported) : base(type) {
            this.versionsSupported = versionsSupported;
            bool soap11 = (versionsSupported & ProtocolsEnum.HttpSoap) != 0;
            bool soap12 = (versionsSupported & ProtocolsEnum.HttpSoap12) != 0;
            LogicalMethodInfo[] methodInfos = WebMethodReflector.GetMethods(type);
            ArrayList mappings = new ArrayList();
            WebServiceAttribute serviceAttribute = WebServiceReflector.GetAttribute(type);
            object soapServiceAttribute = SoapReflector.GetSoapServiceAttribute(type);
            routingOnSoapAction = SoapReflector.GetSoapServiceRoutingStyle(soapServiceAttribute) == SoapServiceRoutingStyle.SoapAction;
            serviceNamespace = serviceAttribute.Namespace;
            serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(type);
            SoapReflectionImporter soapImporter = SoapReflector.CreateSoapImporter(serviceNamespace, serviceDefaultIsEncoded);
            XmlReflectionImporter xmlImporter = SoapReflector.CreateXmlImporter(serviceNamespace, serviceDefaultIsEncoded);
            SoapReflector.IncludeTypes(methodInfos, soapImporter);
            WebMethodReflector.IncludeTypes(methodInfos, xmlImporter);
            SoapReflectedMethod[] soapMethods = new SoapReflectedMethod[methodInfos.Length];

            SoapExtensionType[] extensionTypes = WebServicesConfiguration.Current.SoapExtensionTypes;
            ArrayList highPri = new ArrayList();
            ArrayList lowPri = new ArrayList();
            for (int i = 0; i < extensionTypes.Length; i++) {
                SoapReflectedExtension extension = new SoapReflectedExtension(extensionTypes[i].Type, null, extensionTypes[i].Priority);
                if (extensionTypes[i].Group == SoapExtensionType.PriorityGroup.High)
                    highPri.Add(extension);
                else
                    lowPri.Add(extension);
            }
            HighPriExtensions = (SoapReflectedExtension[]) highPri.ToArray(typeof(SoapReflectedExtension));
            LowPriExtensions = (SoapReflectedExtension[]) lowPri.ToArray(typeof(SoapReflectedExtension));
            Array.Sort(HighPriExtensions);
            Array.Sort(LowPriExtensions);
            HighPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, HighPriExtensions);
            LowPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, LowPriExtensions);
 
            for (int i = 0; i < methodInfos.Length; i++) {
                LogicalMethodInfo methodInfo = methodInfos[i];
                SoapReflectedMethod soapMethod = SoapReflector.ReflectMethod(methodInfo, false, xmlImporter, soapImporter, serviceAttribute.Namespace);
                mappings.Add(soapMethod.requestMappings);
                if (soapMethod.responseMappings != null) mappings.Add(soapMethod.responseMappings);
                mappings.Add(soapMethod.inHeaderMappings);
                if (soapMethod.outHeaderMappings != null) mappings.Add(soapMethod.outHeaderMappings);
                soapMethods[i] = soapMethod;
            }

            XmlSerializer[] serializers = XmlSerializer.FromMappings((XmlMapping[])mappings.ToArray(typeof(XmlMapping)));
            int count = 0;
            for (int i = 0; i < soapMethods.Length; i++) {
                SoapServerMethod serverMethod = new SoapServerMethod();
                SoapReflectedMethod soapMethod = soapMethods[i];
                serverMethod.parameterSerializer = serializers[count++]; 
                if (soapMethod.responseMappings != null) serverMethod.returnSerializer = serializers[count++];
                serverMethod.inHeaderSerializer = serializers[count++];
                if (soapMethod.outHeaderMappings != null) serverMethod.outHeaderSerializer = serializers[count++];
                serverMethod.methodInfo = soapMethod.methodInfo;
                serverMethod.action = soapMethod.action;
                serverMethod.extensions = soapMethod.extensions;
                serverMethod.extensionInitializers = SoapReflectedExtension.GetInitializers(serverMethod.methodInfo, soapMethod.extensions);
                serverMethod.oneWay = soapMethod.oneWay;
                serverMethod.rpc = soapMethod.rpc;
                serverMethod.use = soapMethod.use;
                serverMethod.paramStyle = soapMethod.paramStyle;
                ArrayList inHeaders = new ArrayList();
                ArrayList outHeaders = new ArrayList();
                for (int j = 0; j < soapMethod.headers.Length; j++) {
                    SoapHeaderMapping mapping = new SoapHeaderMapping();
                    SoapReflectedHeader soapHeader = soapMethod.headers[j];
                    mapping.memberInfo = soapHeader.memberInfo;
                    mapping.repeats = soapHeader.repeats;
                    mapping.custom = soapHeader.custom;
                    mapping.direction = soapHeader.direction;
                    mapping.headerType = soapHeader.headerType;
                    if (mapping.direction == SoapHeaderDirection.In)
                        inHeaders.Add(mapping);
                    else if (mapping.direction == SoapHeaderDirection.Out)
                        outHeaders.Add(mapping);
                    else {
                        inHeaders.Add(mapping);
                        outHeaders.Add(mapping);
                    }
                }
                serverMethod.inHeaderMappings = (SoapHeaderMapping[])inHeaders.ToArray(typeof(SoapHeaderMapping));
                if (serverMethod.outHeaderSerializer != null)
                    serverMethod.outHeaderMappings = (SoapHeaderMapping[])outHeaders.ToArray(typeof(SoapHeaderMapping));
                
                // check feasibility of routing on request element for soap 1.1
                if (soap11 && !routingOnSoapAction && soapMethod.requestElementName.IsEmpty)
                    throw new SoapException(Res.GetString(Res.TheMethodDoesNotHaveARequestElementEither1, serverMethod.methodInfo.Name), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace));

                // we can lookup methods by action or request element
                if (methods[soapMethod.action] == null)
                    methods[soapMethod.action] = serverMethod;
                else {
                    // duplicate soap actions not allowed in soap 1.1 if we're routing on soap action
                    if (soap11 && routingOnSoapAction) {
                        SoapServerMethod duplicateMethod = (SoapServerMethod)methods[soapMethod.action];
                        throw new SoapException(Res.GetString(Res.TheMethodsAndUseTheSameSoapActionWhenTheService3, serverMethod.methodInfo.Name, duplicateMethod.methodInfo.Name, soapMethod.action), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace)) ;
                    }
                    duplicateMethods[soapMethod.action] = serverMethod;
                }

                if (methods[soapMethod.requestElementName] == null)
                    methods[soapMethod.requestElementName] = serverMethod;
                else {
                    // duplicate request elements not allowed in soap 1.1 if we're routing on request element
                    if (soap11 && !routingOnSoapAction) {
                        SoapServerMethod duplicateMethod = (SoapServerMethod)methods[soapMethod.requestElementName];
                        throw new SoapException(Res.GetString(Res.TheMethodsAndUseTheSameRequestElementXmlns4, serverMethod.methodInfo.Name, duplicateMethod.methodInfo.Name, soapMethod.requestElementName.Name, soapMethod.requestElementName.Namespace), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace));
                    }
                    duplicateMethods[soapMethod.requestElementName] = serverMethod;
                }
            }
        }

        internal SoapServerMethod GetMethod(object key) {
            return (SoapServerMethod)methods[key];
        }

        internal SoapServerMethod GetDuplicateMethod(object key) {
            return (SoapServerMethod)duplicateMethods[key];
        }
    }

    internal class SoapServerMethod {
        internal LogicalMethodInfo methodInfo;
        internal XmlSerializer returnSerializer;
        internal XmlSerializer parameterSerializer;
        internal XmlSerializer inHeaderSerializer;
        internal XmlSerializer outHeaderSerializer;
        internal SoapHeaderMapping[] inHeaderMappings;
        internal SoapHeaderMapping[] outHeaderMappings;
        internal SoapReflectedExtension[] extensions;
        internal object[] extensionInitializers;
        internal string action;
        internal bool oneWay;
        internal bool rpc;
        internal SoapBindingUse use;
        internal SoapParameterStyle paramStyle;
    }
    
    internal class SoapServerProtocolFactory : ServerProtocolFactory {
        // POST requests without pathinfo (the "/Foo" in "foo.asmx/Foo") 
        // are treated as soap. if the server supports both versions we route requests
        // with soapaction to 1.1 and other requests to 1.2
        protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request){
            if (request.PathInfo.Length > 0)
                return null;
            
            if (request.HttpMethod != "POST")
                return null;

            // at this point we know it's probably soap. we're still not sure of the version
            // but we leave that to the SoapServerProtocol to figure out
            return new SoapServerProtocol(WebServicesConfiguration.Current.EnabledProtocols);
        }
    }

    internal class SoapServerProtocol : ServerProtocol {
        SoapServerType serverType;
        SoapServerMethod serverMethod;
        SoapServerMessage message;
        bool isOneWay;
        Exception onewayInitException;
        SoapProtocolVersion version;
        ProtocolsEnum versionsSupported;
        SoapServerProtocolHelper helper;

        internal SoapServerProtocol(ProtocolsEnum versionsSupported) {
            this.versionsSupported = versionsSupported;
        }

        internal override bool Initialize() {
            // try to guess the request version so we can handle any exceptions that might come up
            GuessVersion();

            message = new SoapServerMessage(this);
            onewayInitException = null;

            serverType = (SoapServerType)GetFromCache(typeof(SoapServerProtocol), Type);
            if (serverType == null) {
                lock(Type){                    
                    serverType = (SoapServerType)GetFromCache(typeof(SoapServerProtocol), Type);
                    if (serverType == null) {
                        serverType = new SoapServerType(Type, versionsSupported);
                        AddToCache(typeof(SoapServerProtocol), Type, serverType);
                    }
                }
            }

            // We delay throwing any exceptions out of the extension until we determine if the method is one-way or not.
            Exception extensionException = null;
            try {
                message.highPriConfigExtensions = SoapMessage.InitializeExtensions(serverType.HighPriExtensions, serverType.HighPriExtensionInitializers);
                // For one-way methods we rely on Request.InputStream guaranteeing that the entire request body has arrived
                message.SetStream(Request.InputStream);

                Debug.Assert(message.Stream.CanSeek, "Web services SOAP handler assumes a seekable stream.");

                message.InitExtensionStreamChain(message.highPriConfigExtensions);
                message.SetStage(SoapMessageStage.BeforeDeserialize);
                message.ContentType = Request.ContentType;
                message.ContentEncoding = Request.Headers[ContentType.ContentEncoding];
                message.RunExtensions(message.highPriConfigExtensions);
                
            }
            catch (Exception e) {
                extensionException = e;
            }

            // set this here since we might throw before we init the other extensions
            message.allExtensions = message.highPriConfigExtensions;
                                
            // maybe the extensions that just ran changed some of the request data so we can make a better version guess
            GuessVersion();
            try {
                this.serverMethod = helper.RouteRequest();
            
                // the RouteRequest impl should throw an exception if it can't route the request but just in case...
                if (this.serverMethod == null)
                    throw new SoapException(Res.GetString(Res.UnableToHandleRequest0), new XmlQualifiedName(Soap.ServerCode, Soap.Namespace));
            }
            catch (Exception) {
                if (helper.RequestNamespace != null)
                    SetHelper(SoapServerProtocolHelper.GetHelper(this, helper.RequestNamespace));

                // version mismatches override other errors
                CheckHelperVersion();

                throw;
            }

            this.isOneWay = serverMethod.oneWay;
            if(extensionException == null){
                try {
                    SoapReflectedExtension[] otherReflectedExtensions = (SoapReflectedExtension[]) CombineExtensionsHelper(serverMethod.extensions, serverType.LowPriExtensions, typeof(SoapReflectedExtension));
                    object[] otherInitializers = (object[]) CombineExtensionsHelper(serverMethod.extensionInitializers, serverType.LowPriExtensionInitializers, typeof(object));
                    message.otherExtensions = SoapMessage.InitializeExtensions(otherReflectedExtensions, otherInitializers);
                    message.allExtensions = (SoapExtension[]) CombineExtensionsHelper(message.highPriConfigExtensions, message.otherExtensions, typeof(SoapExtension));
                }
                catch (Exception e) {
                    extensionException = e;
                }
            }

            if (extensionException != null){
                if(isOneWay)
                    onewayInitException = extensionException;
                else
                    throw new SoapException(Res.GetString(Res.WebConfigExtensionError), new XmlQualifiedName(Soap.ServerCode, Soap.Namespace), extensionException);
            }

            return true;
        }

        private void GuessVersion() {
            // make a best guess as to the version. we'll get more info when we crack the envelope
            if (IsSupported(ProtocolsEnum.AnyHttpSoap)) {
                // both versions supported, we need to pick one
                if (Request.Headers[Soap.Action] == null || ContentType.MatchesBase(Request.ContentType, ContentType.ApplicationSoap))
                    SetHelper(new Soap12ServerProtocolHelper(this));
                else
                    SetHelper(new Soap11ServerProtocolHelper(this));
            }
            else if (IsSupported(ProtocolsEnum.HttpSoap)) {
                SetHelper(new Soap11ServerProtocolHelper(this));
            }
            else if (IsSupported(ProtocolsEnum.HttpSoap12)) {
                SetHelper(new Soap12ServerProtocolHelper(this));
            }
        }

        internal bool IsSupported(ProtocolsEnum protocol) {
            return ((versionsSupported & protocol) == protocol);
        }

        internal override ServerType ServerType {
            get { return serverType; }
        }

        internal override LogicalMethodInfo MethodInfo {
            get { return serverMethod.methodInfo; }
        }

        internal SoapServerMethod ServerMethod {
            get { return serverMethod; }
        }

        internal SoapServerMessage Message {
            get { return message; }
        }

        internal override bool IsOneWay {
            get { return this.isOneWay; }            
        }            
        
        internal override Exception OnewayInitException {
            get {
                Debug.Assert(isOneWay || (onewayInitException == null), "initException is meant to be used for oneWay methods only.");
                return this.onewayInitException;
            }
        }            
            
        internal SoapProtocolVersion Version {
            get { return version; }
        }

        /*
        internal bool IsInitialized {
            get { return serverMethod != null; }
        }
        */

        internal override void CreateServerInstance() {
            base.CreateServerInstance();
            message.SetStage(SoapMessageStage.AfterDeserialize);

            message.RunExtensions(message.allExtensions);
            SoapHeaderHandling.SetHeaderMembers(message.Headers, this.Target, serverMethod.inHeaderMappings, SoapHeaderDirection.In, false);
        }

        /*
        #if DEBUG
        private static void CopyStream(Stream source, Stream dest) {
            byte[] bytes = new byte[1024];
            int numRead = 0;
            while ((numRead = source.Read(bytes, 0, 1024)) > 0)
                dest.Write(bytes, 0, numRead);
        }
        #endif
        */

        private void SetHelper(SoapServerProtocolHelper helper) {
            this.helper = helper;
            this.version = helper.Version;
            // SOAP12: disabled
            //Context.Items[WebService.SoapVersionContextSlot] = helper.Version;
        }

        private static Array CombineExtensionsHelper(Array array1, Array array2, Type elementType) {
            if (array1 == null) return array2;
            if (array2 == null) return array1;
            int length = array1.Length + array2.Length;
            if (length == 0)
                return null;
            Array result = null;
            if (elementType == typeof(SoapReflectedExtension))
                result = new SoapReflectedExtension[length];
            else if (elementType == typeof(SoapExtension))
                result = new SoapExtension[length];
            else if (elementType == typeof(object))
                result  = new object[length];
            else 
                throw new ArgumentException(Res.GetString(Res.ElementTypeMustBeObjectOrSoapExtensionOrSoapReflectedException),"elementType");
            
            Array.Copy(array1, 0, result, 0, array1.Length);
            Array.Copy(array2, 0, result, array1.Length, array2.Length);
            return result;
        }

        private void CheckHelperVersion() {
            if (helper.RequestNamespace == null) return;

            // looks at the helper request namespace and version information to see if we need to return a 
            // version mismatch fault (and if so, what version fault). there are two conditions to check:
            // unknown envelope ns and known but unsupported envelope ns. there are a few rules this code must follow:
            // * a 1.1 node responds with a 1.1 fault. 
            // * a 1.2 node responds to a 1.1 request with a 1.1 fault but responds to an unknown request with a 1.2 fault.
            // * a both node can respond with either but we prefer 1.1.

            // GetHelper returns an arbitrary helper when the envelope ns is unknown, so we can check the helper's
            // expected envelope against the actual request ns to see if the request ns is unknown
            if (helper.RequestNamespace != helper.EnvelopeNs) { // unknown envelope ns -- version mismatch
                // respond with the version we support or 1.1 if we support both
                string requestNamespace = helper.RequestNamespace;
                if (IsSupported(ProtocolsEnum.HttpSoap))
                    SetHelper(new Soap11ServerProtocolHelper(this));
                else
                    SetHelper(new Soap12ServerProtocolHelper(this));
                throw new SoapException(Res.GetString(Res.WebInvalidEnvelopeNamespace, requestNamespace, helper.EnvelopeNs), SoapException.VersionMismatchFaultCode);
            }
            else if (!IsSupported(helper.Protocol)) { // known envelope ns but we don't support this version -- version mismatch
                // always respond with 1.1
                string requestNamespace = helper.RequestNamespace;
                string expectedNamespace = IsSupported(ProtocolsEnum.HttpSoap) ? Soap.Namespace : Soap12.Namespace;
                SetHelper(new Soap11ServerProtocolHelper(this));
                throw new SoapException(Res.GetString(Res.WebInvalidEnvelopeNamespace, requestNamespace, expectedNamespace), SoapException.VersionMismatchFaultCode);
            }
        }

        internal override object[] ReadParameters() {
            message.InitExtensionStreamChain(message.otherExtensions);
            message.RunExtensions(message.otherExtensions);

            // do a sanity check on the content-type before we check the version since otherwise the error might be really nasty
            if (!ContentType.IsSoap(message.ContentType))
                throw new SoapException(Res.GetString(Res.WebRequestContent, message.ContentType, helper.HttpContentType), 
                    new XmlQualifiedName(Soap.ClientCode, Soap.Namespace), new SoapFaultSubcode(Soap12FaultCodes.UnsupportedMediaTypeFaultCode));

            // now that all the extensions have run, establish the real version of the request
            SetHelper(SoapServerProtocolHelper.GetHelper(this));
            CheckHelperVersion();

            // now do a more specific content-type check for soap 1.1 only (soap 1.2 allows various xml content types)
            if (version == SoapProtocolVersion.Soap11 && !ContentType.MatchesBase(message.ContentType, helper.HttpContentType))
                throw new SoapException(Res.GetString(Res.WebRequestContent, message.ContentType, helper.HttpContentType), 
                    new XmlQualifiedName(Soap.ClientCode, Soap.Namespace), new SoapFaultSubcode(Soap12FaultCodes.UnsupportedMediaTypeFaultCode));

            try {
                XmlTextReader reader = SoapServerProtocolHelper.GetXmlTextReader(message.ContentType, message.Stream);
                reader.MoveToContent();
                reader.ReadStartElement(Soap.Envelope, helper.EnvelopeNs);
                reader.MoveToContent();

                new SoapHeaderHandling().ReadHeaders(reader, serverMethod.inHeaderSerializer, message.Headers, serverMethod.inHeaderMappings, SoapHeaderDirection.In, helper.EnvelopeNs, serverMethod.use == SoapBindingUse.Encoded ? helper.EncodingNs : null);
                        
                reader.MoveToContent();
                reader.ReadStartElement(Soap.Body, helper.EnvelopeNs);
                reader.MoveToContent();

                // SOAP12: not using encodingStyle
                //object[] values = (object[])serverMethod.parameterSerializer.Deserialize(reader, serverMethod.use == SoapBindingUse.Encoded ? helper.EncodingNs : null);
                object[] values = (object[])serverMethod.parameterSerializer.Deserialize(reader);

                while (reader.NodeType == XmlNodeType.Whitespace) reader.Skip();
                if (reader.NodeType == XmlNodeType.None) reader.Skip();
                else reader.ReadEndElement();
                while (reader.NodeType == XmlNodeType.Whitespace) reader.Skip();
                if (reader.NodeType == XmlNodeType.None) reader.Skip();
                else reader.ReadEndElement();

                message.SetParameterValues(values);

                return values;
            }
            catch (SoapException) {
                throw;
            }
            catch (Exception e) {
                throw new SoapException(Res.GetString(Res.WebRequestUnableToRead), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace), e);
            }
        }

        internal override void WriteReturns(object[] returnValues, Stream outputStream) {
            if (serverMethod.oneWay) return;
            bool isEncoded = serverMethod.use == SoapBindingUse.Encoded;
            SoapHeaderHandling.EnsureHeadersUnderstood(message.Headers);
            message.Headers.Clear();
            SoapHeaderHandling.GetHeaderMembers(message.Headers, this.Target, serverMethod.outHeaderMappings, SoapHeaderDirection.Out, false);

            if (message.allExtensions != null)
                message.SetExtensionStream(new SoapExtensionStream());
            
            message.InitExtensionStreamChain(message.allExtensions);
            
            message.SetStage(SoapMessageStage.BeforeSerialize);
            message.ContentType = ContentType.Compose(helper.HttpContentType, Encoding.UTF8);
            message.SetParameterValues(returnValues);
            message.RunExtensions(message.allExtensions);

            message.SetStream(outputStream);
            Response.ContentType = message.ContentType;
            if (message.ContentEncoding != null && message.ContentEncoding.Length > 0)
                Response.AppendHeader(ContentType.ContentEncoding, message.ContentEncoding);

            StreamWriter sw = new StreamWriter(message.Stream, new UTF8Encoding(false), 128);
            XmlTextWriter writer = isEncoded && message.Headers.Count > 0 ? new XmlSpecialTextWriter(sw, helper.Version) : new XmlTextWriter(sw);

            writer.WriteStartDocument();
            writer.WriteStartElement("soap", Soap.Envelope, helper.EnvelopeNs);
            writer.WriteAttributeString("xmlns", "soap", null, helper.EnvelopeNs);
            if (isEncoded) {
                writer.WriteAttributeString("xmlns", "soapenc", null, helper.EncodingNs);
                writer.WriteAttributeString("xmlns", "tns", null, serverType.serviceNamespace);
                writer.WriteAttributeString("xmlns", "types", null, SoapReflector.GetEncodedNamespace(serverType.serviceNamespace, serverType.serviceDefaultIsEncoded));
            }
            if (serverMethod.rpc && version == SoapProtocolVersion.Soap12) {
                writer.WriteAttributeString("xmlns", "rpc", null, Soap12.RpcNamespace);
            }
            writer.WriteAttributeString("xmlns", "xsi", null, XmlSchema.InstanceNamespace);
            writer.WriteAttributeString("xmlns", "xsd", null, XmlSchema.Namespace);
            SoapHeaderHandling.WriteHeaders(writer, serverMethod.outHeaderSerializer, message.Headers, serverMethod.outHeaderMappings, SoapHeaderDirection.Out, isEncoded, serverType.serviceNamespace, serverType.serviceDefaultIsEncoded, helper.EnvelopeNs);
            writer.WriteStartElement(Soap.Body, helper.EnvelopeNs);
            if (isEncoded)
                writer.WriteAttributeString("soap", Soap.EncodingStyle, null, helper.EncodingNs);
            // SOAP12: not using encodingStyle
            //serverMethod.returnSerializer.Serialize(writer, returnValues, null, isEncoded ? helper.EncodingNs : null);
            serverMethod.returnSerializer.Serialize(writer, returnValues, null);
            writer.WriteEndElement();
            writer.WriteEndElement();
            writer.Flush();

            message.SetStage(SoapMessageStage.AfterSerialize);
            message.RunExtensions(message.allExtensions);
        }

        internal override bool WriteException(Exception e, Stream outputStream) {
            if (message == null) return false;

            message.Headers.Clear();
            if (serverMethod != null)
                SoapHeaderHandling.GetHeaderMembers(message.Headers, this.Target, serverMethod.outHeaderMappings, SoapHeaderDirection.Fault, false);

            SoapException soapException;
            if (e is SoapException)
                soapException = (SoapException)e;
            else if (serverMethod != null && serverMethod.rpc && helper.Version == SoapProtocolVersion.Soap12 && e is ArgumentException)
                // special case to handle soap 1.2 rpc "BadArguments" fault
                soapException = new SoapException(Res.GetString(Res.WebRequestUnableToProcess), new XmlQualifiedName(Soap.ClientCode, Soap.Namespace), null, null, null, new SoapFaultSubcode(Soap12FaultCodes.RpcBadArgumentsFaultCode), e);
            else 
                soapException = new SoapException(Res.GetString(Res.WebRequestUnableToProcess), new XmlQualifiedName(Soap.ServerCode, Soap.Namespace), e);

            if (SoapException.IsVersionMismatchFaultCode(soapException.Code)) {
                if (IsSupported(ProtocolsEnum.HttpSoap12)) {
                    SoapUnknownHeader unknownHeader = CreateUpgradeHeader();
                    if (unknownHeader != null)
                        Message.Headers.Add(unknownHeader);
                }
            }

            Response.ClearHeaders();
            Response.Clear();
            helper.SetResponseErrorCode(Response, soapException);

            bool disableExtensions = false;

            if (message.allExtensions != null)
                message.SetExtensionStream(new SoapExtensionStream());

            try {
                message.InitExtensionStreamChain(message.allExtensions);
            }
            catch (Exception) {
                disableExtensions = true;
            }
            message.SetStage(SoapMessageStage.BeforeSerialize);
            message.ContentType = ContentType.Compose(helper.HttpContentType, Encoding.UTF8);
            message.SetException(soapException);
            if (!disableExtensions) {
                try {
                    message.RunExtensions(message.allExtensions);
                }
                catch (Exception) {
                    disableExtensions = true;
                }
            }
            message.SetStream(outputStream);
            Response.ContentType = message.ContentType;
            if (message.ContentEncoding != null && message.ContentEncoding.Length > 0)
                Response.AppendHeader(ContentType.ContentEncoding, message.ContentEncoding);

            bool isEncoded = serverMethod != null && serverMethod.use == SoapBindingUse.Encoded;
            StreamWriter sw = new StreamWriter(message.Stream, new UTF8Encoding(false), 128);
            XmlTextWriter writer = isEncoded && message.Headers.Count > 0 ? new XmlSpecialTextWriter(sw, helper.Version) : new XmlTextWriter(sw);
            writer.Formatting = Formatting.Indented; // CONSIDER, don't format to save space
            writer.Indentation = 2; // CONSIDER, don't indent to save space

            helper.WriteFault(writer, soapException);

            if (!disableExtensions) {
                try {
                    message.SetStage(SoapMessageStage.AfterSerialize);
                    message.RunExtensions(message.allExtensions);
                }
                catch (Exception) {
                    // it's too late to do anything about this -- we've already written to the stream
                }
            }
            return true;
        }
        
        internal SoapUnknownHeader CreateUpgradeHeader() {
            XmlDocument doc = new XmlDocument();
            XmlElement upgradeElement = doc.CreateElement("upg", Soap12.Upgrade, Soap12.UpgradeNamespace);
            if (IsSupported(ProtocolsEnum.HttpSoap))
                upgradeElement.AppendChild(CreateUpgradeEnvelope(doc, "soap", Soap.Namespace));
            if (IsSupported(ProtocolsEnum.HttpSoap12))
                upgradeElement.AppendChild(CreateUpgradeEnvelope(doc, "soap12", Soap12.Namespace));

            SoapUnknownHeader upgradeHeader = new SoapUnknownHeader();
            upgradeHeader.Element = upgradeElement;
            return upgradeHeader;
        }

        private static XmlElement CreateUpgradeEnvelope(XmlDocument doc, string prefix, string envelopeNs) {
            XmlElement envelopeElement = doc.CreateElement(Soap12.UpgradeEnvelope, String.Empty);
            XmlAttribute xmlnsAttr = doc.CreateAttribute("xmlns", prefix, "http://www.w3.org/2000/xmlns/");
            xmlnsAttr.Value = envelopeNs;
            XmlAttribute qnameAttr = doc.CreateAttribute(Soap12.UpgradeEnvelopeQname);
            qnameAttr.Value = prefix + ":" + Soap.Envelope;
            envelopeElement.Attributes.Append(qnameAttr);
            envelopeElement.Attributes.Append(xmlnsAttr);
            return envelopeElement;
        }

     }

    internal abstract class SoapServerProtocolHelper {
        SoapServerProtocol protocol;
        string requestNamespace;

        protected SoapServerProtocolHelper(SoapServerProtocol protocol) {
            this.protocol = protocol;
        }

        protected SoapServerProtocolHelper(SoapServerProtocol protocol, string requestNamespace) {
            this.protocol = protocol;
            this.requestNamespace = requestNamespace;
        }

        internal static SoapServerProtocolHelper GetHelper(SoapServerProtocol protocol) {
            SoapServerMessage message = protocol.Message;
            long savedPosition = message.Stream.Position;
            XmlTextReader reader = GetXmlTextReader(message.ContentType, message.Stream);
            reader.MoveToContent();
            string requestNamespace = reader.NamespaceURI;
            SoapServerProtocolHelper helper = GetHelper(protocol, requestNamespace);
            message.Stream.Position = savedPosition;
            return helper;
        }
        
        internal static SoapServerProtocolHelper GetHelper(SoapServerProtocol protocol, string envelopeNs) {
            SoapServerProtocolHelper helper;
            if (envelopeNs == Soap.Namespace)
                helper = new Soap11ServerProtocolHelper(protocol, envelopeNs);
            else if (envelopeNs == Soap12.Namespace)
                helper = new Soap12ServerProtocolHelper(protocol, envelopeNs);
            else
                // just return a soap 1.1 helper -- the fact that the requestNs doesn't match will signal a version mismatch
                helper = new Soap11ServerProtocolHelper(protocol, envelopeNs);
            return helper;
        }

        internal abstract void SetResponseErrorCode(HttpResponse response, SoapException soapException);
        internal abstract void WriteFault(XmlWriter writer, SoapException soapException);
        internal abstract SoapServerMethod RouteRequest();
        internal abstract SoapProtocolVersion Version { get; }
        internal abstract ProtocolsEnum Protocol { get; }
        internal abstract string EnvelopeNs { get; }
        internal abstract string EncodingNs { get; }
        internal abstract string HttpContentType { get; }

        internal string RequestNamespace {
            get { return requestNamespace; }
        }

        protected SoapServerProtocol ServerProtocol {
            get { return protocol; }
        }

        protected SoapServerType ServerType {
            get { return (SoapServerType)protocol.ServerType; }
        }
        
        // tries to get to the first child element of body, ignoring details
        // such as the namespace of Envelope and Body (a version mismatch check will come later)
        protected XmlQualifiedName GetRequestElement() {
            SoapServerMessage message = ServerProtocol.Message;
            long savedPosition = message.Stream.Position;
            XmlTextReader reader = GetXmlTextReader(message.ContentType, message.Stream);
            reader.MoveToContent();
            
            requestNamespace = reader.NamespaceURI;
            reader.ReadStartElement(Soap.Envelope, requestNamespace);
            reader.MoveToContent();
            
            while (!reader.EOF && !reader.IsStartElement(Soap.Body, requestNamespace))
                reader.Skip();

            if (reader.EOF) {
                throw new InvalidOperationException(Res.GetString(Res.WebMissingBodyElement));
            }

            XmlQualifiedName element;
            if (reader.IsEmptyElement) {
                element = new XmlQualifiedName("", "");
            }
            else {
                reader.ReadStartElement(Soap.Body, requestNamespace);
                reader.MoveToContent();
                element = new XmlQualifiedName(reader.LocalName, reader.NamespaceURI);
            }
            message.Stream.Position = savedPosition;
            return element;
        }

        internal static XmlTextReader GetXmlTextReader(string contentType, Stream stream) {
            Encoding enc = RequestResponseUtils.GetEncoding2(contentType);
            XmlTextReader reader;
            if (enc != null)
                reader = new XmlTextReader(new StreamReader(stream, enc, true, 128));
            else
                reader = new XmlTextReader(stream);
            reader.Normalization = true;
            reader.XmlResolver = null;
            return reader;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\soapreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System;
    using System.Reflection;
    using System.Xml.Serialization;
    using System.Collections;
    using System.Web.Services.Configuration;
    using System.Web.Services.Description;
    using System.Globalization;
    using System.Xml;
    
    internal class Soap {
        internal const string Namespace = "http://schemas.xmlsoap.org/soap/envelope/";
        internal const string Encoding = "http://schemas.xmlsoap.org/soap/encoding/";
        internal const string Action = "SOAPAction";
        internal const string Envelope = "Envelope";
        internal const string Body = "Body";
        internal const string EncodingStyle = "encodingStyle";
        internal const string Header = "Header";
        internal const string MustUnderstand = "mustUnderstand";
        internal const string Actor = "actor";
        internal const string Fault = "Fault";
        internal const string FaultCode = "faultcode";
        internal const string FaultString = "faultstring";
        internal const string FaultActor = "faultactor";
        internal const string FaultDetail = "detail";
        internal const string ServerCode = "Server";
        internal const string VersionMismatchCode = "VersionMismatch";
        internal const string MustUnderstandCode = "MustUnderstand";
        internal const string ClientCode = "Client";
        internal const string ArrayType = "Array";
    }

    internal class Soap12 {
        internal const string Namespace = "http://www.w3.org/2002/06/soap-envelope";
        internal const string Encoding = "http://www.w3.org/2002/06/soap-encoding";
        internal const string RpcNamespace = "http://www.w3.org/2002/06/soap-rpc";
        internal const string UpgradeNamespace = "http://www.w3.org/2002/06/soap-upgrade";
        internal const string Upgrade = "Upgrade";
        internal const string UpgradeEnvelope = "envelope";
        internal const string UpgradeEnvelopeQname = "qname";
        internal const string Role = "role";
        internal const string FaultCode = "Code";
        internal const string FaultReason = "Reason";
        internal const string FaultRole = "Role";
        internal const string FaultNode = "Node";
        internal const string FaultCodeValue = "Value";
        internal const string FaultSubcode = "Subcode";
        internal const string FaultDetail = "Detail";

        internal static readonly string VersionMismatchCode = "VersionMismatch";
        internal static readonly string MustUnderstandCode = "MustUnderstand";
        internal static readonly string DataEncodingUnknownCode = "DataEncodingUnknown";
        internal static readonly string SenderCode = "Sender";
        internal static readonly string ReceiverCode = "Receiver";

        internal static readonly string RpcProcedureNotPresentSubcode = "ProcedureNotPresent";
        internal static readonly string RpcBadArgumentsSubcode = "BadArguments";

        internal static readonly string EncodingMissingIDFaultSubcode = "MissingID";
        internal static readonly string EncodingUntypedValueFaultSubcode = "UntypedValue";
    }

    internal class SoapReflectedHeader {
        internal Type headerType;
        internal MemberInfo memberInfo;
        internal SoapHeaderDirection direction;
        internal bool repeats;
        internal bool custom;
    }

    internal class SoapReflectedExtension : IComparable {
        Type type;
        SoapExtensionAttribute attribute;
        int priority;

        internal SoapReflectedExtension(Type type, SoapExtensionAttribute attribute) : this(type, attribute, attribute.Priority) {}

        internal SoapReflectedExtension(Type type, SoapExtensionAttribute attribute, int priority) {
            if (priority < 0) throw new ArgumentException(Res.GetString(Res.WebConfigInvalidExtensionPriority, priority), "priority");
            this.type = type;
            this.attribute = attribute;
            this.priority = priority;
        }

        internal SoapExtension CreateInstance(object initializer) {
            SoapExtension extension = (SoapExtension)Activator.CreateInstance(type);
            extension.Initialize(initializer);
            return extension;
        }

        internal object GetInitializer(LogicalMethodInfo methodInfo) {
            SoapExtension extension = (SoapExtension)Activator.CreateInstance(type);
            return extension.GetInitializer(methodInfo, attribute);
        }

        internal object GetInitializer(Type serviceType) {
            SoapExtension extension = (SoapExtension) Activator.CreateInstance(type);
            return extension.GetInitializer(serviceType);
        }
            
        internal static object[] GetInitializers(LogicalMethodInfo methodInfo, SoapReflectedExtension[] extensions) {
            object[] initializers = new object[extensions.Length];
            for (int i = 0; i < initializers.Length; i++)
                initializers[i] = extensions[i].GetInitializer(methodInfo);
            return initializers;
        }

        internal static object[] GetInitializers(Type serviceType, SoapReflectedExtension[] extensions) {
            object[] initializers = new object[extensions.Length];
            for (int i = 0; i < initializers.Length; i++)
                initializers[i] = extensions[i].GetInitializer(serviceType);
            return initializers;
        }

        public int CompareTo(object o) {
            // higher priorities (lower numbers) go at the front of the list
            return priority - ((SoapReflectedExtension)o).priority;
        }
    }

    internal class SoapReflectedMethod {
        internal LogicalMethodInfo methodInfo;
        internal string action;
        internal string name;
        internal XmlMembersMapping requestMappings;
        internal XmlMembersMapping responseMappings;
        internal XmlMembersMapping inHeaderMappings;
        internal XmlMembersMapping outHeaderMappings;
        internal SoapReflectedHeader[] headers;
        internal SoapReflectedExtension[] extensions;
        internal bool oneWay;
        internal bool rpc;
        internal SoapBindingUse use;
        internal SoapParameterStyle paramStyle;
        internal WebServiceBindingAttribute binding;
        internal XmlQualifiedName requestElementName;
        internal XmlQualifiedName portType;
    }

    // custom attributes are not returned in a "stable" order, so we sort them by name
    internal class SoapHeaderAttributeComparer : IComparer {
        public int Compare(object x, object y) {
            return string.Compare(((SoapHeaderAttribute)x).MemberName, ((SoapHeaderAttribute)y).MemberName, false, CultureInfo.InvariantCulture);
        }
    }

    internal class SoapReflector {

        class SoapParameterInfo {
            //internal string name;
            //internal string ns;
            internal ParameterInfo parameterInfo;
            internal XmlAttributes xmlAttributes;
            internal SoapAttributes soapAttributes;
        }

        class MethodAttribute {
            internal string action;
            internal string binding;
            internal string requestName;
            internal string requestNs;
            internal string responseName;
            internal string responseNs;
        }

        internal static bool ServiceDefaultIsEncoded(Type type){
            return ServiceDefaultIsEncoded(GetSoapServiceAttribute(type));
        }

        internal static bool ServiceDefaultIsEncoded(object soapServiceAttribute) {
            if (soapServiceAttribute == null)
                return false;
            SoapDocumentServiceAttribute documentService = soapServiceAttribute as SoapDocumentServiceAttribute;
            if (documentService == null // soapServiceAttribute is SoapRpcServiceAttribute
                ||
                documentService.Use == SoapBindingUse.Encoded )                   
                return true;
            return false;
        }
        
        internal static string GetEncodedNamespace(string ns, bool serviceDefaultIsEncoded) {
            if(serviceDefaultIsEncoded)
                return ns;
            if (ns.EndsWith("/"))
                return ns + "encodedTypes";
            return ns + "/encodedTypes";
        }

        internal static string GetLiteralNamespace(string ns, bool serviceDefaultIsEncoded) {
            if(!serviceDefaultIsEncoded)
                return ns;
            if (ns.EndsWith("/"))
                return ns + "literalTypes";
            return ns + "/literalTypes";
        }

        internal static SoapReflectionImporter CreateSoapImporter(string defaultNs, bool serviceDefaultIsEncoded) {
            return new SoapReflectionImporter(GetEncodedNamespace(defaultNs, serviceDefaultIsEncoded));
        }

        internal static XmlReflectionImporter CreateXmlImporter(string defaultNs, bool serviceDefaultIsEncoded) {
            return new XmlReflectionImporter(GetLiteralNamespace(defaultNs, serviceDefaultIsEncoded));
        }
        
        internal static void IncludeTypes(LogicalMethodInfo[] methods, SoapReflectionImporter importer) {
            for (int i = 0; i < methods.Length; i++) {
                LogicalMethodInfo method = methods[i];
                importer.IncludeTypes(method.DeclaringType);
                importer.IncludeTypes(method.CustomAttributeProvider);
            }
        }

        internal static object GetSoapMethodAttribute(LogicalMethodInfo methodInfo) {
            object[] rpcMethodAttributes = methodInfo.GetCustomAttributes(typeof(SoapRpcMethodAttribute));
            object[] docMethodAttributes = methodInfo.GetCustomAttributes(typeof(SoapDocumentMethodAttribute));
            if (rpcMethodAttributes.Length > 0) {
                if (docMethodAttributes.Length > 0) throw new ArgumentException(Res.GetString(Res.WebBothMethodAttrs), "methodInfo");
                return rpcMethodAttributes[0];
            }
            else if (docMethodAttributes.Length > 0)
                return docMethodAttributes[0];
            else
                return null;
        }

        internal static object GetSoapServiceAttribute(Type type) {
            object[] rpcServiceAttributes = type.GetCustomAttributes(typeof(SoapRpcServiceAttribute), false);
            object[] docServiceAttributes = type.GetCustomAttributes(typeof(SoapDocumentServiceAttribute), false);
            if (rpcServiceAttributes.Length > 0) {
                if (docServiceAttributes.Length > 0) throw new ArgumentException(Res.GetString(Res.WebBothServiceAttrs), "methodInfo");
                return rpcServiceAttributes[0];
            }
            else if (docServiceAttributes.Length > 0)
                return docServiceAttributes[0];
            else
                return null;
        }

        internal static SoapServiceRoutingStyle GetSoapServiceRoutingStyle(object soapServiceAttribute) {
            if (soapServiceAttribute is SoapRpcServiceAttribute) 
                return ((SoapRpcServiceAttribute)soapServiceAttribute).RoutingStyle;
            else if (soapServiceAttribute is SoapDocumentServiceAttribute) 
                return ((SoapDocumentServiceAttribute)soapServiceAttribute).RoutingStyle;
            else 
                return SoapServiceRoutingStyle.SoapAction;
        }

        internal static string GetSoapMethodBinding(LogicalMethodInfo method) {
            object[] attrs = method.GetCustomAttributes(typeof(SoapDocumentMethodAttribute));
            if (attrs.Length == 0) {
                attrs = method.GetCustomAttributes(typeof(SoapRpcMethodAttribute));
                if (attrs.Length == 0) return string.Empty;
                return ((SoapRpcMethodAttribute)attrs[0]).Binding;
            }
            else
                return ((SoapDocumentMethodAttribute)attrs[0]).Binding;
        }

        internal static SoapReflectedMethod ReflectMethod(LogicalMethodInfo methodInfo, bool client, XmlReflectionImporter xmlImporter, SoapReflectionImporter soapImporter, string defaultNs) {
            try {
                SoapReflectedMethod soapMethod = new SoapReflectedMethod();
                MethodAttribute methodAttribute = new MethodAttribute();

                object serviceAttr = GetSoapServiceAttribute(methodInfo.DeclaringType);
                bool serviceDefaultIsEncoded = ServiceDefaultIsEncoded(serviceAttr);
                object methodAttr = GetSoapMethodAttribute(methodInfo);
                if (methodAttr == null) {
                    if (client) return null; // method attribute required on the client
                    if (serviceAttr is SoapRpcServiceAttribute) 
                        methodAttr = new SoapRpcMethodAttribute();
                    else
                        methodAttr = new SoapDocumentMethodAttribute();
                }
                
                if (methodAttr is SoapRpcMethodAttribute) {
                    SoapRpcMethodAttribute attr = (SoapRpcMethodAttribute)methodAttr;

                    soapMethod.rpc = true;
                    soapMethod.use = SoapBindingUse.Encoded;
                    soapMethod.oneWay = attr.OneWay;
                    methodAttribute.action = attr.Action;
                    methodAttribute.binding = attr.Binding;
                    methodAttribute.requestName = attr.RequestElementName;
                    methodAttribute.requestNs = attr.RequestNamespace;
                    methodAttribute.responseName = attr.ResponseElementName;
                    methodAttribute.responseNs = attr.ResponseNamespace;
                }
                else {
                    SoapDocumentMethodAttribute attr = (SoapDocumentMethodAttribute)methodAttr;
                    
                    soapMethod.rpc = false;
                    soapMethod.use = attr.Use;
                    soapMethod.paramStyle = attr.ParameterStyle;
                    soapMethod.oneWay = attr.OneWay;
                    methodAttribute.action = attr.Action;
                    methodAttribute.binding = attr.Binding;
                    methodAttribute.requestName = attr.RequestElementName;
                    methodAttribute.requestNs = attr.RequestNamespace;
                    methodAttribute.responseName = attr.ResponseElementName;
                    methodAttribute.responseNs = attr.ResponseNamespace;

                    if (soapMethod.use == SoapBindingUse.Default) {
                        if (serviceAttr is SoapDocumentServiceAttribute)
                            soapMethod.use = ((SoapDocumentServiceAttribute)serviceAttr).Use;
                        if (soapMethod.use == SoapBindingUse.Default)
                            soapMethod.use = SoapBindingUse.Literal;
                    }
                    if (soapMethod.paramStyle == SoapParameterStyle.Default) {
                        if (serviceAttr is SoapDocumentServiceAttribute)
                            soapMethod.paramStyle = ((SoapDocumentServiceAttribute)serviceAttr).ParameterStyle;
                        if (soapMethod.paramStyle == SoapParameterStyle.Default)
                            soapMethod.paramStyle = SoapParameterStyle.Wrapped;
                    }
                }

                if (methodAttribute.binding.Length > 0) {
                    if (client) throw new InvalidOperationException(Res.GetString(Res.WebInvalidBindingPlacement, methodAttr.GetType().Name));
                    soapMethod.binding = WebServiceBindingReflector.GetAttribute(methodInfo, methodAttribute.binding);
                }

                WebMethodAttribute webMethodAttribute = WebMethodReflector.GetAttribute(methodInfo);
                soapMethod.name = webMethodAttribute.MessageName;
                if (soapMethod.name.Length == 0) soapMethod.name = methodInfo.Name;

                string requestElementName;
                if (soapMethod.rpc) {
                    requestElementName = methodInfo.Name;
                }
                else {
                    requestElementName = methodAttribute.requestName.Length == 0 ? soapMethod.name : methodAttribute.requestName;
                }
                string requestNamespace = methodAttribute.requestNs;

                if (requestNamespace == null){
                    if (soapMethod.binding != null && soapMethod.binding.Namespace != null && soapMethod.binding.Namespace.Length != 0)
                        requestNamespace = soapMethod.binding.Namespace;
                    else
                        requestNamespace = defaultNs;
                }
                
                string responseElementName = methodAttribute.responseName.Length == 0 ? soapMethod.name + "Response": methodAttribute.responseName;
                string responseNamespace = methodAttribute.responseNs;

                if (responseNamespace == null){
                    if (soapMethod.binding != null && soapMethod.binding.Namespace != null && soapMethod.binding.Namespace.Length != 0)
                        responseNamespace = soapMethod.binding.Namespace;
                    else
                        responseNamespace = defaultNs;
                }

                SoapParameterInfo[] inParameters = ReflectParameters(methodInfo.InParameters, requestNamespace);
                SoapParameterInfo[] outParameters = ReflectParameters(methodInfo.OutParameters, responseNamespace);

                soapMethod.action = methodAttribute.action;
                if (soapMethod.action == null)
                    soapMethod.action = GetDefaultAction(defaultNs, methodInfo);
                soapMethod.methodInfo = methodInfo;

                if (soapMethod.oneWay) {
                    if (outParameters.Length > 0) throw new ArgumentException(Res.GetString(Res.WebOneWayOutParameters), "methodInfo");
                    if (methodInfo.ReturnType != typeof(void)) throw new ArgumentException(Res.GetString(Res.WebOneWayReturnValue), "methodInfo");
                }

                XmlReflectionMember[] members = new XmlReflectionMember[inParameters.Length];
                for (int i = 0; i < members.Length; i++) {
                    SoapParameterInfo soapParamInfo = inParameters[i];
                    XmlReflectionMember member = new XmlReflectionMember();
                    member.MemberName = soapParamInfo.parameterInfo.Name;
                    member.MemberType = soapParamInfo.parameterInfo.ParameterType;
                    if (member.MemberType.IsByRef)
                        member.MemberType = member.MemberType.GetElementType();
                    member.XmlAttributes = soapParamInfo.xmlAttributes;
                    member.SoapAttributes = soapParamInfo.soapAttributes;
                    members[i] = member;
                }
                soapMethod.requestMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, soapMethod.rpc, soapMethod.use, soapMethod.paramStyle, requestElementName, requestNamespace, methodAttribute.requestNs == null, members, true);

                if (GetSoapServiceRoutingStyle(serviceAttr) == SoapServiceRoutingStyle.RequestElement &&
                    soapMethod.paramStyle == SoapParameterStyle.Bare &&
                    soapMethod.requestMappings.Count != 1)
                    throw new ArgumentException(Res.GetString(Res.WhenUsingAMessageStyleOfParametersAsDocument0), "methodInfo");

                string elementName = "";
                string elementNamespace = "";
                if (soapMethod.paramStyle == SoapParameterStyle.Bare) {
                    if (soapMethod.requestMappings.Count == 1) {
                        elementName = soapMethod.requestMappings[0].ElementName;
                        elementNamespace = soapMethod.requestMappings[0].Namespace;
                    }
                    // else: can't route on request element -- we match on an empty qname, 
                    //       normal rules apply for duplicates
                }
                else {
                    elementName = soapMethod.requestMappings.ElementName;
                    elementNamespace = soapMethod.requestMappings.Namespace;
                }
                soapMethod.requestElementName = new XmlQualifiedName(elementName, elementNamespace);
                
                if (!soapMethod.oneWay) {
                    int numOutParams = outParameters.Length;
                    int count = 0;
                    CodeIdentifiers identifiers = null;
                    if (methodInfo.ReturnType != typeof(void)) {
                        numOutParams++;
                        count = 1;
                        identifiers = new CodeIdentifiers();
                    }
                    members = new XmlReflectionMember[numOutParams];

                    for (int i = 0; i < outParameters.Length; i++) {
                        SoapParameterInfo soapParamInfo = outParameters[i];
                        XmlReflectionMember member = new XmlReflectionMember();
                        member.MemberName = soapParamInfo.parameterInfo.Name;
                        member.MemberType = soapParamInfo.parameterInfo.ParameterType;
                        if (member.MemberType.IsByRef)
                            member.MemberType = member.MemberType.GetElementType();
                        member.XmlAttributes = soapParamInfo.xmlAttributes;
                        member.SoapAttributes = soapParamInfo.soapAttributes;
                        members[count++] = member;
                        if (identifiers != null)
                            identifiers.Add(member.MemberName, null);
                    }
                    if (methodInfo.ReturnType != typeof(void)) {
                        XmlReflectionMember member = new XmlReflectionMember();
                        member.MemberName = identifiers.MakeUnique(soapMethod.name + "Result");
                        member.MemberType = methodInfo.ReturnType;
                        member.IsReturnValue = true;

                        member.XmlAttributes = new XmlAttributes(methodInfo.ReturnTypeCustomAttributeProvider);
                        member.XmlAttributes.XmlRoot = null; // Ignore XmlRoot attribute used by get/post
                        member.SoapAttributes = new SoapAttributes(methodInfo.ReturnTypeCustomAttributeProvider);

                        members[0] = member;
                    }
                    soapMethod.responseMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, soapMethod.rpc, soapMethod.use, soapMethod.paramStyle, responseElementName, responseNamespace, methodAttribute.responseNs == null, members, false);

                }

                SoapExtensionAttribute[] extensionAttributes = (SoapExtensionAttribute[])methodInfo.GetCustomAttributes(typeof(SoapExtensionAttribute));
                soapMethod.extensions = new SoapReflectedExtension[extensionAttributes.Length];
                for (int i = 0; i < extensionAttributes.Length; i++)
                    soapMethod.extensions[i] = new SoapReflectedExtension(extensionAttributes[i].ExtensionType, extensionAttributes[i]);
                Array.Sort(soapMethod.extensions);

                SoapHeaderAttribute[] headerAttributes = (SoapHeaderAttribute[])methodInfo.GetCustomAttributes(typeof(SoapHeaderAttribute));
                Array.Sort(headerAttributes, new SoapHeaderAttributeComparer());
                Hashtable headerTypes = new Hashtable();
                soapMethod.headers = new SoapReflectedHeader[headerAttributes.Length];
                int front = 0;
                int back = soapMethod.headers.Length;
                ArrayList inHeaders = new ArrayList();
                ArrayList outHeaders = new ArrayList();
                for (int i = 0; i < soapMethod.headers.Length; i++) {
                    SoapHeaderAttribute headerAttribute = headerAttributes[i];
                    SoapReflectedHeader soapHeader = new SoapReflectedHeader();
                    Type declaringType = methodInfo.DeclaringType;
                    if ((soapHeader.memberInfo = declaringType.GetField(headerAttribute.MemberName)) != null) {
                        soapHeader.headerType = ((FieldInfo)soapHeader.memberInfo).FieldType;
                    }
                    else  if ((soapHeader.memberInfo = declaringType.GetProperty(headerAttribute.MemberName)) != null) {
                        soapHeader.headerType = ((PropertyInfo)soapHeader.memberInfo).PropertyType;
                    }
                    else {
                        throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebHeaderMissing);
                    }
                    if (soapHeader.headerType.IsArray) {
                        soapHeader.headerType = soapHeader.headerType.GetElementType();
                        soapHeader.repeats = true;
                        if (soapHeader.headerType != typeof(SoapUnknownHeader) && soapHeader.headerType != typeof(SoapHeader))
                            throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebHeaderType);
                    }
                    if (MemberHelper.IsStatic(soapHeader.memberInfo)) throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebHeaderStatic);
                    if (!MemberHelper.CanRead(soapHeader.memberInfo)) throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebHeaderRead);
                    if (!MemberHelper.CanWrite(soapHeader.memberInfo)) throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebHeaderWrite);
                    if (!typeof(SoapHeader).IsAssignableFrom(soapHeader.headerType)) throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebHeaderType);
                    
                    SoapHeaderDirection direction = headerAttribute.Direction;
                    if (soapMethod.oneWay && (direction & (SoapHeaderDirection.Out | SoapHeaderDirection.Fault)) != 0) throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebHeaderOneWayOut);
                    if (headerTypes.Contains(soapHeader.headerType)) {
                        SoapHeaderDirection prevDirection = (SoapHeaderDirection) headerTypes[soapHeader.headerType];
                        if ((prevDirection & direction) != 0)
                            throw HeaderException(headerAttribute.MemberName, methodInfo.DeclaringType, Res.WebMultiplyDeclaredHeaderTypes);
                        headerTypes[soapHeader.headerType] = direction | prevDirection;
                    }
                    else
                        headerTypes[soapHeader.headerType] = direction;
                    
                    if (soapHeader.headerType != typeof(SoapHeader) && soapHeader.headerType != typeof(SoapUnknownHeader)) {
                        XmlReflectionMember member = new XmlReflectionMember();
                        member.MemberName = soapHeader.headerType.Name;
                        member.MemberType = soapHeader.headerType;
                        member.OverrideIsNullable = true;
                        
                        if ((direction & SoapHeaderDirection.In) != 0)
                            inHeaders.Add(member);
                        if ((direction & (SoapHeaderDirection.Out | SoapHeaderDirection.Fault)) != 0)
                            outHeaders.Add(member);

                        soapHeader.custom = true;
                    }
                    soapHeader.direction = direction;
                    // Put generic header mappings at the end of the list so they are found last during header processing
                    if (!soapHeader.custom) {
                        soapMethod.headers[--back] = soapHeader;
                    }
                    else {
                        soapMethod.headers[front++] = soapHeader;
                    }
                }
                soapMethod.inHeaderMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, false, soapMethod.use, SoapParameterStyle.Bare, "InHeaders", defaultNs, true, (XmlReflectionMember[]) inHeaders.ToArray(typeof(XmlReflectionMember)), false);
                if (!soapMethod.oneWay)
                    soapMethod.outHeaderMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, false, soapMethod.use, SoapParameterStyle.Bare, "OutHeaders", defaultNs, true, (XmlReflectionMember[]) outHeaders.ToArray(typeof(XmlReflectionMember)), false);
                
                return soapMethod;
            }
            catch (Exception e) {
                throw new InvalidOperationException(Res.GetString(Res.WebReflectionErrorMethod, methodInfo.DeclaringType.Name, methodInfo.Name), e);
            }
        }

        static XmlMembersMapping ImportMembersMapping(XmlReflectionImporter xmlImporter, SoapReflectionImporter soapImporter, bool serviceDefaultIsEncoded, bool rpc, SoapBindingUse use, SoapParameterStyle paramStyle, 
            string elementName, string elementNamespace, bool nsIsDefault, XmlReflectionMember[] members, bool validate) {
            if (use == SoapBindingUse.Encoded) {
                string ns = (!rpc && paramStyle != SoapParameterStyle.Bare && nsIsDefault) ? GetEncodedNamespace(elementNamespace, serviceDefaultIsEncoded) : elementNamespace;
                return soapImporter.ImportMembersMapping(elementName, ns, members, rpc || paramStyle != SoapParameterStyle.Bare, rpc, validate);
            }
            else {
                string ns =  nsIsDefault ? GetLiteralNamespace(elementNamespace, serviceDefaultIsEncoded) : elementNamespace;
                return xmlImporter.ImportMembersMapping(elementName, ns, members, paramStyle != SoapParameterStyle.Bare);
            }
        }

        static Exception HeaderException(string memberName, Type declaringType, string description) {
            return new Exception(Res.GetString(description, declaringType.Name, memberName));
        }

        static SoapParameterInfo[] ReflectParameters(ParameterInfo[] paramInfos, string ns) {
            SoapParameterInfo[] soapParamInfos = new SoapParameterInfo[paramInfos.Length];
            for (int i = 0; i < paramInfos.Length; i++) {
                SoapParameterInfo soapParamInfo = new SoapParameterInfo();
                
                ParameterInfo paramInfo = paramInfos[i];

                if (paramInfo.ParameterType.IsArray && paramInfo.ParameterType.GetArrayRank() > 1)
                    throw new InvalidOperationException(Res.GetString(Res.WebMultiDimArray));

                soapParamInfo.xmlAttributes = new XmlAttributes(paramInfo);
                soapParamInfo.soapAttributes = new SoapAttributes(paramInfo);
                soapParamInfo.parameterInfo = paramInfo;
                soapParamInfos[i] = soapParamInfo;
            }
            return soapParamInfos;
        } 

        static string GetDefaultAction(string defaultNs, LogicalMethodInfo methodInfo) {
            WebMethodAttribute methodAttribute = WebMethodReflector.GetAttribute(methodInfo);
            string messageName = methodAttribute.MessageName;
            if (messageName.Length == 0) messageName = methodInfo.Name;
            if (defaultNs.EndsWith("/"))
                return defaultNs + messageName;
            return defaultNs + "/" + messageName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\urlparameterreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="UrlParameterReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;

    /// <include file='doc\UrlParameterReader.uex' path='docs/doc[@for="UrlParameterReader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class UrlParameterReader : ValueCollectionParameterReader {
        /// <include file='doc\UrlParameterReader.uex' path='docs/doc[@for="UrlParameterReader.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object[] Read(HttpRequest request) {
            return Read(request.QueryString);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\urlparameterwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="UrlParameterWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Text;
    using System.Web.Services;
    using System.Net;

    /// <include file='doc\UrlParameterWriter.uex' path='docs/doc[@for="UrlParameterWriter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class UrlParameterWriter : UrlEncodedParameterWriter {
        /// <include file='doc\UrlParameterWriter.uex' path='docs/doc[@for="UrlParameterWriter.GetRequestUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string GetRequestUrl(string url, object[] parameters) {
            if (parameters.Length == 0) return url;
            StringBuilder builder = new StringBuilder(url);
            builder.Append('?');
            TextWriter writer = new StringWriter(builder);            
            Encode(writer, parameters);
            writer.Flush();
            return builder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\servicesunmanaged\performancecounterlib\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\valuecollectionparameterreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValueCollectionParameterReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Web.Services;
    using System.Text;
    using System.Security.Permissions;


    /// <include file='doc\ValueCollectionParameterReader.uex' path='docs/doc[@for="ValueCollectionParameterReader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class ValueCollectionParameterReader : MimeParameterReader {
        ParameterInfo[] paramInfos;

        /// <include file='doc\ValueCollectionParameterReader.uex' path='docs/doc[@for="ValueCollectionParameterReader.Initialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Initialize(object o) {
            paramInfos = (ParameterInfo[])o;
        }

        /// <include file='doc\ValueCollectionParameterReader.uex' path='docs/doc[@for="ValueCollectionParameterReader.GetInitializer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetInitializer(LogicalMethodInfo methodInfo) {
            if (!IsSupported(methodInfo)) return null;
            return methodInfo.InParameters;
        }

        /// <include file='doc\ValueCollectionParameterReader.uex' path='docs/doc[@for="ValueCollectionParameterReader.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object[] Read(NameValueCollection collection) {
            object[] parameters = new object[paramInfos.Length];
            for (int i = 0; i < paramInfos.Length; i++) {
                ParameterInfo paramInfo = paramInfos[i];
                if (paramInfo.ParameterType.IsArray) {
                    string[] arrayValues = collection.GetValues(paramInfo.Name);
                    Type arrayType = paramInfo.ParameterType.GetElementType();
                    Array array = Array.CreateInstance(arrayType, arrayValues.Length);
                    for (int j = 0; j < arrayValues.Length; j++) {
                        string value = arrayValues[j];
                        array.SetValue(ScalarFormatter.FromString(value, arrayType), j);
                    }
                    parameters[i] = array;
                }
                else {
                    string value = collection[paramInfo.Name];
                    if (value == null) throw new InvalidOperationException(Res.GetString(Res.WebMissingParameter, paramInfo.Name));
                    parameters[i] = ScalarFormatter.FromString(value, paramInfo.ParameterType);
                }
            }
            return parameters;
        }

        /// <include file='doc\ValueCollectionParameterReader.uex' path='docs/doc[@for="ValueCollectionParameterReader.IsSupported"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        static public bool IsSupported(LogicalMethodInfo methodInfo) {
            if (methodInfo.OutParameters.Length > 0)
                return false;
            ParameterInfo[] paramInfos = methodInfo.InParameters;
            for (int i = 0; i < paramInfos.Length; i++)
                if (!IsSupported(paramInfos[i]))
                    return false;
            return true;
        }

        /// <include file='doc\ValueCollectionParameterReader.uex' path='docs/doc[@for="ValueCollectionParameterReader.IsSupported1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        static public bool IsSupported(ParameterInfo paramInfo) {
            Type type = paramInfo.ParameterType;
            if (type.IsArray)
                type = type.GetElementType();
            return ScalarFormatter.IsTypeSupported(type);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\webservicehandlerfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebServiceHandlerFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System.Diagnostics;
    using System;
    using System.Web;
    using Microsoft.Win32;
    //using System.Reflection;
    using System.Web.UI;
    using System.ComponentModel; // for CompModSwitches
    using System.IO;
    using System.Web.Services.Configuration;
    using System.Security.Permissions;
    
    /// <include file='doc\WebServiceHandlerFactory.uex' path='docs/doc[@for="WebServiceHandlerFactory"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class WebServiceHandlerFactory : IHttpHandlerFactory{
        /*
        static WebServiceHandlerFactory() {            
            Stream stream = new FileStream("c:\\out.txt", FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite); //(FileMode.OpenOrCreate);            
            TraceListener listener = new TextWriterTraceListener(stream);            
            Debug.AutoFlush = true;            
            Debug.Listeners.Add(listener);            
            Debug.WriteLine("--------------");            
        }
        */

#if DEBUG
        void DumpRequest(HttpContext context) {
            HttpRequest request = context.Request;
            Debug.WriteLine("Process Request called.");
            Debug.WriteLine("Path = " + request.Path);
            Debug.WriteLine("PhysicalPath = " + request.PhysicalPath);
            Debug.WriteLine("Query = " + request.Url.Query);
            Debug.WriteLine("HttpMethod = " + request.HttpMethod);
            Debug.WriteLine("ContentType = " + request.ContentType);
            Debug.WriteLine("PathInfo = " + request.PathInfo);        
            Debug.WriteLine("----Http request headers: ----");
            System.Collections.Specialized.NameValueCollection headers = request.Headers;
            foreach (string name in headers) {
                string value = headers[name];
                if (value != null && value.Length > 0)
                    Debug.WriteLine(name + "=" + headers[name]);
            }                
        }
#endif
        
        
        /// <include file='doc\WebServiceHandlerFactory.uex' path='docs/doc[@for="WebServiceHandlerFactory.GetHandler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IHttpHandler GetHandler(HttpContext context, string verb, string url, string filePath) {
            new AspNetHostingPermission(AspNetHostingPermissionLevel.Minimal).Demand();
            //if (CompModSwitches.Remote.TraceVerbose) DumpRequest(context);
            //System.Diagnostics.Debugger.Break();
            #if DEBUG
            if (CompModSwitches.Remote.TraceVerbose) DumpRequest(context);
            #endif
            Type type =WebServiceParser.GetCompiledType(filePath,context);
            return CoreGetHandler(type, context, context.Request, context.Response);
        }

        internal IHttpHandler CoreGetHandler(Type type, HttpContext context, HttpRequest request, HttpResponse response) {
            //Debug.Listeners.Add(new TextWriterTraceListener(response.OutputStream));

            ServerProtocolFactory[] protocolFactories = WebServicesConfiguration.Current.ServerProtocolFactories;
            ServerProtocol protocol = null;
            bool abort = false;
            for (int i = 0; i < protocolFactories.Length; i++) {
                try {
                    if ((protocol = protocolFactories[i].Create(type, context, request, response, out abort)) != null || abort)
                        break;
                }
                catch (Exception e) {
                    throw new InvalidOperationException(Res.GetString(Res.FailedToHandleRequest0), e);
                }
            }

            if (abort)
                return new NopHandler();

            if (protocol == null)
                throw new InvalidOperationException(Res.GetString(Res.WebUnrecognizedRequestFormat));

            bool isAsync = protocol.MethodInfo.IsAsync;
            bool requiresSession = protocol.MethodAttribute.EnableSession;

            if (isAsync) {
                if (requiresSession) {
                    return new AsyncSessionHandler(protocol);
                }
                else {
                    return new AsyncSessionlessHandler(protocol);
                }
            }
            else {
                if (requiresSession) {
                    return new SyncSessionHandler(protocol);
                }
                else {
                    return new SyncSessionlessHandler(protocol);
                }
            }
        }

        /// <include file='doc\WebServiceHandlerFactory.uex' path='docs/doc[@for="WebServiceHandlerFactory.ReleaseHandler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ReleaseHandler(IHttpHandler handler) {
        }
    }

    internal class NopHandler : IHttpHandler {

        /// <include file='doc\WebServiceHandlerFactory.uex' path='docs/doc[@for="NopHandler.IsReusable"]/*' />
        /// <devdoc>
        ///      IHttpHandler.IsReusable.
        /// </devdoc>
        public bool IsReusable {
            get { return false; }
        }

        /// <include file='doc\WebServiceHandlerFactory.uex' path='docs/doc[@for="NopHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///      IHttpHandler.ProcessRequest.
        /// </devdoc>
        public void ProcessRequest(HttpContext context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\xmlreturnwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlReturnWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Text;
    
    internal class XmlReturnWriter : MimeReturnWriter {
        XmlSerializer xmlSerializer;
        
        public override void Initialize(object o) {
            xmlSerializer = (XmlSerializer)o;
        }

        public override object[] GetInitializers(LogicalMethodInfo[] methodInfos) {
            return XmlReturn.GetInitializers(methodInfos);
        }
        
        public override object GetInitializer(LogicalMethodInfo methodInfo) {
            return XmlReturn.GetInitializer(methodInfo);
        }

        internal override void Write(HttpResponse response, Stream outputStream, object returnValue) {
            Encoding encoding = new UTF8Encoding(false);
            response.ContentType = ContentType.Compose("text/xml", encoding);
            xmlSerializer.Serialize(new StreamWriter(outputStream, encoding), returnValue);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\webservicehandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebServiceHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.IO;
    using System.Collections;
    using System.Web;
    using System.Web.SessionState;
    using System.Web.Services.Interop;
    using System.Configuration;
    using Microsoft.Win32;
    using System.Threading;    
    using System.Text;
    using System.Web.UI;
    using System.Web.Util;
    using System.Web.UI.WebControls;
    using System.ComponentModel; // for CompModSwitches
    using System.EnterpriseServices;
    using System.Runtime.Remoting.Messaging;

    internal class WebServiceHandler {
        ServerProtocol protocol;
        Exception exception;
        AsyncCallback asyncCallback;
        ManualResetEvent asyncBeginComplete;
        int asyncCallbackCalls;
        bool wroteException;

        internal WebServiceHandler(ServerProtocol protocol) {
            this.protocol = protocol;
        }

        // Flush the trace file after each request so that the trace output makes it to the disk.
        static void TraceFlush() {
            Debug.Flush();
        }
        
        void PrepareContext() {
            this.exception = null;
            this.wroteException = false;
            this.asyncCallback = null;
            this.asyncBeginComplete = new ManualResetEvent(false);
            this.asyncCallbackCalls = 0;
            if (protocol.IsOneWay) 
                return;
            HttpContext context = protocol.Context;
            if (context == null) return; // context is null in non-network case

            // we want the default to be no caching on the client
            int cacheDuration = protocol.MethodAttribute.CacheDuration;
            if (cacheDuration > 0) {
                context.Response.Cache.SetCacheability(HttpCacheability.Server);
                context.Response.Cache.SetExpires(DateTime.Now.AddSeconds(cacheDuration));
                context.Response.Cache.SetSlidingExpiration(false);
                // with soap 1.2 the action is a param in the content-type
                context.Response.Cache.VaryByHeaders["Content-type"] = true;
                context.Response.Cache.VaryByHeaders["SOAPAction"] = true;
                context.Response.Cache.VaryByParams["*"] = true;
            }
            else {
                context.Response.Cache.SetNoServerCaching();
                context.Response.Cache.SetMaxAge(TimeSpan.Zero);
            }
            context.Response.BufferOutput = protocol.MethodAttribute.BufferResponse;
            context.Response.ContentType = null;
            
        }
        
        void WriteException(Exception e) {
            if (this.wroteException) return;

            if (CompModSwitches.Remote.TraceVerbose) Debug.WriteLine("Server Exception: " + e.ToString());
            if (e is TargetInvocationException) {
                if (CompModSwitches.Remote.TraceVerbose) Debug.WriteLine("TargetInvocationException caught.");
                e = e.InnerException;
            }

            this.wroteException = protocol.WriteException(e, protocol.Response.OutputStream);
            if (!this.wroteException)
                throw e;
        }                        
                                
        void Invoke() {                
            PrepareContext();                
            object[] parameters = protocol.ReadParameters();
            protocol.CreateServerInstance();       
            
            string stringBuffer;
            RemoteDebugger debugger = null;
            if (!protocol.IsOneWay && RemoteDebugger.IsServerCallInEnabled(protocol, out stringBuffer)) {
                debugger = new RemoteDebugger();
                debugger.NotifyServerCallEnter(protocol, stringBuffer);
            }

            try {        
                object[] returnValues = protocol.MethodInfo.Invoke(protocol.Target, parameters);
                WriteReturns(returnValues);
            }                    
            catch (Exception e) {
                if (!protocol.IsOneWay)
                    WriteException(e);
                throw;
            }
            finally {                
                protocol.DisposeServerInstance();
                
                if (debugger != null) 
                    debugger.NotifyServerCallExit(protocol.Response);
            }        
        }        

        // By keeping this in a separate method we avoid jitting system.enterpriseservices.dll in cases
        // where transactions are not used.
        void InvokeTransacted() {
            Transactions.InvokeTransacted(new TransactedCallback(this.Invoke), protocol.MethodAttribute.TransactionOption);
        }

        void ThrowInitException(){
            throw new Exception(Res.GetString(Res.WebConfigExtensionError), protocol.OnewayInitException);
        }

        protected void CoreProcessRequest() {
            try {                
                bool transacted = protocol.MethodAttribute.TransactionEnabled;
                if (protocol.IsOneWay) {
                    WorkItemCallback callback = null;
                    if(protocol.OnewayInitException != null)
                        callback = new WorkItemCallback(this.ThrowInitException);
                    else
                        callback = transacted ? new WorkItemCallback(this.OneWayInvokeTransacted) : new WorkItemCallback(this.OneWayInvoke);
                    WorkItem.Post(callback);
                    protocol.WriteOneWayResponse();       
                }
                else if (transacted)
                    InvokeTransacted();
                else
                    Invoke();                                
            }
            catch (Exception e) {
                WriteException(e);
            }
            
            TraceFlush();
        }

        private HttpContext SwitchContext(HttpContext context) {
            HttpContext oldContext = HttpContext.Current;
            HttpContext.Current = context;
            return oldContext;
        }

        private void OneWayInvoke() {
            HttpContext oldContext = null;
            if (protocol.Context != null)
                oldContext = SwitchContext(protocol.Context);

            try {
                Invoke();
            }
            finally {
                if (oldContext != null)
                    SwitchContext(oldContext);
            }
        }

        private void OneWayInvokeTransacted() {
            HttpContext oldContext = null;
            if (protocol.Context != null)
                oldContext = SwitchContext(protocol.Context);

            try {
                InvokeTransacted();
            }
            finally {
                if (oldContext != null)
                    SwitchContext(oldContext);
            }
        }

        private void Callback(IAsyncResult result) {
            if (!result.CompletedSynchronously)
                this.asyncBeginComplete.WaitOne();
            DoCallback(result);
        }

        private void DoCallback(IAsyncResult result) {
            if (this.asyncCallback != null) {
                if (System.Threading.Interlocked.Increment(ref this.asyncCallbackCalls) == 1) {
                    this.asyncCallback.Invoke(result);
                }
            }
        }

        protected IAsyncResult BeginCoreProcessRequest(AsyncCallback callback, object asyncState) {
            IAsyncResult asyncResult;
            
            if (protocol.MethodAttribute.TransactionEnabled)
                throw new InvalidOperationException(Res.GetString(Res.WebAsyncTransaction));

            if (protocol.IsOneWay) {
                WorkItem.Post(new WorkItemCallback(this.OneWayAsyncInvoke));
                asyncResult = new CompletedAsyncResult(asyncState, true);
                if (callback != null)
                    callback.Invoke(asyncResult);
            }
            else
                asyncResult = BeginInvoke(callback, asyncState);
            return asyncResult;
        }

        private void OneWayAsyncInvoke() {
            if(protocol.OnewayInitException != null)
                ThrowInitException();
            else {
                HttpContext oldContext = null;
                if (protocol.Context != null)
                    oldContext = SwitchContext(protocol.Context);

                try {
                    BeginInvoke(new AsyncCallback(this.OneWayCallback), null);
                }
                finally {
                    if (oldContext != null)
                        SwitchContext(oldContext);
                }
            }
        }

        private IAsyncResult BeginInvoke(AsyncCallback callback, object asyncState) {
            IAsyncResult asyncResult;
            try {
                PrepareContext();
                object[] parameters = protocol.ReadParameters();
                protocol.CreateServerInstance();                               
                this.asyncCallback = callback;
                asyncResult =  protocol.MethodInfo.BeginInvoke(protocol.Target, parameters, new AsyncCallback(this.Callback), asyncState);                
                if (asyncResult == null) throw new InvalidOperationException(Res.GetString(Res.WebNullAsyncResultInBegin));
            }
            catch (Exception e) {
                // save off the exception and throw it in EndCoreProcessRequest
                exception = e;
                asyncResult = new CompletedAsyncResult(asyncState, true);
                this.asyncCallback = callback;
                this.DoCallback(asyncResult);
            }
            this.asyncBeginComplete.Set();
            TraceFlush();
            return asyncResult;
        }

        private void OneWayCallback(IAsyncResult asyncResult) {
            EndInvoke(asyncResult);
        }

        protected void EndCoreProcessRequest(IAsyncResult asyncResult) {
            if (asyncResult == null) return;

            if (protocol.IsOneWay)
                protocol.WriteOneWayResponse();
            else
                EndInvoke(asyncResult);
        }

        private void EndInvoke(IAsyncResult asyncResult) {
            try {
                if (exception != null) 
                    throw (exception);
                object[] returnValues = protocol.MethodInfo.EndInvoke(protocol.Target, asyncResult);
                WriteReturns(returnValues);
            }
            catch (Exception e) {
                WriteException(e);
            }
            finally {
                protocol.DisposeServerInstance();
            }
            TraceFlush();
        }

        void WriteReturns(object[] returnValues) {
            if (protocol.IsOneWay) return;

            // By default ASP.NET will fully buffer the response. If BufferResponse=false
            // then we still want to do partial buffering since each write is a named
            // pipe call over to inetinfo.
            bool fullyBuffered = protocol.MethodAttribute.BufferResponse;
            Stream outputStream = protocol.Response.OutputStream;
            if (!fullyBuffered) {                        
                outputStream = new BufferedResponseStream(outputStream, 16*1024);                
                //#if DEBUG
                ((BufferedResponseStream)outputStream).FlushEnabled = false;                
                //#endif
            }
            protocol.WriteReturns(returnValues, outputStream);
            // This will flush the buffered stream and the underlying stream. Its important
            // that it flushes the Response.OutputStream because we always want BufferResponse=false
            // to mean we are writing back a chunked response. This gives a consistent
            // behavior to the client, independent of the size of the partial buffering.
            if (!fullyBuffered) {
                //#if DEBUG
                ((BufferedResponseStream)outputStream).FlushEnabled = true;
                //#endif
                outputStream.Flush();
            }
        }
    }

    internal class SyncSessionlessHandler : WebServiceHandler, IHttpHandler {

        internal SyncSessionlessHandler(ServerProtocol protocol) : base(protocol) { }

        public bool IsReusable {
            get { return false; }
        }

        public void ProcessRequest(HttpContext context) {
            CoreProcessRequest();
        }

    }

    internal class SyncSessionHandler : SyncSessionlessHandler, IRequiresSessionState {
        internal SyncSessionHandler(ServerProtocol protocol) : base(protocol) { }
    }

    internal class AsyncSessionlessHandler : SyncSessionlessHandler, IHttpAsyncHandler {

        internal AsyncSessionlessHandler(ServerProtocol protocol) : base(protocol) { }

        public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback callback, object asyncState) {
            return BeginCoreProcessRequest(callback, asyncState);
        }

        public void EndProcessRequest(IAsyncResult asyncResult) {
            EndCoreProcessRequest(asyncResult);
        }
    }

    internal class AsyncSessionHandler : AsyncSessionlessHandler, IRequiresSessionState {
        internal AsyncSessionHandler(ServerProtocol protocol) : base(protocol) { }
    }
    
    class CompletedAsyncResult : IAsyncResult {
        object asyncState;
        bool completedSynchronously;

        internal CompletedAsyncResult(object asyncState, bool completedSynchronously) {
            this.asyncState = asyncState;
            this.completedSynchronously = completedSynchronously;
        }

        public object AsyncState { get { return asyncState; } }
        public bool CompletedSynchronously { get { return completedSynchronously; } } 
        public bool IsCompleted { get { return true; } }
        public WaitHandle AsyncWaitHandle { get { return null; } } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\protocols\xmlreturnreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlReturnReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Protocols {
    using System.IO;
    using System;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Web.Services;
    using System.Net;
    using System.Text;

    internal class XmlReturn {
        internal static object[] GetInitializers(LogicalMethodInfo[] methodInfos) {
            if (methodInfos.Length == 0) return new object[0];
            WebServiceAttribute serviceAttribute = WebServiceReflector.GetAttribute(methodInfos);
            bool serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(WebServiceReflector.GetMostDerivedType(methodInfos));
            XmlReflectionImporter importer = SoapReflector.CreateXmlImporter(serviceAttribute.Namespace, serviceDefaultIsEncoded);
            WebMethodReflector.IncludeTypes(methodInfos, importer);
            ArrayList mappings = new ArrayList();
            for (int i = 0; i < methodInfos.Length; i++) {
                LogicalMethodInfo methodInfo = methodInfos[i];
                Type type = methodInfo.ReturnType;
                if (IsSupported(type)) {
                    XmlAttributes a = new XmlAttributes(methodInfo.ReturnTypeCustomAttributeProvider);
                    XmlTypeMapping mapping = importer.ImportTypeMapping(type, a.XmlRoot);
                    mappings.Add(mapping);
                }
            }
            XmlSerializer[] serializers = XmlSerializer.FromMappings((XmlMapping[])mappings.ToArray(typeof(XmlMapping)));
            object[] initializers = new object[methodInfos.Length];
            int count = 0;
            for (int i = 0; i < initializers.Length; i++) {
                if (IsSupported(methodInfos[i].ReturnType)) {
                    initializers[i] = serializers[count++];
                }
            }
            return initializers;
        }

        static bool IsSupported(Type returnType) {
            return returnType != typeof(void);
        }
        
        internal static object GetInitializer(LogicalMethodInfo methodInfo) {
            return GetInitializers(new LogicalMethodInfo[] { methodInfo });
        }
    }

    /// <include file='doc\XmlReturnReader.uex' path='docs/doc[@for="XmlReturnReader"]/*' />
    public class XmlReturnReader : MimeReturnReader {
        XmlSerializer xmlSerializer;
        
        /// <include file='doc\XmlReturnReader.uex' path='docs/doc[@for="XmlReturnReader.Initialize"]/*' />
        public override void Initialize(object o) {
            xmlSerializer = (XmlSerializer)o;
        }

        /// <include file='doc\XmlReturnReader.uex' path='docs/doc[@for="XmlReturnReader.GetInitializers"]/*' />
        public override object[] GetInitializers(LogicalMethodInfo[] methodInfos) {
            return XmlReturn.GetInitializers(methodInfos);
        }
        
        /// <include file='doc\XmlReturnReader.uex' path='docs/doc[@for="XmlReturnReader.GetInitializer"]/*' />
        public override object GetInitializer(LogicalMethodInfo methodInfo) {
            return XmlReturn.GetInitializer(methodInfo);
        }

        /// <include file='doc\XmlReturnReader.uex' path='docs/doc[@for="XmlReturnReader.Read"]/*' />
        public override object Read(WebResponse response, Stream responseStream) {
            try {
                if (response == null) throw new ArgumentNullException("response");
                if (!ContentType.MatchesBase(response.ContentType, ContentType.TextXml)) {
                    throw new InvalidOperationException(Res.GetString(Res.WebResultNotXml));
                }
                Encoding e = RequestResponseUtils.GetEncoding(response.ContentType);
                return xmlSerializer.Deserialize(new StreamReader(responseStream, e, true));
            }
            finally {
                response.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\servicesunmanaged\performancecounterlib\stdafx.h ===
//------------------------------------------------------------------------------
// <copyright file="StdAfx.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StdAfx.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_)
#define AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\servicesunmanaged\performancecounterlib\perfcount.cpp ===
/*
 * Copyright (c) 2001, Microsoft Corporation. All Rights Reserved.
 * Information Contained Herein is Proprietary and Confidential.
 */

#include "stdafx.h"
#include <initguid.h>
#include "oaidl.h"
#include "ocidl.h"

#include <windows.h>
#include <string.h>
#include <winperf.h>
#include <mscoree.h>
#include <fxver.h>
#include "wfcperfcount.h"


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4
#define PAGE_SIZE 0x1000
#define MIN_STACK_SPACE_REQUIRED 0x10000
#define FULLY_QUALIFIED_SYSTEM_NAME_STR_L L"System,version=" VER_ASSEMBLYVERSION_STR_L L", Culture=neutral, PublicKeyToken=" ECMA_PUBLICKEY_STR_L

#if DEBUG                                                                                                                                                                          
    #define DEBUGOUTPUT(s) OutputDebugString(s)
#else
    #define DEBUGOUTPUT(s) ;
#endif
  
#define ON_ERROR_EXIT() \
        do { if (hr) { if (1) goto Cleanup; } } while (0)

#pragma warning(disable:4127) // conditional expression is constant

DWORD GetQueryType (IN LPWSTR);
HRESULT CreatePerformanceCounterManager();
HRESULT EnsureCoInitialized(BOOL *pNeedCoUninit, DWORD model);
size_t GetRemainingStackSpace();

DWORD   dwOpenCount = 0;        // count of "Open" threads
ICollectData * pICD;

/////////////////////////////////////////////////////////////////////////////////////

/**
 * Open routine
 * Does nothing except counting threads that entered it
 */
DWORD APIENTRY OpenPerformanceData(LPWSTR lpDeviceNames) 
{
    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread 
    //  at a time so synchronization (i.e. reentrancy) should not be 
    //  a problem
    DEBUGOUTPUT("OpenPerformanceData called.\r\n");
    dwOpenCount++;
    return ERROR_SUCCESS;
}


/**
 * The CollectData function delegates the calls to the Managed interface.
 */
DWORD APIENTRY 
CollectPerformanceData(
       IN LPWSTR lpValueName,
       IN OUT LPVOID *lppData, 
       IN OUT LPDWORD lpcbTotalBytes, 
       IN OUT LPDWORD lpNumObjectTypes) 
{
    DWORD dwQueryType;
    size_t remainingStackSpace;
    INT_PTR res;
    HRESULT hr;
    LPBYTE startPtr = (LPBYTE)*lppData;
    BOOL bNeedCoUninitialize = false;

    DEBUGOUTPUT("GlobalCollect called.\r\n");

     // see if this is a foreign (i.e. non-NT) computer data request 
    // this routine does not service requests for data from Non-NT computers
    dwQueryType = GetQueryType (lpValueName); 
    if (dwQueryType == QUERY_FOREIGN) goto Cleanup;
    
    // In some NT4 services, the callstack is very small.
    // Pick a size that's reasonable to assume won't work well if it's any less.
    remainingStackSpace = GetRemainingStackSpace();
    if (remainingStackSpace < MIN_STACK_SPACE_REQUIRED) goto Cleanup;

    hr = EnsureCoInitialized(&bNeedCoUninitialize, COINIT_APARTMENTTHREADED);
    ON_ERROR_EXIT();
    
    hr = CreatePerformanceCounterManager();    
    ON_ERROR_EXIT();

    hr = pICD->CollectData(0, (INT_PTR)lpValueName, (INT_PTR)*lppData, *lpcbTotalBytes, & res);
    ON_ERROR_EXIT();    

    if (bNeedCoUninitialize) {   
        CoUninitialize();                    
        bNeedCoUninitialize = false;
    }
        
    if (res == -2) { // more data necessary
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    } else if (res == -1) {
        goto Cleanup;
    }

    *lpcbTotalBytes = PtrToUint((LPBYTE)res - startPtr);
    *lpNumObjectTypes = 1;
    *lppData = (VOID*) res;

    DEBUGOUTPUT("GlobalCollect Succeeded.\r\n");
    return ERROR_SUCCESS; 

Cleanup:
    if (bNeedCoUninitialize) 
        CoUninitialize();    

    *lpcbTotalBytes = (DWORD) 0;
    *lpNumObjectTypes = (DWORD) 0;

    DEBUGOUTPUT("GlobalCollect Failed.\r\n");
    return ERROR_SUCCESS; //it should be this way
}

DWORD APIENTRY ClosePerformanceData()
{
     DEBUGOUTPUT("ClosePerformanceData called.\r\n");
    if (!(--dwOpenCount)) { 
        // when this is the last thread...
        // Init stuff for accesing PerfCounterManager COM Object
        if (pICD == NULL)
            return ERROR_SUCCESS;
        
        pICD->CloseData();
        pICD->Release();
        pICD = NULL;        
    }

    return ERROR_SUCCESS;
}

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";
 
/* 
    Returns the type of query described in the lpValue string so that
    the appropriate processing method may be used
  
    Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

    Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS
 */
DWORD GetQueryType (IN LPWSTR lpValue)
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } 
    else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}

HRESULT 
CreatePerformanceCounterManager() {   
    HRESULT hr = S_OK;    
        
    if (pICD == NULL) {                                        
        hr = ClrCreateManagedInstance(
                L"System.Diagnostics.PerformanceCounterManager," FULLY_QUALIFIED_SYSTEM_NAME_STR_L, 
                IID_ICollectData, 
                (LPVOID*)& pICD);                
    }

    return hr;
}

size_t GetRemainingStackSpace() {            
    MEMORY_BASIC_INFORMATION memInfo;
    size_t esp = (size_t)&memInfo;
    size_t dwRes = VirtualQuery((const void *)esp, &memInfo, sizeof(memInfo));
    if (dwRes != sizeof(memInfo))
        return (0);
	
    //A couple of pages are used by Exception handling code.
    return (esp - ((size_t)(memInfo.AllocationBase) + (2 * PAGE_SIZE)));
}

HRESULT
EnsureCoInitialized(BOOL *pNeedCoUninit, DWORD model) {        
    HRESULT hr = CoInitializeEx(NULL, model);
    if (hr == S_OK) {        
        // first time
        *pNeedCoUninit = TRUE;
    }
    else {
        *pNeedCoUninit = FALSE;
        if (hr == S_FALSE) {            
            // already coinited  same model
            CoUninitialize();
            hr = S_OK;
        }
        else if (hr == RPC_E_CHANGED_MODE) {            
            // already coinited different model
            hr = S_OK;
        }        
    }    
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\servicesunmanaged\performancecountershim\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
!if "$(LINKONLY)" == "1"
copyToSystem: 
	$(ECHO_PROCESSING_CMD) copyToSystem
	copy /y %URTTARGET%\netfxperf.dll %SystemRoot%\System32\netfxperf.dll
!else
copyToSystem:  
    echo Nothing to do this phase.
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\servicesunmanaged\performancecountershim\stdafx.h ===
//------------------------------------------------------------------------------
// <copyright file="StdAfx.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StdAfx.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_)
#define AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\sys\resource.h ===
//------------------------------------------------------------------------------
// <copyright file="resource.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   resource.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define ASAX_NAME                       1
#define ASCX_NAME                       2
#define ASMX_NAME                       3
#define ASPX_NAME                       4
#define CONFIG_NAME                     5
#define DISCO_NAME                      6
#define RESX_NAME                       7
#define SDL_NAME                        8
#define WSDL_NAME                       9
#define XSD_NAME                        10
#define XSLT_NAME                       11

#define ASAX_ICON                       101
#define ASCX_ICON                       102
#define ASMX_ICON                       103
#define ASPX_ICON                       104
#define CONFIG_ICON                     105
#define DISCO_ICON                      106
#define RESX_ICON                       107
#define SDL_ICON                        108
#define WSDL_ICON                       109
#define XSD_ICON                        110
#define XSLT_ICON                       111
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\servicesunmanaged\performancecountershim\netfxprf.cpp ===
//------------------------------------------------------------------------------
// <copyright file="NetFxPrf.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   NetFxPrf.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <mscoree.h>

#define PERFCOUNTERDLL_NAME_L L"perfcounter.dll"
#define PERF_ENTRY_POINTS(x) char* x [] = {"OpenPerformanceData", "ClosePerformanceData", "CollectPerformanceData"};
#define PERF_ENTRY_POINT_COUNT 3
#define ARRAYLENGTH(s) (sizeof(s) / sizeof(s[0]))

typedef DWORD WINAPI OpenPerformanceDataMethod(LPWSTR);
typedef DWORD WINAPI ClosePerformanceDataMethod();
typedef DWORD WINAPI CollectPerformanceDataMethod(LPWSTR, LPVOID *, LPDWORD, LPDWORD);

OpenPerformanceDataMethod * extensibleOpenMethod;
ClosePerformanceDataMethod * extensibleCloseMethod;
CollectPerformanceDataMethod * extensibleCollectMethod;

BOOL initExtensibleStatus;  // non-zero means that it has run init once
DWORD initExtensibleError;

DWORD Initialize(LPWSTR counterVersion)
{

    if (initExtensibleStatus || initExtensibleError) {
        return initExtensibleError;
    }

    HINSTANCE hDll;
    FARPROC pProcAddr[PERF_ENTRY_POINT_COUNT];
    PERF_ENTRY_POINTS(perfEntryPoint);
    initExtensibleError = 0;
    int i;    
    WCHAR szCounterVersion[1024];    
    DWORD dwLength;
    DWORD result = GetCORSystemDirectory(szCounterVersion, ARRAYLENGTH(szCounterVersion), &dwLength);
    if (result) {
        initExtensibleError = result;
        return result;
    }
    else {
        if (dwLength + lstrlenW(PERFCOUNTERDLL_NAME_L) >= ARRAYLENGTH(szCounterVersion)) {
            initExtensibleError = ERROR_INVALID_PARAMETER;
            return initExtensibleError;
        }

        lstrcatW(szCounterVersion, PERFCOUNTERDLL_NAME_L);
        // perfcounter.dll depends on msvcr70.dll, which is in the same directory
        // as perfcounter.dll, so we need to load it with LOAD_WITH_ALTERED_SEARCH_PATH
        // so the system will search in perfcounter.dll's directory, instead of the 
        // netfxperf.dll directory.
        hDll = LoadLibraryEx(szCounterVersion, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        if (hDll == NULL)             
            goto Error;            
    }
       
    for (i = 0; i < PERF_ENTRY_POINT_COUNT; i++) {
        pProcAddr[i] = GetProcAddress(hDll, perfEntryPoint[i]);

        // If the proc address was not found, return error
        if (pProcAddr == NULL) {
            // ERROR
            goto Error;
        }
    }
       
    extensibleOpenMethod = (OpenPerformanceDataMethod *) pProcAddr[0];
    extensibleCloseMethod = (ClosePerformanceDataMethod *) pProcAddr[1];
    extensibleCollectMethod = (CollectPerformanceDataMethod *) pProcAddr[2];            
    initExtensibleStatus = TRUE;
        
    return 0;

Error:
    DWORD currentError = GetLastError();    
    initExtensibleError = currentError;        
    return currentError;
}

DWORD WINAPI OpenPerformanceData(LPWSTR counterVersion)
{
    DWORD result; 
    
    // If not initialized, initialize
    result = Initialize(counterVersion);
    if (result) {
        return result;
    }

    // If it got here, then everything is ok.
    return extensibleOpenMethod(counterVersion);
}

DWORD WINAPI ClosePerformanceData()
{
    if (extensibleCloseMethod != NULL)
        return extensibleCloseMethod();

    return ERROR_SUCCESS;    
}

DWORD WINAPI CollectPerformanceData(
    LPWSTR Values,
    LPVOID *lppData,
    LPDWORD lpcbTotalBytes,
    LPDWORD lpNumObjectTypes)
{
    if (extensibleCollectMethod != NULL)
        return extensibleCollectMethod(Values, lppData, lpcbTotalBytes, lpNumObjectTypes);

    // If error, set to zero
    *lpNumObjectTypes = 0;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\sys\makefile.inc ===
!if 0

#
# Define COMNET_DISABLEIPV6 here to disable IPv6 support in the net classes.
#
#COOLC_DEFINES = $(COOLC_DEFINES) /D:COMNET_DISABLEIPV6
#COOLC_DEFINES = $(COOLC_DEFINES) /D:TRAVE


!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\safenativemethods.cs ===
//------------------------------------------------------------------------------
/// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool MessageBeep(int type);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsWindowVisible(IntPtr hWnd);
    
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetCurrentThreadId();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\switches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Switches.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace Microsoft.VisualStudio {
    
    using System.ComponentModel;

    using System.Diagnostics;
    using Microsoft.Win32;

    /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches"]/*' />
    /// <devdoc>
    ///      Contains predefined switches for enabling/disabling trace output or code instrumentation
    ///      in the VisualStudio designer framework.
    /// </devdoc>
    public class Switches {
      //public static TraceSwitch SampleTraceSwitch = new TraceSwitch("DisplayName", "Description");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.AttributeEditing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch AttributeEditing = new TraceSwitch("AttributeEditing", "Enable tracing attribute editing in the properties window.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.SProcGen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch SProcGen = new TraceSwitch("Data.SProcGen", "trace stored procedure / dynamic sql generation");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdAdapter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DsdAdapter = new TraceSwitch("DsdAdapter", "Adapter: Trace Adapter calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdComponent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DsdComponent = new TraceSwitch("DsdComponent", "DataDesigner: Trace DataDesigner calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdDataSetAdapter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DsdDataSetAdapter = new TraceSwitch("DsdDataSetAdapter", "trace code in DataSetAdapter");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdExec"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DsdExec = new TraceSwitch("DsdExec", "DataDesigner: Trace DataDesigner Exec calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DsdTable = new TraceSwitch("DsdTable", "DSD:DsdTable: Trace DesignerTable calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdValidation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DsdValidation = new TraceSwitch("DsdValidation", "Data Designer: Trace name/mapping/key validation calls.");

        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DeploymentDesign"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DeploymentDesign = new TraceSwitch("DeploymentDesign", "Custom Action Editor debug spew");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DeploymentDesignIOCT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DeploymentDesignIOCT = new TraceSwitch("DeploymentDesignIOCT", "Custom Action Editor IOleCommandTarget-related stuff");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.CSCSharpParser"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch CSCSharpParser = new TraceSwitch("CSCSharpParser", "Debug CodeSense.CSharp.(CSharp Parsering)");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.CSCSharpTokenizer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch CSCSharpTokenizer = new TraceSwitch("CSCSharpTokenizer", "Debug CodeSense.CSharp.CSharpCodeTokenizer");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.CSBasicParser"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch CSBasicParser = new TraceSwitch("CSBasicParser", "Debug CodeSense.VisualBasic.BasicParser");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.CSBasicTokenizer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch CSBasicTokenizer = new TraceSwitch("CSBasicTokenizer", "Debug CodeSense.VisualBasic.BasicTokenizer");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.CompCast"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch CompCast = new TraceSwitch("CompCast", "DesignerHost: Issue with casting to IComponent");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.CompChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch CompChange = new TraceSwitch("CompChange", "DesignerHost: Track component change events");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DEBUGCONSOLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DEBUGCONSOLE = new TraceSwitch("DEBUGCONSOLE", "DocumentManager: Create a debug output console.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.TYPELOADER"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch TYPELOADER = new TraceSwitch("TYPELOADER", "TypeLoader: Trace type loading.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.LICMANAGER"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch LICMANAGER = new TraceSwitch("LICMANAGER", "LicenseManager: Trace license creation.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.ALWAYSGENLIC"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch ALWAYSGENLIC = new BooleanSwitch("ALWAYSGENLIC", "LicenseManager: Generate licenses for all components, not just licensed components.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.MENUSERVICE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch MENUSERVICE = new TraceSwitch("MENUSERVICE", "MenuCommandService: Track menu command routing");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.NamespaceRefs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch NamespaceRefs = new TraceSwitch("NamespaceRefs", "Debug namespace references -> ReferenceService, Editor, etc.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.SETSELECT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch SETSELECT = new TraceSwitch("SETSELECT", "SelectionService: Track selection sets");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.SELECTIONRESIZE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch SELECTIONRESIZE = new TraceSwitch("SELECTIONRESIZE", "SelectionService: Track resize of elements through the selection service");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.SSCONTAINER"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch SSCONTAINER = new TraceSwitch("SSCONTAINER", "SelectionService: Debug container selection");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.SELDRAW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch SELDRAW = new TraceSwitch("SELDRAW", "SelectionUIService: Track selection draws");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.SELUISVC"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch SELUISVC = new TraceSwitch("SELUISVC", "SelectionUIService: Track selection UI changes");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.VERBSERVICE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch VERBSERVICE = new TraceSwitch("VERBSERVICE", "VerbCommandService: Track verb command processing");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.TRACEEDIT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch TRACEEDIT = new TraceSwitch("TRACEEDIT", "EditorFactory: Trace editor factory requests.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DESIGNERSERVICE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DESIGNERSERVICE = new TraceSwitch("DESIGNERSERVICE", "Designer Service : Trace service calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.WFCSCRIPT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch WFCSCRIPT = new TraceSwitch("WFCSCRIPT", ".Net Framework Classes Script Engine");

        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DEBUGPBRS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DEBUGPBRS = new TraceSwitch("DEBUGPBRS", "Debug the PropertyBrowser");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.ServerExplorer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch ServerExplorer = new TraceSwitch("ServerExplorer", "Server explorer output");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.TRACESERVICE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch TRACESERVICE = new TraceSwitch("TRACESERVICE", "ServiceProvider: Trace service provider requests.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.ADDTOOLBOXCOMPONENTS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch ADDTOOLBOXCOMPONENTS = new TraceSwitch("ADDTOOLBOXCOMPONENTS", "Trace add/remove components dialog operations.");

      //public static BooleanSwitch SampleBooleanSwitch = new BooleanSwitch("DisplayName", "Description");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.CodeGen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch CodeGen  = new BooleanSwitch("Data.CodeGen", "trace strongly typed data class code generation");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DBFactory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DBFactory = new BooleanSwitch("DBFactory", "DBFactory: Trace DBFactory calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.AdapterWizard"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch AdapterWizard = new BooleanSwitch("AdapterWizard", "DBWizard: Trace DBWizard calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DGEditColumnEditingVS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DGEditColumnEditingVS = new BooleanSwitch("DGEditColumnEditingVS", "DGEditColumnEditing: Trace DataGridDropdownColumn calls");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdSPM"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdSPM = new BooleanSwitch("DsdSPM", "DSD:StoredProcedure Manager: Trace DataSetDesigner Stored Procedure Manager calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.AdapterManager"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch AdapterManager = new BooleanSwitch("AdapterManager", "AdapterManager: Trace AdapterManager calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DSRef"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DSRef = new BooleanSwitch("DSRef", "Trace DSRef calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DumpDSRef"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DumpDSRef = new BooleanSwitch("DumpDSRef", "Dump DSRef object as it's created...");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdCodeStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdCodeStream = new BooleanSwitch("DsdCodeStream", "DataCodeStream: Trace DsdCodeStream calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdQueryStatus"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdQueryStatus = new BooleanSwitch("DsdQueryStatus", "DataDesigner: Trace DataDesigner QueryStatus calls.");

        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DocWindowBug"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static TraceSwitch DocWindowBug = new TraceSwitch("DocWindowBug", "DocumentWindow resize problem");

        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdTask"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdTask = new BooleanSwitch("DsdTask", "DataDesigner: Trace DataDesigner TaskSource related calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdDataTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdDataTypes = new BooleanSwitch("DsdDataTypes", "DataTypes: Trace DataSetDesignerDataType calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdRelation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdRelation = new BooleanSwitch("DsdRelation", "DesignerRelation: Trace DesignerRelation calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdTableColumnMappings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdTableColumnMappings = new BooleanSwitch("DsdTableColumnMappings", "DSD:DsdTableColumnMappings: Trace column mappings on each change");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.DsdPreview"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch DsdPreview = new BooleanSwitch("DsdPreview", "DataDesigner: Trace DataDesigner Preview Data calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.RelationEditor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch RelationEditor = new BooleanSwitch("RelationEditor", "DSD:RelationEditor: Trace RelationsEditor calls.");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.NEVERPASTE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch NEVERPASTE = new BooleanSwitch("NEVERPASTE", "Do not check for clipboard paste operation");
        /// <include file='doc\Switches.uex' path='docs/doc[@for="Switches.ENABLESHELLEXTENDERS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch ENABLESHELLEXTENDERS = new BooleanSwitch("ENABLESHELLEXTENDERS", "Enable shell extensions in the properties window.");
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
/// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern UCOMITypeLib LoadRegTypeLib(ref Guid clsid, int majorVersion, int minorVersion, int lcid);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool PostMessage(IntPtr hwnd, int msg, IntPtr wparam, IntPtr lparam);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\advancedpropertyconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedPropertyConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AdvancedPropertyConverter.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.Serialization.Formatters;    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    using System.Globalization;

    /// <include file='doc\AdvancedPropertyConverter.uex' path='docs/doc[@for="AdvancedPropertyConverter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class AdvancedPropertyConverter : TypeConverter {

        /// <include file='doc\AdvancedPropertyConverter.uex' path='docs/doc[@for="AdvancedPropertyConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string))
                return "";
            else
                return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
!if "$(LINKONLY)" != "1"
compileWithResGen: 
    $(ECHO_PROCESSING_CMD) Compile_With_ResGen
    if exist %URTSDKTARGET%\bin\resgen.exe %URTSDKTARGET%\bin\resgen.exe /compile Resources\Microsoft\VisualStudio\Configuration\AdvancedPropertyDialog.resx,$(O)\AdvancedPropertyDialog.resources Resources\Microsoft\VisualStudio\WinForms\InheritancePicker.resx,$(O)\InheritancePicker.resources Resources\Microsoft\VisualStudio\Configuration\SingleBindingDialog.resx,$(O)\SingleBindingDialog.resources
    if not exist %URTSDKTARGET%\bin\resgen.exe copy Resources\Microsoft\VisualStudio\Configuration\AdvancedPropertyDialog.resources $(O)
    if not exist %URTSDKTARGET%\bin\resgen.exe copy Resources\Microsoft\VisualStudio\WinForms\InheritancePicker.resources $(O)
    if not exist %URTSDKTARGET%\bin\resgen.exe copy Resources\Microsoft\VisualStudio\Configuration\SingleBindingDialog.resources $(O)
!else
compileWithResGen: 
    echo Nothing to do this phase.
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio {

    using Microsoft.VisualStudio.Designer;
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    
    internal class NativeMethods {
    
        public const int
        CLSCTX_INPROC_SERVER  = 0x1,
        CB_SETDROPPEDWIDTH = 0x0160,
        CDDS_PREPAINT = 0x00000001,
        CDDS_POSTPAINT = 0x00000002,
        CDDS_ITEM = 0x00010000,
        CDDS_ITEMPREPAINT = (0x00010000|0x00000001),
        CDIS_SELECTED = 0x0001,
        CDIS_FOCUS = 0x0010,
        CDIS_HOT = 0x0040,
        CDRF_DODEFAULT = 0x00000000,
        CDRF_SKIPDEFAULT = 0x00000004,
        CDRF_NOTIFYPOSTPAINT = 0x00000010,
        CDRF_NOTIFYITEMDRAW = 0x00000020;
    
        public const int 
        DV_E_FORMATETC = unchecked((int)0x80040064),
        DV_E_TYMED = unchecked((int)0x80040069),
        DVASPECT_CONTENT   = 1,
        DATADIR_GET = 1,
        DATE_SHORTDATE = 0x00000001,
        DT_LEFT = 0x00000000,
        DT_VCENTER = 0x00000004,
        DT_NOPREFIX = 0x00000800,
        DT_END_ELLIPSIS = 0x00008000;
        
        public const int
        ETO_OPAQUE = 0x0002,
        ETO_CLIPPED = 0x0004,
        E_UNEXPECTED = unchecked((int)0x8000FFFF),
        E_NOTIMPL = unchecked((int)0x80004001),
        E_INVALIDARG = unchecked((int)0x80070057),
        E_NOINTERFACE = unchecked((int)0x80004002),
        E_POINTER = unchecked((int)0x80004003),
        E_FAIL = unchecked((int)0x80004005),
        E_ABORT = unchecked((int)0x80004004),
        UNDO_E_CLIENTABORT = unchecked((int)0x80044001);
        
        public const int
        FILE_ATTRIBUTE_READONLY = 0x00000001;
        
        public const int
        GA_ROOT         = 2,
        GA_ROOTOWNER    = 3,
        GWL_HWNDPARENT = (-8),
        GWL_STYLE = (-16),
        GWL_EXSTYLE = (-20);

        //Extended List view setting..
        //If a partially hidden label in any list view mode lacks tooltip text, 
        //the list view control will unfold the label. If this style is not set, 
        //the list view control will unfold partly hidden labels only for the large icon mode... 
        public const int
        LVS_EX_LABELTIP = 0x00004000,
        LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000+54);
        
        public const int
        HTCAPTION = 2,
        HTMENU = 5;
        
        public const int
        IDC_WAIT = 32514,
        ILD_TRANSPARENT = 0x0001;

        public static int MAKELANGID(int primary, int sub) {
            return ((((ushort)(sub)) << 10) | (ushort)(primary));
        }
        
        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.Lang.MAKELCID"]/*' />
        /// <devdoc>
        ///     Creates an LCID from a LangId
        /// </devdoc>
        public static int MAKELCID(int lgid) {
            return MAKELCID(lgid, SORT_DEFAULT);
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.Lang.MAKELCID1"]/*' />
        /// <devdoc>
        ///     Creates an LCID from a LangId
        /// </devdoc>
        public static int MAKELCID(int lgid, int sort) {
            return ((0xFFFF & lgid) | (((0x000f) & sort) << 16));
        }

        public const int LANG_NEUTRAL = 0x00;
        public static readonly int LANG_SYSTEM_DEFAULT =MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);
        public static readonly int LOCALE_SYSTEM_DEFAULT=  MAKELCID(LANG_SYSTEM_DEFAULT);
        
        public const int
        NM_CUSTOMDRAW = ((0-0)-12);
        
        public const int
        OLECMDERR_E_NOTSUPPORTED = unchecked((int)0x80040100),
        OLECMDERR_E_UNKNOWNGROUP  = unchecked((int)0x80040104),
        OLEIVERB_HIDE = -3,
        OLEIVERB_UIACTIVATE = -4;
        
        public const int
        PATCOPY = 0x00F00021,
        PM_NOREMOVE = 0x0000;
        
        public const int
        SORT_DEFAULT =0x0,
        SUBLANG_SYS_DEFAULT = 0x02,
        SWP_NOSIZE = 0x0001,
        SWP_NOMOVE = 0x0002,
        SWP_NOZORDER = 0x0004,
        SWP_NOACTIVATE = 0x0010,
        SWP_FRAMECHANGED = 0x0020,
        SW_SHOWNORMAL = 1,
        SW_SHOW = 5;
        
        public const int
        TVM_SETITEMHEIGHT = (0x1100+27),
        TVM_GETITEMHEIGHT = (0x1100+28),
        TRANSPARENT = 1;
        
        public const int
        WS_POPUP = unchecked((int)0x80000000),
        WS_CHILD = 0x40000000,
        WS_MINIMIZE = 0x20000000,
        WS_VISIBLE = 0x10000000,
        WS_CLIPSIBLINGS = 0x04000000,
        WS_MAXIMIZE = 0x01000000,
        WS_DLGFRAME = 0x00400000,
        WS_SYSMENU = 0x00080000,
        WS_THICKFRAME = 0x00040000,
        WS_MINIMIZEBOX = 0x00020000,
        WS_MAXIMIZEBOX = 0x00010000,
        WS_EX_DLGMODALFRAME = 0x00000001,
        WS_EX_NOPARENTNOTIFY = 0x00000004,
        WS_EX_TOPMOST = 0x00000008,
        WS_EX_MDICHILD = 0x00000040,
        WS_EX_TOOLWINDOW = 0x00000080,
        WS_EX_CONTEXTHELP = 0x00000400,
        WS_EX_STATICEDGE = 0x00020000,
        WS_EX_APPWINDOW = 0x00040000,
        WM_USER = 0x0400,
        WM_KEYDOWN = 0x100,
        WM_LBUTTONDOWN = 0x0201,
        WM_RBUTTONDOWN = 0x0204,
        WM_NCACTIVATE = 0x0086,
        WM_NCCALCSIZE = 0x0083,
        WM_NCLBUTTONDOWN = 0x00A1,
        WM_NCRBUTTONDOWN = 0x00A4,
        WM_NCHITTEST = 0x0084,
        WM_ERASEBKGND = 0x0014,
        WM_TIMER = 0x0113,
        WM_REFLECT          = WM_USER + 0x1C00,
        WM_CONTEXTMENU = 0x007B,
        WM_SETFOCUS = 0x0007,
        WM_SYSCOLORCHANGE = 0x0015,
        WM_CUT = 0x0300,
        WM_COPY = 0x0301,
        WM_PASTE = 0x0302,
        WM_UNDO = 0x0304,
        WM_NOTIFY = 0x004E,
        WM_CHAR = 0x0102,
        WM_CLEAR = 0x0303,
        WM_SETREDRAW = 0x000B,
        BM_SETIMAGE = 0x00F7,
        IMAGE_ICON = 1,
        BS_ICON = 0x00000040;
        
        
        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));

        public const int S_OK =      0x00000000;
        public const int S_FALSE =   0x00000001;

        public static bool Succeeded(int hr) {
            return(hr >= 0);
        }

        public static bool Failed(int hr) {
            return(hr < 0);
        }
        
        public static Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");                    
        
        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.TimerProc"]/*' />
        /// <devdoc>
        /// </devdoc>
        public delegate void TimerProc(int hWnd, int msg, int wParam, int lParam);

        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern bool FileTimeToSystemTime(ref long fileTime, [In, Out] SYSTEMTIME systemTime);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern int GetDateFormat(int Locale, int dwFlags, SYSTEMTIME lpDate, String lpFormat, StringBuilder lpDateStr, int cchDate);
        
        #if PERFEVENTS
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern IntPtr CreateEvent(IntPtr securityAttributes, bool manualReset, bool initialState, string name);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern bool SetEvent(IntPtr handle);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern bool CloseHandle(IntPtr handle);
        #endif
        
        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        public static extern void CreateStreamOnHGlobal(IntPtr hGlobal, bool fDeleteOnRelease, [Out] out NativeMethods.IStream pStream );

        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        public static extern void GetHGlobalFromStream(NativeMethods.IStream pStream, [Out]out IntPtr pHGlobal);

        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr GetWindowLong(IntPtr hWnd, int nIndex);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SetWindowLong(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetAncestor(IntPtr hwnd, int gaFlags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter,
                                               int x, int y, int cx, int cy, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public extern static bool IsChild(IntPtr parent, IntPtr child);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetCursor(IntPtr hcursor);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr LoadCursor(IntPtr hInst, int iconId);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool GetWindowRect(IntPtr hWnd, [In, Out] ref RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetFocus();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int MapWindowPoints(IntPtr hWndFrom, IntPtr hWndTo, [In, Out] ref RECT rect, int cPoints);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int MapWindowPoints(IntPtr hWndFrom, IntPtr hWndTo, [In, Out] POINT pt, int cPoints);
        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, int lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, [In, Out, MarshalAs(UnmanagedType.AsAny)] Object lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, [In, Out] ref RECT lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, ref short wParam, ref short lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, [In, Out, MarshalAs(UnmanagedType.AsAny)] object wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, [In, Out, MarshalAs(UnmanagedType.Bool)] bool wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, [In, Out, MarshalAs(UnmanagedType.AsAny)] object wParam, [In, Out, MarshalAs(UnmanagedType.AsAny)] Object lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, [In, Out, MarshalAs(UnmanagedType.AsAny)] object wParam, [In, Out] ref RECT lParam);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetParent(IntPtr hWnd, IntPtr hWndParent);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool InvalidateRect(IntPtr hWnd, ref RECT rect, bool erase);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool InvalidateRect(IntPtr hWnd, COMRECT rect, bool erase);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateBitmap", CharSet=CharSet.Auto)]
        private static extern IntPtr /*HBITMAP*/ IntCreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, int[] lpvBits);
        public static IntPtr /*HBITMAP*/ CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, int[] lpvBits) {
            return NativeMethods.HandleCollector.Add(IntCreateBitmap(nWidth, nHeight, nPlanes, nBitsPerPixel, lpvBits), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateBitmap", CharSet=CharSet.Auto)]
        private static extern IntPtr /*HBITMAP*/ IntCreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, short[] lpvBits);
        public static IntPtr /*HBITMAP*/ CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, short[] lpvBits) {
            return NativeMethods.HandleCollector.Add(IntCreateBitmap(nWidth, nHeight, nPlanes, nBitsPerPixel, lpvBits), NativeMethods.CommonHandles.GDI);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateBitmap", CharSet=CharSet.Auto)]
        private static extern IntPtr /*HBITMAP*/ IntCreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, byte[] lpvBits);
        public static IntPtr /*HBITMAP*/ CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, byte[] lpvBits) {
            return NativeMethods.HandleCollector.Add(IntCreateBitmap(nWidth, nHeight, nPlanes, nBitsPerPixel, lpvBits), NativeMethods.CommonHandles.GDI);
        }


        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreatePatternBrush", CharSet=CharSet.Auto)]
        private static extern IntPtr /*HBRUSH*/ IntCreatePatternBrush(IntPtr hbmp);
        public static IntPtr /*HBRUSH*/ CreatePatternBrush(IntPtr hbmp) {
            return NativeMethods.HandleCollector.Add(IntCreatePatternBrush(hbmp), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="DeleteObject", CharSet=CharSet.Auto)]
        private static extern bool IntDeleteObject(IntPtr hObject);
        public static bool DeleteObject(IntPtr hObject) {
            NativeMethods.HandleCollector.Remove(hObject, NativeMethods.CommonHandles.GDI);
            return IntDeleteObject(hObject);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int SetBkMode(IntPtr hDC, int nBkMode);
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern bool ExtTextOut(IntPtr hDC, int x, int y, int nOptions, ref RECT lpRect, string s, int nStrLength, int[] lpDx);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int SetBkColor(IntPtr hDC, int clr);
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetTextExtentPoint32(IntPtr hDC, String str, int len, [In, Out] SIZE size);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int /*COLORREF*/ SetTextColor(IntPtr hDC, int crColor);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern int DrawText(IntPtr hDC, string lpszString, int nCount, ref RECT lpRect, int nFormat);
        [DllImport(ExternDll.Comctl32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int ImageList_Draw(IntPtr hImageList, int i, IntPtr hdc, int x, int y, int fStyle);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SelectObject(IntPtr hDC, IntPtr hObject);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool PatBlt(IntPtr hDC, int x, int y, int nWidth, int nHeight, int dwRop);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetTimer(IntPtr hWnd, IntPtr nIDEvent, int uElapse, TimerProc lpTimerFunc);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool KillTimer(IntPtr hwnd, IntPtr idEvent);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int GetFileAttributes(String name);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool PeekMessage([In, Out] ref MSG msg, IntPtr hwnd, int msgMin, int msgMax, int remove);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool GetClientRect(IntPtr hWnd, [In, Out] ref RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool GetClientRect(IntPtr hWnd, [In, Out] COMRECT rect);

        [ComVisible(true), Guid("0000000C-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IStream {

    	[return: MarshalAs(UnmanagedType.I4)]
    	 int Read(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int buf,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int len);

    	[return: MarshalAs(UnmanagedType.I4)]
    	 int Write(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int buf,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int len);

    	[return: MarshalAs(UnmanagedType.I8)]
    	 long Seek(
    		[In, MarshalAs(UnmanagedType.I8)] 
    		 long dlibMove,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int dwOrigin);

    	
    	 void SetSize(
    		[In, MarshalAs(UnmanagedType.I8)] 
    		 long libNewSize);

    	[return: MarshalAs(UnmanagedType.I8)]
    	 long CopyTo(
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  NativeMethods.IStream pstm,
    		[In, MarshalAs(UnmanagedType.I8)] 
    		 long cb,
    		[Out, MarshalAs(UnmanagedType.LPArray)] 
    		  long[] pcbRead);

    	
    	 void Commit(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int grfCommitFlags);

    	
    	 void Revert();

    	
    	 void LockRegion(
    		[In, MarshalAs(UnmanagedType.I8)] 
    		 long libOffset,
    		[In, MarshalAs(UnmanagedType.I8)] 
    		 long cb,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int dwLockType);

    	
    	 void UnlockRegion(
    		[In, MarshalAs(UnmanagedType.I8)] 
    		 long libOffset,
    		[In, MarshalAs(UnmanagedType.I8)] 
    		 long cb,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int dwLockType);

    	
    	 void Stat(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		  int pStatstg,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int grfStatFlag);

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  NativeMethods.IStream Clone();
    }             
             
        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.DataStreamFromComStream"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public class DataStreamFromComStream : Stream {

            private NativeMethods.IStream comStream;

            public DataStreamFromComStream(NativeMethods.IStream comStream) : base() {
                this.comStream = comStream;
            }

            public override long Position {
                get {
                    return Seek(0, SeekOrigin.Current);
                }

                set {
                    Seek(value, SeekOrigin.Begin);
                }
            }

            public override bool CanWrite {
                get {
                    return true;
                }
            }

            public override bool CanSeek {
                get {
                    return true;
                }
            }

            public override bool CanRead {
                get {
                    return true;
                }
            }

            public override long Length {
                get {
                    long curPos = this.Position;
                    long endPos = Seek(0, SeekOrigin.End);
                    this.Position = curPos;
                    return endPos - curPos;
                }
            }

            private void _NotImpl(string message) {
                NotSupportedException ex = new NotSupportedException(message, new ExternalException("", NativeMethods.E_NOTIMPL));
                throw ex;
            }

            private unsafe int _Read(void* handle, int bytes) {
                return comStream.Read((int)handle, bytes);
            }

            private unsafe int _Write(void* handle, int bytes) {
                return comStream.Write((int)handle, bytes);
            }
            
            public void Dispose() {
                if (comStream != null) {
                    Flush();
                    comStream = null;
                }
            }

            public override void Flush() {
                if (comStream != null) {
                    try {
                        comStream.Commit(NativeMethods.StreamConsts.STGC_DEFAULT);
                    }
                    catch(Exception) {
                    }
                }
            }

            public unsafe override int Read(byte[] buffer, int index, int count) {
                int bytesRead = 0;
                if (count > 0) {
                    fixed (byte* ch = buffer) {
                        bytesRead = _Read((void*)(ch + index), count); 
                    }
                }
                return bytesRead;
            }

            public override void SetLength(long value) {
                comStream.SetSize(value);
            }

            public override long Seek(long offset, SeekOrigin origin) {
                return comStream.Seek(offset, (int)origin);
            }

            public unsafe override void Write(byte[] buffer, int index, int count) {
                int bytesWritten = 0;
                if (count > 0) {
                    fixed (byte* b = buffer) {
                        bytesWritten = _Write((void*)(b + index), count);
                    }
                    if (bytesWritten != count)
                        throw new IOException("Didn't write enough bytes to NativeMethods.IStream!");  // @TODO: Localize this.
                }
            }

            public override void Close() {
                if (comStream != null) {
                    Flush();
                    comStream = null;
                    GC.SuppressFinalize(this);
                }
            }

            ~DataStreamFromComStream() {
                Close();
            }
        }
        
        [
        ComImport(),
        Guid("FC4801A3-2BA9-11CF-A229-00AA003D7352"),
        InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
        CLSCompliant(false)
        ]
        internal interface IObjectWithSite {
            void SetSite(
                        [MarshalAs(UnmanagedType.Interface)]
                        object pUnkSite);

            [return:MarshalAs(UnmanagedType.Interface)]
            object GetSite(
                [In] 
                  ref Guid riid
                );
        }
        
        [ComVisible(true), 
        ComImport(),
        Guid("B722BCCB-4E68-101B-A2BC-00AA00404770"),
        InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
        CLSCompliantAttribute(false)
        ]
        public interface IOleCommandTarget {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int QueryStatus(
                           ref Guid pguidCmdGroup,
                           int cCmds,
                           [In, Out] 
                           NativeMethods._tagOLECMD prgCmds,
                           [In, Out] 
                           IntPtr pCmdText);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int Exec(
                    ref Guid pguidCmdGroup,
                    int nCmdID,
                    int nCmdexecopt,
                    // we need to have this an array because callers need to be able to specify NULL or VT_NULL
                    [In, MarshalAs(UnmanagedType.LPArray)]
                    Object[] pvaIn,
                    int pvaOut);
        }

        [ComVisible(true), ComImport(), Guid("B722BCC7-4E68-101B-A2BC-00AA00404770"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDocumentSite {
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int ActivateMe(
        		[In, MarshalAs(UnmanagedType.Interface)] 
        		  IOleDocumentView pViewToActivate);
    
    
        }


    [ComVisible(true), ComImport(), Guid("00000117-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IOleInPlaceActiveObject {

         [PreserveSig]
    	 int GetWindow(out IntPtr hwnd);

    	
    	 void ContextSensitiveHelp(
    		[In, MarshalAs(UnmanagedType.I4)]
    		 int fEnterMode);

    	[return: MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
    	 int TranslateAccelerator(
    		[In]
    		  ref MSG lpmsg);

    	
    	 void OnFrameWindowActivate(
    		[In, MarshalAs(UnmanagedType.I4)]
    		 int fActivate);

    	
    	 void OnDocWindowActivate(
    		[In, MarshalAs(UnmanagedType.I4)]
    		 int fActivate);

    	
    	 void ResizeBorder(
    		[In]
    		  COMRECT prcBorder,
    		[In]
    		  IOleInPlaceUIWindow pUIWindow,
    		[In, MarshalAs(UnmanagedType.I4)]
    		 int fFrameWindow);

    	
    	 void EnableModeless(
    		[In, MarshalAs(UnmanagedType.I4)]
    		 int fEnable);


    }

    /**
     * @security(checkClassLinking=on)
     */
    // C#r: noAutoOffset
    [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
    public sealed class tagOleMenuGroupWidths
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=6)/*leftover(offset=0, widths)*/]
        public int[] widths = new int[6];
    }
    
       
       
    public sealed class tagTYMED 
    { 
        public const int HGLOBAL     = 1; 
        public const int FILE        = 2; 
        public const int ISTREAM     = 4; 
        public const int ISTORAGE    = 8; 
        public const int GDI         = 16; 
        public const int MFPICT      = 32; 
        public const int ENHMF       = 64; 
        public const int NULL        = 0;
    }
    
 
    [CLSCompliantAttribute(false)]
    public class  _DOCHOSTUIDBLCLICK {

    	public const   int DEFAULT = 0x0;
    	public const   int SHOWPROPERTIES = 0x1;
    	public const   int SHOWCODE = 0x2;

    }

    // C#r: noAutoOffset
    [
    ComVisible(true), StructLayout(LayoutKind.Sequential),
    CLSCompliantAttribute(false)
    ]
    public class  _DOCHOSTUIINFO {

        [MarshalAs(UnmanagedType.U4)]
        public   int cbSize;
        [MarshalAs(UnmanagedType.I4)]
        public   int dwFlags;
        [MarshalAs(UnmanagedType.I4)]
        public   int dwDoubleClick;
        [MarshalAs(UnmanagedType.I4)]
        public   int dwReserved1;
        [MarshalAs(UnmanagedType.I4)]
        public   int dwReserved2;

    }
    
     [CLSCompliantAttribute(false)]
    public class  _DOCHOSTUIFLAG {

        public const   int DIALOG = 0x1;
        public const   int DISABLE_HELP_MENU = 0x2;
        public const   int NO3DBORDER = 0x4;
        public const   int SCROLL_NO = 0x8;
        public const   int DISABLE_SCRIPT_INACTIVE = 0x10;
        public const   int OPENNEWWIN = 0x20;
        public const   int DISABLE_OFFSCREEN = 0x40;
        public const   int FLAT_SCROLLBAR = 0x80;
        public const   int DIV_BLOCKDEFAULT = 0x100;
        public const   int ACTIVATE_CLIENTHIT_ONLY = 0x200;
        public const   int DISABLE_COOKIE = 0x400;

    }

    [ComVisible(true), Guid("00000115-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IOleInPlaceUIWindow {

    	 IntPtr GetWindow();

    	
    	 void ContextSensitiveHelp(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int fEnterMode);

    	
    	 void GetBorder(
    		[Out] 
    		  COMRECT lprectBorder);

    	
    	 void RequestBorderSpace(
    		[In] 
    		  COMRECT pborderwidths);

    	
    	 void SetBorderSpace(
    		[In] 
    		  COMRECT pborderwidths);

    	
    	 void SetActiveObject(
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  IOleInPlaceActiveObject pActiveObject,
    		[In, MarshalAs(UnmanagedType.LPWStr)] 
    		  string pszObjName);


    }
        
        [ComVisible(true), Guid("B722BCC6-4E68-101B-A2BC-00AA00404770"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDocumentView {
    
        	 void SetInPlaceSite(
        		[In, MarshalAs(UnmanagedType.Interface)] 
        		  IOleInPlaceSite pIPSite);
    
        	[return: MarshalAs(UnmanagedType.Interface)]
        	  IOleInPlaceSite GetInPlaceSite();
    
        	[return: MarshalAs(UnmanagedType.Interface)]
        	  object GetDocument();
    
        	
        	 void SetRect(
        		[In] 
        		  COMRECT prcView);
    
        	
        	 void GetRect(
        		[Out] 
        		  COMRECT prcView);
    
        	
        	 void SetRectComplex(
        		[In] 
        		  COMRECT prcView,
        		[In] 
        		  COMRECT prcHScroll,
        		[In] 
        		  COMRECT prcVScroll,
        		[In] 
        		  COMRECT prcSizeBox);
    
        	
        	 void Show(
        		[In, MarshalAs(UnmanagedType.I4)] 
        		 int fShow);
    
        	
        	 void UIActivate(
        		[In, MarshalAs(UnmanagedType.I4)] 
        		 int fUIActivate);
    
        	
        	 void Open();
    
        	
        	 void CloseView(
        		[In, MarshalAs(UnmanagedType.U4)] 
        		 int dwReserved);
    
        	
        	 void SaveViewState(
        		[In, MarshalAs(UnmanagedType.Interface)] 
        		  IStream pstm);
    
        	
        	 void ApplyViewState(
        		[In, MarshalAs(UnmanagedType.Interface)] 
        		  IStream pstm);
    
        	
        	 void Clone(
        		[In, MarshalAs(UnmanagedType.Interface)] 
        		  IOleInPlaceSite pIPSiteNew,
        		[Out, MarshalAs(UnmanagedType.LPArray)] 
        		   IOleDocumentView[] ppViewNew);
    
    
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
    public sealed class tagOIFI
    {
      [MarshalAs(UnmanagedType.U4)/*leftover(offset=0, cb)*/]
      public int cb;

      [MarshalAs(UnmanagedType.I4)/*leftover(offset=4, fMDIApp)*/]
      public int fMDIApp;

      public IntPtr hwndFrame;

      public IntPtr hAccel;

      [MarshalAs(UnmanagedType.U4)/*leftover(offset=16, cAccelEntries)*/]
      public int cAccelEntries;

    }
    

        [ComVisible(true), ComImport(), Guid("00000116-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceFrame {
    
             IntPtr GetWindow();
    
            
             void ContextSensitiveHelp(
                    [In, MarshalAs(UnmanagedType.I4)]
                     int fEnterMode);
    
            
             void GetBorder(
                    [Out]
                      COMRECT lprectBorder);
    
            
             void RequestBorderSpace(
                    [In]
                      COMRECT pborderwidths);
    
            
             void SetBorderSpace(
                    [In]
                      COMRECT pborderwidths);
    
            
             void SetActiveObject(
                    [In, MarshalAs(UnmanagedType.Interface)]
                      IOleInPlaceActiveObject pActiveObject,
                    [In, MarshalAs(UnmanagedType.LPWStr)]
                      string pszObjName);
    
            
             void InsertMenus(
                    [In]
                     IntPtr hmenuShared,
                    [In, Out]
                      tagOleMenuGroupWidths lpMenuWidths);
    
            
             void SetMenu(
                    [In]
                     IntPtr hmenuShared,
                    [In]
                     IntPtr holemenu,
                    [In]
                     IntPtr hwndActiveObject);
    
            
             void RemoveMenus(
                    [In]
                     IntPtr hmenuShared);
    
            
             void SetStatusText(
                    [In, MarshalAs(UnmanagedType.BStr)]
                      string pszStatusText);
    
            
             void EnableModeless(
                    [In, MarshalAs(UnmanagedType.I4)]
                     int fEnable);
    
            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
             int TranslateAccelerator(
                    [In]
                      ref MSG lpmsg,
                    [In, MarshalAs(UnmanagedType.U2)]
                     short wID);
    
    
        }
        
        [ComVisible(true), ComImport, Guid("00000121-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDropSource {
    
        	[return: MarshalAs(UnmanagedType.I4)]
        	 [PreserveSig]
        	 int OleQueryContinueDrag(
        		[In, MarshalAs(UnmanagedType.I4)]
        		 int fEscapePressed,
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int grfKeyState);
    
        	[return: MarshalAs(UnmanagedType.I4)]
        	 [PreserveSig]
        	 int OleGiveFeedback(
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int dwEffect);
    
    
        }
        
        [ComVisible(true), ComImport, Guid("00000122-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDropTarget {
    
        	[return: MarshalAs(UnmanagedType.I4)]
        	 [PreserveSig]
        	 int OleDragEnter(
        		[In, MarshalAs(UnmanagedType.Interface)]
        		  IOleDataObject pDataObj,
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int grfKeyState,
                 [In, MarshalAs(UnmanagedType.U8)]
        		 long pt,
        		[In, Out, MarshalAs(UnmanagedType.I4)]
        		  ref int pdwEffect);
    
        	[return: MarshalAs(UnmanagedType.I4)]
        	 [PreserveSig]
        	 int OleDragOver(
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int grfKeyState,
                 [In, MarshalAs(UnmanagedType.U8)]
        		  long pt,
        		[In, Out, MarshalAs(UnmanagedType.I4)]
        		  ref int pdwEffect);
    
        	[return: MarshalAs(UnmanagedType.I4)]
        	 [PreserveSig]
        	 int OleDragLeave();
    
        	[return: MarshalAs(UnmanagedType.I4)]
        	 [PreserveSig]
        	 int OleDrop(
        		[In, MarshalAs(UnmanagedType.Interface)]
        		  IOleDataObject pDataObj,
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int grfKeyState,
        		  [In, MarshalAs(UnmanagedType.U8)]
        		  long pt,
        		[In, Out, MarshalAs(UnmanagedType.I4)]
        		  ref int pdwEffect);
        }
        
        
        [ComVisible(true), ComImport(), Guid("00000119-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceSite {
    
             IntPtr GetWindow();
    
            
             void ContextSensitiveHelp(
                    [In, MarshalAs(UnmanagedType.I4)] 
                     int fEnterMode);
    
            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
             int CanInPlaceActivate();
    
            
             void OnInPlaceActivate();
    
            
             void OnUIActivate();
    
            
             void GetWindowContext(
                    [Out]
                       out IOleInPlaceFrame ppFrame,
                    [Out]
                       out IOleInPlaceUIWindow ppDoc,
                    [Out] 
                      COMRECT lprcPosRect,
                    [Out] 
                      COMRECT lprcClipRect,
                    [In, Out] 
                      tagOIFI lpFrameInfo);
    
            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
             int Scroll(
                    [In, MarshalAs(UnmanagedType.U4)] 
                      tagSIZE scrollExtant);
    
            
             void OnUIDeactivate(
                    [In, MarshalAs(UnmanagedType.I4)] 
                     int fUndoable);
    
            
             void OnInPlaceDeactivate();
    
            
             void DiscardUndoState();
    
            
             void DeactivateAndUndo();
    
            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
             int OnPosRectChange(
                    [In] 
                      COMRECT lprcPosRect);
    
    
        }
    

    /**
     * @security(checkClassLinking=on)
     */
    // C#r: noAutoOffset
    [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
    public sealed class tagSIZE
    {
      [MarshalAs(UnmanagedType.I4)/*leftover(offset=0, cx)*/]
      public int cx;

      [MarshalAs(UnmanagedType.I4)/*leftover(offset=4, cy)*/]
      public int cy;

    }

        [ComVisible(true), ComImport(), Guid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        [CLSCompliant(false)]
        public interface IDocHostUIHandler {
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int ShowContextMenu(
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int dwID,
        		[In]
        		  POINT pt,
        		[In, MarshalAs(UnmanagedType.Interface)]
        		  object pcmdtReserved,
        		[In, MarshalAs(UnmanagedType.Interface)]
        		  object pdispReserved);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int GetHostInfo(
        		[In, Out]
        		  _DOCHOSTUIINFO info);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int ShowUI(
        		[In, MarshalAs(UnmanagedType.I4)]
        		 int dwID,
        		[In]
        		  IOleInPlaceActiveObject activeObject,
        		[In]
        		  IOleCommandTarget commandTarget,
        		[In]
        		  IOleInPlaceFrame frame,
        		[In]
        		  IOleInPlaceUIWindow doc);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int HideUI();
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int UpdateUI();
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int EnableModeless(
        		[In, MarshalAs(UnmanagedType.Bool)]
        		 bool fEnable);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int OnDocWindowActivate(
        		[In, MarshalAs(UnmanagedType.Bool)]
        		 bool fActivate);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int OnFrameWindowActivate(
        		[In, MarshalAs(UnmanagedType.Bool)]
        		 bool fActivate);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int ResizeBorder(
        		[In]
        		  COMRECT rect,
        		[In]
        		  IOleInPlaceUIWindow doc,
        		 bool fFrameWindow);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int TranslateAccelerator(
        		[In]
        		  ref MSG msg,
        		[In]
        		  ref Guid group,
        		[In, MarshalAs(UnmanagedType.I4)]
        		 int nCmdID);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int GetOptionKeyPath(
        		[Out, MarshalAs(UnmanagedType.LPArray)]
        		   String[] pbstrKey,
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int dw);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	  int GetDropTarget(
        		[In, MarshalAs(UnmanagedType.Interface)]
        		  IOleDropTarget pDropTarget,
                    [Out, MarshalAs(UnmanagedType.Interface)]
                      out IOleDropTarget ppDropTarget);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	  int GetExternal(
                [Out, MarshalAs(UnmanagedType.Interface)]
                  out object ppDispatch);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	  int TranslateUrl(
        		[In, MarshalAs(UnmanagedType.U4)]
        		 int dwTranslate,
        		[In, MarshalAs(UnmanagedType.LPWStr)]
        		  string strURLIn,
                    [Out, MarshalAs(UnmanagedType.LPWStr)]
                      out string pstrURLOut);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	  int FilterDataObject(
        		[In, MarshalAs(UnmanagedType.Interface)]
        		  IOleDataObject pDO,
                    [Out, MarshalAs(UnmanagedType.Interface)]
                      out IOleDataObject ppDORet);
    
    
        }
    
        [ComVisible(true), ComImport(), Guid("6D5140C1-7436-11CE-8034-00AA006009FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleServiceProvider {
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int QueryService(
                  [In]
        		  ref Guid guidService,
                  [In]
                  ref Guid riid,
                  out IntPtr ppvObject);
        }
        
           [ComVisible(true), Guid("CB728B20-F786-11CE-92AD-00AA00A74CD0"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IProfferService {

    	 void ProfferService(
    		[In] 
    		  ref Guid rguidService,
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  IOleServiceProvider psp,
    		[In, MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pdwCookie);

    	
    	 void RevokeService(
    		[In, MarshalAs(UnmanagedType.U4)] 
    		 int dwCookie);


    }

    
        [ComVisible(true), ComImport(), Guid("00000103-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumFORMATETC {
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int Next(
        		[In, MarshalAs(UnmanagedType.U4)] 
        		 int celt,
        		[Out] 
        		  FORMATETC rgelt,
        		[In, Out, MarshalAs(UnmanagedType.LPArray)] 
        		  int[] pceltFetched);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int Skip(
        		[In, MarshalAs(UnmanagedType.U4)] 
        		 int celt);
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int Reset();
    
        	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
        	 int Clone(
        		[Out, MarshalAs(UnmanagedType.LPArray)] 
        		   IEnumFORMATETC[] ppenum);
    
    
        }
        
        [ComVisible(true), ComImport(), Guid("B196B286-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IConnectionPoint {

    	[return: MarshalAs(UnmanagedType.I4)]
	                [PreserveSig]
    	int GetConnectionInterface();

    	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
    	int GetConnectionPointContainer(
            [MarshalAs(UnmanagedType.Interface)]
            ref IConnectionPointContainer pContainer);

    	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
    	 int Advise(
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  object pUnkSink,
              ref int cookie);

    	[return: MarshalAs(UnmanagedType.I4)]
                [PreserveSig]
    	int Unadvise(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int cookie);

    }
    
     [ComVisible(true), Guid("B196B284-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IConnectionPointContainer {

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  object EnumConnectionPoints();

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  IConnectionPoint FindConnectionPoint(
			[In]
    		  ref Guid guid);

    }
    
    
    public class ConnectionPointCookie {
        private IConnectionPoint connectionPoint;
        private int cookie;
        #if DEBUG
        private string callStack;
        #endif

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.ConnectionPointCookie"]/*' />
        /// <devdoc>
        /// Creates a connection point to of the given interface type.
        /// which will call on a managed code sink that implements that interface.
        /// </devdoc>
        public ConnectionPointCookie(object source, object sink, Type eventInterface) : this(source, sink, eventInterface, true){
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.ConnectionPointCookie1"]/*' />
        /// <devdoc>
        /// Creates a connection point to of the given interface type.
        /// which will call on a managed code sink that implements that interface.
        /// </devdoc>
        public ConnectionPointCookie(object source, object sink, Type eventInterface, bool throwException){
            Exception ex = null;
            if (source is IConnectionPointContainer) {
                IConnectionPointContainer cpc = (IConnectionPointContainer)source;

                try {
                    Guid tmp = eventInterface.GUID;
                    connectionPoint = cpc.FindConnectionPoint(ref tmp);
                }
                catch (Exception) {
                    connectionPoint = null;
                }

                if (connectionPoint == null) {
                    ex = new ArgumentException(SR.GetString(SR.ConnPointSourceIF, eventInterface.Name));
                }
                else if (sink == null || !eventInterface.IsInstanceOfType(sink)) {
                    ex = new InvalidCastException(SR.GetString(SR.ConnPointSinkIF));
                }
                else {
                    int hr = connectionPoint.Advise(sink, ref cookie);
                    if (hr != NativeMethods.S_OK) {
                        cookie = 0;
                        connectionPoint = null;
                        ex = new Exception(SR.GetString(SR.ConnPointAdviseFailed, eventInterface.Name));
                    }
                }
            }
            else {
                ex = new InvalidCastException("The source object does not expost IConnectionPointContainer");
            }


            if (throwException && (connectionPoint == null || cookie == 0)) {
                if (ex == null) {
                    throw new ArgumentException(SR.GetString(SR.ConnPointCouldNotCreate, eventInterface.Name));
                }
                else {
                    throw ex;
                }
            }
        
            #if DEBUG
            callStack = Environment.StackTrace;
            #endif
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.Disconnect"]/*' />
        /// <devdoc>
        /// Disconnect the current connection point.  If the object is not connected,
        /// this method will do nothing.
        /// </devdoc>
        public void Disconnect() {
            Disconnect(false);
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.Disconnect1"]/*' />
        /// <devdoc>
        /// Disconnect the current connection point.  If the object is not connected,
        /// this method will do nothing.
        /// </devdoc>
        public void Disconnect(bool release) {
            if (connectionPoint != null && cookie != 0) {
                connectionPoint.Unadvise(cookie);
                cookie = 0;

                if (release) {
                    Marshal.ReleaseComObject(connectionPoint);
                }

                connectionPoint = null;
            }
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.Finalize"]/*' />
        /// <internalonly/>
        ~ConnectionPointCookie(){
            System.Diagnostics.Debug.Assert(connectionPoint == null || cookie == 0, "We should never finalize an active connection point");
            Disconnect();
        }
    }
    
    [ComVisible(true), ComImport(), Guid("7FD52380-4E07-101B-AE2D-08002B2EC713"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IPersistStreamInit {

    	
    	 void GetClassID(
    		[In, Out] 
    		  ref Guid pClassID);

    	[return: MarshalAs(UnmanagedType.I4)]
        [PreserveSig]
    	 int IsDirty();

    	
    	 void Load(
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  IStream pstm);

    	
    	 void Save(
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  IStream pstm,
    		[In, MarshalAs(UnmanagedType.Bool)] 
    		 bool fClearDirty);

    	
    	 void GetSizeMax(
    		[Out, MarshalAs(UnmanagedType.LPArray)] 
    		 long pcbSize);

    	
    	 void InitNew();


    }



        [
        StructLayout(LayoutKind.Sequential),
        CLSCompliantAttribute(false)
        ]
        public sealed class _tagOLECMD {

            [MarshalAs(UnmanagedType.U4)]
            public   int cmdID;
            [MarshalAs(UnmanagedType.U4)]
            public   int cmdf;

        }
        
        
            [
    StructLayout(LayoutKind.Sequential),
    CLSCompliantAttribute(false)
    ]
    public sealed class  tagOLECMDTEXT {

        [MarshalAs(UnmanagedType.U4)]
        public   int cmdtextf;
        [MarshalAs(UnmanagedType.U4)]
        public   int cwActual;
        [MarshalAs(UnmanagedType.U4)]
        public   int cwBuf;
        [MarshalAs(UnmanagedType.U4)]
        public   int rgwz;

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.tagOLECMDTEXT.GetText"]/*' />
        /// <devdoc>
        ///      Accessing the text of this structure is very cumbersome.  Instead, you may
        ///      use this method to access an integer pointer of the structure.
        ///      Passing integer versions of this structure is needed because there is no
        ///      way to tell the common language runtime that there is extra data at the end of the structure.
        /// </devdoc>
        public static string GetText(IntPtr pCmdTextInt) {
            tagOLECMDTEXT  pCmdText = (tagOLECMDTEXT) Marshal.PtrToStructure(pCmdTextInt, typeof(tagOLECMDTEXT));

            // Get the offset to the rgsz param.
            //
            IntPtr offset = Marshal.OffsetOf(typeof(tagOLECMDTEXT), "rgwz");

            // Punt early if there is no text in the structure.
            //
            if (pCmdText.cwActual == 0) {
                return "";
            }

            char[] text = new char[pCmdText.cwActual - 1];

            Marshal.Copy((IntPtr)((long)pCmdTextInt + (long)offset), text, 0, text.Length);

            StringBuilder s = new StringBuilder(text.Length);
            s.Append(text);
            return s.ToString();
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.tagOLECMDTEXT.SetText"]/*' />
        /// <devdoc>
        ///      Accessing the text of this structure is very cumbersome.  Instead, you may
        ///      use this method to access an integer pointer of the structure.
        ///      Passing integer versions of this structure is needed because there is no
        ///      way to tell the common language runtime that there is extra data at the end of the structure.
        /// </devdoc>
        public static void SetText(IntPtr pCmdTextInt, string text) {
            tagOLECMDTEXT  pCmdText = (tagOLECMDTEXT) Marshal.PtrToStructure(pCmdTextInt, typeof(tagOLECMDTEXT));
            char[]          menuText = text.ToCharArray();

            // Get the offset to the rgsz param.  This is where we will stuff our text
            //
            IntPtr offset = Marshal.OffsetOf(typeof(tagOLECMDTEXT), "rgwz");
            IntPtr offsetToCwActual = Marshal.OffsetOf(typeof(tagOLECMDTEXT), "cwActual");

            // The max chars we copy is our string, or one less than the buffer size,
            // since we need a null at the end.
            //
            int maxChars = Math.Min(pCmdText.cwBuf - 1, menuText.Length);

            Marshal.Copy(menuText, 0, (IntPtr)((long)pCmdTextInt + (long)offset), maxChars);

            // append a null character
            Marshal.WriteInt16((IntPtr)((long)pCmdTextInt + (long)offset + maxChars * 2), 0);

            // write out the length
            // +1 for the null char
            Marshal.WriteInt32((IntPtr)((long)pCmdTextInt + (long)offsetToCwActual), maxChars + 1);
        }
    }

        
    
    public enum tagOLECMDF {
        OLECMDF_SUPPORTED    = 1, 
        OLECMDF_ENABLED      = 2, 
        OLECMDF_LATCHED      = 4, 
        OLECMDF_NINCHED      = 8,
        OLECMDF_INVISIBLE    = 16
   }
   
    [ComVisible(true), ComImport, Guid("0000010E-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IOleDataObject {

    	[return: MarshalAs(UnmanagedType.I4)]
    	 [PreserveSig]
    	 int OleGetData(
    		  FORMATETC pFormatetc,
    		[Out] 
    		  STGMEDIUM pMedium);

    	[return: MarshalAs(UnmanagedType.I4)]
    	 [PreserveSig]
    	 int OleGetDataHere(
    		  FORMATETC pFormatetc,
    		[In, Out] 
    		  STGMEDIUM pMedium);

    	[return: MarshalAs(UnmanagedType.I4)]
    	 [PreserveSig]
    	 int OleQueryGetData(
    		  FORMATETC pFormatetc);

    	[return: MarshalAs(UnmanagedType.I4)]
    	 [PreserveSig]
    	 int OleGetCanonicalFormatEtc(
    		  FORMATETC pformatectIn,
    		[Out] 
    		  FORMATETC pformatetcOut);

    	[return: MarshalAs(UnmanagedType.I4)]
    	 [PreserveSig]
    	 int OleSetData(
    		  FORMATETC pFormatectIn,
    		  STGMEDIUM pmedium,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int fRelease);

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  IEnumFORMATETC OleEnumFormatEtc(
    		[In, MarshalAs(UnmanagedType.U4)] 
    		 int dwDirection);

    	 [PreserveSig]
    	 int OleDAdvise(
    		  FORMATETC pFormatetc,
    		[In, MarshalAs(UnmanagedType.U4)] 
    		 int advf,
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  object pAdvSink,
    		[Out, MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pdwConnection);

    	 [PreserveSig]
    	 int OleDUnadvise(
    		[In, MarshalAs(UnmanagedType.U4)] 
    		 int dwConnection);

    	 [PreserveSig]
    	 int OleEnumDAdvise(
    		[Out, MarshalAs(UnmanagedType.LPArray)] 
    		   Object[] ppenumAdvise);
    }
        
        [StructLayout(LayoutKind.Sequential)]
        public class SYSTEMTIME {
            public short wYear;
            public short wMonth;
            public short wDayOfWeek;
            public short wDay;
            public short wHour;
            public short wMinute;
            public short wSecond;
            public short wMilliseconds;

            public override string ToString() {
                return "[SYSTEMTIME: " 
                + wDay.ToString() +"/" + wMonth.ToString() + "/" + wYear.ToString() 
                + " " + wHour.ToString() + ":" + wMinute.ToString() + ":" + wSecond.ToString()
                + "]";
            }
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public RECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static RECT FromXYWH(int x, int y, int width, int height) {
                return new RECT(x,
                                y,
                                x + width,
                                y + height);
            }
        }
        [StructLayout(LayoutKind.Sequential)]
        public class POINT {
            public int x;
            public int y;

            public POINT() {
            }

            public POINT(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class COMRECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public COMRECT() {
            }

            public COMRECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }
            
            /*public COMRECT(Microsoft.Win32.Interop.COMRECT win32RECT) {
                this.left = win32RECT.left;
                this.top = win32RECT.top;
                this.right = win32RECT.right;
                this.bottom = win32RECT.bottom;
            } */


            public static COMRECT FromXYWH(int x, int y, int width, int height) {
                return new COMRECT(x,
                                y,
                                x + width,
                                y + height);
            }
            
            public COMRECT ToWin32InteropCOMRECT() {
                return new COMRECT(left, top, right, bottom);
            }
        }
        [StructLayout(LayoutKind.Sequential)]
        public class SIZE {
            public int cx;
            public int cy;

            public SIZE() {
            }

            public SIZE(int cx, int cy) {
                this.cx = cx;
                this.cy = cy;
            }
        }
        
        
         [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
       public class LOGFONT {
               public int lfHeight;
               public int lfWidth;
               public int lfEscapement;
               public int lfOrientation;
               public int lfWeight;
               public byte lfItalic;
               public byte lfUnderline;
               public byte lfStrikeOut;
               public byte lfCharSet;
               public byte lfOutPrecision;
               public byte lfClipPrecision;
               public byte lfQuality;
               public byte lfPitchAndFamily;
               [MarshalAs(UnmanagedType.ByValTStr, SizeConst=32)]
               public String   lfFaceName;
       }

        
        [StructLayout(LayoutKind.Sequential)]
        public struct MSG {
            public IntPtr   hwnd;
            public int      message;
            public IntPtr   wParam;
            public IntPtr   lParam;
            public int      time;
            // pt was a by-value POINT structure
            public int      pt_x;
            public int      pt_y;
        }

        [StructLayout(LayoutKind.Sequential)]
        public sealed class FORMATETC {
            
            public   short cfFormat;
            public   short dummy;
        	[MarshalAs(UnmanagedType.I4)]
        	public   int ptd;
        	[MarshalAs(UnmanagedType.I4)]
        	public   int dwAspect;
        	[MarshalAs(UnmanagedType.I4)]
        	public   int lindex;
        	[MarshalAs(UnmanagedType.I4)]
        	public   int tymed;
    
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class STGMEDIUM {
    
            [MarshalAs(UnmanagedType.I4)]
            public   int tymed;
            public   IntPtr unionmember;
            public   IntPtr pUnkForRelease;
    
        }
        
        public sealed class CommonHandles {
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Accelerator"]/*' />
            /// <devdoc>
            ///     Handle type for accelerator tables.
            /// </devdoc>
            public static readonly int Accelerator  = HandleCollector.RegisterType("Accelerator", 80, 50);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Cursor"]/*' />
            /// <devdoc>
            ///     handle type for cursors.
            /// </devdoc>
            public static readonly int Cursor       = HandleCollector.RegisterType("Cursor", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.EMF"]/*' />
            /// <devdoc>
            ///     Handle type for enhanced metafiles.
            /// </devdoc>
            public static readonly int EMF          = HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Find"]/*' />
            /// <devdoc>
            ///     Handle type for file find handles.
            /// </devdoc>
            public static readonly int Find         = HandleCollector.RegisterType("Find", 0, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.GDI"]/*' />
            /// <devdoc>
            ///     Handle type for GDI objects.
            /// </devdoc>
            public static readonly int GDI          = HandleCollector.RegisterType("GDI", 90, 50);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.HDC"]/*' />
            /// <devdoc>
            ///     Handle type for HDC's that count against the Win98 limit of five DC's.  HDC's
            ///     which are not scarce, such as HDC's for bitmaps, are counted as GDIHANDLE's.
            /// </devdoc>
            public static readonly int HDC          = HandleCollector.RegisterType("HDC", 100, 2); // wait for 2 dc's before collecting

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Icon"]/*' />
            /// <devdoc>
            ///     Handle type for icons.
            /// </devdoc>
            public static readonly int Icon         = HandleCollector.RegisterType("Icon", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Kernel"]/*' />
            /// <devdoc>
            ///     Handle type for kernel objects.
            /// </devdoc>
            public static readonly int Kernel       = HandleCollector.RegisterType("Kernel", 0, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Menu"]/*' />
            /// <devdoc>
            ///     Handle type for files.
            /// </devdoc>
            public static readonly int Menu         = HandleCollector.RegisterType("Menu", 30, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Window"]/*' />
            /// <devdoc>
            ///     Handle type for windows.
            /// </devdoc>
            public static readonly int Window       = HandleCollector.RegisterType("Window", 5, 1000);
        }

        
        public sealed class HandleCollector {
            private static HandleType[]             handleTypes = null;
            private static int                      handleTypeCount = 0;
            private static HandleChangeEventHandler handleAdd = null;
            private static HandleChangeEventHandler handleRemove = null;

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Add"]/*' />
            /// <devdoc>
            ///     Adds the given handle to the handle collector.  This keeps the
            ///     handle on a "hot list" of objects that may need to be garbage
            ///     collected.
            /// </devdoc>
            public static IntPtr Add(IntPtr handle, int type) {
                handleTypes[type - 1].Add(handle);
                return handle;
            }


            public static event HandleChangeEventHandler HandleAdded {
                add {
                    handleAdd += value;
                }
                remove {
                    handleAdd -= value;
                }
            }


            public static event HandleChangeEventHandler HandleRemoved {
                add {
                    handleRemove += value;
                }
                remove {
                    handleRemove -= value;
                }
            }

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.RegisterType"]/*' />
            /// <devdoc>
            ///     Registers a new type of handle with the handle collector.
            /// </devdoc>
            public static int RegisterType(string typeName, int expense, int initialThreshold) {
                lock(typeof(HandleCollector)) {
                    if (handleTypeCount == 0 || handleTypeCount == handleTypes.Length) {
                        HandleType[] newTypes = new HandleType[handleTypeCount + 10];
                        if (handleTypes != null) {
                            Array.Copy(handleTypes, 0, newTypes, 0, handleTypeCount);
                        }
                        handleTypes = newTypes;
                    }

                    handleTypes[handleTypeCount++] = new HandleType(typeName, expense, initialThreshold);
                    return handleTypeCount;
                }
            }

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Remove"]/*' />
            /// <devdoc>
            ///     Removes the given handle from the handle collector.  Removing a
            ///     handle removes it from our "hot list" of objects that should be
            ///     frequently garbage collected.
            /// </devdoc>
            public static IntPtr Remove(IntPtr handle, int type) {
                return handleTypes[type - 1].Remove(handle);
            }

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType"]/*' />
            /// <devdoc>
            ///     Represents a specific type of handle.
            /// </devdoc>
            private class HandleType {
                public readonly string name;

                private int threshHold;
                private int handleCount;
                private readonly int deltaPercent;

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.HandleType"]/*' />
                /// <devdoc>
                ///     Creates a new handle type.
                /// </devdoc>
                public HandleType(string name, int expense, int initialThreshold) {
                    this.name = name;
                    this.threshHold = initialThreshold;
                    this.handleCount = 0;
                    this.deltaPercent = 100 - expense;
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Add"]/*' />
                /// <devdoc>
                ///     Adds a handle to this handle type for monitoring.
                /// </devdoc>
                public void Add(IntPtr handle) {
                    lock(this) {
                        handleCount++;
                        if (NeedCollection()) {
        #if DEBUG_HANDLECOLLECTOR
                            Debug.WriteLine("HC> Forcing garbage collection");
                            Debug.WriteLine("HC>     name        :" + name);
                            Debug.WriteLine("HC>     threshHold  :" + (threshHold).ToString());
                            Debug.WriteLine("HC>     handleCount :" + (handleCount).ToString());
                            Debug.WriteLine("HC>     deltaPercent:" + (deltaPercent).ToString());
        #endif
                            GC.Collect();
                            Collected();
                        }

                        if (HandleCollector.handleAdd != null) {
                            HandleCollector.handleAdd(name, handle, GetHandleCount());
                        }
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Collected"]/*' />
                /// <devdoc>
                ///     Called after the collector has finished it's work.  Here,
                ///     we look at the number of objects currently outstanding
                ///     and establish a new cleanup threshhold.
                /// </devdoc>
                public void Collected() {
                    lock(this) {
                        threshHold = handleCount + ((handleCount * deltaPercent) / 100);
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.GetHandleCount"]/*' />
                /// <devdoc>
                ///     Retrieves the outstanding handle count for this
                ///     handle type.
                /// </devdoc>
                public int GetHandleCount() {
                    lock(this) {
                        return handleCount;
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.NeedCollection"]/*' />
                /// <devdoc>
                ///     Determines if this handle type needs a GC pass.
                /// </devdoc>
                public  bool NeedCollection() {
                    lock(this) {
                        return handleCount > threshHold;
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Remove"]/*' />
                /// <devdoc>
                ///     Removes the given handle from our monitor list.
                /// </devdoc>
                public IntPtr Remove(IntPtr handle) {
                    lock(this) {
                        handleCount--;
                        if (HandleCollector.handleRemove != null) {
                            HandleCollector.handleRemove(name, handle, GetHandleCount());
                        }
                        return handle;
                    }
                }
            }
        }
        
    [ComVisible(true), ComImport(), Guid("00000112-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IOleObject {

        [PreserveSig]
         int SetClientSite(
                [In, MarshalAs(UnmanagedType.Interface)]
                  IOleClientSite pClientSite);

        [PreserveSig]
          int GetClientSite(out IOleClientSite site);

        [PreserveSig]
         int SetHostNames(
                [In, MarshalAs(UnmanagedType.LPWStr)]
                  string szContainerApp,
                [In, MarshalAs(UnmanagedType.LPWStr)]
                  string szContainerObj);

        [PreserveSig]
         int Close(
                [In, MarshalAs(UnmanagedType.I4)]
                 int dwSaveOption);

        [PreserveSig]
         int SetMoniker(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwWhichMoniker,
                [In, MarshalAs(UnmanagedType.Interface)]
                  object pmk);

        [PreserveSig]
          int GetMoniker(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwAssign,
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwWhichMoniker,
                out object moniker);

        [PreserveSig]
         int InitFromData(
                [In, MarshalAs(UnmanagedType.Interface)]
                  IOleDataObject pDataObject,
                [In, MarshalAs(UnmanagedType.I4)]
                 int fCreation,
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwReserved);

        [PreserveSig]
          int GetClipboardData(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwReserved,
                out IOleDataObject data);

        [PreserveSig]
         int DoVerb(
                [In, MarshalAs(UnmanagedType.I4)]
                 int iVerb,
                [In]
                 IntPtr lpmsg,
                [In, MarshalAs(UnmanagedType.Interface)]
                  IOleClientSite pActiveSite,
                [In, MarshalAs(UnmanagedType.I4)]
                 int lindex,
                 IntPtr hwndParent,
                [In]
                 COMRECT lprcPosRect);

        [PreserveSig]
          int EnumVerbs([MarshalAs(UnmanagedType.Interface)] out object e);

        [PreserveSig]
         int OleUpdate();

        [PreserveSig]
         int IsUpToDate();

        [PreserveSig]
         int GetUserClassID(
                [In, Out]
                  ref Guid pClsid);

        [PreserveSig]
          int GetUserType(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwFormOfType,
                [Out, MarshalAs(UnmanagedType.LPWStr)]
                out string userType);

        [PreserveSig]
         int SetExtent(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwDrawAspect,
                  IntPtr pSizel);

        [PreserveSig]
         int GetExtent(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwDrawAspect,
                [Out]
                  IntPtr pSizel);

        [PreserveSig]
         int Advise(
                [In, MarshalAs(UnmanagedType.Interface)]
                  object pAdvSink,
                out int cookie);

        [PreserveSig]
         int Unadvise(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwConnection);

        [PreserveSig]
          int EnumAdvise([MarshalAs(UnmanagedType.Interface)] out object e);

        [PreserveSig]
         int GetMiscStatus(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwAspect,
                out int misc);

        [PreserveSig]
         int SetColorScheme(
                  IntPtr pLogpal);


    }
    
         [ComVisible(true), Guid("0000011B-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IOleContainer {

    	
    	 void ParseDisplayName(
    		[In, MarshalAs(UnmanagedType.Interface)] 
    		  object pbc,
    		[In, MarshalAs(UnmanagedType.BStr)] 
    		  string pszDisplayName,
    		[Out, MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pchEaten,
    		[Out, MarshalAs(UnmanagedType.LPArray)] 
    		   Object[] ppmkOut);

    	
    	 void EnumObjects(
    		[In, MarshalAs(UnmanagedType.U4)] 
    		 int grfFlags,
    		[MarshalAs(UnmanagedType.Interface)]
    		   out object ppenum);

    	
    	 void LockContainer(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int fLock);

    }


        [ComVisible(true), Guid("00000118-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleClientSite {

             void SaveObject();

            [return: MarshalAs(UnmanagedType.Interface)]
              object GetMoniker(
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int dwAssign,
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int dwWhichMoniker);

            [PreserveSig]
              int GetContainer(
                    [Out]
                       out IOleContainer ppContainer);

            
             void ShowObject();

            
             void OnShowWindow(
                    [In, MarshalAs(UnmanagedType.I4)] 
                     int fShow);

            
             void RequestNewObjectLayout();


        }


        public static int SignedHIWORD(int n) {
            return (int)(short)((n >> 16) & 0xffff);
        }

        public static int SignedLOWORD(int n) {
            return (int)(short)(n & 0xFFFF);
        }


        public delegate void HandleChangeEventHandler(string handleType, IntPtr handleValue, int currentHandleCount);
        
        
        public class StreamConsts {
            public const   int LOCK_WRITE = 0x1;
            public const   int LOCK_EXCLUSIVE = 0x2;
            public const   int LOCK_ONLYONCE = 0x4;
            public const   int STATFLAG_DEFAULT = 0x0;
            public const   int STATFLAG_NONAME = 0x1;
            public const   int STATFLAG_NOOPEN = 0x2;
            public const   int STGC_DEFAULT = 0x0;
            public const   int STGC_OVERWRITE = 0x1;
            public const   int STGC_ONLYIFCURRENT = 0x2;
            public const   int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 0x4;
            public const   int STREAM_SEEK_SET = 0x0;
            public const   int STREAM_SEEK_CUR = 0x1;
            public const   int STREAM_SEEK_END = 0x2;
        }
        [StructLayout(LayoutKind.Sequential)]
        public class NMTVCUSTOMDRAW
        {
            public NMCUSTOMDRAW    nmcd;
            public int clrText;
            public int clrTextBk;
            public int iLevel;
        }
        [StructLayout(LayoutKind.Sequential)]
        public class NMCUSTOMDRAW {
            public NMHDR    nmcd;
            public int      dwDrawStage;
            public IntPtr   hdc;
            public RECT     rc;
            public int      dwItemSpec;
            public int      uItemState;
            public IntPtr   lItemlParam;
        }
        [StructLayout(LayoutKind.Sequential)]
        public class NMHDR
        {
            public IntPtr hwndFrom;
            public int idFrom;
            public int code;
        }

        /**
         * @security(checkClassLinking=on)
         */
        // C#r: noAutoOffset
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagDISPPARAMS
        {
          [MarshalAs(UnmanagedType.I4)/*leftover(offset=0, rgvarg)*/]
          public int rgvarg;
                
                /*[MarshalAs(UnmanagedType.ByValArray, SizeConst=1)/*leftover(offset=4, rgdispidNamedArgs)]*/
          
          [MarshalAs(UnmanagedType.I4)]
          public int rgdispidNamedArgs;
    
          [MarshalAs(UnmanagedType.U4)/*leftover(offset=8, cArgs)*/]
          public int cArgs;
    
          [MarshalAs(UnmanagedType.U4)/*leftover(offset=12, cNamedArgs)*/]
          public int cNamedArgs;
    
        }
        
        [StructLayout(LayoutKind.Sequential)]
	    public class tagEXCEPINFO {
            [MarshalAs(UnmanagedType.U2)]
            public short wCode;
            [MarshalAs(UnmanagedType.U2)]
            public short wReserved;
            [MarshalAs(UnmanagedType.BStr)]
            public string bstrSource;
            [MarshalAs(UnmanagedType.BStr)]
            public string bstrDescription;
            [MarshalAs(UnmanagedType.BStr)]
            public string bstrHelpFile;
            [MarshalAs(UnmanagedType.U4)]
            public int dwHelpContext;
            [MarshalAs(UnmanagedType.U4)]
            public int pvReserved;
            [MarshalAs(UnmanagedType.U4)]
            public int pfnDeferredFillIn;
            [MarshalAs(UnmanagedType.U4)]
            public int scode;
    	}

        /// <devdoc>
        ///     This method takes a file URL and converts it to an absolute path.  The trick here is that
        ///     if there is a '#' in the path, everything after this is treated as a fragment.  So
        ///     we need to append the fragment to the end of the path.
        /// </devdoc>
        internal static string GetAbsolutePath(string fileName) {
            System.Diagnostics.Debug.Assert(fileName != null && fileName.Length > 0, "Cannot get absolute path, fileName is not valid");

            Uri uri = new Uri(fileName, true);
            return uri.LocalPath + uri.Fragment;
        }

        /// <devdoc>
        ///     This method takes a file URL and converts it to a local path.  The trick here is that
        ///     if there is a '#' in the path, everything after this is treated as a fragment.  So
        ///     we need to append the fragment to the end of the path.
        /// </devdoc>
        internal static string GetLocalPath(string fileName) {
            System.Diagnostics.Debug.Assert(fileName != null && fileName.Length > 0, "Cannot get local path, fileName is not valid");

            Uri uri = new Uri(fileName, true);
            return uri.LocalPath + uri.Fragment;
        }
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\advancedpropertyeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedPropertyEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AdvancedPropertyEditor.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.Serialization.Formatters;    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\AdvancedPropertyEditor.uex' path='docs/doc[@for="AdvancedPropertyEditor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class AdvancedPropertyEditor : UITypeEditor {

        /// <include file='doc\AdvancedPropertyEditor.uex' path='docs/doc[@for="AdvancedPropertyEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

        /// <include file='doc\AdvancedPropertyEditor.uex' path='docs/doc[@for="AdvancedPropertyEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            ComponentSettings compSettings = ((AdvancedPropertyDescriptor) value).ComponentSettings;
            IComponent component = compSettings.Component;

            // make sure it's OK to change
            IComponentChangeService changeService = null;
            if (component.Site != null)
                changeService = (IComponentChangeService) component.Site.GetService(typeof(IComponentChangeService));
            if (changeService != null) {
                try {
                    changeService.OnComponentChanging(component, (PropertyDescriptor) value);
                }
                catch (CheckoutException e) {
                    if (e == CheckoutException.Canceled) {
                            return value;
                    }
                    throw e;
                }
            }

            IWindowsFormsEditorService editorSvc = (IWindowsFormsEditorService) provider.GetService(typeof(IWindowsFormsEditorService));
            Debug.Assert(editorSvc != null, "Couldn't get IWindowsFormsEditorService");
            if (editorSvc != null) {
                try {
                    using (AdvancedPropertyDialog dlg = new AdvancedPropertyDialog(component)) {
                        DialogResult result = editorSvc.ShowDialog(dlg);
                        if (result == DialogResult.OK) {
                            bool changeMade = false;
                            PropertyBindingCollection newBindings = dlg.Bindings;
                            ManagedPropertiesService svc = (ManagedPropertiesService) context.GetService(typeof(ManagedPropertiesService));
                            Debug.Assert(svc != null, "Couldn't get ManagedPropertiesService");
                            if (svc != null) {
                                for (int i = 0; i < newBindings.Count; i++) {                        
                                    svc.EnsureKey(newBindings[i]);
                                    PropertyBinding oldBinding = svc.Bindings[component, newBindings[i].Property];
                                    if (oldBinding == null) {
                                        if (newBindings[i].Bound) {
                                            changeMade = true;
                                        }
                                    }
                                    else if ((oldBinding.Bound != newBindings[i].Bound) || (oldBinding.Key != newBindings[i].Key)) {
                                        changeMade = true;
                                    }
                                    svc.Bindings[component, newBindings[i].Property] = newBindings[i];
                                }
                                svc.MakeDirty();                                        
        
                                if (changeMade) {
                                    TypeDescriptor.Refresh(compSettings.Component);
                                    if (changeService != null) {
                                        changeService.OnComponentChanged(compSettings.Component, null, null, null);                                            
                                    }
                                    try {
                                        svc.WriteConfigFile();
                                    } 
                                    catch {
                                    }
                                }

                                // this fools the properties window into thinking we changed the value, so it refreshes
                                // the owner object.                        
                                object retval = new AdvancedPropertyDescriptor(compSettings);                                                                 
                                return retval;
                            }
                        }
                    }
                }
                catch (Exception e) {
                    System.Windows.Forms.MessageBox.Show(e.Message, SR.GetString(SR.ConfigConfiguredProperties));
                }
            }
            
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\advancedpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AdvancedPropertyDescriptor.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.Serialization.Formatters;    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Editor(typeof(AdvancedPropertyEditor), typeof(UITypeEditor)),
    TypeConverterAttribute(typeof(AdvancedPropertyConverter))
    ]
    public class AdvancedPropertyDescriptor : PropertyDescriptor {

        private ComponentSettings compSettings;

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.AdvancedPropertyDescriptor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AdvancedPropertyDescriptor(ComponentSettings settings) : base(SR.GetString(SR.ConfigAdvanced), 
                                                                                                    new Attribute[] {RefreshPropertiesAttribute.All, 
                                                                                                                            new SRDescriptionAttribute(SR.ConfigAdvancedDesc)}) {
            this.compSettings = settings;
                        
        }            
            
        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.ComponentSettings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ComponentSettings ComponentSettings {
            get {
                return compSettings;
            }
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(ComponentSettings);
            }
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return typeof(AdvancedPropertyDescriptor);
            }
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool CanResetValue(object value) {
            return false;
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void ResetValue(object component) {
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object value) {
            return false;
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetValue(object component) {
            return this;
        }

        /// <include file='doc\AdvancedPropertyDescriptor.uex' path='docs/doc[@for="AdvancedPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\advancedpropertydialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedPropertyDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 2000, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Collections;
    using System.Windows.Forms;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using Microsoft.VisualStudio.Designer;
    
    /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog"]/*' />
    /// <devdoc>
    /// This dialog lets the user bind components' properties to values in
    /// the application settings file.
    /// </devdoc>
    public class AdvancedPropertyDialog : Form {
        private static readonly string HELP_KEYWORD = "VS.PropertyBrowser.DynamicProperties.Advanced";
        
        private System.Windows.Forms.Button okButton;
        
        private System.Windows.Forms.CheckedListBox propertiesList;
        
        private System.Windows.Forms.Label keyLabel;
        
        private System.Windows.Forms.Button cancelButton;
        
        private System.Windows.Forms.Label explanationLabel;
        
        private System.Windows.Forms.Button helpButton;
        
        private System.Windows.Forms.ComboBox keyCombo;
        
        private System.Windows.Forms.Label propertiesLabel;
                
        private PropertyBindingCollection bindings;        
        private IDesignerHost host;
        private IComponent component;        
        
        /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog.AdvancedPropertyDialog"]/*' />
        /// <devdoc>
        /// Creates a new dialog to let the user edit dynamic property bindings.
        /// The bindings parameter must have all possible bindings in it for the
        /// components and their properties, even if none are bound. For unbound
        /// properties, the key property on the binding should be
        /// initialized to its suggested (default) values.
        /// </devdoc>
        public AdvancedPropertyDialog(IComponent component) {
            this.host = (IDesignerHost) component.Site.GetService(typeof(IDesignerHost));
            this.component = component;

            Debug.Assert(host != null, "no IDesignerHost");
            if (host == null) {
                throw new Exception(SR.GetString(SR.ServiceCantGetIDesignerHost));
            }

            CreateBindings();
            this.InitializeComponent();
            FillPropertiesList();
        }
        
        /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog.Bindings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBindingCollection Bindings {
            get {
                return bindings;
            }
        }

        /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog.Component"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IComponent Component {
            get {
                return component;
            }
            set {
                component = value;
            }
        }    

        private void CreateBindings() {
            bindings = new PropertyBindingCollection();
            ManagedPropertiesService svc = (ManagedPropertiesService) component.Site.GetService(typeof(ManagedPropertiesService));
            if (svc != null) {
                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(component, new Attribute[] {BrowsableAttribute.Yes});
                for (int i = 0; i < properties.Count; i++) {
                    PropertyDescriptor prop = properties[i];
                    
                    if (prop.DesignTimeOnly)
                        continue;
                    if (prop.IsReadOnly)
                        continue;
                    if (prop.Attributes.Contains(DesignerSerializationVisibilityAttribute.Hidden))
                        continue;
                    // don't show the ComponentSettings property - it can't be managed!
                    if (prop.PropertyType == typeof(ComponentSettings))
                        continue;
                    if (!ManagedPropertiesService.IsTypeSupported(prop.PropertyType))
                        continue;
    
                    PropertyBinding binding = svc.Bindings[component, prop];
                    if (binding == null) {
                        binding = new PropertyBinding(host);
                        binding.Component = component;
                        binding.Property = prop;
                        binding.Reset();
                    }
                    else {
                        binding = (PropertyBinding)binding.Clone();
                    }
                    bindings.Add(binding);
                }
            }
        }

        /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog.FillPropertiesList"]/*' />
        /// <devdoc>
        /// Fills the Properties listbox with the properties on the currently selected component.
        /// </devdoc>
        private void FillPropertiesList() {
            propertiesList.Items.Clear();
            foreach (PropertyBinding binding in Bindings) {                
                ((CheckedListBox.ObjectCollection) propertiesList.Items).Add(new BindingData(binding), binding.Bound);
            }
            propertiesList.Sorted = true;                                        
        }
        
        
        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(AdvancedPropertyDialog));
            this.okButton = new System.Windows.Forms.Button();
            this.propertiesList = new System.Windows.Forms.CheckedListBox();
            this.keyLabel = new System.Windows.Forms.Label();
            this.cancelButton = new System.Windows.Forms.Button();
            this.explanationLabel = new System.Windows.Forms.Label();
            this.helpButton = new System.Windows.Forms.Button();
            this.keyCombo = new System.Windows.Forms.ComboBox();
            this.propertiesLabel = new System.Windows.Forms.Label();
            this.okButton.Location = ((System.Drawing.Point)(resources.GetObject("okButton.Location")));
            this.okButton.Name = "okButton";
            this.okButton.Size = ((System.Drawing.Size)(resources.GetObject("okButton.Size")));
            this.okButton.TabIndex = ((int)(resources.GetObject("okButton.TabIndex")));
            this.okButton.Text = resources.GetString("okButton.Text");
            this.okButton.DialogResult = DialogResult.OK;
            this.propertiesList.Location = ((System.Drawing.Point)(resources.GetObject("propertiesList.Location")));
            this.propertiesList.Name = "propertiesList";
            this.propertiesList.Size = ((System.Drawing.Size)(resources.GetObject("propertiesList.Size")));
            this.propertiesList.TabIndex = ((int)(resources.GetObject("propertiesList.TabIndex")));
            this.propertiesList.ThreeDCheckBoxes = true;
            this.propertiesList.CheckOnClick = true;
            this.propertiesList.SelectedIndexChanged += new System.EventHandler(this.OnNewPropertySelected);
            this.propertiesList.ItemCheck += new ItemCheckEventHandler(OnPropertyCheck);
            this.keyLabel.AutoSize = ((bool)(resources.GetObject("keyLabel.AutoSize")));
            this.keyLabel.Location = ((System.Drawing.Point)(resources.GetObject("keyLabel.Location")));
            this.keyLabel.Name = "keyLabel";
            this.keyLabel.Size = ((System.Drawing.Size)(resources.GetObject("keyLabel.Size")));
            this.keyLabel.TabIndex = ((int)(resources.GetObject("keyLabel.TabIndex")));
            this.keyLabel.Text = resources.GetString("keyLabel.Text");
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = ((System.Drawing.Point)(resources.GetObject("cancelButton.Location")));
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = ((System.Drawing.Size)(resources.GetObject("cancelButton.Size")));
            this.cancelButton.TabIndex = ((int)(resources.GetObject("cancelButton.TabIndex")));
            this.cancelButton.Text = resources.GetString("cancelButton.Text");
            this.cancelButton.DialogResult = DialogResult.Cancel;
            this.explanationLabel.Location = ((System.Drawing.Point)(resources.GetObject("explanationLabel.Location")));
            this.explanationLabel.Name = "explanationLabel";
            this.explanationLabel.Size = ((System.Drawing.Size)(resources.GetObject("explanationLabel.Size")));
            this.explanationLabel.TabIndex = ((int)(resources.GetObject("explanationLabel.TabIndex")));
            this.explanationLabel.Text = resources.GetString("explanationLabel.Text");
            this.helpButton.Location = ((System.Drawing.Point)(resources.GetObject("helpButton.Location")));
            this.helpButton.Name = "helpButton";
            this.helpButton.Size = ((System.Drawing.Size)(resources.GetObject("helpButton.Size")));
            this.helpButton.TabIndex = ((int)(resources.GetObject("helpButton.TabIndex")));
            this.helpButton.Text = resources.GetString("helpButton.Text");
            this.helpButton.Click += new EventHandler(this.OnClickHelpButton);   
            this.keyCombo.DropDownWidth = 216;
            this.keyCombo.Location = ((System.Drawing.Point)(resources.GetObject("keyCombo.Location")));
            this.keyCombo.Name = "keyCombo";
            this.keyCombo.Size = ((System.Drawing.Size)(resources.GetObject("keyCombo.Size")));
            this.keyCombo.TabIndex = ((int)(resources.GetObject("keyCombo.TabIndex")));
            this.keyCombo.Sorted = true;                        
            this.keyCombo.LostFocus += new EventHandler(OnKeyLostFocus);
            this.propertiesLabel.AutoSize = ((bool)(resources.GetObject("propertiesLabel.AutoSize")));
            this.propertiesLabel.Location = ((System.Drawing.Point)(resources.GetObject("propertiesLabel.Location")));
            this.propertiesLabel.Name = "propertiesLabel";
            this.propertiesLabel.Size = ((System.Drawing.Size)(resources.GetObject("propertiesLabel.Size")));
            this.propertiesLabel.TabIndex = ((int)(resources.GetObject("propertiesLabel.TabIndex")));
            this.propertiesLabel.Text = resources.GetString("propertiesLabel.Text");
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            this.AcceptButton = this.okButton;
            this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));            
            this.CancelButton = this.cancelButton;
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));                        
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this.keyCombo,
                        this.helpButton,
                        this.cancelButton,
                        this.okButton,
                        this.propertiesList,
                        this.keyLabel,
                        this.propertiesLabel,
                        this.explanationLabel});
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "Win32Form1";
            this.ShowInTaskbar = false;
            this.StartPosition = FormStartPosition.CenterParent;
            this.Text = String.Format(resources.GetString("$this.Text"), component.Site.Name);
            this.Closing += new System.ComponentModel.CancelEventHandler(this.OnClosing);
            this.Load += new System.EventHandler(this.OnLoad);
            this.Icon = null;
        }
                        
        private void OnKeyLostFocus(object sender, EventArgs e) {            
            if (propertiesList.SelectedItem != null) {
                BindingData bindingData = (BindingData) propertiesList.SelectedItem;
                bindingData.Key = keyCombo.Text;
            }                
        }

        private void OnClosing(object sender, CancelEventArgs e) {              
            if (this.DialogResult == DialogResult.Cancel)
                return;

            if (propertiesList.SelectedItem != null)
                ((BindingData) propertiesList.SelectedItem).Key = keyCombo.Text;
                 
            foreach (BindingData bindingData in propertiesList.Items) {                
                if (bindingData != null) {
                    bindingData.Value.Key = bindingData.Key;
                    bindingData.Value.Bound = bindingData.Bound;
                }
            }
        }

        private void OnHelpRequested(object sender, HelpEventArgs e) {
            OnClickHelpButton(null, null);
        }
        
        private void OnClickHelpButton(object source, EventArgs e) {            
            IHelpService helpService = (IHelpService)this.component.Site.GetService(typeof(IHelpService));
            if (helpService != null) {
                helpService.ShowHelpFromKeyword(HELP_KEYWORD);
            }
        }

        private void OnLoad(object source, EventArgs e) {                
            SelectFirstItem();
        }

        private void OnPropertyCheck(object sender, ItemCheckEventArgs e) {
            bool isChecked = (e.NewValue != CheckState.Unchecked);
            BindingData bindingData = (BindingData)propertiesList.Items[e.Index];
            keyCombo.Text = bindingData.Key;
            keyCombo.Enabled = bindingData.Bound = isChecked;            
        }        

        /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog.OnNewPropertySelected"]/*' />
        /// <devdoc>
        /// Called when the user selects a new property in the listbox.
        /// </devdoc>
        private void OnNewPropertySelected(object sender, EventArgs e) {
            int index = propertiesList.SelectedIndex;                    
            if (index == -1) {
                keyCombo.Items.Clear();
                keyCombo.Text = "";
                keyCombo.Enabled = false;
                return;
            }

            keyCombo.Items.Clear();
            BindingData bindingData = (BindingData)propertiesList.SelectedItem;

            ManagedPropertiesService mpService = (ManagedPropertiesService) host.GetService(typeof(ManagedPropertiesService));
            if (mpService != null) {
                keyCombo.Items.Clear();
                keyCombo.Items.AddRange(mpService.GetKeysForType(bindingData.Value.Property.PropertyType));
            }            

            keyCombo.Text = bindingData.Key;
            keyCombo.Enabled = bindingData.Bound;            
        }

        /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog.SaveSelectedProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SaveSelectedProperties() {
            PropertyBindingCollection newBindings = Bindings;
            ManagedPropertiesService svc = (ManagedPropertiesService) component.Site.GetService(typeof(ManagedPropertiesService));
            if (svc != null) {
                for (int i = 0; i < newBindings.Count; i++) {
                    svc.EnsureKey(newBindings[i]);
                    svc.Bindings[component, newBindings[i].Property] = newBindings[i];
                }
                svc.MakeDirty();
            }                
            
            TypeDescriptor.Refresh(component);
            // now announce that it's changed
            IComponentChangeService changeService = (IComponentChangeService) component.Site.GetService(typeof(IComponentChangeService));
            if (changeService != null) 
                changeService.OnComponentChanged(component, null, null, null);
                    
        }                  
                  
        /// <include file='doc\AdvancedPropertyDialog.uex' path='docs/doc[@for="AdvancedPropertyDialog.SelectAllProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SelectAllProperties() {
            for (int index = 0; index < propertiesList.Items.Count; ++ index) {
                propertiesList.SelectedIndex = index;
                Application.DoEvents();
                propertiesList.SetItemChecked(index, true);
                BindingData bindingData = (BindingData)propertiesList.Items[index];
                keyCombo.Text = bindingData.Key;
                bindingData.Bound = true;
                keyCombo.Enabled = true;            
                Application.DoEvents();
            } 
        }                 
        
        private void SelectFirstItem() {
            if (propertiesList.Items.Count > 0)
                propertiesList.SelectedIndex = 0;                             
            else                                
                OnNewPropertySelected(null, EventArgs.Empty);                                                    
        }
         
        class BindingData {
            public string Name;            
            public PropertyBinding Value;
            public string Key;
            public bool Bound;

            public BindingData(PropertyBinding binding) {                
                this.Name = binding.Property.Name;                
                this.Key = binding.Key;
                this.Bound = binding.Bound;
                this.Value = binding;                
            }

            public override string ToString() {
                return Name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\componentsettings.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentSettings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Configuration;
    using System.ComponentModel.Design;    

    /// <include file='doc\ComponentSettings.uex' path='docs/doc[@for="ComponentSettings"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [TypeConverterAttribute(typeof(ComponentSettingsConverter))
    ]
    public class ComponentSettings {
        private IComponent component;
        private ManagedPropertiesService service;

        /// <include file='doc\ComponentSettings.uex' path='docs/doc[@for="ComponentSettings.ComponentSettings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ComponentSettings(IComponent component, ManagedPropertiesService service) {
            this.component = component;
            this.service = service;
        }

        /// <include file='doc\ComponentSettings.uex' path='docs/doc[@for="ComponentSettings.Service"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ManagedPropertiesService Service {
            get {
                return service;
            }
        }
        
        /// <include file='doc\ComponentSettings.uex' path='docs/doc[@for="ComponentSettings.Bindings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBindingCollection Bindings {
            get {
                return service.Bindings;
            }
        }

        /// <include file='doc\ComponentSettings.uex' path='docs/doc[@for="ComponentSettings.Component"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IComponent Component {
            get {
                return component;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\bindingpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindingPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   BindingPropertyDescriptor.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.Serialization.Formatters;    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;

    /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class BindingPropertyDescriptor : PropertyDescriptor {

        private ComponentSettings compSettings;
        private PropertyDescriptor property;
        private IDesignerHost host;
        
        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.BindingPropertyDescriptor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public BindingPropertyDescriptor(ComponentSettings settings, PropertyDescriptor prop) : base(prop.Name, new Attribute[] { RefreshPropertiesAttribute.All }) {
            this.compSettings = settings;
            this.property = prop;
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(ComponentSettings);
            }
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return typeof(PropertyBinding);
            }
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool CanResetValue(object value) {
            return true;
        }

        private IDesignerHost GetHost() {
            if (host == null)
                host = (IDesignerHost) compSettings.Component.Site.GetService(typeof(IDesignerHost));
            return host;
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetValue(object component) {
            PropertyBinding binding = compSettings.Bindings[compSettings.Component, property];
            if (binding == null) {
                // this will only happen if the property was "recommended" but it had never
                // been bound.
                binding = new PropertyBinding(GetHost());
                binding.Component = compSettings.Component;
                binding.Property = property;
                binding.Reset();
                compSettings.Bindings[compSettings.Component, property] = binding;
            }
            return binding;
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void ResetValue(object component) {
            PropertyBinding binding = (PropertyBinding) GetValue(component);
            binding.Reset();
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SetValue(object component, object newBinding) {
            // Debug.Assert(compSettings == component, "I don't get it - component is a " + component.GetType().FullName);
            Debug.Assert(newBinding is PropertyBinding || newBinding is string, "I still don't get it " + newBinding.GetType().FullName + " " + newBinding.ToString());            

            // make sure it's OK to change property.
            IComponentChangeService svc = null;
            if (compSettings.Component.Site != null)
                svc = (IComponentChangeService) compSettings.Component.Site.GetService(typeof(IComponentChangeService));
            if (svc != null) {
                try {
                    svc.OnComponentChanging(compSettings.Component, this);
                }
                catch (CheckoutException e) {
                    if (e == CheckoutException.Canceled)
                        return;
                    throw e;
                }   
            }

            PropertyBinding binding;
            
            if (newBinding is PropertyBinding) {
                binding = (PropertyBinding) newBinding;
            }
            else {
                binding = new PropertyBinding((PropertyBinding) GetValue(component));
                binding.Host = GetHost();                                    
                if (newBinding == (object)PropertyBinding.None) 
                    binding.Bound = false;
                else {                    
                    binding.Bound = true;
                    binding.Enabled = false;   // this will be set to true in EnsureKey if appropriate
                    binding.Key = (string)newBinding;                      
                }
            }

            compSettings.Bindings[compSettings.Component, property] = binding;
            //  if the key doesn't exist, use this property's value to set it.
            compSettings.Service.EnsureKey(binding);                                    
            compSettings.Service.MakeDirty();
            compSettings.Service.WriteConfigFile();
                                                                                                                                  
            // now announce that it's changed
            TypeDescriptor.Refresh(compSettings.Component);
            if (svc != null)                                     
                svc.OnComponentChanged(compSettings.Component, null, null, null);               
                
            OnValueChanged(component, EventArgs.Empty);
        }

        /// <include file='doc\BindingPropertyDescriptor.uex' path='docs/doc[@for="BindingPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object value) {
            return false;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\designersettingsstore.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerSettingsStore.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Configuration {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.IO;
    using System.Xml;
    using Microsoft.VisualStudio.Designer;
    using System.Globalization;
    
    /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class DesignerSettingsStore {                  
        private Hashtable values;
        private IServiceProvider provider;
        private static string NullString = "None";

        /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore.DesignerSettingsStore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DesignerSettingsStore(IServiceProvider provider) {
            this.provider = provider;
        }   

        private int GetNoneNesting(string val) {
            int count = 0;
            int len = val.Length;
            if (len > 1) {
                while (val[count] == '(' && val[len - count - 1] == ')') {
                    count++;
                }
                if (count > 0 && string.Compare(NullString, 0, val, count, len - 2 * count, false, CultureInfo.InvariantCulture) != 0) {
                    // the stuff between the parens is not "None"
                    count = 0;
                }
            }
            return count;
        }

        
        /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore.GetValue"]/*' />
        /// <devdoc>
        /// Retrieves a value from the data store, identified by the given key
        /// </devdoc>
        public virtual object GetValue(string key) {
            return values[key];
        }

        /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore.LoadData"]/*' />
        /// <devdoc>
        /// Called once before loading or saving a code file to allow the DesignerSettingsStore
        /// to cache data from its permanent storage location.
        /// </devdoc>
        public virtual void LoadData() {
            values = new Hashtable();
            IConfigurationService configurationService = (IConfigurationService)provider.GetService(typeof(IConfigurationService));
            // if (configurationService == null) ...
            TextReader xmlReader = configurationService.GetConfigurationReader();                 
            if (xmlReader != null) {                                               
                try {                                                                         
                    XmlDocument doc = new XmlDocument();                
                    doc.Load(xmlReader);
                
                    // check for <configuration>
                    XmlElement docElement = doc.DocumentElement;
                    if (docElement == null || docElement.Name != "configuration")
                        throw new Exception(SR.GetString(SR.ConfigMissingRoot));
                                    
                    XmlNodeList list = docElement.GetElementsByTagName("appSettings");
                    if (list.Count != 0) {
                        XmlElement userapplicationElement = (XmlElement)list[0];                                                         
                        foreach (XmlNode valueNode in userapplicationElement.ChildNodes) {                        
                            XmlElement element = valueNode as XmlElement;
                            if (element != null) {                    
                                if (element.Name == "add") {
                                    if (element.HasAttribute("key")) {
                                        string key = element.GetAttribute("key");
    
                                        if (element.HasAttribute("value")) {
                                            string value = element.GetAttribute("value");
                        
                                            int nesting = GetNoneNesting(value);
                                            if (nesting == 1) {
                                                values[key] = null;
                                            }
                                            else if (nesting > 1) {
                                                values[key] = value.Substring(1, value.Length - 2);
                                            }
                                            else {
                                                values[key] = value;
                                            }                                
                                        }
                                    }
                                }
                            }                
                        }                
                    }                    
                }    
                finally {                
                    xmlReader.Close();                
                }                     
            }     
        }        

        /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore.SaveData"]/*' />
        /// <devdoc>
        /// Called after persistence to indicate the designer settings store should save any
        /// cached data to the permanent storage. Any cache may also be released in this
        /// method, as ReleaseData will not be called.
        /// </devdoc>
        public virtual void SaveData() {                        
            XmlDocument doc = new XmlDocument();                             
            doc.PreserveWhitespace = true;
            TextReader xmlReader = null;
            TextWriter xmlWriter = null;
            
            try {
                IConfigurationService configurationService = (IConfigurationService)provider.GetService(typeof(IConfigurationService));
                // if (configurationService == null) ...
                xmlReader = configurationService.GetConfigurationReader();                 
                if (xmlReader == null) 
                    doc.LoadXml("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<configuration>\r\n</configuration>");
                else {
                    doc.Load(xmlReader);
                    xmlReader.Close();                
                    xmlReader = null;
                }                        
                                
                xmlWriter = configurationService.GetConfigurationWriter();
                XmlElement docElement = doc.DocumentElement;
                if (docElement == null || docElement.Name != "configuration")
                    throw new Exception(SR.GetString(SR.ConfigMissingRoot));
                                         
                XmlElement userapplicationElement = null; 
                XmlNodeList list = docElement.GetElementsByTagName("appSettings");
                Hashtable addedValues = new Hashtable();
                if (list.Count == 0) { 
                    // no appSettings section... create one
                    userapplicationElement = doc.CreateElement("appSettings");
                    
                    userapplicationElement.AppendChild(doc.CreateWhitespace("\r\n"));

                    userapplicationElement.AppendChild(doc.CreateWhitespace("\t\t"));
                    userapplicationElement.AppendChild(doc.CreateComment(SR.GetString(SR.ConfigUserAppComment1)));
                    userapplicationElement.AppendChild(doc.CreateWhitespace("\r\n"));

                    userapplicationElement.AppendChild(doc.CreateWhitespace("\t\t"));
                    userapplicationElement.AppendChild(doc.CreateComment(SR.GetString(SR.ConfigUserAppComment2)));                    
                    userapplicationElement.AppendChild(doc.CreateWhitespace("\r\n"));
                    
                    userapplicationElement.AppendChild(doc.CreateWhitespace("\t"));

                    docElement.AppendChild(doc.CreateWhitespace("\t"));
                    docElement.AppendChild(userapplicationElement);
                    docElement.AppendChild(doc.CreateWhitespace("\r\n"));                    
                }                    
                else {
                    userapplicationElement = (XmlElement)list[0];
                    foreach (XmlNode valueNode in userapplicationElement.ChildNodes) {                        
                        XmlElement element = valueNode as XmlElement;
                        if (element != null) {
                            if (element.Name == "add") {
                                if (element.HasAttribute("key")) {
                                    string key = element.GetAttribute("key");
                                    if (values.Contains(key)) {
                                         object value = values[key];
                                         if (value == null) {
                                             value = "(None)";
                                         }
                                         else if (GetNoneNesting(value.ToString()) > 0) {
                                             value = "(" + value.ToString() + ")";
                                         }
                                         element.SetAttribute("value", value.ToString());
                                         addedValues[key] = key;
                                    }
                                }
                            }
                        }                
                    }     
                }

                // If the appSettings section looks like
                //     <appSettings />
                // Then we change it to
                //     <appSettings>
                //     </appSettings>
                // so that the tab logic below works right.
                if (userapplicationElement.ChildNodes.Count == 0) {
                    userapplicationElement.AppendChild(doc.CreateWhitespace("\r\n\t"));
                }

                string[] keys = new string[values.Keys.Count];
                values.Keys.CopyTo(keys, 0);
                Array.Sort(keys, InvariantComparer.Default);
                for (int index = 0; index < keys.Length; ++index) {
                    if (!addedValues.Contains(keys[index])) {
                        XmlElement set = doc.CreateElement("add");
                        set.SetAttribute("key", keys[index]);
                        object value = values[keys[index]];
                        if (value == null) {
                            value = "(None)";
                        }
                        else if (GetNoneNesting(value.ToString()) > 0) {
                            value = "(" + value.ToString() + ")";
                        }
                        set.SetAttribute("value", value.ToString());
                        
                        userapplicationElement.AppendChild(doc.CreateWhitespace("\t"));
                        userapplicationElement.AppendChild(set);
                        userapplicationElement.AppendChild(doc.CreateWhitespace("\r\n\t"));
                    }
                }

                xmlWriter.Write(doc.OuterXml);
            }
            finally {
                if (xmlReader != null)
                    xmlReader.Close();            
                    
                if (xmlWriter != null)
                    xmlWriter.Close();            
            }                
        }

        /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore.SetValue"]/*' />
        /// <devdoc>
        /// Adds or changes a value in the store. valueType is used when creating a column
        /// in the database - it should be the type of the property being managed (since value
        /// may be a subclass of that type).
        /// </devdoc>
        public virtual void SetValue(string key, object value, Type valueType) {
            values[key] = value;
        }

        /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore.ValueExists"]/*' />
        /// <devdoc>
        /// Returns true if GetValue(key, value) will return a non-null value.
        /// </devdoc>
        public virtual bool ValueExists(string key) {
            return values.Contains(key);
        }

        /// <include file='doc\DesignerSettingsStore.uex' path='docs/doc[@for="DesignerSettingsStore.GetKeysAndValues"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual Hashtable GetKeysAndValues() {
            return values;
        }        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\iconfigurationservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IConfigurationService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Configuration {    
    using System.IO;
    
    /// <include file='doc\IConfigurationService.uex' path='docs/doc[@for="IConfigurationService"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides designers a way to  access the runtime configuration 
    ///          settings for the current design-time object.
    ///    </para> 
    /// </devdoc>
    internal interface IConfigurationService {
    
        /// <include file='doc\IConfigurationService.uex' path='docs/doc[@for="IConfigurationService.GetConfigurationReader"]/*' />
        /// <devdoc>
        ///     Locates the runtime configuration settings reader.  If there in no 
        ///     configuration file available this method will return null.
        /// </devdoc>       
        TextReader GetConfigurationReader();
        
        /// <include file='doc\IConfigurationService.uex' path='docs/doc[@for="IConfigurationService.GetConfigurationWriter"]/*' />
        /// <devdoc>
        ///     Locates the runtime configuration settings writer. A new configuration 
        ///     file  will be created if it doesn't exist yet.        
        /// </devdoc>        
        TextWriter GetConfigurationWriter();
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\componentsettingsconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentSettingsConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.Serialization.Formatters;    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    using System.Globalization;

    /// <include file='doc\ComponentSettingsConverter.uex' path='docs/doc[@for="ComponentSettingsConverter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ComponentSettingsConverter : TypeConverter {

        /// <include file='doc\ComponentSettingsConverter.uex' path='docs/doc[@for="ComponentSettingsConverter.ComponentSettingsConverter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ComponentSettingsConverter() : base() {
        }

        /// <include file='doc\ComponentSettingsConverter.uex' path='docs/doc[@for="ComponentSettingsConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string))
                return "";
            else
                return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\ComponentSettingsConverter.uex' path='docs/doc[@for="ComponentSettingsConverter.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            ComponentSettings compSettings = (ComponentSettings) value;
            PropertyBindingCollection bindings = compSettings.Bindings.GetBindingsForComponent(compSettings.Component);

            ArrayList props = new ArrayList();

            // go through all the properties on the component and see if they have the "show me" attribute.
            // also check to see if the propert has already been bound.
            IComponent component = compSettings.Component;
            IDesignerHost host = (IDesignerHost) component.Site.GetService(typeof(IDesignerHost));
            PropertyDescriptorCollection componentProps = TypeDescriptor.GetProperties(component);
            for (int i = 0; i < componentProps.Count; i++) {
                PropertyDescriptor prop = componentProps[i];
                if (!prop.IsReadOnly && ManagedPropertiesService.IsTypeSupported(prop.PropertyType)) {
                    bool recommended = ((RecommendedAsConfigurableAttribute) prop.Attributes[typeof(RecommendedAsConfigurableAttribute)]).RecommendedAsConfigurable;
                    PropertyBinding binding = bindings[component, prop];
                    if (recommended || (binding != null && binding.Bound)) {
                        props.Add(new BindingPropertyDescriptor(compSettings, prop));
                    }
                }
            }

            // add the (Advanced...) property
            props.Add(new AdvancedPropertyDescriptor(compSettings));

            PropertyDescriptor[] propsArray = new PropertyDescriptor[props.Count];
            for (int i = 0; i < props.Count; i++)
                propsArray[i] = (PropertyDescriptor) props[i];
            return new PropertyDescriptorCollection(propsArray);
        }

        /// <include file='doc\ComponentSettingsConverter.uex' path='docs/doc[@for="ComponentSettingsConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\installerdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallerDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Configuration {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Configuration.Install;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\InstallerDesigner.uex' path='docs/doc[@for="InstallerDesigner"]/*' />
    /// <devdoc>
    /// The designer for any class that extends Installer. All this does beyond
    /// CompositionDesigner's job is to add and remove components from the Installers
    /// collection on the base component.
    /// </devdoc>
    public class InstallerDesigner : ComponentDocumentDesigner {

        /// <include file='doc\InstallerDesigner.uex' path='docs/doc[@for="InstallerDesigner.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {

            if (disposing) {
                IComponentChangeService cs = (IComponentChangeService) GetService(typeof(IComponentChangeService));
                Debug.Assert(cs != null, "Couldn't get IComponentChangeService");
                if (cs != null) {
                    cs.ComponentAdding -= new ComponentEventHandler(OnComponentAdding);
                    cs.ComponentRemoved -= new ComponentEventHandler(OnComponentRemoved);
                }
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\InstallerDesigner.uex' path='docs/doc[@for="InstallerDesigner.Initialize"]/*' />
        /// <devdoc>
        /// Called to tell us a new main component is coming along.
        /// </devdoc>
        public override void Initialize(IComponent comp) {
            base.Initialize(comp);

            Debug.Assert(comp is Installer, "InstallerDesigner can only be a designer for Installers, but we got a " + comp.GetType().FullName);

            // add a couple event handlers that will let us know if when a component is added/removed.
            IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            Debug.Assert(cs != null, "Couldn't get IComponentChangeService");
            if (cs != null) {
                cs.ComponentAdding += new ComponentEventHandler(OnComponentAdding);
                cs.ComponentRemoved += new ComponentEventHandler(OnComponentRemoved);
            }
        }
        
        /// <include file='doc\InstallerDesigner.uex' path='docs/doc[@for="InstallerDesigner.OnComponentAdding"]/*' />
        /// <devdoc>
        /// Called whenever a component is added to the class.
        /// </devdoc>
        private void OnComponentAdding(object sender, ComponentEventArgs e) {
            // add the component to the Installers collection on the document.
            // only add if the designer is not loading - if it is, our persister
            // will parse the Installers.Add statement and call add to the collection.
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host == null || !host.Loading) {
                // we don't add if the added component _is_ the document component, or
                // if it's not an installer.
                if (e.Component != Component && e.Component is Installer) {
                    ((Installer) Component).Installers.Add((Installer) e.Component);
                }
            }
        }

        /// <include file='doc\InstallerDesigner.uex' path='docs/doc[@for="InstallerDesigner.OnComponentRemoved"]/*' />
        /// <devdoc>
        /// Called whenever a component is removed from the class
        /// </devdoc>
        private void OnComponentRemoved(object sender, ComponentEventArgs e) {
            // remove the component from the installers collection on the main component.
            if (e.Component != Component && e.Component is Installer) {
                ((Installer) Component).Installers.Remove((Installer) e.Component);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\configdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConfigDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Configuration {

    using System;
    using System.ComponentModel;   
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\ConfigDescriptionAttribute.uex' path='docs/doc[@for="ConfigDescriptionAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>DescriptionAttribute marks a property, event, or extender with a
    ///       description. Visual designers can display this description when referencing
    ///       the member.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class ConfigDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\ConfigDescriptionAttribute.uex' path='docs/doc[@for="ConfigDescriptionAttribute.ConfigDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public ConfigDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\ConfigDescriptionAttribute.uex' path='docs/doc[@for="ConfigDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\installerparentconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallerParentConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.Serialization.Formatters;
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;

    /// <include file='doc\InstallerParentConverter.uex' path='docs/doc[@for="InstallerParentConverter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class InstallerParentConverter : ReferenceConverter {

        /// <include file='doc\InstallerParentConverter.uex' path='docs/doc[@for="InstallerParentConverter.InstallerParentConverter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstallerParentConverter(Type type) : base(type) {
        }

        /// <include file='doc\InstallerParentConverter.uex' path='docs/doc[@for="InstallerParentConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            StandardValuesCollection baseValues = base.GetStandardValues(context);

            object component = context.Instance;
            int sourceIndex = 0, targetIndex = 0;
            // we want to return the same list, but with the current component removed.
            // (You can't set an installer's parent to itself.)
            // optimization: assume the current component will always be in the list.
            object[] newValues = new object[baseValues.Count - 1];
            while (sourceIndex < baseValues.Count) {
                if (baseValues[sourceIndex] != component) {
                    newValues[targetIndex] = baseValues[sourceIndex];
                    targetIndex++;
                }
                sourceIndex++;
            }

            return new StandardValuesCollection(newValues);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\propertybindingconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyBindingConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 2000, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace Microsoft.VisualStudio.Configuration {

    using System;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Configuration;
    using System.ComponentModel.Design;
    using System.Collections;
    using Microsoft.VisualStudio.Designer;
    using System.Globalization;

    /// <include file='doc\PropertyBindingConverter.uex' path='docs/doc[@for="PropertyBindingConverter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class PropertyBindingConverter : TypeConverter {

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                if (text.Length == 0 || text == SR.GetString(SR.ConfigNone)) {
                    return PropertyBinding.None;
                }
                return text;
            }
            return base.ConvertFrom(context, culture, value);
        }
                
        /// <include file='doc\PropertyBindingConverter.uex' path='docs/doc[@for="PropertyBindingConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string) && value is PropertyBinding) {
                if (value == null)
                    return SR.GetString(SR.ConfigNone);
                PropertyBinding binding = (PropertyBinding) value;
                if (!binding.Bound)
                    return SR.GetString(SR.ConfigNone);                                    
                                                
                return binding.Key;
            }
            else
                return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\propertybindingeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyBindingEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace Microsoft.VisualStudio.Configuration {   
    using System;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\PropertyBindingsEditor.uex' path='docs/doc[@for="PropertyBindingEditor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class PropertyBindingEditor : UITypeEditor {
        
        /// <include file='doc\QueuePathEditor.uex' path='docs/doc[@for="PropertyBindingEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {                    	    
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));                                
                if (edSvc != null) {                                                                                                                                                     	    
                    PropertyBinding binding = value as PropertyBinding;
                    if (binding != null) { 	    
                        PropertyBinding bindingToEdit = new PropertyBinding(binding);
                        SingleBindingDialog bindingUI = new SingleBindingDialog(bindingToEdit);                                                    	    
                        if (edSvc.ShowDialog(bindingUI) == DialogResult.OK) {
                            value = bindingToEdit;
                            
                            ManagedPropertiesService svc = (ManagedPropertiesService) context.GetService(typeof(ManagedPropertiesService));
                            if (svc != null) {
                                svc.MakeDirty();                                        
                                try {
                                    svc.WriteConfigFile();
                                } 
                                catch {
                                }
                            }
                        }                            
                    }                                                                                                 
                }                                            
            }
            
            return value;
        }

        /// <include file='doc\QueuePathEditor.uex' path='docs/doc[@for="PropertyBindingEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\propertybinding.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyBinding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 2000, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace Microsoft.VisualStudio.Configuration {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Configuration;
    using System.ComponentModel.Design;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding"]/*' />
    /// <devdoc>
    /// Holds a binding between a component's property and a setting in a settings file.
    /// </devdoc>
    [
    TypeConverterAttribute("Microsoft.VisualStudio.Configuration.PropertyBindingConverter, " + AssemblyRef.MicrosoftVisualStudio),
    Editor("Microsoft.VisualStudio.Configuration.PropertyBindingEditor, " + AssemblyRef.MicrosoftVisualStudio, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing)
    ]
    public class PropertyBinding : ICloneable {

        private bool bound = false;
        private bool enabled = true;
        private string componentName = "";
        private PropertyDescriptor property;
        private string key = "";
        private IDesignerHost host;

        // cached value - computed from componentName.
        private IComponent component;
        private bool isDefault;

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string None = SR.GetString(SR.ConfigNone);
        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string Default = SR.GetString(SR.ConfigDefault);
        // public static string Custom = SR.GetString(SR.ConfigCustom);
        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Edit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string Edit = SR.GetString(SR.ConfigEdit);
        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.StandardValues"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string[] StandardValues = new string[] { None, Default, /*Custom,*/ Edit };

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.PropertyBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBinding() {
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.PropertyBinding1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBinding(PropertyBinding bindingToClone) {
            if (bindingToClone != null) {
                bound = bindingToClone.bound;
                enabled = bindingToClone.enabled;
                componentName = bindingToClone.componentName;
                property = bindingToClone.property;
                key = bindingToClone.key;
                host = bindingToClone.host;

                component = bindingToClone.component;
                isDefault = bindingToClone.isDefault;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.PropertyBinding2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBinding(IDesignerHost host) {
            this.host = host;
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Bound"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Bound {
            get {
                return bound;
            }
            set {
                bound = value;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Component"]/*' />
        /// <devdoc>
        /// The component whose property is bound.
        /// </devdoc>
        public IComponent Component {
            get {
                if (component == null && host != null)
                    component = host.Container.Components[componentName];

                return component;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException();

                component = value;

                // update ComponentName;
                componentName = component.Site.Name;
                isDefault = false;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.ComponentName"]/*' />
        /// <devdoc>
        /// The name of the component whose property is bound
        /// </devdoc>
        public string ComponentName {
            get {
                return componentName;
            }
            set {
                if (value == null)
                    value = "";

                componentName = value;

                // invalidate Component
                component = null;
                isDefault = false;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Enabled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Enabled {
            get {
                return enabled;
            }
            set {
                enabled = value;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Host"]/*' />
        /// <devdoc>
        /// Not actually part of the binding, but used to translate between component names and instances.
        /// </devdoc>
        public IDesignerHost Host {
            get {
                return host;
            }
            set {
                host = value;
                
                // invalidate computed properties
                component = null;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.IsDefault"]/*' />
        /// <devdoc>
        /// Keeps track of whether this binding has been modified (e.g. changing the key or value) from
        /// the tool-supplied default.
        /// </devdoc>
        public bool IsDefault {
            get {
                return isDefault;
            }
            set {
                isDefault = value;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Key"]/*' />
        /// <devdoc>
        /// The key under which the setting is managed.
        /// </devdoc>
        public string Key {
            get {
                return key;
            }
            set {
                if (value == null)
                    value = "";

                key = value;
                isDefault = false;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Property"]/*' />
        /// <devdoc>
        /// The PropertyDescriptor for the property being managed.
        /// </devdoc>
        public PropertyDescriptor Property {
            get {
                return property;
            }
            set {
                property = value;
                isDefault = false;
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Value"]/*' />
        /// <devdoc>
        /// A shortcut to get to the value of the property being managed. Always
        /// goes through to the component to get or set the value.
        /// </devdoc>
        public object Value {
            get {
                if (Component == null)
                    throw new InvalidOperationException(SR.GetString(SR.ConfigGetNoComponent));

                return Property.GetValue(Component);
            }
            set {
                if (Component == null)
                    throw new InvalidOperationException(SR.GetString(SR.ConfigSetNoComponent));

                Property.SetValue(Component, value);
            }
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Clone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual object Clone() {
            return new PropertyBinding(this);
        }

        /// <include file='doc\PropertyBinding.uex' path='docs/doc[@for="PropertyBinding.Reset"]/*' />
        /// <devdoc>
        /// Sets the Key and Bound properties to their default values
        /// </devdoc>
        public void Reset() {
            string baseComponentName = host.RootComponentClassName;
            // just get the part of baseComponentName after the last '.'
            //baseComponentName = baseComponentName.Substring(baseComponentName.LastIndexOf('.') + 1);
            //Key = baseComponentName + "_" + ComponentName + "_" + Property.Name;
            
            Key = ComponentName + "." + Property.Name;
            Bound = false;
            isDefault = true;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\iassemblyenumerationservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IAssemblyEnumerationService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;
    using System.Collections;

    /// <include file='doc\IAssemblyEnumerationService.uex' path='docs/doc[@for="IAssemblyEnumerationService"]/*' />
    /// <devdoc>
    ///     This service enumerates the set of SDK assemblies for Visual Studio.  Assemblies are returned as
    ///     an enumeration of assembly names.
    /// </devdoc>
    internal interface IAssemblyEnumerationService {
    
        /// <devdoc>
        ///     Retrieves an enumerator that enumerates all
        ///     assembly names.
        /// </devdoc>
        IEnumerable GetAssemblyNames();
    
        /// <devdoc>
        ///     Retrieves an enumerator that can enumerate
        ///     assembly names matching name.
        /// </devdoc>
        IEnumerable GetAssemblyNames(string name);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\propertybindingcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyBindingCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 2000, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace Microsoft.VisualStudio.Configuration {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Configuration;    
    
    /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>    
    public class PropertyBindingCollection : ICollection {
        private ArrayList contents = new ArrayList();
        //private Hashtable hashedContents = new Hashtable();

        private int instanceNum = nextInstanceNum++;
        private static int nextInstanceNum = 1;

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBinding this[int index] {
            get {
                return (PropertyBinding) contents[index];
            }
            set {
                contents[index] = value;
                //hashedContents[new InstancedPropertyDescriptor(value.ComponentName, value.Property)] = value;
            }
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBinding this[IComponent component, PropertyDescriptor property] {
            get {
                if (component == null || property == null || Count == 0)
                    return null;

                string componentName = component.Site != null ? component.Site.Name : null;
                
                if (componentName != null) {
                    for (int i = 0; i < Count; i++) {
                        if (this[i].ComponentName == componentName && this[i].Property.Equals(property))
                            return this[i];
                    }
                }
    
                return null;

                /* CONSIDER, ryanstu: 
                    Looking up PropertyBindings by component and property will be faster if we use a
                    hashtable than by doing a linear search if there are more that a few dynamic
                    properties.  The code is here, but it isn't used now because there are couple issues:
                        1. If the property of a binding changes after the binding is added to the
                           hashtable, we won't be able to find it.  This might be okay, though, 
                           since we're the only ones that use this class and we can be careful not
                           to do this.
                        2. It's a drag to have these two structures both storing references to 
                           the PropertyBindings (an ArrayList and a Hashtable).  The only reason we
                           have the ArrayList is so that we can index by int, and the only reason we
                           want that is so that we can iterate over this collection.  If we instead
                           implement IEnumerable and use the Hashtable enumerator, we can get rid of
                           the ArrayList altogether.
                
                
                return (PropertyBinding) hashedContents[new InstancedPropertyDescriptor(component.Site.Name, property)];
                */
            }
            set {
                string componentName = component.Site.Name;
                for (int i = 0; i < Count; i++)
                    if (this[i].ComponentName == componentName && this[i].Property.Equals(property)) {
                        this[i] = value;
                        return;
                    }

                // didn't find one to change, so add it.
                Add(value);

                /* CONSIDER, more of the above.
                hashedContents[new InstancedPropertyDescriptor(component.Site.Name, property)] = value;
                */
                
            }
        }
        
        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual int Count {
            get {
                return contents.Count;
            }
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool IsSynchronized {
            get {
                return contents.IsSynchronized;
            }
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual object SyncRoot {
            get {
                return contents.SyncRoot;
            }
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(PropertyBinding binding) {
            contents.Add(binding);
            //hashedContents[new InstancedPropertyDescriptor(binding.ComponentName, binding.Property)] = binding;
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            contents.Clear();
            //hashedContents.Clear();
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.CopyFrom"]/*' />
        /// <devdoc>
        /// Creates a deep copy of the given collection, cloning each contained PropertyBinding.
        /// </devdoc>
        public void CopyFrom(PropertyBindingCollection coll) {
            Clear();
            for (int i = 0; i < coll.Count; i++)
                Add((PropertyBinding) coll[i].Clone());
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void CopyTo(Array array, int index) {
            contents.CopyTo(array, index);
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual System.Collections.IEnumerator GetEnumerator() {
            return contents.GetEnumerator();
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.GetEnumerator1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual IEnumerator GetEnumerator(bool allowRemove) {
            return contents.GetEnumerator();
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.GetBindingsForComponent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBindingCollection GetBindingsForComponent(IComponent component) {
            PropertyBindingCollection collection = new PropertyBindingCollection();

            foreach (PropertyBinding binding in contents) {
                if (binding.Component == component) {
                    collection.Add(binding);
                }
            }

            return collection;
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.SetBindingsForComponent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetBindingsForComponent(IComponent component, PropertyBindingCollection newBindings) {
            if (component == null)
                throw new ArgumentNullException("component");
            if (newBindings == null)
                throw new ArgumentNullException("newBindings");

            for (int i = Count - 1; i >= 0; i--)
                if (this[i].Component == component)
                    RemoveAt(i);

            for (int i = 0; i < newBindings.Count; i++)
                Add(newBindings[i]);
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            //hashedContents.Remove(new InstancedPropertyDescriptor(this[index].ComponentName, this[index].Property));
            contents.RemoveAt(index);
        }

        /// <include file='doc\PropertyBindingCollection.uex' path='docs/doc[@for="PropertyBindingCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(PropertyBinding binding) {
            contents.Remove(binding);
            //hashedContents.Remove(new InstancedPropertyDescriptor(binding.ComponentName, binding.Property));
        }

        /*
        private class InstancedPropertyDescriptor {
            private string componentName;
            private PropertyDescriptor property;
            private int hashCode = -1;
            
            public InstancedPropertyDescriptor(string componentName, PropertyDescriptor property) {
                this.componentName = componentName;
                this.property = property;
            }

            public override int GetHashCode() {
                if (hashCode == -1)
                    hashCode = componentName.GetHashCode() ^ property.Name.GetHashCode();

                return hashCode;
            }

            public override bool Equals(object obj) {
                try {
                    if (obj == this) {
                        return true;
                    }
                    
                    if (obj == null) {
                        return false;
                    }
                    
                    InstancedPropertyDescriptor ipd = obj as InstancedPropertyDescriptor;
    
                    if (ipd != null &&
                        ipd.componentName == this.componentName &&
                        ipd.property != null &&
                        ipd.property.Equals(this.property)) {
        
                        return true;
                    }
                }
                catch (Exception) {
                }
    
                return false;
            } 
        }
        */
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\singlebindingdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="SingleBindingDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 2000, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace Microsoft.VisualStudio.Configuration {
    using System.ComponentModel;
    using System.Diagnostics;  
    using System;
    using System.Drawing;
    using System.Collections;
    using System.Windows.Forms;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using Microsoft.VisualStudio.Designer;
    
    /// <include file='doc\SingleBindingDialog.uex' path='docs/doc[@for="SingleBindingDialog"]/*' />
    /// <devdoc>
    /// This dialog lets the user bind components' properties to values in
    /// the application settings file.
    /// </devdoc>
    public class SingleBindingDialog : Form {
        private System.Windows.Forms.Button okButton;
        
        private System.Windows.Forms.Label keyLabel;
        
        private System.Windows.Forms.ComboBox keyCombo;
        
        private System.Windows.Forms.Button cancelButton;
        
        private System.Windows.Forms.CheckBox boundCheckbox;
                
        private PropertyBinding binding;
        
        /// <include file='doc\SingleBindingDialog.uex' path='docs/doc[@for="SingleBindingDialog.SingleBindingDialog"]/*' />
        /// <devdoc>
        /// Creates a new dialog to let the user edit dynamic property bindings.
        /// The bindings parameter must have all possible bindings in it for the
        /// components and their properties, even if none are bound. For unbound
        /// properties, the key property on the binding should be
        /// initialized to its suggested (default) values.
        /// </devdoc>
        public SingleBindingDialog(PropertyBinding binding) {
            this.binding = binding;
            this.InitializeComponent();
            FillUI();
        }
        
        /// <include file='doc\SingleBindingDialog.uex' path='docs/doc[@for="SingleBindingDialog.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyBinding Binding {
            get {
                return binding;
            }
        }

        private void InitializeComponent() {
           System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(SingleBindingDialog));
            this.okButton = new System.Windows.Forms.Button();
            this.keyLabel = new System.Windows.Forms.Label();
            this.keyCombo = new System.Windows.Forms.ComboBox();
            this.cancelButton = new System.Windows.Forms.Button();
            this.boundCheckbox = new System.Windows.Forms.CheckBox();
            this.okButton.Location = ((System.Drawing.Point)(resources.GetObject("okButton.Location")));
            this.okButton.Name = "okButton";
            this.okButton.Size = ((System.Drawing.Size)(resources.GetObject("okButton.Size")));
            this.okButton.TabIndex = ((int)(resources.GetObject("okButton.TabIndex")));
            this.okButton.Text = resources.GetString("okButton.Text");
            this.okButton.DialogResult = DialogResult.OK;
            this.keyLabel.Location = ((System.Drawing.Point)(resources.GetObject("keyLabel.Location")));
            this.keyLabel.Name = "keyLabel";
            this.keyLabel.Size = ((System.Drawing.Size)(resources.GetObject("keyLabel.Size")));
            this.keyLabel.TabIndex = ((int)(resources.GetObject("keyLabel.TabIndex")));
            this.keyLabel.Text = resources.GetString("keyLabel.Text");
            this.keyCombo.DropDownWidth = 220;
            this.keyCombo.Location = ((System.Drawing.Point)(resources.GetObject("keyCombo.Location")));
            this.keyCombo.Name = "keyCombo";
            this.keyCombo.Size = ((System.Drawing.Size)(resources.GetObject("keyCombo.Size")));
            this.keyCombo.TabIndex = ((int)(resources.GetObject("keyCombo.TabIndex")));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = ((System.Drawing.Point)(resources.GetObject("cancelButton.Location")));
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = ((System.Drawing.Size)(resources.GetObject("cancelButton.Size")));
            this.cancelButton.TabIndex = ((int)(resources.GetObject("cancelButton.TabIndex")));
            this.cancelButton.Text = resources.GetString("cancelButton.Text");
            this.cancelButton.DialogResult = DialogResult.Cancel;
            this.boundCheckbox.Location = ((System.Drawing.Point)(resources.GetObject("boundCheckbox.Location")));
            this.boundCheckbox.Name = "boundCheckbox";
            this.boundCheckbox.Size = ((System.Drawing.Size)(resources.GetObject("boundCheckbox.Size")));
            this.boundCheckbox.TabIndex = ((int)(resources.GetObject("boundCheckbox.TabIndex")));
            this.boundCheckbox.Text = resources.GetString("boundCheckbox.Text");
            this.boundCheckbox.CheckedChanged += new System.EventHandler(this.OnSaveCheck);
            this.AcceptButton = this.okButton;
            this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));            
            this.CancelButton = this.cancelButton;
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));            
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this.cancelButton,
                        this.okButton,
                        this.keyCombo,
                        this.keyLabel,
                        this.boundCheckbox});
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "Win32Form1";
            this.ShowInTaskbar = false;
            this.StartPosition = FormStartPosition.CenterParent;
            this.Text = String.Format(resources.GetString("$this.Text"), binding.Component.Site.Name + "." + binding.Property.Name);
            this.Icon = null;
            this.Closing += new System.ComponentModel.CancelEventHandler(this.OnClosing);            
        }        
        
        private void OnClosing(object sender, CancelEventArgs e) {              
            if (this.DialogResult == DialogResult.Cancel)
                return;
            binding.Key = keyCombo.Text;
        }

        private void OnSaveCheck(object sender, EventArgs e) {
            keyCombo.Enabled = boundCheckbox.Checked;
            binding.Bound = boundCheckbox.Checked;
            if (binding.Bound) {                
                keyCombo.Text = binding.Key;
            }
        }

        private void FillUI() {
            keyCombo.Items.Clear();
            
            ManagedPropertiesService mpService = (ManagedPropertiesService) binding.Host.GetService(typeof(ManagedPropertiesService));
            if (mpService != null) {
                keyCombo.Items.Clear();
                keyCombo.Items.AddRange(mpService.GetKeysForType(binding.Property.PropertyType));
            }
                                    
            keyCombo.Enabled = binding.Bound;
            boundCheckbox.Checked = binding.Bound;
            keyCombo.Sorted = true;         
            keyCombo.Text = binding.Key;               
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\ityperesolutionserviceprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITypeResolutionServiceProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using Microsoft.VisualStudio.Interop;
    using System.ComponentModel.Design;

    /// <include file='doc\ITypeResolutionServiceProvider.uex' path='docs/doc[@for="ITypeResolutionServiceProvider"]/*' />
    /// <devdoc>
    ///      The type resolution provider is a service that provides
    ///      type resolution service objects on demand.  These objects
    ///      handle loading types given a type name.  In VS, there
    ///      is a type resolution service for each project.  The service 
    ///      maintains a list of references for the project and
    ///      loads types by searching in these references.  It also
    ///      handles generated outputs from the project and supports
    ///      reloading of types when project data changes.
    /// </devdoc>
    public interface ITypeResolutionServiceProvider {

        /// <include file='doc\ITypeResolutionServiceProvider.uex' path='docs/doc[@for="ITypeResolutionServiceProvider.GetTypeResolutionService"]/*' />
        /// <devdoc>
        ///      Retrieves a type resolution service for the given context.  The context
        ///      should be something that implements IVsHierarchy.  If there
        ///      is no type loader for this hierarchy it will create one.
        /// </devdoc>
        ITypeResolutionService GetTypeResolutionService(object context);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\iundoservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IUndoService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;
    using System.ComponentModel.Design;

    /// <include file='doc\IUndoService.uex' path='docs/doc[@for="IUndoService"]/*' />
    /// <devdoc>
    ///     This interface provides access to the undo system from
    ///     the designer.
    /// </devdoc>
    public interface IUndoService {
        /// <include file='doc\IUndoService.uex' path='docs/doc[@for="IUndoService.RedoUnits"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        UndoUnitCollection RedoUnits { get; }
        /// <include file='doc\IUndoService.uex' path='docs/doc[@for="IUndoService.UndoUnits"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        UndoUnitCollection UndoUnits { get; }
        /// <include file='doc\IUndoService.uex' path='docs/doc[@for="IUndoService.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
    
        void Add(IUndoUnit unit);
        /// <include file='doc\IUndoService.uex' path='docs/doc[@for="IUndoService.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        void Clear();
        /// <include file='doc\IUndoService.uex' path='docs/doc[@for="IUndoService.Redo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        void Redo(int count);
        /// <include file='doc\IUndoService.uex' path='docs/doc[@for="IUndoService.Undo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        void Undo(int count);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\iundounit.cs ===
//------------------------------------------------------------------------------
// <copyright file="IUndoUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;
    using System.ComponentModel.Design;

    /// <include file='doc\IUndoUnit.uex' path='docs/doc[@for="IUndoUnit"]/*' />
    /// <devdoc>
    ///     A single unit of undo work.
    /// </devdoc>
    public interface IUndoUnit {
        /// <include file='doc\IUndoUnit.uex' path='docs/doc[@for="IUndoUnit.Description"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
    
        string Description { get; }
        /// <include file='doc\IUndoUnit.uex' path='docs/doc[@for="IUndoUnit.Do"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        void Do(IUndoService uds);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\configuration\managedpropertiesservice.cs ===
//------------------------------------------------------------------------------
/// <copyright file="ManagedPropertiesService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Configuration {
    using System;
    using System.CodeDom;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Configuration;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using Microsoft.VisualStudio.Designer;

    /// <summary>
    ///      This is the value provider for dynamic properties.
    /// </summary>
    [ProvideProperty("DynamicProperties", typeof(IComponent))]
    public class ManagedPropertiesService : IDesignerSerializationProvider, IExtenderProvider, ITypeDescriptorFilterService {
        private Hashtable serializers;
        private Hashtable parsers;   // a hash of Type -> Type.Parse()
        private IServiceProvider serviceProvider;
        private IDesignerHost host = null;
        private PropertyBindingCollection bindings;
        private DesignerSettingsStore settingsStore;
        private Stack busyKeys;
        private Bitmap propBitmapEnabled;
        private Bitmap propBitmapDisabled;
        private bool declarationAdded;
        private bool serializing;
        private bool dirty;
        private bool storeInitialized;
        private ITypeDescriptorFilterService delegateFilterService;
        private ToolboxItemFilterAttribute webControlFilter;


#if DEBUG
        static TraceSwitch managedPropertiesSwitch = new TraceSwitch("managedPropertiesService", "Controls output from ManagedPropertiesServices class");
#else
        static TraceSwitch managedPropertiesSwitch = null;  
#endif
        
        
        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public ManagedPropertiesService(IServiceProvider serviceProvider) {
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "ManagedPropertiesService constructor");

            this.serviceProvider = serviceProvider;

            IComponentChangeService changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            Debug.Assert(changeService != null, "couldn't get component change service");
            if (changeService != null) {
                changeService.ComponentRemoved += new ComponentEventHandler(OnComponentRemoved);
                changeService.ComponentRename += new ComponentRenameEventHandler(OnComponentRename);
                changeService.ComponentChanged += new ComponentChangedEventHandler(OnComponentChanged);
                changeService.ComponentChanging += new ComponentChangingEventHandler(OnComponentChanging);
                changeService.ComponentAdded += new ComponentEventHandler(OnComponentAdded);
            }
            
            IExtenderProviderService provService = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
            if (provService != null) {
                provService.AddExtenderProvider(this);
            }

            IPropertyValueUIService pvUISvc = (IPropertyValueUIService)GetService(typeof(IPropertyValueUIService));
            if (pvUISvc != null) {
                pvUISvc.AddPropertyValueUIHandler(new PropertyValueUIHandler(this.OnGetUIValueItem));
            }            
                                                                                                                                                    
            IServiceContainer serviceContainer = (IServiceContainer)GetService(typeof(IServiceContainer));                                      
            if (serviceContainer != null) {
                delegateFilterService = (ITypeDescriptorFilterService)GetService(typeof(ITypeDescriptorFilterService));
                if (delegateFilterService != null) 
                    serviceContainer.RemoveService(typeof(ITypeDescriptorFilterService));

                serviceContainer.AddService(typeof(ITypeDescriptorFilterService), this);                                                        
            }
        }
        
        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public PropertyBindingCollection Bindings {
            get {
                if (bindings == null) {
                    bindings = new PropertyBindingCollection();
                    // CreateDefaultBindings(bindings);
                }
                return bindings;
            }
            set {
                bindings = value;
            }
        }
         
        /// <summary>
        ///     This is used by the serializer to maintain state.  Serializers are stateless,
        ///     and the first one that writes out data should also write out the variable
        ///     declaration for the settings store.
        /// </summary>
        private bool DeclarationAdded {
            get {
                return declarationAdded;
            }
            set {
                declarationAdded = value;
            }
        }
        
        private DesignerSettingsStore SettingsStore {
            get {
                if (settingsStore == null) {
                    settingsStore = new DesignerSettingsStore(serviceProvider);
                    settingsStore.LoadData();
                }
                return settingsStore;
            }
        }
                
        private Stack BusyKeys {
            get {
                if (busyKeys == null) {
                    busyKeys = new Stack();
                }
                return busyKeys;
            }
        }

        private Bitmap PropBitmapDisabled {
            get {
                if (propBitmapDisabled == null) { 
                    Bitmap b = new Bitmap(typeof(ManagedPropertiesService), "ManagedPropDisabled.bmp");
                    b.MakeTransparent(Color.FromArgb(0, 255, 0));
                    propBitmapDisabled = b;
                }
                return propBitmapDisabled;
            }
        }
        
        private Bitmap PropBitmapEnabled {
            get {
                if (propBitmapEnabled == null) { 
                    Bitmap b = new Bitmap(typeof(ManagedPropertiesService), "ManagedProp.bmp");
                    b.MakeTransparent(Color.FromArgb(0, 255, 0));
                    propBitmapEnabled = b;
                }
                return propBitmapEnabled;
            }
        }
        
        /// <summary>
        ///     This is used by the serializer to maintain state.  Serializers are stateless,
        ///     and we use this so we can tell what direction our serialization is going.
        /// </summary>
        private bool Serializing {
            get {
                return serializing;
            }
            set {
                // This is set by a serializer when it is first asked to serialize us.
                serializing = value;
                
                if (!storeInitialized) {
                    
                    if (!serializing) {
                        // Let go of the old data and get ready to get new stuff
                        bindings = null;
                    }
                    
                    Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "settingsStore.LoadData()");
                    try {
                        SettingsStore.LoadData();
                    } catch (Exception e) {                        
                        throw new Exception(SR.GetString(SR.ConfigLoadError, e.Message));
                    }

                    storeInitialized = true;
                }
            }
        }

        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public void Dispose() {
        
            IComponentChangeService changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            Debug.Assert(changeService != null, "couldn't get component change service");
            if (changeService != null) {
                changeService.ComponentRemoved -= new ComponentEventHandler(OnComponentRemoved);
                changeService.ComponentRename -= new ComponentRenameEventHandler(OnComponentRename);
                changeService.ComponentChanged -= new ComponentChangedEventHandler(OnComponentChanged);
            }
            
            IExtenderProviderService provService = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
            if (provService != null) {
                provService.RemoveExtenderProvider(this);
            }

            IDesignerSerializationManager dm = (IDesignerSerializationManager)GetService(typeof(IDesignerSerializationManager));
            if (dm != null) {
                dm.RemoveSerializationProvider(this);
            }

            IPropertyValueUIService pvUISvc = (IPropertyValueUIService)GetService(typeof(IPropertyValueUIService));
            if (pvUISvc != null) {
                pvUISvc.RemovePropertyValueUIHandler(new PropertyValueUIHandler(this.OnGetUIValueItem));
            }            
        }

        /// <summary>
        ///     Called by the AdvancedPropertyEditor to add a new binding.
        /// </summary>
        public void EnsureKey(PropertyBinding originatingBinding) {
            if (!originatingBinding.Bound)
                return;

            string key = originatingBinding.Key;
            object currentValue = SettingsStore.GetValue(key);
            if (!SettingsStore.ValueExists(key)) {
                object value = originatingBinding.Property.GetValue(originatingBinding.Component);
                Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "setting KeysAndValues[" + key + "] = " + (value == null ? "<null>" : value.ToString()));
                SettingsStore.SetValue(key, (value == null) ? null :  value.ToString(), null);
                originatingBinding.Enabled = true;   // if we get here that the property value does reflect the config value
            }
            else {
                // the key already exists, try to parse it and use it
                originatingBinding.Enabled = SetPropValueToString(originatingBinding.Component, originatingBinding.Property, (string)currentValue);
            }
        }
        
        /// <summary>
        ///     ITypeDescriptorFilterService implementation.
        /// </summary>
        public bool FilterAttributes(IComponent component, IDictionary attributes) {
            if (delegateFilterService != null)
                return delegateFilterService.FilterAttributes(component, attributes);                
                
            return true;                
        }
        
        /// <summary>
        ///     ITypeDescriptorFilterService implementation.
        /// </summary>
        public bool FilterEvents(IComponent component, IDictionary events) {
            if (delegateFilterService != null)
                return delegateFilterService.FilterEvents(component, events);                
                
            return true;                
        }
        
        /// <summary>
        ///     ITypeDescriptorFilterService implementation.
        /// </summary>                      
        public bool FilterProperties(IComponent component, IDictionary properties) { 
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "************ FilterProperties(" + component.ToString() + ")");

            if (delegateFilterService != null)
                delegateFilterService.FilterProperties(component, properties);                

            string componentName = component.Site != null ? component.Site.Name : null;
            foreach (PropertyBinding binding in Bindings) {            
                if (binding.Bound && binding.ComponentName == componentName) {
                    PropertyDescriptor delegatePropertyDescriptor = (PropertyDescriptor)properties[binding.Property.Name];
                    if (delegatePropertyDescriptor != null) {
                        if (!(delegatePropertyDescriptor is ManagedPropertyDescriptor)) {
                            properties[binding.Property.Name] = new ManagedPropertyDescriptor(delegatePropertyDescriptor);
                        }
                    }
                }                    
            }                
                            
            // The return value from this function indicates whether the information
            // can be cached.  We return false as long as the form is being loaded, since
            // the managed properties deserialization stuff will affect how we filter.
            if (host == null) {
                host = (IDesignerHost)GetService(typeof(IDesignerHost));
            }
            bool returnValue = false;
            if (host != null) {
                returnValue = !host.Loading;
            }
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "************ FilterProperties returns " + returnValue);
            return returnValue;
        }

        private MethodInfo GetParser(Type typeToParse) {
            if (parsers == null)
                parsers = new Hashtable();
        
            MethodInfo parser = (MethodInfo)parsers[typeToParse];
            if (parser == null) {
                parser = typeToParse.GetMethod("Parse", new Type[] { typeof(string) } );
                parsers[typeToParse] = parser;
            }

            return parser;
        }
        
        private bool SetPropValueToString(IComponent component, PropertyDescriptor prop, string strVal) {
            object value;
            Type propType = prop.PropertyType;
            try {
                if (propType == typeof(string)) {
                    value = strVal;
                }
                else {
                    MethodInfo parser = GetParser(propType);
                    if (parser == null) return false;
                    value = parser.Invoke(/* no object instance */ null, /* parameters */ new Object[] { strVal });
                }
                prop.SetValue(component, value);               
            }
            catch (Exception) {
                return false;
            }
            return true;
        }

        private class ManagedPropertyDescriptor : PropertyDescriptor {
            private PropertyDescriptor delegatePropertyDescriptor;
            
            public ManagedPropertyDescriptor(PropertyDescriptor delegatePropertyDescriptor) 
            : base(delegatePropertyDescriptor, new Attribute[] { RefreshPropertiesAttribute.Repaint } ) {
                this.delegatePropertyDescriptor = delegatePropertyDescriptor;
            }
            
            public override Type ComponentType {
                get {
                    return this.delegatePropertyDescriptor.ComponentType;
                }
            }                
            
            public override bool IsReadOnly {
                get {
                    return this.delegatePropertyDescriptor.IsReadOnly;
                }
            }                                
            
            public override Type PropertyType {
                get {
                    return this.delegatePropertyDescriptor.PropertyType;
                }
            }
            
            public override void AddValueChanged(object component, EventHandler handler) {
                this.delegatePropertyDescriptor.AddValueChanged(component, handler);
            }
            
            public override bool CanResetValue(object component) {
                return this.delegatePropertyDescriptor.CanResetValue(component);
            }
            
            public override object GetValue(object component) {           
                return this.delegatePropertyDescriptor.GetValue(component);
            } 
                         
            public override void RemoveValueChanged(object component, EventHandler handler) {
                this.delegatePropertyDescriptor.RemoveValueChanged(component, handler);
            }
                                                                           
            public override void ResetValue(object component) {
                this.delegatePropertyDescriptor.ResetValue(component);
            }
            
            public override void SetValue(object component, object value) {
                this.delegatePropertyDescriptor.SetValue(component, value);
            }
            
            public override bool ShouldSerializeValue(object component) {
                return true;
            }            
        }             
             
        /// <summary>
        ///     Implementation of the (ConfigurableProperties) property extended onto all components
        /// </summary>
        [
        ParenthesizePropertyName(true),
        Category("Config"),
        ConfigDescription(SR.ManagedPropServiceDescr),
        RefreshProperties(RefreshProperties.All),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public ComponentSettings GetDynamicProperties(IComponent component) {
            ComponentSettings value = new ComponentSettings(component, this);
            return value;
        }

        /// <summary>
        ///     Called by the AdvancedProeprtyEditor to retrieve keys for
        ///     the given type.
        /// </summary>    
        public string[] GetKeysForType(Type type) {
            try {
                if (settingsStore != null) {
                    Hashtable list = new Hashtable();
                    if (type != typeof(string)) {
                        foreach (string key in SettingsStore.GetKeysAndValues().Keys) {
                            object value = SettingsStore.GetKeysAndValues()[key];
                            try {
                                Convert.ChangeType(value, type);
                                // if it passed, add to list
                                list[key] = true;
                            }
                            catch (Exception) {
                            }
                        }
                    }
                    else {
                        foreach (string key in SettingsStore.GetKeysAndValues().Keys) {
                            list[key] = true;
                        }
                    }

                    foreach (PropertyBinding binding in Bindings) {
                        if (binding.Bound && binding.Property.PropertyType == type) {
                            list[binding.Key] = true;
                        }
                    }
                    
                    string[] keys = new string[list.Count];
                    list.Keys.CopyTo(keys,0);

                    return keys;
                }
            }
            catch (Exception e) {
                Debug.Fail("Couldn't call GetKeys on shell store: " + e);
            }
            return new string[0];
        }

        /// <summary>
        ///     Helper for returning services.
        /// </summary>    
        protected object GetService(Type t) {
            if (serviceProvider != null) {
                return serviceProvider.GetService(t);
            }
            return null;
        }
        
        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public static bool IsTypeSupported(Type type) {            
            // we support null values
            if (type == null) {
                return true;
            }

            if (type.IsPrimitive) {
                return true;
            }

            // these are all value types, so check that bit first
            //
            if (type.IsValueType) {
                return type == typeof(System.DateTime) || type == typeof(System.Decimal) || type == typeof(System.TimeSpan);
            }

            // string is the only non-value, non-primative type we support
            //
            return type == typeof(string);
        }



        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public void MakeDirty() {
            dirty = true;
        }
        
        private void OnComponentAdded(object sender, ComponentEventArgs e) {
        
            // We need to add ourselves as a serialization provider.  The only opportunity we
            // have to do this is after the serialization process has begun for the first time,
            // because the loader is responsible for providing IDesignerSerializationManager.
            // Here we check to see if the component we're adding is the root, and if it is,
            // we attach.
            //
            if (host == null) {
                host = (IDesignerHost)GetService(typeof(IDesignerHost));
            }
            
            if (host != null && host.RootComponent == e.Component) {
                IDesignerSerializationManager dm = (IDesignerSerializationManager)GetService(typeof(IDesignerSerializationManager));
                if (dm != null) {
                    dm.AddSerializationProvider(this);
                }
            }
        }

        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "OnComponentChanged()");

#if DEBUG
            if (managedPropertiesSwitch.TraceVerbose) Debug.Indent();
            try {
#endif


            if (bindings == null || !(e.Component is IComponent) || (e.Member == null) || ((IComponent) e.Component).Site == null) {
                return;
            }

            if (object.Equals(e.OldValue, e.NewValue)) {
                return;
            }

            IComponent component = (IComponent) e.Component;
            string componentName = component.Site.Name;
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "componentName = " + componentName);
            PropertyDescriptor property = TypeDescriptor.GetProperties(component)[e.Member.Name];
            if (property == null) {
                return;   // design-time property
            }
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "property = " + property.Name);

            PropertyBinding originalBinding = Bindings[component, property];
            if (originalBinding == null || !originalBinding.Bound) {
                return;
            }

            if (BusyKeys.Contains(originalBinding.Key)) {
                // this property is being set by managedpropertiesservice,
                // so we don't need to set the value or set other props
                return;
            }

            object originalValue = SettingsStore.GetValue(originalBinding.Key);
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "key = " + originalBinding.Key);
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "originalValue = " + originalValue);
            
            string value;
            if (e.Member is BindingPropertyDescriptor) {
                Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "e.Member is BindingPropertyDescriptor");
                return;
            }
            else {
                object valueObject = property.GetValue(component);
                value = (valueObject == null) ? null : valueObject.ToString();
            }

            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "value = " + (value == null ? "<null>" : value));

            // We only need to act on this if the new value is different from the value currently
            // associated with the key.
            if (!object.Equals(originalValue, value)) {

                BusyKeys.Push(originalBinding.Key);
                try {
        
                    originalBinding.Enabled = true;
        
                    Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "setting KeysAndValues[" + originalBinding.Key + "] = " + (value == null ? "<null>" : value));
                    SettingsStore.SetValue(originalBinding.Key, value, null);
                    MakeDirty();
                    
                    // we need to make sure that every binding with that key gets updated with the proper value.            
                    Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "looking for other properties with my key to update...");
                    Debug.Indent();
                    foreach (PropertyBinding binding in bindings) {
                        if (binding.Bound && binding != originalBinding && binding.Key == originalBinding.Key) {
                            
                            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "updating " + binding.Property.Name + " with value " + (value == null ? "<null>" : value));
                            object bindingCurrentValue = binding.Property.GetValue(binding.Component);
                            if (bindingCurrentValue == null || !object.Equals(value, bindingCurrentValue.ToString())) {
                                binding.Enabled = SetPropValueToString(binding.Component, binding.Property, value);
                            }
                            else {
                                // Here we know that the binding already has the right value, but it is
                                // possible that it is currently disabled
                                binding.Enabled = true;
                            }
                        }
                    }
                    Debug.Unindent();
                    Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "... done with update.");
                }
                finally {
                    BusyKeys.Pop();
                    WriteConfigFile();
                }
            }

#if DEBUG
            }
            finally {
                if (managedPropertiesSwitch.TraceVerbose) Debug.Unindent();
            }
#endif

        }

        
        private void OnComponentChanging(object sender, ComponentChangingEventArgs e) {
            if (bindings == null || !(e.Component is IComponent) || (e.Member == null) || ((IComponent) e.Component).Site == null) {
                return;
            }

            IComponent component = (IComponent) e.Component;
            string componentName = component.Site.Name;
            PropertyDescriptor property = TypeDescriptor.GetProperties(component)[e.Member.Name];
            if (property == null)
                return;   // design-time property
                
            PropertyBinding originalBinding = Bindings[component, property];
            if (originalBinding == null || !originalBinding.Bound)
                return;

        }

        private void OnComponentRemoved(object sender, ComponentEventArgs e) {
            if (bindings == null)
                return;

            for (int i = bindings.Count - 1; i >= 0; i--) {
                if (bindings[i].Component == e.Component) {
                    bindings.RemoveAt(i);
                }
            }
        }

        /// <summary>
        ///     Called when the designer host fires the OnComponentRename event.
        /// </summary>
        private void OnComponentRename(object sender, ComponentRenameEventArgs e) {
            if (bindings == null)
                return;

            for (int i = 0; i < bindings.Count; i++)
                if (bindings[i].ComponentName == e.OldName)
                    bindings[i].ComponentName = e.NewName;
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void OnGetUIValueItem(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList){        
            if (context.Instance is IComponent) {
                PropertyBinding binding = Bindings[(IComponent)context.Instance, propDesc]; 
                if (binding != null && binding.Bound) {
                    if (binding.Enabled) {
                        valueUIItemList.Add(new LocalUIItem(this, binding, PropBitmapEnabled));
                    }
                    else {
                        valueUIItemList.Add(new LocalUIItem(this, binding, PropBitmapDisabled));
                    }
                }
            }    
        }

        private void OnPropertyValueUIItemInvoke(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem) {            
        }
        
        /// <summary>
        ///     Called when serialization is done.  Here we reset our state
        ///     for the next time we're serialized.
        /// </summary>
        private void OnSerializationComplete(object sender, EventArgs evt) {
            IDesignerSerializationManager manager = (IDesignerSerializationManager)sender;
            
            bool wasSerializing = serializing;
            
            storeInitialized = false;
            declarationAdded = false;
            serializing = false;
            manager.SerializationComplete -= new EventHandler(OnSerializationComplete);

            if (wasSerializing) {
                try {
                    WriteConfigFile();
                }
                catch (Exception e) {
                    Debug.Fail("Couldn't save data in shell store: " + e);
                    manager.ReportError(e);
                }
            }
        }

        internal void WriteConfigFile() {
            Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "WriteConfigFile()");           
            if (BusyKeys.Count == 0 && settingsStore != null && dirty) {
                foreach (PropertyBinding binding in Bindings) {
                    if (binding.Bound && binding.Enabled) {
                        object value = binding.Property.GetValue(binding.Component);
                        Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "WriteConfigFile: settingsStore.SetValue(" + binding.Key + ", " + (value == null ? "<null>" : value.ToString()) + ")");
                        settingsStore.SetValue(binding.Key, (value == null) ? null : value.ToString(), binding.Property.PropertyType);
                    }
                }
                settingsStore.SaveData();
                dirty = false;
            }
        }

        /// <summary>
        ///     Called by the serialization engine to retrieve a serializer for our use.
        /// </summary>    
        object IDesignerSerializationProvider.GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType) {

            // The way this works is if the object type is a supported type, and if the serializer type is a CodeDomSerialzer,
            // we always wrap the existing serializer with our own.  Our own serializer maintains a reference
            // to this existing serializer, and may delegate to it if there is no
            // matching property in the config file for our property.  Our serializer also supports serializing 
            // a SettingContainer object -- we create an instance of SettingContainer that points to our
            // bindings, and deserialization of the code happens automatically from the code engine.
            //
            if (serializerType != typeof(CodeDomSerializer)) {
                return null;
            }
            
            if (currentSerializer == null) {
                return null;
            }                
            
            // If the serilaizer is already one of ours, return null.  This indicates that the
            // serialization manager is looping around the providers again.
            //
            if (currentSerializer is ManagedPropertySerializer) {
                return null;
            }                        
                
            if (objectType == typeof(NameValueCollection) || objectType == typeof(AppSettingsReader) || (currentSerializer != null && IsTypeSupported(objectType))) {
                object serializer = null;
                
                if (serializers == null) {
                    serializers = new Hashtable();
                }
                else {
                    serializer = serializers[currentSerializer];
                }
                
                if (serializer == null) {
                    serializer = new ManagedPropertySerializer(this, (CodeDomSerializer)currentSerializer);
                    serializers[currentSerializer] = serializer;
                }

                return serializer;
            }
            
            // Returning null here indicates that we are not interested in providing
            // our own serializer.                                                    
            //
            return null;
        }
    
        /// <summary>
        /// IExtenderProvider implementation
        /// </summary>
        bool IExtenderProvider.CanExtend(object o) {
            IComponent component = o as IComponent;
            if (component != null) {
                
                // we can extend anything that isn't a WebControl
                // Note: Don't directly ask for web control here;
                // it brings in the entire assembly even for non
                // web things.
                //
                if (webControlFilter == null) {
                    webControlFilter = new ToolboxItemFilterAttribute("System.Web.UI");
                }
                if (!TypeDescriptor.GetAttributes(component).Matches(webControlFilter)) {
                    return true;
                }
            }
            return false;
        }
        
        private class LocalUIItem : PropertyValueUIItem {
            PropertyBinding binding;

            internal LocalUIItem(ManagedPropertiesService mpService, PropertyBinding binding, Bitmap bmp) : 
                    base(bmp, new PropertyValueUIItemInvokeHandler(mpService.OnPropertyValueUIItemInvoke), binding.Key) {
                this.binding = binding;
            }

            internal PropertyBinding Binding {
                get {
                    return binding;
                }
            }
        }

        class AppSettingsReaderDesignTime : AppSettingsReader {
            public AppSettingsReaderDesignTime() {}

            private ManagedPropertiesService managedProperties;
            private ManagedPropertySerializer serializer;
            private IDesignerSerializationManager manager;
            private IDesignerHost host;
            
            public AppSettingsReaderDesignTime(ManagedPropertySerializer serializer, ManagedPropertiesService managedProperties, IDesignerSerializationManager manager) {
                this.serializer = serializer;
                this.managedProperties = managedProperties;
                this.manager = manager;
            }
                                
            public new object GetValue(string key, Type type) {
                
                // We need to update our bindings collection
                // This takes a bit of work, because currently we don't know the
                // component or the property.  However, we can use the context
                // stack to discover this information.
                //
                IComponent component;
                PropertyDescriptor property;
                object returnValue = null;
                
                serializer.GetBindingDataFromContext(manager, out component, out property);
                
                if (component != null && property != null) {
                    PropertyBinding binding = managedProperties.Bindings[component, property];
                    if (binding == null) {
                        if (host == null) {
                            host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                        }
                        
                        // if (host == null) ...

                        // didn't find one. Create one.
                        binding = new PropertyBinding(host);
                        binding.Component = component;
                        binding.Property = property;
                        managedProperties.Bindings.Add(binding);
                    }

                    binding.Key = (string)key;
                    binding.Bound = true;
                    binding.Enabled = false;                   

                    try {
                        // If this is not a valid key in the settings store, bail out.
                        if (managedProperties.settingsStore.ValueExists((string)key)) {
                            string configFileValue = (string)managedProperties.settingsStore.GetValue((string)key);
                            if (managedProperties.SetPropValueToString(component, property, configFileValue)) {
                                returnValue = (configFileValue == null ? null : Convert.ChangeType(configFileValue, type));
                                binding.Enabled = true;
                            }
                        }
                    }
                    catch(Exception) {}

                    if (!binding.Enabled) {
                        // Here we know that either
                        //   1. there is no config file
                        //   2. the key is missing the config file
                        //   3. the value was not parsable as the right type
                        //   or
                        //   4. the parsed value wasn't assignable into the property
                        // so we return the current value.
                        returnValue = property.GetValue(component);
                    } 
                }
               
                return returnValue;
            }
        }                                                           

        /// <summary>
        ///     This class implements IDictionary on top of our binding collection.  When someone
        ///     asks for a key here, we pull it out of the vsSettingStore.
        /// </summary>
        private class ManagedPropertiesNameValueCollection : NameValueCollection {
            private AppSettingsReaderDesignTime wrapped;

            public ManagedPropertiesNameValueCollection(ManagedPropertySerializer serializer, ManagedPropertiesService managedProperties, IDesignerSerializationManager manager) {
                wrapped = new AppSettingsReaderDesignTime(serializer, managedProperties, manager);
            }
                                
            public override string Get(string key) {
                object returnValue = wrapped.GetValue(key, typeof(string));
                return (returnValue == null) ? null : returnValue.ToString();
            }
        }                     

    
        /// <summary>
        ///     Our serializer.
        /// </summary>
        private class ManagedPropertySerializer : CodeDomSerializer {
            private ManagedPropertiesService managedProperties;
            private CodeDomSerializer delegateSerializer;
            
            public ManagedPropertySerializer(ManagedPropertiesService managedProperties, CodeDomSerializer delegateSerializer) {
                this.managedProperties = managedProperties;
                this.delegateSerializer = delegateSerializer;
            }
            
            /// <summary>
            ///     This is the name of the configuration settings object we declare
            ///     on the component surface.
            /// </summary>
            private static string ConfigurationSettingsName {
                get {
                    return "configurationAppSettings";
                }
            }
            
            /// <summary>
            ///     Deserilizes the given CodeDom object into a real object.  This
            ///     will use the serialization manager to create objects and resolve
            ///     data types.  The root of the object graph is returned.
            /// </summary>
            /// <param name='manager'>
            ///     A serialization manager interface that is used during the deserialization
            ///     process.
            /// </param>
            /// <param name='codeObject'>
            ///     A CodeDom object to deserialize.
            /// </param>
            /// <returns>
            ///     An object representing the deserialized CodeDom object.
            /// </returns>
            public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
                Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "Deserialize()");
                managedProperties.Serializing = false;
                
                object instance = null;
                
                // Now look for things we understand.
                //
                if (codeObject is CodeStatementCollection) {
                    foreach(CodeStatement element in (CodeStatementCollection)codeObject) {
                        if (element is CodeVariableDeclarationStatement) {
                            CodeVariableDeclarationStatement statement = (CodeVariableDeclarationStatement)element;
                            
                            // Add a serialization complete event handler so we know when we're done.
                            //
                            manager.SerializationComplete += new EventHandler(managedProperties.OnSerializationComplete);
                            
                            // We create the setting container ouselves here because it's not just a straight
                            // parse of the code.
                            //
                            if (statement.Name.Equals(ConfigurationSettingsName)) {
                                // Okay, we know that this is the declaration for the variable with ConfigurationSettingsName, 
                                // but it might be the old code spit (which will give us a NameValueCollection) or the new type
                                // which will be a AppSettingsReader.

                                if (statement.Type.BaseType == "System.Collections.Specialized.NameValueCollection") {
                                    instance = new ManagedPropertiesNameValueCollection(this, managedProperties, manager);
                                    if (!managedProperties.DeclarationAdded) {
                                        managedProperties.DeclarationAdded = true;
                                        manager.SetName(instance, ConfigurationSettingsName);
                                    }
                                } 
                                else if (statement.Type.BaseType == "System.Configuration.AppSettingsReader") {
                                    instance = new AppSettingsReaderDesignTime(this, managedProperties, manager); //ManagedPropertiesNameValueCollection(this, managedProperties, manager);
                                    if (!managedProperties.DeclarationAdded) {
                                        managedProperties.DeclarationAdded = true;
                                        manager.SetName(instance, ConfigurationSettingsName);
                                    }
                                }
                            }
                        }
                    }
                }
                else if (codeObject is CodeExpression) {
                
                    // Not a statement collection.  This must be an expression.  We just let
                    // the base serializer do the work of resolving it here.  The magic
                    // happens when we associate an instance of ManagedPropertiesSettingContainer
                    // with the name "settings", which allows the rest of the 
                    // serializers to just execute code.
                    //
                    instance = DeserializeExpression(manager, null, (CodeExpression)codeObject);
                    if (instance is CodeExpression) {
                        instance = null;
                    }
                }
                
                return instance;
            }
            
            /// <summary>
            ///     This is called by the dynamic properties dictionary
            ///     in order to recover the component and property the dictionary
            ///     is binding to.  We will need to invoke protected methods on
            ///     our base class for this, which is why the method lives
            ///     here.
            /// </summary>
            public void GetBindingDataFromContext(IDesignerSerializationManager manager, out IComponent component, out PropertyDescriptor property) {
            
                component = null;
                property = null;
                
                // First, see if there is a CodeStatement on the context stack.  
                // This will be the closest statement that we are deserializing.
                // We support two kinds of code statements:  CodeAssignStatements and
                // a CodeExpressionStatement that contains a CodeMethodInvokeExpression.
                //
                CodeStatement statement = (CodeStatement)manager.Context[typeof(CodeStatement)];
                if (statement is CodeAssignStatement) {
                
                    // Now verify that the LHS of this statement is a property 
                    // reference expression.
                    //
                    CodeAssignStatement assignStatement = (CodeAssignStatement)statement;
                    
                    if (assignStatement.Left is CodePropertyReferenceExpression) {
                        CodePropertyReferenceExpression propertyRef = (CodePropertyReferenceExpression)assignStatement.Left;
                        
                        object target = DeserializeExpression(manager, null, propertyRef.TargetObject);
                        if (target is IComponent) {
                            component = (IComponent)target;
                            
                            // Now do the property descriptor.
                            //
                            property = TypeDescriptor.GetProperties(component)[propertyRef.PropertyName];
                        }
                    }
                }
                else if (statement is CodeExpressionStatement) {
                    // This wasn't a code assign statement.  It could be a method invoke,
                    // if this was an extender property.
                    //
                    CodeExpressionStatement expStatement = (CodeExpressionStatement)statement;
                    if (expStatement.Expression is CodeMethodInvokeExpression) {
                        CodeMethodInvokeExpression methodInvoke = (CodeMethodInvokeExpression)expStatement.Expression;
                        CodeMethodReferenceExpression methodRef = methodInvoke.Method;
                        
                        // Does this method name start with "Set"?  If so, it could be an extender.
                        //
                        if (methodRef.MethodName.StartsWith("Set")) {
                            string propName = methodRef.MethodName.Substring(3);
                            
                            object target = DeserializeExpression(manager, null, methodRef.TargetObject);
                            if (target is IComponent) {
                                component = (IComponent)target;
                                property = TypeDescriptor.GetProperties(component)[propName];
                            }
                        }
                    }
                }
            }
        
            /// <summary>
            ///     Serializes the given object into a CodeDom object.
            /// </summary>
            /// <param name='manager'>
            ///     A serialization manager interface that is used during the deserialization
            ///     process.
            /// </param>
            /// <param name='value'>
            ///     The object to serialize.
            /// </param>
            /// <returns>
            ///     A CodeDom object representing the object that has been serialized.
            /// </returns>
            public override object Serialize(IDesignerSerializationManager manager, object value) {
                Debug.WriteLineIf(managedPropertiesSwitch.TraceVerbose, "Serialize() - value = " + (value == null ? "<null>" : value.ToString()));
                managedProperties.Serializing = true;
            
                // We have attached ourself to every type that we support.  This means that anytime
                // that type needs to be serialized, we'll be invoked, including property sets, 
                // method invokes, local variable initialization, etc.  So, we have to do some
                // work here to see if we should actually handle the serialization of the object
                // through dynamic properties.
                //
                
                // First step:  Are we serializing a property?  If we are, then there will be
                // a PropertyDescriptor on the context stack.
                //
                PropertyDescriptor property = (PropertyDescriptor)manager.Context[typeof(PropertyDescriptor)];
                if (property == null) {
                
                    // We are not serializing a property, so we don't care.  Delegate to the
                    // serializer we replaced.
                    //
                    return delegateSerializer.Serialize(manager, value);
                }

                // Next, look up this property in our binding collection.
                //
                PropertyBinding binding = null;
                IComponent component = (IComponent)manager.Context[typeof(IComponent)];
                
                if (component != null && component.Site != null) {
                    binding = managedProperties.Bindings[component, property];
                    if (binding != null && !binding.Bound) {
                        binding = null;
                    }
                }
                
                if (binding == null) {
                    // The binding collection doesn't have a binding for this
                    // property.  Delegate to the serializer we replaced.
                    //
                    return delegateSerializer.Serialize(manager, value);
                }
                
                // Ok, the property is bound.  Emit the correct CodeDom
                // statements to hook it up.
                //
                
                // Variable declaration.
                //
                if (!managedProperties.DeclarationAdded) {
                    if (SerializeDeclaration(manager)) {
                        managedProperties.DeclarationAdded = true;
                        
                        // Add a serialization complete event handler so we know when we're done.
                        //
                        manager.SerializationComplete += new EventHandler(managedProperties.OnSerializationComplete);
                    }
                    else {
                        // Serialize declaration was unable to write out 
                        // the declaration.  This could mean that the serializer
                        // did not offer the correct information in the
                        // context stack.  Fail gracefully by not
                        // emitting this property.
                        //
                        return delegateSerializer.Serialize(manager, value);
                    }
                }

                // Actual expression, which return to the caller.
                //
                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression(
                                                                new CodeMethodReferenceExpression(
                                                                    new CodeVariableReferenceExpression(ConfigurationSettingsName),
                                                                    "GetValue"
                                                                ),
                                                                new CodeExpression[] { 
                                                                    new CodePrimitiveExpression(binding.Key),
                                                                    new CodeTypeOfExpression(property.PropertyType)
                                                                }   
                                                            );

                return new CodeCastExpression(property.PropertyType, methodInvoke);
            }
            
            /// <summary>
            ///     Serializes a variable declaration to our setting container.
            /// </summary>
            private bool SerializeDeclaration(IDesignerSerializationManager manager) {
            
                // There will be a statement collection on the context stack.  It is
                // in this collection that we add our local variable declaration / init.
                // 
                CodeStatementCollection statements = (CodeStatementCollection)manager.Context[typeof(CodeStatementCollection)];
                
                if (statements == null) {
                    return false;
                }
                
                CodeTypeReference settingContainerTypeRef = new CodeTypeReference(typeof(AppSettingsReader));
                CodeTypeReference settingsTypeRef = new CodeTypeReference(typeof(ConfigurationSettings));
                CodeTypeReference noNameWrapperTypeRef = new CodeTypeReference(typeof(AppSettingsReader));
                
                CodePropertyReferenceExpression propRef = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(typeof(ConfigurationSettings)), "AppSettings");
                
                CodeVariableDeclarationStatement declaration = new CodeVariableDeclarationStatement(settingContainerTypeRef, ConfigurationSettingsName);
                declaration.InitExpression = new CodeObjectCreateExpression(noNameWrapperTypeRef);
                
                statements.Add(declaration);
                return true;
            }
        }
               
    }    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\interfacereflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="InterfaceReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   InterfaceReflector.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace Microsoft.VisualStudio.Designer {

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;
    
    
    /// <devdoc>
    ///     This object implements IReflect and supports the interfaces passed into it.
    /// </devdoc>
    internal class InterfaceReflector : IReflect {
    
        private Type underlyingType;
        private Type[] interfaces;
        private MethodInfo[] methods;
        private FieldInfo[] fields;
        private PropertyInfo[] properties;
        private MemberInfo[] members;
        
        /// <devdoc>
        ///     Ctor.  UnderlyingType is the type that this reflector will report
        ///     as the underlying type.  Interfaces are the set of public 
        ///     interfaces we need to provide reflection info for.
        /// </devdoc>
        public InterfaceReflector(Type underlyingType, Type[] interfaces) {
            this.underlyingType = underlyingType;
            this.interfaces = interfaces;
        }
    
        /// <include file='doc\uex' path='docs/doc[@for="GetMethod"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name and DescriptorInfo which describes the signature
        /// of the method. 
        /// </devdoc>
        ///
        public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers) {
            MethodInfo method = null;
            
            foreach(Type type in interfaces) {
                method = type.GetMethod(name, bindingAttr, binder, types, modifiers);
                if (method != null) {
                    break;
                }
            }
            
            return method;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetMethod1"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name of the method.  If the object implementes multiple methods
        /// with the same name an AmbiguousMatchException is thrown.
        /// </devdoc>
        ///
        public MethodInfo GetMethod(string name, BindingFlags bindingAttr) {
            MethodInfo method = null;
            
            foreach(Type type in interfaces) {
                method = type.GetMethod(name, bindingAttr);
                if (method != null) {
                    break;
                }
            }
            
            return method;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetMethods"]/*' />
        public MethodInfo[] GetMethods(BindingFlags bindingAttr) {
            if (methods == null) {
                Hashtable methodHash = new Hashtable();
                foreach(Type type in interfaces) {
                    MethodInfo[] typeMethods = type.GetMethods(bindingAttr);
                    foreach(MethodInfo typeMethod in typeMethods) {
                        methodHash[new MethodInfoKey(typeMethod)] = typeMethod;
                    }
                }
                
                methods = new MethodInfo[methodHash.Values.Count];
                methodHash.Values.CopyTo(methods, 0);
            }
            
            return methods;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetField"]/*' />
        /// <devdoc>
        /// Return the requestion field if it is implemented by the Reflection object.  The
        /// match is based upon a name.  There cannot be more than a single field with
        /// a name.
        /// </devdoc>
        ///
        public FieldInfo GetField(string name, BindingFlags bindingAttr) {
            FieldInfo field = null;
            
            foreach(Type type in interfaces) {
                field = type.GetField(name, bindingAttr);
                if (field != null) {
                    break;
                }
            }
            
            return field;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetFields"]/*' />
        public FieldInfo[] GetFields(BindingFlags bindingAttr) {
            if (fields == null) {
                Hashtable fieldHash = new Hashtable();
                foreach(Type type in interfaces) {
                    FieldInfo[] typeFields = type.GetFields(bindingAttr);
                    foreach(FieldInfo typeField in typeFields) {
                        fieldHash[typeField.Name] = typeField;
                    }
                }
                
                fields = new FieldInfo[fieldHash.Values.Count];
                fieldHash.Values.CopyTo(fields, 0);
            }
            
            return fields;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetProperty"]/*' />
        /// <devdoc>
        /// Return the property based upon name.  If more than one property has the given
        /// name an AmbiguousMatchException will be thrown.  Returns null if no property
        /// is found.
        /// </devdoc>
        ///
        public PropertyInfo GetProperty(string name, BindingFlags bindingAttr) {
            PropertyInfo property = null;
            
            foreach(Type type in interfaces) {
                property = type.GetProperty(name, bindingAttr);
                if (property != null) {
                    break;
                }
            }
            
            return property;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetProperty1"]/*' />
        /// <devdoc>
        /// Return the property based upon the name and Descriptor info describing the property
        /// indexing.  Return null if no property is found.
        /// </devdoc>
        ///     
        public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
            PropertyInfo property = null;
            
            foreach(Type type in interfaces) {
                property = type.GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
                if (property != null) {
                    break;
                }
            }
            
            return property;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetProperties"]/*' />
        /// <devdoc>
        /// Returns an array of PropertyInfos for all the properties defined on 
        /// the Reflection object.
        /// </devdoc>
        ///     
        public PropertyInfo[] GetProperties(BindingFlags bindingAttr) {
            if (properties == null) {
                Hashtable propertyHash = new Hashtable();
                foreach(Type type in interfaces) {
                    PropertyInfo[] typeProperties = type.GetProperties(bindingAttr);
                    foreach(PropertyInfo typeProperty in typeProperties) {
                        propertyHash[typeProperty.Name] = typeProperty;
                    }
                }
                
                properties = new PropertyInfo[propertyHash.Values.Count];
                propertyHash.Values.CopyTo(properties, 0);
            }
            
            return properties;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetMember"]/*' />
        /// <devdoc>
        /// Return an array of members which match the passed in name.
        /// </devdoc>
        ///     
        public MemberInfo[] GetMember(string name, BindingFlags bindingAttr) {
        
            Hashtable memberHash = null;
            
            foreach(Type type in interfaces) {
                MemberInfo[] members = type.GetMember(name, bindingAttr);
                
                if (members != null) {
                    if (memberHash == null) {
                        memberHash = new Hashtable();
                    }
                    
                    foreach(MemberInfo member in members) {
                        if (member is MethodInfo) {
                            memberHash[new MethodInfoKey((MethodInfo)member)] = member;
                        }
                        else {
                            memberHash[member.Name] = member;
                        }
                    }
                }
            }
            
            if (memberHash != null) {
                MemberInfo[] members = new MemberInfo[memberHash.Values.Count];
                memberHash.Values.CopyTo(members, 0);
                return members;
            }
            
            return null;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="GetMembers"]/*' />
        /// <devdoc>
        /// Return an array of all of the members defined for this object.
        /// </devdoc>
        ///
        public MemberInfo[] GetMembers(BindingFlags bindingAttr) {
            if (members == null) {
                Hashtable memberHash = new Hashtable();
                foreach(Type type in interfaces) {
                    MemberInfo[] typeMembers = type.GetMembers(bindingAttr);
                    foreach(MemberInfo typeMember in typeMembers) {
                        
                        if (typeMember is MethodInfo) {
                            memberHash[new MethodInfoKey((MethodInfo)typeMember)] = typeMember;
                        }
                        else {
                            memberHash[typeMember.Name] = typeMember;
                        }
                    }
                }
                
                members = new MemberInfo[memberHash.Values.Count];
                memberHash.Values.CopyTo(members, 0);
            }
            
            return members;
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="InvokeMember"]/*' />
        /// <devdoc>
        /// Description of the Binding Process.
        /// We must invoke a method that is accessable and for which the provided
        /// parameters have the most specific match.  A method may be called if
        /// 1. The number of parameters in the method declaration equals the number of 
        /// arguments provided to the invocation
        /// 2. The type of each argument can be converted by the binder to the
        /// type of the type of the parameter.
        /// 
        /// The binder will find all of the matching methods.  These method are found based
        /// upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
        /// of methods is filtered by the name, number of arguments and a set of search modifiers
        /// defined in the Binder.
        /// 
        /// After the method is selected, it will be invoked.  Accessability is checked
        /// at that point.  The search may be control which set of methods are searched based
        /// upon the accessibility attribute associated with the method.
        /// 
        /// The BindToMethod method is responsible for selecting the method to be invoked.
        /// For the default binder, the most specific method will be selected.
        /// 
        /// This will invoke a specific member...
        /// @exception If <var>invokeAttr</var> is CreateInstance then all other
        /// Access types must be undefined.  If not we throw an ArgumentException.
        /// @exception If the <var>invokeAttr</var> is not CreateInstance then an
        /// ArgumentException when <var>name</var> is null.
        /// @exception ArgumentException when <var>invokeAttr</var> does not specify the type
        /// @exception ArgumentException when <var>invokeAttr</var> specifies both get and set of
        /// a property or field.
        /// @exception ArgumentException when <var>invokeAttr</var> specifies property set and
        /// invoke method.
        /// </devdoc>
        ///  
        public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters) {
        
            foreach(Type type in interfaces) {
            
                BindingFlags queryAttr = invokeAttr;
                queryAttr &= ~BindingFlags.InvokeMethod;
                queryAttr |= (BindingFlags.Public | BindingFlags.Instance);
                
                MemberInfo[] members = type.GetMember(name, queryAttr);
                if (members != null && members.Length > 0) {
                    try {
                        return type.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
                    }
                    catch (MissingMethodException) {
                    }
                }
            }
            
            throw new MissingMethodException();
        }
        
        /// <include file='doc\uex' path='docs/doc[@for="UnderlyingSystemType"]/*' />
        /// <devdoc>
        /// Return the underlying Type that represents the IReflect Object.  For expando object,
        /// this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        /// </devdoc>
        ///
        public Type UnderlyingSystemType {
            get {
                return underlyingType;
            }
        }
        
        /// <devdoc>
        ///     This is an object we use as a key to a
        ///     hash table.  It implements Equals and
        ///     GetHashCode in such a way is to make
        ///     each MethodInfo unique according to 
        ///     name and parameters.
        /// </devdoc>
        private class MethodInfoKey {
            private MethodInfo method;
            
            /// <devdoc>
            ///     Creates a new MethodInfoKey for the
            ///     given method.
            /// </devdoc>
            public MethodInfoKey(MethodInfo method) {
                this.method = method;
            }
            
            /// <devdoc>
            ///     Determines if this object is equal to
            ///     another.  MethodInfoKey's are considered
            ///     equal if the methods within them are
            ///     compatible with respect to name and
            ///     parameters.
            /// </devdoc>
            public override bool Equals(object obj) {
                MethodInfoKey theirMethodInfoKey = obj as MethodInfoKey;
                if (theirMethodInfoKey == null) {
                    return false;
                }
                
                MethodInfo theirMethod = theirMethodInfoKey.method;
                
                if (!method.Name.Equals(theirMethod.Name)) {
                    return false;
                }
                
                ParameterInfo[] ourParameters = method.GetParameters();
                ParameterInfo[] theirParameters = theirMethod.GetParameters();
                
                if (ourParameters.Length != theirParameters.Length) {
                    return false;
                }
                
                for (int p = 0; p < ourParameters.Length; p++) {
                    if (!ourParameters[p].ParameterType.Equals(theirParameters[p].ParameterType)) {
                        return false;
                    }
                }
                
                return true;
            }
            
            /// <devdoc>
            ///     Returns the hash code for this object.  Hash codes are
            ///     created based on the underlying method name and
            ///     parameters.
            /// </devdoc>
            public override int GetHashCode() {
                int code = method.Name.GetHashCode();
                
                foreach(ParameterInfo p in method.GetParameters()) {
                    code ^= p.ParameterType.GetHashCode();
                }
                
                return code;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\undounitcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="UndoUnitCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   UndoUnitCollection.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace Microsoft.VisualStudio.Designer {
    using System;
    using System.Collections;
    using System.ComponentModel.Design;
    
    
    /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable()]
    public class UndoUnitCollection : ReadOnlyCollectionBase {
        
        /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection.UndoUnitCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UndoUnitCollection() {
        }
        
        /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection.UndoUnitCollection1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UndoUnitCollection(UndoUnitCollection value) {
            InnerList.AddRange(value);
        }
        
        /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection.UndoUnitCollection2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UndoUnitCollection(IUndoUnit[] value) {
            InnerList.AddRange(value);
        }
        
        /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IUndoUnit this[int index] {
            get {
                return ((IUndoUnit)(InnerList[index]));
            }
        }
        
        /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(IUndoUnit value) {
            return InnerList.Contains(value);
        }
        
        /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(IUndoUnit[] array, int index) {
            InnerList.CopyTo(array, index);
        }
        
        /// <include file='doc\UndoUnitCollection.uex' path='docs/doc[@for="UndoUnitCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(IUndoUnit value) {
            return InnerList.IndexOf(value);
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\vscategoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="VSCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {
    
    using System;
    using System.ComponentModel;   
    using System.Diagnostics;

    /// <include file='doc\VSCategoryAttribute.uex' path='docs/doc[@for="VSCategoryAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       CategoryAttribute that can access Visual Studio localized strings.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    internal sealed class VSCategoryAttribute : CategoryAttribute {

        /// <include file='doc\VSCategoryAttribute.uex' path='docs/doc[@for="VSCategoryAttribute.VSCategoryAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.CategoryAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public VSCategoryAttribute(string category) : base(category) {
        }

        /// <include file='doc\VSCategoryAttribute.uex' path='docs/doc[@for="VSCategoryAttribute.GetLocalizedString"]/*' />
        /// <devdoc>
        ///     This method is called the first time the category property
        ///     is accessed.  It provides a way to lookup a localized string for
        ///     the given category.  Classes may override this to add their
        ///     own localized names to categories.  If a localized string is
        ///     available for the given value, the method should return it.
        ///     Otherwise, it should return null.
        /// </devdoc>
        protected override string GetLocalizedString(string value) {
            string localizedValue = base.GetLocalizedString(value);
            if (localizedValue == null) {
                localizedValue = (string)SR.GetObject("VisualStudioCategory_" + value);
            }
            // This attribute is internal, and we should never have a missing resource string.
            //
            Debug.Assert(localizedValue != null, "All VSDesigner category attributes should have localized strings.  Category '" + value + "' not found.");
            return localizedValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\codedom\vscodedomgenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsCodeDomGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace  Microsoft.VisualStudio.Designer.CodeDom {
    using System;
    using System.Text;
    using System.Diagnostics;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.CodeDom.Compiler;
    using System.Windows.Forms.Design;
    using System.Runtime.InteropServices;
    using System.IO;
    using Microsoft.VisualStudio.Designer.CodeDom.XML;
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Interop;
    using System.Reflection;

    using Microsoft.VisualStudio;
    using EnvDTE;

    using CodeNamespace = System.CodeDom.CodeNamespace;
    using System.Globalization;

    /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Generator for interacting with VS + XML code model.  This generator will convert
    ///       method and field CodeDom objects into VS CodeModel elements and add or delete them
    ///       from the DTE CodeCom
    ///    </para>
    /// </devdoc>
    internal class VsCodeDomGenerator : ICodeGenerator {

        // we'll delegate all the calls that we actually want to create
        // code to this guy
        //
        private ICodeGenerator innerGenerator; 
        private VsCodeDomProvider provider;
        private string fileName;
        private bool implementsBodyPoint;
        private __VSDESIGNER_VARIABLENAMING variableNaming;
        private bool checkedVariableNaming;
        private Hashtable eventSignatures;
        private EventHandler ehHandlerOffsets;

        internal VsCodeDomGenerator(ICodeGenerator innerGenerator, VsCodeDomProvider provider) {
            this.innerGenerator = innerGenerator;
            this.provider = provider;
            this.implementsBodyPoint = true;
            this.ehHandlerOffsets = new EventHandler(this.GetHandlerOffsets);
        }
        
        private string FileName {
            get {
                return fileName;
            }
        }
        
        /// <devdoc>
        ///     Access the VS hierarchy using VSHPROPID_DesignerVariableNaming to see if the
        ///     project wants to enforce a particular type of variable naming scheme.
        /// </devdoc>
        private __VSDESIGNER_VARIABLENAMING VariableNaming {
            get {
                if (!checkedVariableNaming) {
                    checkedVariableNaming = true;
                    variableNaming = __VSDESIGNER_VARIABLENAMING.VSDVN_Camel;
                    
                    try {
                        IVsHierarchy hier = provider.Hierarchy;
                        object prop;
                        
                        if (hier != null 
                            && NativeMethods.Succeeded(hier.GetProperty(
                                __VSITEMID.VSITEMID_ROOT, 
                                __VSHPROPID.VSHPROPID_DesignerVariableNaming, 
                                out prop))) {
                                
                            variableNaming = (__VSDESIGNER_VARIABLENAMING)Enum.ToObject(typeof(__VSDESIGNER_VARIABLENAMING), prop);
                        }
                    }
                    catch {
                        Debug.Fail("Project system threw an exception while asking for VSHPROPID_DesignerVariableNaming, VSITEMID_Root");
                    }
                }
                return variableNaming;
            }
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.IsValidIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether
        ///       the specified value is a valid identifier for this language.
        ///    </para>
        /// </devdoc>
        public bool IsValidIdentifier(string value) {
            if (provider.CodeModel != null) {
                return provider.CodeModel.IsValidID(value);
            }
            return innerGenerator.IsValidIdentifier(value);
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.ValidateIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Throws an exception if value is not a valid identifier.
        ///    </para>
        /// </devdoc>
        public void ValidateIdentifier(string value) {
            innerGenerator.ValidateIdentifier(value);

            if (provider.CodeModel != null && !provider.CodeModel.IsValidID(value)) {
                throw new ArgumentException(SR.GetString(SR.SerializerInvalidIdentifier, value));
            }
        }

        public string CreateEscapedIdentifier(string value) {
            return innerGenerator.CreateEscapedIdentifier(value);
        }

        public string CreateValidIdentifier(string value) {
            string identifier = innerGenerator.CreateValidIdentifier(value);
            
            // Now, apply rules
            if (identifier != null && identifier.Length > 0) {
                switch(VariableNaming) {
                    case __VSDESIGNER_VARIABLENAMING.VSDVN_VB:
                        identifier = char.ToUpper(identifier[0], CultureInfo.InvariantCulture) + identifier.Substring(1);
                        break;
                    case __VSDESIGNER_VARIABLENAMING.VSDVN_Camel:
                        identifier = char.ToLower(identifier[0], CultureInfo.InvariantCulture) + identifier.Substring(1);
                        break;
                    default:
                        Debug.Fail("Unknown function naming: " + VariableNaming);
                        break;
                }
            }
            
            return identifier;
        }

        public string GetTypeOutput(CodeTypeReference type) {
            return innerGenerator.GetTypeOutput(type);
        }

        public bool Supports(GeneratorSupport supports) {
            return innerGenerator.Supports(supports);
        }

        private void EnsureHandlesClauseHookups(CodeClass vsClass, ICollection eventAttachStatements) {

            if (vsClass == null || eventAttachStatements == null || eventAttachStatements.Count == 0 || !provider.IsVB) {
                return;
            }

            foreach (CodeAttachEventStatement attachStmt in eventAttachStatements) {

                // fish out the method name
                //
                CodeDelegateCreateExpression listener = attachStmt.Listener as CodeDelegateCreateExpression;
                string methodName = null;

                if (listener == null) {
                    continue;
                }

                methodName = listener.MethodName;
                
                // check to see if the sig matches
                //
                Type delegateType = (Type)attachStmt.UserData[typeof(Delegate)];

                if (delegateType == null) {
                    continue;
                }

                // get a method for the delegate
                //
                CodeMemberMethod codeMethod = GetMethodFromDelegate(methodName, delegateType);

                CodeFunction vsFunction = (CodeFunction)VsFindMember(vsClass.Members, methodName, codeMethod, false, vsCMElement.vsCMElementFunction);
                
                if (vsFunction == null) {
                    Debug.Fail("Failed to find method '" + methodName + "' we should have created this method or it should already be there.");
                    continue;
                }

                
                IEventHandler eh = vsFunction as IEventHandler;
                if (eh != null) {
                    string eventName = GetHookupName(attachStmt, vsClass.Name);
                    if (!eh.HandlesEvent(eventName)) {
                        eh.AddHandler(eventName);
                        if (provider.FullParseHandlers == null) {
                            provider.FullParseHandlers = new Hashtable();
                        }
                        provider.FullParseHandlers[eventName] = codeMethod;
                    }
                }
            }
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.GenerateCodeFromExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code from the specified expression and
        ///       outputs it to the specified textwriter.
        ///    </para>
        /// </devdoc>
        public void GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o) {
            innerGenerator.GenerateCodeFromExpression(e, w, o);   
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.GenerateCodeFromStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        public void GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o) {
            innerGenerator.GenerateCodeFromStatement(e, w, o);   
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.GenerateCodeFromNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        public void GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o) {

            // If the text writer provided is valid and is not a buffer text writer, someone has
            // asked to actually generate all the code to a particular writer and they do not
            // want to shove the code into the file code model.  Let them do it.
            //
            if (IsExternalWriter(w)) {
                innerGenerator.GenerateCodeFromNamespace(e, w, o);
                return;
            }
        
            foreach(CodeTypeDeclaration ctd in e.Types) {
                GenerateCodeFromType(ctd, w, o);
            }
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.GenerateCodeFromCompileUnit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        public void GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o) {

            // If the text writer provided is valid and is not a buffer text writer, someone has
            // asked to actually generate all the code to a particular writer and they do not
            // want to shove the code into the file code model.  Let them do it.
            //
            if (IsExternalWriter(w)) {
                innerGenerator.GenerateCodeFromCompileUnit(e, w, o);
                return;
            }

            try {
                foreach (CodeNamespace ns in e.Namespaces) {
                    GenerateCodeFromNamespace(ns, w, o);
                }
            }
            catch (ExternalException){
                IUIService uiSvc = (IUIService)((IServiceProvider)w).GetService(typeof(IUIService));
                if (uiSvc != null) {
                    uiSvc.ShowMessage(SR.GetString(SR.GlobalEdit));
                }
            }
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.GenerateCodeFromType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        public void GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o) {
        
            // If the text writer provided is valid and is not a buffer text writer, someone has
            // asked to actually generate all the code to a particular writer and they do not
            // want to shove the code into the file code model.  Let them do it.
            //
            if (IsExternalWriter(w)) {
                innerGenerator.GenerateCodeFromType(e, w, o);
                return;
            }
        
            // get the VS Code Element
            //
            CodeClass vsClass = (CodeClass)e.UserData[VsCodeDomParser.VsElementKey];

            // don't have a key on this one, so it's not one that we care about generating.
            //
            if (vsClass == null) {
                return;
            }

            ArrayList methodsToSpit = new ArrayList();
            CodeTypeMemberCollection newMembers = null;
            ArrayList eventsToCheck = null;

            IVsCompoundAction compoundAction = (IVsCompoundAction)((IServiceProvider)w).GetService(typeof(IVsCompoundAction));

            try {
                if (compoundAction != null && !NativeMethods.Succeeded(compoundAction.OpenCompoundAction(SR.GetString(SR.SerializerDesignerGeneratedCode)))) {
                    // if that fails, null it so we don't close it.
                    compoundAction = null;
                }

                CodeDomLoader.StartMark();
                bool inEdit = false;
                try {
                    
                    
                    // Cache our file name for this run.
                    //
                    this.fileName = provider.FileName;
                    
                    // keep track of the prior member so we know where
                    // to insert
                    CodeTypeMember priorMember = null;
        
                    // whip through the fields & methods and add any that we don't already have.
                    // While doing this, we retrieve the original collection from the parser.
                    // This original collection allows us to know what has been deleted.
                    //
    
                    newMembers = new CodeTypeMemberCollection();
                    CodeTypeMemberCollection originalMembers = e.UserData[VsCodeDomParser.VsOriginalCollectionKey] as CodeTypeMemberCollection;
        
                    // We must perform deletes before processing the add list.  Otherwise,
                    // we will end up deleting things we just added, if the user replaced
                    // them.
                    //
                    // If we don't have this key, we chose not to deserialize this class last time, so nothing to clear out.
                    //
                    if (originalMembers != null) {
                        IEnumerator originalEnum = originalMembers.GetEnumerator();
        
                        // clear out the methods that we've generated before...
                        //
                        provider.ClearGeneratedMembers();
        
                        foreach (CodeTypeMember ctm in e.Members) {
                            object vsElement = ctm.UserData[VsCodeDomParser.VsElementKey];
        
                            if (vsElement != null) {
        
                                // This is an existing element.  Check to see if it
                                // matches the position of our original element,
                                // and delete those that are in between.
                                while (originalEnum.MoveNext()) {
                                    if (originalEnum.Current == ctm) {
                                        break;
                                    }
        
                                    // This member isn't in the new collection, so nuke it.
                                    //
                                   VsRemoveMember(vsClass, (CodeTypeMember)originalEnum.Current);
                                }
                            }
                        }
                        // delete any left in the original enum that weren't present in the member list...
                        //
                        while (originalEnum.MoveNext()) {
                            VsRemoveMember(vsClass, (CodeTypeMember)originalEnum.Current);
                        }
                    }
    
                    inEdit = true;
                    provider.StartEdit();
    
    
                    // Now we've done all the deletes.  We need only do the adds, 
                    // and create a new "originalMembers" collection to represent
                    // what's in the class now.
                    //
                    foreach (CodeTypeMember ctm in e.Members) {
                        newMembers.Add(ctm);
        
                        // fish out the element refernece
                        //
                        object vsElement = ctm.UserData[VsCodeDomParser.VsElementKey];
                        CodeElement method = null;
        
                        // if we didn't find an element, this thing is
                        // new so we should add it
                        //
                        if (vsElement == null) {
        
                            // add the new item.
                            //
                            if (ctm is CodeMemberField) {
                                bool addedNew = VsAddField(vsClass, (CodeMemberField)ctm, priorMember);
                                if (!addedNew) {
                                    Debug.Fail("Failed to add new field '" + ctm.Name + "' or field already exists");
                                    continue;
                                }
                            }
                            else if (ctm is CodeMemberMethod) {
                                method = VsAddMethod(vsClass, (CodeMemberMethod)ctm, priorMember); 
    
                                if (method == null) {
                                    // this is very bad...the method creation failed.  eject eject eject!
                                    //
                                    continue;
                                }
                                methodsToSpit.Add(ctm);
                            }
                        }
                        else {
                        
                            // Already have an element here.  If this element is a method, then
                            // we must replace the contents if they have changed.  The way we tell
                            // that the contents have changed is brute-force; we just check a key
                            // that indicates if we had to parse the contents of the method.  If we
                            // did, then we assume it's because someone made a change.  This key is
                            // also setup in VsAddMethod to indicate that we have previously 
                            // written code dom statements here.
                            //
                            if (ctm is CodeMemberMethod) {
                                if (ctm.UserData[VsCodeDomParser.VsGenerateStatementsKey] != null) {
                                    methodsToSpit.Add(ctm);
                                }
                            }
                        }
    
                        if (ctm is CodeMemberField) {
                            provider.AddGeneratedField(e, (CodeMemberField)ctm);
                        }
                        priorMember = ctm;
                    }
    
                }
                finally {
                    if (inEdit) {
                        provider.EndEdit();
                    }
                    
                }
                
                try {
                    provider.StartEdit();
                    StringBuilder sb = new StringBuilder(256);
                    foreach (CodeMemberMethod method in methodsToSpit) {
                        sb.Length = 0;
                        StringWriter sw = new StringWriter(sb);
        
                        CodeFunction vsFunction = method.UserData[VsCodeDomParser.VsElementKey] as CodeFunction;
        
                        Debug.Assert(vsFunction != null, "Failed to get DTE.CodeFunction from CodeMethod!");
        
                        if (vsFunction == null) {
                            continue;
                        }
        
                        // generate and spit the code inside the function using
                        // the generator we were created with.
                        //
                        CodeStatementCollection statements = method.Statements;
                        bool allparsed = statements.Count > 0;
                        foreach (CodeStatement cs in statements) {
                            if (!provider.IsVB || !(cs is CodeAttachEventStatement)) {
                                int lastLength = sb.Length;
                                try {
                                    innerGenerator.GenerateCodeFromStatement(cs, sw, o);
                                }
                                catch (Exception ex) {
                                    // if it's a property, spit a todo statement for it.
                                    //
    
                                    // make sure we're not in the middle of writing stuff...
                                    //
                                    // get code up to the first space
                                    //
                                    string spitCode = sb.ToString(lastLength, sb.Length - lastLength);
                                    sb.Length = lastLength;
                                    if (cs is CodeAssignStatement) {
                                        int spaceIndex = spitCode.IndexOf(' ');
                                        if (spaceIndex != -1) {
                                            spitCode = spitCode.Substring(0, spaceIndex);
                                        }
                                        CodeCommentStatement comment = new CodeCommentStatement("TODO: " + SR.GetString(SR.FailedToGenerateCode, spitCode, ex.Message));
                                        innerGenerator.GenerateCodeFromStatement(comment, sw, o);
                                    }
                                }
                            }
                            else {
                                if (eventsToCheck == null) {
                                    eventsToCheck = new ArrayList();
                                }
                                eventsToCheck.Add(cs);
                            }
        
                            // this prevents us from attempting to spit code
                            // for event handlers that we tried to delete.  We check their contents
                            // before we delete them which makes them look like 
                            // we parse them.
                            //
                            if (allparsed && cs.UserData[CodeDomXmlProcessor.KeyXmlParsedStatement] == null) {
                                allparsed = false;
                            }
                        }
        
                        if (!allparsed && statements.Count > 0 || (statements.Count == 0 &&  (string)method.UserData[VsCodeDomParser.VsGenerateStatementsKey] == VsCodeDomParser.VsGenerateStatementsKey)) {
                            
                            // replace any existing innerds with 
                            // the string from our codegen.
                            //
                            CodeDomLoader.StartMark();
                            string code = sb.ToString();
        
                            CodeDomLoader.EndMark("Generate code");
                                
                            CodeDomLoader.StartMark();
                            method.UserData[VsCodeDomParser.VsGenerateStatementsKey] = VsCodeDomParser.VsGenerateStatementsKey;
                            VsReplaceChildren((CodeElement)vsFunction, code);
                            CodeDomLoader.EndMark("Spit code");
                            method.UserData[typeof(string)] = code;
                        }
                    }
                }
                finally {
                    provider.EndEdit();
                }
    
                // Now stuff our new collection into the ctm's user data so we can find
                // deletes on the next pass.
                //
                e.UserData[VsCodeDomParser.VsOriginalCollectionKey] = newMembers;
                CodeDomLoader.EndMark("StartEdit -> EndEdit");
    
                if (eventsToCheck != null) {
                    EnsureHandlesClauseHookups(vsClass, eventsToCheck);
                }
			}
            finally {
                if (compoundAction != null) {
                    compoundAction.CloseCompoundAction();
                }
            }
    
            CodeDomLoader.StartMark();
            foreach (CodeMemberMethod method in methodsToSpit) {
                
                string code = method.UserData[typeof(string)] as string;
                if (code != null && code.Length > 0) {
                    CodeDomLoader.StartMark();
                    provider.AddGeneratedMethod(e, method);
                    CodeDomLoader.EndMark("Save code");
                }
                method.UserData[typeof(string)] = null;
                method.UserData[typeof(EventHandler)] = ehHandlerOffsets;
            }
            CodeDomLoader.EndMark("Get points");        
        }

        private void GetHandlerOffsets(object sender, EventArgs e) {
            CodeMemberMethod method = sender as CodeMemberMethod;
            if (method != null) {
                CodeFunction vsFunction = method.UserData[VsCodeDomParser.VsElementKey] as CodeFunction;

                // now pick up the position of the method...
                //
                //
                TextPoint bodyPoint = null;
                
                try {
                    // Not everyone implements this.
                    if (implementsBodyPoint) {
                        bodyPoint = vsFunction.GetStartPoint(vsCMPart.vsCMPartNavigate);
                    }
                }
                catch {
                    implementsBodyPoint = false;
                }
                
                if (bodyPoint == null && vsFunction is IMethodXML) {
                    object bodyPointObj;
                    if (((IMethodXML)vsFunction).GetBodyPoint(out bodyPointObj) == 0) {
                        bodyPoint = bodyPointObj as TextPoint;
                    }
                }

                if (bodyPoint != null) {
                    System.Drawing.Point pt = new System.Drawing.Point(bodyPoint.LineCharOffset, bodyPoint.Line); // these numbers are 1-based, we want zero based.
                    method.UserData[typeof(System.Drawing.Point)] = pt;
                    method.LinePragma = new CodeLinePragma(FileName, pt.Y);
                }
            }
        }

        private string GetHookupName(CodeAttachEventStatement stmt, string thisName) {

            string hookupName = stmt.Event.EventName;
            CodeExpression targetObject = stmt.Event.TargetObject;
            bool thisRef = true;

            while (true) {
                if (targetObject is CodeThisReferenceExpression) {
                    if (thisRef) {
                        hookupName = thisName + "." + hookupName;
                    }
                    break;
                }
                else if (targetObject is CodeFieldReferenceExpression) {
                    thisRef = false;
                    CodeFieldReferenceExpression field = (CodeFieldReferenceExpression)targetObject;
                    hookupName = field.FieldName + "." + hookupName;
                    targetObject = field.TargetObject;
                }
                else if (targetObject is CodePropertyReferenceExpression) {
                    thisRef = false;
                    CodePropertyReferenceExpression prop = (CodePropertyReferenceExpression)targetObject;
                    hookupName = prop.PropertyName + "." + hookupName;
                    targetObject = prop.TargetObject;
                }
                else {
                    Debug.Fail("Unknown event target object " + targetObject.GetType().Name);
                    break;
                }
            }
            return hookupName;
        }

        private CodeMemberMethod GetMethodFromDelegate(string name, Type delegateType) {
    
            CodeMemberMethod method = null;

            if (eventSignatures == null) {
                eventSignatures = new Hashtable();
            }
            else if (eventSignatures.Contains(delegateType)) {
                method = (CodeMemberMethod)eventSignatures[delegateType];
            }


            if (method == null) {
                MethodInfo invoke = delegateType.GetMethod("Invoke");
                Debug.Assert(invoke != null, "Failed to get InvokeMethoid from delegate type '" + delegateType.FullName + "'");

                method = new CodeMemberMethod();

                CodeDomLoader.DelegateTypeInfo dti = new CodeDomLoader.DelegateTypeInfo(delegateType);

                method.ReturnType = dti.ReturnType;
                method.Parameters.AddRange(dti.Parameters);
                eventSignatures[delegateType] = method;
            }
            method.Name = name;
            return method;
        }
        
        private bool IsExternalWriter(TextWriter w) {
            if (w == null) return false;
            IServiceProvider p = w as IServiceProvider;
            return (p == null || p.GetService(typeof(Microsoft.VisualStudio.Designer.TextBuffer)) == null);
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.VsAccessFromMemberAttributes"]/*' />
        /// <devdoc>
        ///     Converts a CodeDom MemberAttributes value to the corresponding
        ///     VS DTE Access value.
        /// </devdoc>
        private vsCMAccess VsAccessFromMemberAttributes(MemberAttributes modifiers) {
            vsCMAccess access = 0;
            modifiers = (modifiers & MemberAttributes.AccessMask);

            switch (modifiers) {
                case MemberAttributes.FamilyOrAssembly:
                    access = vsCMAccess.vsCMAccessProjectOrProtected;
                    break;
                case MemberAttributes.Assembly:
                    access = vsCMAccess.vsCMAccessProject;
                    break;
                case MemberAttributes.Public:
                    access = vsCMAccess.vsCMAccessPublic;
                    break;
                case MemberAttributes.Private:
                    access = vsCMAccess.vsCMAccessPrivate;
                    break;
                case MemberAttributes.Family:
                    access = vsCMAccess.vsCMAccessProtected;
                    break;
                default:
                    Debug.Fail("Unknown MemberAttributes: " + modifiers.ToString());
                    access = vsCMAccess.vsCMAccessDefault;
                    break;
            }
            return access;
        }


        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.VsAddField"]/*' />
        /// <devdoc>
        ///     Adds a member variable to the given VS DTE CodeClass object.  This function
        ///     first checks to see if that object already exists before actually doing the add.
        /// </devdoc>
        private bool VsAddField(CodeClass vsParentClass, CodeMemberField newField, CodeTypeMember insertAfter) {

            // make sure the element doesn't already exist.
            //
            CodeElement codeElem = VsFindMember(vsParentClass.Members, newField.Name, null, false, vsCMElement.vsCMElementVariable);
            if (codeElem != null) {
                return false;
            }

            // go ahead and add the new field.
            //
            try {
                vsCMAccess access = VsAccessFromMemberAttributes(newField.Attributes);

                if (provider.IsVB) {
                    // get the type
                    //
                    Type t = provider.TypeLoader.GetType(VsFormatType(newField.Type.BaseType), false);
                    if (t != null && typeof(IComponent).IsAssignableFrom(t)) {
                        access |= (vsCMAccess)VsCodeDomParser.vsCMWithEvents;
                    }
                }

                object insertKey;

                if (insertAfter != null) {
                    if (insertAfter is CodeTypeConstructor) {
                        insertKey = vsParentClass.Name;
                    }
                    else {
                        insertKey = insertAfter.Name;
                    }
                }
                else {
                     insertKey = (object)0;
                }

                object newVar = vsParentClass.AddVariable(newField.Name, VsFormatType(newField.Type.BaseType), insertKey, access, 0);
                Debug.Assert(newVar != null, "Failed to create varaible '" + newField.Name + "' -- this is a failure in the VS CodeModel of the current language, not the designer!");
                CodeVariable codeVar = (CodeVariable)newVar;
                newField.UserData[VsCodeDomParser.VsElementKey] = codeVar;
                
            }
            catch (Exception ex) {
                Debug.Fail("Failed to create varaible '" + newField.Name + "'  -- this is a failure in the VS CodeModel of the current language, not the designer! : " + ex.ToString());
                return false;
            }
            return true;
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.VsAddMethod"]/*' />
        /// <devdoc>
        ///     Adds a member function to the given VS DTE CodeClass object.  This function
        ///     first checks to see if that object already exists before actually doing the add.
        /// </devdoc>
        private CodeElement VsAddMethod(CodeClass vsParentClass, CodeMemberMethod newMethod, CodeTypeMember insertAfter) {

            // check to see if the method we're looking for already exists.
            //
            CodeFunction newFunc = (CodeFunction)VsFindMember(vsParentClass.Members, newMethod.Name, newMethod, true, vsCMElement.vsCMElementFunction);

            if (newFunc == null) {
            
                try {
                    string baseType = VsFormatType(newMethod.ReturnType.BaseType);
    
                    // if we don't get a type we like back,
                    // assume null.
                    //
                    if (baseType == null) {
                        baseType = typeof(void).FullName;
                    }
                    
                    vsCMFunction funcType;
                    
                    if (provider.IsVB && baseType == typeof(void).FullName) {
                        funcType = vsCMFunction.vsCMFunctionSub;
                    }
                    else {
                        funcType = vsCMFunction.vsCMFunctionFunction;
                    }
    
                    // add it!
                    //
                    newFunc = vsParentClass.AddFunction(newMethod.Name, 
                                                        funcType, 
                                                        baseType, 
                                                        (insertAfter == null ? (object)0 : insertAfter.Name), 
                                                        VsAccessFromMemberAttributes(newMethod.Attributes), 
                                                        0);
                }
                catch {
                }
    
                Debug.Assert(newFunc != null, "Failed to create method '" + newMethod.Name + "'  -- this is a failure in the VS CodeModel of the current language, not the designer!");
    
                if (newFunc == null) {
                    return null;
                }
    
                // poke the new vs member into the CodeDom element.  Also mark this element as
                // something we have generated the statement body for, so we will rewrite it
                // later if needed.
                //
                newMethod.UserData[VsCodeDomParser.VsElementKey] = newFunc;
                
                // now that we've added a method, we need to add the parameters
                //
                foreach (CodeParameterDeclarationExpression param in newMethod.Parameters) {
                    // add each parameter to the end of the parameter list.
                    //
                    CodeParameter codeParam = newFunc.AddParameter(param.Name, VsFormatType(param.Type.BaseType), -1);
                    if (codeParam != null && codeParam is IParameterKind) {
                        IParameterKind paramKind = (IParameterKind)codeParam;

                        CodeTypeReference paramType = param.Type;
                        while (paramType.ArrayRank > 0) {
                            paramKind.SetParameterArrayDimensions(paramType.ArrayRank);
                            paramType = paramType.ArrayElementType;
                        }
                        switch (param.Direction) {
                            case FieldDirection.Ref:
                                paramKind.SetParameterPassingMode(PARAMETER_PASSING_MODE.cmParameterTypeInOut);
                                break;
                            case FieldDirection.Out:
                                paramKind.SetParameterPassingMode(PARAMETER_PASSING_MODE.cmParameterTypeOut);
                                break;
                        }
                    }
                }

                // now if this thing supports IEventHandler, we've gotta spit the handles clause
                //
                IEventHandler eh = newFunc as IEventHandler;
                if (eh != null && provider.IsVB) {
                    string compName = (string)newMethod.UserData[typeof(IComponent)];
                    string eventName = (string)newMethod.UserData[typeof(EventDescriptor)];
    
                    if (compName != null && eventName != null) {
                        eventName = compName + "." + eventName;
                        if (!eh.HandlesEvent(eventName)) {
                            eh.AddHandler(eventName);
                            if (provider.FullParseHandlers == null) {
                                provider.FullParseHandlers = new Hashtable();
                            }
                            provider.FullParseHandlers[eventName] = newMethod;
                        }
                        newMethod.UserData[typeof(IComponent)] = null;
                        newMethod.UserData[typeof(EventDescriptor)] = null;
                    }
                }
            }
            return(CodeElement)newFunc;
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.VsFindMember"]/*' />
        /// <devdoc>
        ///     Searches for a member in a CodeElements DTE collection.  If it finds the member,
        ///     it returns it.
        /// </devdoc>
        private CodeElement VsFindMember(CodeElements elements, string name, CodeMemberMethod newMethod, bool checkMethodReturnType, vsCMElement elementKind) {

            CodeElement elem = null;

            // try the quick way first, just search by name.
            //
            try {
                // try to use our internal interface.  This allows us to avoid
                // having an exception be thrown if the item isn't found.
                //
                CodeElements_Internal ceInterface = elements as CodeElements_Internal;
                if (ceInterface != null) {
                    if (NativeMethods.Failed(ceInterface.Item(name, out elem))) {
                        // just in case...
                        //
                        elem = null;
                    }
                }
                else {
                    Debug.Fail("Cast to CodeElements_Internal failed...did the DTE guids change?");
                    elem = elements.Item(name);
                }
                
            }
            catch {
            }

            if (elem == null) {
                return null;
            }

            // if the Kind of what we found matches the Kind we're 
            // looking for, we're in good shape...
            //
            if (elem.Kind == elementKind) {
                switch (elementKind) {
                case vsCMElement.vsCMElementVariable:
                    break;
                    case vsCMElement.vsCMElementFunction:
                        if (newMethod != null) {
                            elem = VsFindMemberMethod((CodeFunction)elem, newMethod, checkMethodReturnType);
                        }
                        break;
                }
                return elem;
            }

            // ugh, we found something but it's the wrong kind, so we have to walk through the whole list...
            //
            foreach (CodeElement codeElem in elements) {

                if (codeElem.Kind != elementKind) {
                    continue;
                }

                if (codeElem.Kind == vsCMElement.vsCMElementVariable && ((CodeVariable)codeElem).Name == name) {
                    return codeElem;
                }
                else if (codeElem.Kind == vsCMElement.vsCMElementFunction) {
                    CodeElement method = VsFindMemberMethod((CodeFunction)codeElem, newMethod, checkMethodReturnType);
                    if (method != null) {
                       return method;
                    }
                }
            }
            return null;
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.VsFindMemberMethod"]/*' />
        /// <devdoc>
        ///     Searches for a method in a list of overloads by comparing return types, access, etc.
        /// </devdoc>
        private CodeElement VsFindMemberMethod(CodeFunction vsFoundElem, CodeMemberMethod newMethod, bool checkMethodReturnType) {

            // check to see if this is the only one.
            //
            if (vsFoundElem.IsOverloaded) {

                // walk the overloads
                CodeElements overloads = vsFoundElem.Overloads;
                IEnumerator methodEnum = overloads.GetEnumerator();
                vsFoundElem = null;
                while (methodEnum.MoveNext()) {
                    // is this it?
                    if (newMethod != null && VsMethodEquals((CodeFunction)methodEnum.Current, newMethod, checkMethodReturnType)) {
                        vsFoundElem = (CodeFunction)methodEnum.Current;
                    }
                }
            }
            else {
                // no overloads, just check the one we got.
                //
                if (newMethod == null || !VsMethodEquals(vsFoundElem, newMethod, checkMethodReturnType)) {
                    vsFoundElem = null;
                }
            }
            return(CodeElement)vsFoundElem;
        }

        private string VsFormatType(string fullTypeName) {
            return fullTypeName.Replace('+', '.');
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.VsMethodEquals"]/*' />
        /// <devdoc>
        ///     Compares a CodeDom method to a VS DTE function and returns true if they are equivelent.
        /// </devdoc>
        private bool VsMethodEquals(CodeFunction vsMethod, CodeMemberMethod codeMethod, bool checkMethodAccess) {

            // first, check the quick stuff: name, access, return type
            //
            string vsReturnType = vsMethod.Type.AsFullName;

            // VS returns "" as a void return type.
            //
            if (vsReturnType == null || vsReturnType.Length == 0) {
                vsReturnType = typeof(void).FullName;
            }

            CodeElements vsParams = vsMethod.Parameters;

            bool quickCheck = (vsMethod.Name == codeMethod.Name && 
                               vsReturnType == VsFormatType(codeMethod.ReturnType.BaseType)
                               && vsParams.Count == codeMethod.Parameters.Count  
                               && (!checkMethodAccess || vsMethod.Access == VsAccessFromMemberAttributes(codeMethod.Attributes)));

            // if that failed, quit.
            //
            if (!quickCheck) {
                return false;
            }
            
            // now check that the parameter types match up.
            //
            IEnumerator vsParamEnum = vsParams.GetEnumerator();
            IEnumerator codeParamEnum = codeMethod.Parameters.GetEnumerator();
            bool paramsEqual = true;
            int totalMoves = codeMethod.Parameters.Count;

            for (;paramsEqual && vsParamEnum.MoveNext() && codeParamEnum.MoveNext(); --totalMoves) {
                try {
                    CodeParameter vsParam = (CodeParameter)vsParamEnum.Current;
                    CodeParameterDeclarationExpression codeParam = (CodeParameterDeclarationExpression)codeParamEnum.Current;
                    
                    CodeTypeRef vsParamType = vsParam.Type;

                    if (vsParamType.TypeKind == vsCMTypeRef.vsCMTypeRefArray) {
                        // asurt 140862 -- it turns out the CodeModel is implemented in such a way that
                        // they don't return an AsFullName for Array types (it just returns ""), and no good way of walking the
                        // rank/dimensions of the array type. So we just walk down until we have a normal type kind
                        // and then check that against our basetype.
                        while (vsParamType.TypeKind == vsCMTypeRef.vsCMTypeRefArray) {
                            vsParamType = vsParamType.ElementType;
                        }
                    }
                    paramsEqual = (vsParamType.AsFullName == VsFormatType(codeParam.Type.BaseType));  

                }
                catch {
                    paramsEqual = false;
                }
            }

            // make sure we got the same number and types.
            //
            return(paramsEqual && totalMoves == 0);
        }

        private void VsRemoveMember(CodeClass vsClass, CodeTypeMember member) {
            CodeElement removeElement = member.UserData[VsCodeDomParser.VsElementKey] as CodeElement;
            Debug.Assert(removeElement != null, "Our populated list has a missing VS CodeModel element");
            vsClass.RemoveMember(removeElement);
                
            // ensure the remove succeeed
            #if DEBUG
                string elemName =  member.Name;
                removeElement = VsFindMember(vsClass.Members, elemName, null, true, (member is CodeMemberField ? vsCMElement.vsCMElementVariable : vsCMElement.vsCMElementFunction));
                if (removeElement != null) {
                    Debug.Fail( "VS CodeModel failed to remove element '" + elemName + "'");
                }   
            #endif 
        }

        /// <include file='doc\VsCodeDomGenerator.uex' path='docs/doc[@for="VsCodeDomGenerator.VsReplaceChildren"]/*' />
        /// <devdoc>
        ///     Replaces the text within an element with the specified text
        /// </devdoc>
        private void VsReplaceChildren(CodeElement vsElement, string text) {

            EditPoint    startPoint = null;
            TextPoint    endPoint = null;

            try {
                startPoint = vsElement.GetStartPoint(vsCMPart.vsCMPartBody).CreateEditPoint();
    		    endPoint = vsElement.GetEndPoint(vsCMPart.vsCMPartBody);
            }
            catch {
            }

            Debug.Assert(startPoint != null && endPoint != null, "Didn't get start point and end point from the language service.  This is a bug in the language service.");
            if (startPoint != null && endPoint != null) {
                // spit in the new text and attempt to format it
                //                 
                startPoint.ReplaceText(endPoint, text + "\r\n", (int)vsEPReplaceTextOptions.vsEPReplaceTextAutoformat);
            }
        }

        [ComImport(), 
         Guid("0CFBC2B5-0D4E-11D3-8997-00C04F688DDE"),
         InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        private interface CodeElements_Internal
        {
        	
        	void NewEnum_PlaceHolder_DontCallMe();
        
        	object DTE_PlaceHolder_DontCallMe();
                    	
            
        	object Parent_PlaceHolder_DontCallMe();
        
            // the whole point of defining this internal interface is so we can use
            // it to call Item and not get an exception thron by the E_INVALIDARG hresult./
            //
        	[PreserveSig()]
        	int Item(object index, out CodeElement codeElement);
        	
        	void Count_PlaceHolder_DontCallMe();
        
            void Reserved1_PlaceHolder_DontCallMe();
        
        	void CreateUniqueID_PlaceHolder_DontCallMe();
        };
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\vssysdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="VSSysDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;

    /// <include file='doc\VSSysDescriptionAttribute.uex' path='docs/doc[@for="VSSysDescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    internal class VSSysDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\VSSysDescriptionAttribute.uex' path='docs/doc[@for="VSSysDescriptionAttribute.VSSysDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public VSSysDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\VSSysDescriptionAttribute.uex' path='docs/doc[@for="VSSysDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\host\designsite.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignSite.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Host {
    
    using Microsoft.VisualStudio.Designer.Host;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;

    /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite"]/*' />
    /// <devdoc>
    ///     this is our design time site object.  It's pretty much run-of the mill except that
    ///     it allows for the addition of arbitrary services.  It also acts as a holding place
    ///     for properties like "visible" that are shadowed (aren't actually passed to the
    ///     component at design time).
    /// </devdoc>
    internal sealed class DesignSite : ISite, IDictionaryService, IExtenderListService {
    
        private static Attribute[] designerNameAttribute = new Attribute[] {new DesignerNameAttribute(true)};
        
        private IComponent   component;
        private DesignerHost host;
        private string       name;
        private Hashtable    dictionary;
        

        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.DesignSite"]/*' />
        /// <devdoc>
        ///     Constructor.  We create the site first, and then associate the site
        ///     with a component.  This allows us to preconfigure values on the site,
        ///     which is a bit more efficient.
        /// </devdoc>
        public DesignSite(DesignerHost host, string name) {
            this.host = host;
            this.component = null;
            this.name = name;
        }

        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.Component"]/*' />
        /// <devdoc>
        ///     Member of ISite that returns the component this site belongs to.
        /// </devdoc>
        public IComponent Component {
            get {
                Debug.Assert(component != null, "Need the component before we've established it");
                return component;
            }
        }


        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.Container"]/*' />
        /// <devdoc>
        ///     Member of ISite that returns the container this site belongs to.
        /// </devdoc>
        public IContainer Container {
            get {
                return host.Container;
            }
        }

        public string Name {
            get {
                return name;
            }
            set {
                if (value == null) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                if (value.Equals(name)) return;

                PropertyDescriptor p;
                bool rootNameChange = component == host.RootComponent;

                if (rootNameChange) {
                    p = TypeDescriptor.GetProperties(component, new Attribute[]{DesignOnlyAttribute.Yes})["Name"];
                }
                else {
                    p = TypeDescriptor.GetProperties(component, designerNameAttribute)["Name"];
                }

                Debug.Assert(p != null, "Unable to obtain a name property for component " + name + ".  This could indicate an error in TypeDescriptor or DesignerHost");
                if (p != null) {
                    p.SetValue(component, value);
                    string oldName = name;
                    name = value;
                    if (rootNameChange) {
                        host.OnRootComponentRename(oldName, name);
                    }
                    
                }
            }
        }

        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Type service) {

            if (service == typeof(IDictionaryService)) {
                return (IDictionaryService)this;
            }
            else if (service == typeof(IExtenderListService)) {
                return (IExtenderListService)this;
            }

            return host.GetService(service);
        }

        public bool DesignMode {
            get {
                return true;
            }
        }

        public void SetComponent(IComponent component) {
            Debug.Assert(this.component == null, "Cannot set a component twice");
            this.component = component;

            if (this.name == null) {
                this.name = host.GetNewComponentName(component.GetType());
            }
        }
        
        public void SetName(string newName) {
            name = newName;
        }

        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.IDictionaryService.GetKey"]/*' />
        /// <devdoc>
        ///     Retrieves the key corresponding to the given value.
        /// </devdoc>
        object IDictionaryService.GetKey(object value) {
            if (dictionary != null) {
                return GetKeyFromObject(dictionary,value);
            }
            return null;
        }

        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.GetKeyFromObject"]/*' />
        /// <devdoc>
        ///     Reverse look-ups an object in a hashtable; given a value, it will return a key.
        /// </devdoc>
        private static object GetKeyFromObject(Hashtable h, object o) {
            foreach(DictionaryEntry de in h) {
                object value = de.Value;
                if (value != null && value.Equals(o)) {
                    return de.Key;
                }
            }
            return null;
        }
        
        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.IDictionaryService.GetValue"]/*' />
        /// <devdoc>
        ///     Retrieves the value corresponding to the given key.
        /// </devdoc>
        object IDictionaryService.GetValue(object key) {
            if (dictionary != null) {
                return dictionary[key];
            }
            return null;
        }

        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.IDictionaryService.SetValue"]/*' />
        /// <devdoc>
        ///     Stores the given key-value pair in an object's site.  This key-value
        ///     pair is stored on a per-object basis, and is a handy place to save
        ///     additional information about a component.
        /// </devdoc>
        void IDictionaryService.SetValue(object key, object value) {
            if (dictionary == null) {
                dictionary = new Hashtable();
            }
            if (value == null) {
                dictionary.Remove(key);
            }
            else {
                dictionary[key] = value;
            }
        }
        
        /// <include file='doc\DesignSite.uex' path='docs/doc[@for="DesignSite.IExtenderListService.GetExtenderProviders"]/*' />
        /// <devdoc>
        ///     Retrieves a list of extender provides for the component.
        ///
        /// </devdoc>
        IExtenderProvider[] IExtenderListService.GetExtenderProviders() {
            //ArrayList list = null;
            
            // This component cannot be extended if it is privately inherited.
            //
            if (!TypeDescriptor.GetAttributes(component).Contains(InheritanceAttribute.InheritedReadOnly)) {
                
                return host.GetExtenderProviders();

                // for performance reasons, we don't want to do this because it gets called all the time.
                // we'll do the check for can extend in the TypeDescriptor when the set of exteders
                // changes.  
                //
                // the net effect of this is clients need to call typedescriptor.refresh if they want
                // to change the status of an extender on a particular component.
                //

                /*IExtenderProvider[] providers = host.GetExtenderProviders();
                for (int i = 0; i < providers.Length; i++) {
                    IExtenderProvider provider = providers[i];
                    
                    if (provider.CanExtend(component)) {
                        if (list == null) {
                            list = new ArrayList();
                        }
                        list.Add(provider);
                    }
                } */
            }
            
            /*if(list == null) {
                return null;
            }
            return(IExtenderProvider[]) list.ToArray(typeof(IExtenderProvider));*/
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\codedom\xml\codedomxmlprocessor.cs ===
//------------------------------------------------------------------------------
/// <copyright file="CodeDOMXmlProcessor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*

 */

namespace Microsoft.VisualStudio.Designer.CodeDom.XML {


    using Microsoft.Win32;
    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Xml;
    using System.Windows.Forms;

    [
    CLSCompliant(false)
    ]
    internal class CodeDomXmlProcessor {

        private static TraceSwitch CodeDOMXmlParseSwitch = new TraceSwitch("CodeDOMXmlProcessor", "CodeDOMXmlProcessor: Debug XML processing");


        private static string[] NameTableStrings = new string[]{
                    "Array",
                    "Expression",
                    "Type",
                    "scope",
                    "variablekind",
                    "Null",
                    "Number",
                    "Boolean",
                    "Char",
                    "String",
                    "true",
                    "ArrayType",
                    "Local",
                    "Argument",
                    "static",
                    "shadows",
                    "overrides",
                    "sealed",
                    "virtual",
                    "abstract",
                    "ExpressionStatement",
                    "name",
                    "Name",
                    "line",
                    "NameRef",
                    "NewArray",
                    "Assignment",
                    "BinaryOperation",
                    "Cast",
                    "NewDelegate",
                    "MethodCall",
                    "NewClass",
                    "Literal",
                    "PropertyAccess",
                    "ThisReference",
                    "Parenthesis",
                    "ArrayElementAccess",
                    "Block",
                    "plus",
                    "concatenate",
                    "equals",
                    "removedelegate",
                    "adddelegate"
          };

        // the top level XML items that we've created
        //
        private ArrayList topLevelItems = new ArrayList();

        // our XML parser
        //
        //private XmlParser parser = new XmlParser();

        // The stack of XmlElementDatas that we've created
        //
        private Stack     itemStack = new Stack();

        // The current element that we're working with
        //
        private XmlElementData currentElement;

        // The stack of elements that we've created
        //
        private Stack     elementStack = new Stack();

        // the name of the current attribute we're processing
        //
        private string    curAttrName;

        // this hashtable has the handlers that we create
        // 
        private Hashtable createHandlers = new Hashtable();
        private bool      handlersInitialized;


        // the name of the file we're parsing from for 
        // line pragmas
        //
        private string    fileName;

        // the name of the method we're parsing for error reporting
        //
        private string    methodName;

        // the last line pragma we encountered
        //
        private CodeLinePragma lastLinePragma;

        // so we don't have to create so many elements.
        // 
        private Stack    garbagePile = new Stack();

        internal const string KeyXmlParsedStatement = "_XmlCodeDomParseStmt";

        private object CreateArrayExpression(XmlElementData xmlElement) {
            /*
            
              <!-- Value for an array initializer. -->
             <ElementType name="Array" content="eltOnly">
                <group order="one">
                    <element type="Array" minOccurs="1" maxOccurs="*"/>
                    <element type="Expression" minOccurs="1" maxOccurs="*"/>
                </group>
             </ElementType>
            
            */

            XmlElementData[] arrayChildren = xmlElement.Children["Array"];

            CodeArrayExpression arrayExpr = new CodeArrayExpression();

            if (arrayChildren.Length == 0) {
                arrayChildren = xmlElement.Children["Expression"];
            }

            if (arrayChildren != null) {
                foreach(XmlElementData xmlChildData in arrayChildren) {
                    CodeExpression exp = CreateExpressionElement(xmlChildData) as CodeExpression;
                    if (exp != null) {
                        arrayExpr.Values.Add(exp);
                    }
                }
            }

            return arrayExpr;
        }


        private object CreateArrayCreateExpression(XmlElementData xmlElement) {
            /*
            
               - <ElementType name="NewArray" content="eltOnly">
                     <!--  the type of the array being created --> 
                     <element type="ArrayType" /> 
                     <!--  its bounds --> 
                     <element type="Bound" minOccurs="1" maxOccurs="*" /> 
                     <!--  the initial value for the array --> 
                     <element type="Expression" minOccurs="1" maxOccurs="*" /> 
                  </ElementType>
              
              */

            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceInfo, "Creating CreateArray element");

            string arrayType = GetElementType(xmlElement);
            
            // drop one set of brackets since we expect an array here.
            //
            if (arrayType.EndsWith("[]")) {
                arrayType = arrayType.Substring(0, arrayType.Length - 2);
            }

            Debug.Assert(arrayType != null, "Failed to find ArrayType for ArrayCreateExpression");

            XmlElementData[] expressions = xmlElement.Children["Expression"];
            CodeExpression[] codeExprs = null;

            int size = -1;

            if (expressions == null) {
                codeExprs = new CodeExpression[0];
            }
            else {
                ArrayList paramList = new ArrayList();

                CodeExpression itemExpr;

                for (int i = 0; i < expressions.Length; i++) {
                    itemExpr = (CodeExpression)CreateExpressionElement(expressions[i]);

                    if (itemExpr is CodeArrayExpression) {
                        paramList.AddRange(((CodeArrayExpression)itemExpr).CreateValueArray());
                    }
                    else {
                        paramList.Add(itemExpr);
                    }
                }

                if (paramList.Count > 0) {
                    codeExprs = new CodeExpression[paramList.Count];
                    paramList.CopyTo(codeExprs, 0);
                }
                else {
                    XmlElementData bounds = xmlElement.Children.FirstChild("Bound");
                    if (bounds != null) {
                        CodePrimitiveExpression primative = GetElementExpression(bounds) as CodePrimitiveExpression;
                        if (primative != null && primative.Value is int) {
                            size = (int)primative.Value;
                        }
                    }
                }
                
            }
            if (size == -1) {
                return new CodeArrayCreateExpression(arrayType, codeExprs);
            }
            else {
                return new CodeArrayCreateExpression(arrayType, size);
            }
            
        }

         private object CreateArrayIndexerExpression(XmlElementData xmlElement) {

            /*<!-- Array element access -->

               <ElementType name="ArrayElementAccess" content="eltOnly">
            
                   <!-- The array to access -->
                   <element type="Expression"/>
            
                   <!-- A series of expressions for the indexes, from left to right -->
                   <element type="Expression" minOccurs="1" maxOccurs="*"/>
               </ElementType>
           */

            XmlElementData[] expressions = xmlElement.Children["Expression"];

            Debug.Assert(expressions != null && expressions.Length >= 2, "Expected 2 or more expressions in ArrayElementAccess");

            CodeExpression arrayExpression = (CodeExpression)CreateExpressionElement(expressions[0]);

            Debug.Assert(arrayExpression != null, "Couldn't get target array from ArrayElementAccess");

            CodeExpression[] indexers = new CodeExpression[expressions.Length - 1];

            for (int i = 1; i < expressions.Length; i++) {
                indexers[i-1] = (CodeExpression)CreateExpressionElement(expressions[i]);
                Debug.Assert(indexers[i-1] != null, "Couldn't get expression for ArrayElementAccess indexer " + (i-1).ToString());
            }
            return new CodeArrayIndexerExpression(arrayExpression, indexers);
         }

         private object CreateArrayTypeReferenceExpression(XmlElementData xmlElement) {
              /*           <!-- array type -->
                <ElementType name="ArrayType" content="eltOnly" order="seq">
                    <AttributeType name="rank" dt:type="int"/>
                    <AttributeType name="NonZeroLowerBound" dt:type="boolean"/>
                    <attribute type="rank"/>
                    <attribute type="NonZeroLowerBound"/>        
                    <element type="Ranks" minOccurs="0" maxOccurs="1"/>  
                    <group order="one">
                        <element type="Type"/>
                        <element type="ArrayType"/>
                    </group>
                </ElementType>
            */
             // this rank will always be one,
             // so we have to process the nested ArrayType items
             //
             int rank = Int32.Parse((string)xmlElement.Attributes["rank"]);

             string typeName = GetElementType(xmlElement);

             // now count up any nested ArrayTypes we got.
             //
             int index = typeName.IndexOf("[]");
             int firstIndex = index;
             for (; index != -1; index = typeName.IndexOf("[]", index + 1) ) {
                 rank++;
             }
             
             // since we've counted up the ranks ... byte[][][] = 3 for example,
             // we now cut off the brackets so we get a bare type....like
             // (type= System.Byte, rank = 3) to pass to the CodeTypeOfExpression.
             //
             if (firstIndex != -1) {
                 typeName = typeName.Substring(0, firstIndex);
             }

             return new CodeTypeOfExpression(new CodeTypeReference(typeName, rank));
         }



        private object CreateAssignStatement(XmlElementData xmlElement) {   
            /*
            
               <ElementType name="Assignment" content="eltOnly">
                 - <!--  the operation associated with the assignment, for +=, etc. --> 
                   <attribute type="binaryoperator" /> 
                 - <!--  the left-hand operand --> 
                   <element type="Expression" /> 
                 - <!--  the right-hand operand --> 
                   <element type="Expression" /> 
                </ElementType>
                
                */

            string binop = (string)xmlElement.Attributes["binaryoperator"];
            XmlElementData[] expressions = xmlElement.Children["Expression"];

            if (binop == null) {
                binop = "equals";
            }

            Debug.Assert(expressions != null && expressions.Length == 2, "Failed to get 2 expressions for Assignement");

            string eventName = null;
            CodeExpression targetObject = null;
            CodeExpression rhs = (CodeExpression)CreateExpressionElement(expressions[1]);

            CodeStatement stmt = null;

            switch (binop) {
                case "equals":
                    stmt = new CodeAssignStatement((CodeExpression)CreateExpressionElement(expressions[0]), rhs);
                    break;
                case "adddelegate":
                    targetObject = GetMemberTargetObject(expressions[0], ref eventName);
                    Debug.Assert(targetObject != null, "Failed to get target object for Assignment LHS");
                    stmt = new CodeAttachEventStatement(targetObject, eventName, rhs);
                    break;
                case "removedelegate":
                    targetObject = GetMemberTargetObject(expressions[0], ref eventName);
                    Debug.Assert(targetObject != null, "Failed to get target object for Assignment LHS");
                    stmt = new CodeRemoveEventStatement(targetObject, eventName, rhs);
                    break;
                default:
                    Debug.Fail("Unknown binaryoperator '" + binop + "'");
                    break;
            }

            if (stmt != null) {
                // get the next expression statement up the tree
                XmlElementData statementParent = GetElementExpressionStatementParent(xmlElement, false);
                if (statementParent != null) {
                    stmt.LinePragma = GetLinePragma(statementParent);
                }
            }

            return stmt;
        }

        private object CreateBaseReferenceExpression(XmlElementData xmlElement) {
            /*
               <ElementType name="BaseReference" content="empty" /> 
            */
            return new CodeBaseReferenceExpression();
        }

        private static Hashtable binopTable = null;

        private CodeBinaryOperatorType GetBinopType(string binaryOperator, out bool success) {
            if (binopTable == null) {
                binopTable = new Hashtable(18);
                binopTable["plus"] = CodeBinaryOperatorType.Add;
                binopTable["concatenate"] = CodeBinaryOperatorType.Add;
                binopTable["minus"] = CodeBinaryOperatorType.Subtract;
                binopTable["times"] = CodeBinaryOperatorType.Multiply;
                binopTable["divide"] = CodeBinaryOperatorType.Divide;
                binopTable["remainder"] = CodeBinaryOperatorType.Modulus;
                binopTable["bitand"] = CodeBinaryOperatorType.BitwiseAnd;
                binopTable["bitor"] = CodeBinaryOperatorType.BitwiseOr;
                //binopTable["bitxor"] = CodeBinaryOperatorType.BitwiseXOr;
                binopTable["logicaland"] = CodeBinaryOperatorType.BooleanAnd;
                binopTable["logicalor"] = CodeBinaryOperatorType.BooleanOr;
                //binopTable["logicalxor"] = CodeBinaryOperatorType.BooleanXOr;
                binopTable["equals"] = CodeBinaryOperatorType.ValueEquality;
                binopTable["notequals"] = CodeBinaryOperatorType.IdentityInequality;
                binopTable["refnotequals"] = CodeBinaryOperatorType.IdentityInequality;
                binopTable["refequals"] = CodeBinaryOperatorType.IdentityEquality;
                binopTable["greaterthan"] = CodeBinaryOperatorType.GreaterThan;
                binopTable["lessthan"] = CodeBinaryOperatorType.LessThan;
                binopTable["greaterthanorequals"] = CodeBinaryOperatorType.GreaterThanOrEqual;
                binopTable["lessthanorequals"] = CodeBinaryOperatorType.LessThanOrEqual;

                /*binopTable["istype"] =
                binopTable["adddelegate"] =
                binopTable["removedelegate"] =
                binopTable["to"] =*/
            }
            object value = binopTable[binaryOperator];

            if (value == null) {
                success = false;
                return(CodeBinaryOperatorType)0;
            }
            success = true;
            return(CodeBinaryOperatorType)value;
        }

        private object CreateBinaryOperatorExpression(XmlElementData xmlElement) {

            /*
               - <ElementType name="BinaryOperation" content="eltOnly">
               - <!--  the operation 
                 --> 
                 <attribute type="binaryoperator" required="yes" /> 
               - <!--  the left-hand operand 
                 --> 
                 <element type="Expression" /> 
               - <!--  the right-hand operand 
                 --> 
                 <element type="Expression" /> 
                 </ElementType>
            
            */

            string binop = (string)xmlElement.Attributes["binaryoperator"];
            XmlElementData[] expressions = xmlElement.Children["Expression"];

            if (binop == null) {
                binop = "equals";
            }
            Debug.Assert(expressions != null && expressions.Length == 2, "Failed to get 2 expressions for Assignement");
            CodeExpression lhs = (CodeExpression)CreateExpressionElement(expressions[0]);
            CodeExpression rhs = (CodeExpression)CreateExpressionElement(expressions[1]);
            CodeBinaryOperatorType binopType = CodeBinaryOperatorType.Add;
            
            bool success;

            binopType = GetBinopType(binop, out success);
            if (!success) {
                Debug.Fail("Unsupported binaryoperator in BinaryOperation '" + binop + "'");   
                return null;
            }

            return new CodeBinaryOperatorExpression(lhs, binopType, rhs);

        }

        private object CreateCastExpression(XmlElementData xmlElement){

            /*
           
             - <ElementType name="Cast" content="eltOnly">
                <element type="Type"/>
              - <!--  True if this is a user-supplied cast --> 
                <attribute type="implicit" /> 
              - <!--  The expression to convert --> 
                <element type="Expression" /> 
                </ElementType>
           */

            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceInfo, "Creating Cast element");

            string castType = GetElementType(xmlElement);

            Debug.Assert(castType != null, "Failed to get type for cast");

            xmlElement = xmlElement.Children.FirstChild("Expression");
            Debug.Assert(xmlElement != null, "Failed to get expression for cast");
            return new CodeCastExpression(castType, (CodeExpression)CreateExpressionElement(xmlElement));
        }

        private object CreateCommentStatement(XmlElementData xmlElement) {
         /*
             <ElementType name="Comment" content="textOnly" dt:type="string">
                    <attribute type="id"/>
                </ElementType>
                */

        
            return new CodeCommentStatement(xmlElement.ElementText);
        }

        private object CreateDelegateCreateExpression(XmlElementData xmlElement){

            /*
               - <ElementType name="NewDelegate" content="eltOnly">
                     <!--  the name of the method being accessed --> 
                     <attribute type="name" /> 
                     <!--  the delegate to create --> 
                     <element type="Type" /> 
                     <!--  expression that defines the object that contains the method to point to --> 
                     <element type="Expression" minOccurs="0" maxOccurs="1" /> 
                     <!--  the type that the method belongs to --> 
                     <element type="Type" /> 
                 </ElementType>
            */

            CodeExpression targetObject = GetElementExpression(xmlElement);
            Debug.Assert(targetObject != null, "Failed to get tareget object for delegate create");
    
            XmlElementData[] types = xmlElement.Children["Type"];
            string delegateType;
            
            if (types != null && types.Length > 1) {
                delegateType = types[types.Length-1].ElementText;
            }
            else {
                delegateType = GetElementType(xmlElement);
            }

            return new CodeDelegateCreateExpression(new CodeTypeReference(delegateType), targetObject, GetElementName(xmlElement));
        }
       
        private object CreateNameReferenceExpression(XmlElementData xmlElement){

            /*
            
              <ElementType name="NameRef" content="eltOnly">
               - <!--  local, field, property, or method variablekind 
                 --> 
                 <attribute type="variablekind" /> 
               - <!--  Name of referenced member or variable 
                 --> 
                 <attribute type="name" /> 
                 <attribute type="key" minOccurs="0" maxOccurs="1" /> 
               - <!--  Expression of thing from which name is being selected, if any 
                 --> 
                 <element type="Expression" minOccurs="0" maxOccurs="1" /> 
               - <!--  Type of which the name is a member, if any 
                 --> 
                 <element type="Type" minOccurs="0" maxOccurs="1" /> 
                 </ElementType>
            */

            string scope = (string)xmlElement.Attributes["variablekind"];

            string name = GetElementName(xmlElement);
            CodeExpression targetObject = GetElementExpression(xmlElement);

            switch (scope) {
                
                case "local":
                    return new CodeVariableReferenceExpression(name);
                case "field": 
                    return new CodeFieldReferenceExpression(targetObject, name);
                case "property":
                    return new CodePropertyReferenceExpression(targetObject, name);
                case "method":
                    return new CodeMethodReferenceExpression(targetObject, name);
                default:
                    // This usually means compilation errors in the code. We want to pretent it is a field
                    // so there is enought information to throw a meaningful error further down.
                    return new CodeFieldReferenceExpression(targetObject, name);
            }
        }

        private object CreateMethodInvokeExpression(XmlElementData xmlElement){ 
            /*
            
              <ElementType name="MethodCall" content="eltOnly">
               - <!--  the name of the method being accessed 
                 --> 
                 <element type="NameRef" /> 
               - <!--  the type that the method belongs to 
                 --> 
                 <element type="Type" minOccurs="0" maxOccurs="1" /> 
               - <!--  the arguments being passed to the method in left-to-right order 
                 --> 
                 <element type="Argument" minOccurs="0" maxOccurs="*" /> 
                 </ElementType>
            */

            string methodName = null;
            CodeExpression targetObject = GetMemberTargetObject(xmlElement, ref methodName);

            return new CodeMethodInvokeExpression(targetObject, methodName, GetElementArguments(xmlElement));
        }

        private object CreateObjectCreateExpression(XmlElementData xmlElement){

            /*
            <ElementType name="NewClass" content="eltOnly">
            - <!--  The class being created 
              --> 
              <element type="Type" /> 
            - <!--  the arguments being passed to the constructor in left-to-right order 
              --> 
              <element type="Argument" minOccurs="0" maxOccurs="*" /> 
              </ElementType>
            */

            string newType = GetElementType(xmlElement);
            Debug.Assert(newType != null, "Couldn't get type for NewClass");

            return new CodeObjectCreateExpression(newType, GetElementArguments(xmlElement));
        }

		private object CreateParenthesesExpression(XmlElementData xmlElement) {
			xmlElement = xmlElement.Children.FirstChild("Expression");
			if (xmlElement != null) {
				return CreateExpressionElement(xmlElement);
			}
			Debug.Fail("Parentheses element didn't have an Expression in it.");
			return null;
		}

        private object CreatePrimitiveExpression(XmlElementData xmlElement){

            /*
            
              <ElementType name="Literal" content="eltOnly">
            - <group order="one">
              <element type="Null" /> 
              <element type="Number" /> 
              <element type="Boolean" /> 
              <element type="Char" /> 
              <element type="String" /> 
              <element type="Array" /> 
              <element type="Type" /> 
              </group>
              </ElementType>
                               
            */

            xmlElement = (XmlElementData)xmlElement.Children[0];
            string strValue = xmlElement.ElementText;
            object value = null;

            switch (xmlElement.ElementName) {
                case "Null": 
                    break;
                case "Number":
                    if (strValue.IndexOf('.') == -1) {

                        // the xml has a 'd' in it for large integers at the end of the number
                        if (strValue.EndsWith("d")) {
                            strValue = strValue.Substring(0, strValue.Length - 1);
                        }
                        try {
                            value = Int32.Parse(strValue, CultureInfo.InvariantCulture);
                        }
                        catch (OverflowException) {
                            try {
                                value = UInt32.Parse(strValue, CultureInfo.InvariantCulture);
                            }
                            catch (OverflowException) {
                                try {
                                    value = Int64.Parse(strValue, CultureInfo.InvariantCulture);
                                }
                                catch (OverflowException) {
                                    try {
                                        value = UInt64.Parse(strValue, CultureInfo.InvariantCulture);
                                    }
                                    catch (OverflowException) {
                                        throw new Exception("Can't parse numeric value: '" + strValue + "'");
                                    }
                                }
                            }
                        }
                    }
                    else {
                        // the xml has a 'd' in it for large integers at the end of the number
                        if (strValue.EndsWith("d")) {
                            strValue = strValue.Substring(0, strValue.Length - 1);
                        }

                        try {
                            value = Double.Parse(strValue, CultureInfo.InvariantCulture);
                        }
                        catch (OverflowException) {
                            throw new Exception("Can't parse numeric value: '" + strValue + "'");
                        }
                    }
                    break;
                case "Boolean":
                    string val = (string)xmlElement.Attributes["value"];
                    value = (val == "true" || strValue == "true");
                    break;
                case "Char":
                    try {
                        if (strValue == null || strValue.Length == 0) {
                            value = (char)0;
                        }
                        else {
                            char ch = strValue[0];

                            // for characters 0x0 - 0x20, Visual Basic encodes the values as 0xE0<char>, so
                            // newline is 0xE00D
                            //
                            if ((ch & (char)0xFF00) == (char)0xE000) {
                                ch &= (char)0x00FF;
                            }
                            value = ch;
                        }
                    }
                    catch {
                        value = (char)0;
                    }
                    break;
                case "String":
                    // null isn't a valid value for string, so if we got a node like
                    // <String></String>, we need to interpret that as "" rather than
                    // null.
                    //
                    if (strValue == null) {
                        strValue = "";
                    }
                    else if (strValue.Length == 1 && (strValue[0] & (char)0xFF00) == (char)0xE000) {
                        // for characters 0x0 - 0x20, Visual Basic encodes the values as 0xE0<char>, so
                        // newline is 0xE00D
                        //
                        strValue = ((char)(strValue[0] & (char)0x00FF)).ToString();
                    }
                    value = strValue;
                    break;
                case "Array":
                    return xmlElement.CodeDomElement;
                case "Type":
                    return new CodeTypeOfExpression(strValue);
                case "ArrayType":
                    /*<!-- array type -->
                    <ElementType name="ArrayType" content="eltOnly" order="seq">
                        <AttributeType name="rank" dt:type="int"/>
                        <AttributeType name="NonZeroLowerBound" dt:type="boolean"/>
                
                        <attribute type="rank"/>
                        <attribute type="NonZeroLowerBound"/>
                        
                		<element type="Ranks" minOccurs="0" maxOccurs="1"/>   
                    </ElementType>*/
                    return new CodeTypeReferenceExpression(new CodeTypeReference(GetElementType(xmlElement), Int32.Parse((string)xmlElement.Attributes["rank"], CultureInfo.InvariantCulture)));
                default:
                    Debug.Fail("Unknown literal type '" + xmlElement.ElementName + "'");
                    return null;
            }

            return new CodePrimitiveExpression(value);

        }

        private object CreatePropertyReferenceExpression(XmlElementData xmlElement){
            /*
               <ElementType name="PropertyAccess" content="eltOnly">
                   <!--  are we getting or setting the property? --> 
                   <attribute type="accessor" /> 
                   <!--  the name of the property being accessed --> 
                   <element type="NameRef" minOccurs="0" maxOccurs="1" /> 
                   <!--  the type that the property belongs to --> 
                   <element type="Type" minOccurs="0" maxOccurs="1" /> 
                   <!--  the arguments being passed to the method in left-to-right order --> 
                   <element type="Argument" minOccurs="0" maxOccurs="*" /> 
                </ElementType>
           */

            CodeExpression[] codeArgs = GetElementArguments(xmlElement);

            string propName = null;
            CodeExpression targetObject = GetMemberTargetObject(xmlElement, ref propName);
            Debug.Assert(propName != null && targetObject != null, "Couldn't get name and/or taregetObject from PropertyAccess expression");
            Debug.Assert(propName.Equals("Item"), "Indexer on property other than 'Item'");
            CodeIndexerExpression propExpr = new CodeIndexerExpression(targetObject, codeArgs);
            return propExpr;
        }

        private object CreateQuoteExpression(XmlElementData xmlElement) {
            
            string code = xmlElement.ElementText;
            code = code.Replace("\t", "");
            CodeLinePragma pragma = null;
            for (; pragma == null && xmlElement != null; xmlElement = xmlElement.ParentElement) {
                pragma = GetLinePragma(xmlElement);
            }

            if (pragma == null) {
                pragma = this.lastLinePragma;
            }

            string message;

            if (pragma != null) {
                message = SR.GetString(SR.XmlUnknownCodeWithLine, pragma.LineNumber, code, methodName);
            }
            else {
                message = SR.GetString(SR.XmlUnknownCode, code, methodName);
            }
            throw new System.ComponentModel.Design.Serialization.CodeDomSerializerException(message, pragma);
        }

        private object CreateThisReferenceExpression(XmlElementData xmlElement) {
            /*
               <ElementType name="ThisReference" content="empty" /> 
            */
            return new CodeThisReferenceExpression();
        }
        
        private object CreateTypeOfExpression(XmlElementData xmlElement) {
            return new CodeTypeOfExpression(xmlElement.ElementText);
        }

        private object CreateVariableDeclarationStatement(XmlElementData xmlElement){

            /*
            - <ElementType name="Local" content="eltOnly">
                  <attribute type="id" /> 
                  <attribute type="static" /> 
                  <attribute type="instance" /> 
                  <attribute type="implicit" /> 
                  <attribute type="constant" /> 
                - <group order="one">
                     <element type="Type" /> 
                     <element type="ArrayType" /> 
                  </group>
                - <group minOccurs="1" maxOccurs="*" order="seq">
                     <element type="LocalName" /> 
                     <element type="Expression" minOccurs="0" maxOccurs="1" /> 
                  </group>
                </ElementType>
          
          
          */

            string variableType = GetElementType(xmlElement);
            
            int childCount = xmlElement.Children.Count;
            CodeExpression initExpr = null;

            string variableName = GetElementName(xmlElement);

            if (variableName == null) {

                for (int i = 0; i < childCount; i++) {

                    if (((XmlElementData)xmlElement.Children[i]).ElementName == "LocalName") {

                        Debug.Assert(initExpr == null, "XML has given us multiple variable names for a declaration.  While the XML code model supports this, our code model does not.  Why is this code being parsed?");

                        if (initExpr != null) {
                            continue;
                        }

                        variableName = ((XmlElementData)xmlElement.Children[i]).ElementText;
                        if (i < (childCount - 1) && ((XmlElementData)xmlElement.Children[i+1]).ElementName == "Expression") {
                            initExpr = (CodeExpression)CreateExpressionElement((XmlElementData)xmlElement.Children[++i]);
                        }
                        else {
                            initExpr = null;
                        }
                    }
                }
            }
            else {
                initExpr = GetElementExpression(xmlElement);
            }

            CodeVariableDeclarationStatement stmt;

            if (initExpr != null) {
                stmt = new CodeVariableDeclarationStatement(variableType, variableName, initExpr);
            }
            else {
                stmt = new CodeVariableDeclarationStatement(variableType, variableName);
            }
            stmt.LinePragma = GetLinePragma(xmlElement);
            return stmt;
        }


        private CodeExpression[] GetElementArguments(XmlElementData xmlElement) {
            XmlElementData[] args = xmlElement.Children["Argument"];

            CodeExpression[] codeArgs;

            if (args == null) {
                codeArgs = new CodeExpression[0];
            }
            else {
                codeArgs = new CodeExpression[args.Length];

                for (int i = 0; i < codeArgs.Length; i++) {
                    codeArgs[i] = GetElementExpression(args[i]);
                }
            }
            return codeArgs;
        }

        private object CreateExpressionElement(XmlElementData xmlElementData){
            // just delegate down to our first child.
            //
            xmlElementData = (XmlElementData)xmlElementData.Children[0];

            // vs bug where we get 2 nested expression tags...
            if (xmlElementData.ElementName == "Expression") {
                return CreateExpressionElement(xmlElementData);
            }
            return xmlElementData.CodeDomElement;
        }

        private CodeExpression GetElementExpression(XmlElementData xmlElement) {
            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceInfo, "Getting expression elment...");
            Debug.Indent();
            XmlElementData element = xmlElement.Children.FirstChild("Expression");

            try {
                if (element != null) {
                    return(CodeExpression)CreateExpressionElement(element);
                }
            }
            finally {
                Debug.Unindent();
            }
            return null;
        }

        private MemberAttributes GetElementModifiers(XmlElementData xmlElement) {
            Debug.WriteIf(CodeDOMXmlParseSwitch.TraceInfo, "Getting modifiers for '" + xmlElement.ElementName + "': ");
            IEnumerator attrs = xmlElement.Attributes.Keys.GetEnumerator();
            MemberAttributes modifiers = 0;
            while (attrs.MoveNext()) {
                string key = (string)attrs.Current;

                Debug.WriteIf(CodeDOMXmlParseSwitch.TraceInfo, key + ",");

                if (key == "virtual") {
                    modifiers &= ~MemberAttributes.Final;
                }
                else if (key == "static") {
                    modifiers |= MemberAttributes.Static;
                }
                else if (key == "abstract") {
                    modifiers |= MemberAttributes.Abstract;
                }
                else if (key == "shadows") {
                    modifiers |= MemberAttributes.New;
                }
                else if (key == "overrides") {
                    modifiers |= MemberAttributes.Override;
                }
                else if (key == "sealed") {
                    modifiers |= MemberAttributes.Final;
                }
                else if (key == "const") {
                    modifiers |= MemberAttributes.Const;
                }
            }
            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceInfo, ".");
            return modifiers;
        }

        private string GetElementType(XmlElementData xmlData) {
            Debug.WriteIf(CodeDOMXmlParseSwitch.TraceInfo, "Getting code type for '" + xmlData.ElementName + "'...");
            XmlElementData element = xmlData.Children.FirstChild("Type");
            
            if (element == null) {
                element = xmlData.Children.FirstChild("ArrayType");   
                if (element != null) {
                    // we've got an array type here, which has a type inside of it,
                    // so we will append a "[]", and recurse on the type.
                    //
                    return GetElementType(element) + "[]";
                }
            }

            if (element == null) {
                Debug.WriteIf(CodeDOMXmlParseSwitch.TraceInfo, "Couldn't get type for '" + xmlData.ElementName + "'");
                return null;
            }

            string typeName = element.ElementText;

            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceInfo, "Found type is: '" + typeName + "'");
            return typeName;
        }

        // Look for the ExpressionStatement parent of this function
        //
        private XmlElementData GetElementExpressionStatementParent(XmlElementData xmlElementData, bool immediate) {

            int levels = 1;

            XmlElementData parent = xmlElementData.ParentElement;

            while (parent != null && levels >= 0) {
                if (immediate) {
                    levels--;
                }

                if (parent.ElementName == "ExpressionStatement") {
                    return parent;
                }
                parent = parent.ParentElement;
            }
            return null;
        }

        private string GetElementName(XmlElementData xmlElementData) {

            // there is a diff b/t the vb & c# xml here.  c# uses the <Name> child
            // element, while VB uses an attribute 'name'.  they never got lined up
            // on that one, so we'll just live with it.
            //
            string name = (string)xmlElementData.Attributes["name"];

            if (name == null) {
                XmlElementData nameElement = xmlElementData.Children.FirstChild("Name");
                if (nameElement != null) {
                    name = nameElement.ElementText;
                }
            }
            return name;
        }

        private CodeLinePragma GetLinePragma(XmlElementData xmlElementData) {
            string strLine = (string)xmlElementData.Attributes["line"];

            CodeLinePragma pragma  = null;
            if (fileName != null && strLine != null && strLine.Length > 0) {
                try {
                    pragma = new CodeLinePragma(this.fileName, Int32.Parse(strLine, CultureInfo.InvariantCulture) + 1);
                }
                catch {
                }
                this.lastLinePragma = pragma;
            }
            return pragma;
        }

        private CodeExpression GetMemberTargetObject(XmlElementData xmlElementData, ref string member) {
            XmlElementData orig = xmlElementData;
            xmlElementData = xmlElementData.Children.FirstChild("NameRef");
            if (xmlElementData == null) {
                xmlElementData = orig.Children.FirstChild("Expression");
                xmlElementData = xmlElementData.Children.FirstChild("NameRef");
                Debug.Assert(xmlElementData != null, "Couldn't find NameRef");
                if (xmlElementData == null) return null;
            }
            member = GetElementName(xmlElementData);
            xmlElementData = xmlElementData.Children.FirstChild("Expression");
            Debug.Assert(xmlElementData != null, "Couldn't get Expression from NameRef");
            return(CodeExpression)CreateExpressionElement(xmlElementData);
        }

        private void InitHandlers() {
            if (!handlersInitialized) {
                createHandlers["NewArray"] = new CreateCodeExpressionHandler(this.CreateArrayCreateExpression);
                createHandlers["Assignment"] = new CreateCodeExpressionHandler(this.CreateAssignStatement);
                createHandlers["BaseReference"] = new CreateCodeExpressionHandler(this.CreateBaseReferenceExpression);
                createHandlers["BinaryOperation"] = new CreateCodeExpressionHandler(this.CreateBinaryOperatorExpression);
                createHandlers["Cast"] = new CreateCodeExpressionHandler(this.CreateCastExpression);
                createHandlers["NewDelegate"] = new CreateCodeExpressionHandler(this.CreateDelegateCreateExpression);
                createHandlers["NameRef"] = new CreateCodeExpressionHandler(this.CreateNameReferenceExpression);
                createHandlers["MethodCall"] = new CreateCodeExpressionHandler(this.CreateMethodInvokeExpression);
                createHandlers["NewClass"] = new CreateCodeExpressionHandler(this.CreateObjectCreateExpression);
                createHandlers["Literal"] = new  CreateCodeExpressionHandler(this.CreatePrimitiveExpression);
                createHandlers["PropertyAccess"] = new CreateCodeExpressionHandler(this.CreatePropertyReferenceExpression);
                createHandlers["ThisReference"] = new CreateCodeExpressionHandler(this.CreateThisReferenceExpression);
                createHandlers["Local"] = new CreateCodeExpressionHandler(this.CreateVariableDeclarationStatement);
                createHandlers["Array"] = new CreateCodeExpressionHandler(this.CreateArrayExpression);
                createHandlers["Quote"] = new CreateCodeExpressionHandler(this.CreateQuoteExpression);
				createHandlers["Parentheses"] = new CreateCodeExpressionHandler(this.CreateParenthesesExpression);
                createHandlers["Type"] = new CreateCodeExpressionHandler(this.CreateTypeOfExpression);
                createHandlers["ArrayElementAccess"] = new CreateCodeExpressionHandler(this.CreateArrayIndexerExpression);
                createHandlers["Comment"] = new CreateCodeExpressionHandler(this.CreateCommentStatement);
                createHandlers["ArrayType"] = new CreateCodeExpressionHandler(this.CreateArrayTypeReferenceExpression);
                handlersInitialized = true;
            }
        }

        public int ParseXml(string xmlStream, CodeStatementCollection statementCollection, string fileName, string methodName) {

            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "XML: " + xmlStream);

            InitHandlers();

            XmlTextReader reader = new XmlTextReader( new StringReader( xmlStream) );

            for (int i = 0; i < NameTableStrings.Length; i++) {
                reader.NameTable.Add(NameTableStrings[i]);
            }

            this.topLevelItems.Clear();
            try {
                this.fileName = fileName;
                this.methodName = methodName;
                try {
                    Parse(reader);
                }
                catch (System.ComponentModel.Design.Serialization.CodeDomSerializerException) {
                    throw;
                }
                catch (Exception) {
                    if (lastLinePragma != null) {
                        throw new System.ComponentModel.Design.Serialization.CodeDomSerializerException(SR.GetString(SR.XmlParseException, lastLinePragma.LineNumber, methodName), this.lastLinePragma);
                    }
                    else {
                        throw;
                    }    
                }
            }
            finally {
                this.fileName = null;
                this.methodName = null;
            }

            foreach (CodeStatement codeStatement in topLevelItems) {
                statementCollection.Add(codeStatement);
            }
            return topLevelItems.Count;
        }

        private void Parse(XmlReader reader) {
            while ( reader.Read() ) {
                switch (reader.NodeType) {
                    case XmlNodeType.Element:
                        StartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        while ( reader.MoveToNextAttribute() ) {
                            StartAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                            Text(reader.Value);
                            EndAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        }
                        break;

                    case XmlNodeType.EndElement:
                        EndElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        break;

                    case XmlNodeType.Whitespace:
                        Whitespace(reader.Value);
                        break;

                    case XmlNodeType.Text:
                        Text(reader.Value);
                        break;

                    case XmlNodeType.CDATA:
                        CData(reader.Value);
                        break;

                    case XmlNodeType.Comment:
                        Comment(reader.Value);
                        break;

                    case XmlNodeType.ProcessingInstruction:
                        PI(reader.Name, reader.Value);
                        break;
                }
            }
        }

        private XmlElementData GetDataItem(string elementName) {
            XmlElementData dataItem = null;
            if (garbagePile.Count == 0) {
                dataItem = new XmlElementData(elementName);
            }
            else {
                dataItem = (XmlElementData)garbagePile.Pop();
                dataItem.Reset();
                dataItem.ElementName = elementName;
            }
            dataItem.HandlerHash = createHandlers;
            return dataItem;
        }


        private void ReleaseDataItem(XmlElementData dataItem) {
            // we don't actually release an item here, we just release
            // it's children.
            //
            ArrayList children = dataItem.Children;
            int childCount = (children == null ? 0 : children.Count);

            for (int i = 0; i < childCount; i++) {
                ReleaseDataItem((XmlElementData)children[i]);
                garbagePile.Push(children[i]);
            }

            // if this guy isn't parented, push him too
            if (dataItem.ParentElement == null) {
                garbagePile.Push(dataItem);
            }
        }

        public void StartElement(string prefix, string name, string urn) {
            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Starting element '" + name + "'");

            XmlElementData newElement = GetDataItem(name);

            if (currentElement != null) {
                currentElement.Children.Add(newElement);
                newElement.ParentElement = currentElement;  
            }
            else {
                currentElement = null;
            }
            currentElement = newElement;

            if (name != "Block") {
                itemStack.Push(currentElement);
            }
        }

        public void StartChildren() {
        }

        public void FinishChildren(string prefix, string name, string urn) {
        }

        public void EndElement(string prefix, string name, string urn) {
            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Ending element '" + name + "'");

            if (name != "Block") {

                // pop back to the parent.  The XML parser doesn't seem to give us EndElement notifications
                // any more for self-terminating tags like <TAG/>, so we pop until we have a match for the currently
                // ending tag.
                // 
                XmlElementData oldTop = (XmlElementData)itemStack.Peek();

                while (name != oldTop.ElementName) {
                    Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Unexpected termination '" + name + "', trying '" + oldTop.ElementName + "'");
                    EndElement(prefix, oldTop.ElementName, urn);
                    if (itemStack.Count <= 0) {
                        Debug.Fail("Popped off the stack looking for '" + name + "'! Bad XML!!!");
                        return;
                    }
                    oldTop = (XmlElementData)itemStack.Peek();
                }

                // we're in the right state, go ahead and pop.
                itemStack.Pop();

                // we still have to create the element
                //
                object element = currentElement.CodeDomElement;
                int stackCount = itemStack.Count;

                if (element != null && (stackCount == 0 || currentElement.FirstParentWithHandler == null)) {
                    if (element is CodeExpression) {
                        element = new CodeExpressionStatement((CodeExpression)element);

                        // get the next expression statement up the tree
                        XmlElementData statementParent = GetElementExpressionStatementParent(currentElement, false);
                        if (statementParent != null) {
                            ((CodeStatement)element).LinePragma = GetLinePragma(statementParent);
                        }
                    }

                    ((CodeObject)element).UserData[KeyXmlParsedStatement] = KeyXmlParsedStatement;

                    topLevelItems.Add(element);                 
                    ReleaseDataItem(currentElement);
                }

                if (stackCount > 0) {
                    currentElement = (XmlElementData)itemStack.Peek();
                }
                else {
                    currentElement = null;
                }
            }
        }

        public void StartAttribute(string prefix, string name, string urn) {
            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Starting attribute '" + name + "'");
            curAttrName = name;
        }

        public void EndAttribute(string prefix, string name, string urn) {
            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Ending attribute '" + name + "'");
            if (curAttrName != null) {
                // this means it's a boolean attribute with no right hand value.
                //
                currentElement.Attributes[curAttrName] = "";
                curAttrName = null;
            }
        }

        public void Text(string text) {
            if (curAttrName == null) {
                Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Element text '" + currentElement.ElementName + "' is '" + text + "'");
                currentElement.ElementText = text;
            }
            else {
                Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Attribute text '" + curAttrName + "' is '" + text + "'");
                currentElement.Attributes[curAttrName] = text;
                // signal that we've found text
                curAttrName = null;
            }
        }

        public void Whitespace(string text) {
        }

        public void Entity(string name) {
        }

        public void CharEntity(string name, char value) {
        }

        public void NumericEntity(char value, bool hex) {
        }

        // Note: System.XmlParser takes care of <?xml ...?> tag
        //       So we will never be notified if target == "xml"
        // Note: and we don't handle any other target types
        public void PI(string target, string body) {
        }

        public void Comment(string body) {

        }

        public void CData(string text) {
        }

        internal class CodeArrayExpression : CodeExpression {

            private CodeExpressionCollection exprValues;


            public CodeArrayExpression() {
            }


            public CodeArrayExpression(CodeExpression[] values) {
                if (values != null && values.Length > 0) {
                    foreach(CodeExpression codeExpr in values) {
                        Values.Add(codeExpr);
                    }
                }
            }

            public CodeExpression[] CreateValueArray() {
                CodeExpression[] valueArray = new CodeExpression[this.Length];

                if (this.Length > 0) {
                    exprValues.CopyTo(valueArray, 0);
                }
                return valueArray;
            }

            public CodeExpressionCollection Values {
                get {
                    if (exprValues == null) {
                        exprValues = new CodeExpressionCollection();
                    }
                    return exprValues;
                }
            }

            public int Length {
                get {
                    if (exprValues == null) {
                        return 0;
                    }
                    return exprValues.Count;
                }
            }
        }

        protected delegate object CreateCodeExpressionHandler(XmlElementData itemData);

        protected class XmlElementData {
            public string                       ElementName;
            public string                       ElementText;
            private XmlChildren                 children;
            private IDictionary                  attributes;
            private object              codeExpression;
            public  XmlElementData              ParentElement;
            private CreateCodeExpressionHandler    createHandler;
            public  Hashtable                   HandlerHash;
            private bool                        createFailed;
            private object                      parentWithHandler = "checkit";

            public XmlElementData(string elementName) {
                this.ElementName = elementName;
            }

            public IDictionary Attributes {
                get {
                    if (attributes == null) {
                        attributes = new Hashtable();
                    }
                    return attributes;
                }
            }

            public XmlChildren Children {
                get {
                    if (children == null) {
                        children = new XmlChildren();
                    }
                    return children;
                }
            }

            public object CodeDomElement {
                get {
                    if (this.codeExpression == null && CreateHandler != null) {
                        Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceInfo, "Creating code element '" + ElementName + "'");
                        this.codeExpression = CreateHandler(this);
                        createFailed = (codeExpression == null);
                    }
                    return this.codeExpression;
                }
            }

            private CreateCodeExpressionHandler CreateHandler {
                get {
                    if (!createFailed && HandlerHash != null && createHandler == null) {
                        createHandler = (CreateCodeExpressionHandler)HandlerHash[ElementName];
                        if (createHandler == null) {
                            createFailed = true;
                            return null;
                        }
                    }
                    return createHandler;
                }
            }

            public bool HasHandler {
                get {  
                    return(CreateHandler != null);
                }
            }

            public XmlElementData FirstParentWithHandler {
                get {
                    if (parentWithHandler is string) {
                        XmlElementData xmlData = ParentElement;
                        for (; xmlData != null && !xmlData.HasHandler; xmlData = xmlData.ParentElement);
                        parentWithHandler = xmlData;
                    }
                    return(XmlElementData)parentWithHandler;
                }
            }


            public void Reset() {
                ElementName = null;
                ElementText = null;
                codeExpression = null;
                createHandler = null;
                ParentElement = null;
                HandlerHash = null;
                createFailed = false;
                parentWithHandler = "checkit";

                if (attributes != null) {
                    attributes.Clear();
                }
                if (children != null) {
                    children.Clear();
                }
            }

            public override string ToString() {
                string res = ElementName;

                if (ElementText != null) {
                    res += ", text='" + ElementText + "'";
                }

                if (children != null) {
                    res += ", " + children.Count + " children";
                }

                if (codeExpression != null) {
                    res += "expr=" + codeExpression.GetType().Name;
                }

                return res; 
            }

            public class XmlChildren : ArrayList {

                public  XmlElementData FirstChild(string name) {
                    Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Getting first child that is '" + name + "' element");
                    try {
                        Debug.Indent();
                        int childCount = base.Count;
                        for (int i = 0; i < childCount; i++) {
                            XmlElementData child = (XmlElementData)this[i];
                            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Child " + i.ToString() + " is '" + child.ElementName + "'");
                            if (child.ElementName == name) {
                                Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Found a match.");
                                return child;
                            }
                        }
                        Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Didn't find any matches.");
                    }
                    finally {
                        Debug.Unindent();
                    }
                    return null;
                }

                public  XmlElementData[] this[string name] {
                    get {
                        Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Getting children that are '" + name + "' elements");
                        Debug.Indent();
                        ArrayList items = null;
                        int childCount = base.Count;
                        for (int i = 0; i < childCount; i++) {
                            XmlElementData child = (XmlElementData)this[i];
                            Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Child " + i.ToString() + " is '" + child.ElementName + "'");
                            if (child.ElementName == name) {
                                if (items == null) {
                                    items = new ArrayList();
                                }
                                items.Add(this[i]);
                            }
                        }
                        try {
                            if (items == null) {
                                Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Didn't find any matches.");
                                return new XmlElementData[0];
                            }
                            else {
                                Debug.WriteLineIf(CodeDOMXmlParseSwitch.TraceVerbose, "Found " + items.Count.ToString() + " matches.");
                                XmlElementData[] xmlItems = new XmlElementData[items.Count];
                                items.CopyTo(xmlItems, 0);
                                return xmlItems;
                            }
                        }
                        finally {
                            Debug.Unindent();
                        }
                    }
                }

            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\codedom\vscodedomprovider.cs ===
//------------------------------------------------------------------------------
/// <copyright file="VsCodeDomProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace  Microsoft.VisualStudio.Designer.CodeDom {
    using System;
    using System.CodeDom;
    using CodeNamespace = System.CodeDom.CodeNamespace;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.CodeDom.Compiler;
    using System.Diagnostics;
    using System.IO;
    using EnvDTE;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Designer.Shell;
    using System.Globalization;
    
    internal class VsCodeDomProvider : CodeDomProvider, ICodeDomDesignerReload {

    	internal static BooleanSwitch vbBatchGen = new BooleanSwitch("VbBatchGen", "turn on Visual Basic Batch");

        private ProjectItem     projectItem;
        private FileCodeModel   fileCodeModel;
        private CodeModel       codeModel;
        private CodeDomProvider generatorProvider;
        private ICodeGenerator  codeGenerator;
        private ICodeParser     codeParser;
        private IServiceProvider serviceProvider;
        private IVsHierarchy    vsHierarchy;
        private int             itemid;
        private IDictionary     generatedMethods;
        private IDictionary     generatedFields;
        private Hashtable       fullParseHandlers;
        private short           isVB;
        private bool            addedExtender = false;
        private const short ISVB_NOTCHECKED = 0;
        private const short ISVB_YES = 1;
        private const short ISVB_NO = 2;

        private const string GeneratedCodeKey = "_Method_Generated_Code";
        
        internal VsCodeDomProvider(IServiceProvider serviceProvider, ProjectItem projectItem, CodeDomProvider generatorProvider) {
            this.projectItem = projectItem;
            this.serviceProvider = serviceProvider;
            this.generatorProvider = generatorProvider;
        }

        internal ICodeGenerator CodeGenerator {
            get {
                if (codeGenerator == null && generatorProvider != null) {
                    codeGenerator = new VsCodeDomGenerator(generatorProvider.CreateGenerator(), this);
                }
                return codeGenerator;
            }
        }

        internal ICodeParser CodeParser {
            get {
                // Only create a parser if we were able to get to a
                // file code model.  Otherwise, we just don't support it.
                //
                if (codeParser == null && FileCodeModel != null) {
                    codeParser = new VsCodeDomParser(this);
                }
                return codeParser;
            }
        }

        public CodeModel CodeModel {
            get {
                if (codeModel == null && FileCodeModel != null) {
                    ProjectItem pi = FileCodeModel.Parent;
                    if (pi != null) {
                        Project proj = pi.ContainingProject;
                        if (proj != null) {
                            codeModel = proj.CodeModel;
                        }
                    }
                }
                return codeModel;
            }
        }

        public override LanguageOptions LanguageOptions {
            get {
                return generatorProvider.LanguageOptions;
            }
        }
        
        public FileCodeModel FileCodeModel {
            get {
                if (fileCodeModel == null) {
                    if (projectItem != null) {
                        fileCodeModel = projectItem.FileCodeModel;
                        
                        // C# has had trouble here.  Verify that C# isn't giving us
                        // an old file code model
                        Debug.Assert(fileCodeModel == null || fileCodeModel.Parent == projectItem, "FileCodeModel parent is not the correct project item.  This is a problem with the language service.");
                    }
                }
                
                return fileCodeModel;
            }
        }

        private IDictionary GeneratedFields {
            get{
                if (generatedFields == null) {
                    generatedFields = new Hashtable();
                }
                return generatedFields;
            }
        }

        private IDictionary GeneratedMethods {
            get{
                if (generatedMethods == null) {
                    generatedMethods = new Hashtable();
                }
                return generatedMethods;
            }
        }

        /// <devdoc>
        ///    <para>Retrieves the default extension to use when saving files using this code dom provider.</para>
        /// </devdoc>
        public override string FileExtension {
            get {
                string fileExtension = generatorProvider.FileExtension;
                
                if (fileExtension != null) {
                    return fileExtension;
                }
                else {
                    return base.FileExtension;
                }
            }
        }

        public string FileName {
            get {
                // DTE collections are 1-based
                return projectItem.get_FileNames(1);
            }
        }

        internal Hashtable FullParseHandlers {
            get {
                return this.fullParseHandlers;
            }
            set {
                this.fullParseHandlers = value;
            }
        }

        public IVsHierarchy Hierarchy {
            get {
                if (vsHierarchy == null) {
                    vsHierarchy = ShellDocumentManager.GetHierarchyForFile(serviceProvider, FileName, out itemid);
                }
                return vsHierarchy;
            }
        }

        public bool IsVB {
            get {
                if (isVB == ISVB_NOTCHECKED) {
                    isVB = ISVB_NO;
                    
                    if (CodeModel != null) {
                        if (0 == String.Compare(CodeModel.Language, EnvDTE.CodeModelLanguageConstants.vsCMLanguageVB, true, CultureInfo.InvariantCulture)) {
                            isVB = ISVB_YES;
                        }
                    }
                }
                
                return isVB == ISVB_YES;
            }
        }

        public CodeNamespace DefaultNamespace {
            get {
                if (Hierarchy != null) {
                    object o;
                    int hr = vsHierarchy.GetProperty(itemid, __VSHPROPID.VSHPROPID_DefaultNamespace, out o);

                    if (NativeMethods.Succeeded(hr)) {
                        return new CodeNamespace(Convert.ToString(o));
                    }
                }

                // this means we don't have a top level namespace.  Such a shame.
                // but we're tough, we'll just fake one... (SreeramN) Don't think
                // toughing it out is such a good idea.
                //
                return new CodeNamespace("");
            }
        }

        public ITypeResolutionService TypeLoader{
            get{
                // now we have all the created objects, so we walk through the
                // handlers we've found and see which ones are default handlers for those objects.
                //
                ITypeResolutionServiceProvider typeLoaderService = (ITypeResolutionServiceProvider)serviceProvider.GetService(typeof(ITypeResolutionServiceProvider));

                if (typeLoaderService != null) {
                    return typeLoaderService.GetTypeResolutionService(Hierarchy);
                }
                return null;
            }
        }

        public void AddGeneratedField(CodeTypeDeclaration codeType, CodeMemberField field) {
            GeneratedFields[codeType.Name + ':' + field.Name] = field;
        }

        public void AddGeneratedMethod(CodeTypeDeclaration codeType, CodeMemberMethod method) {
            AddGeneratedMethod(codeType, method, null);
        }

        public void AddGeneratedMethod(CodeTypeDeclaration codeType, CodeMemberMethod method, string code) {

            CodeElement vsCodeElement = method.UserData[VsCodeDomParser.VsElementKey] as CodeElement;

            if (vsCodeElement == null) {
                return;
            }


            if (code == null) {
                EditPoint startPoint = vsCodeElement.StartPoint.CreateEditPoint();
                code = startPoint.GetText(vsCodeElement.EndPoint);
            }

            // CONSIDER: we may need a better way to hash this because
            // potentially somebody could add an event handler called InitializeComponent,
            // which would add it to this list and may overwrite the InitializeComponent we
            // actually want here.
            // should we add the member types or the return type or something?
            //
            GeneratedMethods[codeType.Name + ':' + method.Name + ':' + method.Parameters.Count.ToString()] = method;

            method.UserData[GeneratedCodeKey] = code;
        }

        public void ClearGeneratedMembers() {
            if (generatedMethods != null) {
                generatedMethods.Clear();
            }

            if (generatedFields != null) {
                generatedFields.Clear();
            }
        }

        public void EnsureExtender(IServiceProvider sp) {
            if (!this.addedExtender) {
                if (sp != null) {
                    IExtenderProviderService es = (IExtenderProviderService)sp.GetService(typeof(IExtenderProviderService));
                    if (es != null) {
                        es.AddExtenderProvider(new RootComponentNameProvider(sp, (this.LanguageOptions & LanguageOptions.CaseInsensitive) != LanguageOptions.None, CodeGenerator));
                        addedExtender = true;
                    }
                }
            }
        }


        public void StartEdit() {
            IVBFileCodeModelEvents vbfcm = FileCodeModel as IVBFileCodeModelEvents;
            if (vbfcm != null){
                vbfcm.StartEdit();
            }
        }

        public override ICodeGenerator CreateGenerator() {
            return CodeGenerator;
        }

        public override ICodeCompiler CreateCompiler(){
            return null;
        }

        public override ICodeParser CreateParser(){
            return CodeParser;
        }


        public void EndEdit() {
            IVBFileCodeModelEvents vbfcm = FileCodeModel as IVBFileCodeModelEvents;
			if (vbfcm != null){
                vbfcm.EndEdit();
            }
        }

        /// <devdoc>
        ///     Locates the method matching the given method in the named class.
        ///     Returns null if the method wasn't found.
        /// </devdoc>
        private CodeTypeMember FindMatchingMember(CodeCompileUnit compileUnit, string className, CodeTypeMember searchMember, out CodeTypeDeclaration codeTypeDecl) {
                // walk all the public classes in the compile unit
                //
                foreach (CodeNamespace ns in compileUnit.Namespaces) {
                    foreach (CodeTypeDeclaration codeType in ns.Types) {
                        if ((codeType.Attributes & MemberAttributes.Public) != 0 && codeType.Name == className) {
                            // we've found the class, walk it's methods.

                            foreach (CodeTypeMember member in codeType.Members) {

                                if (member.Attributes == searchMember.Attributes && 
                                    member.Name == searchMember.Name && 
                                    searchMember.GetType().IsAssignableFrom(member.GetType())) {
                                
                                    if (searchMember is CodeMemberMethod) {
                                        CodeMemberMethod curMethod = member as CodeMemberMethod;
                                        CodeMemberMethod searchMethod = searchMember as CodeMemberMethod;
                                        if (curMethod.Parameters.Count == searchMethod.Parameters.Count) {
                                            // just to be sure, check the params.
                                            bool paramsEqual = true;
                                            for (int i = 0; i < searchMethod.Parameters.Count; i++) {
                                                if (searchMethod.Parameters[i].Type.BaseType != curMethod.Parameters[i].Type.BaseType) {
                                                    paramsEqual = false;
                                                    break;
                                                }
                                            }
                                            if (paramsEqual) {
                                                codeTypeDecl = codeType;
                                                return curMethod;
                                            }
                                        }
                                    }
                                    else if (searchMember is CodeMemberField) {
                                        CodeMemberField curField = member as CodeMemberField;
                                        CodeMemberField searchField = searchMember as CodeMemberField;
                                        if (curField.Type.BaseType == searchField.Type.BaseType) {
                                                codeTypeDecl = codeType;
                                                return curField;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                codeTypeDecl = null;
                return null;
        }

        /// <devdoc>
        ///     This method allows a code dom provider implementation to provide a different type converter
        ///     for a given data type.  At design time, a designer may pass data types through this
        ///     method to see if the code dom provider wants to provide an additional converter.  
        ///     As typical way this would be used is if the language this code dom provider implements
        ///     does not support all of the values of MemberAttributes enumeration, or if the language
        ///     uses different names (Protected instead of Family, for example).  The default 
        ///     implementation just calls TypeDescriptor.GetConverter for the given type.
        /// </devdoc>
        public override TypeConverter GetConverter(Type type) {
            if (generatorProvider != null) {
                return generatorProvider.GetConverter(type);
            }
            
            return TypeDescriptor.GetConverter(type);
        }
        
        bool ICodeDomDesignerReload.ShouldReloadDesigner(CodeCompileUnit newTree) {

            
                if ((generatedMethods == null || generatedMethods.Count == 0) && (generatedFields == null || generatedFields.Count == 0)) {
                    return true;
                }

                Hashtable handlers = null;
                
                // now that we've got a parsed file, walk through each item that we created, and check
                // to see if it changed at all.
                // 
                char[] splitChars = new char[]{':'};

                CodeTypeDeclaration codeType = null;

                if (generatedFields != null) {

                    foreach (DictionaryEntry de in generatedFields) {
                        string hashName = (string)de.Key;

                        CodeMemberField oldField = de.Value as CodeMemberField;

                        if (oldField == null) {
                            continue;
                        }

                        // this string is in the format
                        // <Type Name>:<Field Name>
                        //
                        string[] names = hashName.Split(splitChars);
                        Debug.Assert(names.Length == 2, "Didn't get 2 items from the name hash string '" + hashName + "'");
                        CodeMemberField parsedField = FindMatchingMember(newTree, names[0], oldField, out codeType) as CodeMemberField;

                        if (parsedField == null) {
                            return true;
                        }
                    }
                }

                if (generatedMethods != null) {

                    foreach (DictionaryEntry de in generatedMethods) {

                        string hashName = (string)de.Key;

                        CodeMemberMethod oldMethod = de.Value as CodeMemberMethod;

                        if (oldMethod == null) {
                            continue;
                        }

                        // this string is in the format
                        // <Type Name>:<Method Name>:<Parameter Count>
                        string[] names = hashName.Split(splitChars);
                        Debug.Assert(names.Length == 3, "Didn't get 3 items from the name hash string '" + hashName  + "'");
                    
                        CodeDomLoader.StartMark();

                        CodeMemberMethod parsedMethod = FindMatchingMember(newTree, names[0], oldMethod, out codeType) as CodeMemberMethod;

                        CodeDomLoader.EndMark("Reload Parse II:" + oldMethod.Name);

                        // if we have differing statment counts, don't even bother looking at code
                        //
                        if (parsedMethod == null) {
                            return true;
                        }

                        CodeElement vsCodeElement = parsedMethod.UserData[VsCodeDomParser.VsElementKey] as CodeElement;

                        if (vsCodeElement == null) {
                            return true;
                        }

                        CodeDomLoader.StartMark();

                        EditPoint startPoint = vsCodeElement.StartPoint.CreateEditPoint();
                    
                        string newCode = startPoint.GetText(vsCodeElement.EndPoint);

                        CodeDomLoader.EndMark("GetCode from VS Element");

                        string oldCode = oldMethod.UserData[GeneratedCodeKey] as string;

                        // okay, let's rock.  if these are different, we need to reload
                        //
                        // sburke: binary compare
                        if (oldCode != newCode) {
                            return true;
                        }
                        else {
                            // add this to the list of things to generate next time in case we don't regenerate.
                            //
                            DictionaryEntry thisDe = de;
                            thisDe.Value = parsedMethod;
                            parsedMethod.UserData[GeneratedCodeKey] = oldCode;
                            parsedMethod.UserData[VsCodeDomParser.VsGenerateStatementsKey] = VsCodeDomParser.VsGenerateStatementsKey;
                        }

                        // pick up the handlers from this class
                        // 
                        if (handlers == null) {
                            handlers = (Hashtable)codeType.UserData[VsCodeDomParser.VbHandlesClausesKey];
                        }
                    }
                }

                if (IsVB) {
                    if ((fullParseHandlers == null) != (handlers == null)) {
                        return true;
                    }
                    if (handlers != null) {
                        
                        // first, a quick check to see if our handlers have changed
                        //
                        string[] handlerNames = new string[handlers.Keys.Count];
                        handlers.Keys.CopyTo(handlerNames, 0);
                        string[] lastHandlerHames = new string [fullParseHandlers.Count];
                        fullParseHandlers.Keys.CopyTo(lastHandlerHames, 0);

                        Array.Sort(handlerNames, InvariantComparer.Default);
                        Array.Sort(lastHandlerHames, InvariantComparer.Default);

                        if (lastHandlerHames.Length != handlerNames.Length) {
                            return true;
                        } 

                        for (int i = 0; i < handlerNames.Length; i++) {
                            if (!handlerNames[i].Equals(lastHandlerHames[i])) {
                                return true;
                            }
                        }

                        // handlers are all the same, make sure they point to the same members
                        //
                        foreach (DictionaryEntry de in fullParseHandlers) {
                            CodeMemberMethod newHandler = handlers[de.Key] as CodeMemberMethod;
                            if (newHandler == null) {
                                return true;
                            }

                            CodeMemberMethod oldHandler = de.Value as CodeMemberMethod;
                            Debug.Assert(oldHandler != null, "Didn't get an old handler?  How?");
                            if (newHandler.Name != oldHandler.Name || 
                                //newHandler.Attributes != oldHandler.Attributes || 
                                newHandler.ReturnType.BaseType != oldHandler.ReturnType.BaseType) {
                                return true;
                            }

                            if (newHandler.Parameters.Count == oldHandler.Parameters.Count) {
                                // just to be sure, check the params.
                                for (int i = 0; i < newHandler.Parameters.Count; i++) {
                                    if (newHandler.Parameters[i].Type.BaseType != newHandler.Parameters[i].Type.BaseType) {
                                        return true;
                                    }
                                }
                            }
                            else {
                                return true;
                            }
                            
                        }
                    }
                }

                return false;
        }

        [
        ProvideProperty("Name", typeof(IComponent))
        ]
        private class RootComponentNameProvider : System.ComponentModel.IExtenderProvider {

            private IServiceProvider sp;
            private IDesignerHost    host;
            private bool             ignoreCase;
            private bool             inSetName;
            private bool             nameFail;
            private ICodeGenerator   codeGenerator;

            public RootComponentNameProvider(IServiceProvider sp, bool ignoreCase, ICodeGenerator gen) {
                this.sp = sp;
                this.host = (IDesignerHost)sp.GetService(typeof(IDesignerHost));
                this.codeGenerator = gen;
                this.ignoreCase = ignoreCase;
            }

            private CodeClass DocumentCodeClass {
                get {
                    CodeTypeDeclaration docType = DocumentCodeType;
                    if (docType != null) {
                        CodeClass vsClass = docType.UserData[VsCodeDomParser.VsElementKey] as CodeClass;
                        return vsClass;
                    }
                    return null;
                }
            }

            private CodeTypeDeclaration DocumentCodeType {
                get {
                    // try to get the code type decl.
                    return (CodeTypeDeclaration)host.GetService(typeof(CodeTypeDeclaration));
                }
            }

             /// <include file='doc\RootComponentNameProvider.uex' path='docs/doc[@for="RootComponentNameProvider.GetName"]/*' />
            /// <devdoc>
            ///     This is an extender property that we offer to all components
            ///     on the form.  It implements the "Modifiers" property, which
            ///     is an enum represneing the "public/protected/private" scope
            ///     of a component.
            /// </devdoc>
            [
            DesignOnly(true),
            SRCategory(SR.CatDesign),
            ParenthesizePropertyName(true)
            ]
            public string GetName(IComponent comp) {
                if (!nameFail) {
                    try {
                        CodeClass vsClass = DocumentCodeClass;
                        if (vsClass != null) {
                            return vsClass.Name;
                        }
                    
                    }
                    catch {
                        nameFail = true;
                        // refresh to remove this extender since it's busted...
                        //
                        TypeDescriptor.Refresh(comp);
                    }
                }
                return "";
            }

            public void SetName(IComponent comp, string value) {
                if (inSetName || host.Loading) {
                    return;
                }

                this.inSetName = true;
                try {
                    CodeClass vsClass = DocumentCodeClass;
                    if (vsClass != null && String.Compare(vsClass.Name, value, this.ignoreCase, CultureInfo.InvariantCulture) != 0) {

                         codeGenerator.ValidateIdentifier(value);

                        // make sure we can make a function name out of this identifier --
                        // this prevents us form accepting escaped names like [Long] for Visual Basic since
                        // that's valid but [Long]_Click is not.
                        //
                        try {
                            codeGenerator.ValidateIdentifier(value + "Handler");
                        }
                        catch {
                            // we have to change the exception back to the original name
                            throw new ArgumentException(SR.GetString(SR.SerializerInvalidIdentifier, value));
                        }
                        
                        // make sure it's not a duplicate of an existing component name
                        //
                        if (host.Container.Components[value] != null) {
                            Exception ex = new Exception(SR.GetString(SR.CODEMANDupComponentName, value));
                            ex.HelpLink = SR.CODEMANDupComponentName;
                            throw ex;
                        }

                        // update the name on the root component
                        //
                        vsClass.Name = value;
                        
                        // update the name on our current codedom tree
                        //
                        CodeTypeDeclaration decl = DocumentCodeType;
                        if (decl != null) {
                            decl.Name = value;
                        }
    
                        // update the name of the root object
                        //
                        if (comp.Site != null) {
                            comp.Site.Name = value;
                        }
                    }
                }
                finally {
                    this.inSetName = false;
                }
            }
        
            bool System.ComponentModel.IExtenderProvider.CanExtend(object extendee) {
                return !nameFail && extendee == host.RootComponent;
            }
        }
   }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\host\designernameattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerNameAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Host {

    using System;

    /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies that the designer for a class belongs to a certain
    ///       category.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple=false, Inherited=true)]
    internal sealed class DesignerNameAttribute : Attribute {
        private bool designerName;

        public static DesignerNameAttribute Default = new DesignerNameAttribute(false);

        public DesignerNameAttribute() : this(false){
        }

        public DesignerNameAttribute(bool designerName) {
            this.designerName = designerName;
        }

        public override bool Equals(object obj) {
            DesignerNameAttribute da = obj as DesignerNameAttribute;

            if (da == null) {
                return false;
            }
            return da.designerName == this.designerName;
        }

        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\host\ierrorreporting.cs ===
//------------------------------------------------------------------------------
// <copyright file="IErrorReporting.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Host {


    internal interface IErrorReporting {
        void ReportErrors(System.Collections.ICollection errorList);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\assemblyobsoleteeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="AssemblyObsoleteEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {

    using System;

    /// <include file='doc\AssemblyObsoleteEventHandler.uex' path='docs/doc[@for="AssemblyObsoleteEventHandler"]/*' />
    /// <devdoc>
    ///      An event that gets raised when an assembly has become obsolete.
    /// </devdoc>
    internal delegate void AssemblyObsoleteEventHandler(object sender, AssemblyObsoleteEventArgs args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\host\documentmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {
    using System.Threading;
    using System.Runtime.InteropServices;   
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    
    using System.Reflection;
    using System.Collections;    
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Drawing;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.PropertyBrowser;
    using System.IO;
    using Microsoft.Win32;

    /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager"]/*' />
    /// <devdoc>
    ///     The document manager is the top level object for all designer
    ///     instances.  There is a single document manager for each instance
    ///     of DevEnv, so all designers and documents share the same
    ///     document manager.
    /// </devdoc>
    public abstract class DocumentManager : IDesignerEventService {

        // Events that we surface
        //
        private static readonly object SELECTION_CHANGED_EVENT = new object();
        private static readonly object DOCUMENT_CHANGED_EVENT = new object();
        private static readonly object DOCUMENT_CREATED_EVENT = new object();
        private static readonly object DOCUMENT_DISPOSED_EVENT = new object();

        // Objects that we maintain and create.
        //
        private ISelectionService       currentSelection;  // the current selection service
        private IDesignerHost           activeDesigner;    // the active document
        private EventHandlerList        eventTable;        // table of events to fire
        private ArrayList               designers;         // array of designer hosts
        private DesignerCollection      documents;         // stashed collection of designer hosts
        private IServiceProvider  provider;          // Where we get outside services from

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.DocumentManager"]/*' />
        /// <devdoc>
        ///     Our public constructor.
        /// </devdoc>
        public DocumentManager(IServiceProvider provider) {
            // DO NOT DELETE -- AUTOMATION BP 1

            this.provider = provider;
            this.eventTable = new EventHandlerList();
            this.designers = new ArrayList();
            Application.ThreadException += new ThreadExceptionEventHandler(this.OnThreadException);
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ActiveDesigner"]/*' />
        /// <devdoc>
        ///     Retrieves the currently active document.
        /// </devdoc>
        public IDesignerHost ActiveDesigner {
            get {
                return activeDesigner;
            }
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.Designers"]/*' />
        /// <devdoc>
        ///      Retrieves a collection of running design documentsin the development environment.
        /// </devdoc>
        public DesignerCollection Designers { 
            get {
                if (documents == null) {
                    documents = new DesignerCollection(designers);
                }
                return documents;
            }
        }
        

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ActiveDesignerChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event ActiveDesignerEventHandler ActiveDesignerChanged {
            add {
                eventTable.AddHandler(DOCUMENT_CHANGED_EVENT, value);
            }
            remove {
                eventTable.RemoveHandler(DOCUMENT_CHANGED_EVENT, value);
            }
        }


        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.DesignerCreated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event DesignerEventHandler DesignerCreated {
            add {
                eventTable.AddHandler(DOCUMENT_CREATED_EVENT, value);
            }
            remove {
                eventTable.RemoveHandler(DOCUMENT_CREATED_EVENT, value);
            }
        }
        

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.DesignerDisposed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event DesignerEventHandler DesignerDisposed {
            add {
                eventTable.AddHandler(DOCUMENT_DISPOSED_EVENT, value);
            }
            remove {
                eventTable.RemoveHandler(DOCUMENT_DISPOSED_EVENT, value);
            }
        }
        

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.SelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler SelectionChanged {
            add {
                eventTable.AddHandler(SELECTION_CHANGED_EVENT, value);
            }
            remove {
                eventTable.RemoveHandler(SELECTION_CHANGED_EVENT, value);
            }
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.CreateDesigner"]/*' />
        /// <devdoc>
        ///     Creates a new instance of a form designer.  This takes a code stream and attempts
        ///     to create a design instance for it.
        /// </devdoc>
        public IDesignerDocument CreateDesigner(DesignerLoader loader) {
            return CreateDesigner(loader, provider);
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.CreateDesigner1"]/*' />
        /// <devdoc>
        ///     Creates a new instance of a form designer.  This uses the given component class
        ///     name as the base component for the class.  The designer for the component
        ///     class is responsible for attaching a code stream if it wants to persist
        ///     information.
        /// </devdoc>
        public IDesignerDocument CreateDesigner(string componentClass) {
            return CreateDesigner(componentClass, provider);
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.CreateDesigner2"]/*' />
        /// <devdoc>
        ///     Creates a new instance of a form designer.  This takes a code stream and attempts
        ///     to create a design instance for it.
        /// </devdoc>
        public IDesignerDocument CreateDesigner(DesignerLoader loader, IServiceProvider provider) {
            DesignerHost dh = new DesignerHost();
            dh.Init(provider, loader);
            return dh;
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.CreateDesigner3"]/*' />
        /// <devdoc>
        ///     Creates a new instance of a form designer.  This uses the given component class
        ///     name as the base component for the class.  The designer for the component
        ///     class is responsible for attaching a code stream if it wants to persist
        ///     information.
        /// </devdoc>
        public IDesignerDocument CreateDesigner(string componentClass, IServiceProvider provider) {
            DesignerHost dh = new DesignerHost();
            ComponentDesignerLoader cs = new ComponentDesignerLoader(componentClass);
            dh.Init(provider, cs);
            return dh;
        }
        
        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.CreateDesignerLoader"]/*' />
        /// <devdoc>
        ///     Creates a designer loader of the given type.
        /// </devdoc>
        public DesignerLoader CreateDesignerLoader(string loaderType) {
        
            Debug.WriteLineIf(Switches.DESIGNERSERVICE.TraceVerbose, "DesignerService::CreateDesignerLoader");

            Type type = Type.GetType(loaderType);

            if (type == null) {
                Debug.WriteLineIf(Switches.DESIGNERSERVICE.TraceVerbose, "\tERROR: Designer loader class " + loaderType + " doesn't exist");
                throw new Exception(SR.GetString(SR.DESIGNERSERVICENoDesignerLoaderClass, loaderType));
            }

            object loader = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);

            if (!(loader is DesignerLoader)) {
                Debug.WriteLineIf(Switches.DESIGNERSERVICE.TraceVerbose, "\tERROR: " + loaderType + " doesn't extend DesignerLoader");
                throw new Exception(SR.GetString(SR.DESIGNERSERVICEBadDesignerLoader, loaderType));
            }

            return (DesignerLoader)loader;
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes the document manager.
        /// </devdoc>
        public virtual void Dispose() {

            eventTable.Dispose();
            designers.Clear();
            provider = null;

            Application.ThreadException -= new ThreadExceptionEventHandler(this.OnThreadException);

            if (currentSelection != null) {
                currentSelection = null;
            }
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.GetCurrentSelection"]/*' />
        /// <devdoc>
        ///     Retrieves the currently available selection.
        /// </devdoc>
        public ISelectionService GetCurrentSelection() {
            return currentSelection;
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of the given service class.  Objects extending
        ///     DocumentManager may override this method to provide their own set of
        ///     global services.
        /// </devdoc>
        protected object GetService(Type serviceClass) {
            if (provider != null) {
                return provider.GetService(serviceClass);
            }
            return null;
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.OnActiveDesignerChanged"]/*' />
        /// <devdoc>
        ///     Extending classes must call this when the active document changes.
        /// </devdoc>
        protected void OnActiveDesignerChanged(ActiveDesignerEventArgs e) {
            activeDesigner = e.NewDesigner;

            ActiveDesignerEventHandler handler = (ActiveDesignerEventHandler)eventTable[DOCUMENT_CHANGED_EVENT];
            if (handler != null) {
                handler.Invoke(this, e);
            }
            
            // Now update the selection events.
            //
            ISelectionService svc = null;
            if (e.NewDesigner != null) {
                svc = (ISelectionService)e.NewDesigner.GetService(typeof(ISelectionService));
            }
            OnSelectionChanged(svc);
        }
        
        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.OnDesignerCreated"]/*' />
        /// <devdoc>
        ///     The designer should call this after it successfully loads.
        /// </devdoc>
        public void OnDesignerCreated(DesignerEventArgs e) {
            designers.Add(e.Designer);
            documents = null;
            DesignerEventHandler handler = (DesignerEventHandler)eventTable[DOCUMENT_CREATED_EVENT];
            if (handler != null) {
                handler.Invoke(this, e);
            }
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.OnDesignerDisposed"]/*' />
        /// <devdoc>
        ///     The designer should call this before it disposes itself.
        /// </devdoc>
        public void OnDesignerDisposed(DesignerEventArgs e) {
            DesignerEventHandler handler = (DesignerEventHandler)eventTable[DOCUMENT_DISPOSED_EVENT];
            if (handler != null) {
                handler.Invoke(this, e);
            }
            if (designers.Contains(e.Designer)) {
                designers.Remove(e.Designer);
            }
            if (activeDesigner == e.Designer) {
                activeDesigner = null;
            }
            documents = null;
        }
        
        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     This is called when the selection changes.  The document manager
        ///     automatically monitors selection events for the active document.
        /// </devdoc>
        public virtual void OnSelectionChanged(ISelectionService newSelection) {
            currentSelection = newSelection;
            EventHandler handler = (EventHandler)eventTable[SELECTION_CHANGED_EVENT];
            if (handler != null) {
                handler.Invoke(this, EventArgs.Empty);
            }
        }
        
        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.OnThreadException"]/*' />
        /// <devdoc>
        ///     Called when an untrapped exception occurs in our codebase.  Rather than displaying
        ///     the default exception dialog, we look for the UI service and ask it to display a
        ///     dialog.
        /// </devdoc>
        private void OnThreadException(object sender, ThreadExceptionEventArgs t) {
            // we always ignore the checkout cancel here
            if (t.Exception == CheckoutException.Canceled) {
                return;
            }

            Debug.Assert(t != null, t.Exception.ToString());
            IUIService uisvc = (IUIService)GetService(typeof(IUIService));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || uisvc != null, "IUIService not found");
            if (uisvc != null) {
                uisvc.ShowError(t.Exception, SR.GetString(SR.ExceptionInMessageLoop, t.Exception.GetType().Name, t.Exception.Message));
            }
            else {
                DialogResult result = DialogResult.Cancel;

                ThreadExceptionDialog td = new ThreadExceptionDialog(t.Exception);
                try {
                    result = td.ShowDialog();
                }
                finally {
                    td.Dispose();
                }
                switch (result) {
                    case DialogResult.Abort:
                        Application.Exit();
                        Environment.Exit(0);
                        break;
                    case DialogResult.Retry:
                        if (Debugger.IsAttached) {
                            Debugger.Break();
                        }
                        break;
                }
            }
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ComponentDesignerLoader"]/*' />
        /// <devdoc>
        ///     Simple implementation of a designer loader.  This loader demand creates an
        ///     instance of the given component class so that the designer for that class
        ///     may be hosted.
        /// </devdoc>
        private class ComponentDesignerLoader : DesignerLoader, IDesignerLoaderService {
            private string                componentClass;
            private IDesignerLoaderHost   host;
            private int                   loadCount;
            private ArrayList             errorList;

            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ComponentDesignerLoader.ComponentDesignerLoader"]/*' />
            /// <devdoc>
            ///     Creates a new ComponentDesignerLoader object.
            /// </devdoc>
            public ComponentDesignerLoader(string componentClass) {
                this.componentClass = componentClass;
            }

            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ComponentDesignerLoader.BeginLoad"]/*' />
            /// <devdoc>
            ///     The host will call this method when it wants to load whatever
            ///     data the code stream contains.  There are three times when this
            ///     method can be called.  First, a code stream is handed to the
            ///     host to initially create the document, so load will be called there.
            ///     Second, when a code steam is first declared through IPersistenceService,
            ///     it will be loaded immediately.  Finally, if the document needs to be
            ///     re-loaded because the user changed one or more files, then all code
            ///     streams will be re-loaded.
            /// </devdoc>
            public override void BeginLoad(IDesignerLoaderHost host) {
            
                if (this.host == null) {
                    host.AddService(typeof(IDesignerLoaderService), this);
                }
                
                this.host = host;
                
                loadCount = 1;
                if (errorList == null) {
                    errorList = new ArrayList();
                }
                else {
                    errorList.Clear();
                }
                
                bool successful = true;

                if (host != null) {
                    Type c = host.GetType(componentClass);
                    if (c == null) {
                        errorList.Add(new Exception(SR.GetString(SR.PersisterClassNotFound, componentClass)));
                    }
                    else {
                        IComponent component = null;
                        
                        try {
                            component = host.CreateComponent(c);
                        }
                        catch (Exception e) {
                            errorList.Add(e);
                            successful = false;
                        }
                    }
                    ((IDesignerLoaderService)this).DependentLoadComplete(successful, errorList);
                }
            }
            
            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ComponentDesignerLoader.Dispose"]/*' />
            /// <devdoc>
            ///     The host will call this method when it no longer needs the
            ///     code stream.  Typically, this only happens when the document is closed.
            /// </devdoc>
            public override void Dispose() {
                if (host != null) {
                    host.RemoveService(typeof(IDesignerLoaderService));
                }
                host = null;
            }
    
            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ComponentDesignerLoader.IDesignerLoaderService.AddLoadDependency"]/*' />
            /// <devdoc>
            ///     Adds a load dependency to this loader.  This indicates that some other
            ///     object is also participating in the load, and that the designer loader
            ///     should not call EndLoad on the loader host until all load dependencies
            ///     have called DependentLoadComplete on the designer loader.
            /// </devdoc>
            void IDesignerLoaderService.AddLoadDependency() {
                loadCount++;
            }
        
            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ComponentDesignerLoader.IDesignerLoaderService.DependentLoadComplete"]/*' />
            /// <devdoc>
            ///     This is called by any object that has previously called
            ///     AddLoadDependency to signal that the dependent load has completed.
            ///     The caller should pass either an empty collection or null to indicate
            ///     a successful load, or a collection of exceptions that indicate the
            ///     reason(s) for failure.
            /// </devdoc>
            void IDesignerLoaderService.DependentLoadComplete(bool successful, ICollection errorCollection) {
            
                if (loadCount > 0) {
                    if (errorCollection != null && errorList != null) {
                        errorList.AddRange(errorCollection);
                    }
                    
                    loadCount--;
                    
                    if (loadCount == 0) {
                        host.EndLoad(null, successful, errorList);
                    }
                }
            }
        
            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.ComponentDesignerLoader.IDesignerLoaderService.Reload"]/*' />
            /// <devdoc>
            ///     This can be called by an outside object to request that the loader
            ///     reload the design document.  If it supports reloading and wants to
            ///     comply with the reload, the designer loader should return true.  Otherwise
            ///     it should return false, indicating that the reload will not occur.
            ///     Callers should not rely on the reload happening immediately; the
            ///     designer loader may schedule this for some other time, or it may
            ///     try to reload at once.
            /// </devdoc>
            bool IDesignerLoaderService.Reload() {
                // no backing store, so we cannot reload.
                return false;
            }
        }

        /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.DebugOutput"]/*' />
        /// <devdoc>
        ///     This class routes debug messages for those times when we can't get to
        ///     standard out or to the shell's debug service.
        /// </devdoc>
        private class DebugOutput : Form {
            private static DebugOutput debugOutput;
            private TextBox edit;

            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.DebugOutput.DebugOutput"]/*' />
            /// <devdoc>
            ///     Private constructor.
            /// </devdoc>
            private DebugOutput() {
                edit = new TextBox();
                Controls.Add(edit);
                edit.Multiline = true;
                edit.ReadOnly = true;
                edit.Dock = DockStyle.Fill;
                edit.ScrollBars = ScrollBars.Vertical;
                edit.Visible = true;
                Text = "Debug Output Window";
                Visible = true;
            }

            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.DebugOutput.OnHandleDestroyed"]/*' />
            /// <devdoc>
            ///     We override this so that if the user closes the form, we can
            ///     null the debug pointer.  That way, the next time something needs
            ///     to be output, it will re-create the form.
            /// </devdoc>
            protected override void OnHandleDestroyed(EventArgs e) {
                base.OnHandleDestroyed(e);
                debugOutput = null;
            }

            /// <include file='doc\DocumentManager.uex' path='docs/doc[@for="DocumentManager.DebugOutput.Write"]/*' />
            /// <devdoc>
            ///     Prints the given text to the output window, followed by a newline.
            /// </devdoc>
            public static void Write(string text) {
                if (debugOutput == null) {
                    debugOutput = new DebugOutput();
                }
                debugOutput.edit.Text = debugOutput.edit.Text + text;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\host\idesignerdocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;
    using System.ComponentModel.Design;
    using System.Windows.Forms;

    /// <include file='doc\IDesignerDocument.uex' path='docs/doc[@for="IDesignerDocument"]/*' />
    /// <devdoc>
    ///     This defines an interface that can be used to access a designer from 
    ///     managed code.
    /// </devdoc>
    public interface IDesignerDocument : IDesignerHost {
        
        /// <include file='doc\IDesignerDocument.uex' path='docs/doc[@for="IDesignerDocument.View"]/*' />
        /// <devdoc>
        ///     The view for this document.  The designer
        ///     should assume that the view will be shown shortly
        ///     after this call is made and make any necessary
        ///     preparations.
        /// </devdoc>
        Control View { get; }
        
        /// <include file='doc\IDesignerDocument.uex' path='docs/doc[@for="IDesignerDocument.Flush"]/*' />
        /// <devdoc>
        ///     Called to flush any changes in this document to disk.
        /// </devdoc>
        void Flush();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\assemblyobsoleteeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="AssemblyObsoleteEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {

    using System;
    using System.Reflection;

    /// <include file='doc\AssemblyObsoleteEventArgs.uex' path='docs/doc[@for="AssemblyObsoleteEventArgs"]/*' />
    /// <devdoc>
    ///      Argument class for the assembly obsolete event.
    /// </devdoc>
    internal class AssemblyObsoleteEventArgs : EventArgs {
        private Assembly assembly;
        
        public AssemblyObsoleteEventArgs(Assembly assembly) {
            this.assembly = assembly;
        }
        
        public Assembly ObsoleteAssembly {
            get {
                return assembly;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\codedom\vscodedomparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsCodeDomParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace  Microsoft.VisualStudio.Designer.CodeDom {
    using System;
    using System.Diagnostics;
    using System.CodeDom;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.IO;
    using Microsoft.VisualStudio.Designer.CodeDom.XML;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer.Serialization;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Text;


    using Microsoft.VisualStudio;
    using EnvDTE;

    using CodeNamespace = System.CodeDom.CodeNamespace;


    /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser"]/*' />
    /// <devdoc>
    ///     Parses a mixed VS DTE CodeModel file and IMethodXML interface file into a CodeDom tree.  All interesting elements outside
    ///     of a method code block are converted into CodeDomElements, and the XML parser converts the IMethodXML stuff into CodeDOM.
    /// </devdoc>
    internal class VsCodeDomParser : CodeParser {

        // the provider that created us.  
        // we need this to get at the FileCodeModel.
        //
        private VsCodeDomProvider provider;

        // our handy-dandy Xml parser
        //
        private CodeDomXmlProcessor xmlProcessor;
        
        // The file name we're currently parsing
        //
        private string fileName;
        
        private bool implementsBodyPoint = true;

        private EventHandler ehFunctionPointHandler;

        // the key we'll use to stash off our DTE objects
        //
        internal static Type VsElementKey = typeof(EnvDTE.CodeElement);

        // the key we'll use to stash off the original member collection
        //
        internal static string VsOriginalCollectionKey = "_vsOriginalCollection";

        // We need to know when we should be regenerating a method that already exists.
        // This key is used for that purpose.  If it exists on a method, it is because
        // we either parsed that method (because someone asked us to), or because we
        // have previously generated to that method.  In either case, we assume it is ok
        // to rebuild the method.
        //
        internal static string VsGenerateStatementsKey = "_vsGenerateStatements";
        
        internal static string VbHandlesClausesKey = "_vbHandlesClauses";
        
        internal const int vsCMWithEvents = 0x80;

        internal VsCodeDomParser(VsCodeDomProvider provider) {
            this.provider = provider;
            this.ehFunctionPointHandler = new EventHandler(GetFunctionPoints);
        }
        
        private string FileName {
            get {
                if (fileName == null) {
                    fileName = provider.FileName;
                }
                
                return fileName;
            }
        }

        /// <devdoc>
        ///     This property is offered up through our designer serialization manager.
        ///     We forward the request onto our code parser, which, if it returns true,
        ///     indicates that the parser will fabricate statements that are not
        ///     in user code.  The code dom serializer may use this knowledge to limit
        ///     the scope of parsing.
        /// </devdoc>
        public bool SupportsStatementGeneration {
            get {
                return provider.IsVB;
            }
        }
        
        private CodeDomXmlProcessor XmlProcessor {
            get {
                if (xmlProcessor == null) {
                    xmlProcessor = new CodeDomXmlProcessor();
                }
                return xmlProcessor;
            }
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.Parse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the given text stream into a CodeCompile unit.  
        ///    </para>
        /// </devdoc>
        public override CodeCompileUnit Parse(TextReader codeStream) {
        
            // Remove away the file name for this round of parsing
            //
            fileName = null;
            
            // we actually don't care about the code here...we'll go build
            // a CodeCompileUnit ourselves
            CodeCompileUnit compileUnit = new CodeCompileUnit();

            CodeNamespace defaultNamespace = null;

            // create CodeDom.CodeNamespace elements for each DTE namespace element
            //
            foreach(CodeElement codeElement in provider.FileCodeModel.CodeElements) {

                CodeNamespace ns = null;

                // make sure we have a namespace kind
                //
                if (codeElement.Kind == vsCMElement.vsCMElementNamespace) {

                    // set it up and sink it's handler.
                    ns = new CodeNamespace(((EnvDTE.CodeNamespace)codeElement).FullName);
                    SetVsElementToCodeObject(codeElement, ns);
                    ns.PopulateTypes += new EventHandler(this.OnNamespacePopulateTypes);
                }
                else if (codeElement.Kind == vsCMElement.vsCMElementClass) {

                    bool dontAdd = false;

                    if (defaultNamespace == null) {

                        // Let's see the VS Hierarchy can bail us out.
                        //
                        defaultNamespace = provider.DefaultNamespace;
                    }
                    else {
                        dontAdd = true;
                    }

                    ns = defaultNamespace;
                    CodeTypeDeclaration codeTypeDecl = CodeTypeDeclarationFromCodeClass((EnvDTE.CodeClass)codeElement);
                    ns.Types.Add(codeTypeDecl);

                    if (dontAdd) {
                        continue;
                    }
                }

                if (ns != null) {

                    compileUnit.Namespaces.Add(ns);  

                    // stuff in the compile unit.  if we encounter
                    // nested namespaces, we'll replace the
                    // top level one with them and recurse.
                    //
                    ns.UserData[typeof(CodeCompileUnit)] = compileUnit;
                    // now we have to ask for the types of this namespace to force any child namespaces
                    // to be flattened to the top.
                    //
                    object typeCollection = ns.Types;
                }
            }
            if (codeStream is IServiceProvider) {
                provider.EnsureExtender((IServiceProvider)codeStream);
            }
            return compileUnit;
        }

        private CodeTypeDeclaration CodeTypeDeclarationFromCodeClass(EnvDTE.CodeClass vsClass) {

            // set it up and sink it's handler.
            CodeTypeDeclaration codeTypeDecl = new CodeTypeDeclaration(vsClass.Name);
            codeTypeDecl.LinePragma = new CodeLinePragma(this.FileName, vsClass.StartPoint.Line);
            SetVsElementToCodeObject((CodeElement)vsClass, codeTypeDecl);
            codeTypeDecl.PopulateMembers += new EventHandler(this.OnTypePopulateMembers);

            // should this language have an events tab?
            // we do this so the grid can retrieve this info later...
            //
            if (provider.IsVB) {
                codeTypeDecl.UserData[typeof(System.Windows.Forms.Design.EventsTab)] = "Hide"; // just a marker value
            }


            // setup it's modifiers
            //
            codeTypeDecl.Attributes = GetMemberAttributesFromVsClass(vsClass);
            codeTypeDecl.TypeAttributes = TypeAttributes.Class;

            // check for base types
            //

            try {
                foreach (CodeElement baseElement in vsClass.Bases) {
                    if (baseElement.Kind == vsCMElement.vsCMElementClass) {
                       codeTypeDecl.BaseTypes.Add(new CodeTypeReference(GetUrtTypeFromVsType((EnvDTE.CodeClass)baseElement)));
                    }
                }
            }
            catch (Exception ex) {
                if (!provider.CodeGenerator.IsValidIdentifier(vsClass.Name)) {
                    throw new Exception(SR.GetString(SR.InvalidClassNameIdentifier));
                }
                throw ex;
            }
            
            
            return codeTypeDecl;
        }

        private CodeAttachEventStatement CreateEventAttachStatement(string fieldName, EventDescriptor eventDesc, string handlerMethod) {
            CodeExpression thisExpr = new CodeThisReferenceExpression();
            CodeExpression targetObject = fieldName == null ? thisExpr : new CodeFieldReferenceExpression(thisExpr, fieldName);
            CodeExpression listener = new CodeObjectCreateExpression(eventDesc.EventType.FullName, new CodeMethodReferenceExpression(thisExpr, handlerMethod));
            CodeAttachEventStatement statement = new CodeAttachEventStatement(targetObject, eventDesc.Name, listener);

            // We add a key to the user data to indicate that this statement was
            // auto generated.  Auto generated statements are ignored by the
            // CodeDom interpreter if there are no additional statements associated
            // with the same component.  This helps to prevent us from "leaking"
            // and parsing code outside of InitializeComponent.
            //
            statement.UserData["GeneratedStatement"] = true;
            return statement;
        }

        private void GetDelegateHookupsFromHandlesClauses(Hashtable handlers, CodeTypeDeclaration codeTypeDecl, CodeStatementCollection statements) {

            CodeDomLoader.StartMark();

            // unfortunately, we have to essentially parse the code to find the objects
            // that we are instantiating to get their types and names
            // 
            // then we get the default event for each type, and then we walk through our list
            // of handlers and add statement hookups for the default ones.
            //
            // why do we go through all this work?  because we need to know which ones are set by
            // parse time or when we double click on the same control, we'll think we have to add another handler.
            // 

            Hashtable objs = new Hashtable();
            
            foreach (CodeTypeMember member in codeTypeDecl.Members) {
                CodeMemberField field = member as CodeMemberField;
                if (field != null) {
                    objs[field.Name] = field.Type.BaseType;
                }
            }

            
            // and add our base type...
            //
            objs["MyBase"] = codeTypeDecl.BaseTypes[0].BaseType;

            // again by name because Visual Basic keeps switching back and forth...
            //
            objs[codeTypeDecl.Name] = codeTypeDecl.BaseTypes[0].BaseType;

            // now we have all the created objects, so we walk through the
            // handlers we've found and see which ones are default handlers for those objects.
            //
            ITypeResolutionService typeLoader = provider.TypeLoader;
            Type baseType = null;

            if (typeLoader != null) {

                // now walk through them, checking each to see if we're on a default event
                //

                foreach(DictionaryEntry de in handlers) {
    
                        // get the handler and and the data for this field
                        //
                        string handler = (string)de.Key;
                        int dot = handler.IndexOf('.');
                        string fieldName = handler.Substring(0, dot);
                        
                        object objInfo = objs[fieldName];
                        Type fieldType = null;
                        
                        if (objInfo == null) {
                            // this means this thing isn't an IComponent...try to reflect against the base type
                            //
                            if (baseType == null) {
                                baseType = typeLoader.GetType(codeTypeDecl.BaseTypes[0].BaseType, false);
                            }
                            if (baseType != null) {
    
                                
                                // because of the wonderful magicalness of VB, there isn't actually a field called "button1", it's a 
                                // property. so we get to walk all the fields, looking for one who has the neat
                                // little Accessed through property attribute that matches the name of this member. 
                                //
                                foreach(FieldInfo field in baseType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) {
                                    if (field.Name == fieldName) {
                                        fieldType = field.FieldType;
                                        break;
                                    }
                                    
                                    object[] fieldAttrs = field.GetCustomAttributes(typeof(AccessedThroughPropertyAttribute), false);
                                    if (fieldAttrs != null && fieldAttrs.Length > 0) {
                                        AccessedThroughPropertyAttribute propAttr = (AccessedThroughPropertyAttribute)fieldAttrs[0];
                                        // does the property name on the attribute match what we're looking for?
                                        //
                                        if (propAttr.PropertyName == fieldName) {
                                            PropertyInfo fieldProp = baseType.GetProperty(propAttr.PropertyName, 
                                                                        BindingFlags.Instance | 
                                                                        BindingFlags.Public | 
                                                                        BindingFlags.NonPublic);
    
                                            // now go find the property and get its value
                                            //
                                            if (fieldProp != null) {
                                                MethodInfo getMethod = fieldProp.GetGetMethod(true);
                                                if (getMethod != null && !getMethod.IsPrivate) {
                                                    fieldType = fieldProp.PropertyType;
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
    
                                if (fieldType != null) {
                                    objs[fieldName] = fieldType;
                                    objInfo = fieldType;
                                }
                                else {
                                    // flag failure of this type so we
                                    // don't check again.
                                    //
                                    objs[fieldName] = false;
                                    objInfo = false;
                                    continue;
                                }
                        }
                    }

                    if (objInfo is string) {
                        // it's the type name, get the default handler from the TypeDescriptor
                        //
                        Type t = typeLoader.GetType((string)objInfo, false);
                        
                        if (t != null) {
                            objs[fieldName] = t;
                            fieldType = t;
                        }

                    }
                    else if (objInfo is Type) {
                        // just grab the handler
                        //
                        fieldType = (Type)objInfo;
                    }
                    else if(objInfo is bool){
                        // we've failed here before, just give up!
                        //
                        continue;
                    }
                    else {
                        // errr, how'd we get here?
                        //
                        Debug.Fail("Why does the handler data have a '" + objInfo.GetType().FullName + "'?");
                        continue;
                    }

                    // now that we have a default event, see if the
                    // handler we're currently on, say "button1.Click" matches
                    // what the handles clause for this component would look like.
                    //
                    
                    if (fieldType != null) {
                        
                        string eventName = handler.Substring(dot + 1);

                        // Make sure this is a valid event for this type
                        EventDescriptor eventDesc = TypeDescriptor.GetEvents(fieldType)[eventName];

                        // (bug 120608) if we got null, we may be hooking up a private interface member. Try to find it.
                        //
                        if (eventDesc == null) {
                            foreach (Type interfaceType in fieldType.GetInterfaces()) {
                                EventInfo eventInfo = interfaceType.GetEvent(eventName);
                                if (eventInfo != null) {
                                    eventDesc = TypeDescriptor.CreateEvent(interfaceType, eventName, eventInfo.EventHandlerType);
                                    break;
                                }
                            }
                        }

                        Debug.Assert(eventDesc != null, "Handles clause '" + handler + "' found, but type '" + fieldType.FullName + "' does not have an event '" + eventName + "'");

                        if (eventDesc != null) {
                            CodeMemberMethod method = de.Value as CodeMemberMethod;
                            CodeStatement attachStatement = CreateEventAttachStatement(fieldName == "MyBase" ? null : fieldName, eventDesc, method.Name);
                            attachStatement.UserData[CodeDomXmlProcessor.KeyXmlParsedStatement] = CodeDomXmlProcessor.KeyXmlParsedStatement;
                            statements.Add(attachStatement);

                        }
                    }
                }
            }

            CodeDomLoader.EndMark("Handles clauses to delegate hookups");
        }

        private void GetFunctionPoints(object sender, EventArgs e) {

            CodeMemberMethod codeMethod = sender as CodeMemberMethod;

            if (codeMethod == null) {
                return;
            }

            CodeFunction vsFunction = codeMethod.UserData[VsCodeDomParser.VsElementKey] as CodeFunction;

            TextPoint bodyPoint = null;
                    
            try {
                // Not everyone implements this.
                if (implementsBodyPoint) {
                    bodyPoint = vsFunction.GetStartPoint(vsCMPart.vsCMPartNavigate);
                }
            }
            catch {
                implementsBodyPoint = false;
            }
            
            if (bodyPoint == null && vsFunction is IMethodXML) {
                object bodyPointObj;
                if (((IMethodXML)vsFunction).GetBodyPoint(out bodyPointObj) == 0) {
                    bodyPoint = bodyPointObj as TextPoint;
                }
            }

            if (bodyPoint != null) {
                System.Drawing.Point pt = new System.Drawing.Point(bodyPoint.LineCharOffset, bodyPoint.Line);
                codeMethod.UserData[typeof(System.Drawing.Point)] = pt;
            }
            
            codeMethod.LinePragma = new CodeLinePragma(this.FileName, vsFunction.StartPoint.Line);
        }

        private string[] GetHandlesClauses(IEventHandler eh) {
            IVsEnumBstr enumBstr = eh.GetHandledEvents();

            if (enumBstr == null) {
                return new string[0];
            }

            string handler = null;
            int    handlersRetrieved = 0;

            int    count = enumBstr.GetCount();
            string[] strs = new string[count];
            count = 0;
            while (NativeMethods.S_OK == enumBstr.Next(1, out handler, out handlersRetrieved) && handlersRetrieved == 1) {
                strs[count++] = handler;
            }
            return strs;
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.GetMemberAttributesFromVsAccess"]/*' />
        /// <devdoc>
        ///     Convert a vsCMAccess enum value into Attributes
        /// </devdoc>
        private MemberAttributes GetMemberAttributesFromVsAccess(vsCMAccess vsAccess) {

            // strip off with events.
            //
            if (provider.IsVB) {
                vsAccess &= (vsCMAccess)(~VsCodeDomParser.vsCMWithEvents);
            }

            switch (vsAccess) {
            case vsCMAccess.vsCMAccessPublic:
                return MemberAttributes.Public;
            case vsCMAccess.vsCMAccessProtected:
                return MemberAttributes.Family;
            case vsCMAccess.vsCMAccessPrivate:
                return MemberAttributes.Private;
            case vsCMAccess.vsCMAccessProject:
                return MemberAttributes.Assembly;
            case vsCMAccess.vsCMAccessProjectOrProtected:
                return MemberAttributes.FamilyOrAssembly;
            default:
                Debug.Fail("Don't know how to convert vsCMAccess." + vsAccess.ToString());
                break;
            }
            return MemberAttributes.Private;
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.GetMemberAttributesFromVsClass"]/*' />
        /// <devdoc>
        ///     Retrieve class specific attributes
        /// </devdoc>
        private MemberAttributes GetMemberAttributesFromVsClass(CodeClass vsClass) {
            MemberAttributes mods = GetMemberAttributesFromVsAccess(vsClass.Access) ;

            if (vsClass.IsAbstract) mods |= MemberAttributes.Abstract;

            return mods;
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.GetMemberAttributesFromVsField"]/*' />
        /// <devdoc>
        ///     Retrieve member variable specific attributes
        /// </devdoc>
        private MemberAttributes GetMemberAttributesFromVsField(CodeVariable vsField) {
            MemberAttributes mods = GetMemberAttributesFromVsAccess(vsField.Access);

            if (vsField.IsShared) mods |= MemberAttributes.Static;
            if (vsField.IsConstant) mods |= MemberAttributes.Const;

            return mods;
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.GetMemberAttributesFromVsFunction"]/*' />
        /// <devdoc>
        ///     Retrieve method specific attributes
        /// </devdoc>
        private MemberAttributes GetMemberAttributesFromVsFunction(CodeFunction vsFunction) {
            MemberAttributes mods = GetMemberAttributesFromVsAccess(vsFunction.Access);

            if (vsFunction.IsShared) mods |= MemberAttributes.Static;
            if (vsFunction.MustImplement) mods |= MemberAttributes.Abstract;

            if (!vsFunction.CanOverride && (mods & MemberAttributes.Private) == (MemberAttributes)0) {
                mods |= MemberAttributes.Final;
            }
            return mods;
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.GetUrtTypeFromVsType"]/*' />
        /// <devdoc>
        ///     Convert the type to URT format -- that is, convert the last '.' to '+'
        /// </devdoc>
        private string GetUrtTypeFromVsType(CodeTypeRef vsType) {
 
            string fullName = "";

            if (vsType.TypeKind == vsCMTypeRef.vsCMTypeRefArray) {
                CodeTypeRef elementType = vsType;
                // asurt 140862 -- it turns out the CodeModel is implemented in such a way that
                // they don't return an AsFullName for Array types (it just returns ""), and no good way of walking the
                // rank/dimensions of the array type. So we just walk down until we have a normal type kind
                // and then check that against our basetype.
                //
                while (elementType.TypeKind == vsCMTypeRef.vsCMTypeRefArray) {
                    elementType = elementType.ElementType;
                }
                fullName = elementType.AsFullName; 
            }
            else {
                fullName = vsType.AsFullName;
            }


            if (vsType.TypeKind == vsCMTypeRef.vsCMTypeRefCodeType) {
                
                CodeType ct = vsType.CodeType;
    
                // if the parent is a CodeType, replace the last dot with a +
                //
                while (ct != null && ct.InfoLocation != vsCMInfoLocation.vsCMInfoLocationNone && ct.Parent is CodeType) {
                    int index = fullName.LastIndexOf('.');
                    if (index != -1) {
                        fullName = fullName.Substring(0, index) + '+' +  fullName.Substring(index + 1);
                    }
                    ct = (CodeType)ct.Parent;
                }
            }
            return fullName;
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.GetUrtTypeFromVsType"]/*' />
        /// <devdoc>
        ///     Convert the type to URT format -- that is, convert the last '.' to '+'
        /// </devdoc>
        private string GetUrtTypeFromVsType(CodeClass vsClass) {
         
            string fullName = vsClass.FullName;

            if (vsClass.InfoLocation != vsCMInfoLocation.vsCMInfoLocationNone) {
                // if the parent is a CodeClass, replace the last dot with a +
                //
                while (vsClass != null && vsClass.Parent is CodeClass) {
                    int index = fullName.LastIndexOf('.');
                    if (index != -1) {
                        fullName = fullName.Substring(0, index) + '+' +  fullName.Substring(index + 1);
                    }
                    vsClass = (CodeClass)vsClass.Parent;
                }
            }

            return fullName;
        }


        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.GetVsElementFromCodeObject"]/*' />
        /// <devdoc>
        ///     Fish the VS DTE element out of a CodeDom element if we've set up such a thing.
        /// </devdoc>
        private CodeElement GetVsElementFromCodeObject(CodeObject codeObject) {
            return(CodeElement)codeObject.UserData[VsElementKey];
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.OnMethodPopulateParameters"]/*' />
        /// <devdoc>
        ///     Populate the parameter list from a function.
        /// </devdoc>
        private void OnMethodPopulateParameters(object sender, EventArgs e) {
            CodeMemberMethod codeMethod = (CodeMemberMethod)sender;
            CodeFunction     vsFunction = (CodeFunction)GetVsElementFromCodeObject(codeMethod);

            try {
                ITypeResolutionService typeService = provider.TypeLoader;
                foreach(CodeElement codeElement in vsFunction.Parameters) {
                    if (codeElement.Kind == vsCMElement.vsCMElementParameter) {
                        CodeParameter codeParam = (CodeParameter)codeElement;
                        FieldDirection fieldDir = FieldDirection.In;
                        StringBuilder type = new StringBuilder(GetUrtTypeFromVsType(codeParam.Type));
                        Type paramType = typeService.GetType(type.ToString());
                        bool typeChanged = false;

                        if (codeParam is IParameterKind) {
                            IParameterKind paramKind = (IParameterKind)codeParam;
                            PARAMETER_PASSING_MODE passMode = (PARAMETER_PASSING_MODE)paramKind.GetParameterPassingMode();
                            switch (passMode) {
                                case PARAMETER_PASSING_MODE.cmParameterTypeOut:
                                    fieldDir = FieldDirection.Out;
                                    break;
                                case PARAMETER_PASSING_MODE.cmParameterTypeInOut:
                                    fieldDir = FieldDirection.Ref;
                                    break;
                            }

                            if (paramType != null) {
                                // we have to walk these backwards...
                                //
                                for (int i =  paramKind.GetParameterArrayCount() - 1; i >= 0 ; i--) {
                                    typeChanged = true;
                                    type.Append("[");
                                    for (int d = 1; d < paramKind.GetParameterArrayDimensions(i); d++) {
                                            type.Append(",");
                                    }
                                    type.Append("]");
                                }
                            }
                        }

                        if (paramType != null && typeChanged) {
                            paramType = paramType.Assembly.GetType(type.ToString());
                        }

                        CodeParameterDeclarationExpression parameterDecl = new CodeParameterDeclarationExpression(new CodeTypeReference(paramType), codeParam.Name);
                        parameterDecl.Direction = fieldDir;

                        codeMethod.Parameters.Add(parameterDecl);
                    }
                }
            }
            catch {
            }
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.OnMethodPopulateStatements"]/*' />
        /// <devdoc>
        ///     Populate the parameter statement list from a method.  Here is where we invoke the XmlProcessor
        /// </devdoc>
        private void OnMethodPopulateStatements(object sender, EventArgs e) {
            CodeMemberMethod codeMethod = (CodeMemberMethod)sender;
            CodeFunction     vsFunction = (CodeFunction)GetVsElementFromCodeObject(codeMethod);

            IMethodXML xmlMethod = null;

            try {
                xmlMethod = (IMethodXML)vsFunction;
            }
            catch {
            }

            if (xmlMethod == null) {
                Debug.Fail("Couldn't get IMethodXML for method '" + codeMethod.Name + "'");
                return;
            }

            string xmlCode = null;

            CodeDomLoader.StartMark();

            // get a hold of the XML if possible.
            //
            try {
                xmlMethod.GetXML(ref xmlCode);
            }
            catch(Exception ex) {
                System.Runtime.InteropServices.COMException cex = ex as System.Runtime.InteropServices.COMException;
                throw new Exception(SR.GetString(SR.FailedToParseMethod, vsFunction.Name, ex.Message));
            }
            finally {
                CodeDomLoader.EndMark("GetXML");
                CodeDomLoader.StartMark();
            }

            // pass it along to the processor.
            //
            XmlProcessor.ParseXml(xmlCode, codeMethod.Statements, this.FileName, codeMethod.Name);
            
            CodeDomLoader.EndMark("XML -> CodeDom Tree");
            

            // Add the statement count to our user data.  We use this as a quick way to tell if we need to
            // regenerate the contents of a method.
            //
            codeMethod.UserData[VsGenerateStatementsKey] = VsGenerateStatementsKey;

            // clear out the methods that we've generated before...
            //
            provider.ClearGeneratedMembers();

            // now apply any handlers for default events.
            //

            if (provider.IsVB) {

                CodeTypeDeclaration codeTypeDecl = (CodeTypeDeclaration)codeMethod.UserData[typeof(CodeTypeDeclaration)];

                if (codeTypeDecl == null) {
                    return;
                }

                Hashtable handlers = (Hashtable)codeTypeDecl.UserData[VbHandlesClausesKey];

                // save this so we can compare against it later to see
                // if we need to reload due to a handler change.
                //
                provider.FullParseHandlers = handlers;

                if (handlers == null || handlers.Count == 0) {
                    return;
                }
                GetDelegateHookupsFromHandlesClauses(handlers, codeTypeDecl, codeMethod.Statements);
            }
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.OnNamespacePopulateTypes"]/*' />
        /// <devdoc>
        ///     Populate the types from a namespace.  
        /// </devdoc>
        private void OnNamespacePopulateTypes(object sender, EventArgs e) {
            CodeNamespace ns = (CodeNamespace)sender;

            EnvDTE.CodeNamespace vsNamespace = (EnvDTE.CodeNamespace)GetVsElementFromCodeObject(ns);

            EventHandler populateTypes = new EventHandler(this.OnNamespacePopulateTypes);

            foreach (CodeElement codeElement in vsNamespace.Members) {
                // get all the classes out
                //
                if (codeElement.Kind == vsCMElement.vsCMElementClass) {
                    CodeTypeDeclaration codeTypeDecl = CodeTypeDeclarationFromCodeClass((EnvDTE.CodeClass)codeElement);
                    ns.Types.Add(codeTypeDecl);
                }
                else if (codeElement.Kind == vsCMElement.vsCMElementNamespace) {

                    // set it up and sink it's handler.
                    CodeNamespace nestedNamespace = new CodeNamespace(((EnvDTE.CodeNamespace)codeElement).FullName);
                    SetVsElementToCodeObject(codeElement, nestedNamespace);
                    nestedNamespace.PopulateTypes += populateTypes;

                    CodeCompileUnit codeUnit = (CodeCompileUnit)ns.UserData[typeof(CodeCompileUnit)];

                    if (codeUnit != null) {
                        int nsIndex = codeUnit.Namespaces.IndexOf(ns);
                        if (nsIndex != -1) {
                            codeUnit.Namespaces[nsIndex] = nestedNamespace;
                            nestedNamespace.UserData[typeof(CodeCompileUnit)] = codeUnit;
                        }
                    }

                    // force generation
                    //
                    object coll = nestedNamespace.Types;

                }
            }
        }

        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.OnTypePopulateMembers"]/*' />
        /// <devdoc>
        ///     Populate the methods and fields of a class declaration
        /// </devdoc>
        private void OnTypePopulateMembers(object sender, EventArgs e) {
            CodeTypeDeclaration codeTypeDecl = (CodeTypeDeclaration)sender;

            EnvDTE.CodeClass vsCodeClass = (CodeClass)GetVsElementFromCodeObject(codeTypeDecl);

            // We create another collection, which we stash in the decl's user 
            // data.  This is used to reconcile deletes when we code
            // gen.
            //
            CodeTypeMemberCollection originalMemberCollection = new CodeTypeMemberCollection();
            codeTypeDecl.UserData[VsOriginalCollectionKey] = originalMemberCollection;

            string shortName = codeTypeDecl.Name;
            int lastDot = shortName.LastIndexOf('.');
            if (lastDot != -1) {
                shortName = shortName.Substring(lastDot + 1);
            }

            foreach (CodeElement codeElement in vsCodeClass.Members) {
                switch (codeElement.Kind) {
                
                case vsCMElement.vsCMElementVariable:
                    CodeVariable vsField = (CodeVariable)codeElement;

                    // create the element
                    //
                    CodeMemberField codeField = new CodeMemberField(new CodeTypeReference(GetUrtTypeFromVsType(vsField.Type)), vsField.Name);

                    codeField.LinePragma = new CodeLinePragma(this.FileName, vsField.StartPoint.Line);

                    // get the attributes
                    //
                    codeField.Attributes = GetMemberAttributesFromVsField(vsField);

                    // add it to the members collection
                    SetVsElementToCodeObject((CodeElement)vsField, codeField);
                    codeTypeDecl.Members.Add(codeField);
                    originalMemberCollection.Add(codeField);
                    break;

                case vsCMElement.vsCMElementFunction:
                    CodeFunction vsFunction = (CodeFunction)codeElement;
                    CodeMemberMethod codeMethod;

                    
                    if (vsFunction.Name == shortName) {
                        codeMethod = new CodeTypeConstructor();
                    }
                    else {
                        codeMethod = new CodeMemberMethod();
                        string returnType = GetUrtTypeFromVsType(vsFunction.Type);
                        if (returnType == null || returnType.Length == 0) {
                            returnType = typeof(void).FullName;
                        }
                        codeMethod.ReturnType = new CodeTypeReference(returnType);
                    }

                    // sync up the name with what VS thinks it is.  This is important
                    // for things like constructors because the default name from CodeDom is
                    // ".cctor", but VS uses the shortname.
                    //
                    codeMethod.Name = vsFunction.Name;

                    codeMethod.UserData[typeof(EventHandler)] = ehFunctionPointHandler;

                    // add the ref
                    SetVsElementToCodeObject((CodeElement)vsFunction, codeMethod);

                    // setup the attriubutes
                    //
                    codeMethod.Attributes = GetMemberAttributesFromVsFunction(vsFunction);

                    // sink population events.
                    codeMethod.PopulateParameters += new EventHandler(this.OnMethodPopulateParameters);
                    codeMethod.PopulateStatements += new EventHandler(this.OnMethodPopulateStatements);
                    codeTypeDecl.Members.Add(codeMethod);
                    originalMemberCollection.Add(codeMethod);

                    // we'll need to navigate back up on this guy to it's code type.
                    //
                    codeMethod.UserData[typeof(CodeTypeDeclaration)] = codeTypeDecl;

                    // now look for any default event hookups for the object
                    //
                    if (provider.IsVB && codeElement is IEventHandler) {
                        string[] hookups = GetHandlesClauses((IEventHandler)codeElement);
                        Hashtable handlers = (Hashtable)codeTypeDecl.UserData[VbHandlesClausesKey];

                        // for each handles item like "button1.Click",
                        // push in the handles clause and the function name
                        //
                        foreach (string s in hookups) {
                            if (s != null) {
                                if (handlers == null) {
                                    handlers = new Hashtable();
                                    codeTypeDecl.UserData[VbHandlesClausesKey] = handlers;
                                }
                                handlers[s] = codeMethod;
                            }
                        }
                    }
                    break;
                default:
                    // we really *should* care about the various element types that
                    // the vs codedom is providing, but it turns out vs is
                    // changing those things too often for us to keep up with.
                    //
                    // so i'm removing the individual cases and the assert.  we
                    // will just ignore any types we don't directly care about.
                    // case vsCMElement.vsCMElementClass:
                    // case vsCMElement.vsCMElementEvent:
                    // case vsCMElement.vsCMElementProperty:
                    // case vsCMElement.vsCMElementEnum:
                    // case vsCMElement.vsCMElementDelegate:
                    // case vsCMElement.vsCMElementStruct:
                    // case vsCMElement.vsCMElementEventsDeclaration:
                    
                    // default:
                        // Debug.Fail("Unexpected element type '" + codeElement.Kind.ToString() + "' in Type member declaration");
                    break;
                }
            }
        }


        /// <include file='doc\VsCodeDomParser.uex' path='docs/doc[@for="VsCodeDomParser.SetVsElementToCodeObject"]/*' />
        /// <devdoc>
        ///     Push a DTE VS CodeElement refernece into a CodeDom element.
        /// </devdoc>
        private void SetVsElementToCodeObject(CodeElement vsElement, CodeObject codeObject){
            codeObject.UserData[VsElementKey] = vsElement;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\host\documentwindow.cs ===
//------------------------------------------------------------------------------
/// <copyright file="DocumentWindow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Host {

    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.PropertyBrowser;
    using Microsoft.VisualStudio.Shell;
    using System;
    using System.Collections;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Drawing.Drawing2D;
    using System.Runtime.InteropServices;
    using System.Web.UI.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Globalization;
    

    /// <summary>
    ///     This class implements the actual document window for a form design.  This is the
    ///     window that the base designer will be parented into.  It is a window because
    ///     it also provides some extra features:
    ///
    ///     It implements IOverlayService, providing a means for designers and services to
    ///     overlay visuals on top of the form design.
    ///
    ///     It implements scrolling for designers that wish to retain their dimensions (win-in-win).
    ///
    ///     It uncouples the startup order.  The shell can request the HWND of the document
    ///     at any time, even before we have finished loading the designer.  This allows
    ///     us to defer designer loading until convienent.
    /// </summary>
    internal class DocumentWindow : Control {
        private IDesignerHost           designerHost;
        private Control                 designerView;
        private object                  docObject;
        private ArrayList               errorList;

        private static Guid             LOGVIEWID_Designer = new Guid("{7651a702-06e5-11d1-8ebd-00a0c90f26ea}");


        // The border around the document window.
        //
        private static int              borderSize = 1;

        private ISelectionService       selectionService = null;

        // Documents and views....just what is going on here?
        //
        // This document window is the HWND that is eventually parented into
        // a VStudio document window.  The actual designer surface is parented
        // into us.  We support two ways of doing this:
        //
        // Windows Forms, CLR.
        // In this scenario the root designer uses Windows Forms as its view technology,
        // and we parent the control returned by the View property directly
        // into our window.
        //
        // ASP.Net, COM2.
        // In this scenario the root designer uses Embedding technology
        // and the View property returns a COM2 DocObject.  In this case we
        // just offer this object directly to the shell.
        //

        /// <summary>
        ///     Creates a new DocumentWindow.
        /// </summary>
        public DocumentWindow(IDesignerHost designerHost) {
            SetStyle(ControlStyles.ResizeRedraw, true);
            this.designerHost = designerHost;
            TabStop = false;
            Visible = false;
            Text = "DocumentWindow";
            BackColor = SystemColors.Window;            
            AllowDrop = true;
        }

        /// <summary>
        ///      Allows you to affect the visibility of the document.
        /// </summary>
        public bool DocumentVisible {
            get {
                return (designerView == null ? false : designerView.Visible);
            }

            set {
                if (designerView != null) {
                    designerView.Visible = value;
                }
            }
        }

        private string ErrorMessage {
            get {
                if (errorList != null && errorList.Count > 0) {
                    string errorText = string.Empty;
                    
                    foreach(object err in errorList) {
                        if (err is Exception && ((Exception)err).Message != null) {
                            errorText += ((Exception)err).Message + "\r\n";
                        }
                        else {
                            errorText += err.ToString() + "\r\n";
                        }
                    }
                    return SR.GetString(SR.CODEMANDocumentException, errorText);
                }

                return null;
            }
        }

        /// <summary>
        ///     Freezes the UI update of the docuement so we can reload without flashing.
        /// </summary>
        public bool FreezePainting {
            set {
                if (value) {
                    NativeMethods.SendMessage(this.Handle, NativeMethods.WM_SETREDRAW, 0, 0);
                }
                else {
                    NativeMethods.SendMessage(this.Handle, NativeMethods.WM_SETREDRAW, 1, 0);
                    Invalidate(true);
                }
            }
        }
        
        private ISelectionService SelectionService {
            get {
                if (selectionService == null && designerHost != null) {
                    selectionService = (ISelectionService)designerHost.GetService(typeof(ISelectionService));
                }
                return selectionService;
            }
        }

        protected override AccessibleObject CreateAccessibilityInstance() {
            return new DocumentWindowAccessibleObject(this);
        }
                
        /// <summary>
        ///     Disposes of the document.
        /// </summary>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                SetDesigner(null);

                designerHost = null;
            }
            base.Dispose(disposing);
        }

        /// <summary>
        ///     Retrieves the COM object that represents the view for this
        ///     document.  This is used to interface to COM containers such as
        ///     the visual studio shell.
        /// </summary>
        /// <returns>
        ///     a COM object that implements interfaces that can be hosted by
        ///     the VS shell.
        /// </returns>
        public virtual object GetComView() {
            if (docObject == null) {
                // Since the designer is wrapping us, then create a normal designer holder
                // for it.  The docObject was previously established for web forms.
                //
                docObject = new DocumentWindowPane(this, designerHost);
            }
            
            return docObject;
        }

        /// <summary>
        ///     Retrieves the CLR version of the view.  Yes, this is just an instance of us, but
        ///     we must hook up the rest of the designer.  It is important to defer this, because
        ///     we do not know what type of view the caller will be requesting.
        /// </summary>
        /// <returns>
        ///     a Control representing the designer view.
        /// </returns>
        public virtual Control GetComPlusView() {
            return this;
        }

        protected override void OnDragEnter(DragEventArgs de) {

            IToolboxService toolboxService = (IToolboxService)designerHost.GetService(typeof(IToolboxService));
            
            if (toolboxService != null) {
                ToolboxItem mouseDragTool = toolboxService.DeserializeToolboxItem(de.Data, designerHost);
                
                if (mouseDragTool != null) {
                    designerHost.Activate();
                }
            }

            base.OnDragEnter(de);
        }

#if DEBUG
        protected override void OnHandleCreated(EventArgs e) {
            Debug.Assert(!RecreatingHandle, "Perf hit: we are recreating the DocumentWindow handle");
            base.OnHandleCreated(e);
        }
#endif // DEBUG

        /// <summary>
        ///     We give the designer's window the focus.
        /// </summary>
        protected override void OnGotFocus(EventArgs e) {
            if (designerView != null) {
                designerView.Focus();
            }
            else {
                base.OnGotFocus(e);
            }
        }

        /// <summary>
        ///      Overrides window painting.  Here, if we have a load exception,
        ///      We draw a nice message.
        /// </summary>
        protected override void OnPaint(PaintEventArgs pe) {

            string errorMessage = ErrorMessage;
            if (errorMessage != null) {

                // We draw the icon in the upper left corner and then wrap text to the left
                // of it.
                //
                Icon glyph = SystemIcons.Error;
                Size glyphSize = SystemInformation.IconSize;
                int marginX = glyphSize.Width / 2 + borderSize;
                int marginY = glyphSize.Height / 2 + borderSize;
                Rectangle clientRect = ClientRectangle;
                Rectangle textRect = clientRect;

                textRect.X = 2 * marginX + glyphSize.Width;
                textRect.Y = 3 * marginY;
                textRect.Width -= (textRect.X + marginX + borderSize);
                textRect.Height -= (textRect.Y + marginY + borderSize);

                // Now, quickly fill and draw.  Because we don't know how big the
                // text will eventually be, we are going to cause some flicker.  At
                // least put all the drawing operations together here so you don't
                // see it as much.
                //
                pe.Graphics.FillRectangle(SystemBrushes.Control, marginX, marginY, clientRect.Width - 2 * marginX, marginY / 2);
                pe.Graphics.DrawIcon(glyph, marginX, 3 * marginY);
                pe.Graphics.DrawString(errorMessage, Font, SystemBrushes.WindowText, textRect);
            }
        }      

        public void OnSelectionChanged(object o, EventArgs e) {
            
            int id = -1;
            
            IComponent component = SelectionService.PrimarySelection as IComponent;
            if (component != null) {
                ComponentCollection components = designerHost.Container.Components;    
                for(int index=0; index < components.Count; ++index) {
                    if (components[index] == component) {
                        id = index;
                        break;
                    }
                }
            }
        }  
        
        /// <summary>
        ///     Paints the surface of the document window with the given error collection
        /// </summary>
        public void ReportErrors(ICollection errors) {
            if (errorList == null) {
                errorList = new ArrayList();
            }
            else {
                errorList.Clear();
            }
            errorList.AddRange(errors);
            
            // Output errors to trace log so developers can find it
            //
            foreach(object err in errorList) {
                Trace.WriteLine(err.ToString());
            }
            
            SetDesigner(null);
        }

        /// <summary>
        ///     Establishes the given designer as the main top level designer for the document.
        /// </summary>
        /// <param name='document'>
        ///     The designer to make top-level.
        /// </param>
        public void SetDesigner(IRootDesigner document) {

            ISelectionService ss = SelectionService;
            
            if (designerView != null) {
                if (ss != null) {
                    ss.SelectionChanged -= new EventHandler(this.OnSelectionChanged);
                }
                Controls.Remove(designerView);
                designerView = null;
            }
            
            docObject = null;

            if (document != null) {
            
                if (ss != null) {
                    ss.SelectionChanged += new EventHandler(this.OnSelectionChanged);
                }
            
                // If we got a designer, then clear our error list.
                if (errorList != null) {
                    errorList.Clear();
                }

                // Demand create the designer holder, if it doesn't already exist.
                ViewTechnology[] technologies = document.SupportedTechnologies;
                bool supportedTechnology = false;
                
                foreach(ViewTechnology tech in technologies) {
                    switch(tech) {
                        case ViewTechnology.WindowsForms: {
                            designerView = (Control)document.GetView(ViewTechnology.WindowsForms);
                            designerView.Dock = DockStyle.Fill;
                            Controls.Add(designerView);
                            supportedTechnology = true;
                            break;
                        }
                            
                        case ViewTechnology.Passthrough: {
                            docObject = document.GetView(ViewTechnology.Passthrough);
                            supportedTechnology = true;
                            break;
                        }
                    }
                    
                    // Stop looping if we found one
                    //
                    if (supportedTechnology) {
                        break;
                    }
                }
                
                // If we didn't find a supported technology, report it.
                //
                if (!supportedTechnology) {
                    throw new Exception(SR.GetString(SR.CODEMANUnsupportedTechnology, designerHost.RootComponent.GetType().FullName));
                }
            }
        }

        private class DocumentWindowAccessibleObject : ControlAccessibleObject {

            public DocumentWindowAccessibleObject(Control owner) : base(owner) {
            }

            public override string Description {
                get {
                    string errorMessage = ((DocumentWindow)Owner).ErrorMessage;
                    if (errorMessage != null) {
                        return errorMessage;
                    }
                    return base.Description;
                }
            }
        }

        /// <summary>
        ///     This class is the object that we expose to the Visual Studio shell.  It
        ///     implements all of the view interfaces that we are interested in.
        /// </summary>
        private class DocumentWindowPane : VsWindowPane, NativeMethods.IOleServiceProvider, IVsExtensibleObject {
            private IDesignerHost       host;
            private DocumentWindow      window;
            private NativeMethods.MSG   msg;

            /// <summary>
            ///     Creates a new document window pane which can be handed to the VS
            ///     shell.
            /// </summary>
            /// <param name='window'>
            ///     The document window for the designer.
            /// </param>
            /// <param name='host'>
            ///     The designer host, through which we can obtain services.
            /// </param>
            public DocumentWindowPane(DocumentWindow window, IDesignerHost host) {
                this.window = window;
                this.host = host;
                this.msg = new NativeMethods.MSG();
            }

            /// <summary>
            ///     Closes the window pane.  We override this so that we can
            ///     destroy the designer.
            /// </summary>
            public override int ClosePane() {

                ISelectionService selService = (ISelectionService)GetService(typeof(ISelectionService));
                if (selService != null) {
                    selService.SetSelectedComponents(null);
                }

                // Destroy the designer
                //
                if (host is IVSMDDesigner) {
                    ((IVSMDDesigner)host).Dispose();
                }

                // Close the actual window.  This
                // must be after the designer desctruction, because
                // closing the window will cause all components
                // on it to be destroyed.
                //
                base.ClosePane();

                return NativeMethods.S_OK;
            }
            
            /// <summary>
            ///     Our window pane overrides GetService so that it can cough up the
            ///     various services that the designer host offers.  When we get
            ///     sited, we push the site SP into the designer host as well, which
            ///     means that designer host now completely implements our GetService.
            /// </summary>
            /// <param name='serviceClass'>
            ///     The class of the service to retrieve.
            /// </param>
            /// <returns>
            ///     an instance of serviceClass if successful, or null.
            /// </returns>
            public override object GetService(Type serviceClass) {
                return host.GetService(serviceClass);
            }

            /// <summary>
            ///     We implement this abstract method so that the window pane can
            ///     get to our window.
            /// </summary>
            protected override IWin32Window GetWindow() {
                return window;
            }

            /// <summary>
            ///     We override VsWindowPane's version of this so we can hand our site
            ///     back to the designer host.  This is necessary so we can get the
            ///     right service routing.
            /// </summary>
            protected override void OnServicesAvailable() {
                // get our site
                object site = null;
                Guid g = typeof(NativeMethods.IOleServiceProvider).GUID;
                site = this.GetSite(ref g);
                if (site != null) {
                    NativeMethods.IObjectWithSite ows = (NativeMethods.IObjectWithSite)host.GetService(typeof(NativeMethods.IObjectWithSite));
                    if (ows != null) {
                        ows.SetSite(site);
                    }
                }
                else {
                    Debug.Fail("Failed to get site for DesignerHost");
                }
                    
                // Signal our perf driver that this event is complete.  This signals that the
                // designer has been created and shown.
                //
                DesignerPackage.SignalPerformanceEvent();
            }

            /// <summary>
            ///     This happens when a user double-clicks a toolbox item.  We add the
            ///     item to the center of the form.
            /// </summary>
            /// <seealso cref='IVsToolboxUser'/>
            protected override bool OnToolPicked(ToolboxItem toolboxItem) {

                // Otherwise, add the component.
                //
                Cursor  oldCursor = Cursor.Current;

                try {
                    Cursor.Current = Cursors.WaitCursor;

                    IComponent c = host.RootComponent;

                    Debug.Assert(c != null, "Designer host has no base component");
                    IDesigner designer = host.GetDesigner(c);

                    if (designer is IToolboxUser) {
                        ((IToolboxUser)designer).ToolPicked(toolboxItem);
                    }
                }
                finally {
                    Cursor.Current = oldCursor;
                }
                return true;
            }

            /// <summary>
            ///     Forward these key messages to the properties window so it can have a look-see.
            /// </summary>
            protected override bool OnTranslateAccelerator(ref Message m) {
                msg.hwnd = m.HWnd;
                msg.message = m.Msg;
                msg.wParam = m.WParam;
                msg.lParam = m.LParam;

                return window.PreProcessMessage(ref m);
            }

            /// <summary>
            ///      This retrieves our extensibility object for this document.  Our root
            ///      extensibility object is IDesignerHost.
            /// </summary>
            /// <param name='propName'>
            ///     The name of the extensibility object to retrieve.  We only understand
            ///     one:  LOGVIEWID_Designer.
            /// </param>
            /// <seealso cref='Microsoft.VisualStudio.Interop.IVsExtensibleObject'/>
            object IVsExtensibleObject.GetAutomationObject(String propName) {
                // Default : null or LOGVIEW_Designer
                //
                if (propName == null || String.Compare(propName, LOGVIEWID_Designer.ToString(), false, CultureInfo.InvariantCulture) == 0) {
                    return host;
                }
                
                // Everything else, just to a host.GetService!
                //
                object obj = null;
                Type t = host.GetType(propName);
                if (t != null) {
                    obj = host.GetService(t);
                }
                
                if (obj == null) {
                    throw new COMException("", NativeMethods.E_NOINTERFACE);
                }
                return obj;
            }

            /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.FlushPendingChanges"]/*' />
            /// <devdoc>
            ///     This is similar to CommitPendingCahnges.  This method is called when the document window 
            ///     should flush any state it has been storing to its underlying buffer.  FlushPendingChanges
            ///     allows you to implement a lazy-write mechanism for your document.  CommitPendingChanges,
            ///     on the other hand, is intended to commit small editors (such as from a text box) before
            ///     focus leaves to another window.
            /// </devdoc>
            protected override void FlushPendingChanges() {

                /// This is called by VS at an appropriate time when we
                /// should commit any changes we have to disk.
                if (host is IVSMDDesigner) {
                    ((IVSMDDesigner)host).Flush();
                }
            }
            
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.NativeMethods.IOleServiceProvider.QueryService"]/*' />
            /// <devdoc>
            ///     Default QueryService implementation.  This will demand create all
            ///     services that were passed into VsPackage's constructor.  You may
            ///     use the GetService method to resolve services in the CLR
            /// </devdoc>
            int NativeMethods.IOleServiceProvider.QueryService(ref Guid sid, ref Guid iid, out IntPtr ppvObj) {
                int hr = NativeMethods.E_NOINTERFACE;
                
                if (sid == typeof(IDesignerHost).GUID ||
                    sid == typeof(IVSMDDesigner).GUID) {
                    if (iid.Equals(NativeMethods.IID_IUnknown)) {
                        ppvObj = Marshal.GetIUnknownForObject(host);
                    }
                    else {
                        IntPtr pUnk = Marshal.GetIUnknownForObject(host);
                        hr = Marshal.QueryInterface(pUnk, ref iid, out ppvObj);
                        Marshal.Release(pUnk);
                    }
                }
                else {
                    ppvObj = IntPtr.Zero;
                }
    
                return hr;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\codeloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {

    using System;
    using System.Collections;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    
    /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader"]/*' />
    /// <devdoc>
    ///     This is a simple class that provides code-model specific
    ///     loading for a designer loader.  We use this as a base
    ///     class so Designerloader can be abstracted out of 
    ///     the logic, which will allow us to drop in either
    ///     CodeDom or CodeModel support easily in the future.
    /// </devdoc>
    internal abstract class CodeLoader {
        private IDesignerLoaderHost loaderHost;
        private TextBuffer buffer;
        private bool reloadSupported;
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.CodeLoader"]/*' />
        /// <devdoc>
        ///     Creates a new code loader.
        /// </devdoc>
        protected CodeLoader(TextBuffer buffer, IDesignerLoaderHost loaderHost) {
            this.buffer = buffer;
            this.loaderHost = loaderHost;
        }
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.Buffer"]/*' />
        /// <devdoc>
        ///     The text buffer for this loader.
        /// </devdoc>
        protected TextBuffer Buffer {
            get {
                return buffer;
            }
        }
        
        /// <devdoc>
        ///     Returns true if the design surface is dirty.
        /// </devdoc>
        public abstract bool IsDirty { get; set;}
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.LoaderHost"]/*' />
        /// <devdoc>
        ///     The designer loader host, which can be used to add and remove
        ///     services.
        /// </devdoc>
        protected IDesignerLoaderHost LoaderHost {
            get {
                Debug.Assert(loaderHost != null, "Need a loader host either too early or too late");
                return loaderHost;
            }
        }

        public virtual bool NeedsReload {
            get{
                return true;
            }
        }
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.ReloadSupported"]/*' />
        /// <devdoc>
        ///     Determines if the designer loader will support reload.  Not all
        ///     code loaders can handle this.
        /// </devdoc>
        public bool ReloadSupported {
            get {
                return reloadSupported;
            }
            set {
                reloadSupported = value;
            }
        }
        
        /// <devdoc>
        ///     Called before loading actually begins.
        /// </devdoc>
        public virtual void BeginLoad(ArrayList errorList) {
        }
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.CreateValidIdentifier"]/*' />
        /// <devdoc>
        ///     This may modify name to make it a valid variable identifier.
        /// </devdoc>
        public virtual string CreateValidIdentifier(string name) { return name; }
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.Dispose"]/*' />
        /// <devdoc>
        ///     You should override this to remove any services you previously added.
        /// </devdoc>
        public virtual void Dispose() {
            loaderHost = null;
        }
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.EndLoad"]/*' />
        /// <devdoc>
        ///     Called when the designer loader finishes with all of its dependent
        ///     loads.
        /// </devdoc>
        public virtual void EndLoad(bool successful) {
        }
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.Flush"]/*' />
        /// <devdoc>
        ///     Called when the designer loader wishes to flush changes to disk.
        /// </devdoc>
        public virtual void Flush() {
        }

        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.IsNameUsed"]/*' />
        /// <devdoc>
        ///     Called during the name creation process to see if this name is already in 
        ///     use.
        /// </devdoc>
        public virtual bool IsNameUsed(string name) { return false;}
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.IsValidIdentifier"]/*' />
        /// <devdoc>
        ///     Called during the name creation process to see if this name is valid.
        /// </devdoc>
        public abstract bool IsValidIdentifier(string name);
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.Load"]/*' />
        /// <devdoc>
        ///     Loads the document.  This should return the fully qualified name
        ///     of the class the document is editing.
        /// </devdoc>
        public abstract string Load();

        /// <devdoc>
        ///     Resets the loader.  Return true if the reset is successful, or false if a new 
        ///     CodeLoader must be created
        /// </devdoc>
        public abstract bool Reset();
        
        /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.ValidateIdentifier"]/*' />
        /// <devdoc>
        ///     Called during the name creation process to see if this name is valid.
        /// </devdoc>
        public virtual void ValidateIdentifier(string name) {
            if (!IsValidIdentifier(name)) {
                throw new Exception(SR.GetString(SR.CODEMANInvalidIdentifier, name));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\iinitializedesignerloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="IInitializeDesignerLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;

    /// <include file='doc\IInitializeDesignerLoader.uex' path='docs/doc[@for="IInitializeDesignerLoader"]/*' />
    /// <devdoc>
    ///     This interface provides a way to initialize our designer loaders.
    /// </devdoc>
    public interface IInitializeDesignerLoader {
    
        /// <include file='doc\IInitializeDesignerLoader.uex' path='docs/doc[@for="IInitializeDesignerLoader.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes a designer loader.
        /// </devdoc>
        void Initialize(IServiceProvider serviceProvider, TextBuffer buffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\soapdesignerloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapDesignerLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {
    using Microsoft.CSharp;
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Reflection;
    using System.Globalization;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Soap;
    using System.Text;
    
    /// <include file='doc\SoapDesignerLoader.uex' path='docs/doc[@for="SoapDesignerLoader"]/*' />
    /// <devdoc>
    ///     This is the language engine for the C# language.
    /// </devdoc>
    internal sealed class SoapDesignerLoader : BaseDesignerLoader {

        /// <include file='doc\SoapDesignerLoader.uex' path='docs/doc[@for="SoapDesignerLoader.CreateBaseName"]/*' />
        /// <devdoc>
        ///     Given a data type this fabricates the main part of a new component
        ///     name, minus any digits for uniqueness.
        /// </devdoc>
        protected override string CreateBaseName(Type dataType) {
            string baseName = dataType.Name;
            
            // camel case the base name.
            //
            StringBuilder b = new StringBuilder(baseName.Length);
            for (int i = 0; i < baseName.Length; i++) {
                if (Char.IsUpper(baseName[i]) && (i == 0 || i == baseName.Length - 1 || Char.IsUpper(baseName[i+1]))) {
                    b.Append(Char.ToLower(baseName[i], CultureInfo.InvariantCulture));
                }
                else {
                    b.Append(baseName.Substring(i));
                    break;
                }
            }
            baseName = b.ToString();
            return baseName;
        }
        
        /// <include file='doc\SoapDesignerLoader.uex' path='docs/doc[@for="SoapDesignerLoader.CreateCodeLoader"]/*' />
        /// <devdoc>
        ///     Called to create the MCM loader.
        /// </devdoc>
        protected override CodeLoader CreateCodeLoader(TextBuffer buffer, IDesignerLoaderHost host) {
            
            // Now create the generic loader
            //
            CodeDomProvider provider = new SoapCodeProvider();
            return new CodeDomLoader(this, provider, buffer, host);
        }

        private class SoapCodeProvider : CodeDomProvider, ICodeGenerator, ICodeCompiler, ICodeParser {
            
            public override ICodeGenerator CreateGenerator() {
                return this;
            }
    
            public override ICodeCompiler CreateCompiler() {
                return this;
            }
            
            public override ICodeParser CreateParser(){
                return this;
            }
            
            private void Generate(object o, TextWriter w) {
                MemoryStream s = new MemoryStream();
                SoapFormatter formatter = new SoapFormatter();
                formatter.Serialize(s, o);
                s.Seek(0, SeekOrigin.Begin);
                w.Write((new StreamReader(s)).ReadToEnd());
                w.Flush();
            }
            
            CompilerResults ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit) {
                CodeDomProvider p = new CSharpCodeProvider();
                return p.CreateCompiler().CompileAssemblyFromDom(options, compilationUnit);
            }
    
            CompilerResults ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName) {
                return null;
            }
    
            CompilerResults ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source) {
                return null;
            }
    
            CompilerResults ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] compilationUnits) {
                CodeDomProvider p = new CSharpCodeProvider();
                return p.CreateCompiler().CompileAssemblyFromDomBatch(options, compilationUnits);
            }
    
            CompilerResults ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, string[] fileNames) {
                return null;
            }
    
            CompilerResults ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, string[] sources) {
                return null;
            }
            
            bool ICodeGenerator.IsValidIdentifier(string value) {
                return true;
            }
    
            void ICodeGenerator.ValidateIdentifier(string value) {}
    
            string ICodeGenerator.CreateEscapedIdentifier(string value) { return value; }
    
            string ICodeGenerator.CreateValidIdentifier(string value) { return value; }
    
            string ICodeGenerator.GetTypeOutput(CodeTypeReference typeRef) { 
                string s;
                if (typeRef.ArrayElementType != null) {
                    // Recurse up
                    s = ((ICodeGenerator)this).GetTypeOutput(typeRef.ArrayElementType);
                }
                else {
    
                    s = typeRef.BaseType;
                    if (s.Length == 0) {
                        s = "System.Void";
                    }
                    else {
                        // replace $ with . for nested classes.
                        //
                        s = s.Replace('$', '.');
                    }
                }
                // Now spit out the array postfix
                if (typeRef.ArrayRank > 0) {
                    char [] results = new char [typeRef.ArrayRank + 1];
                    results[0] = '[';
                    results[typeRef.ArrayRank] = ']';
                    for (int i = 1; i < typeRef.ArrayRank; i++) {
                        results[i] = ',';
                    }
                    s += new string(results);
                }               
                return s;
            }
    
            bool ICodeGenerator.Supports(GeneratorSupport supports) { return true;}
    
            void ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o) {
                Generate(e, w);
            }
    
            void ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o) {
                Generate(e, w);
            }
    
            void ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o) {
                Generate(e, w);
            }
    
            void ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o) {
                Generate(e, w);
            }
    
            void ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o) {
                Generate(e, w);
            }
        
            CodeCompileUnit ICodeParser.Parse(TextReader codeStream) {
                string text = codeStream.ReadToEnd();
                MemoryStream s = new MemoryStream();
                StreamWriter writer = new StreamWriter(s);
                writer.Write(text);
                writer.Flush();
                s.Seek(0, SeekOrigin.Begin);
                
                SoapFormatter formatter = new SoapFormatter();
                try {
                    object o = formatter.Deserialize(s);
                    Debug.Assert(o is CodeCompileUnit, "Expected a code compile unit out of this code");
                    if (o is CodeCompileUnit) {
                        return (CodeCompileUnit)o;
                    }
                }
                catch (SerializationException ex) {
                    Debug.Fail("Serialization exception occurred deserializing parse stream: " + ex.ToString());
                }
                
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\codedomloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDomLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {

    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Windows.Forms;
    using Microsoft.VisualStudio.Designer.Host;
    
    /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader"]/*' />
    /// <devdoc>
    ///     This is a simple class that provides CodeDom specific
    ///     loading for a designer loader.
    /// </devdoc>

    internal class CodeDomLoader : CodeLoader, 
        IDesignerSerializationManager, 
        IEventBindingService, 
        IDesignerSerializationService
        {

        #if DEBUG
        private static Stack markTimes = new Stack();
        private static TraceSwitch codeGenTimings = new TraceSwitch("CodeGenTimings", "Trace UndoRedo");
        #endif

        [System.Diagnostics.Conditional("DEBUG")]          
        public static void StartMark() {
            #if DEBUG
            markTimes.Push(DateTime.Now);
            #endif
        }

        [System.Diagnostics.Conditional("DEBUG")]          
        public static void EndMark(string desc) {
            #if DEBUG
                if (markTimes.Count == 0) {
                    throw new Exception("Unbalanced count!");
                }
    
                long time = DateTime.Now.Ticks;
                long mark = ((DateTime)markTimes.Pop()).Ticks;
                int ms = (int)((time - mark) / 10000);
                Debug.WriteLineIf(codeGenTimings.TraceVerbose, desc + ":" + ms.ToString() + "ms");
            #endif
        }
    
        // Stuff the CodeDom loader maintains.
        //
        private DesignerLoader          loader;
        private CodeDomProvider         provider;
        private ICodeGenerator          codeGenerator;
        private ICodeParser             codeParser;
        private bool                    codeParserChecked;
        private bool                    designerDirty;
        private bool                    codeDomDirty;
        private bool                    caseInsensitive;
        private CodeDomSerializer       rootSerializer;
        private CodeCompileUnit         compileUnit;
        private CodeNamespace           documentNamespace;
        private CodeTypeDeclaration     documentType;
        private ArrayList               documentFailureReasons;
        private UndoManager             undoManager;
        
        // Stuff for the serialization manager.
        //
        private ResolveNameEventHandler         resolveNameEventHandler;
        private EventHandler                    serializationCompleteEventHandler;
        private ArrayList                       designerSerializationProviders;
        private Hashtable                       instancesByName;
        private Hashtable                       namesByInstance;
        private Hashtable                       serializers;
        private ArrayList                       errorList;
        private ContextStack                    contextStack;
        private Hashtable                       handlerCounts;
        private bool                            loadError;
        private PropertyDescriptorCollection    propertyCollection;
        
        // Stuff for IEventBindingService
        //
        private Hashtable eventProperties;
        private IComponent showCodeComponent;
        private EventDescriptor showCodeEventDescriptor;

        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.CodeDomLoader"]/*' />
        /// <devdoc>
        ///     Creates a new code loader.  This will throw if the buffer doesn't contain any
        ///     classes we can load.
        /// </devdoc>
        public CodeDomLoader(DesignerLoader loader, CodeDomProvider provider, TextBuffer buffer, IDesignerLoaderHost host) : base(buffer, host) {
            this.loader = loader;
            this.provider = provider;
            this.rootSerializer = null;
            this.caseInsensitive = ((provider.LanguageOptions & LanguageOptions.CaseInsensitive) != 0);
            
            // The DocumentType property will search for the document type declaration
            // and store the appropriate serializer.
            //
            if (DocumentType == null) {
                
                // Did we get any reasons why we can't load this document?  If so, synthesize a nice
                // description to the user.
                //
                Exception ex;
                
                if (documentFailureReasons != null) {
                    StringBuilder builder = new StringBuilder();
                    foreach(string failure in documentFailureReasons) {
                        builder.Append("\r\n");
                        builder.Append(failure);
                    }
                    ex = new SerializationException(SR.GetString(SR.SerializerNoRootSerializerWithFailures, builder.ToString()));
                    ex.HelpLink = SR.SerializerNoRootSerializerWithFailures;
                }
                else {
                    ex = new SerializationException(SR.GetString(SR.SerializerNoRootSerializer));
                    ex.HelpLink = SR.SerializerNoRootSerializer;
                }
                
                throw ex;
            }
        
            host.AddService(typeof(CodeDomProvider), provider);
            host.AddService(typeof(IDesignerSerializationManager), this);
            host.AddService(typeof(IDesignerSerializationService), this);
            host.AddService(typeof(IEventBindingService), this);
            host.AddService(typeof(CodeTypeDeclaration), new ServiceCreatorCallback(this.OnDemandCreateService));
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DocumentType"]/*' />
        /// <devdoc>
        ///     Retrieves the document type declaration for the designer.
        /// </devdoc>
        private CodeTypeDeclaration DocumentType {
            get {
                if (documentType == null) {
                
                    documentFailureReasons = null;
                
                    if (compileUnit == null) {
                        ICodeParser parser = CodeParser;
                        
                        Debug.Assert(parser != null, "Could not get a parser for this language, so the designer's won't work.  This is a problem with the language engine you are using and NOT a common language runtime or designer issue.");
                        
                        if (parser != null) {
                            BufferTextReader reader = new BufferTextReader(Buffer, LoaderHost);
                            compileUnit = parser.Parse(reader);
                        }
                    }

                    if (compileUnit == null) {
                        Exception ex = new SerializationException(SR.GetString(SR.DESIGNERLOADERNoLanguageSupport));
                        ex.HelpLink = SR.DESIGNERLOADERNoLanguageSupport;
                        
                        throw ex;
                    }

                    this.documentNamespace = null;
                    bool reloadSupported = false;
                    
                    // Look in the compile unit for a class we can load.  The first one we find
                    // that has an appropriate serializer attribute, we take.
                    //
                    ITypeResolutionService ts = LoaderHost.GetService(typeof(ITypeResolutionService)) as ITypeResolutionService;

                    foreach(CodeNamespace ns in compileUnit.Namespaces) {
                    
                        this.documentType = GetDocumentTypeFromNamespace(ts, ns, ref this.documentNamespace, ref this.rootSerializer, ref reloadSupported, ref this.documentFailureReasons);
                        
                        if (documentNamespace != null) {
                            ReloadSupported = reloadSupported;
                            break;
                        }
                    }
                }
                
                return documentType;
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.CodeGenerator"]/*' />
        /// <devdoc>
        ///     Retrieves the code generator for the designer.
        /// </devdoc>
        private ICodeGenerator CodeGenerator {
            get {
                if (codeGenerator == null) {
                    Debug.Assert(provider != null, "Provider doesn't exist -- caller should have guarded call to CodeGenerator property");
                    codeGenerator = provider.CreateGenerator();
                }
                return codeGenerator;
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.CodeParser"]/*' />
        /// <devdoc>
        ///     Retrieves the code generator for the designer.
        /// </devdoc>
        private ICodeParser CodeParser {
            get {
                if (!codeParserChecked && codeParser == null) {
                    Debug.Assert(provider != null, "Provider doesn't exist -- caller should have guarded call to CodeGenerator property");
                    codeParser = provider.CreateParser();
                    codeParserChecked = true;
                }
                return codeParser;
            }
        }
        
        /// <devdoc>
        ///     Returns true if the design surface is dirty.
        /// </devdoc>
        public override bool IsDirty {
            get {
                return designerDirty;
            }
            set {
                // force a dirty state.
                //
                this.designerDirty = value;
                this.codeDomDirty = value;
            }
        }

        /// <devdoc>
        ///     This property is offered up through our designer serialization manager.
        ///     We forward the request onto our code parser, which, if it returns true,
        ///     indicates that the parser will fabricate statements that are not
        ///     in user code.  The code dom serializer may use this knowledge to limit
        ///     the scope of parsing.  This property is explictly created through
        ///     a call to TypeDescriptor so its scope can remain private.
        /// </devdoc>
        private bool SupportsStatementGeneration {
            get {
                PropertyDescriptor supportGenerate = TypeDescriptor.GetProperties(CodeParser)["SupportsStatementGeneration"];
                if (supportGenerate != null && supportGenerate.PropertyType == typeof(bool)) {
                    return (bool)supportGenerate.GetValue(CodeParser);
                }
                return false;
            }
        }
        
        public override bool NeedsReload {
            get{ 
            
                // If we have no document, we definitely need a reload.
                //
                if (this.documentType == null || loadError) {
                    return true;
                }

                ICodeDomDesignerReload reloader = this.provider as ICodeDomDesignerReload;

                if (reloader != null) {

                    bool reload = true;

                    try {
                    
                        // otherwise, parse the file and see if we actually need to reload the mutha.
                        //
                        CodeDomLoader.StartMark();
                        ICodeParser parser = CodeParser;
                        if (parser != null) {
                            BufferTextReader reader = new BufferTextReader(Buffer, LoaderHost);
                            compileUnit = parser.Parse(reader);
                        }
                        CodeDomLoader.EndMark("Reload Parse I");
        
                        reload = reloader.ShouldReloadDesigner(compileUnit);
                    }
                    finally {
                        if (!reload) {
                            LoaderHost.RemoveService(typeof(CodeTypeDeclaration));
                            LoaderHost.AddService(typeof(CodeTypeDeclaration), new ServiceCreatorCallback(this.OnDemandCreateService));
                        }

                        // finally, make sure that the form name didn't change. the problem here is that
                        // a class could have been added at the top of the form that we'll later pick
                        // as our designable class, then turn around and respit code into that class.
                        //
                        // 
                        string oldTypeName = documentType.Name;

                        // null these out so we re-fetch these values.
                        //
                        this.documentType = null;
                        this.rootSerializer = null;

                        if (!reload) {
                            // now, pick up the info again.  Parsing for this is very very fast,
                            // and we'll pretty much always do this again shortly anyway, so it's not
                            // a big perf hit to do this here.
                            //
                            reload = DocumentType == null || DocumentType.Name != oldTypeName;
                        }
                    }
                    return reload;    
                }
                return true;
            }
        }

        /// <devdoc>
        ///     Increase the number of events that are using a given method handler.
        /// </devdoc>
        private void AddRefEventMethod(string methodName, EventDescriptor eventDesc) {
            string key = GetEventMethodKey(methodName, eventDesc);

            int count = 0;

            if (handlerCounts == null) {
                this.handlerCounts = new Hashtable();
            }
            else if (handlerCounts.Contains(key)) {
                count = (int)handlerCounts[key];
            }

            handlerCounts[key] = ++count;
        }

        /// <devdoc>
        ///     Called before loading actually begins.
        /// </devdoc>
        public override void BeginLoad(ArrayList errorList) {

            CodeDomLoader.StartMark();
        
            // Remove any connections we had to the change events.  If we're about to load, then
            // we do not want to know about any of these changes.
            //
            IComponentChangeService cs = (IComponentChangeService)LoaderHost.GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                cs.ComponentRename -= new ComponentRenameEventHandler(OnComponentRename);
                cs.ComponentAdded -= new ComponentEventHandler(OnComponentAdded);
                cs.ComponentRemoved -= new ComponentEventHandler(OnComponentRemoved);
            }
            
            if (undoManager != null) {
                undoManager.TrackChanges(false);
            }
            
            loadError = false;
            InitializeSerializationManager(errorList);
        }

        private bool CompareTypes(CodeTypeReference left, CodeTypeReference right) {
            if (left.ArrayRank != right.ArrayRank) {
                return false;
            }

            if (left.ArrayRank == 0) {
                 return left.BaseType == right.BaseType;
            }
            return CompareTypes(left.ArrayElementType, right.ArrayElementType);
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.CreateValidIdentifier"]/*' />
        /// <devdoc>
        ///     This may modify name to make it a valid variable identifier.
        /// </devdoc>
        public override string CreateValidIdentifier(string name) {
            return CodeGenerator.CreateValidIdentifier(name);
        }

        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.Dispose"]/*' />
        /// <devdoc>
        ///     You should override this to remove any services you previously added.
        /// </devdoc>
        public override void Dispose() {
            IDesignerLoaderHost host = LoaderHost;
            
            if (host != null) {
                host.RemoveService(typeof(CodeDomProvider));
                host.RemoveService(typeof(IDesignerSerializationManager));
                host.RemoveService(typeof(IDesignerSerializationService));
                host.RemoveService(typeof(IEventBindingService));
                host.RemoveService(typeof(CodeTypeDeclaration));
                
                IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                    cs.ComponentRename -= new ComponentRenameEventHandler(OnComponentRename);
                    cs.ComponentAdded -= new ComponentEventHandler(OnComponentAdded);
                    cs.ComponentRemoved -= new ComponentEventHandler(OnComponentRemoved);
                }
                
                if(undoManager != null) {
                    undoManager.Dispose();
                    undoManager = null;
                }
            }
            
            provider = null;
            codeGenerator = null;
            rootSerializer = null;
            compileUnit = null;
            documentNamespace = null;
            documentType = null;
            base.Dispose();
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EndLoad"]/*' />
        /// <devdoc>
        ///     Called when the designer loader finishes with all of its dependent
        ///     loads.
        /// </devdoc>
        public override void EndLoad(bool successful) {
        
            if (successful) {
            
                // After load, if we succeeded we listen to
                // component change events.  Any component change causes us
                // to dirty ourselves, so on next flush we will update the
                // code.
                //
                IComponentChangeService cs = (IComponentChangeService)LoaderHost.GetService(typeof(IComponentChangeService));
                Debug.Assert(cs != null, "No component change service -- we will not know when to update the code");
                if (cs != null) {
                    cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
                    cs.ComponentRename += new ComponentRenameEventHandler(OnComponentRename);
                    cs.ComponentAdded += new ComponentEventHandler(OnComponentAdded);
                    cs.ComponentRemoved += new ComponentEventHandler(OnComponentRemoved);
                }
                
                // Hook up the undo manager, which automates undo actions for us.
                //
                if (undoManager == null) {
                    undoManager = new UndoManager(rootSerializer, LoaderHost, Buffer);
                }
                else {
                    undoManager.TrackChanges(true);
                }
            }
            
            TerminateSerializationManager();

            CodeDomLoader.EndMark("Total Load");
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EnsureEventMethod"]/*' />
        /// <devdoc>
        ///     This is called by an EventPropertyDescriptor when the user changes the name of an event.
        ///     This does the legwork to create an event method body for the given event name.  it will
        ///     check for conflicts in base classes, and if they exist, it may rename the event.  The
        ///     new name is returned from the method.
        /// </devdoc>
        private string EnsureEventMethod(object component, string eventName, MemberAttributes modifiers, EventDescriptor e) {
        
            // If we're loading code or in an otherwise useless state, just return.
            //
            if (LoaderHost == null || LoaderHost.Loading || provider == null) return eventName;
            
            DelegateTypeInfo dti = new DelegateTypeInfo(e);
            
            CodeMemberMethod method = FindMethod(eventName, dti);
            
            // We found a matching method, so we return it.
            //
            if (method != null) {
                return eventName;
            }
            
            // If we got here, it means we didn't find a method in the code, so we must create one.
            // Before we go and create the method, we must search for the method in the base class hierarchy.  If
            // there is one, and it is not private, then we will need to modify our name.
            //
            Type baseType = LoaderHost.RootComponent.GetType().BaseType;
            Type[] paramTypes = new Type[dti.Parameters.Length];
            for(int i = 0; i < paramTypes.Length; i++) {
                paramTypes[i] = LoaderHost.GetType(dti.Parameters[i].Type.BaseType);
                if (paramTypes[i] == null) {
                    Exception ex = new Exception(SR.GetString(SR.SerializerInvalidProjectReferences, dti.Parameters[i].Type.BaseType));
                    ex.HelpLink = SR.SerializerInvalidProjectReferences;
                    
                    throw ex;
                }
            }
            
            MethodInfo methodInfo = baseType.GetMethod(eventName, paramTypes);
            
            while (methodInfo != null && !methodInfo.IsPrivate) {
                eventName = LoaderHost.RootComponent.Site.Name + "_" + eventName;
                methodInfo = baseType.GetMethod(eventName, paramTypes);
            }
            
            // Ok, we've established a new method name.  Make sure it is valid.
            //
            ICodeGenerator codeGen = provider.CreateGenerator();
            codeGen.ValidateIdentifier(eventName);
            
            // Now create the event.
            //
            method = new CodeMemberMethod();
            method.Name = eventName;
            method.Parameters.AddRange(dti.Parameters);
            method.ReturnType = dti.ReturnType;
            method.Attributes = modifiers;

            // put userdata that tells what event this is handing on the method
            // this is a perf key for Visual Basic so we can add the handles clauses when we create the method
            //
            //
            IReferenceService refSvc = (IReferenceService)LoaderHost.GetService(typeof(IReferenceService));
            if (refSvc != null) {
                string compName = refSvc.GetName(component);
                if (compName != null) {
                    method.UserData[typeof(EventDescriptor)] = e.Name;
                    method.UserData[typeof(IComponent)] = refSvc.GetName(component);
                }
            }

            DocumentType.Members.Add(method);
            codeDomDirty = true;
            
            return eventName;
        }                                                   
                                                           
                
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.FindMethod"]/*' />
        /// <devdoc>
        ///     Locates the method with the requested name and type information.
        ///     Returns null if the method wasn't found.
        /// </devdoc>
        private CodeMemberMethod FindMethod(string name, DelegateTypeInfo info) {
            CodeMemberMethod method = null;
            
            CodeTypeDeclaration doc = DocumentType;
            if (doc != null) {
                foreach(CodeTypeMember member in doc.Members) {
                    if (member is CodeMemberMethod) {
                        CodeMemberMethod m = (CodeMemberMethod)member;
                        if (string.Compare(m.Name, name, caseInsensitive, CultureInfo.InvariantCulture) != 0) {
                            continue;
                        }
                        
                        if (!TypesEqual(m.ReturnType, info.ReturnType) || m.Parameters.Count != info.Parameters.Length) {
                            continue;
                        }
                        
                        bool match = true;
                        for (int i = 0; i < info.Parameters.Length; i++) {
                            if (!(TypesEqual(m.Parameters[i].Type, info.Parameters[i].Type))) {
                                match = false;
                                break;
                            }
                        }
                        
                        if (match) {
                            method = m;
                            break;
                        }
                    }
                }
            }
            
            return method;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.Flush"]/*' />
        /// <devdoc>
        ///     Called when the designer loader wishes to flush changes to disk.
        /// </devdoc>
        public override void Flush() {
        
            // Flush handles two scenarios.  The designer may have triggered a 
            // dirty bit on us by changing a component.  In this case we must
            // invoke the root serializer to serialize their DOM, and then
            // merge this DOM back in with our existing tree.  The second
            // scenario is when our code DOM tree itself is dirty.  This 
            // can happen as a result of the first trigger, or it may also
            // happen as a result of adding an event method.  Either way,
            // this is the only place we push code back to the underlying
            // text buffer.
            //
            CodeDomLoader.StartMark();
            if (designerDirty && this.DocumentType != null) {
                
                Cursor oldCursor = Cursor.Current;
                Cursor.Current = Cursors.WaitCursor;
            
                try {
                    object codeElement = null;

                    CodeDomLoader.StartMark();
                    
                    // Ask the serializer for the root component to serialize.  This should return
                    // a CodeTypeDeclaration, which we will plug into our existing code DOM tree.
                    //
                    IDesignerLoaderHost host = LoaderHost;
                    Debug.Assert(host != null, "code model loader was asked to flush after it has been disposed.");
                    if (host != null) {
                        IComponent baseComp = host.RootComponent;

                        if (baseComp == null) {
                            // we probably failed our last load.
                            return;
                        }

                        Debug.Assert(rootSerializer != null, "What are we saving right now?  Base component has no serializer: " + baseComp.GetType().FullName);
                        
                        if (rootSerializer != null) {

                            ArrayList errors = new ArrayList();
                        
                            InitializeSerializationManager(errors);
                            
                            try {
                                codeElement = rootSerializer.Serialize(this, baseComp);
                                Debug.Assert(codeElement is CodeTypeDeclaration, "Root CodeDom serializer must return a CodeTypeDeclaration");
                            }
                            finally {
                                try {
                                    if (serializationCompleteEventHandler != null) {
                                        serializationCompleteEventHandler(this, EventArgs.Empty);
                                    }
                                }
                                catch {}
                            
                                // After serialization we always clear out all of the
                                // state we stored. Serializers are supposed to be
                                // stateless, so we "enforce" it here.
                                //
                                TerminateSerializationManager();

                                IErrorReporting errorSvc = host as IErrorReporting;
                                if (errorSvc != null) {
                                    errorSvc.ReportErrors(errors);
                                }
                            }
                        }
                    }
                    
                    // Now we must integrate the code DOM tree from the serializer with
                    // our own tree.  If changes were made this will set codeDomDirty = true.
                    //
                    if (codeElement is CodeTypeDeclaration) {
                        IntegrateSerializedTree((CodeTypeDeclaration)codeElement);
                    }
                    
                    designerDirty = false;
                    loadError = false;

                    if (this.undoManager != null) {
                        undoManager.OnDesignerFlushed();
                    }
                    CodeDomLoader.EndMark("Serialize tree");
                }
                finally {
                    Cursor.Current = oldCursor;
                }
            }
            
            if (codeDomDirty) {
                codeDomDirty = false;

                CodeDomLoader.StartMark();

                BufferTextWriter writer = new BufferTextWriter(Buffer);
                CodeGenerator.GenerateCodeFromCompileUnit(compileUnit, writer, null);
                writer.Flush();
                
                CodeDomLoader.EndMark("Generate unit total");
            }

            CodeDomLoader.EndMark("** Full Flush **");
        }

        internal static CodeTypeDeclaration GetDocumentType(IServiceProvider sp, object pHier, CodeDomProvider codeDomProvider, TextBuffer buffer, out CodeNamespace documentNamespace) {

            ICodeParser parser = codeDomProvider.CreateParser();
            Debug.Assert(parser != null, "Could not get a parser for this language, so the designer's won't work.  This is a problem with the language engine you are using and NOT a common language runtime or designer issue.");
            CodeTypeDeclaration typeDecl = null;
            documentNamespace = null;

            if (parser != null) {
                BufferTextReader reader = new BufferTextReader(buffer, sp);
                CodeCompileUnit compileUnit = parser.Parse(reader);
    
                if (compileUnit == null) {
                    Exception ex = new SerializationException(SR.GetString(SR.DESIGNERLOADERNoLanguageSupport));
                    ex.HelpLink = SR.DESIGNERLOADERNoLanguageSupport;
    
                    throw ex;
                }

                // Look in the compile unit for a class we can load.  The first one we find
                // that has an appropriate serializer attribute, we take.
                //
                ArrayList failures = null;
                CodeDomSerializer serializer = null;
                bool reloadSupported = false;

                ITypeResolutionServiceProvider tsp = sp.GetService(typeof(ITypeResolutionServiceProvider)) as ITypeResolutionServiceProvider;
                Debug.Assert(tsp != null, "No type resolutoinservice provider, we can't load types");
                ITypeResolutionService ts = null;
                if (tsp != null) {
                    ts = tsp.GetTypeResolutionService(pHier);
                }

                foreach(CodeNamespace ns in compileUnit.Namespaces) {
                    typeDecl = GetDocumentTypeFromNamespace(ts, ns, ref documentNamespace, ref serializer, ref reloadSupported, ref failures);
                    if (typeDecl != null) {
                        break;
                    }
                }
            }

            return typeDecl;
        }

        private static CodeTypeDeclaration GetDocumentTypeFromNamespace(ITypeResolutionService ts, CodeNamespace codeNameSpace, ref CodeNamespace documentNamespace, ref CodeDomSerializer rootSerializer, ref bool reloadSupported, ref ArrayList documentFailureReasons) {
            CodeTypeDeclaration documentType = null;
            bool firstClass = true;

            foreach(CodeTypeDeclaration typeDecl in codeNameSpace.Types) {
                            
                // Uncover the baseType of this class
                //
                Type baseType = null;
                foreach(CodeTypeReference typeRef in typeDecl.BaseTypes) {
                    Type t = ts.GetType(typeRef.BaseType);

                    if (t != null && !(t.IsInterface)) {
                        baseType = t;
                        break;
                    }
                    
                    if (t == null) {
                        if (documentFailureReasons == null) {
                            documentFailureReasons = new ArrayList();
                        }
                        documentFailureReasons.Add(SR.GetString(SR.SerializerTypeFailedTypeNotFound, typeDecl.Name, typeRef.BaseType));
                    }
                }
                
                if (baseType != null) {
                
                    bool foundAttribute = false;
                
                    // Walk the member attributes for this type, looking for an appropriate serializer
                    // attribute.
                    //
                    AttributeCollection attributes = TypeDescriptor.GetAttributes(baseType);
                    foreach(Attribute attr in attributes) {
                        if (attr is RootDesignerSerializerAttribute) {
                        
                            foundAttribute = true;
                            RootDesignerSerializerAttribute ra = (RootDesignerSerializerAttribute)attr;
                            string typeName = ra.SerializerBaseTypeName;
                            
                            // This serializer must support a CodeModelSerializer or we're not interested.
                            //
                            if (typeName != null && ts.GetType(typeName) == typeof(CodeDomSerializer)) {
                                Type serializerType = ts.GetType(ra.SerializerTypeName);
                                if (serializerType != null) {

                                    // Only allow loading the first class in the file.  We have no good way
                                    // of conveying what class we chose as designable to the project system,
                                    // so it will break if it's not the first class.
                                    if (firstClass) {
                                        rootSerializer = (CodeDomSerializer)Activator.CreateInstance(serializerType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
                                        reloadSupported = ra.Reloadable;
                                    }
                                    else {
                                        throw new InvalidOperationException(SR.GetString(SR.SerializerTypeNotFirstType, typeDecl.Name));
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // If we didn't find a serializer for this type, report it.
                    //
                    if (rootSerializer == null) {
                            
                        if (documentFailureReasons == null) {
                            documentFailureReasons = new ArrayList();
                        }
                        
                        if (foundAttribute) {
                            documentFailureReasons.Add(SR.GetString(SR.SerializerTypeFailedTypeDesignerNotInstalled, typeDecl.Name, baseType.FullName));
                        }
                        else {
                            documentFailureReasons.Add(SR.GetString(SR.SerializerTypeFailedTypeNotDesignable, typeDecl.Name, baseType.FullName));
                        }
                    }
                }
                
                // If we found a serializer, then we're done.  Save this type and namespace for later
                // use.
                //
                if (rootSerializer != null) {
                    documentNamespace = codeNameSpace;
                    documentType = typeDecl;
                    break;
                }

                firstClass = false;
            }
            
            if (documentNamespace != null) {
                return documentType;
            }
            
            // failed to find a document to load...
            //
            return null;
        }


        /// <devdoc>
        ///  Generates a key based on a method name and it's parameters by just concatenating the
        ///  parameters.
        /// </devdoc>
        private string GetEventDescriptorHashCode(EventDescriptor eventDesc) {
            StringBuilder builder = new StringBuilder(eventDesc.Name);
            builder.Append(eventDesc.EventType.GetHashCode().ToString());
            foreach(Attribute a in eventDesc.Attributes) {
                builder.Append(a.GetHashCode().ToString());
            }
            
            return builder.ToString();
        }

        /// <devdoc>
        ///  Generates a key based on a method name and it's parameters by just concatenating the
        ///  parameters.
        /// </devdoc>
        private string GetEventMethodKey(string methodName, EventDescriptor eventDesc) {
            if (methodName == null || eventDesc == null) {
                throw new ArgumentNullException();
            }

            Type delegateType = eventDesc.EventType;

            MethodInfo invoke = delegateType.GetMethod("Invoke");

            foreach(ParameterInfo param in invoke.GetParameters()) {
                methodName += param.ParameterType.FullName;
            }
            return methodName;
        }

        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.InitializeSerializationManager"]/*' />
        /// <devdoc>
        ///     Initializes the serialization manager for use.  We only
        ///     keep the serialization manager's state alive during
        ///     serialization or deserialization to prevent serializers
        ///     from hanging on.
        /// </devdoc>
        private void InitializeSerializationManager(ArrayList errorList) {
            this.errorList = errorList;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IntegrateSerializedTree"]/*' />
        /// <devdoc>
        ///     Takes the given code element and integrates it into the existing CodeDom
        ///     tree.
        /// </devdoc>
        private void IntegrateSerializedTree(CodeTypeDeclaration newDecl) {
            CodeTypeDeclaration docDecl = DocumentType;
            
            if (docDecl == null) {
                return;
            }

            
            // Update the class name of the code type, in case it is different.
            //
            if (string.Compare(docDecl.Name, newDecl.Name, caseInsensitive, CultureInfo.InvariantCulture) != 0) {
                docDecl.Name = newDecl.Name;
                codeDomDirty = true;
            }
            
            if (!docDecl.Attributes.Equals(newDecl.Attributes)) {
                docDecl.Attributes = newDecl.Attributes;
                codeDomDirty = true;
            }
            
            // Now, hash up the member names in the document and use this
            // when determining what to add and what to replace.  In addition,
            // we also build up a set of indexes into approximate locations for
            // inserting fields and methods.
            //
            int fieldInsertLocation = 0;
            bool lockField = false;
            int methodInsertLocation = 0;
            bool lockMethod = false;
            IDictionary docMemberHash = new HybridDictionary(docDecl.Members.Count, caseInsensitive);
            
            int memberCount = docDecl.Members.Count;
            for(int i = 0; i < memberCount; i++) {
                CodeTypeMember member = docDecl.Members[i];
                
                docMemberHash[member.Name] = i;
                if (member is CodeMemberField) {
                    if (!lockField) {
                        fieldInsertLocation = i;
                    }
                }
                else {
                    if (fieldInsertLocation > 0) {
                        lockField = true;
                    }
                }
                
                if (member is CodeMemberMethod) {
                    if (!lockMethod) {
                        methodInsertLocation = i;
                    }
                }
                else {
                    if (methodInsertLocation > 0) {
                        lockMethod = true;
                    }
                }
            }
            
            // Now start looking through the new declaration and process it.
            // We are index driven, so if we need to add new values we put
            // them into an array list, and post process them.
            //
            ArrayList newElements = new ArrayList();
            foreach(CodeTypeMember member in newDecl.Members) {
                object existingSlot = docMemberHash[member.Name];
                if (existingSlot != null) {
                    int slot = (int)existingSlot;
                    CodeTypeMember existingMember = docDecl.Members[slot];
                    
                    if (existingMember == member) {
                        continue;
                    }

                    if (member is CodeMemberField) {
                        if (existingMember is CodeMemberField) {
                            CodeMemberField docField = (CodeMemberField)existingMember;
                            CodeMemberField newField = (CodeMemberField)member;
                            // We will can be case-sensitive always in working out whether to replace the field
                            if ((string.Compare(newField.Name, docField.Name, false, CultureInfo.InvariantCulture) == 0) && 
                                newField.Attributes == docField.Attributes && 
                                TypesEqual(newField.Type, docField.Type)) {
                                continue;
                            }
                            else {
                                docDecl.Members[slot] = member;
                            }
                        }
                        else {
                            // We adding a field with the same name as a method. This should cause a
                            // compile error, but we don't want to clobber the existing method.
                            newElements.Add(member);
                        }
                    }
                    else if (member is CodeMemberMethod) {

                         if (existingMember is CodeMemberMethod) {
                    
                            // For methods, we do not want to replace the method; rather, we
                            // just want to replace its contents.  This helps to preserve
                            // the layout of the file.
                            //
                            CodeMemberMethod existingMethod = (CodeMemberMethod)existingMember;
                            CodeMemberMethod newMethod = (CodeMemberMethod)member;
                            existingMethod.Statements.Clear();
                            existingMethod.Statements.AddRange(newMethod.Statements);
                         
                         }
                    }
                    else {
                        docDecl.Members[slot] = member;
                    }
                    codeDomDirty = true;
                }
                else {
                    newElements.Add(member);
                }
            }
            
            // Now, process all new elements.
            //
            foreach(CodeTypeMember member in newElements) {
                if (member is CodeMemberField) {
                    if (fieldInsertLocation >= docDecl.Members.Count) {
                        docDecl.Members.Add(member);
                    }
                    else {
                        docDecl.Members.Insert(fieldInsertLocation, member);
                    }
                    fieldInsertLocation++;
                    methodInsertLocation++;
                    codeDomDirty = true;
                }
                else if (member is CodeMemberMethod) {
                    if (methodInsertLocation >= docDecl.Members.Count) {
                        docDecl.Members.Add(member);
                    }
                    else {
                        docDecl.Members.Insert(methodInsertLocation, member);
                    }
                    methodInsertLocation++;
                    codeDomDirty = true;
                }
                else {
                    // For rare members, just add them to the end.
                    //
                    docDecl.Members.Add(member);
                    codeDomDirty = true;
                }
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IsNameUsed"]/*' />
        /// <devdoc>
        ///     Called during the name creation process to see if this name is already in 
        ///     use.
        /// </devdoc>
        public override bool IsNameUsed(string name) {
            CodeTypeDeclaration type = DocumentType;
            if (type != null) {
                foreach(CodeTypeMember member in type.Members) {
                    if (string.Compare(member.Name, name, true, CultureInfo.InvariantCulture) == 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IsValidIdentifier"]/*' />
        /// <devdoc>
        ///     Called during the name creation process to see if this name is valid.
        /// </devdoc>
        public override bool IsValidIdentifier(string name) {
            // make sure we can make a function name out of this identifier --
            // this prevents us form accepting escaped names like [Long] for Visual Basic since
            // that's valid but [Long]_Click is not.
            //
            return CodeGenerator.IsValidIdentifier(name) && CodeGenerator.IsValidIdentifier(name + "Handler");
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.Load"]/*' />
        /// <devdoc>
        ///     Loads the document.  This should return the fully qualified name
        ///     of the class the document is editing.
        /// </devdoc>
        public override string Load() {

            if (DocumentType == null) {
                
                // Did we get any reasons why we can't load this document?  If so, synthesize a nice
                // description to the user.
                //
                Exception ex;
                
                if (documentFailureReasons != null) {
                    StringBuilder builder = new StringBuilder();
                    foreach(string failure in documentFailureReasons) {
                        builder.Append("\r\n");
                        builder.Append(failure);
                    }
                    ex = new SerializationException(SR.GetString(SR.SerializerNoRootSerializerWithFailures, builder.ToString()));
                    ex.HelpLink = SR.SerializerNoRootSerializerWithFailures;
                }
                else {
                    ex = new SerializationException(SR.GetString(SR.SerializerNoRootSerializer));
                    ex.HelpLink = SR.SerializerNoRootSerializer;
                }
                
                throw ex;
            }
        
            Debug.Assert(DocumentType != null && rootSerializer != null, "Must have both a root serializer and document code class.  Perhaps this object has been disposed?");
        
            try {
                CodeDomLoader.StartMark();
                rootSerializer.Deserialize(this, DocumentType);
                CodeDomLoader.EndMark("Deserialize document");
            }
            finally {
                try {
                    if (serializationCompleteEventHandler != null) {
                        serializationCompleteEventHandler(this, EventArgs.Empty);
                    }
                }
                catch {}
                
                // We cannot call TerminateSerializationManager here because
                // there may be load dependencies.  Terminate our serialization
                // manager when EndLoad is called on us.
            }
            
            Debug.Assert(documentNamespace != null, "Retrieving document type did not fill in namespace.");
            
            string fullName;
            if (documentNamespace != null && documentNamespace.Name.Length > 0) {
                fullName = documentNamespace.Name + "." + DocumentType.Name;
            }
            else {
                fullName = DocumentType.Name;
            }
            
            return fullName;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.OnComponentAdded"]/*' />
        /// <devdoc>
        ///     Raised by the host when a component is added.  Here we just mess
        ///     ourselves.
        /// </devdoc>
        private void OnComponentAdded(object sender, ComponentEventArgs e) {
            designerDirty = true;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.OnComponentChanged"]/*' />
        /// <devdoc>
        ///     Raised by the host when a component changes.  Here we just set our dirty
        ///     bit and wait for flush to be called.
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            designerDirty = true;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.OnComponentRemoved"]/*' />
        /// <devdoc>
        ///     Raised by the host when a component is removed.  Here we dirty ourselves
        ///     and then whack the component declaration.
        /// </devdoc>
        private void OnComponentRemoved(object sender, ComponentEventArgs e) {
            string name = ((IDesignerSerializationManager)this).GetName(e.Component);
            RemoveDeclaration(name);
            designerDirty = true;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.OnComponentRename"]/*' />
        /// <devdoc>
        ///     Raised by the host when a component is renamed.  Here we dirty ourselves
        ///     and then whack the component declaration.  At the next code gen
        ///     cycle we will recreate the declaration.
        /// </devdoc>
        private void OnComponentRename(object sender, ComponentRenameEventArgs e) {
            RemoveDeclaration(e.OldName);
            designerDirty = true;
        }

        /// <devdoc>
        ///     Raised by the host when CodeTypeDeclaration is requested as a service.
        /// </devdoc>
        private object OnDemandCreateService(IServiceContainer requestingContainer, Type requestedService) {
            if (requestedService == typeof(CodeTypeDeclaration)) {
                return this.DocumentType;
            }
            return null;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.RemoveDeclaration"]/*' />
        /// <devdoc>
        ///     This is called when a component is deleted or renamed.  We remove
        ///     the component's declaration here, if it exists.
        /// </devdoc>
        private void RemoveDeclaration(string name) {
            if (DocumentType != null) {
                CodeTypeMemberCollection members = documentType.Members;
                for(int i = 0; i < members.Count; i++) {
                    if (members[i] is CodeMemberField && members[i].Name.Equals(name)) {
                        ((IList)members).RemoveAt(i);
                        codeDomDirty = true;
                        break;
                    }
                }
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.RemoveEventMethod"]/*' />
        /// <devdoc>
        ///     This is called by an EventPropertyDescriptor when the user changes the name of an event.
        ///     Here we check that (a) we are not currently loading and (b) that the contents of the
        ///     event method are empty.  If both of these are true we will remove the event
        ///     declaration from code.
        /// </devdoc>
        private void ReleaseEventMethod(string methodName, EventDescriptor eventDesc) {
            if (LoaderHost != null && !LoaderHost.Loading && provider != null && DocumentType != null) {
                DelegateTypeInfo dti = new DelegateTypeInfo(eventDesc);
                CodeMemberMethod method = FindMethod(methodName, dti);
                
                if (method != null) {

                    string key = GetEventMethodKey(methodName, eventDesc);

                    Debug.Assert(this.handlerCounts != null && this.handlerCounts.Count > 0, "How can we be deleting a handler with no handler cache?");
                    if (this.handlerCounts != null) {
                        object handlerCount = handlerCounts[key];
                        int count = 0;                           
                        Debug.Assert(handlerCount != null, "How can we be deleting a handler with no handler cache?");
                        if (handlerCount != null) {
                            count = (int)handlerCount;
                            handlerCounts[key] = --count;
                            if (count > 0) {
                                return;
                            }
                        }
                    }
                    
                    bool emptyMethod = false;

                    // The code dom may fail to parse the contents of a method if it contains
                    // structures that are not CLS compliant.  In this case we assume that there
                    // was code in the method and we do not delete it; we only delete the method
                    // if we can verify that it contains no code.
                    //
                    try {
                        if (method.Statements.Count == 0) {
                            emptyMethod = true;
                        }
                    }
                    catch {
                    }
                    
                    if (emptyMethod) {
                        ((IList)DocumentType.Members).Remove(method);
                        codeDomDirty = true;
                    }
                }
            }
        }

        public override bool Reset() {

            IDesignerLoaderHost host = LoaderHost;

            if (provider == null || host == null) {
                return false;
            }

            this.documentNamespace = null;
            this.documentType = null;
            this.rootSerializer = null;
            this.designerDirty = false;
            this.codeDomDirty = false;
            this.compileUnit = null;
            
            if (this.handlerCounts != null) {
                this.handlerCounts.Clear();
            }
            host.RemoveService(typeof(CodeTypeDeclaration));
            host.AddService(typeof(CodeTypeDeclaration), new ServiceCreatorCallback(this.OnDemandCreateService));

            IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                cs.ComponentRename -= new ComponentRenameEventHandler(OnComponentRename);
                cs.ComponentAdded -= new ComponentEventHandler(OnComponentAdded);
                cs.ComponentRemoved -= new ComponentEventHandler(OnComponentRemoved);
            }
            
            if(undoManager != null) {
                undoManager.Dispose();
                undoManager = null;
            }
            return true;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.TerminateSerializationManager"]/*' />
        /// <devdoc>
        ///     Terminates the serialization manager.  We only
        ///     keep the serialization manager's state alive during
        ///     serialization or deserialization to prevent serializers
        ///     from hanging on.
        /// </devdoc>
        private void TerminateSerializationManager() {
            resolveNameEventHandler = null;
            serializationCompleteEventHandler = null;
            instancesByName = null;
            namesByInstance = null;
            serializers = null;
            errorList = null;
            contextStack = null;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.ValidateIdentifier"]/*' />
        /// <devdoc>
        ///     Called during the name creation process to see if this name is valid.
        /// </devdoc>
        public override void ValidateIdentifier(string name) {
            CodeGenerator.ValidateIdentifier(name);

            // make sure we can make a function name out of this identifier --
            // this prevents us form accepting escaped names like [Long] for Visual Basic since
            // that's valid but [Long]_Click is not.
            //
            try {
                CodeGenerator.ValidateIdentifier(name + "Handler");
            }
            catch {
                // we have to change the exception back to the original name
                throw new ArgumentException(SR.GetString(SR.SerializerInvalidIdentifier, name));
            }
            
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.Context"]/*' />
        /// <devdoc>
        ///     The Context property provides a user-defined storage area
        ///     implemented as a stack.  This storage area is a useful way
        ///     to provide communication across serializers, as serialization
        ///     is a generally hierarchial process.
        /// </devdoc>
        ContextStack IDesignerSerializationManager.Context {
            get {
                if (contextStack == null) {
                    contextStack = new ContextStack();
                }
                return contextStack;
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.Properties"]/*' />
        /// <devdoc>
        ///     The Properties property provides a set of custom properties
        ///     the serialization manager may surface.  The set of properties
        ///     exposed here is defined by the implementor of 
        ///     IDesignerSerializationManager.  
        /// </devdoc>
        PropertyDescriptorCollection IDesignerSerializationManager.Properties {
            get {
                if (propertyCollection == null) {
                    PropertyDescriptor autoGenProp = TypeDescriptor.CreateProperty(typeof(CodeDomLoader), "SupportsStatementGeneration", typeof(bool), null);
                    propertyCollection = new PropertyDescriptorCollection(
                        new PropertyDescriptor[] {autoGenProp});
                }
                return propertyCollection;
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.ResolveName"]/*' />
        /// <devdoc>
        ///     ResolveName event.  This event
        ///     is raised when GetName is called, but the name is not found
        ///     in the serialization manager's name table.  It provides a 
        ///     way for a serializer to demand-create an object so the serializer
        ///     does not have to order object creation by dependency.  This
        ///     delegate is cleared immediately after serialization or deserialization
        ///     is complete.
        /// </devdoc>
        event ResolveNameEventHandler IDesignerSerializationManager.ResolveName {
            add {
                resolveNameEventHandler += value;
            }
            remove {
                resolveNameEventHandler -= value;
            }
        }
    
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.SerializationComplete"]/*' />
        /// <devdoc>
        ///     This event is raised when serialization or deserialization
        ///     has been completed.  Generally, serialization code should
        ///     be written to be stateless.  Should some sort of state
        ///     be necessary to maintain, a serializer can listen to
        ///     this event to know when that state should be cleared.
        ///     An example of this is if a serializer needs to write
        ///     to another file, such as a resource file.  In this case
        ///     it would be inefficient to design the serializer
        ///     to close the file when finished because serialization of
        ///     an object graph generally requires several serializers.
        ///     The resource file would be opened and closed many times.
        ///     Instead, the resource file could be accessed through
        ///     an object that listened to the SerializationComplete
        ///     event, and that object could close the resource file
        ///     at the end of serialization.
        /// </devdoc>
        event EventHandler IDesignerSerializationManager.SerializationComplete {
            add {
                serializationCompleteEventHandler += value;
            }
            remove {
                serializationCompleteEventHandler -= value;
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.AddSerializationProvider"]/*' />
        /// <devdoc>
        ///     This method adds a custom serialization provider to the 
        ///     serialization manager.  A custom serialization provider will
        ///     get the opportunity to return a serializer for a data type
        ///     before the serialization manager looks in the type's
        ///     metadata.  
        /// </devdoc>
        void IDesignerSerializationManager.AddSerializationProvider(IDesignerSerializationProvider provider) {
            if (designerSerializationProviders == null) {
                designerSerializationProviders = new ArrayList();
            }
            designerSerializationProviders.Add(provider);
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.CreateInstance"]/*' />
        /// <devdoc>                
        ///     Creates an instance of the given type and adds it to a collection
        ///     of named instances.  Objects that implement IComponent will be
        ///     added to the design time container if addToContainer is true.
        /// </devdoc>
        object IDesignerSerializationManager.CreateInstance(Type type, ICollection arguments, string name, bool addToContainer) {
            object[] argArray = null;
            
            if (arguments != null && arguments.Count > 0) {
                argArray = new object[arguments.Count];
                arguments.CopyTo(argArray, 0);
            }
            
            object instance = null;
            
            // We do some special casing here.  If we are adding to the container, and if this type 
            // is an IComponent, then we don't create the instance through Activator, we go
            // through the loader host.  The reason for this is that if we went through activator,
            // and if the object already specified a constructor that took an IContainer, our
            // deserialization mechanism would equate the container to the designer host.  This
            // is the correct thing to do, but it has the side effect of adding the compnent
            // to the designer host twice -- once with a default name, and a second time with
            // the name we provide.  This equates to a component rename, which isn't cheap, 
            // so we don't want to do it when we load each and every component.
            //
            if (addToContainer && typeof(IComponent).IsAssignableFrom(type)) {
                IDesignerLoaderHost host = LoaderHost;
                if (host != null) {
                    if (name == null) {
                        instance = host.CreateComponent(type);
                    }
                    else {
                        instance = host.CreateComponent(type, name);
                    }
                }
            }
            
            if (instance == null) {
            
                // If we have a name but the object wasn't a component
                // that was added to the design container, save the
                // name/value relationship in our own nametable.
                //
                if (name != null && instancesByName != null) {
                    if (instancesByName.ContainsKey(name)) {
                        Exception ex = new SerializationException(SR.GetString(SR.SerializerDuplicateComponentDecl, name));
                        ex.HelpLink = SR.SerializerDuplicateComponentDecl;
                        
                        throw ex;
                    }
                }
            
                try {
                    try {
                        // First, just try to create the object directly with the arguments.  generaly this
                        // should work.
                        //
                        instance = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, argArray, null);
                    }
                    catch (MissingMethodException mmex) {

                        // okay, the create failed because the argArray didn't match the types of ctors that
                        // are available.  don't panic, we're tough.  we'll try to coerce the types to match
                        // the ctor.
                        //
                        Type[] types = new Type[argArray.Length];
                        
                        // first, get the types of the arguments we've got.
                        //
                        for(int index = 0; index < argArray.Length; index++) {
                            if (argArray[index] != null) {
                                types[index] = argArray[index].GetType();
                            }
                        }

                        object[] tempArgs = new object[argArray.Length];

                        // now, walk the public ctors looking for one to 
                        // invoke here with the arguments we have.
                        //
                        foreach(ConstructorInfo ci in type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance)) {
                            ParameterInfo[] pi = ci.GetParameters();

                            // obviously the count has to match
                            //
                            if (pi != null && pi.Length == types.Length) {
                                bool match = true;

                                // now walk every type of argument and compare it to
                                // the corresponding argument.  if it matches up exactly or is a derived type, great.
                                // otherwise, we'll try to use IConvertible to make it into the right thing.
                                //
                                for (int t = 0; t < types.Length; t++) {
                                    if (types[t] == null || pi[t].ParameterType.IsAssignableFrom(types[t])) {
                                        tempArgs[t] = argArray[t];
                                        continue;
                                    }

                                    if (argArray[t] is IConvertible) {
                                        try {
                                            // try the IConvertible route.  If it works, we'll call it a match
                                            // for this parameter and continue on.
                                            //
                                            tempArgs[t] = ((IConvertible)argArray[t]).ToType(pi[t].ParameterType, null);
                                            continue;       
                                        }
                                        catch {
                                        }
                                    }
                                    match = false;
                                    break;
                                }
                                // all of the parameters were converted or matched, so try the creation again.
                                // if that works, we're in the money. 
                                //
                                if (match) {
                                   instance = ci.Invoke(BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, tempArgs, null);
                                   break;
                                }
                            }
                        }

                        // we still failed...rethrow the original exception.
                        //
                        if (instance == null) {
                            throw mmex;
                        }
                    }
                    
                }
                catch(MissingMethodException) {
                    StringBuilder argTypes = new StringBuilder();
                    foreach (object o in argArray) {
                        if (argTypes.Length > 0) {
                            argTypes.Append(", ");
                        }

                        if (o != null) {
                            argTypes.Append(o.GetType().Name);
                        }
                        else {
                            argTypes.Append("null");
                        }
                        
                    }
                    
                    Exception ex = new SerializationException(SR.GetString(SR.SerializerNoMatchingCtor, type.FullName, argTypes.ToString()));
                    ex.HelpLink = SR.SerializerNoMatchingCtor;
                    
                    throw ex;
                }                
                    
                // If we have a name but the object wasn't a component
                // that was added to the design container, save the
                // name/value relationship in our own nametable.
                //
                if (name != null) {
                    if (instancesByName == null) {
                        instancesByName = new Hashtable();
                        namesByInstance = new Hashtable();
                    }
                    
                    instancesByName[name] = instance;
                    namesByInstance[instance] = name;
                }
            }
            
            return instance;
        }
    
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.GetInstance"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of a created object of the given name, or
        ///     null if that object does not exist.
        /// </devdoc>
        object IDesignerSerializationManager.GetInstance(string name) {
            object instance = null;
            
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            
            // Check our local nametable first
            //
            if (instancesByName != null) {
                instance = instancesByName[name];
            }
            
            if (instance == null && LoaderHost != null) {
                instance = LoaderHost.Container.Components[name];
            }
            
            if (instance == null && resolveNameEventHandler != null) {
                ResolveNameEventArgs e = new ResolveNameEventArgs(name);
                resolveNameEventHandler(this, e);
                instance = e.Value;
            }
            
            return instance;
        }
    
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.GetName"]/*' />
        /// <devdoc>
        ///     Retrieves a name for the specified object, or null if the object
        ///     has no name.
        /// </devdoc>
        string IDesignerSerializationManager.GetName(object value) {
            string name = null;
        
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            
            // Check our local nametable first
            //
            if (namesByInstance != null) {
                name = (string)namesByInstance[value];
            }
            
            if (name == null && value is IComponent) {
                ISite site = ((IComponent)value).Site;
                if (site != null) {
                    name = site.Name;
                }
            }
            return name;
        }
    
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.GetSerializer"]/*' />
        /// <devdoc>
        ///     Retrieves a serializer of the requested type for the given
        ///     object type.
        /// </devdoc>
        object IDesignerSerializationManager.GetSerializer(Type objectType, Type serializerType) {
            object serializer = null;
            
            if (objectType != null) {
            
                if (serializers != null) {
                    // I don't double hash here.  It will be a very rare day where
                    // multiple types of serializers will be used in the same scheme.
                    // We still handle it, but we just don't cache.
                    //
                    serializer = serializers[objectType];
                    if (serializer != null && !serializerType.IsAssignableFrom(serializer.GetType())) {
                        serializer = null;
                    }
                }
                
                // Now actually look in the type's metadata.
                //
                if (serializer == null && LoaderHost != null) {
                    IDesignerLoaderHost host = LoaderHost;
                    AttributeCollection attributes = TypeDescriptor.GetAttributes(objectType);
                    foreach(Attribute attr in attributes) {
                        if (attr is DesignerSerializerAttribute) {
                            DesignerSerializerAttribute da = (DesignerSerializerAttribute)attr;
                            string typeName = da.SerializerBaseTypeName;
                            
                            // This serializer must support a CodeModelSerializer or we're not interested.
                            //
                            if (typeName != null && host.GetType(typeName) == serializerType && da.SerializerTypeName != null && da.SerializerTypeName.Length > 0) {
                                Type type = host.GetType(da.SerializerTypeName);
                                Debug.Assert(type != null, "Type " + objectType.FullName + " has a serializer that we couldn't bind to: " + da.SerializerTypeName);
                                if (type != null) {
                                    serializer = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
                                    break;
                                }
                            }
                        }
                    }
                
                    // And stash this little guy for later.
                    //
                    if (serializer != null) {
                        if (serializers == null) {
                            serializers = new Hashtable();
                        }
                        serializers[objectType] = serializer;
                    }
                }
            }
            
            // Designer serialization providers can override our metadata discovery.
            // We loop until we reach steady state.  This breaks order dependencies
            // by allowing all providers a chance to party on each other's serializers.
            //
            if (designerSerializationProviders != null) {
                bool continueLoop = true;
                for(int i = 0; continueLoop && i < designerSerializationProviders.Count; i++) {
                
                    continueLoop = false;
                    
                    foreach(IDesignerSerializationProvider provider in designerSerializationProviders) {
                        object newSerializer = provider.GetSerializer(this, serializer, objectType, serializerType);
                        if (newSerializer != null) {
                            continueLoop = (serializer != newSerializer);
                            serializer = newSerializer;
                        }
                    }
                }
            }
            
            return serializer;
        }
    
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.GetType"]/*' />
        /// <devdoc>
        ///     Retrieves a type of the given name.
        /// </devdoc>
        Type IDesignerSerializationManager.GetType(string typeName) {
            Type t = null;

            if (LoaderHost != null) {
                while (t == null) {
                    t = LoaderHost.GetType(typeName);

                    if (t == null && typeName != null && typeName.Length > 0) {
                        int dotIndex = typeName.LastIndexOf('.');
                        if (dotIndex == -1 || dotIndex == typeName.Length - 1)
                            break;

                        typeName = typeName.Substring(0, dotIndex) + "+" + typeName.Substring(dotIndex + 1, typeName.Length - dotIndex - 1);
                    }
                }
            }
            
            return t;
        }
    
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.RemoveSerializationProvider"]/*' />
        /// <devdoc>
        ///     Removes a previously added serialization provider.
        /// </devdoc>
        void IDesignerSerializationManager.RemoveSerializationProvider(IDesignerSerializationProvider provider) {
            if (designerSerializationProviders != null) {
                designerSerializationProviders.Remove(provider);
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.ReportError"]/*' />
        /// <devdoc>
        ///     Reports a non-fatal error in serialization.  The serialization
        ///     manager may implement a logging scheme to alert the caller
        ///     to all non-fatal errors at once.  If it doesn't, it should
        ///     immediately throw in this method, which should abort
        ///     serialization.  
        ///     Serialization may continue after calling this function.
        /// </devdoc>
        void IDesignerSerializationManager.ReportError(object errorInformation) {
            if (errorInformation != null) {
                loadError = true;
                if (errorList != null) {
                    errorList.Add(errorInformation);
                }
                else {
                    if (errorInformation is Exception) {
                        throw (Exception)errorInformation;
                    }
                    else {
                        throw new SerializationException(errorInformation.ToString());
                    }
                }
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.SetName"]/*' />
        /// <devdoc>
        ///     Provides a way to set the name of an existing object.
        ///     This is useful when it is necessary to create an 
        ///     instance of an object without going through CreateInstance.
        ///     An exception will be thrown if you try to rename an existing
        ///     object or if you try to give a new object a name that
        ///     is already taken.
        /// </devdoc>
        void IDesignerSerializationManager.SetName(object instance, string name) {
        
            if (instance == null) {
                throw new ArgumentNullException("instance");
            }
            
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            
            if (instancesByName == null) {
                instancesByName = new Hashtable();
                namesByInstance = new Hashtable();
            }
            
            if (instancesByName[name] != null) {
                throw new ArgumentException(SR.GetString(SR.SerializerNameInUse, name));
            }
            
            if (namesByInstance[instance] != null) {
                throw new ArgumentException(SR.GetString(SR.SerializerObjectHasName, name, (string)namesByInstance[instance]));
            }
            
            instancesByName[name] = instance;
            namesByInstance[instance] = name;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IDesignerSerializationService.Deserialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Deserializes the provided serialization data object and
        ///     returns a collection of objects contained within that
        ///     data.
        ///    </para>
        /// </devdoc>
        ICollection IDesignerSerializationService.Deserialize(object serializationData) {
            if (!(serializationData is DesignerSerializationObject)) {
                throw new ArgumentException(SR.GetString(SR.SerializerBadSerializationObject));
            }


            ICollection deserializedObjects =  null;
            IDesignerLoaderService loaderService = (IDesignerLoaderService)LoaderHost.GetService(typeof(IDesignerLoaderService));
            try {
                
                if (loaderService != null) {
                    loaderService.AddLoadDependency();
                }
                deserializedObjects = ((DesignerSerializationObject)serializationData).Deserialize(this, rootSerializer);
            }
            finally {
                if (loaderService != null) {
                    loaderService.DependentLoadComplete(true, null);
                }
            }
            return deserializedObjects;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IDesignerSerializationService.Serialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Serializes the given collection of objects and 
        ///     stores them in an opaque serialization data object.
        ///     The returning object fully supports runtime serialization.
        ///    </para>
        /// </devdoc>
        object IDesignerSerializationService.Serialize(ICollection objects) {

            if (DocumentType == null) {
                Exception ex = new SerializationException(SR.GetString(SR.SerializerNoRootSerializer));
                ex.HelpLink = SR.SerializerNoRootSerializer;
                throw ex;
            }
            return new DesignerSerializationObject(this, rootSerializer, objects);
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.CreateUniqueMethodName"]/*' />
        /// <devdoc>
        ///     This creates a name for an event handling method for the given component
        ///     and event.  The name that is created is guaranteed to be unique in the user's source
        ///     code.
        /// </devdoc>
        string IEventBindingService.CreateUniqueMethodName(IComponent component, EventDescriptor e) {
            string name = null;
            IReferenceService referenceService = (IReferenceService)((IServiceProvider)this).GetService(typeof(IReferenceService));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || referenceService != null, "IReferenceService not found");
            
            if (referenceService != null) {
                name = referenceService.GetName(component);
            }
            else {
                ISite site = component.Site;
                if (site != null && site.Name != null) {
                    name = site.Name;
                }
            }
            
            if (name == null) {
                throw new Exception(SR.GetString(SR.SerializerNoComponentSite));
            }
            
            name = name.Replace('.','_') + "_" + e.Name;
                
            // Now we must make sure that our proposed name is not already taken.
            //
            ICollection compatibleMethods = ((IEventBindingService)this).GetCompatibleMethods(e);
            int tryCount = 0;
            bool match = true;
            string uniqueName = name;
            
            while(match) {
                match = false;
                foreach(string existingMethod in compatibleMethods) {
                    if (existingMethod.Equals(uniqueName)) {
                        uniqueName = name + "_" + (++tryCount).ToString();
                        match = true;
                        break;
                    }
                }
            }
            
            return uniqueName;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.GetCompatibleMethods"]/*' />
        /// <devdoc>
        ///     Retrieves a collection of strings.  Each string is the name of a method
        ///     in user code that has a signature that is compatible with the given event.
        /// </devdoc>
        ICollection IEventBindingService.GetCompatibleMethods(EventDescriptor e) {
            ArrayList methodList = new ArrayList();
            
            if (DocumentType != null) {
                DelegateTypeInfo dti = new DelegateTypeInfo(e);
                
                foreach(CodeTypeMember member in documentType.Members) {
                    if (member is CodeMemberMethod) {
                        CodeMemberMethod method = (CodeMemberMethod)member;
                        
                        if (TypesEqual(dti.ReturnType, method.ReturnType) && method.Parameters.Count == dti.Parameters.Length) {
                            bool match = true;
                            for (int i = 0; i < dti.Parameters.Length; i++) {
                                CodeParameterDeclarationExpression left = method.Parameters[i];
                                CodeParameterDeclarationExpression right = dti.Parameters[i];
                                
                                if ((left.Direction != right.Direction) ||
                                    !CompareTypes(left.Type, right.Type)) {
                                    match = false;
                                    break;
                                }
                            }

                            if (match) {
                                methodList.Add(method.Name);
                            }
                        }
                        
                    }
                }
            }

            return methodList;
        }

        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.GetEvent"]/*' />
        /// <devdoc>
        ///     For properties that are representing events, this will return the event
        ///     that the property represents.
        /// </devdoc>
        EventDescriptor IEventBindingService.GetEvent(PropertyDescriptor property) {
            if (property is EventPropertyDescriptor) {
                return ((EventPropertyDescriptor)property).Event;
            }
            return null;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.GetEventProperties"]/*' />
        /// <devdoc>
        ///     Converts a set of events to a set of properties.
        /// </devdoc>
        PropertyDescriptorCollection IEventBindingService.GetEventProperties(EventDescriptorCollection events) {

            PropertyDescriptor[] props = new PropertyDescriptor[events.Count];
            IReferenceService referenceService = (IReferenceService)((IServiceProvider)this).GetService(typeof(IReferenceService));

            // We cache the property descriptors here for speed.  Create those for
            // events that we don't have yet.
            //
            if (eventProperties == null) eventProperties = new Hashtable();
            
            for (int i = 0; i < events.Count; i++) {
                props[i] = (PropertyDescriptor)eventProperties[GetEventDescriptorHashCode(events[i])];

                if (props[i] == null) {
                    props[i] = new EventPropertyDescriptor(events[i], referenceService, this, this);
                    eventProperties[GetEventDescriptorHashCode(events[i])] = props[i];
                }
            }

            return new PropertyDescriptorCollection(props);
        }

        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.GetEventProperty"]/*' />
        /// <devdoc>
        ///     Converts a single event to a property.
        /// </devdoc>
        PropertyDescriptor IEventBindingService.GetEventProperty(EventDescriptor e) {
            if (eventProperties == null) eventProperties = new Hashtable();
            PropertyDescriptor prop = (PropertyDescriptor)eventProperties[GetEventDescriptorHashCode(e)];

            if (prop == null) {
                IReferenceService referenceService = (IReferenceService)((IServiceProvider)this).GetService(typeof(IReferenceService));
                prop = new EventPropertyDescriptor(e, referenceService, this, this);
                eventProperties[GetEventDescriptorHashCode(e)] = prop;
            }

            return prop;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.ShowCode"]/*' />
        /// <devdoc>
        ///     Displays the user code for this designer.  This will return true if the user
        ///     code could be displayed, or false otherwise.
        /// </devdoc>
        bool IEventBindingService.ShowCode() {
            if (Buffer != null) {
                Buffer.ShowCode();
                return true;
            }
            return false;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.ShowCode1"]/*' />
        /// <devdoc>
        ///     Displays the user code for the designer.  This will return true if the user
        ///     code could be displayed, or false otherwise.
        /// </devdoc>
        bool IEventBindingService.ShowCode(int lineNumber) {
            if (Buffer != null) {
                Buffer.ShowCode(lineNumber);
                return true;
            }
            return false;
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.ShowCode2"]/*' />
        /// <devdoc>
        ///     Displays the user code for the given event.  This will return true if the user
        ///     code could be displayed, or false otherwise.
        /// </devdoc>
        bool IEventBindingService.ShowCode(IComponent component, EventDescriptor e) {

            if (Buffer == null) {
                return false;
            }
         
            PropertyDescriptor prop = ((IEventBindingService)this).GetEventProperty(e);
            
            string eventName = (string)prop.GetValue(component);
            if (eventName == null) {
                return false;   // the event is not bound to a method.
            }
            
            if (DocumentType == null) {
                return false; // no doc class
            }
            
            
            Debug.Assert(showCodeComponent == null && showCodeEventDescriptor == null, "show code already pending");

            showCodeComponent = component;
            showCodeEventDescriptor = e;
            Application.Idle += new EventHandler(this.ShowCodeIdle);
            return true;
        }

        bool ShowCodeCore(IComponent component, EventDescriptor e) {


            if (Buffer == null) {
                return false;
            }
         
            PropertyDescriptor prop = ((IEventBindingService)this).GetEventProperty(e);
            
            string eventName = (string)prop.GetValue(component);
            if (eventName == null) {
                return false;   // the event is not bound to a method.
            }
            
            if (DocumentType == null) {
                return false; // no doc class
            }

            DesignerTransaction dt = LoaderHost.CreateTransaction(SR.GetString(SR.DesignerCodeGeneration));
            DelegateTypeInfo dti = new DelegateTypeInfo(e);
            CodeMemberMethod method = null;

            try {
                                           
                // Before searching for the method, flush our buffer.  This causes the
                // any new methods to be code generated into the text buffer, which also
                // hooks up their line numbers.
                //
                loader.Flush();
                method = FindMethod(eventName, dti);
                
                if (method == null) {
                    // There is no method for this event, but the event property has been set.  This can happen
                    // if the user deletes the event method block.  Just re-set the event value.
                    //
                    prop.SetValue(component, null);
                    prop.SetValue(component, eventName);
                    eventName = (string)prop.GetValue(component);
                    
                    // Before searching for the method, flush our buffer.  This causes the
                    // any new methods to be code generated into the text buffer, which also
                    // hooks up their line numbers.
                    //
                    loader.Flush();
                    method = FindMethod(eventName, dti);
                }
            }
            finally {
                dt.Commit();
            }

            // In case committing the transaction flushed and re-arranged code, re-aquire
            // the method.  Should that fail, use the original
            //
            CodeMemberMethod newMethod = FindMethod(eventName, dti);
            if (newMethod != null) {
                method = newMethod;
            }

            if (method == null) {
                return false;   // we tried, but couldn't get to the method.
            }
            
            // first see if there's an event handler in the user data
            // if there is, we call that to ensure all the line information
            // is current.
            //
            EventHandler eh = method.UserData[typeof(EventHandler)] as EventHandler;
            if (eh != null) {
                eh(method, EventArgs.Empty);
            }
            
            // Check to see if a Point object is embedded in the user data.  If there is, then
            // we will use it to navigate as it is more accurate than the line pragma.
            //
            object pointObj = method.UserData[typeof(System.Drawing.Point)];
            if (pointObj is System.Drawing.Point) {
                System.Drawing.Point point = (System.Drawing.Point)pointObj;
                Buffer.ShowCode(point.Y, point.X);
            }
            else {
                CodeLinePragma linePragma = method.LinePragma;
            
                if (linePragma != null) {
                    Buffer.ShowCode(linePragma.LineNumber);
                }
                else {
                    Buffer.ShowCode();
                }
            }
            
            return true;
        }

        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IEventBindingService.ShowCode2"]/*' />
        /// <devdoc>
        ///     Displays the user code for the given event.  This will return true if the user
        ///     code could be displayed, or false otherwise.
        /// </devdoc>
        private void ShowCodeIdle(object sender, EventArgs e) {
            Application.Idle -= new EventHandler(this.ShowCodeIdle);

            try {
                ShowCodeCore(showCodeComponent, showCodeEventDescriptor);
            }
            finally {
                showCodeComponent = null;
                showCodeEventDescriptor = null;
            }
        }

        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.IServiceProvider.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return LoaderHost.GetService(serviceType);
        }

        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private static bool TypesEqual(CodeTypeReference typeLeft, CodeTypeReference typeRight) {
            
            if (typeLeft.ArrayRank != typeRight.ArrayRank) return false;
            if (!typeLeft.BaseType.Equals(typeRight.BaseType)) return false;
            if (typeLeft.ArrayRank > 0) {
                return TypesEqual(typeLeft.ArrayElementType, typeRight.ArrayElementType);
            }
            return true;
        }

    
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DelegateTypeInfo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Stores
        ///       and provides access to the type information of a delegate.
        ///    </para>
        /// </devdoc>
        internal class DelegateTypeInfo {
            private CodeParameterDeclarationExpression[] parameters;
            private CodeTypeReference                    returnType;
    
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DelegateTypeInfo.Parameters"]/*' />
            /// <devdoc>
            ///    <para> 
            ///       Gets the parameters used in the <see langword='Invoke'/>
            ///       method of the delegate.</para>
            /// </devdoc>
            public CodeParameterDeclarationExpression[] Parameters {
                get {
                    return parameters;
                }
            }
    
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DelegateTypeInfo.ReturnType"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the return type of the delegate.
            ///    </para>
            /// </devdoc>
            public CodeTypeReference ReturnType {
                get {
                    return returnType;
                }
            }
    
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DelegateTypeInfo.DelegateTypeInfo"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes
            ///       a new instance of the DelegateTypeInfo class
            ///       to represent the
            ///       delegate called within the specified source
            ///       file and with the specified event descriptor.
            ///    </para>
            /// </devdoc>
            public DelegateTypeInfo(EventDescriptor eventdesc) {
                Resolve(eventdesc.EventType);
            }
    
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DelegateTypeInfo.DelegateTypeInfo1"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes
            ///       a new instance of the DelegateTypeInfo class to represent the
            ///       delegate called within the specified source
            ///       file and with the specified event descriptor.
            ///    </para>
            /// </devdoc>
            public DelegateTypeInfo(Type delegateClass) {
                Resolve(delegateClass);
            }
                
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DelegateTypeInfo.Resolve"]/*' />
            /// <devdoc>
            ///     Resolves the given delegate class into type information.
            /// </devdoc>
            private void Resolve(Type delegateClass) {
                MethodInfo invokeMethod = delegateClass.GetMethod("Invoke");
    
                if (invokeMethod == null) {
                    throw new Exception(SR.GetString(SR.SerializerBadDelegate, delegateClass.FullName));
                }
                Resolve(invokeMethod);
            }
    
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.DelegateTypeInfo.Resolve1"]/*' />
            /// <devdoc>
            ///     Resolves the given method into type information.
            /// </devdoc>
            private void Resolve(MethodInfo method) {
                // Here we build up an array of argument types, separated
                // by commas.
                //
                ParameterInfo[] argTypes = method.GetParameters();
                
                parameters = new CodeParameterDeclarationExpression[argTypes.Length];
    
                for (int j = 0; j < argTypes.Length; j++) {
                    string paramName = argTypes[j].Name;
                    Type   paramType = argTypes[j].ParameterType;
                    
                    if (paramName == null || paramName.Length == 0) {
                        paramName = "param" + j.ToString();
                    }
                    
                    FieldDirection  fieldDir = FieldDirection.In;

                    // check for the '&' that means ref (gotta love it!) 
                    // and we need to strip that & before we continue.  Ouch.
                    //
                    if (paramType.IsByRef) {
                        if (paramType.FullName.EndsWith("&")) {
                            // strip the & and reload the type without it.
                            //
                            paramType = paramType.Assembly.GetType(paramType.FullName.Substring(0, paramType.FullName.Length - 1), true);
                        }
                        fieldDir = FieldDirection.Ref;
                    }

                    if (argTypes[j].IsOut) {
                        if (argTypes[j].IsIn) {
                            fieldDir = FieldDirection.Ref;
                        }
                        else {
                            fieldDir = FieldDirection.Out;
                        }
                    }
                    
                    parameters[j] = new CodeParameterDeclarationExpression(new CodeTypeReference(paramType), paramName);
                    parameters[j].Direction = fieldDir;   
                }
    
                this.returnType = new CodeTypeReference(method.ReturnType);
            }

            public override bool Equals(object other) {
                if (other == null) {
                    return false;
                }

                DelegateTypeInfo dtiOther = other as DelegateTypeInfo;

                if (dtiOther == null) {
                    return false;
                }

                if (ReturnType.BaseType != dtiOther.ReturnType.BaseType || Parameters.Length != dtiOther.Parameters.Length) {
                    return false;
                }

                for (int i = 0; i < Parameters.Length; i++) {
                    CodeParameterDeclarationExpression otherParam = dtiOther.Parameters[i];

                    if (otherParam.Type.BaseType != Parameters[i].Type.BaseType) {
                        return false;
                    }
                }
                return true;
            }

            public override int GetHashCode() {
                return base.GetHashCode();
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor"]/*' />
        /// <devdoc>
        ///     This is an EventDescriptor cleverly wrapped in a PropertyDescriptor
        ///     of type String.  Note that we now handle subobjects by storing their
        ///     event information in their base component's site's dictionary.
        ///     Note also that when a value is set for this property we will code-gen
        ///     the event method.  If the property is set to a new value we will
        ///     remove the old event method ONLY if it is empty.
        /// </devdoc>
        private class EventPropertyDescriptor : PropertyDescriptor {

            private CodeDomLoader loader;
            private EventDescriptor eventdesc;
            private IReferenceService referenceService;
            private TypeConverter converter;
            private IEventBindingService eventSvc;

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventPropertyDescriptor"]/*' />
            /// <devdoc>
            ///     Creates a new EventPropertyDescriptor.
            /// </devdoc>
            public EventPropertyDescriptor(EventDescriptor eventdesc, IReferenceService referenceService, CodeDomLoader loader, IEventBindingService eventSvc)
            : base(eventdesc, null) {
                this.eventdesc = eventdesc;
                this.referenceService = referenceService;
                this.eventSvc = eventSvc;
                this.loader = loader;
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.CanResetValue"]/*' />
            /// <devdoc>
            ///     Indicates whether reset will change the value of the component.  If there
            ///     is a DefaultValueAttribute, then this will return true if getValue returns
            ///     something different than the default value.  If there is a reset method and
            ///     a shouldPersist method, this will return what shouldPersist returns.
            ///     If there is just a reset method, this always returns true.  If none of these
            ///     cases apply, this returns false.
            /// </devdoc>
            public override bool CanResetValue(object component) {
                return GetValue(component) != null;
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.ComponentType"]/*' />
            /// <devdoc>
            ///     Retrieves the type of the component this PropertyDescriptor is bound to.
            /// </devdoc>
            public override Type ComponentType {
                get {
                    return eventdesc.ComponentType;
                }
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.Converter"]/*' />
            /// <devdoc>
            ///      Retrieves the type converter for this property.
            /// </devdoc>
            public override TypeConverter Converter {
                get {
                    if (converter == null) {
                        converter = new EventConverter(eventdesc);
                    }
                    
                    return converter;
                }
            }
            
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.Event"]/*' />
            /// <devdoc>
            ///     Retrieves the event descriptor we are representing.
            /// </devdoc>
            public EventDescriptor Event {
                get {
                    return eventdesc;
                }
            }
    
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.IsReadOnly"]/*' />
            /// <devdoc>
            ///     Indicates whether this property is read only.
            /// </devdoc>
            public override bool IsReadOnly {
                get {
                    return Attributes[typeof(ReadOnlyAttribute)].Equals(ReadOnlyAttribute.Yes);
                }
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.PropertyType"]/*' />
            /// <devdoc>
            ///     Retrieves the type of the property.
            /// </devdoc>
            public override Type PropertyType {
                get {
                    return eventdesc.EventType;
                }
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.GetValue"]/*' />
            /// <devdoc>
            ///     Retrieves the current value of the property on component,
            ///     invoking the getXXX method.  An exception in the getXXX
            ///     method will pass through.
            /// </devdoc>
            public override object GetValue(object component) {
                string value = null;

                ISite site = null;
                
                if (component is IComponent) {
                    site = ((IComponent)component).Site;
                }

                if (site == null && referenceService != null) {
                    IComponent baseComponent = referenceService.GetComponent(component);
                    if (baseComponent != null) {
                        site = baseComponent.Site;
                    }
                }

                if (site != null) {
                    IDictionaryService ds = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || ds != null, "IDictionaryService not found");
                    if (ds != null) {
                        value = (string)ds.GetValue(new ReferenceEventClosure(component, this));
                    }
                }

                return value;
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.ResetValue"]/*' />
            /// <devdoc>
            ///     Will reset the default value for this property on the component.  If
            ///     there was a default value passed in as a DefaultValueAttribute, that
            ///     value will be set as the value of the property on the component.  If
            ///     there was no default value passed in, a ResetXXX method will be looked
            ///     for.  If one is found, it will be invoked.  If one is not found, this
            ///     is a nop.
            /// </devdoc>
            public override void ResetValue(object component) {
                SetValue(component, null);
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.SetValue"]/*' />
            /// <devdoc>
            ///     This will set value to be the new value of this property on the
            ///     component by invoking the setXXX method on the component.  If the
            ///     value specified is invalid, the component should throw an exception
            ///     which will be passed up.  The component designer should design the
            ///     property so that getXXX following a setXXX should return the value
            ///     passed in if no exception was thrown in the setXXX call.
            /// </devdoc>
            public override void SetValue(object component, object value) {
                
                ISite site = null;

                if (IsReadOnly) {
                    Exception ex = new Exception(SR.GetString(SR.EventReadOnly, Name));
                    ex.HelpLink = SR.EventReadOnly;
                    
                    throw ex;
                }
                
                if (value != null && !(value is string)) {
                    throw new ArgumentException();
                }

                string name = (string)value;
                if (name != null && name.Length == 0) {
                    name = null; 
                }
                
                string oldName = (string)GetValue(component);
                if (oldName == name) {
                    return;
                }
                
                if (oldName != null && name != null && oldName.Equals(name)) {
                    return;
                }
                
                if (referenceService != null) {
                    IComponent baseComponent = referenceService.GetComponent(component);
                    if (baseComponent != null) {
                        site = baseComponent.Site;
                    }
                }
                else {
                    if (component is IComponent) {
                        site = ((IComponent)component).Site;
                    }
                }

                if (site != null) {
                
                    IDictionaryService ds = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || ds != null, "IDictionaryService not found");

                    IComponentChangeService change = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    if (change != null) {
                        try{
                            change.OnComponentChanging(component, this);
                        }
                        catch(CheckoutException coEx){
                            if (coEx == CheckoutException.Canceled){
                                    return;
                            }
                            throw coEx;
                        }
                    }

                    if (ds != null) {
                        ReferenceEventClosure key = new ReferenceEventClosure(component, this);
                        object old = ds.GetValue(key);

                        if (old != null) {
                            loader.ReleaseEventMethod((string)old, eventdesc);
                        }
                        
                        if (name != null) {
                            loader.CodeGenerator.ValidateIdentifier(name);
                            MemberAttributes modifiers = MemberAttributes.Private;
                            
                            // See if this object has an "EventModifiers" property on it.  If
                            // it does, then use the value of that to set our modifiers.
                            //
                            PropertyDescriptor modifiersProp = TypeDescriptor.GetProperties(component)["EventModifiers"];
                            if (modifiersProp != null && modifiersProp.PropertyType == typeof(MemberAttributes)) {
                                modifiers = (MemberAttributes)modifiersProp.GetValue(component);
                            }
                            
                            name = loader.EnsureEventMethod(component, name, modifiers, eventdesc);

                            loader.AddRefEventMethod((string)name, eventdesc);
                        }
                        ds.SetValue(key, name);
                        change.OnComponentChanged(component, this, old, name);
                        OnValueChanged(component, EventArgs.Empty);
                    }
                }
            }

            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.ShouldSerializeValue"]/*' />
            /// <devdoc>
            ///     Indicates whether the value of this property needs to be persisted. In
            ///     other words, it indicates whether the state of the property is distinct
            ///     from when the component is first instantiated. If there is a default
            ///     value specified in this PropertyDescriptor, it will be compared against the
            ///     property's current value to determine this.  If there is't, the
            ///     shouldPersistXXX method is looked for and invoked if found.  If both
            ///     these routes fail, true will be returned.
            ///
            ///     If this returns false, a tool should not persist this property's value.
            /// </devdoc>
            public override bool ShouldSerializeValue(object component) {
                return CanResetValue(component);
            }
        
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter"]/*' />
            /// <devdoc>
            ///     Implements a type converter for event objects.
            /// </devdoc>
            private class EventConverter : TypeConverter {
                private EventDescriptor evt;
                
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.EventConverter"]/*' />
                /// <devdoc>
                ///     Creates a new EventConverter.
                /// </devdoc>
                public EventConverter(EventDescriptor evt) {
                    this.evt = evt;
                }
                
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.CanConvertFrom"]/*' />
                /// <devdoc>
                ///      Determines if this converter can convert an object in the given source
                ///      type to the native type of the converter.
                /// </devdoc>
                public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
                    if (sourceType == typeof(string)) {
                        return true;
                    }
                    return base.CanConvertFrom(context, sourceType);
                }
        
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.CanConvertTo"]/*' />
                /// <devdoc>
                ///      Determines if this converter can convert an object to the given destination
                ///      type.
                /// </devdoc>
                public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
                    if (destinationType == typeof(string)) {
                        return true;
                    }
                    return base.CanConvertTo(context, destinationType);
                }
        
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.ConvertFrom"]/*' />
                /// <devdoc>
                ///      Converts the given object to the converter's native type.
                /// </devdoc>
                public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
                    if (value == null) {
                        return value;
                    }
                    if (value is string) {
                        if (((string)value).Length == 0) {
                            return null;
                        }
                        return value;
                    }
                    return base.ConvertFrom(context, culture, value);
                }
        
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.ConvertTo"]/*' />
                /// <devdoc>
                ///      Converts the given object to another type.  The most common types to convert
                ///      are to and from a string object.  The default implementation will make a call
                ///      to ToString on the object if the object is valid and if the destination
                ///      type is string.  If this cannot convert to the desitnation type, this will
                ///      throw a NotSupportedException.
                /// </devdoc>
                public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
                    if (destinationType == typeof(string)) {
                        return value == null ? string.Empty : value;
                    }
                    return base.ConvertTo(context, culture, value, destinationType);
                }
        
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.GetStandardValues"]/*' />
                /// <devdoc>
                ///      Retrieves a collection containing a set of standard values
                ///      for the data type this validator is designed for.  This
                ///      will return null if the data type does not support a
                ///      standard set of values.
                /// </devdoc>
                public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
                
                    // We cannot cache this because it depends on the contents of the source file.
                    //
                    string[] eventMethods = null;
    
                    if (context != null) {
                        IEventBindingService eps = (IEventBindingService)context.GetService(typeof(IEventBindingService));
                        Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || eps != null, "IEventBindingService not found");
                        if (eps != null) {
                            ICollection methods = eps.GetCompatibleMethods(evt);
                            eventMethods = new string[methods.Count];
                            int i = 0;
                            foreach(string s in methods) {
                                eventMethods[i++] = s;
                            }
                        }
                    }
                    
                    return new StandardValuesCollection(eventMethods);
                }
        
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.GetStandardValuesExclusive"]/*' />
                /// <devdoc>
                ///      Determines if the list of standard values returned from
                ///      GetStandardValues is an exclusive list.  If the list
                ///      is exclusive, then no other values are valid, such as
                ///      in an enum data type.  If the list is not exclusive,
                ///      then there are other valid values besides the list of
                ///      standard values GetStandardValues provides.
                /// </devdoc>
                public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
                    return false;
                }
        
                /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.EventConverter.GetStandardValuesSupported"]/*' />
                /// <devdoc>
                ///      Determines if this object supports a standard set of values
                ///      that can be picked from a list.
                /// </devdoc>
                public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
                    return true;
                }
            }
        
            /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.EventPropertyDescriptor.ReferenceEventClosure"]/*' />
            /// <devdoc>
            ///     This is a combination of a reference and a property, so that it can be used
            ///     as the key of a hashtable.  This is because we may have subobjects that share
            ///     the same property.
            /// </devdoc>
            private class ReferenceEventClosure {
                object reference;
                EventPropertyDescriptor propertyDescriptor;

                public ReferenceEventClosure(object reference, EventPropertyDescriptor prop) {
                    this.reference = reference;
                    this.propertyDescriptor = prop;
                }

                public override int GetHashCode() {
                    return reference.GetHashCode() * propertyDescriptor.GetHashCode();
                }

                public override bool Equals(Object otherClosure) {
                    if (otherClosure is ReferenceEventClosure) {
                        ReferenceEventClosure typedClosure = (ReferenceEventClosure) otherClosure;
                        return(typedClosure.reference == reference &&
                               typedClosure.propertyDescriptor == propertyDescriptor);
                    }
                    return false;
                }
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.BufferTextReader"]/*' />
        /// <devdoc>
        ///     A text reader object that sits on top of a TextBuffer.
        /// </devdoc>
        private class BufferTextReader : TextReader, IServiceProvider {
            private TextBuffer buffer;
            private int position;
            private IServiceProvider hostProvider;
        
            public BufferTextReader(TextBuffer buffer, IServiceProvider hostProvider) {
                this.buffer = buffer;
                position = 0;
                this.hostProvider = hostProvider;
            }
           
            public override int Peek() {
                if (position < buffer.TextLength) {
                    string s = buffer.GetText(position, 1);
                    return s[0];
                }
                return -1;
            }
            
            public override int Read() {
                if (position < buffer.TextLength) {
                    string s = buffer.GetText(position, 1);
                    position++;
                    return s[0];
                }
                return -1;
            }
            
            public override int Read(char[] chars, int index, int count) {
                
                // Fix count so it doesn't walk off the end.  If count
                // is zero, then we can't read any more.
                //
                count = Math.Min(count, buffer.TextLength - position);
                
                string s = buffer.GetText(position, count);
                
                int charsRead = 0;
                int cch = 0;
                
                while (cch < s.Length && (count-- > 0)) {
                    chars[index + charsRead++] = s[cch++];
                }
                
                position += cch;
                return charsRead;
            }
            
            object IServiceProvider.GetService(Type serviceType) {
                if (serviceType == typeof(TextBuffer)) {
                    return buffer;
                }
                
                IServiceProvider provider = buffer as IServiceProvider;
                if (provider != null) {
                    object svc = provider.GetService(serviceType);
                    if (svc != null) {
                        return svc;
                    }
                }

                if (hostProvider != null) {
                    return hostProvider.GetService(serviceType);
                }
                return null;
            }
        }
        
        /// <include file='doc\CodeDomLoader.uex' path='docs/doc[@for="CodeDomLoader.BufferTextWriter"]/*' />
        /// <devdoc>
        ///     This object implements a text writer on top of a TextBuffer.
        /// </devdoc>
        private class BufferTextWriter : TextWriter, IServiceProvider {
            TextBuffer buffer;
            StringBuilder builder;
            int chars;
            
            public BufferTextWriter(TextBuffer buffer) {
                this.buffer = buffer;
                this.builder = new StringBuilder();
                this.chars = 0;
            }
            
            public override Encoding Encoding {
                get {
                    return UnicodeEncoding.Default;
                }
            }
                      
            public override void Flush() {
                if (builder.Length > 0) {
                    buffer.ReplaceText(chars, buffer.TextLength - chars, builder.ToString());
                    chars += builder.Length;
                    builder.Length = 0;
                }
                base.Flush();
            }
            
            public override void Write(char ch) {
                builder.Append(ch);
            }
            
            object IServiceProvider.GetService(Type serviceType) {
                if (serviceType == typeof(TextBuffer)) {
                    return buffer;
                }
                
                IServiceProvider provider = buffer as IServiceProvider;
                if (provider != null) {
                    return provider.GetService(serviceType);
                }
                
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\textbuffer.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBuffer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;

    /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer"]/*' />
    /// <devdoc>
    ///     This abstract class is used to read and write textual
    ///     data to and from a file.
    /// </devdoc>
    public abstract class TextBuffer {

        private EventHandler attributeChangedHandler;
        private TextBufferChangedEventHandler textChangedHandler;
        private bool         lockEvents;


        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.IsDirty"]/*' />
        /// <devdoc>
        ///      Marks this buffer as being modified.
        /// </devdoc>
        public virtual bool IsDirty {
            get {
                return false;
            }
            set {
            }
        }
        
        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.LockEvents"]/*' />
        /// <devdoc>
        ///      Locks change events.
        /// </devdoc>
        public bool LockEvents {
            get {
                return lockEvents;
            }
            set {
                lockEvents = value;
            }
        }
        
        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.ReadOnly"]/*' />
        /// <devdoc>
        ///      Determines if this file is read only.
        /// </devdoc>
        public virtual bool ReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.Text"]/*' />
        /// <devdoc>
        ///      Retrieves or sets the text in the entire stream.
        /// </devdoc>
        public abstract string Text { get;  set;}	

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.TextLength"]/*' />
        /// <devdoc>
        ///     Retrieves the number of characters in the buffer.
        /// </devdoc>
        public abstract int TextLength { get;}	

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.AttributeChanged"]/*' />
        /// <devdoc>
        ///     Event that will be raised when an attribute of this
        ///     buffer changes.
        /// </devdoc>
        public event EventHandler AttributeChanged {
            add {
                attributeChangedHandler += value;
            }
            remove {
                attributeChangedHandler -= value;
            }
        }
        
        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.TextChanged"]/*' />
        /// <devdoc>
        ///     Event that will be raised when the contents of this
        ///     buffer change.  This will not be raised if WE are the
        ///     ones responsible for changing the buffer.
        /// </devdoc>
        public event TextBufferChangedEventHandler TextChanged {
            add {
                textChangedHandler += value;
            }                             
            remove {
                textChangedHandler -= value;
            }
        }
        
        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.Checkout"]/*' />
        /// <devdoc>
        ///     Checks out the file this buffer is connected to, or throws
        ///     a CheckoutException on failure.
        /// </devdoc>
        public virtual void Checkout() {
        }

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.Checkout2"]/*' />
        /// <devdoc>
        ///     Checks out the file this buffer is connected to, and any additional buffers passed
        ////    in parameter or throws a CheckoutException on failure.
        /// </devdoc>
        public virtual void Checkout(string[] additionalBuffers) {
        }

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.Dirty"]/*' />
        /// <devdoc>
        ///      Marks this buffer as being modified.
        /// </devdoc>
        //public virtual void Dirty() {
        //}
        
        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes this text buffer.
        /// </devdoc>
        public virtual void Dispose() {
        }

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.GetText"]/*' />
        /// <devdoc>
        ///     Retrieves the contents of the buffer starting at
        ///     startPosition.  A total of chars
        ///     characters will be retrieved.  This will throw
        ///     an exception if either parameter would run off the
        ///     end of the buffer.
        /// </devdoc>
        public abstract string GetText(int startPosition, int chars);

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.OnAttributeChanged"]/*' />
        /// <devdoc>
        ///     Called when an attribute on the buffer changes.
        /// </devdoc>
        protected void OnAttributeChanged(EventArgs e) {
            if (attributeChangedHandler != null && !lockEvents) {
                attributeChangedHandler(this, e);
            }
        }

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.OnTextChanged"]/*' />
        /// <devdoc>
        ///     Called when the text in the buffer changes.
        /// </devdoc>
        protected void OnTextChanged(TextBufferChangedEventArgs e) {
            if (textChangedHandler != null && !lockEvents) {
                textChangedHandler(this, e);
            }
        }

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.ReplaceText"]/*' />
        /// <devdoc>
        ///     Replaces text in the buffer with the given string.  The
        ///     replacement will replace all text beginning at startPosition
        ///     and ending at chars.
        /// </devdoc>
        public abstract void ReplaceText(int startPosition, int count, string text);
        
        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.ShowCode"]/*' />
        /// <devdoc>
        ///     If there is a text view associated with this buffer, this will
        ///     attempt to surface this view to the user.
        /// </devdoc>
        public abstract void ShowCode();

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.ShowCode1"]/*' />
        /// <devdoc>
        ///     If there is a text view associated with this buffer, this will
        ///     attempt to surface this view to the user.  The caret will be
        ///     moved to lineNum.
        /// </devdoc>
        public abstract void ShowCode(int lineNum);

        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.ShowCode2"]/*' />
        /// <devdoc>
        ///     If there is a text view associated with this buffer, this will
        ///     attempt to surface this view to the user.  The caret will be
        ///     moved to lineNum, columnNum.
        /// </devdoc>
        public virtual void ShowCode(int lineNum, int columnNum) {
            ShowCode(lineNum);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\textbufferchangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBufferChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;

    /// <include file='doc\TextBufferChangedEventArgs.uex' path='docs/doc[@for="TextBufferChangedEventArgs"]/*' />
    /// <devdoc>
    ///     EventArgs for event that is raised when the text underlying the TextBuffer has changed.
    /// </devdoc>
    public class TextBufferChangedEventArgs : EventArgs {

        private bool reload;

        public TextBufferChangedEventArgs(bool shouldReload) {
            this.reload = shouldReload;
        }

        /// <include file='doc\TextBufferChangedEventArgs.uex' path='docs/doc[@for="TextBufferChangedEventArgs.SnouldReload"]/*' />
        /// <devdoc>
        ///      True if the designer should be reloaded as a result of this change - e.g. this wasn't a change the designer caused or expected
        ///      such as another application or source control changing the file.
        /// </devdoc>
        public bool ShouldReload {
            get {
                return this.reload;
            }
        }

    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\host\designerhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Host {
    using EnvDTE;
    using Microsoft.VisualStudio.Configuration;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.VisualStudio.Windows.Forms;
    using System;    
    using System.CodeDom;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;   
    using System.Text;
    using System.Web.UI.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using ObjectExtenders = EnvDTE.ObjectExtenders;
    using IExtenderProvider = System.ComponentModel.IExtenderProvider;

    /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost"]/*' />
    /// <devdoc>
    ///     The DesignerHost class manages the source code associated with a form.  It is the
    ///     container of the form, and it implements a wide array of interfaces for designer
    ///     support.  There is one of these objects for each document on the screen.
    ///     @author andersh, 4.97
    /// </devdoc>
    internal sealed class DesignerHost :
        IVSMDDesigner,
        IComponentChangeService,
        IContainer,
        IExtenderProviderService,
        IDesignerLoaderHost,
        IDesignerHost,
        IDesignerDocument,
        IServiceProvider,
        NativeMethods.IObjectWithSite,
        ITypeDescriptorFilterService,
        IErrorReporting,
        IReflect {

        // Events that users can hook into
        //
        private static readonly object CODE_LOADED_EVENT = new object();
        private static readonly object COMPONENT_ADD_EVENT = new object();
        private static readonly object COMPONENT_ADDING_EVENT = new object();
        private static readonly object COMPONENT_CHANGE_EVENT = new object();
        private static readonly object COMPONENT_CHANGING_EVENT = new object();
        private static readonly object COMPONENT_REMOVE_EVENT = new object();
        private static readonly object COMPONENT_REMOVING_EVENT = new object();
        private static readonly object COMPONENT_RENAME_EVENT = new object();
        private static readonly object DOCUMENT_ACTIVATE_EVENT = new object();
        private static readonly object DOCUMENT_DEACTIVATE_EVENT = new object();
        private static readonly object TRANSACTION_CLOSED_EVENT = new object();
        private static readonly object TRANSACTION_CLOSING_EVENT = new object();
        private static readonly object TRANSACTION_OPENED_EVENT = new object();
        private static readonly object TRANSACTION_OPENING_EVENT = new object();

        // Service objects we are responsible for
        //
        private SelectionService              selectionService;       // selection services
        private MenuCommandService            menuCommandService;     // the menu command service
        private HelpService                   helpService;            // the help service
        private ReferenceService              referenceService;       // service to maintain references
        private VsTaskProvider                taskProvider;           // the task list provider
        private ImageList                     taskImages;             // the images it contains.
        private MenuEditorService             menuEditorService;      // vs menu editor service

        // User attached events, designers and services.
        //
        private Hashtable               eventTable;                // holds all of our events
        private ServiceContainer        serviceContainer;          // holds global services users have added
        private Hashtable               designerTable;             // holds component<->designer mappings

        // The current form design
        //
        private DesignerLoader              designerLoader;            // the loader that reads/writes the document
        private Hashtable                   sites;                     // name -> DesignSite mapping
        private DesignerComponentCollection components;                // public component collection.  Tracks sites table.
        private ArrayList                   extenderProviders;         // extenders that are on the current form
        private IComponent                  baseComponent;             // the base document component we're designing
        private string                      baseComponentClass;        // the name of the class the base compnoent represents
        private IRootDesigner               baseDesigner;              // the designer for the document
        private DocumentWindow              documentWindow;            // the thing being reparented by the docwin
        private ITypeResolutionService      typeResolver;              // The object we load types through.
        private Exception                   loadError;                 // The first load error, or null.
        private bool                        viewRegistered;            // Have we registered our view with the shell?
        private IVsTextBuffer               registeredBuffer;          // registered view data
        private object                      registeredView;            // registered view data
        private INameCreationService        nameService;               // service we use to validate names of things.
        private int                         transactionCount;          // >0 means we're doing a transaction
        private StringStack                 transactionDescriptions;   // string descriptions of the current transactions
        private InterfaceReflector          interfaceReflector;        // the reflection object we use.
        private int                         supressComponentChanging;  // count to supress OnComponentChanging calls.

        // Flags that determine the validity of our code...are we in ssync?
        //
        private bool          loadingDesigner;           // true if we are loading
        private bool          unloadingDesigner;         // true if we are unloading
        private bool          reloading;                 // true if we are reloading the document

        // Transient stuff that changes with the 'flo
        //
        private DesignSite       newComponentSite;          // used during new component creation
        
        // License context information
        //
        private ShellDesigntimeLicenseContext licenseCtx;
        private static readonly object selfLock = new object();

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.DesignerHost"]/*' />
        /// <devdoc>
        ///     Public constructor.  Here we setup our own private objects and register
        ///     ourselves as a public service.
        /// </devdoc>
        internal DesignerHost() {
            eventTable = new Hashtable();
            designerTable = new Hashtable();
            sites = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            transactionCount = 0;
            reloading = false;
        }

        internal ShellDesigntimeLicenseContext LicenseContext {
            get {
                if (licenseCtx == null) {
                    licenseCtx = new ShellDesigntimeLicenseContext(this);
                }

                return licenseCtx;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Loading"]/*' />
        /// <devdoc>
        ///     Is the document currently being loaded.
        /// </devdoc>
        public bool Loading {
            get {
                return loadingDesigner || unloadingDesigner || (designerLoader != null && designerLoader.Loading);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.InTransaction"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the designer host is currently in a transaction.</para>
        /// </devdoc>
        public bool InTransaction { 
            get {
                return transactionCount > 0;
            }
        }

        public IContainer Container {
            get {
                return(IContainer)this;
            }
        }
        
        /// <devdoc>
        ///     Returns the IReflect object we will use for reflection.
        /// </devdoc>
        private InterfaceReflector Reflector {
            get {
                if (interfaceReflector == null) {
                    interfaceReflector = new InterfaceReflector(
                        typeof(DesignerHost), new Type[] {
                            typeof(IDesignerHost),
                            typeof(IComponentChangeService),
                            typeof(IContainer),
                            typeof(IExtenderProviderService),
                            typeof(IServiceProvider),
                            typeof(ITypeDescriptorFilterService)
                        }
                    );
                }
                return interfaceReflector;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.RootComponent"]/*' />
        /// <devdoc>
        ///     Retrieves the instance of the base class that is being used as the basis
        ///     for this design.  This is typically a Form or UserControl instance; it
        ///     defines the class for which the user's derived class will extend.
        /// </devdoc>
        public IComponent RootComponent {
            get {
                return baseComponent;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.RootComponentClassName"]/*' />
        /// <devdoc>
        ///     Retrieves the fully qualified name of the class that is being designed.
        ///     This class is not available at design time because it is the class that
        ///     is being designed, so the class's superclass is substituted.  This allows
        ///     you to get at the fully qualified name of the class that will be used
        ///     at runtime.
        /// </devdoc>
        public string RootComponentClassName {
            get {
                return baseComponentClass;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.TransactionDescription"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the description of the current transaction.
        ///    </para>
        /// </devdoc>
        public string TransactionDescription {
            get {
                if (transactionDescriptions != null) {
                    return transactionDescriptions.GetNonNull();
                }
                return "";
            }
        }


        public event ComponentEventHandler ComponentAdded {
            add {
                eventTable[COMPONENT_ADD_EVENT] = Delegate.Combine((Delegate)eventTable[COMPONENT_ADD_EVENT], value);
            }
            remove {
                eventTable[COMPONENT_ADD_EVENT] = Delegate.Remove((Delegate)eventTable[COMPONENT_ADD_EVENT], value);
            }
        }


        public event ComponentEventHandler ComponentAdding {
            add {
                eventTable[COMPONENT_ADDING_EVENT] = Delegate.Combine((Delegate)eventTable[COMPONENT_ADDING_EVENT], value);
            }
            remove {
                eventTable[COMPONENT_ADDING_EVENT] = Delegate.Remove((Delegate)eventTable[COMPONENT_ADDING_EVENT], value);
            }
        }


        public event ComponentChangedEventHandler ComponentChanged {
            add {
                eventTable[COMPONENT_CHANGE_EVENT] = Delegate.Combine((Delegate)eventTable[COMPONENT_CHANGE_EVENT], value);
            }
            remove {
                eventTable[COMPONENT_CHANGE_EVENT] = Delegate.Remove((Delegate)eventTable[COMPONENT_CHANGE_EVENT], value);
            }
        }


        public event ComponentChangingEventHandler ComponentChanging {
            add {
                eventTable[COMPONENT_CHANGING_EVENT] = Delegate.Combine((Delegate)eventTable[COMPONENT_CHANGING_EVENT], value);
            }
            remove {
                eventTable[COMPONENT_CHANGING_EVENT] = Delegate.Remove((Delegate)eventTable[COMPONENT_CHANGING_EVENT], value);
            }
        }


        public event ComponentEventHandler ComponentRemoved {
            add {
                eventTable[COMPONENT_REMOVE_EVENT] = Delegate.Combine((Delegate)eventTable[COMPONENT_REMOVE_EVENT], value);
            }
            remove {
                eventTable[COMPONENT_REMOVE_EVENT] = Delegate.Remove((Delegate)eventTable[COMPONENT_REMOVE_EVENT], value);
            }
        }


        public event ComponentEventHandler ComponentRemoving {
            add {
                eventTable[COMPONENT_REMOVING_EVENT] = Delegate.Combine((Delegate)eventTable[COMPONENT_REMOVING_EVENT], value);
            }
            remove {
                eventTable[COMPONENT_REMOVING_EVENT] = Delegate.Remove((Delegate)eventTable[COMPONENT_REMOVING_EVENT], value);
            }
        }


        public event ComponentRenameEventHandler ComponentRename {
            add {
                eventTable[COMPONENT_RENAME_EVENT] = Delegate.Combine((Delegate)eventTable[COMPONENT_RENAME_EVENT], value);
            }
            remove {
                eventTable[COMPONENT_RENAME_EVENT] = Delegate.Remove((Delegate)eventTable[COMPONENT_RENAME_EVENT], value);
            }
        }


        public event EventHandler Activated {
            add {
                eventTable[DOCUMENT_ACTIVATE_EVENT] = Delegate.Combine((Delegate)eventTable[DOCUMENT_ACTIVATE_EVENT], value);
            }
            remove {
                eventTable[DOCUMENT_ACTIVATE_EVENT] = Delegate.Remove((Delegate)eventTable[DOCUMENT_ACTIVATE_EVENT], value);
            }
        }


        public event EventHandler Deactivated {
            add {
                eventTable[DOCUMENT_DEACTIVATE_EVENT] = Delegate.Combine((Delegate)eventTable[DOCUMENT_DEACTIVATE_EVENT], value);
            }
            remove {
                eventTable[DOCUMENT_DEACTIVATE_EVENT] = Delegate.Remove((Delegate)eventTable[DOCUMENT_DEACTIVATE_EVENT], value);
            }
        }

        public event EventHandler LoadComplete {
            add {
                eventTable[CODE_LOADED_EVENT] = Delegate.Combine((Delegate)eventTable[CODE_LOADED_EVENT], value);
            }
            remove {
                eventTable[CODE_LOADED_EVENT] = Delegate.Remove((Delegate)eventTable[CODE_LOADED_EVENT], value);
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.TransactionClosed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionClosed'/> event.
        ///    </para>
        /// </devdoc>
        public event DesignerTransactionCloseEventHandler TransactionClosed {
            add {
                eventTable[TRANSACTION_CLOSED_EVENT] = Delegate.Combine((Delegate)eventTable[TRANSACTION_CLOSED_EVENT], value);
            }
            remove {
                eventTable[TRANSACTION_CLOSED_EVENT] = Delegate.Remove((Delegate)eventTable[TRANSACTION_CLOSED_EVENT], value);
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.TransactionClosing"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionClosing'/> event.</para>
        /// </devdoc>
        public event DesignerTransactionCloseEventHandler TransactionClosing {
            add {
                eventTable[TRANSACTION_CLOSING_EVENT] = Delegate.Combine((Delegate)eventTable[TRANSACTION_CLOSING_EVENT], value);
            }
            remove {
                eventTable[TRANSACTION_CLOSING_EVENT] = Delegate.Remove((Delegate)eventTable[TRANSACTION_CLOSING_EVENT], value);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.TransactionOpened"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionOpened'/> event.</para>
        /// </devdoc>
        public event EventHandler TransactionOpened {
            add {
                eventTable[TRANSACTION_OPENED_EVENT] = Delegate.Combine((Delegate)eventTable[TRANSACTION_OPENED_EVENT], value);
            }
            remove {
                eventTable[TRANSACTION_OPENED_EVENT] = Delegate.Remove((Delegate)eventTable[TRANSACTION_OPENED_EVENT], value);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.TransactionOpening"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionOpening'/> event.
        ///    </para>
        /// </devdoc>
        public event EventHandler TransactionOpening {
            add {
                eventTable[TRANSACTION_OPENING_EVENT] = Delegate.Combine((Delegate)eventTable[TRANSACTION_OPENING_EVENT], value);
            }
            remove {
                eventTable[TRANSACTION_OPENING_EVENT] = Delegate.Remove((Delegate)eventTable[TRANSACTION_OPENING_EVENT], value);
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Activate"]/*' />
        /// <devdoc>
        ///     Causes the designer that this host is hosting to become activated.
        /// </devdoc>
        public void Activate() {
            IVsWindowFrame frame = (IVsWindowFrame)GetService(typeof(IVsWindowFrame));
            if (frame != null) {
                frame.Show();
            }
            else {
                documentWindow.Focus();
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Add"]/*' />
        /// <devdoc>
        ///     adds the given component to the form.  This sets up the lifetime and site
        ///     relationship between component / container and then adds the new component
        ///     to the formcore and code buffer.
        ///     This will fabricate a default name for the component
        /// </devdoc>
        public void Add(IComponent component) {
            Add(component, null);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Add1"]/*' />
        /// <devdoc>
        ///     adds the given component to the form.  This sets up the lifetime and site
        ///     relationship between component / container and then adds the new component
        ///     to the code buffer.
        /// </devdoc>
        public void Add(IComponent component, string name) {
            Debug.WriteLineIf(Switches.CompCast.TraceVerbose,  "2Component: " + component.ToString() + " " + component.GetType().FullName);
            Debug.WriteLineIf(Switches.CompCast.TraceVerbose,  "2Site: " + ((component.Site != null) ? component.Site.GetType().FullName : "null"));
            if (unloadingDesigner) {
                Exception ex = new Exception(SR.GetString(SR.CODEMANOnUnload));
                ex.HelpLink = SR.CODEMANOnUnload;
                throw ex;
            }

            if (null == component)
                return;

            if (baseComponent != null) {

                // Compare to the class the basecomponent represents, not it's actual class!
                //
                if (String.Compare(component.GetType().FullName, baseComponentClass, true, CultureInfo.InvariantCulture) == 0) {
                    Exception ex = new Exception(SR.GetString(SR.CODEMANCyclicAdd, component.GetType().FullName));
                    ex.HelpLink = SR.CODEMANCyclicAdd;
                    throw ex;
                }
            }

            ISite site = component.Site;

            // If the compnent is already added to us, all we have to do is check
            // the name.  If the name is different we rename it, otherwise we do
            // nothing.
            //
            if (site != null && site.Container == this) {
                if (name != null && !name.Equals(site.Name)) {
                    CheckName(name);
                    site.Name = name;
                }
                return;
            }

            // Check to see if someone has already configured a site for us.  If so,
            // use it.  Otherwise, fabricate a new site.
            //
            DesignSite newSite = newComponentSite;
            newComponentSite = null;

            if (newSite != null && name == null) {
                name = newSite.Name;
                Debug.WriteLineIf(Switches.CompCast.TraceVerbose, "got name from site:  " + name );
            }

            // make sure we don't already have one of this type
            if (name != null) {
                CheckName(name);
            }

            // Remove this component from its current site
            //
            if (site != null) site.Container.Remove(component);

            ComponentEventArgs ce = new ComponentEventArgs(component);
            OnComponentAdding(ce);

            if (newSite == null) {
                newSite = new DesignSite(this, name);
            }

            // And set the relationship between this site and it's component.  If the
            // site has no name at this point, it will fabricate one.
            //
            newSite.SetComponent(component);

            // If we were given a site, the name we're given should always be null,
            // or at least be the same name as what's stored in the new site.
            //
            Debug.Assert(name == null || name.Equals(newSite.Name), "Name should match the one in newComponentSite");

            if (component is IExtenderProvider &&
                !TypeDescriptor.GetAttributes(component).Contains(InheritanceAttribute.InheritedReadOnly)) {
                AddExtenderProvider((IExtenderProvider)component);
            }

            // See if this component supports an IContainer constructor...
            //
            Type compClass = ((object)component).GetType();
            Type[] argTypes = new Type[] {typeof(IContainer)};

            // And establish the component/site relationship
            //
            sites[newSite.Name] = newSite;
            component.Site = newSite;
            if (components != null) {
                components.Add(newSite);
            }

            try {
                // Is this the first component the loader has created?  If so, then it must
                // be the base component (by definition) so we will expect there to be a document
                // designer associated with the component.  Otherwise, we search for a
                // normal designer, which can be optionally provided.
                //
                IDesigner designer = null;

                if (baseComponent == null) {
                    baseComponent = component;

                    // Get the root designer.  We check right here to see if the document window supports
                    // hosting this type of designer.  If not, we bail early.
                    //
                    baseDesigner = (IRootDesigner)TypeDescriptor.CreateDesigner(component, typeof(IRootDesigner));

                    if (baseDesigner == null) {
                        baseComponent = null;
                        Exception ex = new Exception(SR.GetString(SR.CODEMANNoTopLevelDesigner, compClass.FullName));
                        ex.HelpLink = SR.CODEMANNoTopLevelDesigner;
                        
                        throw ex;
                    }
                    
                    ViewTechnology[] technologies = baseDesigner.SupportedTechnologies;
                    bool supported = false;
                    foreach(ViewTechnology tech in technologies) {
                        if (tech == ViewTechnology.Passthrough || tech == ViewTechnology.WindowsForms) {
                            supported = true;
                            break;
                        }
                    }
                    
                    if (!supported) {
                        Exception ex = new Exception(SR.GetString(SR.CODEMANUnsupportedTechnology, compClass.FullName));
                        ex.HelpLink = SR.CODEMANUnsupportedTechnology;
                        
                        throw ex;
                    }                    

                    designer = baseDesigner;

                    // Check and see if anyone has set the class name of the base component.
                    // we default to the component name.
                    //
                    if (baseComponentClass == null) {
                        baseComponentClass = newSite.Name;
                    }
                }
                else {
                    designer = TypeDescriptor.CreateDesigner(component, typeof(IDesigner));
                }

                if (designer != null) {
                    designerTable[component] = designer;
                    try {
                        designer.Initialize(component);
                    }
                    catch {
                        designerTable.Remove(component);

                        if (designer == baseDesigner) {
                            baseDesigner = null;
                        }

                        throw;
                    }

                    if (designer is IExtenderProvider &&
                        !TypeDescriptor.GetAttributes(designer).Contains(InheritanceAttribute.InheritedReadOnly)) {
                        AddExtenderProvider((IExtenderProvider)designer);
                    }

                    // Now, if this is the base designer, initialize the document with it.
                    //
                    if (designer == baseDesigner) {
                        documentWindow.SetDesigner(baseDesigner);
                    }
                }

                // The component has been added.  Note that it is tempting to move this above the
                // designer because the designer will never need to know that its own component just
                // got added, but this would be bad because the designer is needed to extract
                // shadowed properties from the component.
                //
                OnComponentAdded(ce);
            }
            catch (Exception t) {
                if (t != CheckoutException.Canceled) {
                    Debug.Fail(t.ToString());

                    // If we're loading, then don't remove the component.  We are about to
                    // fail the load anyway here, and we don't want to be firing remove events during
                    // a load.
                    //
                    if (!loadingDesigner && !unloadingDesigner) {
                        Remove(component);
                    }
                }
                throw;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.AddExtenderProvider"]/*' />
        /// <devdoc>
        ///      Allows someone who is not a component to add an extender
        ///      provider into the design time set of extenders.  All
        ///      properties that appear from these extender providers will
        ///      be marked with as design time only.
        /// </devdoc>
        public void AddExtenderProvider(IExtenderProvider provider) {
            if (extenderProviders == null)
                extenderProviders = new ArrayList();

            extenderProviders.Add(provider);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CheckName"]/*' />
        /// <devdoc>
        ///     Validates that the given name is OK to use.  Not only does it have to
        ///     be a valid identifier, but it must not already be in our container.
        /// </devdoc>
        private void CheckName(string name) {

            if (name == null || name.Length == 0) {

                Exception ex = new Exception(SR.GetString(SR.CODEMANEmptyIdentifier));
                ex.HelpLink = SR.CODEMANEmptyIdentifier;
                throw ex;
            }

            if (this.Components[name] != null) {
                Exception ex = new Exception(SR.GetString(SR.CODEMANDupComponentName, name));
                ex.HelpLink = SR.CODEMANDupComponentName;
                throw ex;
            }
            
            if (nameService == null) {
                nameService = (INameCreationService)GetService(typeof(INameCreationService));
            }
            
            if (nameService != null) {
                nameService.ValidateName(name);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateComponent"]/*' />
        /// <devdoc>
        ///     Creates a new component from the given class.  This fabricates a name
        ///     for the component and sites it in the container.
        /// </devdoc>
        public IComponent CreateComponent(Type componentClass) {
            return CreateComponent(componentClass, (DesignSite)null);
        }


        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateComponent1"]/*' />
        /// <devdoc>
        ///     Creates a component of the given class name.  This creates the component
        ///     and sites it into the designer container.
        /// </devdoc>
        public IComponent CreateComponent(Type componentClass, string name) {
            return CreateComponent(componentClass, new DesignSite(this, name));
        }
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateComponent2"]/*' />
        /// <devdoc>
        ///     Creates a new component from a given class.  The given site will be
        ///     used as a template for the component's values.  For example, the site's
        ///     attributes can be preset and a name can be created here.
        /// </devdoc>
        public IComponent CreateComponent(Type componentClass, DesignSite newSite) {

            Debug.WriteLineIf(Switches.CompCast.TraceVerbose,  "Creating component of type'" + componentClass.FullName + "'");

            object obj = null;
            IComponent comp = null;
            bool fAddCalled = false;

            // Store this so when the component calls add on us, it can pick up any user-defined site.
            //
            newComponentSite = newSite;

            try {
                // see if we can create the component using an IContainer constructor...
                //
                try {
                    object[] args = new object[] {this};
                    Type[] argTypes = new Type[] {typeof(IContainer)};
                    obj = CreateObject(componentClass, args, argTypes, false);

                    if (obj != null) {
                        // Did the object add itself to the container?  This is only possible if we created
                        // it with an appropriate constructor.
                        //
                        fAddCalled = (obj is IComponent) &&
                                     ((IComponent)obj).Site is DesignSite;
                    }
                }
                catch (Exception) {
                }

                // If it failed, try to create it with a default constructor
                //
                if (null == obj) {
                    obj = CreateObject(componentClass, null, null);
                }

                if (!(obj is IComponent)) {
                    Exception ex = new Exception(SR.GetString(SR.ClassNotIComponent, componentClass.FullName));
                    ex.HelpLink = SR.ClassNotIComponent;
                    
                    throw ex;
                }

                comp = (IComponent)obj;
                Debug.WriteLineIf(Switches.CompCast.TraceVerbose,  "0Component: " + comp.ToString() + " " + comp.GetType().FullName);
                Debug.WriteLineIf(Switches.CompCast.TraceVerbose,  "0Site: " + ((comp.Site != null) ? comp.Site.GetType().FullName : "null"));

                // If we didn't have a constructor that took a code manager, then we will
                // do the container.add() work ourselves.  If it did, then it was the component's
                // responsibility to do this, which we police below.
                //
                if (!fAddCalled) {
                    Debug.WriteLineIf(Switches.CompCast.TraceVerbose,  "1Component: " + comp.ToString() + " " + comp.GetType().FullName);
                    Debug.WriteLineIf(Switches.CompCast.TraceVerbose,  "1Site: " + ((comp.Site != null) ? comp.Site.GetType().FullName : "null"));
                    Add(comp);
                }
                else {
                    if (!(comp.Site is DesignSite)) {
                        Exception ex = new Exception(SR.GetString(SR.CODEMANDidntCallAddInConstructor,componentClass.FullName));
                        ex.HelpLink = SR.CODEMANDidntCallAddInConstructor;
                        
                        throw ex;
                    }
                }

                DesignSite site = (DesignSite)comp.Site;

                // At this point, our add call should have used the new site we gave it (if there was
                // one), and nulled out the holder pointer.
                //
                Debug.Assert(newComponentSite == null, "add didn't use newComponentSite");
            }
            catch (Exception ex) {

                try {
                    if (ex == CheckoutException.Canceled) {
                        this.supressComponentChanging++;
                    }
    
                    if (comp != null) {
                        try {
                            DestroyComponent(comp);
                        }
                        catch (Exception) {
                        }
                    }
                }
                finally {

                    if (ex == CheckoutException.Canceled) {
                        this.supressComponentChanging--;
                    }
                }


                // A lot of CLR exceptions have no message information, so we ToString the exception here
                // so the user has some information.
                //
                string message = ex.Message;

                if (message == null || message.Length == 0) {
                    throw new Exception(ex.ToString(), ex);
                }
                
                throw;
            }

            return comp;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateObject"]/*' />
        /// <devdoc>
        ///     Creates an instance of the target class.  This is used during code parsing
        ///     to create intstances of non-component objects, such as Fonts and Colors.
        /// </devdoc>
        public object CreateObject(Type objectClass) {
            return CreateObject(objectClass, null);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateObject1"]/*' />
        /// <devdoc>
        ///     Creates an instance of the target class.  This is used during code parsing
        ///     to create intstances of non-component objects, such as Fonts and Colors.
        /// </devdoc>
        public object CreateObject(Type objectClass, object[] args) {
            return CreateObject(objectClass, args, null);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateObject2"]/*' />
        /// <devdoc>
        ///     Creates an instance of the target class.  This is used during code parsing
        ///     to create intstances of non-component objects, such as Fonts and Colors.
        /// </devdoc>
        public object CreateObject(Type objectClass, object []args, Type[] argTypes) {
            return CreateObject(objectClass, args, argTypes, true);
        }

        private object CreateObject(Type objectClass, object []args, Type[] argTypes, bool fThrowException) {
            ConstructorInfo ctr = null;

            if (args != null && args.Length > 0) {
                if (argTypes == null) {
                    argTypes = new Type[args.Length];

                    for (int i = args.Length - 1; i>= 0; i--) {
                        if (args[i] != null) argTypes[i] = args[i].GetType();
                    }
                }

                ctr = objectClass.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, argTypes, null);

                if (ctr == null && fThrowException) {
                    Exception ex = new Exception(SR.GetString(SR.ClassMissingConstructor, objectClass.FullName));
                    ex.HelpLink = SR.ClassMissingConstructor;
                    
                    throw ex;
                }
                else
                    return null;
            }

            LicenseContext oldContext = LicenseManager.CurrentContext;
            LicenseManager.CurrentContext = LicenseContext;
            LicenseManager.LockContext(selfLock);

            try {
                return(ctr == null) ? Activator.CreateInstance(objectClass, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null) : ctr.Invoke(args);
            }
            catch (Exception e) {
                if (e is TargetInvocationException) {
                    e = e.InnerException;
                }
                
                string message = e.Message;
                if (message == null) {
                    message = e.ToString();
                }
                
                throw new Exception(SR.GetString(SR.ExceptionCreatingObject,
                                                    objectClass.FullName,
                                                    message), e);
            }
            finally {
                LicenseManager.UnlockContext(selfLock);
                LicenseManager.CurrentContext = oldContext;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateTransaction"]/*' />
        /// <devdoc>
        /// <para>
        ///     Lengthy operations that involve multiple components may raise many events.  These events
        ///     may cause other side-effects, such as flicker or performance degradation.  When operating
        ///     on multiple components at one time, or setting multiple properties on a single component,
        ///     you should encompass these changes inside a transaction.  Transactions are used
        ///     to improve performance and reduce flicker.  Slow operations can listen to 
        ///     transaction events and only do work when the transaction completes.
        /// </para>
        /// </devdoc>
        public DesignerTransaction CreateTransaction() {
            return CreateTransaction(null);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.CreateTransaction1"]/*' />
        /// <devdoc>
        /// <para>
        ///     Lengthy operations that involve multiple components may raise many events.  These events
        ///     may cause other side-effects, such as flicker or performance degradation.  When operating
        ///     on multiple components at one time, or setting multiple properties on a single component,
        ///     you should encompass these changes inside a transaction.  Transactions are used
        ///     to improve performance and reduce flicker.  Slow operations can listen to 
        ///     transaction events and only do work when the transaction completes.
        /// </para>
        /// </devdoc>
        public DesignerTransaction CreateTransaction(string description) {
            if (description == null) {
                description = string.Empty;
            }
            
            return new HostDesignerTransaction(this, description);
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.DestroyComponent"]/*' />
        /// <devdoc>
        ///     Destroys the given component, removing it from the design container.
        /// </devdoc>
        public void DestroyComponent(IComponent comp) {
            string name;
            
            if (comp.Site != null && comp.Site.Name != null) {
                name = comp.Site.Name;
            }
            else {
                name = comp.GetType().Name;
            }

            // Make sure the component is not being inherited -- we can't delete these!
            //
            InheritanceAttribute ia = (InheritanceAttribute)TypeDescriptor.GetAttributes(comp)[typeof(InheritanceAttribute)];
            if (ia != null && ia.InheritanceLevel != InheritanceLevel.NotInherited) {
                Exception ex = new InvalidOperationException(SR.GetString(SR.CODEMANCantDestroyInheritedComponent, name));
                ex.HelpLink = SR.CODEMANCantDestroyInheritedComponent;
                
                throw ex;
            }
            
            DesignerTransaction t = null;
            try {
                // We try to remove the component from the container before destroying it.  This allows us to
                // ensure the file is checked out (via OnComponentRemoving) before actually destroying the
                // object.
                //
                t = CreateTransaction(SR.GetString(SR.CODEMANDestroyComponentTransaction, name));

                // We need to signal changing and then perform the remove.  Remove must be done by us and not
                // by Dispose because (a) people need a chance to cancel through a Removing event, and (b)
                // Dispose removes from the container last and anything that would sync Removed would end up
                // with a dead component.
                //
                OnComponentChanging(comp, null);
                if (comp.Site != null) {
                    Remove(comp);
                }
                comp.Dispose();
                OnComponentChanged(comp, null, null, null);
            }
            finally {
                if (t != null) {
                    t.Commit();
                }
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of the DesignContainer.  This cleans up any objects we may be holding
        ///     and removes any services that we created.
        /// </devdoc>
        public void Dispose() {
        
            DocumentManager dm = (DocumentManager)GetService(typeof(DocumentManager));
            if (dm != null) {
                dm.OnDesignerDisposed(new DesignerEventArgs(this));
            }
            
            // Unregister our view
            //
            if (viewRegistered) {
                RegisterView(false);
            }

            // First, before disposing anything, flush the code stream and then
            // unload it.  If we don't do this the code stream will delete all
            // components on the form.
            //
            if (designerLoader != null) {
                try {
                    designerLoader.Flush();
                }
                catch (Exception e1) {
                    Debug.Fail("Designer loader '" + designerLoader.GetType().Name + "' threw during Flush: " + e1.ToString());
                    e1 = null;
                }
                try {
                    designerLoader.Dispose();
                }
                catch (Exception e2) {
                    Debug.Fail("Designer loader '" + designerLoader.GetType().Name + "' threw during Dispose: " + e2.ToString());
                    e2 = null;
                }
                designerLoader = null;
            }

            // Unload the document
            //
            UnloadDocument();

            // Detach ourselves from any event handlers we were using.
            //
            IDesignerEventService des = (IDesignerEventService)GetService(typeof(IDesignerEventService));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || des != null, "IDesignerEventService not found");
            if (des != null) {
                des.ActiveDesignerChanged -= new ActiveDesignerEventHandler(this.OnActiveDesignerChanged);
            }

            // no services after this!
            //
            serviceContainer = null;

            // Now tear down all of our services.
            //

            if (menuEditorService != null) {
                menuEditorService.Dispose();
            }

            if (selectionService != null) {
                selectionService.Dispose();
                selectionService = null;
            }

            if (menuCommandService != null) {
                menuCommandService.Dispose();
                menuCommandService = null;
            }

            if (helpService != null) {
                helpService.Dispose();
                helpService = null;
            }

            if (referenceService != null) {
                referenceService.Dispose();
                referenceService = null;
            }

            if (taskProvider != null) {
                taskProvider.Tasks.Clear();
                taskProvider.Dispose();
                taskProvider = null;
            }
            
            if (taskImages != null) {
                taskImages.Dispose();
                taskImages = null;
            }

            // Destroy our document window.
            //
            if (documentWindow != null) {
                documentWindow.Dispose();
                documentWindow = null;
            }

            // We're completely dead now.
            //
            GC.Collect();
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.FilterAttributes"]/*' />
        /// <devdoc>
        ///      This will be called when a user requests a set of attributes
        ///      for a component.  The attributes will be added to the
        ///      dictionary with the attribute types as the keys.  
        ///      Implementers of this service may make changes, add or remove
        ///      attributes in the dictionary.
        /// </devdoc>
        public bool FilterAttributes(IComponent component, IDictionary attributes) {
            IDesigner designer = GetDesigner(component);
            if (designer is IDesignerFilter) {
                ((IDesignerFilter)designer).PreFilterAttributes(attributes);
                ((IDesignerFilter)designer).PostFilterAttributes(attributes);
            }
            return designer != null;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.FilterEvents"]/*' />
        /// <devdoc>
        ///      This will be called when a user requests a set of events
        ///      for a component.  The events will be added to the
        ///      dictionary with the event names as the keys.  
        ///      Implementers of this service may make changes, add or remove
        ///      events in the dictionary.
        /// </devdoc>
        public bool FilterEvents(IComponent component, IDictionary events) {
            IDesigner designer = GetDesigner(component);
            if (designer is IDesignerFilter) {
                ((IDesignerFilter)designer).PreFilterEvents(events);
                ((IDesignerFilter)designer).PostFilterEvents(events);
            }
            return designer != null;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.FilterProperties"]/*' />
        /// <devdoc>
        ///      This will be called when a user requests a set of properties
        ///      for a component.  The properties will be added to the
        ///      dictionary with the property names as the keys.  
        ///      Implementers of this service may make changes, add or remove
        ///      properties in the dictionary.
        /// </devdoc>
        public bool FilterProperties(IComponent component, IDictionary properties) {

            // Now do the VS property filtering here.  DTE wants to hide some properties.
            //
            Microsoft.VisualStudio.PropertyBrowser.PropertyBrowser.FilterProperties(this, component, properties);

            IDesigner designer = GetDesigner(component);
            if (designer is IDesignerFilter) {
                ((IDesignerFilter)designer).PreFilterProperties(properties);
                ((IDesignerFilter)designer).PostFilterProperties(properties);
            }
            return designer != null;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Components"]/*' />
        /// <devdoc>
        ///     Retrieves an array of all components in this container
        /// </devdoc>
        public ComponentCollection Components {
            get {
                if (components == null) {
                    components = new DesignerComponentCollection(this);
                }
                
                return components;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetDesigner"]/*' />
        /// <devdoc>
        ///     Retrieves the designer for the given component.
        /// </devdoc>
        public IDesigner GetDesigner(IComponent component) {
            Debug.Assert(component != null, "Cannot call GetDesigner with a NULL component.  Check that the root hasn't been disposed.");
            if (component == null) throw new ArgumentNullException("component");
            return(IDesigner)designerTable[component];
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetExtenderProviders"]/*' />
        /// <devdoc>
        ///     Retrieves an array of all extender providers that are currently offering
        ///     extender properties on components.
        /// </devdoc>
        public IExtenderProvider[] GetExtenderProviders() {
            if (extenderProviders == null)
                return(new IExtenderProvider[0]);
            return(IExtenderProvider[]) extenderProviders.ToArray(typeof(IExtenderProvider));
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetNewComponentName"]/*' />
        /// <devdoc>
        ///     Construct a unique name for a new component. The resulting name is a
        ///     concatenation of the decapitalized class name and the lowest possible
        ///     integer that makes the name unique (e.g. "button1" or "textArea3").
        /// </devdoc>
        internal string GetNewComponentName(Type compClass) {
            INameCreationService nameCreate = (INameCreationService)GetService(typeof(INameCreationService));
            if (nameCreate != null) {
                return nameCreate.CreateName(Container, compClass);
            }
            
            // Do a default thing...
            //
            string baseName = compClass.Name;
            
            // camel case the base name.
            //
            StringBuilder b = new StringBuilder(baseName.Length);
            for (int i = 0; i < baseName.Length; i++) {
                if (Char.IsUpper(baseName[i]) && (i == 0 || i == baseName.Length - 1 || Char.IsUpper(baseName[i+1]))) {
                    b.Append(Char.ToLower(baseName[i], CultureInfo.InvariantCulture));
                }
                else {
                    b.Append(baseName.Substring(i));
                    break;
                }
            }
            baseName = b.ToString();
            
            int idx = 1;
            string finalName = baseName + idx.ToString();
            while(Container.Components[finalName] != null) {
                idx++;
                finalName = baseName + idx.ToString();
            }
            
            return finalName;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves a service at the DesignContainer level, and traverses up to the
        ///     global service list if necessary.  Note that anything with access to
        ///     a component (such as a designer, which is tied to a component), should
        ///     go through the getService method on the component's site.  By having
        ///     a single way to access services, we don't end up with the "which service
        ///     provider is the right one?" question that the shell has today.
        /// </devdoc>
        public object GetService(Type serviceClass) {

            // Delegate to our standard service container.
            //
            if (serviceContainer != null) {
                return serviceContainer.GetService(serviceClass);
            }
            
            return null;
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetSite"]/*' />
        /// <devdoc>
        ///     Retrieves the requested site interface.  We just pass this to our
        ///     service provider, if it supports IObjectWithSite.  Otherwise, we
        ///     fail with E_NOINTERFACE.
        /// </devdoc>
        public void GetSite(ref Guid riid, object[] site) {
            site[0] = GetSite(ref riid);
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetSite1"]/*' />
        /// <devdoc>
        ///     Retrieves the requested site interface.  We just pass this to our
        ///     service provider, if it supports IObjectWithSite.  Otherwise, we
        ///     fail with E_NOINTERFACE.
        /// </devdoc>
        public object GetSite(ref Guid riid) {
            NativeMethods.IObjectWithSite ows = (NativeMethods.IObjectWithSite)GetService(typeof(NativeMethods.IObjectWithSite));
            if (ows != null) {
                return ows.GetSite(ref riid);
            }
            else {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOINTERFACE);
            }

            return null;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetSite1"]/*' />
        /// <devdoc>
        ///     Retrieves the DesignSite for the given component name.
        /// </devdoc>
        public DesignSite GetSite(string name) {
            return(DesignSite)sites[name];
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetSite2"]/*' />
        /// <devdoc>
        ///     Retrieves the DesignSite for the given component.
        /// </devdoc>
        public DesignSite GetSite(IComponent component) {
            ISite site = component.Site;
            if (site is DesignSite) {
                return(DesignSite) site;
            }
            return null;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.GetType"]/*' />
        /// <devdoc>
        ///     Retrieves the Type instance for the given type name.  The type name must be
        ///     fully qualified.
        /// </devdoc>
        public Type GetType(string typeName) {
            if (typeResolver == null) {
                typeResolver = (ITypeResolutionService)GetService(typeof(ITypeResolutionService));
            }
            if (typeResolver != null) {
                return typeResolver.GetType(typeName);
            }
            return Type.GetType(typeName);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Init"]/*' />
        /// <devdoc>
        ///     Initialization for the design container.  This supplies us with the needed interfaces
        ///     needed to initialize a form and create a designer.
        /// </devdoc>
        public void Init(IServiceProvider provider, DesignerLoader designerLoader) {
            try {
                this.serviceContainer = new ServiceContainer(provider);
                
                // Things we need early on.
                //
                documentWindow = new DocumentWindow(this);
                    
                // Services that we already have implemented on our object
                //
                serviceContainer.AddService(typeof(IDesignerHost), this);
                serviceContainer.AddService(typeof(IComponentChangeService), this);
                serviceContainer.AddService(typeof(IExtenderProviderService), this);
                serviceContainer.AddService(typeof(IContainer), this);
                serviceContainer.AddService(typeof(ITypeDescriptorFilterService), this);
                
                // And services that we demand create.
                //
                ServiceCreatorCallback callback = new ServiceCreatorCallback(this.OnCreateService);
                serviceContainer.AddService(typeof(IMenuEditorService), callback);
                serviceContainer.AddService(typeof(ISelectionService), callback);
                serviceContainer.AddService(typeof(IMenuCommandService), callback);
                serviceContainer.AddService(typeof(NativeMethods.IOleCommandTarget), callback);
                serviceContainer.AddService(typeof(IHelpService), callback);
                serviceContainer.AddService(typeof(IReferenceService), callback);
                serviceContainer.AddService(typeof(IPropertyValueUIService), callback);

                // configure extenders
                //
                this.extenderProviders = new ArrayList();
                AddExtenderProvider(new HostExtenderProvider(this));
                AddExtenderProvider(new HostInheritedExtenderProvider(this));

                // Attach document activation / deactivation events.
                //
                IDesignerEventService des = (IDesignerEventService)GetService(typeof(IDesignerEventService));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || des != null, "IDesignerEventService not found");
                if (des != null) {
                    des.ActiveDesignerChanged += new ActiveDesignerEventHandler(this.OnActiveDesignerChanged);
                }

                serviceContainer.AddService(typeof(ManagedPropertiesService), new ManagedPropertiesService(this));
                
                // Now we're done.  Note that the form hasn't been loaded yet.  This happens
                // in a somewhat roundabout fashion due to what I've been told is "the OLE way
                // of initializing documents".  So where does the load occur?  It happens in
                // CreatePane of the document window.  This is the next logical step where
                // we can do this sort of thing.
                this.designerLoader = designerLoader;
                
                // Finally, load the document
                //
                Load(false);
                
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
                throw;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Load"]/*' />
        /// <devdoc>
        ///     Loads the document from the code stream.
        /// </devdoc>
        private void Load(bool reloading) {
            Cursor oldCursor = Cursor.Current;
            Cursor.Current = Cursors.WaitCursor;
            this.reloading = reloading;

            try {
                if (!reloading && designerLoader is IExtenderProvider) {
                    AddExtenderProvider((IExtenderProvider)designerLoader);
                }
                
                if (taskProvider != null) {
                    taskProvider.Tasks.Clear();
                }
                
                if (loadError != null && helpService != null) {
                    string helpLink = loadError.HelpLink;
                    
                    if (helpLink != null && helpLink.Length > 0) {
                        helpService.RemoveContextAttribute("Keyword", helpLink);
                    }
                }
                
                loadingDesigner = true;
                loadError = null;
                designerLoader.BeginLoad(this);
            }
            catch (Exception e) {
                Exception exNew = e;
                // These things are just plain useless.
                //
                if (e is TargetInvocationException) {
                    exNew = e.InnerException;
                }

                string message = exNew.Message;

                // We must handle the case of an exception with no message.
                //
                if (message == null || message.Length == 0) {
                    Debug.Fail("Parser has thrown an exception that has no friendly message", exNew.ToString());
                    exNew = new Exception(SR.GetString(SR.CODEMANDocumentException, exNew.ToString()));
                }
            
                // Loader blew up.  Add this exception to our error list
                //
                ArrayList errorList = new ArrayList();
                errorList.Add(exNew);
                ((IDesignerLoaderHost)this).EndLoad(null, false, errorList);
            }
            
            Cursor.Current = oldCursor;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnActiveDesignerChanged"]/*' />
        /// <devdoc>
        ///     Called in response to a document becoming active or inactive.
        /// </devdoc>
        private void OnActiveDesignerChanged(object sender, ActiveDesignerEventArgs e) {

            object eventobj = null;


            if (e.OldDesigner == this) {
                eventobj = DOCUMENT_DEACTIVATE_EVENT;
            }
            else if (e.NewDesigner == this) {
                eventobj = DOCUMENT_ACTIVATE_EVENT;
                
                // If we are first becoming active, register our view
                //
                if (!viewRegistered) {
                    RegisterView(true);
                }
            }

            // Not our document, so we don't fire.
            //
            if (eventobj == null) {
                return;
            }
            
            // Finally, if we are deactivating, flush our buffer.
            //
            if (e.OldDesigner == this) {
                ((IVSMDDesigner)this).Flush();
            }

            // Fire the appropriate event.
            //
            EventHandler handler = (EventHandler)eventTable[eventobj];
            if (handler != null) {
                handler(this, EventArgs.Empty);
            }

            // And notify the shell what properties window to display...
            //
            if (e.NewDesigner == this) {
                IVsTrackSelectionEx tsex = (IVsTrackSelectionEx)this.GetService((typeof(IVsTrackSelectionEx)));
                if (tsex != null) {
                    string coolPbrsToolWin = "{" + (typeof(IVSMDPropertyBrowser)).GUID.ToString() + "}";
                    tsex.OnElementValueChange(4 /* SEID_PropertyBrowserSID */, 0, coolPbrsToolWin);
                    System.Runtime.InteropServices.Marshal.ReleaseComObject(tsex);
                }
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnComponentAdded"]/*' />
        /// <devdoc>
        ///     This is called after a component has been added to the container.
        /// </devdoc>
        private void OnComponentAdded(ComponentEventArgs ce) {
            Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "Added component: " + ce.Component.ToString());

            ComponentEventHandler ceh = (ComponentEventHandler)eventTable[COMPONENT_ADD_EVENT];
            if (ceh != null) {
                ceh.Invoke(this, ce);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnComponentAdding"]/*' />
        /// <devdoc>
        ///     This is called when a component is about to be added to our container.
        /// </devdoc>
        private void OnComponentAdding(ComponentEventArgs ce) {
            Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "Adding component: " + ce.Component.ToString());

            ComponentEventHandler ceh = (ComponentEventHandler)eventTable[COMPONENT_ADDING_EVENT];
            if (ceh != null) {
                ceh.Invoke(this, ce);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnComponentChanged"]/*' />
        /// <devdoc>
        ///     This is called after a property has been changed.  It allows
        ///     the implementor to do any post-processing that may be needed
        ///     after a property change.  For example, a designer will typically
        ///     update the source code that sets the property with the new value.
        /// </devdoc>
        public void OnComponentChanged(object component, MemberDescriptor member, Object oldValue, Object newValue) {

#if DEBUG
            Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "Component changed: " + component.ToString());
            if (member != null) {
                Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "\t Member: " + member.Name);
                Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "\t Old   : " + Convert.ToString(oldValue));
                Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "\t New   : " + Convert.ToString(newValue));
            }
#endif // DEBUG

            // If we're loading code, then eat changes.  This just slows us down.
            //
            if (Loading || supressComponentChanging > 0) {
                return;
            }

            //  Fire our changed event.
            //
            ComponentChangedEventHandler handler = (ComponentChangedEventHandler)eventTable[COMPONENT_CHANGE_EVENT];
            if (handler != null) {
                ComponentChangedEventArgs ce = new ComponentChangedEventArgs(component, member, oldValue, newValue);
                handler.Invoke(this, ce);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnComponentChanging"]/*' />
        /// <devdoc>
        ///     This is called when a property is about to change.  Before the
        ///     property descriptor commits the property it will call this
        ///     method.  This method should throw an exception if the property
        ///     cannot be changed.  This is not intended to validate the values
        ///     of a particular property.  Instead, it is intended to be a global
        ///     way of preventing a component from changing.  For example, if
        ///     a designer file is checked into source code control, this would
        ///     typically throw an exception if the user refused to check out
        ///     the file.
        /// </devdoc>
        public void OnComponentChanging(object component, MemberDescriptor member) {

            Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "Component Changing: " + ((component == null) ? "(null)" : component.ToString()));

            // If we're loading code, then eat changes.  This just slows us down.
            //
            if (Loading || supressComponentChanging > 0) {
                return;
            }

            ComponentChangingEventHandler handler = (ComponentChangingEventHandler)eventTable[COMPONENT_CHANGING_EVENT];
            if (handler != null) {
                ComponentChangingEventArgs ce = new ComponentChangingEventArgs(component, member);
                handler.Invoke(this, ce);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnCreateService"]/*' />
        /// <devdoc>
        ///     Creates some of the more infrequently used services we offer.
        /// </devdoc>
        private object OnCreateService(IServiceContainer container, Type serviceType) {
            if (serviceType == typeof(IMenuEditorService)) {
                if (menuEditorService == null) {
                    menuEditorService = new MenuEditorService(this);
                }
                return menuEditorService;
            }
            
            if (serviceType == typeof(ISelectionService)) {
                if (selectionService == null) {
                    selectionService = new SelectionService(this);
                }
                return selectionService;
            }
            
            if (serviceType == typeof(IMenuCommandService) || serviceType == typeof(NativeMethods.IOleCommandTarget)) {
                if (menuCommandService == null) {
                    menuCommandService = new MenuCommandService(this);
                }
                return menuCommandService;
            }
            
            if (serviceType == typeof(IHelpService)) {
                if (helpService == null) {
                    helpService = new HelpService(this);
                }
                return helpService;
            }
            
            if (serviceType == typeof(IReferenceService)) {
                if (referenceService == null) {
                    referenceService = new ReferenceService(this, true /* IgnoreCase */);
                }
                return referenceService;
            }
            
            if (serviceType == typeof(IPropertyValueUIService)) {
                return new PropertyValueUIService();
            }

            
            Debug.Fail("Service type " + serviceType.FullName + " requested but we don't support it");
            return null;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnComponentRemoved"]/*' />
        /// <devdoc>
        ///     This is called after a component has been removed from the container, but before
        ///     the component's site has been destroyed.
        /// </devdoc>
        private void OnComponentRemoved(ComponentEventArgs ce) {
            Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "Component Removed: " + ce.Component.ToString());

            ComponentEventHandler ceh = (ComponentEventHandler)eventTable[COMPONENT_REMOVE_EVENT];
            if (ceh != null) {
                ceh.Invoke(this, ce);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnComponentRemoving"]/*' />
        /// <devdoc>
        ///     This is called when a component is about to be removed from our container.
        /// </devdoc>
        private void OnComponentRemoving(ComponentEventArgs ce) {
            Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "Component Removing: " + ce.Component.ToString());

            ComponentEventHandler ceh = (ComponentEventHandler)eventTable[COMPONENT_REMOVING_EVENT];
            if (ceh != null) {
                ceh.Invoke(this, ce);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.OnComponentRename"]/*' />
        /// <devdoc>
        ///     This is called when a component has been renamed.
        /// </devdoc>
        private void OnComponentRename(ComponentRenameEventArgs cre) {
            Debug.WriteLineIf(Switches.CompChange.TraceVerbose, "Component Renamed: " + cre.OldName + " -> " + cre.NewName);

            ComponentRenameEventHandler ceh = (ComponentRenameEventHandler)eventTable[COMPONENT_RENAME_EVENT];
            if (ceh != null) {
                ceh.Invoke(this, cre);
            }
        }

        /// <devdoc>
        ///      Allows notification for a name change of the root component
        /// </devdoc>
        internal void OnRootComponentRename(string oldName, string newName) {
            
            // BUGBUG (SBurke, BrianPe): we got the fully qualified name of the base
            // component from EndLoad, and now we need to update that.  There is no
            // way for us to re-fetch this name, so we'll have to use search & replace
            // to try and do it that way.  It's not very robust, but it'll have to do
            // for this version.
            //
            int oldNameIndex = this.baseComponentClass.LastIndexOf(oldName);
            if (oldNameIndex != -1) {
                this.baseComponentClass = baseComponentClass.Substring(0, oldNameIndex) + newName;
            }

            DesignSite ds = sites[oldName] as DesignSite; 

            sites.Remove(oldName);
            sites[newName] = ds;
                
            OnComponentRename(new ComponentRenameEventArgs(this.RootComponent, oldName, newName));
        }

        private void OnTransactionOpened(EventArgs e) {
            EventHandler handler = (EventHandler)eventTable[TRANSACTION_OPENED_EVENT];
            if (handler != null) handler(this, e);
        }
        
        private void OnTransactionOpening(EventArgs e) {
            EventHandler handler = (EventHandler)eventTable[TRANSACTION_OPENING_EVENT];
            if (handler != null) handler(this, e);
        }

        private void OnTransactionClosed(DesignerTransactionCloseEventArgs e) {
            DesignerTransactionCloseEventHandler handler = (DesignerTransactionCloseEventHandler)eventTable[TRANSACTION_CLOSED_EVENT];
            if (handler != null) handler(this, e);
        }
        
        private void OnTransactionClosing(DesignerTransactionCloseEventArgs e) {
            DesignerTransactionCloseEventHandler handler = (DesignerTransactionCloseEventHandler)eventTable[TRANSACTION_CLOSING_EVENT];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.RegisterView"]/*' />
        /// <devdoc>
        ///     This tells the shell that another view cares about the underlying buffer
        ///     besides the text editor so we will be notified if it is changed outside the
        ///     shell.
        /// </devdoc>
        private void RegisterView(bool register) {
        
            if (viewRegistered != register) {
                IVsTextManager mgr = (IVsTextManager)GetService(typeof(VsTextManager));
                
                if (registeredBuffer == null || registeredView == null) {
                    IVsWindowFrame frame = (IVsWindowFrame)GetService(typeof(IVsWindowFrame));
                    if (frame != null) {
                        registeredBuffer = frame.GetProperty(__VSFPROPID.VSFPROPID_DocData) as IVsTextBuffer;
                        registeredView = frame.GetProperty(__VSFPROPID.VSFPROPID_DocView);
                    }
                }
                
                if (mgr != null && registeredBuffer != null && registeredView != null) {
                    try {
                        if (register) {
                            mgr.RegisterIndependentView(registeredView, registeredBuffer);
                        }
                        else {
                            mgr.UnregisterIndependentView(registeredView, registeredBuffer);
                            registeredBuffer = null;
                            registeredView = null;
                        }
                        viewRegistered = register;
                    }
                    catch {
                        // just eat any exception...we'll work okay if this fails
                    }
                }
            }
        }
       
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.Remove"]/*' />
        /// <devdoc>
        ///     Called to remove a component from its container.
        /// </devdoc>
        public void Remove(IComponent component) {

            // Bail early if this component hasn't been added to us.
            //
            if (component == null) return;
            ISite site = component.Site;
            if (!sites.ContainsValue(site)) return;
            if (site == null || site.Container != this) return;
            if (!(site is DesignSite)) return;

            ComponentEventArgs ce = new ComponentEventArgs(component);

            try {
                OnComponentRemoving(ce);
            }
            catch(CheckoutException ex){
                if (ex == CheckoutException.Canceled) {
                    return;
                }
                throw;
            }
            

            // remove the component from the formcore and the code buffer
            //
            DesignSite csite = (DesignSite)site;
            if (csite.Component != baseComponent) {
                if (component is IExtenderProvider) {
                    RemoveExtenderProvider((IExtenderProvider)component);
                }
            }

            // and remove it's designer, should one exist.  If we are
            // unloading the document we don't do this, however, because
            // during unload we always destroy designers first, and then
            // go ahead an destroy their compnents.  This preserves the
            // order properly:  component gets created w/o designer, then
            // gets designer.  Designer initializes after component
            // initializes.  At teardown we want the reverse: designer
            // gets destroyed first, then component.  So we must
            // check a flag during Remove.
            //
            if (!unloadingDesigner) {
                IDesigner designer = (IDesigner)designerTable[component];
                if (designer != null) {
                    designer.Dispose();
                }
            }

            designerTable.Remove(component);

            sites.Remove(csite.Name);
            if (components != null) {
                components.Remove(site);
            }

            // By this time, the component is dead.  If some bonehead
            // thew, there's nothing we can do about it.
            //
            try {
                OnComponentRemoved(ce);
            }
            catch (Exception) {
            }

            // Finally, rip the site instance.
            //
            component.Site = null;
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.RemoveExtenderProvider"]/*' />
        /// <devdoc>
        ///      Allows someone who is not a component to remove a previously
        ///      added extender provider.
        /// </devdoc>
        public void RemoveExtenderProvider(IExtenderProvider provider) {
            if (extenderProviders != null)
                extenderProviders.Remove(provider);
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.UnloadDocument"]/*' />
        /// <devdoc>
        ///     This is called durning Dispose and Reload methods to unload the current designer.
        /// </devdoc>
        private void UnloadDocument() {

            // Clear out the task list.  We use this during loading to report errors.
            //
            if (taskProvider != null) {
                taskProvider.Tasks.Clear();
            }
            
            if (helpService != null && baseDesigner != null) {
                helpService.RemoveContextAttribute("Keyword", "Designer_" + baseDesigner.GetType().FullName);
            }
            
            // Note: Because this can be called during Dispose, we are very careful here
            // about checking for null references.

            // If we can get a selection service, clear the selection...
            // we don't want the properties window browsing disposed components...
            // or components who's designer has been destroyed.
            ISelectionService selectionService = (ISelectionService)GetService(typeof(ISelectionService));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || selectionService != null, "ISelectionService not found");
            if (selectionService != null) {
                selectionService.SetSelectedComponents(null);
            }

            // Stash off the base designer and component.  We are
            // going to be destroying these and we don't want them
            // to be accidently referenced after they're dead.
            //
            IDesigner baseDesignerHolder = baseDesigner;
            IComponent baseComponentHolder = baseComponent;

            baseDesigner = null;
            baseComponent = null;
            baseComponentClass = null;

            DesignSite[] siteArray = new DesignSite[sites.Values.Count];
            sites.Values.CopyTo(siteArray, 0);

            // Destroy all designers.  We save the base designer for last.
            //
            IDesigner[] designers = new IDesigner[designerTable.Values.Count];
            designerTable.Values.CopyTo(designers, 0);

            // We create a transaction here to limit the effects of making
            // so many changes.
            //
            unloadingDesigner = true;
            DesignerTransaction trans = CreateTransaction();
            
            try {
                for (int i = 0; i < designers.Length; i++) {
                    if (designers[i] != baseDesignerHolder) {
                        IComponent comp = designers[i].Component;
                        try {
                            designers[i].Dispose();
                        }
                        catch {
                            Debug.Fail("Designer " + designers[i].GetType().Name + " threw an exception during Dispose.");
                        }
                        designerTable.Remove(comp);
                    }
                }
    
                // Now destroy all components.
                //
                for (int i = 0; i < siteArray.Length; i++) {
                    DesignSite site = siteArray[i];
                    IComponent comp = site.Component;
                    if (comp != null && comp != baseComponentHolder) {
                        try {
                            comp.Dispose();
                        }
                        catch {
                            Debug.Fail("Component " + site.Name + " threw during dispose.  Bad component!!");
                        }
                        if (comp.Site != null) {
                            Debug.Fail("Component " + site.Name + " did not remove itself from its container");
                            Remove(comp);
                        }
                    }
                }
    
                // Finally, do the base designer and component.
                //
                if (baseDesignerHolder != null) {
                    try {
                        baseDesignerHolder.Dispose();
                    }
                    catch {
                        Debug.Fail("Designer " + baseDesignerHolder.GetType().Name + " threw an exception during Dispose.");
                    }
                }
    
                if (baseComponentHolder != null) {
                    try {
                        baseComponentHolder.Dispose();
                    }
                    catch {
                        Debug.Fail("Component " + baseComponentHolder.GetType().Name + " threw during dispose.  Bad component!!");
                    }
                    
                    if (baseComponentHolder.Site != null) {
                        Debug.Fail("Component " + baseComponentHolder.Site.Name + " did not remove itself from its container");
                        Remove(baseComponentHolder);
                    }
                }
            
                designerTable.Clear();
                sites.Clear();
                if (components != null) {
                    components.Clear();
                }

                if (referenceService != null) {
                    referenceService.Clear();
                }
            }
            finally {
                unloadingDesigner = false;
                trans.Commit();
            }
            
            // And clear the document window
            //
            if (documentWindow != null) {
                documentWindow.SetDesigner(null);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IDesignerLoaderHost.Reload"]/*' />
        /// <devdoc>
        ///     This is called by the designer loader when it wishes to reload the
        ///     design document.  The reload may happen immediately or it may be deferred
        ///     until idle time.  The designer loader should unload itself before calling
        ///     this method, to reset its state to that before BeginLoad was originally
        ///     called.
        /// </devdoc>
        void IDesignerLoaderHost.Reload() {
        
            // If the code stream has been destroyed already, then there
            // is no need to reload
            //
            if (designerLoader == null || documentWindow == null) {
                return;
            }
            
            // Before reloading, fush any changes!
            //
            designerLoader.Flush();
            
            Cursor oldCursor = Cursor.Current;
            Cursor.Current = Cursors.WaitCursor;

            bool unfreeze = false;
            
            ICollection selectedObjects = null;
            ArrayList selectedNames = null;
            
            ISelectionService selectionService = (ISelectionService)GetService(typeof(ISelectionService));
            if (selectionService != null) {
                selectedObjects = selectionService.GetSelectedComponents();
                selectedNames = new ArrayList();
                
                foreach(object comp in selectedObjects) {
                    if (comp is IComponent && ((IComponent)comp).Site != null) {
                        selectedNames.Add(((IComponent)comp).Site.Name);
                    }
                }
            }
            
            try {
                documentWindow.FreezePainting = true;
                unfreeze = true;
                
                UnloadDocument();
                Load(true);
            }
            finally {
            
                if (selectionService != null) {
                
                    ArrayList selection = new ArrayList();
                    foreach(string name in selectedNames) {
                        if (name != null) {
                            IComponent comp = this.Components[name];
                            if (comp != null) {
                                selection.Add(comp);
                            }
                        }
                    }
                    
                    selectionService.SetSelectedComponents(selection);
                }
                
                if (unfreeze) {
                    documentWindow.FreezePainting = false;
                }
                Cursor.Current = oldCursor;
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IDesignerLoaderHost.EndLoad"]/*' />
        /// <devdoc>
        ///     This is called by the designer loader to indicate that the load has 
        ///     terminated.  If there were errors, they should be passed in the errorCollection
        ///     as a collection of exceptions (if they are not exceptions the designer
        ///     loader host may just call ToString on them).  If the load was successful then
        ///     errorCollection should either be null or contain an empty collection.
        /// </devdoc>
        void IDesignerLoaderHost.EndLoad(string baseClassName, bool successful, ICollection errorCollection) {

            bool wasReload = reloading;
            bool wasLoading = loadingDesigner;

            // Set our state back to the starting point.
            //
            this.loadingDesigner = false;
            this.reloading = false;
            
            if (baseClassName != null) {
                this.baseComponentClass = baseClassName;
            }
            
            // If we had errors, report them.
            //
            if (successful && baseComponent == null) {
                ArrayList errorList = new ArrayList();
                errorList.Add(new Exception(SR.GetString(SR.CODEMANNoBaseClass)));
                errorCollection = errorList;
                successful = false;
            }
                        
            if (!successful) {
            
                // The document is partially loaded.  Unload it here.
                //
                try {
                    UnloadDocument();
                }
                catch (Exception ex) {
                    Debug.Fail("Failed to unload after a...failed load.", ex.ToString());
                }

                if (errorCollection != null) {
                    foreach(object errorObj in errorCollection) {
                        if (errorObj is Exception) {
                            loadError = (Exception)errorObj;
                        }
                        else {
                            loadError = new Exception(errorObj.ToString());
                        }
                        break;
                    }
                }
                else {
                    loadError = new Exception(SR.GetString(SR.CODEMANUnknownLoadError));
                }
                
                // If we have a help service, and if the load error contains a help link,
                // introduce these two.
                //
                string helpLink = loadError.HelpLink;
                
                if (helpService != null && helpLink != null && helpLink.Length > 0) {
                    helpService.AddContextAttribute("Keyword", helpLink, HelpKeywordType.F1Keyword);
                }
                
                documentWindow.ReportErrors(errorCollection);
                ((IErrorReporting)this).ReportErrors(errorCollection);
            }
            else {

                ((IErrorReporting)this).ReportErrors(errorCollection);
            
                // We may be invoked to do an EndLoad when we are already loaded.  This can happen
                // if the user called AddLoadDependency, essentially putting us in a loading state
                // while we are already loaded.  This is OK, and is used as a hint that the user
                // is going to monkey with settings but doesn't want the code engine to report
                // it.
                //
                if (wasLoading) {
                
                    // Offer up our base help attribute
                    //
                    if (helpService != null && baseDesigner != null) {
                        helpService.AddContextAttribute("Keyword", "Designer_" + baseDesigner.GetType().FullName, HelpKeywordType.F1Keyword);
                    }
        
                    // and let everyone know that we're loaded
                    //
                    EventHandler handler = (EventHandler)eventTable[CODE_LOADED_EVENT];
                    if (handler != null) {
                        handler.Invoke(this, EventArgs.Empty);
                    }
        
                    DocumentManager dm = (DocumentManager)GetService(typeof(DocumentManager));
                    if (dm != null) {
                        dm.OnDesignerCreated(new DesignerEventArgs(this)); 
                    }
                
                    documentWindow.DocumentVisible = true;
                }
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IDesignerDocument.View"]/*' />
        /// <devdoc>
        ///     The view for this document.  The designer
        ///     should assume that the view will be shown shortly
        ///     after this call is made and make any necessary
        ///     preparations.
        /// </devdoc>
        Control IDesignerDocument.View {
            get {
                return documentWindow.GetComPlusView();
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IDesignerDocument.Flush"]/*' />
        /// <devdoc>
        ///     Called to flush any changes in this document to disk.
        /// </devdoc>
        void IDesignerDocument.Flush() {
            if (designerLoader != null) {
                designerLoader.Flush();
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.NativeMethods.IObjectWithSite.SetSite"]/*' />
        /// <devdoc>
        ///     Called by the document view when it gets sited.  In Visual Studio, the
        ///     document's site object may contain services that are only relevant
        ///     to the document.  Here we check to see if the document service
        ///     provider supports a site.  If it does, we hand it off.  We always
        ///     resolve all services through the document service provider, so this way
        ///     any custom services on the document's site will be available.
        /// </devdoc>
        void NativeMethods.IObjectWithSite.SetSite(object site) {
            NativeMethods.IObjectWithSite ows = (NativeMethods.IObjectWithSite)GetService(typeof(NativeMethods.IObjectWithSite));
            if (ows != null) {
                ows.SetSite(site);
            }
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name and DescriptorInfo which describes the signature
        /// of the method. 
        /// </devdoc>
        ///
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers) {
            return Reflector.GetMethod(name, bindingAttr, binder, types, modifiers);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod1"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name of the method.  If the object implementes multiple methods
        /// with the same name an AmbiguousMatchException is thrown.
        /// </devdoc>
        ///
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr) {
            return Reflector.GetMethod(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethods"]/*' />
        MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
            return Reflector.GetMethods(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetField"]/*' />
        /// <devdoc>
        /// Return the requestion field if it is implemented by the Reflection object.  The
        /// match is based upon a name.  There cannot be more than a single field with
        /// a name.
        /// </devdoc>
        ///
        FieldInfo IReflect.GetField(string name, BindingFlags bindingAttr) {
            return Reflector.GetField(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetFields"]/*' />
        FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
            return Reflector.GetFields(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty"]/*' />
        /// <devdoc>
        /// Return the property based upon name.  If more than one property has the given
        /// name an AmbiguousMatchException will be thrown.  Returns null if no property
        /// is found.
        /// </devdoc>
        ///
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr) {
            return Reflector.GetProperty(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty1"]/*' />
        /// <devdoc>
        /// Return the property based upon the name and Descriptor info describing the property
        /// indexing.  Return null if no property is found.
        /// </devdoc>
        ///     
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
            return Reflector.GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperties"]/*' />
        /// <devdoc>
        /// Returns an array of PropertyInfos for all the properties defined on 
        /// the Reflection object.
        /// </devdoc>
        ///     
        PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
            return Reflector.GetProperties(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMember"]/*' />
        /// <devdoc>
        /// Return an array of members which match the passed in name.
        /// </devdoc>
        ///     
        MemberInfo[] IReflect.GetMember(string name, BindingFlags bindingAttr) {
            return Reflector.GetMember(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMembers"]/*' />
        /// <devdoc>
        /// Return an array of all of the members defined for this object.
        /// </devdoc>
        ///
        MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
            return Reflector.GetMembers(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.InvokeMember"]/*' />
        /// <devdoc>
        /// Description of the Binding Process.
        /// We must invoke a method that is accessable and for which the provided
        /// parameters have the most specific match.  A method may be called if
        /// 1. The number of parameters in the method declaration equals the number of 
        /// arguments provided to the invocation
        /// 2. The type of each argument can be converted by the binder to the
        /// type of the type of the parameter.
        /// 
        /// The binder will find all of the matching methods.  These method are found based
        /// upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
        /// of methods is filtered by the name, number of arguments and a set of search modifiers
        /// defined in the Binder.
        /// 
        /// After the method is selected, it will be invoked.  Accessability is checked
        /// at that point.  The search may be control which set of methods are searched based
        /// upon the accessibility attribute associated with the method.
        /// 
        /// The BindToMethod method is responsible for selecting the method to be invoked.
        /// For the default binder, the most specific method will be selected.
        /// 
        /// This will invoke a specific member...
        /// @exception If <var>invokeAttr</var> is CreateInstance then all other
        /// Access types must be undefined.  If not we throw an ArgumentException.
        /// @exception If the <var>invokeAttr</var> is not CreateInstance then an
        /// ArgumentException when <var>name</var> is null.
        /// @exception ArgumentException when <var>invokeAttr</var> does not specify the type
        /// @exception ArgumentException when <var>invokeAttr</var> specifies both get and set of
        /// a property or field.
        /// @exception ArgumentException when <var>invokeAttr</var> specifies property set and
        /// invoke method.
        /// </devdoc>
        ///  
        object IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters) {
            return Reflector.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.UnderlyingSystemType"]/*' />
        /// <devdoc>
        /// Return the underlying Type that represents the IReflect Object.  For expando object,
        /// this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        /// </devdoc>
        ///
        Type IReflect.UnderlyingSystemType {
            get {
                return Reflector.UnderlyingSystemType;
            }
        }  

        void IErrorReporting.ReportErrors(ICollection errorCollection) {
        
            // Clear out any existing errors.
            //
            if (taskProvider != null) {
                taskProvider.Tasks.Clear();
            }
        
            // If our error collection isn't empty, then add them to the
            // task list
            //
            if (errorCollection != null && errorCollection.Count > 0) {
                if (taskProvider == null) {
                    taskProvider = new VsTaskProvider(this);
                    taskImages = new ImageList();
                    taskImages.TransparentColor = Color.Red;
                    taskImages.Images.Add(new Bitmap(typeof(DesignerHost), "DesignerGlyph.bmp"));
                    taskProvider.ImageList = taskImages;
                }

                // Show the window.
                IUIService uis = (IUIService)GetService(typeof(IUIService));
                if (uis != null) {
                    uis.ShowToolWindow(StandardToolWindows.TaskList);
                }
                
                foreach(object error in errorCollection) {
                    string s = null;
                    string helpKeyword = string.Empty;
                    string file = string.Empty;
                    int line = 0;
                    
                    if (error is Exception) {
                        s = ((Exception)error).Message;
                        helpKeyword = ((Exception)error).HelpLink;
                    }
                    
                    if (error is CodeDomSerializerException) {
                        CodeLinePragma lp = ((CodeDomSerializerException)error).LinePragma;
                        if (lp != null) {
                            file = lp.FileName;
                            line = lp.LineNumber;
                        }
                    }
                    
                    if (s == null || s.Length == 0) {
                        s = error.ToString();
                    }
                    
                    VsTaskItem task = taskProvider.Tasks.Add(s, file, line, 0, line, 0);
                    task.Category = _vstaskcategory.CAT_BUILDCOMPILE;
                    task.HelpKeyword = helpKeyword;
                    task.ImageListIndex = 0;
                    taskProvider.Filter(_vstaskcategory.CAT_BUILDCOMPILE);
                }
                
                taskProvider.Refresh();
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IServiceContainer.AddService"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance) {
            Debug.Assert(serviceContainer != null, "We have no sevice container.  Either the host has not been initialized yet or it has been disposed.");
            if (serviceContainer != null) {
                serviceContainer.AddService(serviceType, serviceInstance);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IServiceContainer.AddService1"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance, bool promote) {
            Debug.Assert(serviceContainer != null, "We have no sevice container.  Either the host has not been initialized yet or it has been disposed.");
            if (serviceContainer != null) {
                serviceContainer.AddService(serviceType, serviceInstance, promote);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IServiceContainer.AddService2"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback) {
            Debug.Assert(serviceContainer != null, "We have no sevice container.  Either the host has not been initialized yet or it has been disposed.");
            if (serviceContainer != null) {
                serviceContainer.AddService(serviceType, callback);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IServiceContainer.AddService3"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback, bool promote) {
            Debug.Assert(serviceContainer != null, "We have no sevice container.  Either the host has not been initialized yet or it has been disposed.");
            if (serviceContainer != null) {
                serviceContainer.AddService(serviceType, callback, promote);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IServiceContainer.RemoveService"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType) {
            if (serviceContainer != null) {
                serviceContainer.RemoveService(serviceType);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IServiceContainer.RemoveService1"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType, bool promote) {
            if (serviceContainer != null) {
                serviceContainer.RemoveService(serviceType, promote);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IVSMDDesigner.CommandGuid"]/*' />
        /// <devdoc>
        ///      Retrieves the command UI guid that is used for keybindings.
        /// </devdoc>
        Guid IVSMDDesigner.CommandGuid {
            get {
                return typeof(Microsoft.VisualStudio.Designer.Shell.DesignerPackage).GUID;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IVSMDDesigner.SelectionContainer"]/*' />
        /// <devdoc>
        ///     Retrieves the selection container for this document.  This is used by the shell
        ///     and other hosting interfaces to push an appropriate selection context.
        /// </devdoc>
        object IVSMDDesigner.SelectionContainer {
            get {
                return selectionService;
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IVSMDDesigner.View"]/*' />
        /// <devdoc>
        ///     Retrieves the Win32 window handle that will contain the design-time view for this
        ///     document.
        /// </devdoc>
        object IVSMDDesigner.View {
            get {
                try {
                    return documentWindow.GetComView();
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                    throw;
                }
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IVSMDDesigner.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of the DesignContainer.  This cleans up any objects we may be holding
        ///     and removes any services that we created.
        /// </devdoc>
        void IVSMDDesigner.Dispose() {
            Dispose();
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IVSMDDesigner.Flush"]/*' />
        /// <devdoc>
        ///     Reloads the contents of this document.
        /// </devdoc>
        void IVSMDDesigner.Flush() {
            if (designerLoader != null) {
                designerLoader.Flush();
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.IVSMDDesigner.GetLoadError"]/*' />
        /// <devdoc>
        ///     Loads the form from the code stream we've been provided.  This will throw
        ///     a meaningful exception if it was unable to load the code.
        /// </devdoc>
        void IVSMDDesigner.GetLoadError() {
            // Loading happens instantly.  Check for a load error, and if we got one,
            // return it.
            if (loadError != null) {
                throw new Exception(loadError.Message, loadError);
            }
        }
        
        internal class DesignerComponentCollection : ComponentCollection, IReflect {
            private DesignerHost host;
            private InterfaceReflector interfaceReflector;

            internal DesignerComponentCollection(DesignerHost host) : base(new IComponent[0]) {
                this.host = host;
                
                // Initially fill the list with site data.  After the initial fill it is up to
                // those who modify the sites hash to update us.
                //
                if (host.sites != null) {
                    foreach(ISite site in host.sites.Values) {
                        InnerList.Add(site.Component);
                    }
                }
            }

            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.DesignerComponentCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the component corresponding to the given name.
            /// </devdoc>
            public override IComponent this[string name] {
                get {
                    Debug.Assert(name != null, "name is null");
                    if (name == null) {
                        return null;
                    }

                    if (name.Length == 0) {
                        Debug.Assert(host.RootComponent != null, "base component is null");
                        return host.RootComponent;
                    }
                    
                    ISite site = (ISite)host.sites[name];
                    return (site == null) ? null : site.Component;
                }
            }
            
            /// <devdoc>
            ///     Returns the IReflect object we will use for reflection.
            /// </devdoc>
            private InterfaceReflector Reflector {
                get {
                    if (interfaceReflector == null) {
                        interfaceReflector = new InterfaceReflector(
                            typeof(ComponentCollection), new Type[] {
                                typeof(ComponentCollection)
                            }
                        );
                    }
                    return interfaceReflector;
                }
            }
            
            internal void Add(ISite site) {
                InnerList.Add(site.Component);
            }
            
            internal void Clear() {
                InnerList.Clear();
            }
            
            internal void Remove(ISite site) {
                InnerList.Remove(site.Component);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod"]/*' />
            /// <devdoc>
            /// Return the requested method if it is implemented by the Reflection object.  The
            /// match is based upon the name and DescriptorInfo which describes the signature
            /// of the method. 
            /// </devdoc>
            ///
            MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers) {
                return Reflector.GetMethod(name, bindingAttr, binder, types, modifiers);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod1"]/*' />
            /// <devdoc>
            /// Return the requested method if it is implemented by the Reflection object.  The
            /// match is based upon the name of the method.  If the object implementes multiple methods
            /// with the same name an AmbiguousMatchException is thrown.
            /// </devdoc>
            ///
            MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr) {
                return Reflector.GetMethod(name, bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethods"]/*' />
            MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
                return Reflector.GetMethods(bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetField"]/*' />
            /// <devdoc>
            /// Return the requestion field if it is implemented by the Reflection object.  The
            /// match is based upon a name.  There cannot be more than a single field with
            /// a name.
            /// </devdoc>
            ///
            FieldInfo IReflect.GetField(string name, BindingFlags bindingAttr) {
                return Reflector.GetField(name, bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetFields"]/*' />
            FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
                return Reflector.GetFields(bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty"]/*' />
            /// <devdoc>
            /// Return the property based upon name.  If more than one property has the given
            /// name an AmbiguousMatchException will be thrown.  Returns null if no property
            /// is found.
            /// </devdoc>
            ///
            PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr) {
                return Reflector.GetProperty(name, bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty1"]/*' />
            /// <devdoc>
            /// Return the property based upon the name and Descriptor info describing the property
            /// indexing.  Return null if no property is found.
            /// </devdoc>
            ///     
            PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
                return Reflector.GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperties"]/*' />
            /// <devdoc>
            /// Returns an array of PropertyInfos for all the properties defined on 
            /// the Reflection object.
            /// </devdoc>
            ///     
            PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
                return Reflector.GetProperties(bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMember"]/*' />
            /// <devdoc>
            /// Return an array of members which match the passed in name.
            /// </devdoc>
            ///     
            MemberInfo[] IReflect.GetMember(string name, BindingFlags bindingAttr) {
                return Reflector.GetMember(name, bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMembers"]/*' />
            /// <devdoc>
            /// Return an array of all of the members defined for this object.
            /// </devdoc>
            ///
            MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
                return Reflector.GetMembers(bindingAttr);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.InvokeMember"]/*' />
            /// <devdoc>
            /// Description of the Binding Process.
            /// We must invoke a method that is accessable and for which the provided
            /// parameters have the most specific match.  A method may be called if
            /// 1. The number of parameters in the method declaration equals the number of 
            /// arguments provided to the invocation
            /// 2. The type of each argument can be converted by the binder to the
            /// type of the type of the parameter.
            /// 
            /// The binder will find all of the matching methods.  These method are found based
            /// upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
            /// of methods is filtered by the name, number of arguments and a set of search modifiers
            /// defined in the Binder.
            /// 
            /// After the method is selected, it will be invoked.  Accessability is checked
            /// at that point.  The search may be control which set of methods are searched based
            /// upon the accessibility attribute associated with the method.
            /// 
            /// The BindToMethod method is responsible for selecting the method to be invoked.
            /// For the default binder, the most specific method will be selected.
            /// 
            /// This will invoke a specific member...
            /// @exception If <var>invokeAttr</var> is CreateInstance then all other
            /// Access types must be undefined.  If not we throw an ArgumentException.
            /// @exception If the <var>invokeAttr</var> is not CreateInstance then an
            /// ArgumentException when <var>name</var> is null.
            /// @exception ArgumentException when <var>invokeAttr</var> does not specify the type
            /// @exception ArgumentException when <var>invokeAttr</var> specifies both get and set of
            /// a property or field.
            /// @exception ArgumentException when <var>invokeAttr</var> specifies property set and
            /// invoke method.
            /// </devdoc>
            ///  
            object IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters) {
                return Reflector.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
            }
            
            /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.UnderlyingSystemType"]/*' />
            /// <devdoc>
            /// Return the underlying Type that represents the IReflect Object.  For expando object,
            /// this is the (Object) IReflectInstance.GetType().  For Type object it is this.
            /// </devdoc>
            ///
            Type IReflect.UnderlyingSystemType {
                get {
                    return Reflector.UnderlyingSystemType;
                }
            }  
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostDesignerTransaction"]/*' />
        /// <devdoc>
        ///     Our designer transaction object.
        /// </devdoc>
        private class HostDesignerTransaction : DesignerTransaction {
            private DesignerHost host;
            
            public HostDesignerTransaction(DesignerHost host, string description) : base(description) {
                this.host = host;
                
                if (host.transactionDescriptions == null) {
                    host.transactionDescriptions = new StringStack();
                }
                host.transactionDescriptions.Push(description);
    
                if (host.transactionCount++ == 0) {
                    host.OnTransactionOpening(EventArgs.Empty);
                    host.OnTransactionOpened(EventArgs.Empty);
                }
            }
            
            protected override void OnCancel() {
                if (host != null) {
                    Debug.Assert(host.transactionDescriptions != null, "End batch operation with no desription?!?");
                    string s =  (string)host.transactionDescriptions.Pop();
                    if (--host.transactionCount == 0) {
                        DesignerTransactionCloseEventArgs dtc = new DesignerTransactionCloseEventArgs(false);
                        host.OnTransactionClosing(dtc);
                        host.OnTransactionClosed(dtc);
                    }
                    host = null;
                }
            }
            
            protected override void OnCommit() {
                if (host != null) {
                    Debug.Assert(host.transactionDescriptions != null, "End batch operation with no desription?!?");
                    string s =  (string)host.transactionDescriptions.Pop();
                    if (--host.transactionCount == 0) {
                        DesignerTransactionCloseEventArgs dtc = new DesignerTransactionCloseEventArgs(true);
                        host.OnTransactionClosing(dtc);
                        host.OnTransactionClosed(dtc);
                    }
                    host = null;
                }
            }
        }
        
        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostExtenderProvider"]/*' />
        /// <devdoc>
        ///      This is the base extender provider for the designer host.  It provides
        ///      the "Name" property.
        /// </devdoc>
        [
        ProvideProperty("Name", typeof(IComponent))
        ]
        private class HostExtenderProvider : IExtenderProvider {

            private static Attribute[] designerNameAttribute = new Attribute[] {new DesignerNameAttribute(true)};

            private DesignerHost host;

            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostExtenderProvider.HostExtenderProvider"]/*' />
            /// <devdoc>
            ///      Creates a new HostExtenderProvider.
            /// </devdoc>
            public HostExtenderProvider(DesignerHost host) {
                this.host = host;
            }

            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostExtenderProvider.Host"]/*' />
            /// <devdoc>
            ///      Retrieves the host we are connected to.
            /// </devdoc>
            protected DesignerHost Host {
                get {
                    return host;
                }
            }

            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostExtenderProvider.CanExtend"]/*' />
            /// <devdoc>
            ///     Determines if ths extender provider can extend the given object.  We extend
            ///     all objects, so we always return true.
            /// </devdoc>
            public virtual bool CanExtend(object o) {

                // We don't add name or modifiers to the base component.
                //
                if (o == Host.baseComponent) {
                    return false;
                }

                // Now see if this object is inherited.  If so, then we don't want to
                // extend.
                //
                if (!TypeDescriptor.GetAttributes(o)[typeof(InheritanceAttribute)].Equals(InheritanceAttribute.NotInherited)) {
                    return false;
                }

                return true;
            }

            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostExtenderProvider.GetName"]/*' />
            /// <devdoc>
            ///     This is an extender property that we offer to all components
            ///     on the form.  It implements the "Name" property.
            /// </devdoc>
            [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DesignerName(true),
            ParenthesizePropertyName(true),
            MergableProperty(false),
            VSSysDescriptionAttribute(SR.ShadowPropName),
            VSCategory("Design")
            ]
            public virtual string GetName(IComponent comp) {
                ISite site = comp.Site;
                if (site != null) {
                    return site.Name;
                }
                return null;
            }
            
            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostExtenderProvider.SetName"]/*' />
            /// <devdoc>
            ///     This is an extender property that we offer to all components
            ///     on the form.  It implements the "Name" property.
            /// </devdoc>
            public void SetName(IComponent comp, string newName) {

                // trim any spaces off of the name
                newName = newName.Trim();

                DesignSite cs = (DesignSite) comp.Site;
                if (newName.Equals(cs.Name)) return;

                // allow a rename with just casing changes - no need to checkname
                //
                if (string.Compare(newName, cs.Name, true, CultureInfo.InvariantCulture) != 0) {
                    Host.CheckName(newName);
                }
                Host.OnComponentChanging(comp, TypeDescriptor.GetProperties(comp, designerNameAttribute)["Name"]);

                Host.sites.Remove(cs.Name);
                Host.sites[newName] = cs;

                string oldName = cs.Name;
                cs.SetName(newName);

                Host.OnComponentRename(new ComponentRenameEventArgs(comp, oldName, newName));
                Host.OnComponentChanged(comp, TypeDescriptor.GetProperties(comp, designerNameAttribute)["Name"], oldName, newName);
            }
        }

        /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostInheritedExtenderProvider"]/*' />
        /// <devdoc>
        ///      This extender provider offers up read-only versions of "Name" property
        ///      for inherited components.
        /// </devdoc>
        private class HostInheritedExtenderProvider : HostExtenderProvider {

            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostInheritedExtenderProvider.HostInheritedExtenderProvider"]/*' />
            /// <devdoc>
            ///      Creates a new HostInheritedExtenderProvider.
            /// </devdoc>
            public HostInheritedExtenderProvider(DesignerHost host) : base(host) {
            }

            /// <include file='doc\DesignerHost.uex' path='docs/doc[@for="DesignerHost.HostInheritedExtenderProvider.CanExtend"]/*' />
            /// <devdoc>
            ///     Determines if ths extender provider can extend the given object.  We extend
            ///     all objects, so we always return true.
            /// </devdoc>
            public override bool CanExtend(object o) {
                // We don't add name or modifiers to the base component.
                //
                if (o == Host.baseComponent) {
                    return false;
                }

                // Now see if this object is inherited.  If so, then we are interested in it.
                //
                if (!TypeDescriptor.GetAttributes(o)[typeof(InheritanceAttribute)].Equals(InheritanceAttribute.NotInherited)) {
                    return true;
                }

                return false;
            }

            [ReadOnly(true)]
            public override string GetName(IComponent comp) {
                return base.GetName(comp);
            }
        }
    }

    internal class StringStack : Stack {
        internal StringStack() {
        }

        internal string GetNonNull() {
            int items = this.Count;
            object item;
            object[] itemArr = this.ToArray();
            for (int i = items - 1; i >=0; i--) {
                item = itemArr[i];
                if (item != null && item is string && ((string)item).Length > 0) {
                    return(string)item;
                }
            }
            return "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\typeloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="TypeLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {
    using System;
    using System.ComponentModel.Design;
    using System.Reflection;

    /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader"]/*' />
    /// <devdoc>
    ///      This class defines a type loader. A type loader is responsible
    ///      for loading types from some location.  In a development environment,
    ///      this type loader loads from the project references.
    /// </devdoc>
    internal abstract class TypeLoader : ITypeResolutionService {
        private AssemblyObsoleteEventHandler assemblyObsoleteHandler;

        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.AssemblyObsolete"]/*' />
        /// <devdoc>
        ///     Adds an event handler that will be called when an assembly
        ///     becomes obsolete.
        /// </devdoc>
        public event AssemblyObsoleteEventHandler AssemblyObsolete {
            add {
                assemblyObsoleteHandler += value;
            }
            remove {
                assemblyObsoleteHandler -= value;
            }
        }
    
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.GetAssembly"]/*' />
        /// <devdoc>
        ///     Retrieves a type of the given name.  This searches all loaded references
        ///     and may demand-create generated assemblies when attempting to resolve the
        ///     type.
        /// </devdoc>
        public abstract Assembly GetAssembly(AssemblyName name, bool throwOnError);
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.GetType"]/*' />
        /// <devdoc>
        ///     Retrieves a type of the given name.  This searches all loaded references
        ///     and may demand-create generated assemblies when attempting to resolve the
        ///     type.
        /// </devdoc>
        public abstract Type GetType(string typeName, bool ignoreCase);
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.OnAssemblyObsolete"]/*' />
        /// <devdoc>
        ///     Raises the assembly obsolete event.
        /// </devdoc>
        protected void OnAssemblyObsolete(AssemblyObsoleteEventArgs args) {
            if (assemblyObsoleteHandler != null) {
                assemblyObsoleteHandler(this, args);
            }
        }
        
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.OnTypeChanged"]/*' />
        /// <devdoc>
        ///     This is called by an object when it has made changes to a class.
        ///     It is used to add a task list item informing the user that he/she must
        ///     rebuild the project for the changes to be seen.
        /// </devdoc>
        public abstract void OnTypeChanged(string typeName);

        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ReferenceAssembly"]/*' />
        /// <devdoc>
        ///     Called by the type resolution service to ensure that the
        ///     assembly is being referenced by the development environment.
        /// </devdoc>
        public abstract void ReferenceAssembly(AssemblyName a);
        

        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.GetPathOfAssembly"]/*' />
        /// <devdoc>
        ///       Returns the path to the file name from which the assembly was loaded.
        /// </devdoc>
        public abstract string GetPathOfAssembly(AssemblyName a);
        
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ITypeResolutionService.GetAssembly"]/*' />
        /// <devdoc>
        ///     Retrieves the requested assembly.
        /// </devdoc>    
        Assembly ITypeResolutionService.GetAssembly(AssemblyName name) {
            return GetAssembly(name, false);
        }
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ITypeResolutionService.GetAssembly1"]/*' />
        /// <devdoc>
        ///     Retrieves the requested assembly.
        /// </devdoc>    
        Assembly ITypeResolutionService.GetAssembly(AssemblyName name, bool throwOnError) {
            return GetAssembly(name, throwOnError);
        }
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ITypeResolutionService.GetType"]/*' />
        /// <devdoc>
        ///     Loads a type with the given name.
        /// </devdoc>
        Type ITypeResolutionService.GetType(string name) {
            return ((ITypeResolutionService)this).GetType(name, false, false);
        }
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ITypeResolutionService.GetType1"]/*' />
        /// <devdoc>
        ///     Loads a type with the given name.
        /// </devdoc>
        Type ITypeResolutionService.GetType(string name, bool throwOnError) {
            return ((ITypeResolutionService)this).GetType(name, throwOnError, false);
        }
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ITypeResolutionService.GetType2"]/*' />
        /// <devdoc>
        ///     Loads a type with the given name.
        /// </devdoc>
        Type ITypeResolutionService.GetType(string name, bool throwOnError, bool ignoreCase) {
            Type type = GetType(name, ignoreCase);
            if (type == null && throwOnError) {
                throw new TypeLoadException(SR.GetString(SR.DESIGNERLOADERTypeNotFound, name));
            }
            return type;
        }
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ITypeResolutionService.ReferenceAssembly"]/*' />
        /// <devdoc>
        ///     References the given assembly.  Once an assembly has
        ///     been referenced types may be loaded from it without
        ///     qualifying them with the assembly.
        /// </devdoc>
        void ITypeResolutionService.ReferenceAssembly(AssemblyName name) {
            ((TypeLoader)this).ReferenceAssembly(name);
        }
    
        /// <include file='doc\TypeLoader.uex' path='docs/doc[@for="TypeLoader.ITypeResolutionService.GetPathOfAssembly"]/*' />
        /// <devdoc>
        ///       Returns the path to the file name from which the assembly was loaded.
        /// </devdoc>
        string ITypeResolutionService.GetPathOfAssembly(AssemblyName name) {
            return ((TypeLoader)this).GetPathOfAssembly(name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\textbufferchangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBufferChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using System;

    /// <include file='doc\TextBufferChangedEventHandler.uex' path='docs/doc[@for="TextBufferChangedEventHandler"]/*' />
    /// <devdoc>
    ///     Handler that is raised when the text underlying the TextBuffer has changed.
    /// </devdoc>
    public delegate void TextBufferChangedEventHandler(object sender, TextBufferChangedEventArgs e);
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\basedesignerloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseDesignerLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Designer.Serialization {

    using EnvDTE;
    using Microsoft.VisualStudio;
    using Microsoft.VisualStudio.Configuration;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    
    using TextBuffer = Microsoft.VisualStudio.Designer.TextBuffer;
    using IExtenderProvider = System.ComponentModel.IExtenderProvider;
    
    /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader"]/*' />
    /// <devdoc>
    ///     DesignerLoader.  This class is responsible for loading a designer document.  
    ///     Where and how this load occurs is a private matter for the designer loader.
    ///     The designer loader will be handed to an IDesignerHost instance.  This instance, 
    ///     when it is ready to load the document, will call BeginLoad, passing an instance
    ///     of IDesignerLoaderHost.  The designer loader will load up the design surface
    ///     using the host interface, and call EndLoad on the interface when it is done.
    ///     The error collection passed into EndLoad should be empty or null to indicate a
    ///     successful load, or it should contain a collection of exceptions that 
    ///     describe the error.
    /// </devdoc>

    internal abstract class BaseDesignerLoader : 
        DesignerLoader, 
        IDesignerLoaderService, 
        IInitializeDesignerLoader,
        IVSMDDesignerLoader,
        IResourceService,
        INameCreationService,
        IVsRunningDocTableEvents,
        IVsRunningDocTableEvents2,
        IConfigurationService,
        ILicenseReaderWriterService {

        // Flags that we use
        //
        private static readonly int StateLoaded                   = BitVector32.CreateMask();
        private static readonly int StateBufferReady              = BitVector32.CreateMask(StateLoaded);
        private static readonly int StateLoadReady                = BitVector32.CreateMask(StateBufferReady);
        private static readonly int StateActiveDocument           = BitVector32.CreateMask(StateLoadReady);
        private static readonly int StateDeferredReload           = BitVector32.CreateMask(StateActiveDocument);
        private static readonly int StateReloadAtIdle             = BitVector32.CreateMask(StateDeferredReload);
        private static readonly int StateLoadFailed               = BitVector32.CreateMask(StateReloadAtIdle);
        private static readonly int StateRDTEventsAdvised         = BitVector32.CreateMask(StateLoadFailed);
        private static readonly int StateReloading                = BitVector32.CreateMask(StateRDTEventsAdvised);
        private static readonly int StateExternalChange           = BitVector32.CreateMask(StateReloading);
        private static readonly int StateAlwaysReload             = BitVector32.CreateMask(StateExternalChange);
        private static readonly int StateDirtyIfErrors            = BitVector32.CreateMask(StateAlwaysReload);
        private static readonly int StateFlushInProgress          = BitVector32.CreateMask(StateDirtyIfErrors);

        
        // Our own data.
        //
        private IDesignerLoaderHost         host;
        private int                         loadDependencyCount;
        private ArrayList                   errorList;
        private TypeLoader                  typeLoader;
        private ShellLicenseManager         licenseManager;
        private TextBuffer                  textBuffer;
        private BitVector32                 flags = new BitVector32();
        private string                      baseComponentClassName;
        private IServiceProvider            serviceProvider;
        private CodeLoader                  codeLoader;
        private VsCheckoutService           checkoutService;
        private IExtenderProvider           defaultModifiersProvider;

        // VS specific values.
        //
        private string                  baseEditorCaption;
        private IVsHierarchy            hierarchy;
        private int                     itemid;
        private IOleUndoManager         oleUndoManager;     // Doc data's undo manager.
        private object                  initialDocData;     // This is only valid until the first load completes
        private int                     rdtEventsCookie;    // Our RDT event sync
        private Hashtable               docDataHash;        // Hash of filename / DocDataHolder used for non-primary doc datas
        
        private static TraceSwitch traceLoader = new TraceSwitch("TraceLoader", "Trace designer loading / saving.");
        private const int WebProjectType = 1;
        private const string WebConfigName = "web.config";
        private int         supressReloadWithDocData = 0;  // we need this because we get a ReloadDocData notification when we first load a file.  
                                                                       // So we bump this value to ignore it when we get an on load completed
                        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.Hierarchy"]/*' />
        /// <devdoc>
        ///     Retrieves the VS hierarchy this loader was created with.  This may be null.
        /// </devdoc>
        protected IVsHierarchy Hierarchy {
            get {
                return hierarchy;
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.ItemId"]/*' />
        /// <devdoc>
        ///     Retrieves the VS Item ID this loader was created with.
        /// </devdoc>
        protected int ItemId {
            get {
                return itemid;
            }
        }

        public override bool Loading {
            get {
                return loadDependencyCount != 0;
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnTextBufferSetDirty"]/*' />
        /// <devdoc>
        ///     This enumerates every docDataHolder and sets it dirty.
        /// </devdoc>
        private void OnTextBufferSetDirty(object sender, EventArgs e) {
            if (docDataHash == null)
                return;
        
            foreach(DocDataHolder holder in docDataHash.Values) {
                holder.SetDirty();
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.AddDocDataHelpAttributes"]/*' />
        /// <devdoc>
        ///     This is called to get help attributes off of a VS
        ///     doc data.  The help information for language independent
        ///     features is stored here.
        /// </devdoc>
        private void AddDocDataHelpAttributes(object docData, IHelpService helpSvc) {
            
            // The stream that comes in must implement a certain subset of interfaces.
            // If not, then we bail out early.
            //
            if (!(docData is IVsTextBuffer) || !(docData is IVsTextLines)) {
                return;
            }
            
            IVsTextBuffer buffer = (IVsTextBuffer)docData;
            Guid languageGuid = Guid.Empty;
                    
            try {
                languageGuid = buffer.GetLanguageServiceID();
            }
            catch(Exception) {
                // Throwing here should never happen for VS, but we can't guarantee that other language providers
                // will implement...
            }
            
            if (languageGuid != Guid.Empty) {
            
                // Get the language context provider.  We have to mess with
                // a native service provider here because we only have a GUID.
                //
                IVsLanguageContextProvider langCtx = null;
                
                NativeMethods.IOleServiceProvider nativeProvider = (NativeMethods.IOleServiceProvider)GetService(typeof(NativeMethods.IOleServiceProvider));
                if (nativeProvider != null) {
                   Guid IID_IVsLanguageContextProvider = typeof(IVsLanguageContextProvider).GUID;
                    
                    IntPtr ppvObj = (IntPtr)0;
                    int hr = nativeProvider.QueryService(ref languageGuid, ref IID_IVsLanguageContextProvider, out ppvObj);
                    if (NativeMethods.Succeeded(hr) && ppvObj != (IntPtr)0) {
                        langCtx = (IVsLanguageContextProvider)Marshal.GetObjectForIUnknown(ppvObj);
                        Marshal.Release(ppvObj);
                    }
                }
                
                // Now ask the language context to fill in its help information.  We pluck this out of IVsUserContext
                // after the language context fills it.
                //
                if (langCtx != null) {
                    IVsMonitorUserContext muc = (IVsMonitorUserContext)GetService(typeof(IVsMonitorUserContext));
                    if (muc != null) {
                        IVsUserContext context = muc.CreateEmptyContext();
                        _TextSpan txt = new _TextSpan();
                        
                        if (NativeMethods.Succeeded(langCtx.UpdateLanguageContext(_LanguageContextHint.LCH_DEFAULT, (IVsTextLines)buffer, txt, context))) {
                            context.RemoveAttribute("keyword", null);
                            int count = context.CountAttributes(null, 0);
                            for (int i = 0; i < count; i++) {
                                string attrName;
                                string attrValue = context.GetAttribute(i, null, 0, out attrName);
                                helpSvc.AddContextAttribute(attrName, attrValue, HelpKeywordType.FilterKeyword);
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.AddExtenderProviders"]/*' />
        /// <devdoc>
        ///      This is called at the appropriate time to add any extra extender
        ///      providers into the designer host.  The loader itself will
        ///      be checked for IExtenderProvider and added automatically, but
        ///      this offers a way for the loader to add more providers.
        /// </devdoc>
        protected virtual void AddExtenderProviders(IExtenderProviderService ex) {
        
            // Check the hierarchy for VSHPROPID_DesignerFunctionVisibility
            //
            try {
                object prop;
                
                if (hierarchy != null 
                    && NativeMethods.Succeeded(hierarchy.GetProperty(
                        __VSITEMID.VSITEMID_ROOT, 
                        __VSHPROPID.VSHPROPID_DesignerFunctionVisibility, 
                        out prop))) {
                        
                    __VSDESIGNER_FUNCTIONVISIBILITY visibility = (__VSDESIGNER_FUNCTIONVISIBILITY)Enum.ToObject(typeof(__VSDESIGNER_FUNCTIONVISIBILITY), prop);
                    
                    defaultModifiersProvider = new DefaultModifiersProvider(visibility);
                    ex.AddExtenderProvider(defaultModifiersProvider);
                }
            }
            catch {
                Debug.Fail("VS hierarchy threw an exception asking for VSHPROPID_DesignerFunctionVisibility");
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.BeginLoad"]/*' />
        /// <devdoc>
        ///     Called by the designer host to begin the loading process.  The designer
        ///     host passes in an instance of a designer loader host (which is typically
        ///     the same object as the designer host.  This loader host allows
        ///     the designer loader to reload the design document and also allows
        ///     the designer loader to indicate that it has finished loading the
        ///     design document.
        /// </devdoc>
        public override void BeginLoad(IDesignerLoaderHost host) {

            Debug.Assert(!flags[StateLoaded], "Invalid call to BeginLoad");
            Debug.Assert(textBuffer != null, "Text Buffer should be set before BeginLoad.  Somebody didn't initialize us");
            Debug.Assert(this.host == null || this.host == host, "BeginLoad called with two different designer hosts.");

            flags[StateLoaded | StateLoadFailed] = false;
            loadDependencyCount = 0;

            if (this.host == null) {
                this.host = host;
                
                // Perform first time initialization.
                //
                host.AddService(typeof(IDesignerLoaderService), this);
                host.AddService(typeof(INameCreationService), this);
                host.AddService(typeof(IConfigurationService), this);
                host.AddService(typeof(ILicenseReaderWriterService), this);
                host.Activated += new EventHandler(this.OnDesignerActivate);
                host.Deactivated += new EventHandler(this.OnDesignerDeactivate);
                
                // Only add the resource service if the hierarchy implements IVsProjectResources.
                // Otherwise, we won't be able to get resource data.
                //
                if (Hierarchy is IVsProjectResources) {
                    host.AddService(typeof(IResourceService), this);
                }

                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentChanging += new ComponentChangingEventHandler(this.OnComponentChanging);
                    cs.ComponentAdding += new ComponentEventHandler(this.OnComponentAdding);
                    cs.ComponentRemoving += new ComponentEventHandler(this.OnComponentRemoving);
                    cs.ComponentAdded += new ComponentEventHandler(this.OnComponentAdded);
                    cs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
                    cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
                }
                IExtenderProviderService es = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
                if (es != null) {
                    AddExtenderProviders(es);
                }
                
                if (hierarchy != null) {
                    // See if we can get to DTE.  If so, add it as a service too.
                    //
                    object obj;
                    int hr = hierarchy.GetProperty(ItemId, __VSHPROPID.VSHPROPID_ExtObject, out obj);

                    if (NativeMethods.Succeeded(hr)) {
                        Debug.Assert(obj != null, "shell project model did not return an extensibility object.");
                        Type t = Type.GetType("EnvDTE.ProjectItem, " + AssemblyRef.EnvDTE);
                        if (t != null) {
                            host.AddService(t, obj);
                        }
                    }
                
                    // Check to see if we can create a type loader.  If we can, then publish ourselves as
                    // a type resolution service.
                    //
                    ITypeResolutionServiceProvider tls = (ITypeResolutionServiceProvider)GetService(typeof(ITypeResolutionServiceProvider));
                    Debug.Assert(tls != null, "No ITypeResolutionServiceProvider -- we cannot load classes for the designer.");
                    if (tls != null)  {
                        ITypeResolutionService trs = tls.GetTypeResolutionService(hierarchy);
                        
                        Debug.Assert(trs != null, "Type loader service failed to return a type loader");
                        Debug.Assert(trs is TypeLoader, "We need the type resolution service to be a type loader or dynamic reload won't work.");
                        
                        if (trs != null) {
                            host.AddService(typeof(ITypeResolutionService), trs);
                        }
                        
                        if (trs is TypeLoader) {
                            typeLoader = (TypeLoader)trs;
                            typeLoader.AssemblyObsolete += new AssemblyObsoleteEventHandler(this.OnAssemblyObsolete);
                        }
                    }
                }
            
                textBuffer.AttributeChanged += new EventHandler(this.OnTextBufferAttributeChanged);
                textBuffer.TextChanged += new TextBufferChangedEventHandler(this.OnTextBufferChanged);
            }

            flags[StateLoadReady] = true;

            // If the buffer is ready for us to load, then let's load it up.
            //
            if (flags[StateBufferReady]) {
                Load();
            }
        }

        private void CheckoutBuffer(bool checkoutLicx) {
            if (!flags[StateReloading] && loadDependencyCount == 0 && textBuffer != null) {

                int numFiles = 0;
                if (docDataHash != null) {
                    numFiles += docDataHash.Count;
                }
                if (checkoutLicx) {
                    numFiles++;
                }

                string[] files = new string[numFiles];
                int index = 0;

                if (docDataHash != null) {
                    foreach(string file in docDataHash.Keys) {
                        if ((((DocDataHolder)docDataHash[file]).Access & FileAccess.Write) != 0) {                        
                            files[index++] = file;
                        }
                    }
                }
                if (checkoutLicx) {
                    files[index++] = GetLicenseName();
                }

                textBuffer.Checkout(files);
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.CreateBaseName"]/*' />
        /// <devdoc>
        ///     Given a data type this fabricates the main part of a new component
        ///     name, minus any digits for uniqueness.
        /// </devdoc>
        protected abstract string CreateBaseName(Type dataType);

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.CreateCodeLoader"]/*' />
        /// <devdoc>
        ///     Called to create the code loader.
        /// </devdoc>
        protected abstract CodeLoader CreateCodeLoader(TextBuffer buffer, IDesignerLoaderHost host);

        private void DirtyState() {
            if (flags[StateLoaded]) {

                // Notify the type loader that anyone who is using our
                // class is now obsolete.
                //
                if (typeLoader != null && host != null) {
                    typeLoader.OnTypeChanged(host.RootComponentClassName);
                }
                
                if (textBuffer != null) {
                    CheckoutBuffer(false);
                    textBuffer.IsDirty = true;
                }
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes this designer loader.  The designer host will call this method
        ///     when the design document itself is being destroyed.  Once called, the
        ///     designer loader will never be called again.
        /// </devdoc>
        public override void Dispose() {
            Unload();
            
            // Get rid of any extra doc data elements we may be holding.  This releases
            // the RDT locks on them.  We do this in Dispose, not in Unload, because
            // we don't want to require a save to this data just to reload the designer;
            // we keep the buffers intact here.
            //
            if (docDataHash != null) {
                ICollection docDataEntries = docDataHash.Values;
                docDataHash = null;
                foreach(DocDataHolder holder in docDataEntries) {
                    holder.Dispose();
                }
            }
            
            if (flags[StateRDTEventsAdvised]) {
                IVsRunningDocumentTable rdt = (IVsRunningDocumentTable)GetService(typeof(IVsRunningDocumentTable));
                if (rdt != null) {
                    rdt.UnadviseRunningDocTableEvents(rdtEventsCookie);
                }
                flags[StateRDTEventsAdvised] = false;
            }

            IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentChanging -= new ComponentChangingEventHandler(this.OnComponentChanging);
                cs.ComponentAdding -= new ComponentEventHandler(this.OnComponentAdding);
                cs.ComponentRemoving -= new ComponentEventHandler(this.OnComponentRemoving);
                cs.ComponentAdded -= new ComponentEventHandler(this.OnComponentAdded);
                cs.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemoved);
                cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
            }
            
            IExtenderProviderService es = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
            if (es != null) {
                RemoveExtenderProviders(es);
            }

            if (host != null) {
            
                host.RemoveService(typeof(IDesignerLoaderService));
                host.RemoveService(typeof(IResourceService));
                host.RemoveService(typeof(INameCreationService));
                host.RemoveService(typeof(IConfigurationService));
                host.RemoveService(typeof(ILicenseReaderWriterService));
                
                Type t = Type.GetType("EnvDTE.ProjectItem, " + AssemblyRef.EnvDTE);
                if (t != null) {
                    host.RemoveService(t);
                }
                
                if (typeLoader != null) {
                    host.RemoveService(typeof(ITypeResolutionService));
                }
                
                host.Activated -= new EventHandler(this.OnDesignerActivate);
                host.Deactivated -= new EventHandler(this.OnDesignerDeactivate);

                host = null;
            }
            
            if (checkoutService != null) {
                checkoutService.Dispose();
            }
            
            if (typeLoader != null) {
                typeLoader.AssemblyObsolete -= new AssemblyObsoleteEventHandler(this.OnAssemblyObsolete);
                typeLoader = null;
            }
            
            if (textBuffer != null) {
                textBuffer.AttributeChanged -= new EventHandler(this.OnTextBufferAttributeChanged);
                textBuffer.TextChanged -= new TextBufferChangedEventHandler(this.OnTextBufferChanged);
                textBuffer.Dispose();
                textBuffer = null;
            }

            if (codeLoader != null) {
                codeLoader.Dispose();
                codeLoader = null;
            }

            oleUndoManager = null;
            
            flags[StateBufferReady | StateLoadReady] = false;
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.Flush"]/*' />
        /// <devdoc>
        ///     The designer host will call this periodically when it wants to
        ///     ensure that any changes that have been made to the document
        ///     have been saved by the designer loader.  This method allows
        ///     designer loaders to implement a lazy-write scheme to improve
        ///     performance.  The default implementation does nothing.
        /// </devdoc>
        public override void Flush() {
            if (flags[StateReloading]) {
                return;
            }

            if (codeLoader != null) {
                Debug.WriteLineIf(traceLoader.TraceVerbose, "flushing designer changes to disk");
                
                if (codeLoader.IsDirty && textBuffer.IsDirty) {

                    // Check to see if we are currently in a transaction.  If we are, then
                    // wait until we're out of it before flushing.
                    //
                    if (host.InTransaction) {
                        host.TransactionClosed += new DesignerTransactionCloseEventHandler(this.OnFlushTransactionClosed);
                    }
                    else {
                        flags[StateFlushInProgress] = true;

                        try {
                            // Final check to ensure the text buffer is checked out.  It should be by now,
                            // but let's be safe.
                            //
                            textBuffer.Checkout();

                            WarningUndoUnit unit = null;
                            if (oleUndoManager != null) {
                                unit = new WarningUndoUnit(serviceProvider, SR.GetString(SR.SerializerDesignerGeneratedCode));
                                oleUndoManager.Open(unit);
                            }

                            // Flush the changes to the code.
                            //
                            codeLoader.Flush();

                            // Flush any changes to the licenses.
                            //
                            ILicenseManagerService licService = (ILicenseManagerService)GetService(typeof(ILicenseManagerService));
                            if (licService != null)  {
                                if (licenseManager == null) {
                                    licenseManager = licService.GetLicenseManager(hierarchy);
                                }
                                Debug.Assert(licenseManager != null, "License Manager service failed to return a license manager");

                                if (licenseManager != null) {
                                    licenseManager.Flush(host);
                                }
                            }

                            // Look for an undo manager on the text buffer.  If we find one
                            // discard all undo changes.
                            //
                            if (oleUndoManager != null && unit != null) {
                                oleUndoManager.Close(unit, true);
                            }

                        }
                        finally {
                            flags[StateFlushInProgress] = false;
                        }
                    }
                }
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetConfigDocData"]/*' />
        /// <devdoc>
        ///      Retrieves the VS doc data for the project runtime configuration file.  
        ///      If fileAccess is ReadWrite, this will also ensure that the file is 
        ///      checked out.  It returns a holder to the doc data (the holder contains the lock).
        /// </devdoc>
        private bool GetConfigDocData(FileAccess access, out DocDataHolder docData) {
            return GetDocDataInternal(access, __PSFFILEID.AppConfig, out docData);
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetLicenseDocData"]/*' />
        /// <devdoc>
        ///      Retrieves the VS doc data for the project runtime configuration file.  
        ///      If fileAccess is ReadWrite, this will also ensure that the file is 
        ///      checked out.  It returns a holder to the doc data (the holder contains the lock).
        /// </devdoc>
        private bool GetLicenseDocData(FileAccess access, out DocDataHolder docData) {
            return GetDocDataInternal(access, __PSFFILEID.Licenses, out docData);
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetDocDataInternal"]/*' />
        /// <devdoc>
        ///      Retrieves the VS doc data for the given project item.  
        ///      If fileAccess is ReadWrite, this will also ensure that the file is 
        ///      checked out.  It returns a holder to the doc data (the holder contains the lock).
        /// </devdoc>
        private bool GetDocDataInternal(FileAccess access, int fileID, out DocDataHolder docData) {
            docData = null;
            string docName = null;
            int configItemId = __VSITEMID.VSITEMID_NIL;                
            int hr;
                                                                       
            IVsProjectSpecialFiles specialFiles = Hierarchy as IVsProjectSpecialFiles;
            
            if (specialFiles == null) {
                return false;
            }
            
            int psFlags = __PSFFLAGS.FullPath;
            
            if (access != FileAccess.Read) {
                psFlags |= __PSFFLAGS.CreateIfNotExist;
            }
            
            hr = specialFiles.GetFile(fileID, psFlags, ref configItemId, ref docName);
            if (NativeMethods.Failed(hr)) {
                Marshal.ThrowExceptionForHR(hr);
            }
            
            if (configItemId != __VSITEMID.VSITEMID_NIL) {
                return GetFileDocData(access, Hierarchy, configItemId, out docData);
            }
            
            docData = null;
            return true;
        }
            
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetConfigName"]/*' />
        /// <devdoc>
        ///      Retrieves the name of the runtime configuration file for the project. 
        ///      If no project is available, the name of the RootComponentClass will 
        ///      be used.
        /// </devdoc>                              
        private string GetConfigName() {
            string configName = WebConfigName;
            if (host != null) {
                configName = host.RootComponentClassName;                
                if (configName != null) {
                    int lastDot = configName.LastIndexOf('.');
                    if (lastDot != -1) 
                        configName = configName.Substring(lastDot + 1);
                                    
                    configName = configName + ".exe.config";                                    
                }                        
            }            
            
            return configName;
        }                 
                                    
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetLicenseName"]/*' />
        /// <devdoc>
        ///      Retrieves the name of the license file for the project. 
        ///      If no project is available, the name of the RootComponentClass will 
        ///      be used.
        /// </devdoc>                              
        private string GetLicenseName() {
            return "licenses.licx";
        }                 
                                    
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetConfigStream"]/*' />
        /// <devdoc>
        ///      Retrieves a Stream for the project runtime configuration file.        
        /// </devdoc>
        private Stream GetConfigStream(FileAccess access) {
            Stream stream = null;            
            string fileName = GetConfigName();                                    
            if (access == FileAccess.Read) {               
                if (File.Exists(fileName)) {
                    stream = File.Open(fileName, FileMode.Open, access, FileShare.None);
                }
            }
            else {  
                stream = File.Open(fileName, FileMode.Create, access, FileShare.None);
            }
                                        
            return stream;                            
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetLicenseStream"]/*' />
        /// <devdoc>
        ///      Retrieves a Stream for the project licenses file.        
        /// </devdoc>
        private Stream GetLicenseStream(FileAccess access) {
            Stream stream = null;            
            string fileName = GetLicenseName();                                    
            if (access == FileAccess.Read) {               
                if (File.Exists(fileName)) {
                    stream = File.Open(fileName, FileMode.Open, access, FileShare.None);
                }
            }
            else {  
                stream = File.Open(fileName, FileMode.Create, access, FileShare.None);
            }
                                        
            return stream;                            
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetFileDocData"]/*' />
        /// <devdoc>
        ///     Retrieves a doc data holder for a given item.  This checks our cache of open editor files first,
        ///     and only creates a new lock if the editor file does not exist.
        /// </devdoc>
        private bool GetFileDocData(FileAccess access, IVsHierarchy hierarchy, int itemId, out DocDataHolder docData) {
        
            docData = null;
            
            // Get the file name for this item.
            //
            IVsProject vsProj = hierarchy as IVsProject;
            if (vsProj == null) {
                Debug.Fail("hierarchy does not implement IVsProject");
                return false;
            }
            
            string docName = vsProj.GetMkDocument(itemId);
            
            // We will need this.  If it isn't present, bail early so we don't
            // do bad things like check out a file we will never access.
            //
            IVsProjectResources projRes = hierarchy as IVsProjectResources;
            if (projRes == null) {
                Debug.Fail("hierarchy does not implement IVsProjectResources");
                return false;
            }

            // Ensure that the file is checked out.
            //
            if (access != FileAccess.Read) {
                if (checkoutService == null) {
                    checkoutService = new VsCheckoutService(host);
                }
                checkoutService.CheckoutFile(docName);
            }
            
            // Do we already have this doc data?
            //
            if (docDataHash == null) {
                docDataHash = new Hashtable(5); // should be rare to have over 5 entries here.
            }
            else {
                docData = (DocDataHolder)docDataHash[docName];                
            }
            
            if (docData == null) {
                IVsHierarchy docHier = null;
                int docItemId = 0;
                object vsDocData = null;
                int lockCookie = 0;
                
                // We first must check the running document table to see if someone already
                // has the document open.  If they do, we use that doc data.  If they don't,
                // then we create a doc data and register it in the RDT.
                //
                IVsRunningDocumentTable rdt = (IVsRunningDocumentTable)GetService(typeof(IVsRunningDocumentTable));
                Debug.Assert(rdt != null, "What?  VS has no RDT?");
                        
                int hr = rdt.FindAndLockDocument(__VSRDTFLAGS.RDT_EditLock, docName, ref docHier, ref docItemId, ref vsDocData, ref lockCookie);
                        
                if (hr != 0) {
                
                    // Document is not in the RDT.  Create a buffer and add it to the RDT.
                    //
                    try {
                        vsDocData = projRes.CreateResourceDocData(itemId);
                    }
                    catch (ExternalException eex){
                        hr = eex.ErrorCode;
                    }
                    
                    if (vsDocData != null) {
                        hr = rdt.RegisterAndLockDocument(__VSRDTFLAGS.RDT_EditLock, docName, hierarchy, itemId, vsDocData, ref lockCookie);
                        if (NativeMethods.Failed(hr)) {
                        
                            // Failed to register.  All we can do here is release the doc data and continue.
                            //
                            Marshal.ReleaseComObject(vsDocData);
                        }
                    }
                }
                
                if (NativeMethods.Failed(hr)) {
                    Marshal.ThrowExceptionForHR(hr);
                }
                
                // Got a locked doc data.  Wrap it in our holder object and return.  We will hang
                // on to this object until this loader is destroyed.
                //
                docData = new DocDataHolder(this, rdt, vsDocData, lockCookie, access);
                docDataHash[docName] = docData;
            }
            else {
                // Make sure the file access member is up-to-date
                //
                if ((access & FileAccess.Write) != 0) {
                    docData.Access = access;
                }
            }

            return true;
        }
                                             
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetResourceDocData"]/*' />
        /// <devdoc>
        ///      Retrieves the VS doc data for the resource file for the given culture
        ///      info.  If fileAccess is ReadWrite, this will also ensure that the file
        ///      is checked out.  It returns the text stream object as well as the 
        ///      edit lock cookie.
        /// </devdoc>
        private bool GetResourceDocData(CultureInfo culture, FileAccess access, out DocDataHolder docData) {
            
            docData = null;
            bool supported = false;
        
            if (Hierarchy is IVsProjectResources) {
                IVsProjectResources projRes = (IVsProjectResources)Hierarchy;
                supported = true;
            
                // Ok, we have IVsProjectResources.  Look for an item ID for the correct culture.
                //
                __VSPROJRESFLAGS resFlags;
                
                // always create a new node.
                //
                resFlags = __VSPROJRESFLAGS.PRF_CreateIfNotExist;
                
                string cultureName;
            
                if (culture.Equals(CultureInfo.InvariantCulture)) {
                    cultureName = string.Empty;
                }
                else {
                    cultureName = culture.Name;
                }
            
                int resItemId;
                
                
                int hr = projRes.GetResourceItem(ItemId, cultureName, resFlags, out resItemId);
                
                if (NativeMethods.Succeeded(hr)) {
                    supported = GetFileDocData(access, Hierarchy, resItemId, out docData);
                }
                else {
                    // If we failed to find the resource, and someone requested a writable
                    // resource, then throw.  This indicates that some problem has occurred.
                    //
                    if (access != FileAccess.Read) {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                }
            }
            
            return supported;
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.GetService"]/*' />
        /// <devdoc>
        ///     Our own little service provider.
        /// </devdoc>
        protected object GetService(Type serviceType) {
            object value = null;

            if (host != null) {
                value = host.GetService(serviceType);
            }

            if (value == null && serviceProvider != null) {
                value = serviceProvider.GetService(serviceType);
            }

            return value;
        }

        /// <devdoc>
        ///     Our internal reload function...
        /// </devdoc>
        private void InternalReload(bool forceLoad) {

            flags[StateAlwaysReload] = forceLoad;

            // Our implementation of Reload only reloads if we are the 
            // active designer.  Otherwise, we wait until we become
            // active and reload at that time.  We also never do a 
            // reload if we are flushing code.
            //
            if (!flags[StateFlushInProgress]) {
                if (flags[StateActiveDocument]) {
                    if (!flags[StateReloadAtIdle]) {
                        Application.Idle += new EventHandler(this.OnIdle);
                        flags[StateReloadAtIdle] = true;
                    }
                }
                else {
                    flags[StateDeferredReload] = true;
                }
            }
        }

        /// <devdoc>
        ///     Checks if the given docCookie represents the document that this loader owns.
        /// </devdoc>
        private bool IsDesignerDocument(int docCookie) {
            IVsRunningDocumentTable rdt = (IVsRunningDocumentTable)GetService(typeof(IVsRunningDocumentTable));
            if (rdt != null) {
                string docName = null;
                __VSRDTFLAGS flags = 0;
                int readLocks = 0;
                int editLocks = 0;
                IVsHierarchy pHier = null;
                int docItemid = 0;
                object pDocData = null;
                
                int hr = rdt.GetDocumentInfo(docCookie, ref flags, ref readLocks, ref editLocks, ref docName, ref pHier, ref docItemid, ref pDocData);
                return NativeMethods.Succeeded(hr) && pHier == hierarchy && docItemid == itemid;
            }
            return false;
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.Load"]/*' />
        /// <devdoc>
        ///     This performs the actual load of the designer.  It is called from
        ///     two places.  If our text buffer came preloaded with text this
        ///     will be called from BeginLoad.  Otherwise it will be called from
        ///     OnTextBufferLoaded.
        /// </devdoc>
        private void Load() {

            CodeDomLoader.StartMark();

            // We assume we support reload until the codeLoader tells us we
            // can't.  That way, we will do the reload if we didn't get a
            // valid loader to start with.
            //
            bool successful = true;
            ArrayList localErrorList = null;
            
            try {
                if (codeLoader == null) {
                    codeLoader = CreateCodeLoader(textBuffer, host);
                }
                ((IDesignerLoaderService)this).AddLoadDependency(); // This will call codeLoader.BeginLoad
                baseComponentClassName = codeLoader.Load();
            }
            catch (Exception e) {
            
                // If the code loader threw, then we don't have a load dependency.  We need one
                // however, so we can finish out the load.  So we add one here.
                //
                if (codeLoader == null) {
                    loadDependencyCount++;
                }
                
                localErrorList = new ArrayList();
                localErrorList.Add(e);
                successful = false;
            }

            // Now add VS-specific services and attributes.  We do this
            // once on first load, which is why we null out initialDocData
            // after we do this.
            //
            if (initialDocData != null) {
                object docData = initialDocData;
                initialDocData = null;

                IVsTextBuffer vsTextBuf = docData as IVsTextBuffer;
                if (vsTextBuf != null) {
                    vsTextBuf.GetUndoManager(out oleUndoManager);
                }

                // Provide the necessary help attributes to
                // the help system for the language behind this
                // source file.
                //
                IHelpService helpSvc = (IHelpService)GetService(typeof(IHelpService));
                if (helpSvc != null) {
                    AddDocDataHelpAttributes(docData, helpSvc);
                }
            }

            ((IDesignerLoaderService)this).DependentLoadComplete(successful, localErrorList);

            CodeDomLoader.EndMark("Full Load");
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnAssemblyObsolete"]/*' />
        /// <devdoc>
        ///      Called when an assembly has changed in the type loader.  Here we look to
        ///      see if we own any classes in this assemlby, and if we do, we reload ourselves.
        /// </devdoc>
        private void OnAssemblyObsolete(object sender, AssemblyObsoleteEventArgs e) {
            if (host != null) {
                
                foreach(IComponent comp in host.Container.Components) {
                    if (comp.GetType().Module.Assembly == e.ObsoleteAssembly) {

                        // set this flag so if we reload and we get errors, we'll 
                        // mark the buffer dirty. We do this because this can be caused by
                        // a generated item (like dataset1.xsd) being deleted, so dirtying
                        // will clear the file references.
                        //
                        flags[StateDirtyIfErrors] = true;
                        InternalReload(true);
                        break;
                    }
                }
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnComponentChanged"]/*' />
        /// <devdoc>
        ///     This is called whenever a component on the design surface changes.
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            DirtyState();
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnComponentAdding"]/*' />
        /// <devdoc>
        ///     This is called when the design surface is about to change.  Here
        ///     we ensure that the file is checked out.  If the file cannot be
        ///     checked out, this will throw an exception which will prevent
        ///     the change from occurring.
        /// </devdoc>
        private void OnComponentAdding(object sender, ComponentEventArgs e) {
            bool checkoutLicx = false;
            
            // See if we need to create and/or checkout the licx file.
            //
            if (!flags[StateReloading] && loadDependencyCount == 0 && textBuffer != null) {
                
                ILicenseManagerService licService = (ILicenseManagerService)GetService(typeof(ILicenseManagerService));
                if (licService != null)  {
                    if (licenseManager == null)
                        licenseManager = licService.GetLicenseManager(hierarchy);
                    
                    Debug.Assert(licenseManager != null, "License Manager service failed to return a license manager");
    
                    if (licenseManager != null && licenseManager.NeedsCheckoutLicX(e.Component)) {
                        ILicenseReaderWriterService licrwService = (ILicenseReaderWriterService)GetService(typeof(ILicenseReaderWriterService));
                        
                        TextReader licxReader = licrwService.GetLicenseReader();
                        if (licxReader == null) {
                            TextWriter licxWriter = licrwService.GetLicenseWriter();
                            licxWriter.Close();
                        }
                        else {
                            licxReader.Close();
                        }
    
                        checkoutLicx = true;
                    }
                }
            }
            
            CheckoutBuffer(checkoutLicx);
        }

        private void OnComponentAdded(object sender, ComponentEventArgs e) {
            DirtyState();
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnComponentChanging"]/*' />
        /// <devdoc>
        ///     This is called when the design surface is about to change.  Here
        ///     we ensure that the file is checked out.  If the file cannot be
        ///     checked out, this will throw an exception which will prevent
        ///     the change from occurring.
        /// </devdoc>
        private void OnComponentChanging(object sender, ComponentChangingEventArgs e) {
            CheckoutBuffer(false);
        }

        private void OnComponentRemoved(object sender, ComponentEventArgs e) {
            DirtyState();
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnComponentRemoving"]/*' />
        /// <devdoc>
        ///     This is called when the design surface is about to change.  Here
        ///     we ensure that the file is checked out.  If the file cannot be
        ///     checked out, this will throw an exception which will prevent
        ///     the change from occurring.
        /// </devdoc>
        private void OnComponentRemoving(object sender, ComponentEventArgs e) {
            CheckoutBuffer(false);
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnDesignerActivate"]/*' />
        /// <devdoc>
        ///     Called when this document becomes active.  here we check to see if
        ///     someone else has modified the contents of our buffer.  If so, we
        ///     ask the designer to reload.
        /// </devdoc>
        private void OnDesignerActivate(object sender, EventArgs e) {
            flags[StateActiveDocument] = true;

            if (flags[StateDeferredReload] && host != null) {
                flags[StateDeferredReload] = false;
                InternalReload(flags[StateAlwaysReload]);
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnDesignerDeactivate"]/*' />
        /// <devdoc>
        ///     Called when this document loses activation.  We just remember this
        ///     for later.
        /// </devdoc>
        private void OnDesignerDeactivate(object sender, EventArgs e) {
            flags[StateActiveDocument] = false;
        }

        /// <devdoc>
        ///     If we were asked to flush while we were in a transaction, we defer this request until we are out
        ///     of the transaction.  Otherwise, we could end up combining text changes in with designer changes
        ///     on a linked undo stack.  These combined undo actions can cause us to try to reload during
        ///     an undo, because the undo is also pushing code changes into the buffer.
        /// </devdoc>
        private void OnFlushTransactionClosed(object sender, DesignerTransactionCloseEventArgs e) {
            host.TransactionClosed -= new DesignerTransactionCloseEventHandler(this.OnFlushTransactionClosed);
            Flush();
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnIdle"]/*' />
        /// <devdoc>
        ///     Invoked by the loader host when it actually performs the reload, but before
        ///     the reload actually happens.  Here we unload our part of the loader
        ///     and get us ready for the pending reload.
        /// </devdoc>
        private void OnIdle(object sender, EventArgs e) {
            if (flags[StateReloadAtIdle]) {
                flags[StateReloadAtIdle] = false;
                if(host != null) {

                    if (codeLoader == null || flags[StateAlwaysReload] || codeLoader.NeedsReload) {

                        DesignerTransaction dt = null;
                        
                        try {
                            if (!flags[StateExternalChange]) {
                                Flush();
                            }

                            // bump out dependency count so we know we're
                            // loading and dont' try to checkout the file.
                            dt = host.CreateTransaction();

                            flags[StateReloading] = true;
                            Unload();
                            host.Reload();
                        }
                        finally {
                            if (dt != null) {
                                dt.Commit();
                            }
                            flags[StateReloading] = false;
                            flags[StateAlwaysReload] = false;
                            flags[StateDirtyIfErrors] = false;
                        }
                    }
                }
            }
            
            Application.Idle -= new EventHandler(this.OnIdle);
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnTextBufferAttributeChanged"]/*' />
        /// <devdoc>
        ///      Called when the file attributes change.  Here we update the frame's
        ///      window caption, if we can get it.
        /// </devdoc>
        private void OnTextBufferAttributeChanged(object sender, EventArgs e) {
            IVsWindowFrame frame = (IVsWindowFrame)GetService(typeof(IVsWindowFrame));
            if (frame != null) {
                string caption = ((IVSMDDesignerLoader)this).GetEditorCaption(_READONLYSTATUS.ROSTATUS_Unknown);
                frame.SetProperty(__VSFPROPID.VSFPROPID_EditorCaption, caption);
            }

            // if the attributes changed prompt a reload if necessary.
            if (codeLoader != null && codeLoader.IsDirty && flags[StateActiveDocument]) {
                flags[StateExternalChange] = true;
                InternalReload(false);
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnTextBufferChanged"]/*' />
        /// <devdoc>
        ///      Called when the text in the document changes.  We use this to announce to the type
        ///      loader that our class definition has changed.
        /// </devdoc>
        private void OnTextBufferChanged(object sender, TextBufferChangedEventArgs e) {
        
            // If we're not the active document, then prompt a reload.
            // If we are the active document then someone, either via
            // DTE or by poking into the text buffer, made a change
            // that we probably should ignore.
            //
            if (!flags[StateActiveDocument] || e.ShouldReload) {
                flags[StateExternalChange] = flags[StateActiveDocument];
                InternalReload(false);
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.OnTextBufferLoaded"]/*' />
        /// <devdoc>
        ///     This is called by the VS text buffer to signal that it has finished
        ///     loading its text.  VS may load the text buffer after they hand it
        ///     to us, so we must check.
        /// </devdoc>
        private void OnTextBufferLoaded(object sender, EventArgs e) {
            flags[StateBufferReady] = true;
            // bump the supress so we ignore the next DocDataReloaded notification from the shell
            supressReloadWithDocData++;
            if (flags[StateLoadReady]) {
                Load();
            }
            ((ShellTextBuffer)sender).Loaded -= new EventHandler(this.OnTextBufferLoaded);
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.RemoveExtenderProviders"]/*' />
        /// <devdoc>
        ///      This is called at the appropriate time to remove any extra extender
        ///      providers previously added to the designer host.
        /// </devdoc>
        protected virtual void RemoveExtenderProviders(IExtenderProviderService ex) {
            if (defaultModifiersProvider != null) {
                ex.RemoveExtenderProvider(defaultModifiersProvider);
                defaultModifiersProvider = null;
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.Unload"]/*' />
        /// <devdoc>
        ///     This method will be called when the document is to be unloaded.  It
        ///     does not dispose us, but it gets us ready for a dispose or a reload.
        /// </devdoc>
        private void Unload() {

            // Flush any pending changes we have stored up before we unload.
            // We don't want to lose data.
            //
            Flush();
            flags[StateLoaded] = false;

            if (codeLoader != null) {
                if (!codeLoader.Reset()) {
                    codeLoader.Dispose();
                    codeLoader = null;
                }
            }

            if (docDataHash != null) {
                foreach(DocDataHolder holder in docDataHash.Values) {
                    holder.Cache = null;
                }
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IConfigurationService.GetConfigurationReader"]/*' />
        /// <devdoc>
        ///     Locates the runtime configuration settings reader.  If there in no 
        ///     configuration file available this method will return null.
        /// </devdoc>       
        TextReader IConfigurationService.GetConfigurationReader() {
        
            TextReader reader = null;            
            DocDataHolder docData;
             
           if (GetConfigDocData(FileAccess.Read, out docData)) {
                if (docData != null) {
                    reader = new DocDataTextReader(docData);
                }
            }
            else {
                Stream stream = GetConfigStream(FileAccess.Read);
                if (stream != null) {
                    reader = new StreamReader(stream);
                }
            }
                                            
            return reader;
        }
    
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.ILicenseReaderWriterService.GetLicenseWriter"]/*' />
        /// <devdoc>
        ///     Locates the license writer. A new licenses 
        ///     file  will be created if it doesn't exist yet.        
        /// </devdoc>        
        TextWriter ILicenseReaderWriterService.GetLicenseWriter() {
            TextWriter writer = null;                            
            DocDataHolder docData;
             
            if (GetLicenseDocData(FileAccess.ReadWrite, out docData)) {
                if (docData != null) {
                    writer = new DocDataTextWriter(docData);
                }
            }
            else {
                Stream stream = GetConfigStream(FileAccess.ReadWrite);
                writer = new StreamWriter(stream);
            }
            
            return writer;       
        }                        
                        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.ILicenseReaderWriterService.GetLicenseReader"]/*' />
        /// <devdoc>
        ///     Locates the project's license reader.  If there in no 
        ///     licenses file available this method will return null.
        /// </devdoc>       
        TextReader ILicenseReaderWriterService.GetLicenseReader() {
            TextReader reader = null;            
            DocDataHolder docData;
             
           if (GetLicenseDocData(FileAccess.Read, out docData)) {
                if (docData != null) {
                    reader = new DocDataTextReader(docData);
                }
            }
            else {
                Stream stream = GetConfigStream(FileAccess.Read);
                if (stream != null) {
                    reader = new StreamReader(stream);
                }
            }
                                            
            return reader;
        }
    
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IConfigurationService.GetConfigurationWriter"]/*' />
        /// <devdoc>
        ///     Locates the runtime configuration settings writer. A new configuration 
        ///     file  will be created if it doesn't exist yet.        
        /// </devdoc>        
        TextWriter IConfigurationService.GetConfigurationWriter() {
            TextWriter writer = null;                            
            DocDataHolder docData;
             
            if (GetConfigDocData(FileAccess.ReadWrite, out docData)) {
                if (docData != null) {
                    writer = new DocDataTextWriter(docData);
                }
            }
            else {
                Stream stream = GetConfigStream(FileAccess.ReadWrite);
                writer = new StreamWriter(stream);
            }
            
            return writer;       
        }                        
                        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IDesignerLoaderService.AddLoadDependency"]/*' />
        /// <devdoc>
        ///     Adds a load dependency to this loader.  This indicates that some other
        ///     object is also participating in the load, and that the designer loader
        ///     should not call EndLoad on the loader host until all load dependencies
        ///     have called DependentLoadComplete on the designer loader.
        /// </devdoc>
        void IDesignerLoaderService.AddLoadDependency() {
            if (codeLoader == null) {
                throw new InvalidOperationException();
            }
            
            if (loadDependencyCount++ == 0) {
                errorList = new ArrayList();
                codeLoader.BeginLoad(errorList);
                flags[StateLoaded] = false;
            }
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IDesignerLoaderService.DependentLoadComplete"]/*' />
        /// <devdoc>
        ///     This is called by any object that has previously called
        ///     AddLoadDependency to signal that the dependent load has completed.
        ///     The caller should pass either an empty collection or null to indicate
        ///     a successful load, or a collection of exceptions that indicate the
        ///     reason(s) for failure.
        /// </devdoc>
        void IDesignerLoaderService.DependentLoadComplete(bool successful, ICollection errorCollection) {
            if (loadDependencyCount == 0) {
                throw new InvalidOperationException();
            }

            if (errorCollection != null && errorCollection.Count > 0) {
                if (errorList == null) {
                    errorList = new ArrayList();
                }
                errorList.AddRange(errorCollection);
            }
            
            if (!successful) {
                flags[StateLoadFailed] = true;
            }

            if (--loadDependencyCount == 0) {
                flags[StateLoaded] = true;
                if (flags[StateLoadFailed]) {
                    try {
                        Unload();
                    }
                    catch {
                    }
                }
                if (codeLoader != null) {
                    codeLoader.EndLoad(!flags[StateLoadFailed]);
                }
                host.EndLoad(baseComponentClassName, !flags[StateLoadFailed], errorList);

                // if we got errors in the load, set ourselves as dirty so we'll regen code.
                //
                if (flags[StateDirtyIfErrors] && errorList != null && errorList.Count > 0) {
                    try {
                        textBuffer.Checkout();
                        textBuffer.IsDirty = true;
                        DirtyState();
                        codeLoader.IsDirty = true;
                    }
                    catch {
                        // Eat this -- if the user aborts a checkout or some other problem arises
                        // with the dirty, it's no big deal.
                    }
                }
                errorList = null;
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IDesignerLoaderService.Reload"]/*' />
        /// <devdoc>
        ///     This can be called by an outside object to request that the loader
        ///     reload the design document.  If it supports reloading and wants to
        ///     comply with the reload, the designer loader should return true.  Otherwise
        ///     it should return false, indicating that the reload will not occur.
        ///     Callers should not rely on the reload happening immediately; the
        ///     designer loader may schedule this for some other time, or it may
        ///     try to reload at once.
        /// </devdoc>
        bool IDesignerLoaderService.Reload() {
            if ((codeLoader == null || codeLoader.ReloadSupported) && loadDependencyCount == 0) {
                // if we've been called from externally, force the reload
                //
                InternalReload(true);
                return true;
            } 
            return false;
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IInitializeDesignerLoader.Initialize"]/*' />
        /// <devdoc>
        ///     This method is called to initialize the designer loader.
        /// </devdoc>
        void IInitializeDesignerLoader.Initialize(IServiceProvider provider, TextBuffer buffer) {
            this.serviceProvider = provider;
            this.textBuffer = buffer;
            flags[StateBufferReady] = true;
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.INameCreationService.CreateName"]/*' />
        /// <devdoc>
        ///     Creates a new name that is unique to all the components
        ///     in the given container.  The name will be used to create
        ///     an object of the given data type, so the service may
        ///     derive a name from the data type's name.
        /// </devdoc>
        string INameCreationService.CreateName(IContainer container, Type dataType) {
            string baseName = CreateBaseName(dataType);
            string finalName;
            
            if (container != null) {
                int idx = 1;
                finalName = baseName + idx.ToString();
                while(container.Components[finalName] != null || codeLoader.IsNameUsed(finalName)) {
                    idx++;
                    finalName = baseName + idx.ToString();
                }
            }
            else {
                finalName = baseName;
            }
            
            return codeLoader.CreateValidIdentifier(finalName);
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.INameCreationService.IsValidName"]/*' />
        /// <devdoc>
        ///     Determines if the given name is valid.  A name 
        ///     creation service may have rules defining a valid
        ///     name, and this method allows the sevice to enforce
        ///     those rules.
        /// </devdoc>
        bool INameCreationService.IsValidName(string name) {
            return codeLoader.IsValidIdentifier(name) && !codeLoader.IsNameUsed(name);
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.INameCreationService.ValidateName"]/*' />
        /// <devdoc>
        ///     Determines if the given name is valid.  A name 
        ///     creation service may have rules defining a valid
        ///     name, and this method allows the sevice to enforce
        ///     those rules.  It is similar to IsValidName, except
        ///     that this method will throw an exception if the
        ///     name is invalid.  This allows implementors to provide
        ///     rich information in the exception message.
        /// </devdoc>
        void INameCreationService.ValidateName(string name) {
            codeLoader.ValidateIdentifier(name);
            
            // Only check with the code loader if we're not loading.  If we are
            // loading, then of course the name will found inside the code loader; that's
            // where it originates!
            //
            if (loadDependencyCount == 0 && codeLoader.IsNameUsed(name)) {
                Exception ex = new ArgumentException(SR.GetString(SR.CODEMANDupComponentName, name));
                ex.HelpLink = SR.CODEMANDupComponentName;
                throw ex;
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IResourceService.GetResourceReader"]/*' />
        /// <devdoc>
        ///     Locates the resource reader for the specified culture
        ///     and returns it.  If there are no resources associated
        ///     with the designer for the specified culture this will
        ///     return null.
        /// </devdoc>
        IResourceReader IResourceService.GetResourceReader(CultureInfo info) {
        
            ResXResourceReader reader = null;
            DocDataHolder docData;
             
            CodeDomLoader.StartMark();

            if (GetResourceDocData(info, FileAccess.Read, out docData)) {
                if (docData != null) {

                    reader = docData.Cache as ResXResourceReader;

                    if (reader == null) {
                        ITypeResolutionService tls = (ITypeResolutionService)GetService(typeof(ITypeResolutionService));
                        Debug.Assert(tls != null, "No ITypeResolutionService -- we cannot load classes for the designer.");

                        // ResXReader throws if the XML blob is empty.  Guard against
                        // an empty file here.
                        //
                        DocDataTextReader textReader = new DocDataTextReader(docData);
                        if (!textReader.IsEmpty) {
                            reader = new ResXResourceReader(new DocDataTextReader(docData), tls);
                        }

                        docData.Cache = reader;
                    }
                }
            }
            
            CodeDomLoader.EndMark("Aquired resource file for culture " + info.ToString());

            return reader;
        }
    
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IResourceService.GetResourceWriter"]/*' />
        /// <devdoc>
        ///     Locates the resource writer for the specified culture
        ///     and returns it.  This will create a new resource for
        ///     the specified culture and destroy any existing resource,
        ///     should it exist.
        /// </devdoc>
        IResourceWriter IResourceService.GetResourceWriter(CultureInfo info) {
        
            ResXResourceWriter writer = null;
            DocDataHolder docData;
             
            if (GetResourceDocData(info, FileAccess.ReadWrite, out docData)) {
                writer = new ResXResourceWriter(new DocDataTextWriter(docData));
            }
            
            return writer;
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IVSMDDesignerLoader.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes the designer loader from the native side.
        /// </devdoc>
        void IVSMDDesignerLoader.Dispose() {
            ((BaseDesignerLoader)this).Dispose();
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IVSMDDesignerLoader.GetEditorCaption"]/*' />
        /// <devdoc>
        ///      Sets the base editor caption for the VS editor window.  This can be
        ///      called to override the base editor caption, which is "[Design]".
        /// </devdoc>
        string IVSMDDesignerLoader.GetEditorCaption(int status) {
            string caption = baseEditorCaption;
            if (caption == null) {
                caption = SR.GetString(SR.DesignerCaption);
            }

            if (status == _READONLYSTATUS.ROSTATUS_Unknown) {
                if (textBuffer == null || textBuffer.ReadOnly) {
                    status = _READONLYSTATUS.ROSTATUS_ReadOnly;
                }
                else {
                    status = _READONLYSTATUS.ROSTATUS_NotReadOnly;
                }
            }

            if (status == _READONLYSTATUS.ROSTATUS_ReadOnly) {
                caption += " " + SR.GetString(SR.DesignerReadOnlyCaption);
            }

            return " " + caption;
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IVSMDDesignerLoader.Initialize"]/*' />
        /// <devdoc>
        ///     This method is called to initialize the designer loader with the text
        ///     buffer to read from and a service provider through which we
        ///     can ask for services.
        /// </devdoc>
        void IVSMDDesignerLoader.Initialize(object pSp, object pHier, int itemid, object punkDocData) {

            if (this.hierarchy != null || this.textBuffer != null) {
                Debug.Fail("IVSMDDesignerLoader::Initialized should only be called once!");
                return;
            }
        
            if (!(pSp is NativeMethods.IOleServiceProvider)) {
                throw new ArgumentException("pSp");
            }
            
            if (!(pHier is IVsHierarchy)) {
                throw new ArgumentException("pHier");
            }
        
            // If a random editor opens the file and locks it using an incompatible buffer, we need 
            // to detect this.
            //
            if (punkDocData is IVsTextBufferProvider) {
                punkDocData = ((IVsTextBufferProvider)punkDocData).GetTextBuffer();
            }
            
            if (!(punkDocData is IVsTextStream)) {
                string fileName = string.Empty;
                
                if (punkDocData is IVsUserData) {
                   Guid guid = typeof(IVsUserData).GUID;
                    object vt = ((IVsUserData)punkDocData).GetData(ref guid);
                    if (vt is string) {
                        fileName = (string)vt;
                        fileName = Path.GetFileName(fileName);
                    }
                }
                
                if (fileName.Length > 0) {
                    throw new Exception(SR.GetString(SR.DESIGNERLOADERIVsTextStreamNotFound, fileName));
                }
                else {
                    throw new Exception(SR.GetString(SR.DESIGNERLOADERIVsTextStreamNotFoundGeneric));
                }
            }

            this.hierarchy = (IVsHierarchy)pHier;
            this.itemid = itemid;
            this.serviceProvider = new ServiceProvider((NativeMethods.IOleServiceProvider)pSp);
            
            ShellTextBuffer shellBuffer = new ShellTextBuffer((IVsTextStream)punkDocData, serviceProvider);

            shellBuffer.BufferSetDirty += new EventHandler(this.OnTextBufferSetDirty);

            // The shell's text buffer implementation may not have any text loaded into it yet.
            // If this is the case, then we just hook an event.
            //
            if (!shellBuffer.IsLoaded) {
                flags[StateBufferReady] = false;
                shellBuffer.Loaded += new EventHandler(this.OnTextBufferLoaded);
            }
            else {
                flags[StateBufferReady] = true;
            }
            
            // Sync RDT events so we can track hierarchy and itemid changes.
            //
            Debug.Assert(!flags[StateRDTEventsAdvised], "Someone calling initialize twice?");
            IVsRunningDocumentTable rdt = (IVsRunningDocumentTable)GetService(typeof(IVsRunningDocumentTable));
            if (rdt != null) {
                rdt.AdviseRunningDocTableEvents(this, out rdtEventsCookie);
                flags[StateRDTEventsAdvised] = true;
            }
            
            this.initialDocData = punkDocData;
            this.textBuffer = shellBuffer;
        }

        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.IVSMDDesignerLoader.SetBaseEditorCaption"]/*' />
        /// <devdoc>
        ///      Sets the base editor caption for the VS editor window.  This can be
        ///      called to override the base editor caption, which is "[Design]".
        /// </devdoc>
        void IVSMDDesignerLoader.SetBaseEditorCaption(string caption) {
            baseEditorCaption = caption;
        }
    
        void IVsRunningDocTableEvents.OnAfterFirstDocumentLock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
        }
        void IVsRunningDocTableEvents.OnBeforeLastDocumentUnlock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
            if (IsDesignerDocument(docCookie) && (dwRDTLockType & __VSRDTFLAGS.RDT_Unlock_NoSave) != __VSRDTFLAGS.RDT_NoLock && codeLoader != null) {
                codeLoader.IsDirty = false;

                // Make sure we do not prompt to save the resx file, since the
                // the last lock on it from our side has been released.
                //
                if (docDataHash != null) {
                    foreach(DocDataHolder holder in docDataHash.Values) {
                        holder.SavePrompt = false;
                    }
                }
            }
        }
        void IVsRunningDocTableEvents.OnAfterSave( int docCookie) {
            ((IVsRunningDocTableEvents2)this).OnAfterSave(docCookie);
        }
        void IVsRunningDocTableEvents.OnAfterAttributeChange( int docCookie,  __VSRDTATTRIB grfAttribs) {
        }
        void IVsRunningDocTableEvents.OnBeforeDocumentWindowShow( int docCookie,  bool fFirstShow,  IVsWindowFrame pFrame) {
        }
        void IVsRunningDocTableEvents.OnAfterDocumentWindowHide( int docCookie,  IVsWindowFrame pFrame) {
        }
        
        void IVsRunningDocTableEvents2.OnAfterFirstDocumentLock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
        }
        void IVsRunningDocTableEvents2.OnBeforeLastDocumentUnlock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
        }
        void IVsRunningDocTableEvents2.OnAfterSave( int docCookie) {
            // Is this cookie our document?  If so, then also save all related doc datas.
            //
            if (docDataHash != null && IsDesignerDocument(docCookie)) {
                foreach(DocDataHolder holder in docDataHash.Values) {
                    holder.Save();
                }
            }
        }
        void IVsRunningDocTableEvents2.OnAfterAttributeChange( int docCookie,  __VSRDTATTRIB grfAttribs) {
        }
        void IVsRunningDocTableEvents2.OnBeforeDocumentWindowShow( int docCookie,  bool fFirstShow,  IVsWindowFrame pFrame) {
        }
        void IVsRunningDocTableEvents2.OnAfterDocumentWindowHide( int docCookie,  IVsWindowFrame pFrame) {
        }
        
        // All these sinks for this one method.  Aren't COM events great?
        void IVsRunningDocTableEvents2.OnAfterAttributeChangeEx( int docCookie, __VSRDTATTRIB grfAttribs, 
            IVsHierarchy pHierOld, int itemidOld, string pszMkDocumentOld, 
            IVsHierarchy pHierNew, int itemidNew, string pszMkDocumentNew) {

            // We stash the itemid and hierarchy of the object we're working on.  We must keep it in sync
            // should the object move while we're open.
            //
            if ((grfAttribs & __VSRDTATTRIB.RDTA_ItemID) != 0 && itemidOld == itemid) {
                // This one's really simple.  We just need to have this around from time to time.
                itemid = itemidNew;
            }
            
            // If the file name changes, we must scan our doc data holder list and update the
            // key.
            //
            if (docDataHash != null && pszMkDocumentOld != null && pszMkDocumentNew != null && !pszMkDocumentOld.Equals(pszMkDocumentNew)) {
                object docData = docDataHash[pszMkDocumentOld];
                if (docData != null) {
                    docDataHash[pszMkDocumentNew] = docData;
                    docDataHash.Remove(pszMkDocumentOld);
                }
            }
            
            bool hierarchyChange = (grfAttribs & __VSRDTATTRIB.RDTA_Hierarchy) != 0 && hierarchy == pHierOld;
            bool reload = hierarchyChange; 

            if (!reload && (grfAttribs & __VSRDTATTRIB.RDTA_DocDataReloaded) != 0 && IsDesignerDocument(docCookie)) 
            {
                // reload if we're not suppressing the DocDataReload...
                // otherwise just decrement the value.
                //
                if (supressReloadWithDocData == 0) {
                    reload = true;
                }
                else {
                    supressReloadWithDocData--;
                }
            }
            
            if (hierarchyChange) {
                // This one's a lot harder.  If the type loader has already been created, we've
                // got to perform a document reload (not all types are available to all hierarchies)
                hierarchy = pHierNew;
                
                if (typeLoader != null) {
                    typeLoader.AssemblyObsolete -= new AssemblyObsoleteEventHandler(this.OnAssemblyObsolete);
                    typeLoader = null;
                }
            }

            if (reload) {

                if (host != null && flags[StateLoaded]) {
                    InternalReload(true);
                }
            }
        }
        
        /// <devdoc>
        ///     This extender provider provides a default set of modifiers to use for
        ///     variables.
        /// </devdoc>
        [ProvideProperty("DefaultModifiers", typeof(IComponent))]
        private class DefaultModifiersProvider : IExtenderProvider {
        
            private MemberAttributes modifiers;
        
            public DefaultModifiersProvider(__VSDESIGNER_FUNCTIONVISIBILITY visibility) {
            
                modifiers = MemberAttributes.Private;
                
                switch(visibility) {
                    case __VSDESIGNER_FUNCTIONVISIBILITY.VSDFV_Private:
                        modifiers = MemberAttributes.Private;
                        break;
                        
                    case __VSDESIGNER_FUNCTIONVISIBILITY.VSDFV_Friend:
                        modifiers = MemberAttributes.Assembly;
                        break;
                        
                    case __VSDESIGNER_FUNCTIONVISIBILITY.VSDFV_Public:
                        modifiers = MemberAttributes.Public;
                        break;
                        
                    default:
                        Debug.Fail("Unknown function visibility: " + visibility);
                        break;
                }
            }
            
            /// <include file='doc\DefaultModifiersProvider.uex' path='docs/doc[@for="DefaultModifiersProvider.CanExtend"]/*' />
            /// <devdoc>
            ///     Determines if ths extender provider can extend the given object.  We extend
            ///     all objects, so we always return true.
            /// </devdoc>
            public bool CanExtend(object o) {
                return (o is IComponent);
            }

            /// <include file='doc\DefaultModifiersProvider.uex' path='docs/doc[@for="DefaultModifiersProvider.GetDefaultModifiers"]/*' />
            /// <devdoc>
            ///     This is an extender property that we offer to all components
            ///     on the form.  It implements the "Modifiers" property, which
            ///     is an enum represneing the "public/protected/private" scope
            ///     of a component.
            /// </devdoc>
            [
            DesignOnly(true),
            Browsable(false)
            ]
            public MemberAttributes GetDefaultModifiers(IComponent comp) {
                return modifiers;
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.DocDataHolder"]/*' />
        /// <devdoc>
        ///     A holder for a live vs doc data.  This holder object maintains the edit lock (passed into the ctor).
        /// </devdoc>
        private class DocDataHolder : IVsDocumentLockHolder, IDisposable, IVsTextStreamEvents {
            
            private BaseDesignerLoader loader;
            private IVsRunningDocumentTable rdt;
            private object docData;
            private int editLock;
            private int holderLock;
            private NativeMethods.ConnectionPointCookie textEventCookie;
            private bool changingText;
            private bool savePrompt = true;
            private object cache;
            private FileAccess access;
            
            public DocDataHolder(BaseDesignerLoader loader, IVsRunningDocumentTable rdt, object docData, int editLock, FileAccess access) {
                this.loader = loader;
                this.rdt = rdt;
                this.docData = docData;
                this.editLock = editLock;
                this.access = access;
                int hr = rdt.RegisterDocumentLockHolder(0, editLock, this, ref holderLock);
                
                // If this fails, it's not the end of the world, but our file saving will be a bit screwy (multiple save dialogs).
                //
                Debug.Assert(NativeMethods.Succeeded(hr), "Failed to register us as a document lock holder.");
            }

            public FileAccess Access
            {
                get
                {
                    return access;
                }
                set 
                {
                    access = value;
                }
            }
            
            // General purpose cache object.  Typically, a doc data holder is used
            // underneath another object, such as a resource reader or config file.
            // This cache slot allows storage of such data onto the holder so it
            // doesn't have to be recreated all the time.
            public object Cache {
                get {
                    return cache;
                }
                set {
                    cache = value;
                }
            }
            
            public bool ChangingText {
                get {
                    return changingText;
                }
                set {
                    changingText = value;
                }
            }
            
            public object DocData {
                get {
                    return docData;
                }
            }

            public string Name {
                get {
                    string docName = string.Empty;
                    __VSRDTFLAGS flags = 0;
                    int readLocks = 0;
                    int editLocks = 0;
                    IVsHierarchy pHier = null;
                    int docItemid = 0;
                    object pDocData = null;
                    
                    int hr = rdt.GetDocumentInfo(editLock, ref flags, ref readLocks, ref editLocks, ref docName, ref pHier, ref docItemid, ref pDocData);
                    if (NativeMethods.Succeeded(hr)) {
                        docName = Path.GetFileName(docName);
                    }
                    
                    return docName;
                }
            }            
            
            public bool SavePrompt {
                get {
                    return this.savePrompt;
                }

                set {
                    this.savePrompt = value;
                }
            }

            public IVsTextStream TextStream {
                get {
                    IVsTextStream textStream = docData as IVsTextStream;
                    
                    if (textStream == null) {
                        IVsTextBufferProvider prov = docData as IVsTextBufferProvider;
                        if (prov != null) {
                            textStream = prov.GetTextBuffer() as IVsTextStream;
                        }
                    }
                    
                    // If someone asked for our text stream, make sure we listen to events on it so we
                    // know when to reload.
                    //
                    if (textStream != null && textEventCookie == null) {
                        textEventCookie = new NativeMethods.ConnectionPointCookie(textStream, this, typeof(IVsTextStreamEvents));
                    }
                    
                    return textStream;
                }
            }
            
            public void Dispose() {
                if (rdt != null) {
                
                    __VSRDTFLAGS flags = __VSRDTFLAGS.RDT_EditLock;
                    flags |= (SavePrompt) ? __VSRDTFLAGS.RDT_Unlock_PromptSave : __VSRDTFLAGS.RDT_Unlock_NoSave;
                    
                    // We unlock without saving here -- all saves should have saved by now.
                    if (editLock != 0) {
                        rdt.UnlockDocument(flags, editLock);
                        editLock = 0;
                    }
                    
                    if (holderLock != 0) {
                        rdt.UnregisterDocumentLockHolder(holderLock);
                        holderLock = 0;
                    }
                    
                    if (textEventCookie != null){
                        textEventCookie.Disconnect();
                        textEventCookie = null;
                    }
                    
                    rdt = null;
                    docData = null;
                }
            }
            
            public void Save() {
                SavePrompt = false;

                if (rdt != null && editLock != 0) {
                    string docName = null;
                    __VSRDTFLAGS flags = 0;
                    int readLocks = 0;
                    int editLocks = 0;
                    IVsHierarchy pHier = null;
                    int itemid = 0;
                    object pDocData = null;
                    
                    int hr = rdt.GetDocumentInfo(editLock, ref flags, ref readLocks, ref editLocks, ref docName, ref pHier, ref itemid, ref pDocData);
                    Debug.Assert(NativeMethods.Succeeded(hr), "GetDocumentInfo failed for a document we own a lock on.");
                    if (NativeMethods.Succeeded(hr)) {
                        rdt.SaveDocuments(0, pHier, itemid, editLock);
                    }
                }
            }

            public void SetDirty() {
                SavePrompt = true;

                if (docData is IVsTextBuffer) {
                    IVsTextBuffer buffer = (IVsTextBuffer)docData;
                    int state = buffer.GetStateFlags();
                    state |= _bufferstateflags.BSF_MODIFIED;
                    buffer.SetStateFlags(state);
                }
            }
            
            void IVsDocumentLockHolder.ShowDocumentHolder() {
                IVsWindowFrame frame = (IVsWindowFrame)loader.GetService(typeof(IVsWindowFrame));
                if (frame != null) {
                    frame.Show();
                }
            }
            
            void IVsDocumentLockHolder.CloseDocumentHolder(int dwSaveOptions) {
                // This means we are to close our window frame because someone
                // has requested that one of our child documents close.  So, 
                // let's do it.
                //
                IVsWindowFrame frame = (IVsWindowFrame)loader.GetService(typeof(IVsWindowFrame));
                if (frame != null) {
                    frame.CloseFrame(dwSaveOptions);
                }
                
                // After the frame has closed, we should have been disposed!
                Debug.Assert(rdt == null, "Closing the frame should have disposed us!");
                
                // If the assert above fires, then we probably still have a lock.  Make
                // sure that we release it.
                //
                if (editLock != 0 && rdt != null) {
                    rdt.UnlockDocument(__VSRDTFLAGS.RDT_EditLock | (__VSRDTFLAGS)dwSaveOptions, editLock);
                    editLock = 0;
                }
            }
            
            /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsTextStreamEvents.OnChangeStreamAttributes"]/*' />
            /// <devdoc>
            ///     Notification from VS that something in the text has changed.
            /// </devdoc>
            void IVsTextStreamEvents.OnChangeStreamAttributes(int iPos, int iLength) {
            }
    
            /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsTextStreamEvents.OnChangeStreamText"]/*' />
            /// <devdoc>
            ///     Notification from VS that something in the text has changed.
            /// </devdoc>
            void IVsTextStreamEvents.OnChangeStreamText(int iPos, int iOldLen, int iNewLen, int fLast) {
                if (!changingText) {
                    // We are not the ones who change the text.  Ask our loader to reload.
                    if (!((IDesignerLoaderService)loader).Reload()) {
                        IUIService uis = (IUIService)loader.GetService(typeof(IUIService));
                        if (uis != null) {
                            uis.ShowMessage(SR.GetString(SR.DESIGNERLOADERManualReload, Name));
                        }
                    }
                    else {
                        SavePrompt = true;
                    }
                }
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.DocDataTextReader"]/*' />
        /// <devdoc>
        ///     A text reader object that sits on top of a VS doc data.  It is essentially a "snapshot"
        ///     of the doc data -- it reads it on demand and then keeps the data internally.
        /// </devdoc>
        private class DocDataTextReader : TextReader {
            private IVsTextStream textStream;
            private int position;
            private string text;
        
            public DocDataTextReader(DocDataHolder docData) {
            
                this.textStream = docData.TextStream;

                if (this.textStream == null) {
                    string fileName = docData.Name;
                
                    if (fileName.Length > 0) {
                        throw new Exception(SR.GetString(SR.DESIGNERLOADERIVsTextStreamNotFound, fileName));
                    }
                    else {
                        throw new Exception(SR.GetString(SR.DESIGNERLOADERIVsTextStreamNotFoundGeneric));
                    }
                }

                this.position = 0;
                this.text = null;
            }

            public bool IsEmpty {
                get {
                    IVsTextBuffer buffer = textStream as IVsTextBuffer;
                    if (buffer != null) {
                        int size;
                        
                        buffer.GetSize(out size);
                        return size == 0;
                    }
                    return true;
                }
            }
            
            private string Text {
                get {
                    if (textStream == null) {
                        throw new InvalidOperationException();
                    }
                    if (text == null) {
                        int len;
                        textStream.GetSize(out len);
                        IntPtr buffer = Marshal.AllocCoTaskMem((len + 1) * 2);
            
                        try {
                            textStream.GetStream(0, len, buffer);
                            text = Marshal.PtrToStringUni(buffer);
                        }
                        finally {
                            Marshal.FreeCoTaskMem(buffer);
                        }
                    }
                    return text;
                }
            }
            
            public override void Close() {
                textStream = null;
            }
            
            public override int Peek() {
                if (position < Text.Length) {
                    return Text[position];
                }
                return -1;
            }
            
            public override int Read() {
                if (position < Text.Length) {
                    return Text[position++];
                }
                return -1;
            }
            
            public override int Read(char[] buffer, int index, int count) {
                int charsRead = 0;
                string s = Text;
                
                while (position < s.Length && (count-- > 0)) {
                    buffer[index + charsRead++] = s[position++];
                }
                
                return charsRead;
            }
        }
        
        /// <include file='doc\BaseDesignerLoader.uex' path='docs/doc[@for="BaseDesignerLoader.DocDataTextWriter"]/*' />
        /// <devdoc>
        ///     A text writer object that sits on top of a VS doc data.  This just contains a string
        ///     builder that is used to write the text into.  At close time this text is saved
        ///     en masse to the text stream.
        /// </devdoc>
        private class DocDataTextWriter : TextWriter {
            private IVsTextStream textStream;
            private StringBuilder builder;
            private DocDataHolder docData;
            private int position;
        
            public DocDataTextWriter(DocDataHolder docData) {
            
                this.docData = docData;
                this.textStream = docData.TextStream;

                if (this.textStream == null) {
                    string fileName = docData.Name;
                
                    if (fileName.Length > 0) {
                        throw new Exception(SR.GetString(SR.DESIGNERLOADERIVsTextStreamNotFound, fileName));
                    }
                    else {
                        throw new Exception(SR.GetString(SR.DESIGNERLOADERIVsTextStreamNotFoundGeneric));
                    }
                }
                
                this.builder = new StringBuilder();
                this.position = 0;
            }
            
            public override Encoding Encoding {
                get {
                    return UnicodeEncoding.Default;
                }
            }
                       
            public override void Close() {
                if (textStream != null) {
                    Flush();
                    textStream = null;
                }
            }
            
            public override void Flush() {
                
                if (textStream == null) {
                    throw new InvalidOperationException();
                }
                
                // Replace the contents of the text stream with the contents of our string
                // builder.  We keep track of how much we have sent to the text stream and we
                // clear the string builder for a true "flush"
                //
                
                if (builder.Length > 0) {
                    int len;
                    textStream.GetSize(out len);
                    string text = builder.ToString();
                    builder.Length = 0;
                    
                    // We guard actual changes here because we will reload the desigenr
                    // if outside changes were made.
                    //
                    bool wasChanging = docData.ChangingText;
                    docData.ChangingText = true;
                    
                    try {
                        textStream.ReplaceStream(position, len - position, text, text.Length);
                    }
                    finally {
                        docData.ChangingText = wasChanging;
                    }
                    
                    position += text.Length;
                }
            }
            
            public override void Write(char ch) {
                builder.Append(ch);
            }
            
            public override void Write(string s) {
                builder.Append(s);
            }
        }

        /// <devdoc>
        ///     This is an undo unit we use to wrap our large designer
        ///     flush in a warning so the user doesn't undo it all
        ///     and lose a ton of work.
        /// </devdoc>
        private class WarningUndoUnit : IOleParentUndoUnit, IOleUndoUnit {

            private ArrayList childUnits;
            private IOleParentUndoUnit openParent;
            private IServiceProvider provider;
            private string description;
            private bool redo;

            internal WarningUndoUnit(IServiceProvider provider, string description) {
                this.provider = provider;
                this.description = description;
            }
            
            int IOleParentUndoUnit.Do(IOleUndoManager pUndoManager) {

                if (childUnits != null) {
                    bool newRedo = !redo;

                    if (!redo) {
                        // Warn the user he is about to make a serious
                        // mistake
                        //
                        IVsUIShell uishell = (IVsUIShell)provider.GetService(typeof(IVsUIShell));

                        if (uishell != null) {
                            Guid guid =Guid.Empty;
                            if ((DialogResult)uishell.ShowMessageBox(0, ref guid, null, 
                                                       SR.GetString(SR.DESIGNERLOADERUndoWarning), 
                                                       null, 0, (int)MessageBoxButtons.YesNo, 
                                                       1, /* OLEMSGDEFAULTBUTTON2 */
                                                       3 /* OLEMSGICON_EXCLAMATION */, false) != DialogResult.Yes) {
                                return NativeMethods.UNDO_E_CLIENTABORT;
                            }
                        }
                        else {
                            if (MessageBox.Show(null, SR.GetString(SR.DESIGNERLOADERUndoWarning), null, MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button2) != DialogResult.Yes) {
                                return NativeMethods.UNDO_E_CLIENTABORT;
                            }
                        }
                    }

                    // Here's how it works.  We open a new undo unit
                    // on the redo stack.  Then, we save off the set
                    // of children and walk through them in reverse
                    // order.  Each child adds itself to the redo
                    // stack, which reacreates childUnits and adds
                    // units to it.  As we are traversing in reverse
                    // order, this always reverses the order of elements
                    // in childUnits, automatically toggling between
                    // undo and redo states.
                    //
                    ArrayList undoChildren = childUnits;
                    childUnits = null;

                    if (pUndoManager != null) {
                        pUndoManager.Open(this);
                    }

                    try {
                        for (int i = undoChildren.Count - 1; i >= 0; i--) {
                            ((IOleUndoUnit)undoChildren[i]).Do(pUndoManager);
                            redo = newRedo;
                        }
                    }
                    finally {
                        if (pUndoManager != null) {
                            // The undo rules state that we commit if at least
                            // one unit succeeded.  This will be the case when
                            // redo == newRedo.
                            pUndoManager.Close(this, (redo == newRedo));
                        }
                    }
                }

                return NativeMethods.S_OK;
            }
            
            string IOleParentUndoUnit.GetDescription() {
                return description;
            }
            
            int IOleParentUndoUnit.GetUnitType(ref System.Guid pClsid, out int plID) {
                plID = 0;
                return NativeMethods.E_NOTIMPL;
            }
            
            void IOleParentUndoUnit.OnNextAdd() {
            }
            
            int IOleParentUndoUnit.Open(IOleParentUndoUnit pPUU) {
                if (this.openParent == null) {
                    this.openParent = pPUU;
                } else {
                    this.openParent.Open(pPUU);
                }
                return NativeMethods.S_OK;
            }
            
            int IOleParentUndoUnit.Close(IOleParentUndoUnit pPUU, bool fCommit) {
            
                if (this.openParent == null) {
                    return NativeMethods.S_FALSE;
                }
            
                int hr = openParent.Close(pPUU, fCommit);
                if (hr != NativeMethods.S_FALSE) {
                    return hr;
                }
            
                if (pPUU != this.openParent) {
                    return(NativeMethods.E_INVALIDARG);
                }
            
                openParent = null;

                if (fCommit) {
                    ((IOleParentUndoUnit)this).Add((IOleUndoUnit)pPUU);
                }

                return NativeMethods.S_OK;
            }
            
            int IOleParentUndoUnit.Add(IOleUndoUnit pUU) {
                if (this.childUnits == null) {
                    this.childUnits = new ArrayList();
                }
                this.childUnits.Add(pUU);
                if (this.childUnits.Count > 1) {
                    ((IOleUndoUnit)(this.childUnits[this.childUnits.Count - 2])).OnNextAdd();
                }
                return NativeMethods.S_OK;
            }
            
            int IOleParentUndoUnit.FindUnit(IOleUndoUnit pUU) {
                if (childUnits == null) {
                    return NativeMethods.S_FALSE;
                }
                foreach (IOleUndoUnit undoUnit in childUnits) {
                    if (undoUnit == pUU) {
                        return NativeMethods.S_OK;
                    }
                    IOleParentUndoUnit parentUnit = undoUnit as IOleParentUndoUnit;
                    if (parentUnit != null && NativeMethods.S_OK == parentUnit.FindUnit(pUU)) {
                        return NativeMethods.S_OK;
                    }
                }
                return NativeMethods.S_FALSE;
            }
            
            int IOleParentUndoUnit.GetParentState() {
                if (this.openParent != null) {
                    return this.openParent.GetParentState();
                } else {
                    return 0; // UAS_NORMAL
                }
            }
            
            int IOleUndoUnit.Do(IOleUndoManager pUndoManager) {
                return ((IOleParentUndoUnit)this).Do(pUndoManager);
            }
            
            string IOleUndoUnit.GetDescription() {
                return ((IOleParentUndoUnit)this).GetDescription();
            }
            
            int IOleUndoUnit.GetUnitType(ref System.Guid pClsid, out int plID) {
                return ((IOleParentUndoUnit)this).GetUnitType(ref pClsid, out plID);
            }
            
            void IOleUndoUnit.OnNextAdd() {
                ((IOleParentUndoUnit)this).OnNextAdd();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\designerserializationobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerSerializationObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {

    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Resources;
    using System.Runtime.Serialization;
    
    /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject"]/*' />
    /// <devdoc>
    ///     This object is the object used as a serialization object for
    ///     the IDesignerSerializationService.  It maintains a collection of objects,
    ///     and can serialize and deserialize them as needed.  If the objects are 
    ///     components, they will be serialized using the code dom serializer.  Otherwise,
    ///     we will use standard object serialization.
    ///
    ///     How does this work?  DesignerSerializationObject wears many hats.  When asked to 
    ///     serialize a set of components, it creates a CodeTypeDeclaration that derives
    ///     from itself, and then hands this off to the generic CodeDom serializers.  When
    ///     asked to create or retrieve an instance of this DesignerSerializationObject
    ///     this will look into the current designer host and use it's root component as
    ///     the instance.  This DesignerSerializationObject is sited by a special container.
    ///     This container contains all the components we wish to serialize, but we do NOT
    ///     remove these components from their original container.  We are making some 
    ///     fragile assumptions on the RootCodeDomSerializer here, but it should be very
    ///     rare for anyone to actually replace it, and we can document this oddity.
    ///
    ///     DesignerSerializationObject also implements IDesignerSerializationManager, and it
    ///     delegates to the real serialization manager on occasion.  It also implements
    ///     IResourceService to save off resources into a hashtable for easy and cheap
    ///     serialization.
    ///     
    /// </devdoc>
    [Serializable(), DesignerSerializer(typeof(DSOCodeDomSerializer), typeof(CodeDomSerializer))]
    internal sealed class DesignerSerializationObject : 
        Component, 
        IDesignerSerializationManager, 
        IResourceService, 
        ISerializable, 
        IContainer {



        private static TraceSwitch traceDSO = new TraceSwitch("DesignerSerializationObject", "Trace DesignerSerializationObject");

        #if DEBUG
            internal static void GenerateCodeFromSerializedData(object data) {
                
                if (data == null || !traceDSO.TraceVerbose) {
                    return;
                }

                if (data is CodeTypeDeclaration) {

                    ICodeGenerator codeGenerator = new Microsoft.CSharp.CSharpCodeProvider().CreateGenerator();
                    StringWriter sw = new StringWriter();
                    Debug.WriteLine("********************** Serialized Data Block ********************************");      
                    Debug.Indent();
                    codeGenerator.GenerateCodeFromType((CodeTypeDeclaration)data, sw, null);

                    // spit this line by line so it respects the indent.
                    // 
                    StringReader sr = new StringReader(sw.ToString());
                    for (string ln = sr.ReadLine(); ln != null;ln = sr.ReadLine()) {
                        Debug.WriteLine(ln);
                    }
                    Debug.Unindent();
                    Debug.WriteLine("********************** End Serialized Data Block ********************************");      
                }
            }
        #endif

    
        // This is the "real" designer serialization manager.  During serialization / deserialization, we may
        // refer to this, but we never ever pass it to the serializers.  Instead, we pass ourselves, and we act
        // as a delegator to this guy when we need it.
        private IDesignerSerializationManager manager;
        private CodeDomSerializer rootSerializer;
        
        // This is our collection of objects.  The contents of this are complex.  If we
        // are not a serialized object, this contains a copy of the original collection.
        // If we are a deserialized object, this may either contain a reconstituted
        // collection or it may contain an array of just objects, no components.  The latter case
        // can happen if we deserialize from ISerializable and the original collection
        // contained components.  For compoents, we serialize them as code so the
        // code field will contain the code.
        private object[]                objects;    // this gets serialized
        
        // This will be the code that was used during serialization or deserialization of
        // components.  It is also an identifier to indicate whether the objects
        // array is complete or needs additional processing.
        private object     code;                    // this gets serialized

        private ResolveNameEventHandler resolveNameEventHandler;
        private EventHandler            serializationCompleteEventHandler;
        private ArrayList               designerSerializationProviders;
        private Hashtable               instancesByName;
        private Hashtable               namesByInstance;
        private Hashtable               designTimeProperties;
        private ContextStack            contextStack;
        private ArrayList               containerComponents;

        private DsoResourceManager         resourceManager;

        private IComponentChangeService    componentChangeSvc;
        private Hashtable                  addedComps;
        
        // The string names we use for our serialized state
        //
        private const string serializableObjects = "SerializableObjects";  // an ArrayList of serialized data (not components)
        private const string componentCode       = "ComponentCode";        // a string consisting of C# code for serialized components.
        private const string componentResources  = "ComponentResources";   // a hashtable consisting of resource data for the code.
        private const string designTimeProps     = "DesigntimeProps";

        public DesignerSerializationObject(SerializationInfo info, StreamingContext context) {
            ArrayList objectList = (ArrayList)info.GetValue(serializableObjects, typeof(ArrayList));
            code = info.GetValue(componentCode, typeof(object));
            Hashtable resourceData = (Hashtable)info.GetValue(componentResources, typeof(Hashtable));
            if (resourceData != null) {
                resourceManager = new DsoResourceManager(resourceData);
            }
            this.designTimeProperties = (Hashtable)info.GetValue(designTimeProps, typeof(Hashtable));
            objects = objectList.ToArray();
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.DesignerSerializationObject"]/*' />
        /// <devdoc>
        ///     Stores the collection of objects into our serialization object.
        ///     The contents of the objects are not actually serialized until
        ///     this object is serialized.
        /// </devdoc>
        public DesignerSerializationObject(IDesignerSerializationManager manager, CodeDomSerializer rootSerializer, ICollection objects) {
            this.manager = manager;
            this.rootSerializer = rootSerializer;
            this.code = null;
            this.objects = new object[objects.Count];
            objects.CopyTo(this.objects, 0);
        }

        ~DesignerSerializationObject(){

        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.DataTypeName"]/*' />
        /// <devdoc>
        ///     The name of the type we're creating.
        /// </devdoc>
        private string DataTypeName {
            get {
                return "DesignerSerializationComponent";
            }
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.Deserialize"]/*' />
        /// <devdoc>
        ///     Returns the original collection of objects, deserializing
        ///     them from saved state if necessary.
        /// </devdoc>
        public ICollection Deserialize(IDesignerSerializationManager manager, CodeDomSerializer rootSerializer) {
        
            // If we have a set of objects, and we don't have 
            // any code that needs to be deserialized, then
            // we're done.
            //
            if (objects != null && code == null) {
                return objects;
            }
            
            // If we need to deserialize, we just ask the real serialization manager for
            // the root serializer, and we let it party on the code.  The result is
            // going to be a (hopefully) non-null containerComponents object whose
            // values contain all the components we were interested in.
            //
            this.manager = manager;
            ArrayList components = null;
            
            try {
                #if DEBUG
                if (traceDSO.TraceVerbose) {
                    Debug.WriteLine("Deserializing:");
                    Debug.Indent();
                    GenerateCodeFromSerializedData(code);
                    Debug.Unindent();
                }
                #endif
                rootSerializer.Deserialize(this, code);
            }
            finally {
                if (serializationCompleteEventHandler != null) {
                    try {
                        serializationCompleteEventHandler(this, EventArgs.Empty);
                    }
                    catch {}
                }
                
                this.manager = null;
                resolveNameEventHandler = null;
                serializationCompleteEventHandler = null;
                designerSerializationProviders = null;
                instancesByName = null;
                namesByInstance = null;
                contextStack = null;
                components = containerComponents;
                containerComponents = null;
            }
            
            // If we got some compnents into our container, get 'em out!
            //
            if (components != null) {
            
                // The designer host's root object will be sitting in this
                // container, because the root serializer believes that it
                // created an instance of it.  Remove this object here because
                // it is not actually a part of the serialization work.
                //
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                if (host != null && components.Contains(host.RootComponent)) {
                    components.Remove(host.RootComponent);
                    
                }
                
                object[] finalObjects = new object[objects.Length + components.Count];
                objects.CopyTo(finalObjects, 0);
                components.CopyTo(finalObjects, objects.Length);
                objects = finalObjects;

                if (host != null) {
                    this.componentChangeSvc = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
                    if (this.componentChangeSvc != null) {
                        this.componentChangeSvc.ComponentAdded += new ComponentEventHandler(this.OnComponentAdded);
                        addedComps = new Hashtable();
                        foreach(IComponent ic in components) {
                            addedComps[ic.Site.Name] = ic;
                        }
                    }
                }
            }                          
            
            return objects;
        }

        private void OnComponentAdded(object sender, ComponentEventArgs ce) {

            if (addedComps == null || !addedComps.ContainsValue(ce.Component)) {
                return;
            }

            string oldName = null;

            // now find the key for the component
            //
            foreach (DictionaryEntry de in addedComps) {
                if (de.Value == ce.Component) {
                    PropertyDescriptorCollection props = TypeDescriptor.GetProperties(ce.Component, new Attribute[]{DesignOnlyAttribute.Yes});
                    oldName = (string)de.Key;
                    foreach (DictionaryEntry designEntry in designTimeProperties) {
                        string key = (string)designEntry.Key;
                        int dot = key.IndexOf('.');
                        if (dot == -1) {
                            Debug.Fail("Bad key in design time props: '" + key + "'");
                            continue;
                        }

                        // make sure we've got the right design entry.
                        if (key.Substring(0, dot) != oldName) {
                            continue;
                        }

                        string propName = key.Substring(dot + 1);
                        PropertyDescriptor prop = props[propName];
                        if (prop != null) {
                            try {
                                prop.SetValue(ce.Component, designEntry.Value);
                            }
                            catch{
                                // if that didn't work, so be it.
                            }
                            
                        }
                    }
                }
            } 

            // if we processed this guy, remove it from the list.
            //
            addedComps.Remove(oldName);
            if (addedComps.Count == 0 && componentChangeSvc != null) {
                this.componentChangeSvc.ComponentAdded -= new ComponentEventHandler(this.OnComponentAdded);
                this.componentChangeSvc = null;
                addedComps = null;
            }
        }

        private Hashtable SerializeDesignTimeProperties(IDesignerSerializationManager manager, ICollection objectList) {
            Hashtable t = new Hashtable();
            Attribute[] dtAttrs = new Attribute[]{DesignOnlyAttribute.Yes};
            foreach (object o in objectList) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(o, dtAttrs);
                string name = manager.GetName(o);
                foreach (PropertyDescriptor prop in props) {
                    string propName = name + "." + prop.Name;
                    object value = prop.GetValue(o); 

                    if (prop.ShouldSerializeValue(o) && (value == null || value.GetType().IsSerializable)) {
                        t[propName] = value;
                    }
                }
            }
            return t;
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.IContainer.Add"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.ComponentModel.IComponent'/> to the <see cref='System.ComponentModel.IContainer'/>
        /// at the end of the list.</para>
        /// </devdoc>
        void IContainer.Add(IComponent component) {
            ((IContainer)this).Add(component, null);
        }

        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.IContainer.Add1"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.ComponentModel.IComponent'/> to the <see cref='System.ComponentModel.IContainer'/>
        /// at the end of the list, and assigns a name to the component.</para>
        /// </devdoc>
        void IContainer.Add(IComponent component, String name) {
            if (name == null) {
                // Do nothing -- we only support adding named components
                return;
            }
            else {
                if (containerComponents == null) {
                    containerComponents = new ArrayList();
                    containerComponents.Add(component);
                }
                else {
                    bool found = false;
                    foreach(object o in containerComponents) {
                        if (o == component) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        containerComponents.Add(component);
                    }
                }
            }
            
            // We will provide a site ONLY if the component doesn't already have one.  We are
            // using IContainer solely to provide an object list, not to provide ownership.
            //
            if (component.Site == null) {
                component.Site = new SimpleSite(this, component, name);
            }
        }

        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.IContainer.Components"]/*' />
        /// <devdoc>
        /// <para>Gets all the components in the <see cref='System.ComponentModel.IContainer'/>.</para>
        /// </devdoc>
        ComponentCollection IContainer.Components {
            get {
                IComponent[] compArray;
                
                if (containerComponents == null) {
                    compArray = new IComponent[0];
                }
                else {
                    compArray = new IComponent[containerComponents.Count];
                    containerComponents.CopyTo(compArray, 0);
                }
                return new ComponentCollection(compArray);
            }
        }

        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.IContainer.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes a component from the <see cref='System.ComponentModel.IContainer'/>.</para>
        /// </devdoc>
        void IContainer.Remove(IComponent component) {
            if (containerComponents != null) {
                if (containerComponents.Contains(component)) {
                    containerComponents.Remove(component);
                }
                if (component.Site is SimpleSite) {
                    component.Site = null;
                }
            }
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.Context"]/*' />
        /// <devdoc>
        ///     The Context property provides a user-defined storage area
        ///     implemented as a stack.  This storage area is a useful way
        ///     to provide communication across serializers, as serialization
        ///     is a generally hierarchial process.
        /// </devdoc>
        ContextStack IDesignerSerializationManager.Context {
            get {
                if (contextStack == null) {
                    contextStack = new ContextStack();
                }
                return contextStack;
            }
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.Properties"]/*' />
        /// <devdoc>
        ///     The Properties property provides a set of custom properties
        ///     the serialization manager may surface.  The set of properties
        ///     exposed here is defined by the implementor of 
        ///     IDesignerSerializationManager.  
        /// </devdoc>
        PropertyDescriptorCollection IDesignerSerializationManager.Properties {
            get {
                return TypeDescriptor.GetProperties(this);
            }
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.ResolveName"]/*' />
        /// <devdoc>
        ///     ResolveName event.  This event
        ///     is raised when GetName is called, but the name is not found
        ///     in the serialization manager's name table.  It provides a 
        ///     way for a serializer to demand-create an object so the serializer
        ///     does not have to order object creation by dependency.  This
        ///     delegate is cleared immediately after serialization or deserialization
        ///     is complete.
        /// </devdoc>
        event ResolveNameEventHandler IDesignerSerializationManager.ResolveName {
            add {
                resolveNameEventHandler += value;
            }
            remove {
                resolveNameEventHandler -= value;
            }
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.SerializationComplete"]/*' />
        /// <devdoc>
        ///     This event is raised when serialization or deserialization
        ///     has been completed.  Generally, serialization code should
        ///     be written to be stateless.  Should some sort of state
        ///     be necessary to maintain, a serializer can listen to
        ///     this event to know when that state should be cleared.
        ///     An example of this is if a serializer needs to write
        ///     to another file, such as a resource file.  In this case
        ///     it would be inefficient to design the serializer
        ///     to close the file when finished because serialization of
        ///     an object graph generally requires several serializers.
        ///     The resource file would be opened and closed many times.
        ///     Instead, the resource file could be accessed through
        ///     an object that listened to the SerializationComplete
        ///     event, and that object could close the resource file
        ///     at the end of serialization.
        /// </devdoc>
        event EventHandler IDesignerSerializationManager.SerializationComplete {
            add {
                serializationCompleteEventHandler += value;
            }
            remove {
                serializationCompleteEventHandler -= value;
            }
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.AddSerializationProvider"]/*' />
        /// <devdoc>
        ///     This method adds a custom serialization provider to the 
        ///     serialization manager.  A custom serialization provider will
        ///     get the opportunity to return a serializer for a data type
        ///     before the serialization manager looks in the type's
        ///     metadata.  
        /// </devdoc>
        void IDesignerSerializationManager.AddSerializationProvider(IDesignerSerializationProvider provider) {
            if (designerSerializationProviders == null) {
                designerSerializationProviders = new ArrayList();
            }
            designerSerializationProviders.Add(provider);
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.CreateInstance"]/*' />
        /// <devdoc>                
        ///     Creates an instance of the given type and adds it to a collection
        ///     of named instances.  Objects that implement IComponent will be
        ///     added to the design time container if addToContainer is true.
        /// </devdoc>
        object IDesignerSerializationManager.CreateInstance(Type type, ICollection arguments, string name, bool addToContainer) {
        
            object instance = null;
            
            // We do some special casing here.  If the data type is our object type, then we 
            // do not create it but instead return the root component for the current designer.
            
            if (type == this.GetType()) {
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                instance = host.RootComponent;
            }

            if (typeof(ResourceManager).IsAssignableFrom(type)) {
                instance = this.resourceManager;
            }

            if (instance == null) {
                object[] argArray = null;
                
                if (arguments != null && arguments.Count > 0) {
                    argArray = new object[arguments.Count];
                    arguments.CopyTo(argArray, 0);
                }
                
                instance = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, argArray, null);
            }
                
            // If we have a name establish a name/value relationship
            // here.
            //
            if (name != null) {
                if (instancesByName == null) {
                    instancesByName = new Hashtable();
                    namesByInstance = new Hashtable();
                }
                
                instancesByName[name] = instance;
                namesByInstance[instance] = name;
                
                if (addToContainer && instance is IComponent) {
                    ((IContainer)this).Add((IComponent)instance, name);
                }
            }
            
            return instance;
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.GetInstance"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of a created object of the given name, or
        ///     null if that object does not exist.
        /// </devdoc>
        object IDesignerSerializationManager.GetInstance(string name) {
            object instance = null;
            
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            
            // Check our local nametable first
            //
            if (instancesByName != null) {
                instance = instancesByName[name];
            }
            
            // Check our own stuff here.
            //
            if (instance == null && name.Equals("components")) {
            
                // We implement the IContainer here
                //
                instance = this;
            }
            
            if (instance == null && resolveNameEventHandler != null) {
                ResolveNameEventArgs e = new ResolveNameEventArgs(name);
                resolveNameEventHandler(this, e);
                instance = e.Value;
            }

            // okay, fine, we're just a failure.  we can't do anything right.
            // ask the designer's actual manager if it's heard of this guy.
            //
            if (instance == null && manager != null) {
                instance = manager.GetInstance(name);
            }

            if (instance == null) {
                IReferenceService refSvs = (IReferenceService)((IServiceProvider)this).GetService(typeof(IReferenceService));
                if (refSvs != null) {
                    instance = refSvs.GetReference(name);
                }
            }
            
            return instance;
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.GetName"]/*' />
        /// <devdoc>
        ///     Retrieves a name for the specified object, or null if the object
        ///     has no name.
        /// </devdoc>
        string IDesignerSerializationManager.GetName(object value) {
            string name = null;
        
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            
            // Check our local nametable first
            //
            if (namesByInstance != null) {
                name = (string)namesByInstance[value];
            }
            
            if (name == null && value is IComponent) {
                ISite site = ((IComponent)value).Site;
                if (site != null) {
                    name = site.Name;
                }
            }
            
            return name;
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.GetSerializer"]/*' />
        /// <devdoc>
        ///     Retrieves a serializer of the requested type for the given
        ///     object type.
        /// </devdoc>
        object IDesignerSerializationManager.GetSerializer(Type objectType, Type serializerType) {


            object serializer = manager.GetSerializer(objectType, serializerType);

            if (objectType != null && serializer != null && typeof(ResourceManager).IsAssignableFrom(objectType) && typeof(CodeDomSerializer).IsAssignableFrom(serializerType)) {
                serializer = new ResourceManagerCodeDomSerializer(this, (CodeDomSerializer)serializer);   
            }
            
            if (objectType != null && serializer != null && typeof(ResourceManager).IsAssignableFrom(objectType) && typeof(CodeDomSerializer).IsAssignableFrom(serializerType)) {
                serializer = new ResourceManagerCodeDomSerializer(this, (CodeDomSerializer)serializer);   
            }
            
            // Designer serialization providers can override our metadata discovery.
            // Give them a chance.  Note that it's last one in wins.
            //
            if (designerSerializationProviders != null) {
                foreach(IDesignerSerializationProvider provider in designerSerializationProviders) {
                    object newSerializer = provider.GetSerializer(this, serializer, objectType, serializerType);
                    if (newSerializer != null) {
                        serializer = newSerializer;
                    }
                }
            }
            return serializer;
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.GetType"]/*' />
        /// <devdoc>
        ///     Retrieves a type of the given name.
        /// </devdoc>
        Type IDesignerSerializationManager.GetType(string typeName) {
        
            // Do a special case for our own type -- we substitute this as the root of the 
            // object graph.  However, the manager won't have a reference to us so it won't be able to 
            // find the type.
            //
            if (typeName.Equals(typeof(DesignerSerializationObject).FullName)) {
                return typeof(DesignerSerializationObject);
            }
            
            return manager.GetType(typeName);
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.RemoveSerializationProvider"]/*' />
        /// <devdoc>
        ///     Removes a previously added serialization provider.
        /// </devdoc>
        void IDesignerSerializationManager.RemoveSerializationProvider(IDesignerSerializationProvider provider) {
            if (designerSerializationProviders != null) {
                designerSerializationProviders.Remove(provider);
            }
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.ReportError"]/*' />
        /// <devdoc>
        ///     Reports a non-fatal error in serialization.  The serialization
        ///     manager may implement a logging scheme to alert the caller
        ///     to all non-fatal errors at once.  If it doesn't, it should
        ///     immediately throw in this method, which should abort
        ///     serialization.  
        ///     Serialization may continue after calling this function.
        /// </devdoc>
        void IDesignerSerializationManager.ReportError(object errorInformation) {
            // We just eat these
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.SetName"]/*' />
        /// <devdoc>
        ///     Provides a way to set the name of an existing object.
        ///     This is useful when it is necessary to create an 
        ///     instance of an object without going through CreateInstance.
        ///     An exception will be thrown if you try to rename an existing
        ///     object or if you try to give a new object a name that
        ///     is already taken.
        /// </devdoc>
        void IDesignerSerializationManager.SetName(object instance, string name) {
        
            if (instance == null) {
                throw new ArgumentNullException("instance");
            }
            
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            
            if (instancesByName == null) {
                instancesByName = new Hashtable();
                namesByInstance = new Hashtable();
            }
            
            if (instancesByName[name] != null) {
                throw new ArgumentException(SR.GetString(SR.SerializerNameInUse, name));
            }
            
            if (namesByInstance[instance] != null) {
                throw new ArgumentException(SR.GetString(SR.SerializerObjectHasName, name, (string)namesByInstance[instance]));
            }
            
            instancesByName[name] = instance;
            namesByInstance[instance] = name;
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.IResourceService.GetResourceReader"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Locates the resource reader for the specified culture and
        ///       returns it.</para>
        /// </devdoc>
        IResourceReader IResourceService.GetResourceReader(CultureInfo info) {
            if (resourceManager == null) {
                resourceManager = new DsoResourceManager();
            }
            return resourceManager;
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.IResourceService.GetResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>Locates the resource writer for the specified culture
        ///       and returns it. This will create a new resource for
        ///       the specified culture and destroy any existing resource,
        ///       should it exist.</para>
        /// </devdoc>
        IResourceWriter IResourceService.GetResourceWriter(CultureInfo info) {
            if (resourceManager == null) {
                resourceManager = new DsoResourceManager();
            }
            return resourceManager;
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.ISerializable.GetObjectData"]/*' />
        /// <devdoc>
        ///     Implements the save part of ISerializable.
        /// </devdoc>
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
        
            // check if we need to save any components as source code.
            //
            if (code == null && manager != null) {
                instancesByName = new Hashtable(objects.Length);
                namesByInstance = new Hashtable(objects.Length);
                
                foreach(object o in objects) {
                    if (o is IComponent && ((IComponent)o).Site != null && ((IComponent)o).Site.Name != null) {
                        IComponent comp = (IComponent)o;
                        ((IContainer)this).Add(comp, comp.Site.Name);
                        instancesByName[comp.Site.Name] = comp;
                        namesByInstance[comp] = comp.Site.Name;
                    }
                }
                
                if (containerComponents != null && containerComponents.Count > 0) {
                    IDesignerSerializationManager ourManager = (IDesignerSerializationManager)this;
                    
                    // Add our own object into the container.  This gives the root serializer something
                    // to serialize.
                    //
                    ((IContainer)this).Add(this, DataTypeName);
                    
                    // Now just ask the serializer to serialize.
                    //
                    try {
                        code = rootSerializer.Serialize(ourManager, this);

                       #if DEBUG
                            if (traceDSO.TraceVerbose) {
                                Debug.WriteLine("Serializing:");
                                Debug.Indent();
                                GenerateCodeFromSerializedData(code);
                                Debug.Unindent();
                            }
                        #endif
                        
                        designTimeProperties = SerializeDesignTimeProperties(manager, objects);
                    }                         
                    finally {
                        if (serializationCompleteEventHandler != null) {
                            try {
                                serializationCompleteEventHandler(this, EventArgs.Empty);
                            }
                            catch {}
                        }
                        
                        this.manager = null;
                        resolveNameEventHandler = null;
                        serializationCompleteEventHandler = null;
                        designerSerializationProviders = null;
                        instancesByName = null;
                        namesByInstance = null;
                        contextStack = null;
                        ((IContainer)this).Remove(this);
                        containerComponents = null;
                    }
                }
                
                // Now that we have made this pass, we can null out persister so
                // we will not re-enter here should someone call us again.
                //
                manager = null;
                rootSerializer = null;
            }
            
            // Now serialize all the stuff.
            //
            ArrayList objectsToSerialize = new ArrayList();
            
            if (code != null) {
                foreach(object obj in objects) {
                    if (!(obj is IComponent)) {
                        objectsToSerialize.Add(obj);
                    }
                }
            }
            
            info.AddValue(serializableObjects, objectsToSerialize);
            info.AddValue(componentCode, code);
            info.AddValue(componentResources,  resourceManager != null ? resourceManager.Data : null);
            info.AddValue(designTimeProps, designTimeProperties);
        }
        
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.IServiceProvider.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {

            if (serviceType == typeof(IResourceService)) {
                return this;
            }

            if (manager != null) return manager.GetService(serviceType);
            
            return null;
        }
    
        /// <include file='doc\DesignerSerializationObject.uex' path='docs/doc[@for="DesignerSerializationObject.SimpleSite"]/*' />
        /// <devdoc>
        ///     A simple site implementation we use to site components that are
        ///     not in the designer.
        /// </devdoc>
        private class SimpleSite : ISite, ITypeDescriptorFilterService {

            private ITypeDescriptorFilterService innerFilter;
            private DesignerSerializationObject container;
            private IComponent component;
            private string name;
            
            public SimpleSite(DesignerSerializationObject container, IComponent component, string name) {
                this.container = container;
                this.component = component;
                this.name = name;
            }
            
            public IComponent Component {
                get { 
                    return component;
                }
            }
        
            public IContainer Container {
                get {
                    return (IContainer)container;
                }
            }
        
            public bool DesignMode {
                get {
                    return true;
                }
            }
        
        	public string Name {
                get {
                    return name;
                }
                set {
                    name = value;
                }
            }
            
            public object GetService(Type t) {

                if (t == typeof(ITypeDescriptorFilterService)) {
                    if (innerFilter == null) {
                        innerFilter = (ITypeDescriptorFilterService)((IDesignerSerializationManager)container).GetService(t);
                        if (innerFilter == null) {
                            innerFilter = this;
                        }
                    }
                    return this;
                }
                return ((IDesignerSerializationManager)container).GetService(t);
                
            }

            bool ITypeDescriptorFilterService.FilterAttributes(IComponent component, IDictionary attributes) {
                if (innerFilter != this) {
                    return innerFilter.FilterAttributes(component, attributes);
                }
                return true;
            }
    
            bool ITypeDescriptorFilterService.FilterEvents(IComponent component, IDictionary events) {
                if (innerFilter != this) {
                    return innerFilter.FilterEvents(component, events);
                }
                return true;
            }
    
            bool ITypeDescriptorFilterService.FilterProperties(IComponent component, IDictionary properties) {
                if (innerFilter != this) {
                    innerFilter.FilterProperties(component, properties);
                }

                // we've got to filter out all the read only properties
                // because otherwise the serializer won't be able to set values on them
                //
                ArrayList replaceList = null;
                foreach (DictionaryEntry de in properties) {
                    PropertyDescriptor pd = (PropertyDescriptor)de.Value;
                    if (pd.IsReadOnly) {
                        if (replaceList == null) {
                            replaceList = new ArrayList();
                        }
                        replaceList.Add(TypeDescriptor.CreateProperty(pd.ComponentType, pd, ReadOnlyAttribute.No));
                    }
                }

                if (replaceList != null) {
                    foreach (PropertyDescriptor pd in replaceList) {
                        properties[pd.Name] = pd;
                    }
                }

                return false;
            }

        }


        /// <devdoc>
        /// Our private resource manager...it just pushes all the data into a hashtable
        //  and then we serialize the hashtable.  On deseriaization, the hashtable is rebuilt
        //  for us and we have all the data we saved out.
        // </doc>
        private class DsoResourceManager : ComponentResourceManager, IResourceWriter, IResourceReader {
            private Hashtable hashtable;

            public DsoResourceManager() {
            }

            public DsoResourceManager(Hashtable data) {
                this.hashtable = data;
            }

            internal IDictionary Data {
                get{
                    if (hashtable == null) {
                        hashtable = new Hashtable();
                    }
                    return hashtable;
                }
            }

            public void AddResource(string name, object value) {
                Data[name] = value;
            }

            public void AddResource(string name, string value) {
                Data[name] = value;
            }

            public void AddResource(string name, byte[] value) {
                Data[name] = value;
            }

            public void Close() {
            }

            public void Dispose() {
                Data.Clear();
            }

            public void Generate() {
            }

            public override object GetObject(string name) {
                return Data[name];
            }

            public override string GetString(string name) {
                return Data[name] as string;
            }

            public IDictionaryEnumerator GetEnumerator() {
                return Data.GetEnumerator();
            }

            /// <devdoc>
            ///     Override of GetResourceSet from ResourceManager.
            /// </devdoc>
            public override ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents) {
                return new DsoResourceSet(hashtable);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            } 

            private class DsoResourceSet : ResourceSet {
                public DsoResourceSet(Hashtable ht) {
                    Table = ht;
                }
            }
         }

        private class ResourceManagerCodeDomSerializer : CodeDomSerializer {
    
            CodeDomSerializer innerSerializer;
            DesignerSerializationObject owner;
    
            public ResourceManagerCodeDomSerializer(DesignerSerializationObject owner, CodeDomSerializer inner) {
                this.owner = owner;
                this.innerSerializer = inner;
            }
    
            public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
                
                object instance = null;
                // look for the creation statement.
                //
                foreach(CodeStatement element in (CodeStatementCollection)codeObject) {
                    if (element is CodeVariableDeclarationStatement) {
                        CodeVariableDeclarationStatement statement = (CodeVariableDeclarationStatement)element;
                        
                        // We create the resource manager ouselves here because it's not just a straight
                        // parse of the code.
                        //
                        instance = owner.resourceManager;
                        manager.SetName(instance, statement.Name);
                        codeObject = new CodeStatementCollection((CodeStatementCollection)codeObject);
                        ((CodeStatementCollection)codeObject).Remove(element);
                    }
                }
                innerSerializer.Deserialize(manager, codeObject);
                return instance;
            }

            public override object Serialize(IDesignerSerializationManager manager, object value) {
                return innerSerializer.Serialize(manager, value);
            }
        }
    }


    // Empty serializer... we never want any props or events gen'd for the container...
    //
    internal class DSOCodeDomSerializer : CodeDomSerializer {
        
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            return null;
        }
            
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            return new CodeStatementCollection();
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\service\helpservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Service {
    using System.Threading;
    

    using System.Diagnostics;

    using System;
    using System.Collections;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Shell;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService"]/*' />
    /// <devdoc>
    ///     The help service provides a way to provide the IDE help system with
    ///     contextual information for the current task.  The help system
    ///     evaluates all contextual information it gets and determines the
    ///     most likely topics to display to the user.
    /// </devdoc>

    internal class HelpService : IHelpService, IDisposable {

        private IServiceProvider   provider;
        private IVsUserContext           context;
        private bool                     notifySelection;
        
        private HelpService              parentService;
        private int                      cookie;
        private HelpContextType          priority;
        private ArrayList                subContextList;
        private bool                     needsRecreate;

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.HelpService"]/*' />
        /// <devdoc>
        ///     Creates a new help service object.
        /// </devdoc>
        public HelpService(IServiceProvider provider) {
            this.provider = provider;

            IDesignerHost host = (IDesignerHost)provider.GetService(typeof(IDesignerHost));
            if (host != null) {
                host.Activated += new EventHandler(this.OnDesignerActivate);
            }
        }
        
        private HelpService(HelpService parentService, IVsUserContext subContext, int cookie, IServiceProvider provider, HelpContextType priority) {
            this.context = subContext;
            this.provider = provider;
            this.cookie = cookie;
            this.parentService = parentService;
            this.priority = priority;
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.ClearContextAttributes"]/*' />
        /// <devdoc>
        ///     Clears all existing context attributes from the document.
        /// </devdoc>
        public virtual void ClearContextAttributes() {
            if (context != null) {
                context.RemoveAttribute(null,null);
                
                if (subContextList != null) {
                    foreach(object helpObj in subContextList) {
                        if (helpObj is IHelpService) {
                            ((IHelpService)helpObj).ClearContextAttributes();
                        }
                    }
                }
            }
            NotifyContextChange(context);
        }
        
        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.AddContextAttribute"]/*' />
        /// <devdoc>
        ///     Adds a context attribute to the document.  Context attributes are used
        ///     to provide context-sensitive help to users.  The designer host will
        ///     automatically add context attributes from available help attributes
        ///     on selected components and properties.  This method allows you to
        ///     further customize the context-sensitive help.
        /// </devdoc>
        public virtual void AddContextAttribute(string name, string value, HelpKeywordType keywordType) {

            if (provider == null) {
                return;
            }

            // First, get our context and update the attribute.
            //
            IVsUserContext cxt = GetUserContext();

            if (cxt != null) {

                tagVsUserContextAttributeUsage usage = tagVsUserContextAttributeUsage.VSUC_Usage_LookupF1;
                
                switch (keywordType) {
                    case HelpKeywordType.F1Keyword:
                        usage = tagVsUserContextAttributeUsage.VSUC_Usage_LookupF1;
                        break;
                    case HelpKeywordType.GeneralKeyword:
                        usage = tagVsUserContextAttributeUsage.VSUC_Usage_Lookup;
                        break;
                    case HelpKeywordType.FilterKeyword:
                        usage = tagVsUserContextAttributeUsage.VSUC_Usage_Filter;
                        break;
                }
                
                cxt.AddAttribute(usage, name, value);

                // Then notify the shell that it has been updated.
                //
                NotifyContextChange(cxt);
            }
        }
        
        
        public IHelpService CreateLocalContext(HelpContextType contextType) {
            IVsUserContext newContext = null;
            int cookie = 0;
            return CreateLocalContext(contextType, false, out newContext, out cookie);
        }
        
        private IHelpService CreateLocalContext(HelpContextType contextType, bool recreate, out IVsUserContext localContext, out int cookie) {
            cookie = 0;
            localContext = null;
            if (provider == null) {
                return null;
            }

            localContext = null;
            IVsMonitorUserContext muc = (IVsMonitorUserContext)provider.GetService(typeof(IVsMonitorUserContext));
         
            if (muc != null) {
                localContext = muc.CreateEmptyContext();
            }
         
            if (localContext != null) {
                int priority = 0;
                switch (contextType) {
                    case HelpContextType.ToolWindowSelection:
                        priority = tagVsUserContextPriority.VSUC_Priority_ToolWndSel;
                        break;
                    case HelpContextType.Selection:
                        priority = tagVsUserContextPriority.VSUC_Priority_Selection;
                        break;
                    case HelpContextType.Window:
                        priority = tagVsUserContextPriority.VSUC_Priority_Window;
                        break;
                    case HelpContextType.Ambient:
                        priority = tagVsUserContextPriority.VSUC_Priority_Ambient;
                        break;
                }
                
                cookie = GetUserContext().AddSubcontext(localContext, priority);
                
                if (cookie != 0) {
                    if (!recreate) {
                        HelpService newHs = new HelpService(this, localContext, cookie, provider, contextType);
                        if (subContextList == null) {
                            subContextList = new ArrayList();
                        }
                        subContextList.Add(newHs);
                        return newHs;
                    }
                }
            }
            return null;
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes this object.
        /// </devdoc>
        public virtual void Dispose() {

            if (subContextList != null && subContextList.Count > 0) {

                foreach (HelpService hs in subContextList) {
                    hs.parentService = null;
                    if (context != null) {
                        context.RemoveSubcontext(hs.cookie);
                    }
                    hs.Dispose();
                }
                subContextList = null;
            }
        
            if (parentService != null) {
                IHelpService parent = parentService;
                parentService = null;
                parent.RemoveLocalContext(this);
            }
            
            if (provider != null) {
                IDesignerHost host = (IDesignerHost)provider.GetService(typeof(IDesignerHost));
                if (host != null) {
                    host.Activated -= new EventHandler(this.OnDesignerActivate);
                }
                provider = null;
            }
            if (context != null) {
                System.Runtime.InteropServices.Marshal.ReleaseComObject(context);
                context = null;
            }
            this.cookie = 0;
        }
        
        ~HelpService() {
            Dispose();
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.GetUserContext"]/*' />
        /// <devdoc>
        ///     Retrieves a user context for us to add and remove attributes.  This
        ///     will demand create the context if it doesn't exist.
        /// </devdoc>
        private IVsUserContext GetUserContext() {

            // try to rebuild from a parent if possible.
            RecreateContext();
            
            // Create a new context if we don't have one.
            //
            if (context == null) {

                if (provider == null) {
                    return null;
                }
                
                
                IVsWindowFrame windowFrame = (IVsWindowFrame)provider.GetService(typeof(IVsWindowFrame));
               
                if (windowFrame != null) {
                    context = (IVsUserContext)windowFrame.GetProperty(__VSFPROPID.VSFPROPID_UserContext);
                }
               
                if (context == null) {
                   IVsMonitorUserContext muc = (IVsMonitorUserContext)provider.GetService(typeof(IVsMonitorUserContext));
                   if (muc != null) {
                       context = muc.CreateEmptyContext();
                       notifySelection = true;
                       Debug.Assert(context != null, "muc didn't create context");
                   }
                }
                
                if (subContextList != null && context != null) {
                   foreach(object helpObj in subContextList) {
                       if (helpObj is HelpService) {
                           ((HelpService)helpObj).RecreateContext();
                       }
                   }
                }
            }

            return context;
        }
        
        private void RecreateContext() {
            if (parentService != null && needsRecreate) {
                needsRecreate = false;
                if (this.context == null) {
                    parentService.CreateLocalContext(this.priority, true, out this.context, out this.cookie);
                }
                else {
                    int vsPriority = 0;
                    switch (priority) {
                       case HelpContextType.ToolWindowSelection:
                           vsPriority = tagVsUserContextPriority.VSUC_Priority_ToolWndSel;
                           break;
                       case HelpContextType.Selection:
                           vsPriority = tagVsUserContextPriority.VSUC_Priority_Selection;
                           break;
                       case HelpContextType.Window:
                           vsPriority = tagVsUserContextPriority.VSUC_Priority_Window;
                           break;
                       case HelpContextType.Ambient:
                           vsPriority = tagVsUserContextPriority.VSUC_Priority_Ambient;
                           break;
                    }
                    cookie = parentService.GetUserContext().AddSubcontext(GetUserContext(), vsPriority);
                }
            }
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.OnDesignerActivate"]/*' />
        /// <devdoc>
        ///     Called by the designer host when our document becomes active.  This will only fire
        ///     if we are being hosted by a document.
        /// </devdoc>
        private void OnDesignerActivate(object sender, EventArgs e) {
            if (context != null) {
                NotifyContextChange(context);
            }
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.NotifyContextChange"]/*' />
        /// <devdoc>
        ///     Called to notify the IDE that our user context has changed.
        /// </devdoc>
        private void NotifyContextChange(IVsUserContext cxt) {

            if (provider == null || !notifySelection) {
                return;
            }

            IVsTrackSelectionEx ts = (IVsTrackSelectionEx)provider.GetService(typeof(IVsTrackSelectionEx));

            if (ts != null) {
                Object obj = cxt;

                ts.OnElementValueChange(5 /* SEID_UserContext */, 0, obj);
            }
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.RemoveContextAttribute"]/*' />
        /// <devdoc>
        ///     Removes a previously added context attribute.
        /// </devdoc>
        public virtual void RemoveContextAttribute(string name, string value) {

            if (provider == null) {
                return;
            }

            // First, get our context and update the attribute.
            //
            IVsUserContext cxt = GetUserContext();

            if (cxt != null) {
                cxt.RemoveAttribute(name, value);
                NotifyContextChange(cxt);
            }
        }
        
        public void RemoveLocalContext(IHelpService localContext) {
            if (subContextList == null) {
                return;
            }
            
            int index = subContextList.IndexOf(localContext);
            if (index != -1) {
                subContextList.Remove(localContext);
                if (context != null) {
                    context.RemoveSubcontext(((HelpService)localContext).cookie);
                }
                ((HelpService)localContext).parentService = null;
            }
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.ShowHelpFromKeyword"]/*' />
        /// <devdoc>
        ///     Shows the help topic corresponding the specified keyword.
        ///     The topic will be displayed in
        ///     the environment's integrated help system.
        /// </devdoc>
        public virtual void ShowHelpFromKeyword(string helpKeyword) {
            IVsHelp help = (IVsHelp)provider.GetService(typeof(IVsHelp));

            if (help != null) {
                try {
                    help.DisplayTopicFromF1Keyword(helpKeyword);
                }
                catch (Exception) {
                    // IVsHelp causes a ComException to be thrown if the help
                    // topic isn't found.
                }
            }
        }

        /// <include file='doc\HelpService.uex' path='docs/doc[@for="HelpService.ShowHelpFromUrl"]/*' />
        /// <devdoc>
        ///     Shows the given help topic.  This should contain a Url to the help
        ///     topic.  The topic will be displayed in
        ///     the environment's integrated help system.
        /// </devdoc>
        public virtual void ShowHelpFromUrl(string helpUrl) {
            IVsHelp help = (IVsHelp)provider.GetService(typeof(IVsHelp));

            if (help != null) {
                try {
                    help.DisplayTopicFromURL(helpUrl);
                }
                catch (Exception) {
                    // IVsHelp causes a ComException to be thrown if the help
                    // topic isn't found.
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\service\propertyvalueuiservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyValueUIService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Service {

    using System.Diagnostics;
    
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    using System;

    /// <include file='doc\PropertyValueUIService.uex' path='docs/doc[@for="PropertyValueUIService"]/*' />
    /// <devdoc>
    /// This interface allows additional ui to be added to the properties window.  When a property
    /// is painted, the PropertyValueUIHandler items added to this service will be invoked
    /// and handlers can be added to them.  Each handler can add a small icon to the 
    /// property that will be painted at the right side of the "property name" column.  This icon
    /// can be clicked on to launch additional UI, etc.
    /// </devdoc>
    internal class PropertyValueUIService : IPropertyValueUIService {
         
         private PropertyValueUIHandler handler;
         private EventHandler           notifyHandler;
         private ArrayList             itemList = new ArrayList();
         
         
          /// <include file='doc\PropertyValueUIService.uex' path='docs/doc[@for="PropertyValueUIService.PropertyUIValueItemsChanged"]/*' />
          /// <devdoc>
         /// <para>
         ///  Adds or removes an <see cref='System.EventHandler'/> that will be invoked
         ///  when the global list of PropertyValueUIItems is modified.
         ///  </para>
         ///  </devdoc>
         public event EventHandler PropertyUIValueItemsChanged {
            add {
                notifyHandler += value;
            }
            remove {
                notifyHandler -= value;
            }
         }
         
         /// <include file='doc\PropertyValueUIService.uex' path='docs/doc[@for="PropertyValueUIService.AddPropertyValueUIHandler"]/*' />
         /// <devdoc>
         /// Adds a PropertyValueUIHandler to this service.  When GetPropertyUIValueItems is
         /// called, each handler added to this service will be called and given the opportunity
         /// to add an icon to the specified property.
         /// </devdoc>
         public void AddPropertyValueUIHandler(PropertyValueUIHandler newHandler) {
                handler = (PropertyValueUIHandler)Delegate.Combine(handler, newHandler);
         }
    
         
         /// <include file='doc\PropertyValueUIService.uex' path='docs/doc[@for="PropertyValueUIService.GetPropertyUIValueItems"]/*' />
         /// <devdoc>
         /// Gets all the PropertyValueUIItems that should be displayed on the given property.
         /// For each item returned, a glyph icon will be aded to the property.
         /// </devdoc>
         public PropertyValueUIItem[] GetPropertyUIValueItems(ITypeDescriptorContext context, PropertyDescriptor propDesc){
            
            if (handler == null) {
                return new PropertyValueUIItem[0];
            }
             
            lock(itemList) {
                itemList.Clear();
                handler.Invoke(context, propDesc, itemList);
                
    